{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Neuroglia Python Framework","text":"<p>This Python framework is a lightweight layer built on top of FastAPI. It offers developers a set of useful tools and features that can be applied to any microservice, no matter its specific purpose or domain. These features include:</p> <ul> <li>Adherence to 12-Factor App principles.</li> <li>Built-in MVC Web App structure: It provides a foundation for building web applications using the Model-View-Controller pattern, with essential abstractions.</li> <li>Simplified Dependency Injection: A straightforward mechanism for managing dependencies, including automatic discovery and instantiation of classes.</li> <li>Class-based API Controllers with Automatic Loading: Easily define API controllers using classes, with the framework automatically finding and loading them.</li> <li>Modular Command/Query Separation (CQRS): Supports a clear separation of commands (actions that change data) and queries (actions that retrieve data).</li> <li>Optional Event-Sourcing: Provides the option to implement event-sourcing for building event-driven domain models.</li> <li> <p>Clean, Layered Code: Encourages a clean architecture approach, similar to the principles outlined in [link to clean architecture article].</p> <ul> <li>Pure Domain Models: Allows you to define domain models that are independent of any specific persistence mechanism.</li> <li>Application Handlers: Provides a structure for handling commands, queries, events, and background tasks within your application logic.</li> <li>Repository Pattern Implementation: Includes support for the Repository pattern for abstracting data access.</li> <li>Separation of API and Domain: Keeps API controllers, endpoints, and data transfer objects (DTOs) separate from your core domain models and business logic.</li> </ul> </li> <li> <p>Native Asynchronous Event Handling with RxPy: Offers built-in support for handling, emitting, and ingesting asynchronous events (in JSON CloudEvent format) using the ReactiveX programming paradigm with RxPy.</p> </li> <li>Data Model Mapping: Provides tools for easily mapping data between your domain models and integration layers.</li> <li>Easy Background Task Scheduling: Integrates seamlessly with apscheduler for scheduling background tasks.</li> <li>And more...</li> </ul>"},{"location":"#code-structure","title":"Code Structure","text":""},{"location":"#entry-point","title":"Entry Point","text":"<p>The main entry point of your application is typically the <code>src/main.py</code> file (or <code>src/api/main.py</code>). This file is where you define all the necessary dependencies and specify the sub-folders where the framework should dynamically load your API, Application, Integration, and Domain Layers.</p>"},{"location":"#framework-conventions","title":"Framework Conventions","text":"<p>The <code>src</code> folder contains four distinct Layers:</p> <p></p> <ul> <li> <p>API Layer (Controllers): <code>uses the Application Layer</code></p> <ul> <li>Defines the endpoints available to external clients (incl. OpenAPI specs)</li> <li>Maps each endpoint to its corresponding Application handler.</li> <li>Maps external data (DTO's) models (API Requests and Responses schemas) to internal Domain layer</li> </ul> </li> <li> <p>Application Layer (Handlers and Services): <code>executes the main biz logic, uses the Domain and Integration Layers</code></p> </li> <li> <p>Integration Layer (Dependencies): <code>provides reusable independent logic (persistence Layer, API clients, external logic)</code></p> <ul> <li>Loads any external API client services, persistence layer clients, and their associated data models (API DTOs for requests and responses).</li> </ul> </li> </ul>"},{"location":"#-loads-the-logic-for-handling-commands-queries-events-tasks-and-any-other-business-logic-services","title":"- Loads the logic for handling commands, queries, events, tasks, and any other business logic services.","text":""},{"location":"#samples","title":"Samples","text":""},{"location":"#openbank","title":"OpenBank","text":"<p>Implements a simplified Bank that manages Accounts, Users and Transactions with full Event Sourcing, CQRS</p> <p>Explore OpenBank</p>"},{"location":"#desktop-controller","title":"Desktop Controller","text":"<p>Remotely and securely control custom files or commands on a Desktop running the app as a Docker container...</p> <p>Explore Desktop Controller</p>"},{"location":"#api-gateway","title":"API Gateway","text":"<p>Expose single entry point for 3rd party clients into an internal layer, like a GenAI stack... Models a Prompt entity, enforces a business logic (e.g. Prompt' state-machine), handles scheduled background task (with persistence), exposes API with multiple Security schemes, ...</p> <p>Explore API Gateway</p>"},{"location":"samples/api_gateway/","title":"API Gateway","text":"<p>TODO</p>"},{"location":"samples/desktop_controller/","title":"Desktop Controller","text":"<p>REST API to remotely control a Desktop (i.e. the Docker Host running the controller) over HTTP.</p> <p>The Controller must:</p> <ol> <li>Register itself periodically (via CloudEvent) to the Desktops Registry (providing its IP address as the identifier to the Registry)</li> <li>Securely expose a set of <code>Commands</code> and <code>Queries</code> via a REST API (with OpenAPI 3.x specs) that enable remote control for the Desktop's <code>HostInfo</code> and <code>UserInfo</code> (wrapping Linux Shell commands as HTTP Requests)</li> <li>Maintain various local files (e.g. <code>/data/hostinfo.json</code>, <code>/data/userinfo.json</code>) that other apps (on the Desktop VM) may rely upon (Screen Logger).</li> <li>Trigger remote execution of custom Shell scripts to be run on the Desktop VM (not the controller's container!)</li> </ol> <p>[[TOC]]</p>"},{"location":"samples/desktop_controller/#overview","title":"Overview","text":""},{"location":"samples/desktop_controller/#controllers-interactions","title":"Controller's Interactions","text":""},{"location":"samples/desktop_controller/#controllers-context","title":"Controller's Context","text":""},{"location":"samples/desktop_controller/#design","title":"Design","text":""},{"location":"samples/desktop_controller/#development","title":"Development","text":""},{"location":"samples/desktop_controller/#setup","title":"Setup","text":"<pre><code>\n# 0. Prerequisites:\n#    Have Python 3.12 installed\n# \n#    - Create/Activate a local python environment (e.g. with pyenv)\n#      pyenv virtualenv 3.12.2 desktop-controller\n#      pyenv activate desktop-controller\n# \n#    - Start Docker Desktop locally\n#\n# 1. Clone the repository\ncd ~/\n\ngit clone git@....\n\ncd desktop-controller\n\n# pip install pre-commit\npre-commit install\n\n# pip install poetry\npoetry lock &amp;&amp; poetry install \n\n# 2. Start the docker-compose stack\n# sudo apt-get install make\nmake up\n\n# 3. Connect the vscode debugger to the running container\n# From vscode: hit F5 (ensure that the \"Run and Debug\" launcher is set to \"Python: Remote Attach\")\n\n# 4. Open the SwaggerUI at http://localhost:9781/api/docs\n\n# 5. Add a Breakpoint, e.g. in api.controllers.userinfo_controller.py:29...\n\n# 6. Send a test request :)\n\n# 7. Enjoy live debugging on your local development\n</code></pre>"},{"location":"samples/desktop_controller/#code-contribution","title":"Code Contribution","text":"<ol> <li>Clone <code>main</code> branch</li> <li>Create new branch, e.g. <code>feat-cmd-userinfo</code> or <code>fix-linux-cmd</code></li> <li>Push the new branch to Gitlab and create a Merge Request into <code>main</code></li> <li>Document the review</li> <li>Approve and merge (may discard the branch if needed)</li> </ol>"},{"location":"samples/desktop_controller/#release-process","title":"Release Process","text":"<ol> <li>Refer to Semantic Versioning</li> <li>Create new Tag in Gitlab &gt; Repository &gt; Tags &gt; New Tag</li> <li>This will trigger Gitlab CI to publish a new container image based on the latest commit in the <code>main</code> branch and will be named as per the new Tag.</li> <li>Test the image locally: <code>docker run -p 8080:80 desktop-controller:latest</code> then browse to http://localhost:8080/api/docs</li> </ol>"},{"location":"samples/desktop_controller/#settings","title":"Settings","text":"<p>Required configuration:</p> <ul> <li>create new SSH key pair</li> <li>install the private key into the container and the public key into the DockerHost/SSH server</li> <li>mount the SSH private key to <code>:/app/id_rsa</code> when starting the container</li> <li>add the pub key to the DockerHost's <code>~/.ssh/authorized_keys</code></li> <li>add env var <code>DOCKER_HOST_USER_NAME</code> with the sys-admin' username on the DockerHost!</li> </ul> <p>See App Settings.</p>"},{"location":"samples/desktop_controller/#testing","title":"Testing","text":"<p>The API has a sample <code>Command</code> that ultimately resolves to remotely run <code>~/test_shell_script_on_host.sh -i {user_input}</code> on the DockerHost. </p> <p>See sample_bin/test_shell_script_on_host.sh.</p> <p>E.g.: Install with</p> <pre><code># copy the sample shell script on the Docker Host' user' home folder\ncp sample_bin/test_shell_script_on_host.sh ~/test_shell_script_on_host.sh\n\n# set permissions to execute\nchmod a+x ~/test_shell_script_on_host.sh\n\n# set ownership\nchown $USERNAME:staff ~/test_shell_script_on_host.sh\n\n# test run as user:\n~/test_shell_script_on_host.sh -i \"my input value\"\n\nAdding a new line my input value to /tmp/test.txt...\n\n# verify local file on Docker Host: \ncat /tmp/test.txt\n\nUserInput: my input value\n\n</code></pre>"},{"location":"samples/desktop_controller/#test_shell_script_on_hostsh","title":"test_shell_script_on_host.sh","text":"<p>See sample_bin/test_shell_script_on_host.sh.</p> <p>This test script just adds a line to a file <code>/tmp/test.txt</code>.</p> <pre><code>#!/bin/bash\n\n# test_shell_script_on_host.sh\n\nif [ $# -lt 2 ]; then\n  echo \"Error: Please provide an argument after the -i flag.\"\n  exit 1\nfi\n\nif [ \"$1\" != \"-i\" ]; then\n  echo \"Error: Please use the -i flag followed by your argument.\"\n  exit 1\nfi\n\nargument=\"$2\"\n\necho \"Adding a new line $argument to /tmp/test.txt...\"\n\necho \"UserInput: $argument\" &gt;&gt; /tmp/test.txt\n\n</code></pre>"},{"location":"samples/desktop_controller/#call-test-endpoint","title":"Call Test Endpoint","text":"<p>The HTTP <code>Command</code> runs a SSH client that simply connects to the DockerHost at <code>host.docker.internal</code> (with preconfigured username and SSH keys) and runs a custom command_line.</p> <p>From SwaggerUI</p> <p><code>http://localhost:9781/api/docs#/Custom/run_test_write_file_on_host_api_v1_custom_test_shell_script_on_host_sh_post</code></p> <p>From Curl: (will need <code>Authorization</code> header with JWT, see API Auth)</p> <pre><code>curl -X 'POST' \\\n  'http://localhost:9781/api/v1/custom/test/shell_script_on_host.sh' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n  \"user_input\": \"my input value\"\n}'\n</code></pre> <pre><code># 201   Response body\n{\n  \"command_line\": \"~/test_shell_script_on_host.sh -i my_input_value\",\n  \"stdout\": [\n    \"Adding a new line my_input_value to /tmp/test.txt...\"\n  ],\n  \"stderr\": [],\n  \"aggregate_id\": \"4c660c0572d8449598ee5fde58e04423\",\n  \"success\": true\n}\n</code></pre>"},{"location":"samples/desktop_controller/#api-authentication","title":"API Authentication","text":"<p>We're using Keycloak as the IDP. See <code>deployment/keycloak/realm-config.json</code> for sample keycloak config.</p> <p>The intent is that \"whoever\" wants to remotely control a desktop first needs to get a valid token from the common Keycloak instance (which is the one that the VDI/BYOD Desktops - ie. DockerHosts have access to!).</p> <p>Local testings can be done with a local/dev Keycloak instance. Just include it in <code>docker-compose.yml</code>!</p> <pre><code>version: \"3.4\"\n\nname: mozart-dev\nservices:\n  # http://localhost:9780\n  keycloak97:\n    image: jboss/keycloak\n    environment:\n      - KEYCLOAK_USER=admin\n      - KEYCLOAK_PASSWORD=admin\n      - KEYCLOAK_IMPORT=/tmp/realm-export.json\n    volumes:\n      - ./deployment/keycloak/realm-config.json:/tmp/realm-export.json\n    ports:\n      - 9780:8080\n    networks:\n      - desktopcontrollernet\n</code></pre> <p>Login at http://localhost:9780 using <code>admin</code>:<code>admin</code></p>"},{"location":"samples/desktop_controller/#source-code","title":"Source Code","text":""},{"location":"samples/desktop_controller/#context","title":"Context","text":""},{"location":"samples/desktop_controller/#containers","title":"Containers","text":""},{"location":"samples/desktop_controller/#components","title":"Components","text":""},{"location":"samples/desktop_controller/#code","title":"Code","text":""},{"location":"samples/desktop_controller/#app-settings","title":"App Settings","text":"<pre><code>    environment:\n      APP_TITLE: Remote Desktop Controller\n      LOCAL_DEV: true\n      LOG_LEVEL: DEBUG\n\n      CLOUD_EVENT_SINK: http://event-player97/events/pub\n      CLOUD_EVENT_SOURCE: https://desktop-controller.domain.com\n      CLOUD_EVENT_TYPE_PREFIX: com.domain.desktop-controller\n\n      OAUTH2_SCHEME: client_credentials  # authorization_code or client_credentials\n      JWT_AUTHORITY: http://keycloak97/auth/realms/mozart\n      JWT_SIGNING_KEY: MIIBIj...copy_from_keycloak...elJ3dvQIDAQAB\n      JWT_AUDIENCE: desktops\n      REQUIRED_SCOPE: api\n\n      SWAGGER_UI_JWT_AUTHORITY: http://localhost:9780/auth/realms/mozart\n      SWAGGER_UI_CLIENT_ID: desktop-controller\n      SWAGGER_UI_CLIENT_SECRET: 6Wbr0V1TtgEUPUCRSqHh1T0vYuVyG0aa\n\n      USER_INFO_FILE_NAME: '/tmp/userinfo.json'\n      HOST_INFO_FILE_NAME: '/tmp/hostinfo.json'\n      DOCKER_HOST_USER_NAME: bvandewe  # UPDATE TO YOUR LOCAL USERNAME!\n      DOCKER_HOST_HOST_NAME: host.docker.internal\n\n</code></pre> <p>Set corresponding <code>ENV VARS</code> in <code>docker-compose.yml</code>.</p> <p>Pydantic settings automatically parses environment variables, see ./src/api/settings.py.</p> <pre><code># ./src/api/settings.py\n\nfrom neuroglia.hosting.abstractions import ApplicationSettings\nfrom pydantic import ConfigDict\n\n\nclass DesktopControllerSettings(ApplicationSettings):\n    model_config = ConfigDict(extra=\"allow\")\n\n    required_scopes: str\n    jwt_authority: str\n    jwt_signing_key: str\n    jwt_audience: str = \"desktops\"\n    docker_host_user_name: str = \"sys-admin\"\n    userinfo_filename: str = \"/app/data/userinfo.json\"\n    ...\n\napp_settings = DesktopControllerSettings(_env_file=\".env\")\n\n</code></pre>"},{"location":"samples/desktop_controller/#app-bootup","title":"App Bootup","text":"<p>The <code>main.py</code> file pre-loads all required services using the Dependency Injection mechanism from the neuroglia framework.</p> <p>API Controllers and Application Handlers may then declare any dependencies in their constructor (<code>def __init__(self, my_dependency: RegisteredDependency)</code>) and the framework will provide the instance!</p> <p>See Dependency Injection.</p> <pre><code># ./src/main.py\n...\nbuilder = WebApplicationBuilder()\n\n# required shared resources\nMapper.configure(builder, application_modules)\nMediator.configure(builder, application_modules)\nJsonSerializer.configure(builder)\nCloudEventIngestor.configure(builder, application_modules)\nCloudEventPublisher.configure(builder)\n\n# custom shared resources\n# \n# ADD ANY REQUIRED RESOURCE\nbuilder.services.add_scoped(paramiko.SSHClient, paramiko.SSHClient)\nbuilder.services.add_scoped(SecuredDockerHost, SecuredDockerHost)\nbuilder.services.add_singleton(DockerHostSshClientSettings, singleton=DockerHostSshClientSettings(username=builder.settings.docker_host_user_name))\nbuilder.services.add_scoped(DockerHostCommandRunner, DockerHostCommandRunner)\n\n# app\napp = builder.build()\n...\napp.run()\n</code></pre>"},{"location":"samples/desktop_controller/#dependency-injection","title":"Dependency Injection","text":"<ol> <li>Add a Custom Service source code file (likely in any of the <code>application_modules</code> folder in <code>./src/api/controllers</code> or <code>./src/application/commands</code> or <code>./src/application/queries</code> or <code>./src/application/events</code>) that requires a <code>Dependency</code>:</li> </ol> <p>```python   # ./src/application/services/docker_host_command_runner.py   ...   class DockerHostCommandRunner:       def init(self, secured_docker_host: SecuredDockerHost):  # Declare Dependencies!           self.secured_docker_host = secured_docker_host</p> <pre><code>  secured_docker_host: SecuredDockerHost  # Injected when handling a Command!\n\n  async def run(self, command: HostCommand) -&gt; dict[str, Any]:\n      data = {}\n      await self.secured_docker_host.connect()\n      stdout, stderr = await self.secured_docker_host.execute_command(command)\n      await self.secured_docker_host.close()\n      stdout_lines = [line.strip() for line in stdout.splitlines() if line.strip()]\n      data = {\"command_line\": command.line, \"stdout\": stdout_lines, \"stderr\": stderr.splitlines() if stderr else []}\n      return data\n</code></pre> <p>...   ```</p> <ol> <li>Add the source code for the dependency itself (likely in <code>./src/integration/services</code>!). It may also include other dependencies! (e.g. <code>DockerHostSshClientSettings</code>!!)</li> </ol> <p>```python   # ./src/integration/services/secured_docker_host.py   ...</p> <p>class DockerHostSshClientSettings(BaseModel):       username: str       hostname: str = \"host.docker.internal\"       port: int = 22       private_key_filename: str = \"/app/id_rsa\"   ...   class SecuredDockerHost:       \"\"\"Service that Securely provides access to the Docker Host's Shell via SSH.\"\"\"</p> <pre><code>  def __init__(self, ssh_client: paramiko.SSHClient, ssh_client_settings: DockerHostSshClientSettings):\n      self.hostname: str = ssh_client_settings.hostname\n      self.port: int = ssh_client_settings.port\n      self.username: str = ssh_client_settings.username\n      self.private_key_filename: str = ssh_client_settings.private_key_filename\n      self.ssh_client: paramiko.SSHClient = ssh_client\n      self.ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n\n  async def connect(self):\n      ...\n\n  async def execute_command(self, command: HostCommand):\n      async def run_command(command_line: str):\n          ...\n\n      stdout, stderr = await run_command(command.line)\n      return stdout.decode(), stderr.decode()\n\n  async def close(self):\n      ...\n</code></pre> <p>```</p> <ol> <li>Register its service_type (<code>singleton</code>, <code>scoped</code>, <code>transient</code>) in the <code>main.py</code> bootup script</li> </ol> <p><code>python   # ./src/main.py   ...   builder.services.add_scoped(paramiko.SSHClient, paramiko.SSHClient)   builder.services.add_scoped(SecuredDockerHost, SecuredDockerHost)   builder.services.add_singleton(DockerHostSshClientSettings, singleton=DockerHostSshClientSettings(username=builder.settings.docker_host_user_name))   builder.services.add_scoped(DockerHostCommandRunner, DockerHostCommandRunner)   ...</code></p> <ol> <li>Declare it as a dependency in a consumer Service, e.g. Application's <code>CommandHandler</code>: </li> </ol> <p>Note how the <code>DockerHostCommandRunner</code> is just declared as a dependency in the constructor function <code>__init__</code>! This is the same for the other dependencies (<code>CloudEventBus</code>, <code>CloudEventPublishingOptions</code>)</p> <p>```python</p> <p>@map_from(TestHostScriptCommandDto)   @map_to(TestHostScriptCommandDto)   @dataclass   class TestHostScriptCommand(Command):       user_input: str</p> <p>class TestHostScriptCommandsHandler(CommandHandler[TestHostScriptCommand, OperationResult[Any]]):       \"\"\"Represents the service used to handle UserInfo-related Commands\"\"\"</p> <pre><code>  cloud_event_bus: CloudEventBus\n  \"\"\" Gets the service used to observe the cloud events consumed and produced by the application \"\"\"\n\n  cloud_event_publishing_options: CloudEventPublishingOptions\n  \"\"\" Gets the options used to configure how the application should publish cloud events \"\"\"\n\n  docker_host_command_runner: DockerHostCommandRunner\n\n  def __init__(self, cloud_event_bus: CloudEventBus, cloud_event_publishing_options: CloudEventPublishingOptions, docker_host_command_runner: DockerHostCommandRunner):\n      self.cloud_event_bus = cloud_event_bus\n      self.cloud_event_publishing_options = cloud_event_publishing_options\n      self.docker_host_command_runner = docker_host_command_runner\n\n  async def handle_async(self, command: TestHostScriptCommand) -&gt; OperationResult[Any]:\n      command_id = str(uuid.uuid4()).replace(\"-\", \"\")\n      command_line = HostCommand()\n      data = {}\n      try:\n          line = f\"~/test_shell_script_on_host.sh -i {command.user_input.replace(' ', '_')}\"\n          log.debug(f\"TestHostScriptCommand Line: {line}\")\n          await self.publish_cloud_event_async(DesktopHostCommandReceivedIntegrationEventV1(aggregate_id=command_id, command_line=line))\n\n          command_line.line = line\n          data = await self.docker_host_command_runner.run(command_line)\n          data.update({\"aggregate_id\": command_id})\n          log.debug(f\"TestHostScriptCommand: {data}\")\n\n          await self.publish_cloud_event_async(DesktopHostCommandExecutedIntegrationEventV1(**data))\n          data.update({\"success\": True}) if len(data[\"stderr\"]) == 0 else data.update({\"success\": False})\n          return self.created(data)\n\n      except Exception as ex:\n          return self.bad_request(f\"Exception when trying to run a shell script on the host: {command_line.line}: {data}: {ex}\")\n</code></pre> <p>```</p>"},{"location":"samples/desktop_controller/#api-controllers","title":"API Controllers","text":"<ul> <li>inherits ControllerBase</li> </ul> <pre><code># ./src/api/controllers/host_controller.py\n\nclass HostController(ControllerBase):\n    def __init__(self, service_provider: ServiceProviderBase, mapper: Mapper, mediator: Mediator):\n        ControllerBase.__init__(self, service_provider, mapper, mediator)\n\n    @post(\"/info\", response_model=Any, status_code=201, responses=ControllerBase.error_responses)\n    async def set_host_info(self, command_dto: SetHostInfoCommandDto, token: str = Depends(validate_token)) -&gt; Any:\n        \"\"\"Sets data of the hostinfo.json file.\"\"\"\n        log.debug(f\"set_host_info: command_dto:{command_dto}, token={token}\")\n        return self.process(await self.mediator.execute_async(self.mapper.map(command_dto, SetHostInfoCommand)))\n\n    @get(\"/info\", response_model=Any, status_code=201, responses=ControllerBase.error_responses)\n    async def get_host_info(self):\n        query = ReadHostInfoQuery()\n        log.debug(f\"get_host_info: query:{query}\")\n        return self.process(await self.mediator.execute_async(query))\n\n</code></pre>"},{"location":"samples/open_bank/","title":"OpenBank","text":"<p>See samples/openbank...</p>"}]}