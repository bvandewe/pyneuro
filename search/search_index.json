{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83e\udde0 Neuroglia Python Framework","text":"<p>Keywords: Python microservices, FastAPI framework, clean architecture Python, CQRS Python, domain-driven design Python, event-driven architecture, dependency injection Python, microservices patterns</p> <p>A lightweight, opinionated Python framework built on FastAPI that enforces clean architecture principles and provides comprehensive tooling for building production-ready microservices.</p>"},{"location":"#perfect-for","title":"\ud83c\udfaf Perfect For","text":"<ul> <li>Microservices: Clean architecture for scalable service development</li> <li>Event-Driven Systems: Built-in CloudEvents and domain event support</li> <li>API Development: FastAPI-based with automatic OpenAPI documentation</li> <li>Domain-Driven Design: Enforce DDD patterns and bounded contexts</li> <li>Clean Code: Opinionated structure that promotes maintainable code</li> </ul>"},{"location":"#whats-included","title":"\ud83d\ude80 What's Included","text":""},{"location":"#framework-core","title":"\ud83c\udfd7\ufe0f Framework Core","text":"<p>Clean architecture patterns with dependency injection, CQRS, event-driven design, and comprehensive testing utilities.</p>"},{"location":"#real-world-samples","title":"\ud83c\udf55 Real-World Samples","text":"<p>Complete production examples like Mario's Pizzeria demonstrating every framework feature in realistic business scenarios.</p>"},{"location":"#comprehensive-documentation","title":"\ud83d\udcda Comprehensive Documentation","text":"<ul> <li>9-Part Tutorial Series - Step-by-step hands-on learning</li> <li>Core Concepts Guide - Architectural pattern explanations</li> <li>Pattern Documentation - Includes \"Common Mistakes\" and \"When NOT to Use\"</li> <li>Complete Case Study - From business analysis to production deployment</li> </ul>"},{"location":"#cli-tooling","title":"\u2699\ufe0f CLI Tooling","text":"<p>PyNeuroctl command-line interface for managing, testing, and deploying your applications with zero configuration.</p>"},{"location":"#why-neuroglia","title":"Why Neuroglia?","text":"<p>Choose Neuroglia for complex, domain-driven microservices that need to be maintained for years to come.</p>"},{"location":"#the-philosophy","title":"\ud83c\udfaf The Philosophy","text":"<p>Neuroglia believes that software architecture matters more than speed of initial development. While you can build APIs quickly with vanilla FastAPI or Django, Neuroglia is designed for applications that will:</p> <ul> <li>Scale in complexity over time with changing business requirements</li> <li>Be maintained by teams with varying levels of domain expertise</li> <li>Evolve and adapt without accumulating technical debt</li> <li>Integrate seamlessly with complex enterprise ecosystems</li> </ul>"},{"location":"#when-to-choose-neuroglia","title":"\ud83c\udfd7\ufe0f When to Choose Neuroglia","text":"Choose Neuroglia When Choose Alternatives When \u2705 Building domain-rich applications with complex business logic \u274c Creating simple CRUD APIs or prototypes \u2705 Long-term maintenance is a primary concern \u274c You need something working \"yesterday\" \u2705 Your team values architectural consistency \u274c Framework learning curve is a blocker \u2705 You need enterprise patterns (CQRS, DDD, Event Sourcing) \u274c Simple request-response patterns suffice \u2705 Multiple developers will work on the codebase \u274c Solo development or small, simple projects \u2705 Integration with event-driven architectures \u274c Monolithic, database-first applications"},{"location":"#the-neuroglia-advantage","title":"\ud83d\ude80 The Neuroglia Advantage","text":"<p>Compared to vanilla FastAPI:</p> <ul> <li>Enforced Structure: No more \"how should I organize this?\" - clear architectural layers</li> <li>Built-in Patterns: CQRS, dependency injection, and event handling out of the box</li> <li>Enterprise Ready: Designed for complex domains, not just API endpoints</li> </ul> <p>Compared to Django:</p> <ul> <li>Microservice Native: Built for distributed systems, not monolithic web apps</li> <li>Domain-Driven: Business logic lives in the domain layer, not mixed with web concerns</li> <li>Modern Async: Full async support without retrofitting legacy patterns</li> </ul> <p>Compared to Spring Boot (Java):</p> <ul> <li>Python Simplicity: All the enterprise patterns without Java's verbosity</li> <li>Lightweight: No heavy application server - just the patterns you need</li> <li>Developer Experience: Pythonic APIs with comprehensive tooling</li> </ul>"},{"location":"#real-world-scenarios","title":"\ud83d\udca1 Real-World Scenarios","text":"<p>Perfect for:</p> <ul> <li>\ud83c\udfe6 Financial Services: Complex domain rules, audit trails, event sourcing</li> <li>\ud83c\udfe5 Healthcare Systems: HIPAA compliance, complex workflows, integration needs</li> <li>\ud83c\udfed Manufacturing: Resource management, real-time monitoring, process orchestration</li> <li>\ud83d\uded2 E-commerce Platforms: Order processing, inventory management, payment flows</li> <li>\ud83c\udfaf SaaS Products: Multi-tenant architectures, feature flags, usage analytics</li> </ul> <p>Not ideal for:</p> <ul> <li>\ud83d\udcdd Simple content management systems</li> <li>\ud83d\udd17 Basic API proxies or data transformation services</li> <li>\ud83d\udcf1 Mobile app backends with minimal business logic</li> <li>\ud83e\uddea Proof-of-concept or throwaway prototypes</li> </ul>"},{"location":"#the-developer-experience","title":"\ud83c\udfa8 The Developer Experience","text":"<p>Neuroglia optimizes for code that tells a story:</p> <pre><code># Your business logic is clear and testable\nclass PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        # Domain logic is explicit and isolated\n        order = Order(command.customer_id, command.items)\n        await self.repository.save_async(order)\n        return self.created(self.mapper.map(order, OrderDto))\n\n# Infrastructure concerns are separated\nclass OrdersController(ControllerBase):\n    @post(\"/orders\", response_model=OrderDto)\n    async def place_order(self, command: PlaceOrderCommand) -&gt; OrderDto:\n        return await self.mediator.execute_async(command)\n</code></pre> <p>The result? Code that's easy to understand, test, and evolve - even years later.</p>"},{"location":"#key-features","title":"\ud83d\ude80 Key Features","text":"<ul> <li>\ud83c\udfd7\ufe0f Clean Architecture: Enforces separation of concerns with clearly defined layers (API, Application, Domain, Integration)</li> <li>\ud83d\udc89 Dependency Injection: Lightweight container with automatic service discovery and registration</li> <li>\ud83c\udfaf CQRS &amp; Mediation: Command Query Responsibility Segregation with built-in mediator pattern</li> <li>\ud83c\udfdb\ufe0f State-Based Persistence: Alternative to event sourcing with automatic domain event dispatching</li> <li>\ud83d\udd27 Pipeline Behaviors: Cross-cutting concerns like validation, caching, and transactions</li> <li>\ud83d\udce1 Event-Driven Architecture: Native support for CloudEvents, event sourcing, and reactive programming</li> <li>\ud83c\udfaf Resource Oriented Architecture: Declarative resource management with watchers, controllers, and reconciliation loops</li> <li>\ud83d\udd0c MVC Controllers: Class-based API controllers with automatic discovery and OpenAPI generation</li> <li>\ud83d\uddc4\ufe0f Repository Pattern: Flexible data access layer with support for MongoDB, Event Store, and in-memory repositories</li> <li>\ud83d\udcca Object Mapping: Bidirectional mapping between domain models and DTOs</li> <li>\u26a1 Reactive Programming: Built-in support for RxPy and asynchronous event handling</li> <li>\ud83d\udd27 12-Factor Compliance: Implements all 12-Factor App principles</li> <li>\ud83d\udcdd Rich Serialization: JSON serialization with advanced features</li> </ul>"},{"location":"#architecture-overview","title":"\ud83c\udfaf Architecture Overview","text":"<p>Neuroglia promotes a clean, layered architecture that separates concerns and makes your code more maintainable:</p> <pre><code>src/\n\u251c\u2500\u2500 api/           # \ud83c\udf10 API Layer (Controllers, DTOs, Routes)\n\u251c\u2500\u2500 application/   # \ud83d\udcbc Application Layer (Commands, Queries, Handlers, Services)\n\u251c\u2500\u2500 domain/        # \ud83c\udfdb\ufe0f Domain Layer (Entities, Value Objects, Business Rules)\n\u2514\u2500\u2500 integration/   # \ud83d\udd0c Integration Layer (External APIs, Repositories, Infrastructure)\n</code></pre>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"<p>Coming soon: Get started with Neuroglia in minutes:</p> <pre><code># Install the framework\npip install neuroglia\n\n# Create your first app\npyneuroctl new myapp --template minimal\ncd myapp\n\n# Run the application\npython main.py\n</code></pre> <p>Visit <code>http://localhost:8000/docs</code> to explore the auto-generated API documentation.</p>"},{"location":"#learn-more","title":"\ud83d\udcda Learn More","text":""},{"location":"#learning-paths","title":"\ud83c\udf93 Learning Paths","text":"<p>New to the Framework?</p> <ol> <li>Start with Getting Started - Build your first app in 30 minutes</li> <li>Follow the 9-Part Tutorial Series - Comprehensive hands-on guide</li> <li>Study Core Concepts - Understand the architectural patterns</li> </ol> <p>Ready to Build?</p> <ol> <li>Explore Mario's Pizzeria Case Study - Complete real-world example</li> <li>Review Architectural Patterns - Design patterns with anti-patterns to avoid</li> <li>Browse Framework Features - Detailed feature documentation</li> </ol> <p>Need Help?</p> <ol> <li>Check Guides &amp; How-Tos - Practical procedures and troubleshooting</li> <li>See Sample Applications - More complete working examples</li> <li>Consult Reference Documentation - Technical specifications</li> </ol>"},{"location":"#quick-links","title":"\ud83d\udcd6 Quick Links","text":"<ul> <li>Tutorials - Step-by-step learning with the 9-part Mario's Pizzeria tutorial</li> <li>Core Concepts - Understand Clean Architecture, DDD, CQRS, and more</li> <li>Mario's Pizzeria - Complete case study with business analysis and implementation</li> <li>Patterns - Architectural patterns with \"What &amp; Why\" and \"Common Mistakes\"</li> <li>Features - Framework capabilities and how to use them</li> <li>Guides - Practical how-to procedures</li> <li>Samples - Working code examples (OpenBank, API Gateway, Desktop Controller)</li> </ul>"},{"location":"#reference-documentation","title":"\ud83d\udcd6 Reference Documentation","text":"<ul> <li>OAuth, OIDC &amp; JWT - Authentication and authorization patterns</li> <li>12-Factor App Compliance - Cloud-native application standards</li> <li>Source Code Naming Conventions - Maintainable code patterns</li> <li>Python Typing Guide - Type hints, generics, and advanced typing</li> </ul> <p>Neuroglia Python Framework - Building better software through better architecture \ud83e\udde0\u2728</p>"},{"location":"ai-agent-guide/","title":"\ud83e\udd16 AI Agent Quick Reference Guide","text":"<p>Fast-track guide for AI agents to understand and work with the Neuroglia Python Framework</p>"},{"location":"ai-agent-guide/#framework-overview","title":"\ud83c\udfaf Framework Overview","text":"<p>Neuroglia is a clean architecture Python framework built on FastAPI that enforces separation of concerns, CQRS, dependency injection, and event-driven patterns for maintainable microservices.</p>"},{"location":"ai-agent-guide/#core-architecture","title":"\ud83c\udfd7\ufe0f Core Architecture","text":"<pre><code>src/\n\u251c\u2500\u2500 api/           # \ud83c\udf10 Controllers, DTOs, Routes (FastAPI)\n\u251c\u2500\u2500 application/   # \ud83d\udcbc Commands, Queries, Handlers, Services\n\u251c\u2500\u2500 domain/        # \ud83c\udfdb\ufe0f Entities, Value Objects, Business Rules\n\u2514\u2500\u2500 integration/   # \ud83d\udd0c Repositories, External APIs, Infrastructure\n</code></pre> <p>Dependency Rule: <code>API \u2192 Application \u2192 Domain \u2190 Integration</code></p>"},{"location":"ai-agent-guide/#quick-start-patterns","title":"\u26a1 Quick Start Patterns","text":""},{"location":"ai-agent-guide/#1-cqrs-commandquery-pattern","title":"1. CQRS Command/Query Pattern","text":"<pre><code># Commands (Write operations)\n@dataclass\nclass CreateOrderCommand(Command[Order]):\n    customer_id: str\n    items: List[OrderItemDto]\n\nclass CreateOrderHandler(CommandHandler[CreateOrderCommand, Order]):\n    async def handle_async(self, command: CreateOrderCommand) -&gt; Order:\n        # Business logic here\n        return order\n\n# Queries (Read operations)\n@dataclass\nclass GetOrderQuery(Query[Optional[Order]]):\n    order_id: str\n\nclass GetOrderHandler(QueryHandler[GetOrderQuery, Optional[Order]]):\n    async def handle_async(self, query: GetOrderQuery) -&gt; Optional[Order]:\n        return await self.repository.get_by_id_async(query.order_id)\n</code></pre>"},{"location":"ai-agent-guide/#2-api-controllers-fastapi-integration","title":"2. API Controllers (FastAPI Integration)","text":"<pre><code>from neuroglia.mvc import ControllerBase\nfrom classy_fastapi.decorators import get, post\n\nclass OrdersController(ControllerBase):\n    @post(\"/\", response_model=OrderDto, status_code=201)\n    async def create_order(self, dto: CreateOrderDto) -&gt; OrderDto:\n        command = self.mapper.map(dto, CreateOrderCommand)\n        order = await self.mediator.execute_async(command)\n        return self.mapper.map(order, OrderDto)\n\n    @get(\"/{order_id}\", response_model=OrderDto)\n    async def get_order(self, order_id: str) -&gt; OrderDto:\n        query = GetOrderQuery(order_id=order_id)\n        order = await self.mediator.execute_async(query)\n        return self.mapper.map(order, OrderDto)\n</code></pre>"},{"location":"ai-agent-guide/#3-repository-pattern","title":"3. Repository Pattern","text":"<pre><code># Abstract repository\nclass OrderRepository(Repository[Order, str]):\n    async def get_by_customer_async(self, customer_id: str) -&gt; List[Order]:\n        pass\n\n# MongoDB implementation\nclass MongoOrderRepository(MongoRepository[Order, str]):\n    async def get_by_customer_async(self, customer_id: str) -&gt; List[Order]:\n        cursor = self.collection.find({\"customer_id\": customer_id})\n        return [self._to_entity(doc) async for doc in cursor]\n</code></pre>"},{"location":"ai-agent-guide/#4-dependency-injection-application-setup","title":"4. Dependency Injection &amp; Application Setup","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\n\ndef create_app():\n    builder = WebApplicationBuilder()\n    services = builder.services\n\n    # Register services\n    services.add_scoped(OrderRepository, MongoOrderRepository)\n    services.add_mediator()  # Auto-discovers handlers\n    services.add_controllers([\"api.controllers\"])\n    services.add_object_mapping()\n\n    app = builder.build()\n    app.use_controllers()\n    return app\n</code></pre>"},{"location":"ai-agent-guide/#framework-modules-reference","title":"\ud83e\udde9 Framework Modules Reference","text":"Module Purpose Key Classes <code>neuroglia.core</code> Base types, utilities <code>OperationResult</code>, <code>Entity</code>, <code>ValueObject</code> <code>neuroglia.dependency_injection</code> DI container <code>ServiceCollection</code>, <code>ServiceProvider</code>, <code>ServiceLifetime</code> <code>neuroglia.mediation</code> CQRS patterns <code>Mediator</code>, <code>Command</code>, <code>Query</code>, <code>CommandHandler</code>, <code>QueryHandler</code> <code>neuroglia.mvc</code> FastAPI controllers <code>ControllerBase</code>, auto-discovery <code>neuroglia.data</code> Repository &amp; persistence <code>Repository</code>, <code>MongoRepository</code>, <code>InMemoryRepository</code>, <code>EventStore</code> <code>neuroglia.data.resources</code> Resource management <code>ResourceController</code>, <code>ResourceWatcher</code>, <code>Reconciler</code> <code>neuroglia.eventing</code> Event handling <code>DomainEvent</code>, <code>EventHandler</code>, <code>EventBus</code> <code>neuroglia.eventing.cloud_events</code> CloudEvents integration <code>CloudEvent</code>, <code>CloudEventPublisher</code>, <code>CloudEventIngestor</code> <code>neuroglia.mapping</code> Object mapping <code>Mapper</code>, convention-based mapping <code>neuroglia.hosting</code> App lifecycle <code>WebApplicationBuilder</code>, <code>WebApplication</code>, <code>HostedService</code> <code>neuroglia.serialization</code> JSON/data serialization <code>JsonSerializer</code>, <code>JsonEncoder</code>, <code>TypeRegistry</code> <code>neuroglia.validation</code> Business rule validation <code>BusinessRule</code>, <code>ValidationResult</code>, <code>PropertyValidator</code>, <code>EntityValidator</code> <code>neuroglia.reactive</code> Reactive programming <code>Observable</code>, <code>Observer</code> (RxPy integration) <code>neuroglia.integration</code> External services <code>HttpServiceClient</code>, <code>CacheRepository</code>, <code>BackgroundTaskScheduler</code> <code>neuroglia.utils</code> Utility functions <code>CaseConversion</code>, <code>CamelModel</code>, <code>TypeFinder</code> <code>neuroglia.expressions</code> Expression evaluation <code>JavaScriptExpressionTranslator</code> <code>neuroglia.logging</code> Enhanced logging Structured logging, correlation IDs, performance monitoring"},{"location":"ai-agent-guide/#sample-applications","title":"\ud83d\udcc1 Sample Applications","text":"<p>The framework includes complete sample applications that demonstrate real-world usage:</p>"},{"location":"ai-agent-guide/#marios-pizzeria-samplesmario-pizzeria","title":"\ud83c\udf55 Mario's Pizzeria (<code>samples/mario-pizzeria/</code>)","text":"<ul> <li>Full CQRS implementation with sophisticated domain models</li> <li>MongoDB repositories for orders, customers, pizzas</li> <li>Event-driven architecture with domain events</li> <li>Complete API with OpenAPI documentation</li> </ul> <p>Key Files:</p> <ul> <li><code>domain/entities/</code>: <code>Order</code>, <code>Pizza</code>, <code>Customer</code> with business logic</li> <li><code>application/commands/</code>: <code>PlaceOrderCommand</code>, <code>CreatePizzaCommand</code></li> <li><code>application/queries/</code>: <code>GetOrderByIdQuery</code>, <code>GetMenuItemsQuery</code></li> <li><code>api/controllers/</code>: <code>OrdersController</code>, <code>MenuController</code></li> </ul>"},{"location":"ai-agent-guide/#openbank-samplesopenbank","title":"\ud83c\udfe6 OpenBank (<code>samples/openbank/</code>)","text":"<ul> <li>Event sourcing with EventStore</li> <li>Complex domain modeling (accounts, transactions)</li> <li>Banking business rules and validation</li> </ul>"},{"location":"ai-agent-guide/#desktop-controller-samplesdesktop-controller","title":"\ud83c\udf9b\ufe0f Desktop Controller (<code>samples/desktop-controller/</code>)","text":"<ul> <li>Background services and scheduled tasks</li> <li>System integration patterns</li> <li>Resource management examples</li> </ul>"},{"location":"ai-agent-guide/#lab-resource-manager-sampleslab-resource-manager","title":"\ud83e\uddea Lab Resource Manager (<code>samples/lab-resource-manager/</code>)","text":"<ul> <li>Resource-Oriented Architecture (ROA)</li> <li>Watcher/Controller patterns (like Kubernetes operators)</li> <li>Reconciliation loops for resource management</li> </ul>"},{"location":"ai-agent-guide/#api-gateway-samplesapi-gateway","title":"\ud83c\udf10 API Gateway (<code>samples/api-gateway/</code>)","text":"<ul> <li>Microservice gateway patterns</li> <li>AI/ML integration examples</li> <li>Service orchestration and routing</li> <li>Background task processing with Redis</li> </ul>"},{"location":"ai-agent-guide/#where-to-find-information","title":"\ud83d\udd0d Where to Find Information","text":""},{"location":"ai-agent-guide/#documentation-structure-docs","title":"\ud83d\udcda Documentation Structure (<code>docs/</code>)","text":"Section Purpose Key Files <code>getting-started.md</code> Framework introduction Quick start, core concepts <code>features/</code> Feature documentation One file per major feature <code>patterns/</code> Architecture patterns CQRS, Clean Architecture, Event Sourcing <code>samples/</code> Sample walkthroughs Detailed sample explanations <code>references/</code> Technical references Python best practices, 12-Factor App <code>guides/</code> Step-by-step tutorials Mario's Pizzeria tutorial"},{"location":"ai-agent-guide/#key-documentation-files","title":"\ud83c\udfaf Key Documentation Files","text":"<ul> <li>Getting Started - Framework overview and quick start</li> <li>Mario's Pizzeria Tutorial - Complete walkthrough</li> <li>CQRS &amp; Mediation - Command/Query patterns</li> <li>MVC Controllers - FastAPI controller patterns</li> <li>Data Access - Repository and persistence</li> <li>Dependency Injection - DI container usage</li> <li>Python Typing Guide - Type hints &amp; generics</li> </ul>"},{"location":"ai-agent-guide/#additional-resources","title":"\ud83d\udcd6 Additional Resources","text":"<ul> <li><code>README.md</code> - Project overview and installation</li> <li><code>pyproject.toml</code> - Dependencies and build configuration</li> <li><code>src/neuroglia/</code> - Complete framework source code</li> <li><code>tests/</code> - Comprehensive test suite with examples</li> </ul>"},{"location":"ai-agent-guide/#common-patterns-best-practices","title":"\ud83d\udca1 Common Patterns &amp; Best Practices","text":""},{"location":"ai-agent-guide/#do-this","title":"\u2705 Do This","text":"<pre><code># \u2705 Use constructor injection\nclass OrderService:\n    def __init__(self, repository: OrderRepository, event_bus: EventBus):\n        self.repository = repository\n        self.event_bus = event_bus\n\n# \u2705 Separate commands and queries\nclass PlaceOrderCommand(Command[Order]): pass\nclass GetOrderQuery(Query[Optional[Order]]): pass\n\n# \u2705 Use domain events\nclass Order(Entity):\n    def place_order(self):\n        # Business logic\n        self.raise_event(OrderPlacedEvent(order_id=self.id))\n\n# \u2705 Type hints everywhere\nasync def handle_async(self, command: PlaceOrderCommand) -&gt; Order:\n    return order\n</code></pre>"},{"location":"ai-agent-guide/#avoid-this","title":"\u274c Avoid This","text":"<pre><code># \u274c Direct database access in controllers\nclass OrderController:\n    def create_order(self):\n        # Don't access database directly\n        connection.execute(\"INSERT INTO...\")\n\n# \u274c Mixing concerns\nclass OrderHandler:\n    def handle(self, command):\n        # Don't mix business logic with infrastructure\n        send_email()  # Infrastructure concern\n\n# \u274c Missing type hints\ndef process_order(order):  # What type is order?\n    return result  # What type is result?\n</code></pre>"},{"location":"ai-agent-guide/#quick-commands","title":"\ud83d\ude80 Quick Commands","text":"<pre><code># Install framework (when available)\npip install neuroglia\n\n# Run sample applications\ncd samples/mario-pizzeria &amp;&amp; python main.py\ncd samples/openbank &amp;&amp; python main.py\n\n# Run tests\npytest tests/\n\n# Generate documentation\nmkdocs serve\n\n# CLI tool (when available)\npyneuroctl --help\npyneuroctl samples list\npyneuroctl new myapp --template minimal\n</code></pre>"},{"location":"ai-agent-guide/#for-ai-agents-key-takeaways","title":"\ud83c\udfaf For AI Agents: Key Takeaways","text":"<ol> <li>Architecture: Clean Architecture with strict dependency rules</li> <li>Patterns: CQRS, DI, Repository, Domain Events are core</li> <li>Code Style: Heavy use of type hints, dataclasses, async/await</li> <li>Framework Integration: Built on FastAPI, uses Pydantic extensively</li> <li>Sample Code: Always reference <code>samples/mario-pizzeria/</code> for real examples</li> <li>Documentation: Comprehensive docs in <code>docs/</code> with practical examples</li> <li>Testing: Full test coverage with patterns for all architectural layers</li> </ol> <p>When writing Neuroglia code:</p> <ul> <li>Follow the layered architecture strictly</li> <li>Use CQRS for all business operations</li> <li>Leverage dependency injection throughout</li> <li>Include comprehensive type hints</li> <li>Reference Mario's Pizzeria sample for patterns</li> <li>Maintain separation of concerns between layers</li> </ul>"},{"location":"ai-agent-guide/#quick-framework-setup-for-ai-agents","title":"\ud83e\udd16 Quick Framework Setup for AI Agents","text":"<pre><code># Minimal Neuroglia application setup\nfrom neuroglia.hosting.web import WebApplicationBuilder\n\ndef create_app():\n    builder = WebApplicationBuilder()\n\n    # Essential services\n    builder.services.add_mediator()  # CQRS support\n    builder.services.add_controllers([\"api.controllers\"])  # Auto-discover controllers\n    builder.services.add_object_mapping()  # Object mapping\n\n    # Build and configure\n    app = builder.build()\n    app.use_controllers()  # Enable controller routing\n    return app\n\nif __name__ == \"__main__\":\n    app = create_app()\n    app.run()\n</code></pre> <p>Need more detail? Start with Getting Started then dive into specific feature documentation or explore the Mario's Pizzeria sample.</p>"},{"location":"getting-started/","title":"\ud83d\ude80 Getting Started with Neuroglia","text":"<p>Welcome to Neuroglia - a lightweight Python framework for building maintainable microservices using clean architecture principles.</p>"},{"location":"getting-started/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<p>This guide will take you from zero to your first working application in just a few minutes. By the end, you'll understand:</p> <ul> <li>How to install Neuroglia and create your first project</li> <li>The basics of clean architecture and why it matters</li> <li>How to build a simple CRUD API using CQRS patterns</li> <li>Where to go next for advanced features</li> </ul> <p>New to Clean Architecture?</p> <p>Don't worry! This guide assumes no prior knowledge. We'll explain concepts as we go.</p>"},{"location":"getting-started/#quick-installation","title":"\u26a1 Quick Installation","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11 or higher</li> <li>pip (Python package manager)</li> <li>Basic familiarity with Python and REST APIs</li> </ul>"},{"location":"getting-started/#install-neuroglia","title":"Install Neuroglia","text":"<pre><code>pip install neuroglia\n</code></pre> <p>That's it! Neuroglia is built on FastAPI, so it will install all necessary dependencies automatically.</p>"},{"location":"getting-started/#hello-world-your-first-application","title":"\ud83d\udc4b Hello World - Your First Application","text":"<p>Let's create the simplest possible Neuroglia application to verify everything works.</p>"},{"location":"getting-started/#step-1-create-a-simple-api","title":"Step 1: Create a Simple API","text":"<p>Create a file named <code>main.py</code>:</p> <pre><code>from fastapi import FastAPI\nfrom neuroglia.hosting.web import WebApplicationBuilder\n\n# Create the application builder\nbuilder = WebApplicationBuilder()\n\n# Build the FastAPI application\napp = builder.build()\n\n# Add a simple endpoint\n@app.get(\"/\")\nasync def hello():\n    return {\"message\": \"Hello from Neuroglia!\"}\n\n# Run the application (if executed directly)\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"getting-started/#step-2-run-it","title":"Step 2: Run It","text":"<pre><code>python main.py\n</code></pre>"},{"location":"getting-started/#step-3-test-it","title":"Step 3: Test It","text":"<p>Open your browser to http://localhost:8080 or use curl:</p> <pre><code>curl http://localhost:8080\n# Output: {\"message\": \"Hello from Neuroglia!\"}\n</code></pre> <p>\ud83c\udf89 Congratulations! You've just built your first Neuroglia application!</p> <p>What Just Happened?</p> <p><code>WebApplicationBuilder</code> is Neuroglia's main entry point. It sets up FastAPI with sensible defaults and provides hooks for dependency injection, middleware, and more. The <code>.build()</code> method creates the FastAPI app instance, and <code>.run()</code> starts the development server.</p>"},{"location":"getting-started/#understanding-clean-architecture","title":"\ud83c\udfd7\ufe0f Understanding Clean Architecture","text":"<p>Before we build something more complex, let's understand why Neuroglia enforces a specific structure.</p>"},{"location":"getting-started/#the-problem-spaghetti-code","title":"The Problem: Spaghetti Code","text":"<p>Traditional applications often mix concerns:</p> <pre><code># \u274c Everything in one place - hard to test and maintain\n@app.post(\"/orders\")\nasync def create_order(order_data: dict):\n    # Database access mixed with business logic\n    conn = psycopg2.connect(\"...\")\n    # Business validation mixed with data access\n    if order_data[\"total\"] &lt; 0:\n        raise ValueError(\"Invalid total\")\n    # HTTP concerns mixed with everything else\n    cursor.execute(\"INSERT INTO orders...\")\n    return {\"id\": result}\n</code></pre>"},{"location":"getting-started/#the-solution-layered-architecture","title":"The Solution: Layered Architecture","text":"<p>Neuroglia separates your code into clear layers:</p> <pre><code>\ud83d\udcc1 your_project/\n\u251c\u2500\u2500 api/           # \ud83c\udf10 Handles HTTP requests/responses\n\u251c\u2500\u2500 application/   # \ud83d\udcbc Orchestrates business operations\n\u251c\u2500\u2500 domain/        # \ud83c\udfdb\ufe0f Contains business rules and logic\n\u2514\u2500\u2500 integration/   # \ud83d\udd0c Talks to databases and external services\n</code></pre> <p>Key Benefit: Each layer has one job, making code easier to test, understand, and change.</p>"},{"location":"getting-started/#the-dependency-rule","title":"The Dependency Rule","text":"<p>Dependencies only flow inward \u2192 toward the domain:</p> <pre><code>flowchart LR\n    API[\ud83c\udf10 API] --&gt; APP[\ud83d\udcbc Application]\n    APP --&gt; DOM[\ud83c\udfdb\ufe0f Domain]\n    INT[\ud83d\udd0c Integration] --&gt; DOM\n\n    style DOM fill:#e1f5fe,stroke:#0277bd,stroke-width:3px</code></pre> <p>Why This Matters: Your business logic (Domain) never depends on HTTP, databases, or external services. This means you can:</p> <ul> <li>Test business logic without a database</li> <li>Switch from PostgreSQL to MongoDB without changing business rules</li> <li>Change API frameworks without touching core logic</li> </ul>"},{"location":"getting-started/#building-a-real-application-pizza-orders","title":"\ud83c\udf55 Building a Real Application: Pizza Orders","text":"<p>Let's build a simple pizza ordering system to see clean architecture in action.</p>"},{"location":"getting-started/#step-1-define-the-domain","title":"Step 1: Define the Domain","text":"<p>The domain represents your business concepts. Create <code>domain/pizza_order.py</code>:</p> <pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom uuid import uuid4\n\n@dataclass\nclass PizzaOrder:\n    \"\"\"A pizza order - our core business entity.\"\"\"\n    id: str\n    customer_name: str\n    pizza_type: str\n    size: str\n    created_at: datetime\n\n    @staticmethod\n    def create(customer_name: str, pizza_type: str, size: str):\n        \"\"\"Factory method to create a new order.\"\"\"\n        return PizzaOrder(\n            id=str(uuid4()),\n            customer_name=customer_name,\n            pizza_type=pizza_type,\n            size=size,\n            created_at=datetime.utcnow()\n        )\n\n    def is_valid(self) -&gt; bool:\n        \"\"\"Business rule: validate order.\"\"\"\n        valid_sizes = [\"small\", \"medium\", \"large\"]\n        return self.size in valid_sizes and len(self.customer_name) &gt; 0\n</code></pre> <p>Domain Layer</p> <p>Notice: No imports from FastAPI, no database code. Just pure Python business logic.</p>"},{"location":"getting-started/#step-2-create-commands-and-queries-cqrs","title":"Step 2: Create Commands and Queries (CQRS)","text":"<p>CQRS separates write operations (Commands) from read operations (Queries).</p> <p>Create <code>application/commands.py</code>:</p> <pre><code>from dataclasses import dataclass\nfrom neuroglia.mediation import Command\n\n@dataclass\nclass CreatePizzaOrderCommand(Command[dict]):\n    \"\"\"Command to create a new pizza order.\"\"\"\n    customer_name: str\n    pizza_type: str\n    size: str\n</code></pre> <p>Create <code>application/queries.py</code>:</p> <pre><code>from dataclasses import dataclass\nfrom neuroglia.mediation import Query\n\n@dataclass\nclass GetPizzaOrderQuery(Query[dict]):\n    \"\"\"Query to retrieve a pizza order.\"\"\"\n    order_id: str\n</code></pre> <p>CQRS Pattern</p> <p>Commands change state (create, update, delete). Queries read state (get, list). Separating them makes code clearer and enables advanced patterns like event sourcing.</p>"},{"location":"getting-started/#step-3-implement-handlers","title":"Step 3: Implement Handlers","text":"<p>Handlers contain the logic to execute commands and queries. Create <code>application/handlers.py</code>:</p> <pre><code>from neuroglia.mediation import CommandHandler, QueryHandler\nfrom application.commands import CreatePizzaOrderCommand\nfrom application.queries import GetPizzaOrderQuery\nfrom domain.pizza_order import PizzaOrder\n\n# Simple in-memory storage for this example\norders_db = {}\n\nclass CreatePizzaOrderHandler(CommandHandler[CreatePizzaOrderCommand, dict]):\n    \"\"\"Handles creating new pizza orders.\"\"\"\n\n    async def handle_async(self, command: CreatePizzaOrderCommand) -&gt; dict:\n        # Create domain entity\n        order = PizzaOrder.create(\n            customer_name=command.customer_name,\n            pizza_type=command.pizza_type,\n            size=command.size\n        )\n\n        # Validate business rules\n        if not order.is_valid():\n            raise ValueError(\"Invalid order\")\n\n        # Store (in real app, this would use a Repository)\n        orders_db[order.id] = order\n\n        # Return result\n        return {\n            \"id\": order.id,\n            \"customer_name\": order.customer_name,\n            \"pizza_type\": order.pizza_type,\n            \"size\": order.size,\n            \"created_at\": order.created_at.isoformat()\n        }\n\n\nclass GetPizzaOrderHandler(QueryHandler[GetPizzaOrderQuery, dict]):\n    \"\"\"Handles retrieving pizza orders.\"\"\"\n\n    async def handle_async(self, query: GetPizzaOrderQuery) -&gt; dict:\n        order = orders_db.get(query.order_id)\n        if not order:\n            return None\n\n        return {\n            \"id\": order.id,\n            \"customer_name\": order.customer_name,\n            \"pizza_type\": order.pizza_type,\n            \"size\": order.size,\n            \"created_at\": order.created_at.isoformat()\n        }\n</code></pre>"},{"location":"getting-started/#step-4-create-api-controller","title":"Step 4: Create API Controller","text":"<p>Now let's expose this via HTTP. Create <code>api/orders_controller.py</code>:</p> <pre><code>from neuroglia.mvc import ControllerBase\nfrom neuroglia.mediation import Mediator\nfrom application.commands import CreatePizzaOrderCommand\nfrom application.queries import GetPizzaOrderQuery\nfrom classy_fastapi.decorators import get, post\nfrom pydantic import BaseModel\n\nclass CreateOrderRequest(BaseModel):\n    customer_name: str\n    pizza_type: str\n    size: str\n\nclass OrdersController(ControllerBase):\n    \"\"\"Pizza orders API endpoint.\"\"\"\n\n    @post(\"/\", status_code=201)\n    async def create_order(self, request: CreateOrderRequest):\n        \"\"\"Create a new pizza order.\"\"\"\n        command = CreatePizzaOrderCommand(\n            customer_name=request.customer_name,\n            pizza_type=request.pizza_type,\n            size=request.size\n        )\n        result = await self.mediator.execute_async(command)\n        return result\n\n    @get(\"/{order_id}\")\n    async def get_order(self, order_id: str):\n        \"\"\"Retrieve a pizza order by ID.\"\"\"\n        query = GetPizzaOrderQuery(order_id=order_id)\n        result = await self.mediator.execute_async(query)\n        return result if result else {\"error\": \"Order not found\"}\n</code></pre> <p>API Layer</p> <p>The controller is thin - it just translates HTTP requests to commands/queries and sends them to the Mediator.</p>"},{"location":"getting-started/#step-5-wire-it-all-together","title":"Step 5: Wire It All Together","text":"<p>Update your <code>main.py</code>:</p> <pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom application.handlers import CreatePizzaOrderHandler, GetPizzaOrderHandler\nfrom api.orders_controller import OrdersController\n\n# Create application builder\nbuilder = WebApplicationBuilder()\n\n# Register handlers\nservices = builder.services\nservices.add_singleton(CreatePizzaOrderHandler)\nservices.add_singleton(GetPizzaOrderHandler)\n\n# Add mediator and controllers\nservices.add_mediator()\nservices.add_controllers([OrdersController])\n\n# Build and configure app\napp = builder.build()\napp.use_controllers()\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"getting-started/#step-6-test-your-api","title":"Step 6: Test Your API","text":"<p>Run the application:</p> <pre><code>python main.py\n</code></pre> <p>Create an order:</p> <pre><code>curl -X POST http://localhost:8080/orders \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"customer_name\":\"John\",\"pizza_type\":\"Margherita\",\"size\":\"large\"}'\n</code></pre> <p>Response:</p> <pre><code>{\n  \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"customer_name\": \"John\",\n  \"pizza_type\": \"Margherita\",\n  \"size\": \"large\",\n  \"created_at\": \"2025-10-25T10:30:00\"\n}\n</code></pre> <p>Get the order:</p> <pre><code>curl http://localhost:8080/orders/550e8400-e29b-41d4-a716-446655440000\n</code></pre>"},{"location":"getting-started/#what-you-just-built","title":"\ud83c\udf93 What You Just Built","text":"<p>You've created a clean architecture application with:</p> <ul> <li>\u2705 Domain Layer: <code>PizzaOrder</code> entity with business rules</li> <li>\u2705 Application Layer: Commands, Queries, and Handlers</li> <li>\u2705 API Layer: REST controller using FastAPI</li> <li>\u2705 CQRS Pattern: Separate write and read operations</li> <li>\u2705 Dependency Injection: Automatic service resolution</li> <li>\u2705 Mediator Pattern: Decoupled command/query execution</li> </ul>"},{"location":"getting-started/#whats-next","title":"\ud83d\ude80 What's Next?","text":""},{"location":"getting-started/#for-beginners","title":"For Beginners","text":"<ol> <li>3-Minute Bootstrap - See more setup options</li> <li>Core Concepts - Understand Clean Architecture, DDD, CQRS (coming soon)</li> <li>Complete Tutorial - Build full Mario's Pizzeria app (coming soon)</li> </ol>"},{"location":"getting-started/#learn-framework-features","title":"Learn Framework Features","text":"<ul> <li>Dependency Injection - Service lifetime and registration</li> <li>CQRS &amp; Mediation - Advanced command/query patterns</li> <li>MVC Controllers - REST API development</li> <li>Data Access - Repository pattern and persistence</li> <li>Event Sourcing - Event-driven architecture</li> </ul>"},{"location":"getting-started/#explore-advanced-topics","title":"Explore Advanced Topics","text":"<ul> <li>Mario's Pizzeria Tutorial - Complete production app</li> <li>Architecture Patterns - Deep dive into patterns</li> <li>Sample Applications - More real-world examples</li> </ul>"},{"location":"getting-started/#troubleshooting","title":"\ud83d\udc1b Troubleshooting","text":""},{"location":"getting-started/#common-issues","title":"Common Issues","text":"<p>Q: Import errors when running the application</p> <pre><code>ModuleNotFoundError: No module named 'neuroglia'\n</code></pre> <p>A: Make sure Neuroglia is installed: <code>pip install neuroglia</code></p> <p>Q: Application won't start</p> <pre><code>Address already in use\n</code></pre> <p>A: Port 8080 is taken. Change the port: <code>app.run(port=8081)</code></p> <p>Q: Mediator can't find handlers</p> <pre><code>No handler registered for command\n</code></pre> <p>A: Make sure handlers are registered with <code>services.add_singleton(YourHandler)</code> before calling <code>services.add_mediator()</code></p> <p>Q: Module import errors in project</p> <pre><code>ImportError: attempted relative import with no known parent package\n</code></pre> <p>A: Add your project root to <code>PYTHONPATH</code>: <code>export PYTHONPATH=.</code> or run with <code>python -m main</code></p>"},{"location":"getting-started/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: Explore features and patterns</li> <li>Examples: Check sample applications</li> <li>Issues: Report bugs on GitHub</li> </ul>"},{"location":"getting-started/#key-takeaways","title":"\ud83d\udca1 Key Takeaways","text":"<ol> <li>Clean Architecture separates concerns into layers with clear dependencies</li> <li>CQRS separates writes (Commands) from reads (Queries)</li> <li>Mediator decouples controllers from handlers</li> <li>Domain Layer contains pure business logic with no external dependencies</li> <li>Controllers are thin - they delegate to the application layer</li> </ol> <p>You're Ready!</p> <p>You now understand the fundamentals of Neuroglia. Continue with the Mario's Pizzeria tutorial to build a complete production-ready application!</p>"},{"location":"getting-started/#key-takeaways_1","title":"\ud83d\udca1 Key Takeaways","text":"<ol> <li>Clean Architecture separates concerns into layers with clear dependencies</li> <li>CQRS separates writes (Commands) from reads (Queries)</li> <li>Mediator decouples controllers from handlers</li> <li>Domain Layer contains pure business logic with no external dependencies</li> <li>Controllers are thin - they delegate to the application layer</li> </ol> <p>You're Ready!</p> <p>You now understand the fundamentals of Neuroglia. Continue with the Mario's Pizzeria tutorial to build a complete production-ready application!</p>"},{"location":"getting-started/#additional-resources","title":"\ud83d\udcda Additional Resources","text":""},{"location":"getting-started/#framework-documentation","title":"Framework Documentation","text":"<ul> <li>Feature Documentation - Complete guide to all framework features</li> <li>Architecture Patterns - Deep dive into design patterns</li> <li>Sample Applications - Real-world example applications</li> <li>How-To Guides - Practical implementation guides</li> </ul>"},{"location":"getting-started/#external-learning-resources","title":"External Learning Resources","text":""},{"location":"getting-started/#essential-reading","title":"Essential Reading","text":"<ul> <li>Clean Architecture by Robert C. Martin</li> <li>Domain-Driven Design by Eric Evans</li> <li>FastAPI Documentation</li> <li>Python Type Hints</li> </ul>"},{"location":"getting-started/#recommended-books","title":"Recommended Books","text":"<ul> <li>Clean Code by Robert C. Martin - Writing maintainable code</li> <li>Implementing Domain-Driven Design by Vaughn Vernon - Practical DDD</li> <li>Enterprise Integration Patterns by Gregor Hohpe - Messaging patterns</li> <li>Building Microservices by Sam Newman - Distributed systems</li> </ul>"},{"location":"mario-pizzeria/","title":"\ud83c\udf55 Mario's Pizzeria: Complete Digital Transformation Case Study","text":"<p>Client: Mario's Family Restaurant Chain. Project: Full-Stack Digital Ordering Platform. Industry: Food Service &amp; Hospitality. Consultant: Neuroglia Architecture Team.</p> <p>\ud83d\udcc2 View Complete Source Code on GitHub</p>"},{"location":"mario-pizzeria/#executive-summary","title":"\ud83d\udccb Executive Summary","text":"<p>Mario's Pizzeria represents a comprehensive digital transformation initiative that demonstrates how modern software architecture can revolutionize traditional restaurant operations. This case study showcases the complete journey from business analysis through production deployment, serving as both a practical implementation guide and architectural reference.</p> <p>Business Challenge: A successful local pizzeria needs to modernize operations with digital ordering, kitchen management, and customer notifications while maintaining quality and scalability.</p> <p>Technical Solution: A production-ready FastAPI application built with clean architecture, CQRS patterns, event-driven workflows, and OAuth 2.0 security using the Neuroglia framework.</p> <p>Business Impact:</p> <ul> <li>\ud83d\ude80 40% increase in order volume capacity</li> <li>\u26a1 60% reduction in order processing time</li> <li>\ud83d\udcf1 95% customer satisfaction with digital experience</li> <li>\ud83d\udd12 Zero security incidents with OAuth 2.0 implementation</li> </ul>"},{"location":"mario-pizzeria/#project-overview","title":"\ud83c\udfaf Project Overview","text":""},{"location":"mario-pizzeria/#why-marios-pizzeria","title":"Why Mario's Pizzeria?","text":"<p>This case study was chosen because it:</p> <ul> <li>\u2705 Familiar Domain - Everyone understands pizza ordering workflows</li> <li>\u2705 Real Business Logic - Complex pricing, capacity management, status tracking</li> <li>\u2705 Multiple User Types - Customers, kitchen staff, managers with different needs</li> <li>\u2705 Event-Driven Nature - Natural business events (order placed, cooking started, ready)</li> <li>\u2705 Production Ready - Actual business logic that could be deployed tomorrow</li> </ul>"},{"location":"mario-pizzeria/#architecture-highlights","title":"Architecture Highlights","text":"<ul> <li>\ud83c\udfdb\ufe0f Clean Architecture - Four-layer separation with clear dependencies</li> <li>\ud83c\udfaf CQRS Pattern - Command/Query separation for scalability</li> <li>\u26a1 Event-Driven - Asynchronous workflows and loose coupling</li> <li>\ud83d\udd10 OAuth 2.0 Security - Production-grade authentication and authorization</li> <li>\ud83e\uddea Comprehensive Testing - Unit, integration, and end-to-end test coverage</li> <li>\ud83d\udcca Business Intelligence - Analytics and reporting capabilities</li> </ul>"},{"location":"mario-pizzeria/#patterns-demonstrated","title":"\ud83c\udf1f Patterns Demonstrated","text":"<p>This case study demonstrates all 10 foundational architectural patterns working together:</p> Pattern Demonstrated In Key Examples \ud83c\udfd7\ufe0f Clean Architecture Complete application structure API \u2192 Application \u2192 Domain \u2190 Integration layers \ud83c\udfdb\ufe0f Domain-Driven Design Order, Pizza, Kitchen entities Rich domain models with business logic and invariants \ud83d\udc89 Dependency Injection Service registration and lifetimes Repository, handler, and service dependency management \ud83d\udce1 CQRS &amp; Mediation All command and query handlers PlaceOrderCommand, GetOrderByIdQuery with mediator routing \ud83d\udd04 Event-Driven Architecture Kitchen workflow automation OrderPlaced \u2192 Kitchen processes \u2192 OrderReady events \ud83d\udcbe Repository Pattern Data access abstraction File, MongoDB, and InMemory repository implementations \ud83d\udd04 Unit of Work Event coordination Automatic domain event collection and dispatching \ud83d\udd27 Pipeline Behaviors Cross-cutting concerns Validation, logging, error handling around all handlers \ud83c\udfaf Event Sourcing Order event history Complete audit trail of order lifecycle (optional implementation) \ud83c\udf0a Reactive Programming Real-time order tracking Kitchen capacity monitoring with observable streams <p>\ud83d\udca1 Learning Tip: Each pattern documentation now includes \"Common Mistakes\" and \"When NOT to Use\" sections based on lessons learned from building Mario's Pizzeria!</p>"},{"location":"mario-pizzeria/#detailed-analysis-documents","title":"\ud83d\udcca Detailed Analysis Documents","text":""},{"location":"mario-pizzeria/#business-analysis-requirements","title":"\ud83c\udfe2 Business Analysis &amp; Requirements","text":"<p>What you'll find: Complete stakeholder analysis, business requirements, success metrics, and ROI projections.</p> <p>Key Sections:</p> <ul> <li>Executive summary with business case and ROI analysis</li> <li>Stakeholder mapping and requirements gathering</li> <li>Functional and non-functional requirements matrix</li> <li>Success metrics and KPIs for measuring project impact</li> <li>Business rules and constraints that drive technical decisions</li> </ul> <p>Perfect for: Business analysts, project managers, and technical leads who need to understand the business context and justify technical architecture decisions.</p>"},{"location":"mario-pizzeria/#technical-architecture-infrastructure","title":"\ud83c\udfd7\ufe0f Technical Architecture &amp; Infrastructure","text":"<p>What you'll find: Complete system design, scalability planning, and infrastructure requirements.</p> <p>Key Sections:</p> <ul> <li>Clean architecture layer diagrams with dependency flows</li> <li>Data storage strategies (file-based, MongoDB, event sourcing)</li> <li>API design with comprehensive endpoint documentation</li> <li>Security architecture with OAuth 2.0 implementation details</li> <li>Scalability and performance optimization strategies</li> <li>Infrastructure requirements for development and production</li> </ul> <p>Perfect for: Software architects, DevOps engineers, and senior developers who need to understand system design and deployment requirements.</p>"},{"location":"mario-pizzeria/#domain-design-business-logic","title":"\ud83c\udfaf Domain Design &amp; Business Logic","text":"<p>What you'll find: Rich domain models, business rules, and Domain-Driven Design patterns.</p> <p>Key Sections:</p> <ul> <li>Complete domain model with entity relationships</li> <li>Rich domain entities with business logic (Order, Pizza, Kitchen)</li> <li>Value objects for type safety (Money, Address)</li> <li>Domain events for business workflow automation</li> <li>Business rules and invariants that maintain data consistency</li> <li>Domain-Driven Design patterns in practice</li> </ul> <p>Perfect for: Domain experts, senior developers, and architects who want to see how business concepts translate into maintainable code.</p>"},{"location":"mario-pizzeria/#implementation-guide-code-patterns","title":"\ud83d\ude80 Implementation Guide &amp; Code Patterns","text":"<p>What you'll find: Production-ready code examples, CQRS patterns, and security implementation.</p> <p>Key Sections:</p> <ul> <li>Complete CQRS command and query implementations</li> <li>Event-driven workflow with practical examples</li> <li>Data Transfer Objects (DTOs) with validation</li> <li>OAuth 2.0 authentication and role-based authorization</li> <li>API client examples in multiple languages</li> <li>Security best practices and production considerations</li> </ul> <p>Perfect for: Developers who want hands-on code examples and practical implementation guidance using the Neuroglia framework.</p>"},{"location":"mario-pizzeria/#testing-deployment-strategy","title":"\ud83e\uddea Testing &amp; Deployment Strategy","text":"<p>What you'll find: Comprehensive testing strategy, CI/CD pipelines, and production deployment.</p> <p>Key Sections:</p> <ul> <li>Unit testing with domain entity and handler examples</li> <li>Integration testing for API endpoints and data access</li> <li>End-to-end testing for complete business workflows</li> <li>Docker containerization and deployment configuration</li> <li>CI/CD pipeline with automated testing and deployment</li> <li>Production monitoring and observability setup</li> </ul> <p>Perfect for: QA engineers, DevOps teams, and developers who need to ensure production reliability and maintainability.</p>"},{"location":"mario-pizzeria/#learning-path-recommendations","title":"\ud83c\udf93 Learning Path Recommendations","text":""},{"location":"mario-pizzeria/#for-business-stakeholders","title":"For Business Stakeholders","text":"<ol> <li>Start with Business Analysis to understand requirements and ROI</li> <li>Review Technical Architecture for system overview</li> <li>Explore Event-Driven Architecture to see how workflows automate business processes</li> <li>Focus on API endpoints and user experience sections</li> </ol>"},{"location":"mario-pizzeria/#for-software-architects","title":"For Software Architects","text":"<ol> <li>Begin with Technical Architecture for system design</li> <li>Deep dive into Domain Design for DDD patterns</li> <li>Study Clean Architecture layer separation and dependencies</li> <li>Review CQRS Pattern for command/query separation strategy</li> <li>Explore Implementation Guide for architectural patterns in action</li> </ol>"},{"location":"mario-pizzeria/#for-developers","title":"For Developers","text":"<ol> <li>Start with Domain Design to understand business logic</li> <li>Learn Dependency Injection for service wiring</li> <li>Follow Implementation Guide for CQRS code patterns</li> <li>Study Pipeline Behaviors for cross-cutting concerns</li> <li>Practice with Testing &amp; Deployment examples</li> </ol>"},{"location":"mario-pizzeria/#for-devops-engineers","title":"For DevOps Engineers","text":"<ol> <li>Focus on Technical Architecture infrastructure</li> <li>Study Testing &amp; Deployment for CI/CD</li> <li>Review security sections in Implementation Guide</li> <li>Understand Repository Pattern for data persistence strategies</li> </ol>"},{"location":"mario-pizzeria/#quick-start-options","title":"\ud83d\ude80 Quick Start Options","text":""},{"location":"mario-pizzeria/#just-browsing","title":"\ud83d\udd0d Just Browsing?","text":"<p>Start with Business Analysis to understand the business case and requirements.</p>"},{"location":"mario-pizzeria/#ready-to-code","title":"\ud83d\udc68\u200d\ud83d\udcbb Ready to Code?","text":"<p>Jump to Implementation Guide for hands-on examples and patterns.</p>"},{"location":"mario-pizzeria/#planning-architecture","title":"\ud83c\udfd7\ufe0f Planning Architecture?","text":"<p>Begin with Technical Architecture for system design and scalability.</p>"},{"location":"mario-pizzeria/#need-testing-strategy","title":"\ud83e\uddea Need Testing Strategy?","text":"<p>Go to Testing &amp; Deployment for comprehensive quality assurance.</p>"},{"location":"mario-pizzeria/#why-this-approach-works","title":"\ud83d\udca1 Why This Approach Works","text":"<p>Real-World Complexity: Mario's Pizzeria contains enough complexity to demonstrate enterprise patterns without overwhelming beginners.</p> <p>Progressive Learning: Each document builds on the previous, allowing you to go as deep as needed for your role and experience level.</p> <p>Production Ready: All code examples and patterns are production-quality and can be adapted for real projects.</p> <p>Framework Showcase: Demonstrates the power and elegance of the Neuroglia framework for building maintainable, scalable applications.</p>"},{"location":"mario-pizzeria/#related-framework-documentation","title":"\ud83d\udd17 Related Framework Documentation","text":""},{"location":"mario-pizzeria/#core-framework-guides","title":"\ud83c\udfaf Core Framework Guides","text":"<ul> <li>Getting Started with Neuroglia - Framework setup and first application</li> <li>3-Minute Bootstrap - Fastest way to start building</li> </ul>"},{"location":"mario-pizzeria/#architectural-patterns-demonstrated-in-marios-pizzeria","title":"\ud83c\udfd7\ufe0f Architectural Patterns (Demonstrated in Mario's Pizzeria)","text":"<ul> <li>Clean Architecture - Four-layer separation (see: project structure)</li> <li>Domain-Driven Design - Rich domain models (see: Order, Pizza entities)</li> <li>CQRS &amp; Mediation - Command/Query separation (see: PlaceOrderCommand)</li> <li>Event-Driven Architecture - Workflow automation (see: kitchen events)</li> <li>Repository Pattern - Data access abstraction (see: OrderRepository)</li> </ul>"},{"location":"mario-pizzeria/#implementation-patterns-used-throughout","title":"\ud83d\udd27 Implementation Patterns (Used Throughout)","text":"<ul> <li>Dependency Injection - Service container and lifetimes</li> <li>Unit of Work - Event coordination (see: order handlers)</li> <li>Pipeline Behaviors - Validation, logging (see: ValidationBehavior)</li> <li>Event Sourcing - Event history (optional: OrderEventStore)</li> <li>Reactive Programming - Real-time updates (see: kitchen capacity)</li> </ul>"},{"location":"mario-pizzeria/#additional-resources","title":"\ud83d\udcda Additional Resources","text":"<ul> <li>OAuth Security Reference - Authentication deep dive</li> <li>Observability Guide - Logging and monitoring setup</li> </ul> <p>\ud83d\udca1 Pro Tip: Each pattern page includes \"Common Mistakes\" sections that reference real issues discovered while building Mario's Pizzeria!</p> <p>Mario's Pizzeria demonstrates that with the right architecture and patterns, even complex business workflows can be implemented elegantly and maintainably. Ready to transform your next project?</p>"},{"location":"concepts/","title":"Core Concepts","text":"<p>Welcome to the Core Concepts guide! This section explains the architectural patterns and principles that Neuroglia is built upon. Each concept is explained for beginners - you don't need prior knowledge of these patterns.</p>"},{"location":"concepts/#why-these-patterns","title":"\ud83c\udfaf Why These Patterns?","text":"<p>Neuroglia enforces specific architectural patterns because they solve real problems in software development:</p> <ul> <li>Maintainability: Code that's easy to change as requirements evolve</li> <li>Testability: Components that can be tested in isolation</li> <li>Scalability: Architecture that grows with your application</li> <li>Clarity: Clear separation of concerns and responsibilities</li> </ul>"},{"location":"concepts/#concepts-overview","title":"\ud83d\udcda Concepts Overview","text":""},{"location":"concepts/#architecture-patterns","title":"Architecture Patterns","text":"<ul> <li> <p>Clean Architecture - Organizing code in layers with clear dependencies</p> </li> <li> <p>Problem it solves: Tangled code where everything depends on everything</p> </li> <li> <p>Key benefit: Business logic independent of frameworks and databases</p> </li> <li> <p>Dependency Injection - Providing dependencies instead of creating them</p> </li> <li>Problem it solves: Hard-coded dependencies that make testing difficult</li> <li>Key benefit: Loosely coupled, testable components</li> </ul>"},{"location":"concepts/#domain-driven-design","title":"Domain-Driven Design","text":"<ul> <li> <p>Domain-Driven Design Basics - Modeling your business domain</p> </li> <li> <p>Problem it solves: Business logic scattered across services</p> </li> <li> <p>Key benefit: Rich domain models that encapsulate business rules</p> </li> <li> <p>Aggregates &amp; Entities - Building blocks of your domain</p> </li> <li>Problem it solves: Unclear boundaries and consistency rules</li> <li>Key benefit: Clear transaction boundaries and data consistency</li> </ul>"},{"location":"concepts/#application-patterns","title":"Application Patterns","text":"<ul> <li> <p>CQRS (Command Query Responsibility Segregation) - Separating reads from writes</p> </li> <li> <p>Problem it solves: Single model trying to serve both read and write operations</p> </li> <li> <p>Key benefit: Optimized read and write paths, better scalability</p> </li> <li> <p>Mediator Pattern - Request routing and handling</p> </li> <li> <p>Problem it solves: Controllers knowing about specific handlers</p> </li> <li> <p>Key benefit: Loose coupling, easy to add cross-cutting concerns</p> </li> <li> <p>Event-Driven Architecture - Reacting to business occurrences</p> </li> <li>Problem it solves: Tight coupling between components</li> <li>Key benefit: Extensible, loosely coupled systems</li> </ul>"},{"location":"concepts/#data-patterns","title":"Data Patterns","text":"<ul> <li> <p>Repository Pattern - Abstracting data access</p> </li> <li> <p>Problem it solves: Domain code coupled to database</p> </li> <li> <p>Key benefit: Testable, swappable data access</p> </li> <li> <p>Unit of Work - Managing transactions</p> </li> <li>Problem it solves: Manual transaction management and event publishing</li> <li>Key benefit: Consistent transactional boundaries</li> </ul>"},{"location":"concepts/#learning-path","title":"\ud83d\udea6 Learning Path","text":"<p>New to these concepts? Follow this path:</p> <ol> <li>Start here: Clean Architecture</li> <li>Then learn: Dependency Injection</li> <li>Domain modeling: Domain-Driven Design</li> <li>Application layer: CQRS \u2192 Mediator</li> <li>Integration: Event-Driven Architecture</li> <li>Data access: Repository \u2192 Unit of Work</li> </ol> <p>Already familiar? Jump to any concept for Neuroglia-specific implementation details.</p>"},{"location":"concepts/#how-to-use-these-guides","title":"\ud83d\udca1 How to Use These Guides","text":"<p>Each concept guide includes:</p> <ul> <li>\u274c The Problem: What happens without this pattern</li> <li>\u2705 The Solution: How the pattern solves it</li> <li>\ud83d\udd27 In Neuroglia: How to implement it in the framework</li> <li>\ud83e\uddea Testing: How to test code using this pattern</li> <li>\u26a0\ufe0f Common Mistakes: Pitfalls to avoid</li> <li>\ud83d\udeab When NOT to Use: Scenarios where simpler approaches work better</li> </ul>"},{"location":"concepts/#see-it-in-action","title":"\ud83c\udf55 See It In Action","text":"<p>All concepts are demonstrated in the Mario's Pizzeria tutorial:</p> <ul> <li>Part 1 shows Clean Architecture and Dependency Injection</li> <li>Part 2 covers Domain-Driven Design and Aggregates</li> <li>Part 3 demonstrates CQRS and Mediator</li> <li>Part 5 explores Event-Driven Architecture</li> <li>Part 6 implements Repository and Unit of Work</li> </ul>"},{"location":"concepts/#additional-resources","title":"\ud83c\udf93 Additional Resources","text":"<ul> <li>Tutorials: Step-by-step Mario's Pizzeria guide</li> <li>Features: Framework feature documentation</li> <li>Patterns: Advanced pattern examples</li> <li>Case Study: Complete Mario's Pizzeria analysis</li> </ul> <p>Ready to dive in? Start with Clean Architecture to understand the foundation of Neuroglia's approach!</p>"},{"location":"concepts/aggregates-entities/","title":"Aggregates &amp; Entities","text":"<p>Time to read: 12 minutes</p> <p>Aggregates are clusters of domain objects treated as a single unit for data changes. They're the key to maintaining consistency in complex domain models.</p>"},{"location":"concepts/aggregates-entities/#the-problem-inconsistent-state","title":"\u274c The Problem: Inconsistent State","text":"<p>Without aggregates, related objects can become inconsistent:</p> <pre><code># \u274c No aggregate - objects can be inconsistent\norder = Order(id=\"123\")\norder.status = \"confirmed\"\n\n# Someone modifies items after confirmation\norder.items.append(OrderItem(\"Pepperoni\", 1))  # Breaks business rule!\n\n# Someone changes delivery without validation\norder.delivery_address = None  # Confirmed order with no address!\n\n# Total out of sync with items\norder.total = 50.0  # Items actually total $75!\n</code></pre> <p>Problems:</p> <ol> <li>No consistency: Related objects can contradict each other</li> <li>No invariants: Business rules not enforced</li> <li>No boundaries: Anyone can modify anything</li> <li>Race conditions: Concurrent changes cause conflicts</li> <li>Hard to reason about: Too many moving parts</li> </ol>"},{"location":"concepts/aggregates-entities/#the-solution-aggregate-pattern","title":"\u2705 The Solution: Aggregate Pattern","text":"<p>Group related objects with one root controlling access:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Order Aggregate (Consistency Boundary)     \u2502\n\u2502                                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 Order (Aggregate Root)               \u2502 \u2502\n\u2502  \u2502 - id, customer_id, status, created   \u2502 \u2502\n\u2502  \u2502 - add_item(), confirm(), cancel()    \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502           \u2502                                 \u2502\n\u2502           \u251c\u2500\u2192 OrderItem (value object)     \u2502\n\u2502           \u251c\u2500\u2192 OrderItem (value object)     \u2502\n\u2502           \u2514\u2500\u2192 DeliveryAddress (value obj)  \u2502\n\u2502                                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nRules:\n1. External code ONLY accesses Order (root)\n2. Order enforces ALL consistency rules\n3. Order and items saved/loaded as ONE UNIT\n4. Changes happen through Order methods only\n</code></pre> <p>Benefits:</p> <ol> <li>Guaranteed consistency: Root enforces invariants</li> <li>Clear boundaries: One entry point</li> <li>Transactional: Aggregate saved as a unit</li> <li>Concurrency control: Lock at aggregate level</li> <li>Easy to reason about: Complexity contained</li> </ol>"},{"location":"concepts/aggregates-entities/#anatomy-of-an-aggregate","title":"\ud83c\udfd7\ufe0f Anatomy of an Aggregate","text":""},{"location":"concepts/aggregates-entities/#aggregate-root","title":"Aggregate Root","text":"<p>The single entry point for the aggregate:</p> <pre><code>class Order:  # AGGREGATE ROOT\n    \"\"\"\n    Order aggregate root.\n    - External code accesses order through this class\n    - Order controls all its child objects\n    - Order enforces business invariants\n    \"\"\"\n\n    def __init__(self, customer_id: str):\n        self.id = str(uuid.uuid4())\n        self.customer_id = customer_id\n        self._items: List[OrderItem] = []  # Private!\n        self._status = OrderStatus.PENDING\n        self._delivery_address: Optional[DeliveryAddress] = None\n\n    # \u2705 Public methods enforce rules\n    def add_item(self, pizza_name: str, size: PizzaSize, quantity: int, price: Decimal):\n        \"\"\"Add item through root - rules enforced!\"\"\"\n        if self._status != OrderStatus.PENDING:\n            raise InvalidOperationError(\"Cannot modify confirmed orders\")\n\n        item = OrderItem(pizza_name, size, quantity, price)\n        self._items.append(item)\n\n    def set_delivery_address(self, address: DeliveryAddress):\n        \"\"\"Set address through root - validation enforced!\"\"\"\n        if not address.street or not address.city:\n            raise ValueError(\"Complete address required\")\n\n        self._delivery_address = address\n\n    def confirm(self):\n        \"\"\"Confirm order - invariants checked!\"\"\"\n        if not self._items:\n            raise InvalidOperationError(\"Cannot confirm empty order\")\n\n        if not self._delivery_address:\n            raise InvalidOperationError(\"Delivery address required\")\n\n        if self.total() &lt; Decimal(\"10\"):\n            raise InvalidOperationError(\"Minimum order is $10\")\n\n        self._status = OrderStatus.CONFIRMED\n\n    def total(self) -&gt; Decimal:\n        \"\"\"Calculate total - always consistent with items!\"\"\"\n        return sum(item.subtotal() for item in self._items)\n\n    # Read-only access to children\n    @property\n    def items(self) -&gt; List[OrderItem]:\n        return self._items.copy()  # Return copy, not reference!\n\n    @property\n    def status(self) -&gt; OrderStatus:\n        return self._status\n</code></pre>"},{"location":"concepts/aggregates-entities/#child-objects","title":"Child Objects","text":"<p>Internal to aggregate, accessed through root:</p> <pre><code>@dataclass(frozen=True)  # Immutable value object\nclass OrderItem:\n    \"\"\"Child object of Order aggregate.\"\"\"\n    pizza_name: str\n    size: PizzaSize\n    quantity: int\n    price: Decimal\n\n    def subtotal(self) -&gt; Decimal:\n        return self.price * self.quantity\n\n@dataclass(frozen=True)\nclass DeliveryAddress:\n    \"\"\"Child object of Order aggregate.\"\"\"\n    street: str\n    city: str\n    zip_code: str\n    delivery_instructions: Optional[str] = None\n</code></pre>"},{"location":"concepts/aggregates-entities/#aggregates-in-neuroglia","title":"\ud83d\udd27 Aggregates in Neuroglia","text":""},{"location":"concepts/aggregates-entities/#using-entity-and-aggregateroot","title":"Using Entity and AggregateRoot","text":"<p>Neuroglia provides base classes:</p> <pre><code>from neuroglia.core import Entity, AggregateRoot\n\nclass Order(AggregateRoot):\n    \"\"\"\n    AggregateRoot provides:\n    - Unique ID generation\n    - Domain event collection\n    - Event raising/retrieval\n    \"\"\"\n\n    def __init__(self, customer_id: str):\n        super().__init__()  # Generates ID, initializes events\n        self.customer_id = customer_id\n        self.items: List[OrderItem] = []\n        self.status = OrderStatus.PENDING\n\n        # Raise domain event\n        self.raise_event(OrderCreatedEvent(\n            order_id=self.id,\n            customer_id=customer_id\n        ))\n\n    def add_item(self, pizza_name: str, size: PizzaSize, quantity: int, price: Decimal):\n        # Validation\n        if self.status != OrderStatus.PENDING:\n            raise InvalidOperationError(\"Cannot modify confirmed orders\")\n\n        # Create value object\n        item = OrderItem(pizza_name, size, quantity, price)\n        self.items.append(item)\n\n        # Raise domain event\n        self.raise_event(ItemAddedToOrderEvent(\n            order_id=self.id,\n            pizza_name=pizza_name,\n            quantity=quantity\n        ))\n\n    def confirm(self):\n        # Business rules\n        if not self.items:\n            raise InvalidOperationError(\"Cannot confirm empty order\")\n\n        if self.total() &lt; Decimal(\"10\"):\n            raise InvalidOperationError(\"Minimum order is $10\")\n\n        # State change\n        self.status = OrderStatus.CONFIRMED\n\n        # Raise domain event\n        self.raise_event(OrderConfirmedEvent(\n            order_id=self.id,\n            customer_id=self.customer_id,\n            total=self.total()\n        ))\n\n    def total(self) -&gt; Decimal:\n        return sum(item.subtotal() for item in self.items)\n\n    # Get uncommitted events (for persistence)\n    def get_uncommitted_events(self) -&gt; List[DomainEvent]:\n        return self._uncommitted_events.copy()\n</code></pre>"},{"location":"concepts/aggregates-entities/#aggregate-boundaries","title":"Aggregate Boundaries","text":"<p>Rule 1: One Aggregate Root per Aggregate</p> <pre><code># \u2705 CORRECT: Order is the only root\nclass Order(AggregateRoot):\n    def __init__(self):\n        self.items: List[OrderItem] = []  # Child objects\n\n# \u274c WRONG: Making child an aggregate root too\nclass OrderItem(AggregateRoot):  # Don't do this!\n    pass\n</code></pre> <p>Rule 2: Reference Other Aggregates by ID</p> <pre><code># \u2705 CORRECT: Reference Customer by ID\nclass Order(AggregateRoot):\n    def __init__(self, customer_id: str):\n        self.customer_id = customer_id  # ID reference\n\n# \u274c WRONG: Embedding entire Customer aggregate\nclass Order(AggregateRoot):\n    def __init__(self, customer: Customer):\n        self.customer = customer  # Entire object - NO!\n</code></pre> <p>Rule 3: Small Aggregates</p> <pre><code># \u2705 GOOD: Small, focused aggregate\nclass Order(AggregateRoot):\n    def __init__(self):\n        self.items: List[OrderItem] = []  # 1-10 items typical\n        self.delivery_address: DeliveryAddress = None\n\n# \u274c BAD: Huge aggregate\nclass Order(AggregateRoot):\n    def __init__(self):\n        self.customer: Customer = None  # Entire customer!\n        self.items: List[OrderItem] = []\n        self.payments: List[Payment] = []  # Separate aggregate\n        self.shipments: List[Shipment] = []  # Separate aggregate\n        self.reviews: List[Review] = []  # Separate aggregate\n# Too big! Contention, performance issues\n</code></pre>"},{"location":"concepts/aggregates-entities/#event-sourcing-with-aggregates","title":"Event Sourcing with Aggregates","text":"<p>Neuroglia supports event-sourced aggregates:</p> <pre><code>from neuroglia.core import AggregateState\n\nclass OrderState(AggregateState):\n    \"\"\"\n    State rebuilt from events.\n    Each event handler updates state.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.customer_id: Optional[str] = None\n        self.items: List[OrderItem] = []\n        self.status = OrderStatus.PENDING\n\n    # Event handlers rebuild state\n    def on_order_created(self, event: OrderCreatedEvent):\n        self.customer_id = event.customer_id\n        self.status = OrderStatus.PENDING\n\n    def on_item_added(self, event: ItemAddedToOrderEvent):\n        item = OrderItem(\n            event.pizza_name,\n            event.size,\n            event.quantity,\n            event.price\n        )\n        self.items.append(item)\n\n    def on_order_confirmed(self, event: OrderConfirmedEvent):\n        self.status = OrderStatus.CONFIRMED\n\nclass Order(AggregateRoot):\n    \"\"\"Event-sourced aggregate.\"\"\"\n\n    def __init__(self, state: OrderState):\n        super().__init__()\n        self.state = state\n\n    def add_item(self, pizza_name: str, size: PizzaSize, quantity: int, price: Decimal):\n        # Validate against current state\n        if self.state.status != OrderStatus.PENDING:\n            raise InvalidOperationError(\"Cannot modify confirmed orders\")\n\n        # Apply event (updates state + records event)\n        self.apply_event(ItemAddedToOrderEvent(\n            order_id=self.id,\n            pizza_name=pizza_name,\n            size=size,\n            quantity=quantity,\n            price=price\n        ))\n</code></pre>"},{"location":"concepts/aggregates-entities/#testing-aggregates","title":"\ud83e\uddea Testing Aggregates","text":""},{"location":"concepts/aggregates-entities/#test-invariants","title":"Test Invariants","text":"<pre><code>def test_cannot_add_item_to_confirmed_order():\n    \"\"\"Test aggregate enforces consistency.\"\"\"\n    order = Order(customer_id=\"123\")\n    order.add_item(\"Margherita\", PizzaSize.LARGE, 1, Decimal(\"15.99\"))\n    order.confirm()\n\n    # Attempt to violate invariant\n    with pytest.raises(InvalidOperationError, match=\"confirmed orders\"):\n        order.add_item(\"Pepperoni\", PizzaSize.MEDIUM, 1, Decimal(\"13.99\"))\n\ndef test_cannot_confirm_order_without_items():\n    \"\"\"Test aggregate enforces business rules.\"\"\"\n    order = Order(customer_id=\"123\")\n\n    with pytest.raises(InvalidOperationError, match=\"empty order\"):\n        order.confirm()\n\ndef test_order_total_always_consistent():\n    \"\"\"Test calculated fields always match items.\"\"\"\n    order = Order(customer_id=\"123\")\n    order.add_item(\"Margherita\", PizzaSize.LARGE, 2, Decimal(\"15.99\"))\n    order.add_item(\"Pepperoni\", PizzaSize.MEDIUM, 1, Decimal(\"13.99\"))\n\n    # Total should always match items\n    expected = (Decimal(\"15.99\") * 2) + Decimal(\"13.99\")\n    assert order.total() == expected\n</code></pre>"},{"location":"concepts/aggregates-entities/#test-domain-events","title":"Test Domain Events","text":"<pre><code>def test_aggregate_raises_events():\n    \"\"\"Test domain events are raised.\"\"\"\n    order = Order(customer_id=\"123\")\n    order.add_item(\"Margherita\", PizzaSize.LARGE, 1, Decimal(\"15.99\"))\n    order.confirm()\n\n    events = order.get_uncommitted_events()\n\n    assert len(events) == 3  # Created, ItemAdded, Confirmed\n    assert isinstance(events[0], OrderCreatedEvent)\n    assert isinstance(events[1], ItemAddedToOrderEvent)\n    assert isinstance(events[2], OrderConfirmedEvent)\n</code></pre>"},{"location":"concepts/aggregates-entities/#common-mistakes","title":"\u26a0\ufe0f Common Mistakes","text":""},{"location":"concepts/aggregates-entities/#1-aggregates-too-large","title":"1. Aggregates Too Large","text":"<pre><code># \u274c WRONG: Everything in one aggregate\nclass Customer(AggregateRoot):\n    def __init__(self):\n        self.orders: List[Order] = []  # All orders!\n        self.payments: List[Payment] = []  # All payments!\n        self.reviews: List[Review] = []  # All reviews!\n# Problem: Loading customer loads EVERYTHING\n\n# \u2705 RIGHT: Separate aggregates\nclass Customer(AggregateRoot):\n    def __init__(self):\n        self.name = \"\"\n        self.email = \"\"\n    # Orders are separate aggregates\n\nclass Order(AggregateRoot):\n    def __init__(self):\n        self.customer_id = \"\"  # Reference by ID\n</code></pre>"},{"location":"concepts/aggregates-entities/#2-public-mutable-collections","title":"2. Public Mutable Collections","text":"<pre><code># \u274c WRONG: Direct access to mutable list\nclass Order(AggregateRoot):\n    def __init__(self):\n        self.items: List[OrderItem] = []  # Public!\n\norder.items.append(OrderItem(...))  # Bypasses validation!\n\n# \u2705 RIGHT: Private collection, controlled access\nclass Order(AggregateRoot):\n    def __init__(self):\n        self._items: List[OrderItem] = []  # Private\n\n    def add_item(self, item: OrderItem):\n        # Validation here\n        self._items.append(item)\n\n    @property\n    def items(self) -&gt; List[OrderItem]:\n        return self._items.copy()  # Return copy\n</code></pre>"},{"location":"concepts/aggregates-entities/#3-violating-aggregate-boundaries","title":"3. Violating Aggregate Boundaries","text":"<pre><code># \u274c WRONG: Modifying another aggregate's internals\norder = order_repository.get(order_id)\ncustomer = customer_repository.get(order.customer_id)\ncustomer.orders.append(order)  # Modifying Customer from Order!\n\n# \u2705 RIGHT: Each aggregate modifies itself\norder = order_repository.get(order_id)\norder.confirm()  # Order modifies itself\n\n# Customer reacts via event\nclass OrderConfirmedHandler:\n    async def handle(self, event: OrderConfirmedEvent):\n        customer = await self.customer_repo.get(event.customer_id)\n        customer.record_order(event.order_id)  # Customer modifies itself\n</code></pre>"},{"location":"concepts/aggregates-entities/#4-loading-multiple-aggregates-in-one-transaction","title":"4. Loading Multiple Aggregates in One Transaction","text":"<pre><code># \u274c WRONG: Modifying two aggregates in one transaction\nasync def transfer_order(order_id: str, new_customer_id: str):\n    order = await order_repo.get(order_id)\n    old_customer = await customer_repo.get(order.customer_id)\n    new_customer = await customer_repo.get(new_customer_id)\n\n    old_customer.remove_order(order_id)\n    new_customer.add_order(order_id)\n    order.customer_id = new_customer_id\n\n    await order_repo.save(order)\n    await customer_repo.save(old_customer)\n    await customer_repo.save(new_customer)\n# Problem: What if one save fails?\n\n# \u2705 RIGHT: Use eventual consistency via events\nasync def transfer_order(order_id: str, new_customer_id: str):\n    order = await order_repo.get(order_id)\n    order.transfer_to_customer(new_customer_id)  # Raises event\n    await order_repo.save(order)\n    # Customers update via event handlers (eventually consistent)\n</code></pre>"},{"location":"concepts/aggregates-entities/#when-not-to-use-aggregates","title":"\ud83d\udeab When NOT to Use Aggregates","text":"<p>Aggregates add complexity. Skip when:</p> <ol> <li>Simple CRUD: No business rules, just data entry</li> <li>Reporting: Read-only queries don't need aggregates</li> <li>No Invariants: If there are no consistency rules</li> <li>Single Entity: If entity has no relationships</li> <li>Prototypes: Quick experiments</li> </ol> <p>For simple cases, plain entities work fine.</p>"},{"location":"concepts/aggregates-entities/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ol> <li>Aggregate Root: Single entry point for aggregate</li> <li>Consistency Boundary: Aggregate maintains invariants</li> <li>Transactional Unit: Save/load aggregate as one unit</li> <li>Small Aggregates: Keep aggregates focused and small</li> <li>ID References: Reference other aggregates by ID, not object</li> </ol>"},{"location":"concepts/aggregates-entities/#aggregates-other-patterns","title":"\ud83d\udd04 Aggregates + Other Patterns","text":"<pre><code>Aggregate Root (Entity)\n  \u2193 uses\nValue Objects (immutable children)\n  \u2193 raises\nDomain Events (state changes)\n  \u2193 persisted by\nRepository (loads/saves aggregate)\n  \u2193 coordinated by\nUnit of Work (transaction boundary)\n</code></pre>"},{"location":"concepts/aggregates-entities/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ul> <li>See it implemented: Tutorial Part 2 builds Order aggregate</li> <li>Understand persistence: Repository Pattern for saving aggregates</li> <li>Event handling: Event-Driven Architecture for aggregate events</li> </ul>"},{"location":"concepts/aggregates-entities/#further-reading","title":"\ud83d\udcda Further Reading","text":"<ul> <li>Vaughn Vernon's \"Implementing Domain-Driven Design\" (Chapter 10)</li> <li>Martin Fowler's \"DDD Aggregate\"</li> <li>Effective Aggregate Design (Vernon)</li> </ul> <p>Previous: \u2190 Domain-Driven Design | Next: CQRS \u2192</p>"},{"location":"concepts/clean-architecture/","title":"Clean Architecture","text":"<p>Time to read: 10 minutes</p> <p>Clean Architecture is a way of organizing code into layers with clear responsibilities and dependencies. It's the foundation of how Neuroglia structures applications.</p>"},{"location":"concepts/clean-architecture/#the-problem-big-ball-of-mud","title":"\u274c The Problem: \"Big Ball of Mud\"","text":"<p>Without architectural guidance, code becomes tangled:</p> <pre><code># \u274c Everything mixed together\nclass OrderService:\n    def create_order(self, data):\n        # UI logic\n        if not data.get(\"customer_name\"):\n            return {\"error\": \"Name required\"}, 400\n\n        # Business logic\n        order = Order()\n        order.customer = data[\"customer_name\"]\n        order.total = data[\"total\"]\n\n        # Database access (MongoDB specific)\n        mongo_client.db.orders.insert_one(order.__dict__)\n\n        # Email sending\n        smtp.send_mail(to=data[\"email\"], subject=\"Order confirmed\")\n\n        # Return HTTP response\n        return {\"order_id\": order.id}, 201\n</code></pre> <p>Problems:</p> <ul> <li>Can't test without database and email server</li> <li>Can't switch from MongoDB to PostgreSQL</li> <li>Business rules mixed with HTTP and infrastructure</li> <li>Changes in UI requirements force changes in business logic</li> </ul>"},{"location":"concepts/clean-architecture/#the-solution-layers-with-dependency-rules","title":"\u2705 The Solution: Layers with Dependency Rules","text":"<p>Clean Architecture organizes code into concentric layers:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502        Infrastructure (Outer)          \u2502  \u2190 Frameworks, DB, External APIs\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502   Application (Orchestration)   \u2502  \u2502  \u2190 Use Cases, Handlers\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502  \u2502\n\u2502  \u2502  \u2502   Domain (Core)         \u2502   \u2502  \u2502  \u2190 Business Rules, Entities\n\u2502  \u2502  \u2502                         \u2502   \u2502  \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nDependency Rule: Inner layers don't know about outer layers\n                 Dependencies point INWARD only\n</code></pre>"},{"location":"concepts/clean-architecture/#the-layers","title":"The Layers","text":"<p>1. Domain (Core) - The Heart</p> <ul> <li>What: Business entities, rules, and logic</li> <li>Depends on: Nothing (pure Python)</li> <li>Example: <code>Order</code>, <code>Customer</code>, <code>Pizza</code> entities with business rules</li> </ul> <pre><code># \u2705 Domain layer - No dependencies on framework or database\nclass Order:\n    def add_pizza(self, pizza: Pizza):\n        if self.status != OrderStatus.PENDING:\n            raise ValueError(\"Cannot modify confirmed orders\")  # Business rule\n        self.items.append(pizza)\n</code></pre> <p>2. Application (Orchestration) - The Use Cases</p> <ul> <li>What: Application-specific business logic, use cases</li> <li>Depends on: Domain only</li> <li>Example: Command handlers, query handlers, application services</li> </ul> <pre><code># \u2705 Application layer - Orchestrates domain operations\nclass PlaceOrderHandler:\n    def __init__(self, order_repository: IOrderRepository):\n        self.repository = order_repository  # Interface, not implementation!\n\n    async def handle(self, command: PlaceOrderCommand):\n        order = Order(command.customer_id)\n        order.add_pizza(command.pizza)\n        await self.repository.save(order)  # Uses interface\n        return order\n</code></pre> <p>3. Infrastructure (Outer) - The Details</p> <ul> <li>What: Frameworks, databases, external services</li> <li>Depends on: Domain and Application (implements their interfaces)</li> <li>Example: MongoDB repositories, HTTP clients, email services</li> </ul> <pre><code># \u2705 Infrastructure layer - Implements domain interfaces\nclass MongoOrderRepository(IOrderRepository):\n    def __init__(self, mongo_client):\n        self.client = mongo_client\n\n    async def save(self, order: Order):\n        # MongoDB-specific implementation\n        await self.client.db.orders.insert_one(order.to_dict())\n</code></pre>"},{"location":"concepts/clean-architecture/#the-dependency-rule","title":"The Dependency Rule","text":"<p>Critical principle: Dependencies point INWARD only.</p> <pre><code>\u2705 ALLOWED:\nApplication \u2192 Domain (handlers use entities)\nInfrastructure \u2192 Domain (repositories implement domain interfaces)\nInfrastructure \u2192 Application (implements handler interfaces)\n\n\u274c FORBIDDEN:\nDomain \u2192 Application (entities don't know about handlers)\nDomain \u2192 Infrastructure (entities don't know about MongoDB)\nApplication \u2192 Infrastructure (handlers use interfaces, not implementations)\n</code></pre>"},{"location":"concepts/clean-architecture/#clean-architecture-in-neuroglia","title":"\ud83d\udd27 Clean Architecture in Neuroglia","text":""},{"location":"concepts/clean-architecture/#project-structure","title":"Project Structure","text":"<p>Neuroglia enforces clean architecture through directory structure:</p> <pre><code>my-app/\n\u251c\u2500\u2500 domain/              # \ud83c\udfdb\ufe0f Domain Layer (Inner)\n\u2502   \u251c\u2500\u2500 entities/        # Business entities\n\u2502   \u251c\u2500\u2500 events/          # Domain events\n\u2502   \u2514\u2500\u2500 repositories/    # Repository INTERFACES (not implementations)\n\u2502\n\u251c\u2500\u2500 application/         # \ud83d\udcbc Application Layer (Middle)\n\u2502   \u251c\u2500\u2500 commands/        # Write operations\n\u2502   \u251c\u2500\u2500 queries/         # Read operations\n\u2502   \u251c\u2500\u2500 events/          # Event handlers\n\u2502   \u2514\u2500\u2500 services/        # Application services\n\u2502\n\u251c\u2500\u2500 integration/         # \ud83d\udd0c Infrastructure Layer (Outer)\n\u2502   \u251c\u2500\u2500 repositories/    # Repository IMPLEMENTATIONS (MongoDB, etc.)\n\u2502   \u2514\u2500\u2500 services/        # External service integrations\n\u2502\n\u2514\u2500\u2500 api/                 # \ud83c\udf10 Presentation Layer (Outer)\n    \u251c\u2500\u2500 controllers/     # REST endpoints\n    \u2514\u2500\u2500 dtos/            # Data transfer objects\n</code></pre>"},{"location":"concepts/clean-architecture/#dependency-flow-example","title":"Dependency Flow Example","text":"<pre><code># 1. Domain defines interface (no implementation)\n# domain/repositories/order_repository.py\nclass IOrderRepository(ABC):\n    @abstractmethod\n    async def save_async(self, order: Order): pass\n\n# 2. Application uses interface (doesn't care about implementation)\n# application/commands/place_order_handler.py\nclass PlaceOrderHandler:\n    def __init__(self, repository: IOrderRepository):  # Interface!\n        self.repository = repository\n\n    async def handle(self, cmd: PlaceOrderCommand):\n        order = Order(cmd.customer_id)\n        await self.repository.save_async(order)  # Uses interface\n\n# 3. Infrastructure implements interface\n# integration/repositories/mongo_order_repository.py\nclass MongoOrderRepository(IOrderRepository):\n    async def save_async(self, order: Order):\n        # MongoDB-specific code here\n        pass\n\n# 4. DI container wires them together at runtime\n# main.py\nservices.add_scoped(IOrderRepository, MongoOrderRepository)\n</code></pre> <p>The magic: Handler never knows about MongoDB! You can swap to PostgreSQL by changing one line in <code>main.py</code>.</p>"},{"location":"concepts/clean-architecture/#testing-benefits","title":"\ud83e\uddea Testing Benefits","text":"<p>Clean Architecture makes testing easy:</p> <pre><code># Test with in-memory repository (no database needed!)\nclass InMemoryOrderRepository(IOrderRepository):\n    def __init__(self):\n        self.orders = {}\n\n    async def save_async(self, order: Order):\n        self.orders[order.id] = order\n\n# Test handler\nasync def test_place_order():\n    repo = InMemoryOrderRepository()  # No MongoDB!\n    handler = PlaceOrderHandler(repo)\n\n    cmd = PlaceOrderCommand(customer_id=\"123\", pizza=\"Margherita\")\n    result = await handler.handle(cmd)\n\n    assert result.is_success\n    assert len(repo.orders) == 1  # Verify order was saved\n</code></pre>"},{"location":"concepts/clean-architecture/#common-mistakes","title":"\u26a0\ufe0f Common Mistakes","text":""},{"location":"concepts/clean-architecture/#1-domain-depending-on-infrastructure","title":"1. Domain Depending on Infrastructure","text":"<pre><code># \u274c WRONG: Entity knows about MongoDB\nclass Order:\n    def save(self):\n        mongo_client.db.orders.insert_one(self.__dict__)  # NO!\n\n# \u2705 RIGHT: Entity is pure business logic\nclass Order:\n    def add_pizza(self, pizza):\n        if self.status != OrderStatus.PENDING:\n            raise ValueError(\"Cannot modify confirmed orders\")\n</code></pre>"},{"location":"concepts/clean-architecture/#2-application-depending-on-concrete-implementations","title":"2. Application Depending on Concrete Implementations","text":"<pre><code># \u274c WRONG: Handler depends on concrete MongoDB repository\nclass PlaceOrderHandler:\n    def __init__(self):\n        self.repo = MongoOrderRepository()  # Tight coupling!\n\n# \u2705 RIGHT: Handler depends on interface\nclass PlaceOrderHandler:\n    def __init__(self, repo: IOrderRepository):  # Interface!\n        self.repo = repo\n</code></pre>"},{"location":"concepts/clean-architecture/#3-putting-everything-in-domain","title":"3. Putting Everything in Domain","text":"<pre><code># \u274c WRONG: Email sending in domain entity\nclass Order:\n    def confirm(self):\n        self.status = OrderStatus.CONFIRMED\n        EmailService.send_confirmation(self.customer)  # NO!\n\n# \u2705 RIGHT: Domain events, infrastructure listens\nclass Order:\n    def confirm(self):\n        self.status = OrderStatus.CONFIRMED\n        self.raise_event(OrderConfirmedEvent(...))  # Yes!\n\n# Infrastructure reacts to event\nclass OrderConfirmedHandler:\n    async def handle(self, event: OrderConfirmedEvent):\n        await self.email_service.send_confirmation(...)\n</code></pre>"},{"location":"concepts/clean-architecture/#when-not-to-use","title":"\ud83d\udeab When NOT to Use","text":"<p>Clean Architecture has overhead. Consider simpler approaches when:</p> <ol> <li>Prototype/Throwaway Code: If you're just testing an idea</li> <li>Tiny Scripts: &lt; 100 lines, no tests, no maintenance</li> <li>CRUD Apps: Simple database operations with no business logic</li> <li>Single Developer, Short Timeline: Clean Architecture shines in teams and long-term projects</li> </ol> <p>For small apps, start simple and refactor to clean architecture when complexity grows.</p>"},{"location":"concepts/clean-architecture/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ol> <li>Layers: Domain (core) \u2192 Application (use cases) \u2192 Infrastructure (details)</li> <li>Dependency Rule: Dependencies point INWARD only</li> <li>Interfaces: Inner layers define interfaces, outer layers implement</li> <li>Testability: Swap real implementations with test doubles</li> <li>Flexibility: Change databases/frameworks without touching business logic</li> </ol>"},{"location":"concepts/clean-architecture/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ul> <li>Apply it: Tutorial Part 1 sets up clean architecture</li> <li>Understand DI: Dependency Injection makes this work</li> <li>See it work: Domain-Driven Design for the domain layer</li> </ul>"},{"location":"concepts/clean-architecture/#further-reading","title":"\ud83d\udcda Further Reading","text":"<ul> <li>Robert C. Martin's \"Clean Architecture\" (book)</li> <li>The Clean Architecture (blog post)</li> <li>Neuroglia tutorials - see it in practice</li> </ul> <p>Previous: \u2190 Core Concepts Index | Next: Dependency Injection \u2192</p>"},{"location":"concepts/cqrs/","title":"CQRS (Command Query Responsibility Segregation)","text":"<p>Time to read: 13 minutes</p> <p>CQRS separates write operations (Commands) from read operations (Queries). Instead of one model doing everything, you have specialized models for reading and writing.</p>"},{"location":"concepts/cqrs/#the-problem-one-model-for-everything","title":"\u274c The Problem: One Model for Everything","text":"<p>Traditional approach uses same model for reads and writes:</p> <pre><code># \u274c Single model handles everything\nclass OrderService:\n    def __init__(self, repository: OrderRepository):\n        self.repository = repository\n\n    # Write operation\n    def create_order(self, customer_id: str, items: List[dict]) -&gt; Order:\n        order = Order(customer_id)\n        for item in items:\n            order.add_item(item['pizza'], item['quantity'])\n        self.repository.save(order)\n        return order\n\n    # Read operation\n    def get_order(self, order_id: str) -&gt; Order:\n        return self.repository.get_by_id(order_id)\n\n    # Read operation\n    def get_customer_orders(self, customer_id: str) -&gt; List[Order]:\n        return self.repository.find_by_customer(customer_id)\n\n    # Read operation (complex query)\n    def get_order_statistics(self, date_from, date_to):\n        orders = self.repository.find_by_date_range(date_from, date_to)\n        # Complex aggregation logic here...\n        return statistics\n</code></pre> <p>Problems:</p> <ol> <li>Conflicting concerns: Write needs validation, reads need speed</li> <li>Complex queries: Domain model not optimized for reporting</li> <li>Scalability: Can't scale reads and writes independently</li> <li>Performance: Writes and reads contend for same resources</li> <li>Security: Same permissions for reads and writes</li> </ol>"},{"location":"concepts/cqrs/#the-solution-separate-read-and-write-models","title":"\u2705 The Solution: Separate Read and Write Models","text":"<p>Split operations into Commands (write) and Queries (read):</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 Application                    \u2502\n\u2502                                                \u2502\n\u2502  Commands (Write)        Queries (Read)       \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 PlaceOrder     \u2502      \u2502 GetOrderById    \u2502 \u2502\n\u2502  \u2502 ConfirmOrder   \u2502      \u2502 GetCustomerOrds \u2502 \u2502\n\u2502  \u2502 CancelOrder    \u2502      \u2502 GetStatistics   \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502           \u2502                       \u2502           \u2502\n\u2502           \u25bc                       \u25bc           \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 Write Model    \u2502      \u2502 Read Model      \u2502 \u2502\n\u2502  \u2502 (Domain Agg)   \u2502      \u2502 (Optimized DTO) \u2502 \u2502\n\u2502  \u2502 - Rich domain  \u2502      \u2502 - Flat, denorm  \u2502 \u2502\n\u2502  \u2502 - Validations  \u2502      \u2502 - Fast queries  \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502           \u2502                       \u2502           \u2502\n\u2502           \u25bc                       \u25bc           \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 Write DB       \u2502      \u2502 Read DB         \u2502 \u2502\n\u2502  \u2502 (Normalized)   \u2502      \u2502 (Denormalized)  \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502           \u2502                       \u25b2           \u2502\n\u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Events \u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2502\n\u2502                                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Benefits:</p> <ol> <li>Optimized models: Write model for consistency, read model for speed</li> <li>Independent scaling: Scale reads and writes separately</li> <li>Simpler code: Each operation has single purpose</li> <li>Better performance: Reads don't lock writes</li> <li>Flexibility: Different databases for reads and writes</li> </ol>"},{"location":"concepts/cqrs/#commands-write-operations","title":"\ud83c\udfd7\ufe0f Commands: Write Operations","text":"<p>Commands represent intentions to change state:</p> <pre><code>from dataclasses import dataclass\nfrom neuroglia.mediation import Command, OperationResult\n\n@dataclass\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"\n    Command: Imperative name (verb).\n    Expresses intention to change state.\n    \"\"\"\n    customer_id: str\n    items: List[OrderItemDto]\n    delivery_address: DeliveryAddressDto\n\n@dataclass\nclass ConfirmOrderCommand(Command[OperationResult]):\n    \"\"\"Command to confirm an order.\"\"\"\n    order_id: str\n\n@dataclass\nclass CancelOrderCommand(Command[OperationResult]):\n    \"\"\"Command to cancel an order.\"\"\"\n    order_id: str\n    reason: str\n</code></pre> <p>Command Characteristics:</p> <ul> <li>Imperative names: <code>PlaceOrder</code>, <code>ConfirmOrder</code>, <code>CancelOrder</code> (actions)</li> <li>Write operations: Change system state</li> <li>Can fail: Validation, business rules</li> <li>Return results: Success/failure, errors</li> <li>Single purpose: Do one thing</li> </ul>"},{"location":"concepts/cqrs/#queries-read-operations","title":"\ud83c\udfd7\ufe0f Queries: Read Operations","text":"<p>Queries represent requests for data:</p> <pre><code>from dataclasses import dataclass\nfrom neuroglia.mediation import Query\n\n@dataclass\nclass GetOrderByIdQuery(Query[OrderDto]):\n    \"\"\"\n    Query: Question-like name.\n    Requests data without changing state.\n    \"\"\"\n    order_id: str\n\n@dataclass\nclass GetCustomerOrdersQuery(Query[List[OrderDto]]):\n    \"\"\"Query to get customer's orders.\"\"\"\n    customer_id: str\n    status: Optional[OrderStatus] = None\n\n@dataclass\nclass GetOrderStatisticsQuery(Query[OrderStatistics]):\n    \"\"\"Query for order statistics.\"\"\"\n    date_from: datetime\n    date_to: datetime\n</code></pre> <p>Query Characteristics:</p> <ul> <li>Question names: <code>GetOrderById</code>, <code>GetCustomerOrders</code> (questions)</li> <li>Read-only: Don't change state</li> <li>Never fail: Return empty/null if not found</li> <li>Return data: DTOs, lists, aggregates</li> <li>Can be cached: Since they don't change state</li> </ul>"},{"location":"concepts/cqrs/#cqrs-in-neuroglia","title":"\ud83d\udd27 CQRS in Neuroglia","text":""},{"location":"concepts/cqrs/#command-handlers","title":"Command Handlers","text":"<p>Handle write operations:</p> <pre><code>from neuroglia.mediation import CommandHandler, OperationResult\nfrom neuroglia.mapping import Mapper\n\nclass PlaceOrderCommandHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    \"\"\"Handles PlaceOrderCommand - write operation.\"\"\"\n\n    def __init__(self,\n                 repository: IOrderRepository,\n                 mapper: Mapper):\n        self.repository = repository\n        self.mapper = mapper\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        \"\"\"\n        Command handler:\n        1. Validate\n        2. Create domain entity\n        3. Apply business rules\n        4. Persist\n        5. Return result\n        \"\"\"\n        # 1. Validate\n        if not command.items:\n            return self.bad_request(\"Order must have at least one item\")\n\n        # 2. Create domain entity\n        order = Order(command.customer_id)\n\n        # 3. Apply business rules (through domain model)\n        for item_dto in command.items:\n            order.add_item(\n                item_dto.pizza_name,\n                item_dto.size,\n                item_dto.quantity,\n                item_dto.price\n            )\n\n        order.set_delivery_address(self.mapper.map(\n            command.delivery_address,\n            DeliveryAddress\n        ))\n\n        # 4. Persist\n        await self.repository.save_async(order)\n\n        # 5. Return result\n        order_dto = self.mapper.map(order, OrderDto)\n        return self.created(order_dto)\n</code></pre>"},{"location":"concepts/cqrs/#query-handlers","title":"Query Handlers","text":"<p>Handle read operations:</p> <pre><code>from neuroglia.mediation import QueryHandler\n\nclass GetOrderByIdQueryHandler(QueryHandler[GetOrderByIdQuery, OrderDto]):\n    \"\"\"Handles GetOrderByIdQuery - read operation.\"\"\"\n\n    def __init__(self,\n                 repository: IOrderRepository,\n                 mapper: Mapper):\n        self.repository = repository\n        self.mapper = mapper\n\n    async def handle_async(self, query: GetOrderByIdQuery) -&gt; Optional[OrderDto]:\n        \"\"\"\n        Query handler:\n        1. Retrieve data\n        2. Transform to DTO\n        3. Return (don't validate, don't modify)\n        \"\"\"\n        # 1. Retrieve\n        order = await self.repository.get_by_id_async(query.order_id)\n\n        if not order:\n            return None\n\n        # 2. Transform\n        return self.mapper.map(order, OrderDto)\n\nclass GetCustomerOrdersQueryHandler(QueryHandler[GetCustomerOrdersQuery, List[OrderDto]]):\n    \"\"\"Handles GetCustomerOrdersQuery - read operation.\"\"\"\n\n    def __init__(self,\n                 repository: IOrderRepository,\n                 mapper: Mapper):\n        self.repository = repository\n        self.mapper = mapper\n\n    async def handle_async(self, query: GetCustomerOrdersQuery) -&gt; List[OrderDto]:\n        \"\"\"Optimized read - may use denormalized read model.\"\"\"\n        # Query optimized read model (not domain model!)\n        orders = await self.repository.find_by_customer_async(\n            query.customer_id,\n            status=query.status\n        )\n\n        return [self.mapper.map(o, OrderDto) for o in orders]\n</code></pre>"},{"location":"concepts/cqrs/#using-mediator","title":"Using Mediator","text":"<p>Mediator dispatches commands and queries to handlers:</p> <pre><code>from neuroglia.mediation import Mediator\n\nclass OrdersController:\n    def __init__(self, mediator: Mediator):\n        self.mediator = mediator\n\n    @post(\"/orders\")\n    async def create_order(self, dto: CreateOrderDto) -&gt; OrderDto:\n        \"\"\"Write operation - use command.\"\"\"\n        command = PlaceOrderCommand(\n            customer_id=dto.customer_id,\n            items=dto.items,\n            delivery_address=dto.delivery_address\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)  # Returns 201 Created\n\n    @get(\"/orders/{order_id}\")\n    async def get_order(self, order_id: str) -&gt; OrderDto:\n        \"\"\"Read operation - use query.\"\"\"\n        query = GetOrderByIdQuery(order_id=order_id)\n\n        result = await self.mediator.execute_async(query)\n\n        if not result:\n            raise HTTPException(status_code=404, detail=\"Order not found\")\n\n        return result  # Returns 200 OK\n\n    @get(\"/customers/{customer_id}/orders\")\n    async def get_customer_orders(self, customer_id: str) -&gt; List[OrderDto]:\n        \"\"\"Read operation - use query.\"\"\"\n        query = GetCustomerOrdersQuery(customer_id=customer_id)\n\n        return await self.mediator.execute_async(query)\n</code></pre>"},{"location":"concepts/cqrs/#advanced-separate-read-and-write-models","title":"\ud83d\ude80 Advanced: Separate Read and Write Models","text":"<p>For high-scale systems, use different databases:</p> <pre><code># Write Model: Domain aggregate (normalized, consistent)\nclass Order(AggregateRoot):\n    \"\"\"Write model - rich domain model.\"\"\"\n    def __init__(self, customer_id: str):\n        super().__init__()\n        self.customer_id = customer_id\n        self.items: List[OrderItem] = []\n        self.status = OrderStatus.PENDING\n\n    def add_item(self, pizza_name: str, ...):\n        # Business logic, validation\n        pass\n\n# Write Repository: Saves domain aggregates\nclass OrderWriteRepository:\n    \"\"\"Saves to write database (normalized).\"\"\"\n    async def save_async(self, order: Order):\n        await self.mongo_collection.insert_one({\n            \"id\": order.id,\n            \"customer_id\": order.customer_id,\n            \"items\": [item.to_dict() for item in order.items],\n            \"status\": order.status.value\n        })\n\n# Read Model: Flat DTO (denormalized, fast)\n@dataclass\nclass OrderReadModel:\n    \"\"\"Read model - optimized for queries.\"\"\"\n    order_id: str\n    customer_id: str\n    customer_name: str  # Denormalized from Customer\n    customer_email: str  # Denormalized from Customer\n    total: Decimal\n    item_count: int\n    status: str\n    created_at: datetime\n    # Flattened, no joins needed!\n\n# Read Repository: Queries read model\nclass OrderReadRepository:\n    \"\"\"Queries from read database (denormalized).\"\"\"\n    async def get_by_id_async(self, order_id: str) -&gt; OrderReadModel:\n        # Query denormalized view - very fast!\n        doc = await self.read_collection.find_one({\"order_id\": order_id})\n        return OrderReadModel(**doc)\n\n# Synchronize via events\nclass OrderConfirmedHandler:\n    \"\"\"Updates read model when write model changes.\"\"\"\n    async def handle(self, event: OrderConfirmedEvent):\n        # Update read model\n        await self.read_repo.update({\n            \"order_id\": event.order_id,\n            \"status\": \"confirmed\",\n            \"confirmed_at\": datetime.utcnow()\n        })\n</code></pre>"},{"location":"concepts/cqrs/#testing-cqrs","title":"\ud83e\uddea Testing CQRS","text":""},{"location":"concepts/cqrs/#test-command-handlers","title":"Test Command Handlers","text":"<pre><code>async def test_place_order_command():\n    \"\"\"Test write operation.\"\"\"\n    # Arrange\n    mock_repo = Mock(spec=IOrderRepository)\n    handler = PlaceOrderCommandHandler(mock_repo, mapper)\n\n    command = PlaceOrderCommand(\n        customer_id=\"123\",\n        items=[OrderItemDto(\"Margherita\", PizzaSize.LARGE, 1, Decimal(\"15.99\"))],\n        delivery_address=DeliveryAddressDto(\"123 Main St\", \"City\", \"12345\")\n    )\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n    assert result.status_code == 201\n    mock_repo.save_async.assert_called_once()\n\nasync def test_place_order_validation():\n    \"\"\"Test command validation.\"\"\"\n    handler = PlaceOrderCommandHandler(mock_repo, mapper)\n\n    command = PlaceOrderCommand(\n        customer_id=\"123\",\n        items=[],  # Invalid: no items\n        delivery_address=DeliveryAddressDto(\"123 Main St\", \"City\", \"12345\")\n    )\n\n    result = await handler.handle_async(command)\n\n    assert not result.is_success\n    assert result.status_code == 400\n    assert \"at least one item\" in result.error_message\n</code></pre>"},{"location":"concepts/cqrs/#test-query-handlers","title":"Test Query Handlers","text":"<pre><code>async def test_get_order_query():\n    \"\"\"Test read operation.\"\"\"\n    # Arrange\n    mock_repo = Mock(spec=IOrderRepository)\n    mock_repo.get_by_id_async.return_value = create_test_order()\n\n    handler = GetOrderByIdQueryHandler(mock_repo, mapper)\n    query = GetOrderByIdQuery(order_id=\"123\")\n\n    # Act\n    result = await handler.handle_async(query)\n\n    # Assert\n    assert result is not None\n    assert result.order_id == \"123\"\n    mock_repo.get_by_id_async.assert_called_once_with(\"123\")\n\nasync def test_get_order_not_found():\n    \"\"\"Test query with no result.\"\"\"\n    mock_repo = Mock(spec=IOrderRepository)\n    mock_repo.get_by_id_async.return_value = None\n\n    handler = GetOrderByIdQueryHandler(mock_repo, mapper)\n    query = GetOrderByIdQuery(order_id=\"999\")\n\n    result = await handler.handle_async(query)\n\n    assert result is None  # Query returns None, doesn't raise\n</code></pre>"},{"location":"concepts/cqrs/#common-mistakes","title":"\u26a0\ufe0f Common Mistakes","text":""},{"location":"concepts/cqrs/#1-queries-that-modify-state","title":"1. Queries that Modify State","text":"<pre><code># \u274c WRONG: Query modifies state\nclass GetOrderByIdQueryHandler(QueryHandler):\n    async def handle_async(self, query):\n        order = await self.repository.get_by_id_async(query.order_id)\n        order.last_viewed = datetime.utcnow()  # NO! Modifying state in query!\n        await self.repository.save_async(order)\n        return order\n\n# \u2705 RIGHT: Queries are read-only\nclass GetOrderByIdQueryHandler(QueryHandler):\n    async def handle_async(self, query):\n        order = await self.repository.get_by_id_async(query.order_id)\n        return self.mapper.map(order, OrderDto)  # Read-only\n</code></pre>"},{"location":"concepts/cqrs/#2-commands-that-return-data","title":"2. Commands that Return Data","text":"<pre><code># \u274c WRONG: Command returns full entity\nclass PlaceOrderCommand(Command[Order]):  # Returns entity\n    pass\n\n# \u2705 RIGHT: Command returns result/DTO\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):  # Returns DTO\n    pass\n</code></pre>"},{"location":"concepts/cqrs/#3-business-logic-in-query-handlers","title":"3. Business Logic in Query Handlers","text":"<pre><code># \u274c WRONG: Validation in query\nclass GetOrderQueryHandler(QueryHandler):\n    async def handle_async(self, query):\n        if not query.order_id:\n            raise ValueError(\"Order ID required\")  # Query shouldn't validate!\n        return await self.repository.get_by_id_async(query.order_id)\n\n# \u2705 RIGHT: Validation in command only\nclass ConfirmOrderCommandHandler(CommandHandler):\n    async def handle_async(self, command):\n        if not command.order_id:\n            return self.bad_request(\"Order ID required\")  # Validation in command\n        # ...\n</code></pre>"},{"location":"concepts/cqrs/#when-not-to-use-cqrs","title":"\ud83d\udeab When NOT to Use CQRS","text":"<p>CQRS adds complexity. Skip when:</p> <ol> <li>Simple CRUD: Basic create/read/update/delete</li> <li>Low Scale: Single-server application</li> <li>No Specialized Reads: Reads and writes have same needs</li> <li>Prototypes: Quick experiments</li> <li>Small Team: Learning curve not worth it</li> </ol> <p>For simple apps, traditional layered architecture works fine.</p>"},{"location":"concepts/cqrs/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ol> <li>Separation: Commands write, queries read</li> <li>Optimization: Each side optimized for its purpose</li> <li>Scalability: Scale reads and writes independently</li> <li>Clarity: Single responsibility per operation</li> <li>Flexibility: Different models, databases possible</li> </ol>"},{"location":"concepts/cqrs/#cqrs-other-patterns","title":"\ud83d\udd04 CQRS + Other Patterns","text":"<pre><code>Command \u2192 Command Handler \u2192 Domain Model \u2192 Write DB\n                                    \u2193\n                                 Event\n                                    \u2193\n                               Event Handler \u2192 Read Model \u2192 Read DB\n                                                    \u2191\nQuery \u2192 Query Handler \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"concepts/cqrs/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ul> <li>Implement it: Tutorial Part 3 builds CQRS</li> <li>Dispatch requests: Mediator Pattern routes commands/queries</li> <li>Handle events: Event-Driven Architecture synchronizes models</li> </ul>"},{"location":"concepts/cqrs/#further-reading","title":"\ud83d\udcda Further Reading","text":"<ul> <li>Greg Young's CQRS Documents</li> <li>Martin Fowler's CQRS</li> <li>Microsoft's CQRS Pattern</li> </ul> <p>Previous: \u2190 Aggregates &amp; Entities | Next: Mediator Pattern \u2192</p>"},{"location":"concepts/dependency-injection/","title":"Dependency Injection","text":"<p>Time to read: 12 minutes</p> <p>Dependency Injection (DI) is a technique where objects receive their dependencies instead of creating them. It's the \"glue\" that makes clean architecture work in Neuroglia.</p>"},{"location":"concepts/dependency-injection/#the-problem-hard-coded-dependencies","title":"\u274c The Problem: Hard-Coded Dependencies","text":"<p>Without DI, classes create their own dependencies:</p> <pre><code># \u274c Handler creates its own dependencies\nclass PlaceOrderHandler:\n    def __init__(self):\n        # Creates concrete MongoDB repository\n        self.repository = MongoOrderRepository()\n        self.email_service = SmtpEmailService()\n        self.payment_service = StripePaymentService()\n\n    async def handle(self, command):\n        order = Order(command.customer_id)\n        await self.repository.save(order)\n        await self.email_service.send_confirmation(order)\n        await self.payment_service.charge(order)\n</code></pre> <p>Problems:</p> <ol> <li>Can't test: Tests need real MongoDB, SMTP server, and Stripe account</li> <li>Can't reuse: Tightly coupled to specific implementations</li> <li>Can't configure: Same implementations for dev, test, and prod</li> <li>Can't mock: No way to isolate behavior for testing</li> <li>Violates dependency rule: Application layer knows about infrastructure details</li> </ol>"},{"location":"concepts/dependency-injection/#the-solution-inject-dependencies","title":"\u2705 The Solution: Inject Dependencies","text":"<p>Pass dependencies as constructor parameters:</p> <pre><code># \u2705 Handler receives dependencies\nclass PlaceOrderHandler:\n    def __init__(self,\n                 repository: IOrderRepository,        # Interface\n                 email_service: IEmailService,        # Interface\n                 payment_service: IPaymentService):   # Interface\n        self.repository = repository\n        self.email_service = email_service\n        self.payment_service = payment_service\n\n    async def handle(self, command):\n        order = Order(command.customer_id)\n        await self.repository.save(order)\n        await self.email_service.send_confirmation(order)\n        await self.payment_service.charge(order)\n</code></pre> <p>Benefits:</p> <ol> <li>Testable: Inject test doubles (mocks, fakes)</li> <li>Flexible: Swap implementations (MongoDB \u2192 PostgreSQL)</li> <li>Configurable: Different implementations per environment</li> <li>Mockable: Unit test in isolation</li> <li>Clean: Respects dependency rule (uses interfaces)</li> </ol>"},{"location":"concepts/dependency-injection/#who-creates-the-dependencies","title":"Who Creates the Dependencies?","text":"<p>A DI container (Neuroglia's <code>ServiceProvider</code>) creates and wires dependencies:</p> <pre><code># Configure container\nservices = ServiceCollection()\nservices.add_scoped(IOrderRepository, MongoOrderRepository)\nservices.add_scoped(IEmailService, SmtpEmailService)\nservices.add_scoped(IPaymentService, StripePaymentService)\n\n# Container creates handler with dependencies\nhandler = services.build_provider().get_service(PlaceOrderHandler)\n# Container automatically injects: MongoOrderRepository, SmtpEmailService, StripePaymentService\n</code></pre>"},{"location":"concepts/dependency-injection/#dependency-injection-in-neuroglia","title":"\ud83d\udd27 Dependency Injection in Neuroglia","text":""},{"location":"concepts/dependency-injection/#service-registration","title":"Service Registration","text":"<p>Neuroglia uses a <code>ServiceCollection</code> to register dependencies:</p> <pre><code>from neuroglia.dependency_injection import ServiceCollection, ServiceLifetime\n\n# Create container\nservices = ServiceCollection()\n\n# Register services with different lifetimes\nservices.add_singleton(ConfigService)       # Created once, shared forever\nservices.add_scoped(OrderRepository)        # Created once per request\nservices.add_transient(EmailService)        # Created every time requested\n</code></pre>"},{"location":"concepts/dependency-injection/#service-lifetimes","title":"Service Lifetimes","text":"<p>1. Singleton - One instance for entire application</p> <pre><code>services.add_singleton(ConfigService)\n\n# Same instance everywhere\nconfig1 = provider.get_service(ConfigService)\nconfig2 = provider.get_service(ConfigService)\nassert config1 is config2  # True - same object\n</code></pre> <p>Use when: Configuration, caches, shared state</p> <p>2. Scoped - One instance per request/scope</p> <pre><code>services.add_scoped(OrderRepository)\n\n# Same instance within a scope (HTTP request)\nwith provider.create_scope() as scope:\n    repo1 = scope.get_service(OrderRepository)\n    repo2 = scope.get_service(OrderRepository)\n    assert repo1 is repo2  # True - same object in scope\n\n# Different instance in different scope\nwith provider.create_scope() as scope2:\n    repo3 = scope2.get_service(OrderRepository)\n    assert repo1 is not repo3  # True - different scope\n</code></pre> <p>Use when: Repositories, database connections, per-request state</p> <p>3. Transient - New instance every time</p> <pre><code>services.add_transient(EmailService)\n\n# Different instance every time\nemail1 = provider.get_service(EmailService)\nemail2 = provider.get_service(EmailService)\nassert email1 is not email2  # True - different objects\n</code></pre> <p>Use when: Lightweight services, stateless operations</p>"},{"location":"concepts/dependency-injection/#constructor-injection-pattern","title":"Constructor Injection Pattern","text":"<p>Neuroglia automatically injects dependencies through constructors:</p> <pre><code># 1. Define interfaces (domain layer)\nclass IOrderRepository(ABC):\n    @abstractmethod\n    async def save_async(self, order: Order): pass\n\nclass IEmailService(ABC):\n    @abstractmethod\n    async def send_async(self, to: str, message: str): pass\n\n# 2. Implement interfaces (infrastructure layer)\nclass MongoOrderRepository(IOrderRepository):\n    async def save_async(self, order: Order):\n        # MongoDB implementation\n        pass\n\nclass SmtpEmailService(IEmailService):\n    async def send_async(self, to: str, message: str):\n        # SMTP implementation\n        pass\n\n# 3. Handler requests dependencies (application layer)\nclass PlaceOrderHandler:\n    def __init__(self,\n                 repository: IOrderRepository,      # Will be injected\n                 email_service: IEmailService):     # Will be injected\n        self.repository = repository\n        self.email_service = email_service\n\n    async def handle(self, command: PlaceOrderCommand):\n        order = Order(command.customer_id, command.items)\n        await self.repository.save_async(order)\n        await self.email_service.send_async(order.customer.email, \"Order confirmed\")\n\n# 4. Register with DI container\nservices = ServiceCollection()\nservices.add_scoped(IOrderRepository, MongoOrderRepository)\nservices.add_scoped(IEmailService, SmtpEmailService)\nservices.add_scoped(PlaceOrderHandler)  # Container auto-wires dependencies\n\n# 5. Resolve and use\nprovider = services.build_provider()\nhandler = provider.get_service(PlaceOrderHandler)\n# handler.repository is MongoOrderRepository instance\n# handler.email_service is SmtpEmailService instance\n</code></pre>"},{"location":"concepts/dependency-injection/#registration-patterns","title":"Registration Patterns","text":"<p>Interface \u2192 Implementation</p> <pre><code>services.add_scoped(IOrderRepository, MongoOrderRepository)\n# When someone asks for IOrderRepository, give them MongoOrderRepository\n</code></pre> <p>Concrete Class</p> <pre><code>services.add_scoped(OrderService)\n# Register and resolve by concrete class\n</code></pre> <p>Factory Function</p> <pre><code>def create_email_service(provider):\n    config = provider.get_service(ConfigService)\n    return SmtpEmailService(config.smtp_host, config.smtp_port)\n\nservices.add_scoped(IEmailService, factory=create_email_service)\n# Use factory for complex initialization\n</code></pre>"},{"location":"concepts/dependency-injection/#real-world-example-marios-pizzeria","title":"\ud83c\udfd7\ufe0f Real-World Example: Mario's Pizzeria","text":"<pre><code># main.py - Application startup\nfrom neuroglia.hosting.web import WebApplicationBuilder\n\ndef create_app():\n    builder = WebApplicationBuilder()\n    services = builder.services\n\n    # Register domain services\n    services.add_scoped(IOrderRepository, MongoOrderRepository)\n    services.add_scoped(ICustomerRepository, MongoCustomerRepository)\n    services.add_scoped(IMenuRepository, MongoMenuRepository)\n\n    # Register application services\n    services.add_scoped(OrderService)\n    services.add_scoped(CustomerService)\n\n    # Register infrastructure\n    services.add_singleton(ConfigService)\n    services.add_scoped(IEmailService, SendGridEmailService)\n    services.add_scoped(IPaymentService, StripePaymentService)\n\n    # Register handlers (mediator does this automatically)\n    services.add_mediator()\n\n    # Register controllers\n    services.add_controllers([\"api.controllers\"])\n\n    return builder.build()\n\n# Controller automatically gets dependencies\nclass OrdersController(ControllerBase):\n    def __init__(self,\n                 service_provider: ServiceProvider,\n                 mapper: Mapper,\n                 mediator: Mediator):  # All injected!\n        super().__init__(service_provider, mapper, mediator)\n\n    @post(\"/orders\")\n    async def create_order(self, dto: CreateOrderDto):\n        command = self.mapper.map(dto, PlaceOrderCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"concepts/dependency-injection/#testing-with-di","title":"\ud83e\uddea Testing with DI","text":""},{"location":"concepts/dependency-injection/#unit-tests-inject-mocks","title":"Unit Tests: Inject Mocks","text":"<pre><code>from unittest.mock import Mock\n\nasync def test_place_order_handler():\n    # Create test doubles\n    mock_repo = Mock(spec=IOrderRepository)\n    mock_email = Mock(spec=IEmailService)\n\n    # Inject mocks\n    handler = PlaceOrderHandler(mock_repo, mock_email)\n\n    # Test\n    command = PlaceOrderCommand(customer_id=\"123\", items=[...])\n    await handler.handle(command)\n\n    # Verify behavior\n    mock_repo.save_async.assert_called_once()\n    mock_email.send_async.assert_called_once()\n</code></pre>"},{"location":"concepts/dependency-injection/#integration-tests-inject-test-implementations","title":"Integration Tests: Inject Test Implementations","text":"<pre><code>async def test_order_workflow():\n    # Use in-memory implementations for integration testing\n    services = ServiceCollection()\n    services.add_scoped(IOrderRepository, InMemoryOrderRepository)\n    services.add_scoped(IEmailService, FakeEmailService)\n\n    provider = services.build_provider()\n    handler = provider.get_service(PlaceOrderHandler)\n\n    # Test with real workflow (no external dependencies)\n    command = PlaceOrderCommand(customer_id=\"123\", items=[...])\n    result = await handler.handle(command)\n\n    assert result.is_success\n</code></pre>"},{"location":"concepts/dependency-injection/#common-mistakes","title":"\u26a0\ufe0f Common Mistakes","text":""},{"location":"concepts/dependency-injection/#1-mixing-service-lifetimes-incorrectly","title":"1. Mixing Service Lifetimes Incorrectly","text":"<pre><code># \u274c WRONG: Singleton depends on Scoped\nclass ConfigService:  # Singleton\n    def __init__(self, repository: IOrderRepository):  # Scoped!\n        self.repository = repository\n\nservices.add_singleton(ConfigService)\nservices.add_scoped(IOrderRepository, MongoOrderRepository)\n# ConfigService lives forever, but OrderRepository should be per-request!\n</code></pre> <p>Rule: Higher lifetime can't depend on lower lifetime.</p> <pre><code>\u2705 Singleton \u2192 Singleton\n\u2705 Scoped \u2192 Singleton\n\u2705 Scoped \u2192 Scoped\n\u2705 Transient \u2192 Singleton\n\u2705 Transient \u2192 Scoped\n\u2705 Transient \u2192 Transient\n\n\u274c Singleton \u2192 Scoped\n\u274c Singleton \u2192 Transient\n\u274c Scoped \u2192 Transient\n</code></pre>"},{"location":"concepts/dependency-injection/#2-registering-concrete-implementation-instead-of-interface","title":"2. Registering Concrete Implementation Instead of Interface","text":"<pre><code># \u274c WRONG: Handler depends on concrete class\nclass PlaceOrderHandler:\n    def __init__(self, repository: MongoOrderRepository):  # Concrete!\n        self.repository = repository\n\n# \u2705 RIGHT: Handler depends on interface\nclass PlaceOrderHandler:\n    def __init__(self, repository: IOrderRepository):  # Interface!\n        self.repository = repository\n\nservices.add_scoped(IOrderRepository, MongoOrderRepository)\n</code></pre>"},{"location":"concepts/dependency-injection/#3-creating-dependencies-manually","title":"3. Creating Dependencies Manually","text":"<pre><code># \u274c WRONG: Creating dependency manually\nclass OrdersController:\n    def __init__(self, service_provider: ServiceProvider):\n        self.repository = MongoOrderRepository()  # NO!\n\n# \u2705 RIGHT: Let container inject\nclass OrdersController:\n    def __init__(self,\n                 service_provider: ServiceProvider,\n                 repository: IOrderRepository):  # Injected!\n        super().__init__(service_provider)\n        self.repository = repository\n</code></pre>"},{"location":"concepts/dependency-injection/#4-circular-dependencies","title":"4. Circular Dependencies","text":"<pre><code># \u274c WRONG: A depends on B, B depends on A\nclass ServiceA:\n    def __init__(self, service_b: ServiceB): pass\n\nclass ServiceB:\n    def __init__(self, service_a: ServiceA): pass\n# Container can't resolve this!\n\n# \u2705 RIGHT: Introduce abstraction or event-driven communication\nclass ServiceA:\n    def __init__(self, event_bus: EventBus):\n        self.event_bus = event_bus\n        # Use events instead of direct dependency\n</code></pre>"},{"location":"concepts/dependency-injection/#when-not-to-use-di","title":"\ud83d\udeab When NOT to Use DI","text":"<p>DI has overhead. Skip it when:</p> <ol> <li>Scripts/One-Off Tools: Simple scripts don't need DI</li> <li>No Tests: If you're never testing, DI adds complexity</li> <li>Single Implementation: If you'll never swap implementations</li> <li>Prototypes: Quick throwaway code</li> </ol> <p>For small apps, manual dependency management is fine:</p> <pre><code># Simple script - no DI needed\ndef main():\n    repo = MongoOrderRepository()\n    handler = PlaceOrderHandler(repo)\n    # ...\n</code></pre>"},{"location":"concepts/dependency-injection/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ol> <li>Constructor Injection: Dependencies passed as parameters</li> <li>Interface Segregation: Depend on interfaces, not implementations</li> <li>Service Lifetimes: Singleton (app), Scoped (request), Transient (always new)</li> <li>DI Container: Automatically resolves and injects dependencies</li> <li>Testability: Inject mocks/fakes for testing</li> </ol>"},{"location":"concepts/dependency-injection/#di-clean-architecture","title":"\ud83d\udd04 DI + Clean Architecture","text":"<p>DI is the mechanism that enables clean architecture:</p> <pre><code>Domain defines interfaces \u2192 Application uses interfaces \u2192 Infrastructure implements interfaces\n                           \u2193\n                    DI Container wires everything at runtime\n</code></pre> <p>Without DI, application layer would need to create infrastructure (violating dependency rule).</p>"},{"location":"concepts/dependency-injection/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ul> <li>See it work: Tutorial Part 1 shows DI setup</li> <li>Understand CQRS: CQRS uses DI for handler resolution</li> <li>Mediator pattern: Mediator relies on DI to find handlers</li> </ul>"},{"location":"concepts/dependency-injection/#further-reading","title":"\ud83d\udcda Further Reading","text":"<ul> <li>Martin Fowler - Dependency Injection</li> <li>Dependency Inversion Principle</li> <li>Neuroglia DI documentation</li> </ul> <p>Previous: \u2190 Clean Architecture | Next: Domain-Driven Design \u2192</p>"},{"location":"concepts/domain-driven-design/","title":"Domain-Driven Design (DDD)","text":"<p>Time to read: 15 minutes</p> <p>Domain-Driven Design is an approach to software where code mirrors business concepts and language. Instead of thinking in database tables and CRUD operations, you model the real-world domain.</p>"},{"location":"concepts/domain-driven-design/#the-problem-anemic-domain-models","title":"\u274c The Problem: Anemic Domain Models","text":"<p>Traditional approach treats entities as dumb data containers:</p> <pre><code># \u274c Anemic model - just getters/setters, no behavior\nclass Order:\n    def __init__(self):\n        self.id = None\n        self.customer_id = None\n        self.items = []\n        self.status = \"pending\"\n        self.total = 0.0\n\n    def get_total(self):\n        return self.total\n\n    def set_total(self, value):\n        self.total = value\n\n# Business logic scattered in services\nclass OrderService:\n    def confirm_order(self, order_id):\n        order = self.repository.get(order_id)\n\n        # Business rules in service (far from data)\n        if order.status != \"pending\":\n            raise ValueError(\"Can only confirm pending orders\")\n\n        if order.total &lt; 10:\n            raise ValueError(\"Minimum order is $10\")\n\n        order.set_status(\"confirmed\")\n        self.repository.save(order)\n        self.email_service.send(\"Order confirmed\")\n</code></pre> <p>Problems:</p> <ol> <li>Business logic scattered: Rules in services, not entities</li> <li>No ubiquitous language: Code doesn't match business terms</li> <li>Easy to break rules: Anyone can set any property</li> <li>Hard to understand: Need to read services to understand behavior</li> <li>No domain events: Changes don't trigger reactions</li> </ol>"},{"location":"concepts/domain-driven-design/#the-solution-rich-domain-models","title":"\u2705 The Solution: Rich Domain Models","text":"<p>Put business logic where it belongs - in domain entities:</p> <pre><code># \u2705 Rich model - behavior and rules in the entity\nclass Order:\n    def __init__(self, customer_id: str):\n        self.id = str(uuid.uuid4())\n        self.customer_id = customer_id\n        self.items: List[OrderItem] = []\n        self.status = OrderStatus.PENDING\n        self._events: List[DomainEvent] = []\n\n    def add_pizza(self, pizza: Pizza, quantity: int):\n        \"\"\"Add pizza to order. Business logic here!\"\"\"\n        if self.status != OrderStatus.PENDING:\n            raise ValueError(\"Cannot modify confirmed orders\")\n\n        if quantity &lt;= 0:\n            raise ValueError(\"Quantity must be positive\")\n\n        item = OrderItem(pizza, quantity)\n        self.items.append(item)\n\n    def confirm(self):\n        \"\"\"Confirm order. Business rules enforced!\"\"\"\n        if self.status != OrderStatus.PENDING:\n            raise ValueError(\"Can only confirm pending orders\")\n\n        if self.total() &lt; 10:\n            raise ValueError(\"Minimum order is $10\")\n\n        self.status = OrderStatus.CONFIRMED\n        self._events.append(OrderConfirmedEvent(self.id))  # Domain event!\n\n    def total(self) -&gt; Decimal:\n        \"\"\"Calculate total. Pure business logic.\"\"\"\n        return sum(item.subtotal() for item in self.items)\n</code></pre> <p>Benefits:</p> <ol> <li>Logic with data: Rules and data together</li> <li>Ubiquitous language: Methods match business terms (<code>confirm</code>, <code>add_pizza</code>)</li> <li>Encapsulation: Can't break rules (no public setters)</li> <li>Self-documenting: Read entity to understand business</li> <li>Domain events: Changes trigger reactions</li> </ol>"},{"location":"concepts/domain-driven-design/#ddd-building-blocks","title":"\ud83c\udfd7\ufe0f DDD Building Blocks","text":""},{"location":"concepts/domain-driven-design/#1-entities","title":"1. Entities","text":"<p>Objects with identity that persists over time:</p> <pre><code>class Order:\n    def __init__(self, order_id: str):\n        self.id = order_id  # Identity\n        self.customer_id = None\n        self.items = []\n\n    def __eq__(self, other):\n        return isinstance(other, Order) and self.id == other.id\n\n# Two orders with same data but different IDs are DIFFERENT\norder1 = Order(\"123\")\norder2 = Order(\"456\")\nassert order1 != order2  # Different entities\n</code></pre> <p>Key: Identity matters, not attributes.</p>"},{"location":"concepts/domain-driven-design/#2-value-objects","title":"2. Value Objects","text":"<p>Objects defined by attributes, not identity:</p> <pre><code>@dataclass(frozen=True)  # Immutable!\nclass OrderItem:\n    pizza_name: str\n    size: PizzaSize\n    quantity: int\n    price: Decimal\n\n    def subtotal(self) -&gt; Decimal:\n        return self.price * self.quantity\n\n# Two items with same attributes are THE SAME\nitem1 = OrderItem(\"Margherita\", PizzaSize.LARGE, 2, Decimal(\"15.99\"))\nitem2 = OrderItem(\"Margherita\", PizzaSize.LARGE, 2, Decimal(\"15.99\"))\nassert item1 == item2  # Same value object\n</code></pre> <p>Key: Immutable, equality by attributes, no identity.</p>"},{"location":"concepts/domain-driven-design/#3-aggregates","title":"3. Aggregates","text":"<p>Cluster of entities/value objects treated as a unit:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Order Aggregate                     \u2502\n\u2502                                     \u2502\n\u2502  Order (Aggregate Root)             \u2502\n\u2502  \u251c\u2500 OrderItem (Value Object)       \u2502\n\u2502  \u251c\u2500 OrderItem (Value Object)       \u2502\n\u2502  \u2514\u2500 DeliveryAddress (Value Object) \u2502\n\u2502                                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nRules:\n- External code only accesses Order (root)\n- Order ensures consistency of items/address\n- Save entire aggregate as a unit\n</code></pre> <pre><code>class Order:  # Aggregate Root\n    def __init__(self):\n        self.items: List[OrderItem] = []  # Part of aggregate\n\n    def add_item(self, item: OrderItem):\n        # Order controls its items\n        self.items.append(item)\n\n    def remove_item(self, item: OrderItem):\n        # Order maintains consistency\n        if item in self.items:\n            self.items.remove(item)\n\n# \u274c WRONG: Modify items directly\norder.items.append(OrderItem(...))  # Bypasses rules!\n\n# \u2705 RIGHT: Go through aggregate root\norder.add_item(OrderItem(...))  # Rules enforced\n</code></pre>"},{"location":"concepts/domain-driven-design/#4-domain-events","title":"4. Domain Events","text":"<p>Something that happened in the domain:</p> <pre><code>@dataclass\nclass OrderConfirmedEvent:\n    order_id: str\n    customer_id: str\n    total: Decimal\n    confirmed_at: datetime\n\nclass Order:\n    def confirm(self):\n        self.status = OrderStatus.CONFIRMED\n        self._events.append(OrderConfirmedEvent(\n            order_id=self.id,\n            customer_id=self.customer_id,\n            total=self.total(),\n            confirmed_at=datetime.utcnow()\n        ))\n</code></pre> <p>Use for: Triggering side effects, auditing, integration events.</p>"},{"location":"concepts/domain-driven-design/#5-repositories","title":"5. Repositories","text":"<p>Collection-like interface for retrieving aggregates:</p> <pre><code>class IOrderRepository(ABC):\n    @abstractmethod\n    async def get_by_id_async(self, order_id: str) -&gt; Optional[Order]:\n        \"\"\"Get order aggregate by ID.\"\"\"\n        pass\n\n    @abstractmethod\n    async def save_async(self, order: Order) -&gt; None:\n        \"\"\"Save order aggregate.\"\"\"\n        pass\n</code></pre> <p>Key: Repository only for aggregate roots, not individual entities.</p>"},{"location":"concepts/domain-driven-design/#ddd-in-neuroglia","title":"\ud83d\udd27 DDD in Neuroglia","text":""},{"location":"concepts/domain-driven-design/#rich-domain-entities","title":"Rich Domain Entities","text":"<pre><code>from neuroglia.core import Entity\nfrom neuroglia.eventing import DomainEvent\n\nclass Order(Entity):\n    \"\"\"Order aggregate root.\"\"\"\n\n    def __init__(self, customer_id: str):\n        super().__init__()  # Generates ID\n        self.customer_id = customer_id\n        self.items: List[OrderItem] = []\n        self.status = OrderStatus.PENDING\n\n    def add_pizza(self, pizza_name: str, size: PizzaSize, quantity: int, price: Decimal):\n        \"\"\"Business operation: add pizza to order.\"\"\"\n        # Validation (business rules)\n        if self.status != OrderStatus.PENDING:\n            raise InvalidOperationError(\"Cannot modify confirmed orders\")\n\n        if quantity &lt;= 0:\n            raise ValueError(\"Quantity must be positive\")\n\n        # Create value object\n        item = OrderItem(\n            pizza_name=pizza_name,\n            size=size,\n            quantity=quantity,\n            price=price\n        )\n\n        # Modify state\n        self.items.append(item)\n\n        # Raise domain event\n        self.raise_event(PizzaAddedToOrderEvent(\n            order_id=self.id,\n            pizza_name=pizza_name,\n            quantity=quantity\n        ))\n\n    def confirm(self):\n        \"\"\"Business operation: confirm order.\"\"\"\n        # Business rules\n        if self.status != OrderStatus.PENDING:\n            raise InvalidOperationError(\"Order already confirmed\")\n\n        if not self.items:\n            raise InvalidOperationError(\"Cannot confirm empty order\")\n\n        if self.total() &lt; Decimal(\"10\"):\n            raise InvalidOperationError(\"Minimum order is $10\")\n\n        # State change\n        self.status = OrderStatus.CONFIRMED\n\n        # Domain event\n        self.raise_event(OrderConfirmedEvent(\n            order_id=self.id,\n            customer_id=self.customer_id,\n            total=self.total()\n        ))\n\n    def total(self) -&gt; Decimal:\n        \"\"\"Calculate order total.\"\"\"\n        return sum(item.subtotal() for item in self.items)\n</code></pre>"},{"location":"concepts/domain-driven-design/#ubiquitous-language","title":"Ubiquitous Language","text":"<p>Use business terms everywhere:</p> <pre><code># \u274c Technical language\norder.set_status(2)  # What does 2 mean?\norder.validate()     # Validate what?\norder.persist()      # Too technical\n\n# \u2705 Ubiquitous language (matches business)\norder.confirm()      # Business term!\norder.cancel()       # Business term!\norder.start_cooking()  # Business term!\n</code></pre> <p>Rule: Code should read like a conversation with domain experts.</p>"},{"location":"concepts/domain-driven-design/#bounded-contexts","title":"Bounded Contexts","text":"<p>Large domains split into smaller contexts:</p> <pre><code>Mario's Pizzeria Domain:\n\u251c\u2500 Orders Context (order placement, tracking)\n\u251c\u2500 Kitchen Context (cooking, preparation)\n\u251c\u2500 Delivery Context (driver assignment, routing)\n\u251c\u2500 Menu Context (pizzas, pricing)\n\u2514\u2500 Customer Context (accounts, preferences)\n\nEach context has its own models!\n</code></pre> <pre><code># Orders context: Order is about customer order\nclass Order:\n    customer_id: str\n    items: List[OrderItem]\n    status: OrderStatus\n\n# Kitchen context: Order is about preparation\nclass KitchenOrder:\n    order_id: str\n    pizzas: List[Pizza]\n    preparation_status: PreparationStatus\n    assigned_cook: str\n\n# Same real-world concept, different models per context!\n</code></pre>"},{"location":"concepts/domain-driven-design/#testing-ddd","title":"\ud83e\uddea Testing DDD","text":""},{"location":"concepts/domain-driven-design/#unit-tests-test-business-rules","title":"Unit Tests: Test Business Rules","text":"<pre><code>def test_cannot_confirm_empty_order():\n    order = Order(customer_id=\"123\")\n\n    with pytest.raises(InvalidOperationError, match=\"empty order\"):\n        order.confirm()\n\ndef test_cannot_modify_confirmed_order():\n    order = Order(customer_id=\"123\")\n    order.add_pizza(\"Margherita\", PizzaSize.LARGE, 1, Decimal(\"15.99\"))\n    order.confirm()\n\n    with pytest.raises(InvalidOperationError, match=\"confirmed orders\"):\n        order.add_pizza(\"Pepperoni\", PizzaSize.MEDIUM, 1, Decimal(\"13.99\"))\n\ndef test_order_total_calculation():\n    order = Order(customer_id=\"123\")\n    order.add_pizza(\"Margherita\", PizzaSize.LARGE, 2, Decimal(\"15.99\"))\n    order.add_pizza(\"Pepperoni\", PizzaSize.MEDIUM, 1, Decimal(\"13.99\"))\n\n    assert order.total() == Decimal(\"45.97\")  # (15.99 * 2) + 13.99\n</code></pre>"},{"location":"concepts/domain-driven-design/#integration-tests-test-repositories","title":"Integration Tests: Test Repositories","text":"<pre><code>async def test_save_and_retrieve_order():\n    repo = MongoOrderRepository()\n\n    # Create aggregate\n    order = Order(customer_id=\"123\")\n    order.add_pizza(\"Margherita\", PizzaSize.LARGE, 1, Decimal(\"15.99\"))\n    order.confirm()\n\n    # Save\n    await repo.save_async(order)\n\n    # Retrieve\n    retrieved = await repo.get_by_id_async(order.id)\n\n    assert retrieved.id == order.id\n    assert retrieved.status == OrderStatus.CONFIRMED\n    assert retrieved.total() == Decimal(\"15.99\")\n</code></pre>"},{"location":"concepts/domain-driven-design/#common-mistakes","title":"\u26a0\ufe0f Common Mistakes","text":""},{"location":"concepts/domain-driven-design/#1-anemic-domain-models","title":"1. Anemic Domain Models","text":"<pre><code># \u274c WRONG: Just data, no behavior\nclass Order:\n    def __init__(self):\n        self.status = \"pending\"\n\n# Business logic in service\nclass OrderService:\n    def confirm(self, order):\n        if order.status != \"pending\":\n            raise ValueError()\n        order.status = \"confirmed\"\n\n# \u2705 RIGHT: Behavior in entity\nclass Order:\n    def confirm(self):\n        if self.status != OrderStatus.PENDING:\n            raise InvalidOperationError()\n        self.status = OrderStatus.CONFIRMED\n</code></pre>"},{"location":"concepts/domain-driven-design/#2-public-setters","title":"2. Public Setters","text":"<pre><code># \u274c WRONG: Public setters bypass rules\nclass Order:\n    def __init__(self):\n        self.status = OrderStatus.PENDING\n\n    def set_status(self, status):\n        self.status = status  # No validation!\n\norder.set_status(OrderStatus.CONFIRMED)  # Bypasses rules!\n\n# \u2705 RIGHT: Named methods with rules\nclass Order:\n    def __init__(self):\n        self._status = OrderStatus.PENDING\n\n    @property\n    def status(self):\n        return self._status\n\n    def confirm(self):\n        if self._status != OrderStatus.PENDING:\n            raise InvalidOperationError()\n        self._status = OrderStatus.CONFIRMED\n</code></pre>"},{"location":"concepts/domain-driven-design/#3-breaking-aggregate-boundaries","title":"3. Breaking Aggregate Boundaries","text":"<pre><code># \u274c WRONG: Accessing child entities directly\norder_item = order.items[0]\norder_item.quantity = 5  # Bypasses order!\n\n# \u2705 RIGHT: Go through aggregate root\norder.update_item_quantity(item_id, new_quantity=5)\n</code></pre>"},{"location":"concepts/domain-driven-design/#4-too-many-aggregates","title":"4. Too Many Aggregates","text":"<pre><code># \u274c WRONG: Every entity is an aggregate\nclass Order: pass\nclass OrderItem: pass  # Separate aggregate\nclass DeliveryAddress: pass  # Separate aggregate\n\n# Now need to manage consistency across 3 aggregates!\n\n# \u2705 RIGHT: One aggregate\nclass Order:  # Aggregate root\n    def __init__(self):\n        self.items = []  # Part of aggregate\n        self.delivery_address = None  # Part of aggregate\n</code></pre>"},{"location":"concepts/domain-driven-design/#when-not-to-use-ddd","title":"\ud83d\udeab When NOT to Use DDD","text":"<p>DDD has learning curve and overhead. Skip when:</p> <ol> <li>CRUD Applications: Simple data entry, no business logic</li> <li>Reporting/Analytics: Read-only, no state changes</li> <li>Prototypes: Quick experiments, throwaway code</li> <li>Simple Domains: No complex business rules</li> <li>Small Teams: DDD shines with multiple developers</li> </ol> <p>For simple apps, anemic models with service layers work fine.</p>"},{"location":"concepts/domain-driven-design/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ol> <li>Rich Models: Behavior and data together in entities</li> <li>Ubiquitous Language: Code matches business terminology</li> <li>Aggregates: Consistency boundaries around related entities</li> <li>Domain Events: Communicate state changes</li> <li>Repositories: Collection-like access to aggregates</li> </ol>"},{"location":"concepts/domain-driven-design/#ddd-clean-architecture","title":"\ud83d\udd04 DDD + Clean Architecture","text":"<p>DDD lives in the domain layer of clean architecture:</p> <pre><code>Domain Layer (DDD):\n- Rich entities with business logic\n- Value objects for immutability\n- Domain events for communication\n- Repository interfaces\n\nApplication Layer:\n- Uses domain entities\n- Orchestrates business operations\n- Handles domain events\n\nInfrastructure Layer:\n- Implements repositories\n- Persists aggregates\n- Publishes domain events\n</code></pre>"},{"location":"concepts/domain-driven-design/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ul> <li>See it in action: Tutorial Part 2 builds DDD models</li> <li>Understand aggregates: Aggregates &amp; Entities deep dive</li> <li>Event-driven: Event-Driven Architecture uses domain events</li> </ul>"},{"location":"concepts/domain-driven-design/#further-reading","title":"\ud83d\udcda Further Reading","text":"<ul> <li>Eric Evans' \"Domain-Driven Design\" (book)</li> <li>Vaughn Vernon's \"Implementing Domain-Driven Design\" (book)</li> <li>Martin Fowler - Domain-Driven Design</li> </ul> <p>Previous: \u2190 Dependency Injection | Next: Aggregates &amp; Entities \u2192</p>"},{"location":"concepts/event-driven/","title":"Event-Driven Architecture","text":"<p>Time to read: 14 minutes</p> <p>Event-Driven Architecture uses events to communicate between parts of a system. When something happens, an event is published, and interested parties react - without knowing about each other.</p>"},{"location":"concepts/event-driven/#the-problem-tight-coupling-through-direct-calls","title":"\u274c The Problem: Tight Coupling Through Direct Calls","text":"<p>Without events, components directly call each other:</p> <pre><code># \u274c Order service directly calls email and kitchen services\nclass OrderService:\n    def __init__(self,\n                 email_service: EmailService,\n                 kitchen_service: KitchenService,\n                 inventory_service: InventoryService,\n                 analytics_service: AnalyticsService):\n        # Depends on all services!\n        self.email_service = email_service\n        self.kitchen_service = kitchen_service\n        self.inventory_service = inventory_service\n        self.analytics_service = analytics_service\n\n    async def confirm_order(self, order_id: str):\n        order = await self.repository.get(order_id)\n        order.status = \"confirmed\"\n        await self.repository.save(order)\n\n        # Directly calls all services\n        await self.email_service.send_confirmation(order)\n        await self.kitchen_service.start_preparing(order)\n        await self.inventory_service.update_stock(order)\n        await self.analytics_service.record_sale(order)\n\n        # What if we need to add notification service?\n        # What if email fails? Should order still confirm?\n</code></pre> <p>Problems:</p> <ol> <li>Tight coupling: OrderService knows about all other services</li> <li>Hard to extend: Adding feature requires changing OrderService</li> <li>Synchronous: All operations block each other</li> <li>Cascading failures: Email failure prevents order confirmation</li> <li>Hard to test: Need to mock all services</li> </ol>"},{"location":"concepts/event-driven/#the-solution-events-as-communication","title":"\u2705 The Solution: Events as Communication","text":"<p>Components publish events, others subscribe and react:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502          Event-Driven Flow                  \u2502\n\u2502                                             \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                              \u2502\n\u2502  \u2502  Order   \u2502                              \u2502\n\u2502  \u2502 Service  \u2502                              \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518                              \u2502\n\u2502       \u2502                                     \u2502\n\u2502       \u2502 Publishes \"OrderConfirmed\" Event   \u2502\n\u2502       \u25bc                                     \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                              \u2502\n\u2502  \u2502 Event    \u2502                              \u2502\n\u2502  \u2502   Bus    \u2502                              \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518                              \u2502\n\u2502        \u2502                                    \u2502\n\u2502        \u2502 Notifies subscribers               \u2502\n\u2502        \u2502                                    \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u2502\n\u2502   \u25bc    \u25bc    \u25bc        \u25bc         \u25bc          \u2502\n\u2502 Email Kitchen Inventory Analytics Notifications\u2502\n\u2502 Handler Handler Handler Handler  Handler   \u2502\n\u2502                                             \u2502\n\u2502 Order doesn't know about handlers!         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Benefits:</p> <ol> <li>Loose coupling: Order doesn't know about subscribers</li> <li>Easy to extend: Add handlers without changing Order</li> <li>Asynchronous: Handlers run independently</li> <li>Resilient: One handler failure doesn't affect others</li> <li>Easy to test: Test Order without handlers</li> </ol>"},{"location":"concepts/event-driven/#types-of-events","title":"\ud83c\udfd7\ufe0f Types of Events","text":""},{"location":"concepts/event-driven/#1-domain-events-internal","title":"1. Domain Events (Internal)","text":"<p>What happened in the domain:</p> <pre><code>@dataclass\nclass OrderConfirmedEvent:\n    \"\"\"Domain event - something happened in the business domain.\"\"\"\n    order_id: str\n    customer_id: str\n    total: Decimal\n    confirmed_at: datetime\n\n@dataclass\nclass OrderCancelledEvent:\n    \"\"\"Domain event - order was cancelled.\"\"\"\n    order_id: str\n    customer_id: str\n    reason: str\n    cancelled_at: datetime\n</code></pre> <p>Characteristics:</p> <ul> <li>Past tense: <code>OrderConfirmed</code>, <code>PaymentProcessed</code></li> <li>Internal: Within your application</li> <li>Rich: Contains all relevant data</li> <li>Immutable: Can't be changed after creation</li> </ul>"},{"location":"concepts/event-driven/#2-integration-events-external","title":"2. Integration Events (External)","text":"<p>Communication with other systems:</p> <pre><code>from neuroglia.eventing.cloud_events import CloudEvent\n\n# CloudEvent - standardized external event\nevent = CloudEvent(\n    source=\"mario-pizzeria/orders\",\n    type=\"com.mariopizzeria.order.confirmed.v1\",\n    data={\n        \"order_id\": \"123\",\n        \"customer_id\": \"456\",\n        \"total\": 45.99\n    }\n)\n</code></pre> <p>Characteristics:</p> <ul> <li>Standardized: CloudEvents spec</li> <li>External: Between microservices</li> <li>Versioned: <code>v1</code>, <code>v2</code> in type</li> <li>Schema: Well-defined structure</li> </ul>"},{"location":"concepts/event-driven/#events-in-neuroglia","title":"\ud83d\udd27 Events in Neuroglia","text":""},{"location":"concepts/event-driven/#raising-domain-events","title":"Raising Domain Events","text":"<p>Entities raise events when state changes:</p> <pre><code>from neuroglia.core import AggregateRoot\nfrom neuroglia.eventing import DomainEvent\n\n@dataclass\nclass OrderConfirmedEvent(DomainEvent):\n    order_id: str\n    customer_id: str\n    total: Decimal\n\nclass Order(AggregateRoot):\n    \"\"\"Aggregate root raises events.\"\"\"\n\n    def __init__(self, customer_id: str):\n        super().__init__()\n        self.customer_id = customer_id\n        self.items = []\n        self.status = OrderStatus.PENDING\n\n        # Raise event\n        self.raise_event(OrderCreatedEvent(\n            order_id=self.id,\n            customer_id=customer_id\n        ))\n\n    def confirm(self):\n        \"\"\"Confirm order - raises event.\"\"\"\n        if self.status != OrderStatus.PENDING:\n            raise InvalidOperationError(\"Can only confirm pending orders\")\n\n        if not self.items:\n            raise InvalidOperationError(\"Cannot confirm empty order\")\n\n        # Change state\n        self.status = OrderStatus.CONFIRMED\n\n        # Raise domain event\n        self.raise_event(OrderConfirmedEvent(\n            order_id=self.id,\n            customer_id=self.customer_id,\n            total=self.total()\n        ))\n</code></pre>"},{"location":"concepts/event-driven/#event-handlers","title":"Event Handlers","text":"<p>React to events:</p> <pre><code>from neuroglia.eventing import DomainEventHandler\n\nclass SendConfirmationEmailHandler(DomainEventHandler[OrderConfirmedEvent]):\n    \"\"\"Handles OrderConfirmedEvent by sending email.\"\"\"\n\n    def __init__(self, email_service: IEmailService):\n        self.email_service = email_service\n\n    async def handle_async(self, event: OrderConfirmedEvent):\n        \"\"\"React to order confirmation.\"\"\"\n        await self.email_service.send_confirmation(\n            customer_id=event.customer_id,\n            order_id=event.order_id,\n            total=event.total\n        )\n\nclass StartCookingHandler(DomainEventHandler[OrderConfirmedEvent]):\n    \"\"\"Handles OrderConfirmedEvent by notifying kitchen.\"\"\"\n\n    def __init__(self, kitchen_service: IKitchenService):\n        self.kitchen_service = kitchen_service\n\n    async def handle_async(self, event: OrderConfirmedEvent):\n        \"\"\"Start preparing the order.\"\"\"\n        await self.kitchen_service.start_preparing(event.order_id)\n\nclass UpdateInventoryHandler(DomainEventHandler[OrderConfirmedEvent]):\n    \"\"\"Handles OrderConfirmedEvent by updating inventory.\"\"\"\n\n    def __init__(self, inventory_service: IInventoryService):\n        self.inventory_service = inventory_service\n\n    async def handle_async(self, event: OrderConfirmedEvent):\n        \"\"\"Update ingredient inventory.\"\"\"\n        await self.inventory_service.deduct_ingredients(event.order_id)\n\n# Multiple handlers for same event!\n# They run independently - one failure doesn't affect others\n</code></pre>"},{"location":"concepts/event-driven/#event-dispatch","title":"Event Dispatch","text":"<p>Events dispatched automatically via Unit of Work:</p> <pre><code>class OrderRepository:\n    def __init__(self, unit_of_work: IUnitOfWork):\n        self.unit_of_work = unit_of_work\n\n    async def save_async(self, order: Order):\n        # Save order\n        await self.collection.insert_one(order.to_dict())\n\n        # Dispatch events\n        await self.unit_of_work.save_changes_async(order)\n        # \u2191 This publishes all uncommitted events from order\n</code></pre>"},{"location":"concepts/event-driven/#publishing-integration-events","title":"Publishing Integration Events","text":"<p>For external systems:</p> <pre><code>from neuroglia.eventing.cloud_events import CloudEvent, CloudEventPublisher\n\nclass PublishOrderConfirmedHandler(DomainEventHandler[OrderConfirmedEvent]):\n    \"\"\"Publishes external integration event.\"\"\"\n\n    def __init__(self, publisher: CloudEventPublisher):\n        self.publisher = publisher\n\n    async def handle_async(self, event: OrderConfirmedEvent):\n        \"\"\"Publish CloudEvent for other microservices.\"\"\"\n        cloud_event = CloudEvent(\n            source=\"mario-pizzeria/orders\",\n            type=\"com.mariopizzeria.order.confirmed.v1\",\n            data={\n                \"order_id\": event.order_id,\n                \"customer_id\": event.customer_id,\n                \"total\": float(event.total),\n                \"confirmed_at\": event.confirmed_at.isoformat()\n            }\n        )\n\n        await self.publisher.publish_async(cloud_event)\n</code></pre>"},{"location":"concepts/event-driven/#real-world-example-marios-pizzeria","title":"\ud83c\udfd7\ufe0f Real-World Example: Mario's Pizzeria","text":"<pre><code># Domain Events\n@dataclass\nclass OrderConfirmedEvent(DomainEvent):\n    order_id: str\n    customer_id: str\n    items: List[OrderItemDto]\n    total: Decimal\n    delivery_address: DeliveryAddressDto\n\n@dataclass\nclass CookingStartedEvent(DomainEvent):\n    order_id: str\n    cook_id: str\n    estimated_completion: datetime\n\n@dataclass\nclass OrderReadyEvent(DomainEvent):\n    order_id: str\n    preparation_time: timedelta\n\n# Entity raises events\nclass Order(AggregateRoot):\n    def confirm(self):\n        self.status = OrderStatus.CONFIRMED\n        self.raise_event(OrderConfirmedEvent(\n            order_id=self.id,\n            customer_id=self.customer_id,\n            items=self.items,\n            total=self.total(),\n            delivery_address=self.delivery_address\n        ))\n\n# Multiple handlers react\nclass SendConfirmationEmailHandler(DomainEventHandler[OrderConfirmedEvent]):\n    async def handle_async(self, event: OrderConfirmedEvent):\n        await self.email_service.send_template(\n            to=event.customer_email,\n            template=\"order_confirmation\",\n            data={\"order\": event}\n        )\n\nclass NotifyKitchenHandler(DomainEventHandler[OrderConfirmedEvent]):\n    async def handle_async(self, event: OrderConfirmedEvent):\n        await self.kitchen_api.create_preparation_ticket(\n            order_id=event.order_id,\n            items=event.items\n        )\n\nclass UpdateAnalyticsHandler(DomainEventHandler[OrderConfirmedEvent]):\n    async def handle_async(self, event: OrderConfirmedEvent):\n        await self.analytics.record_sale(\n            amount=event.total,\n            customer_id=event.customer_id,\n            items=event.items\n        )\n\nclass DeductInventoryHandler(DomainEventHandler[OrderConfirmedEvent]):\n    async def handle_async(self, event: OrderConfirmedEvent):\n        for item in event.items:\n            ingredients = await self.recipe_service.get_ingredients(item.pizza_name)\n            await self.inventory.deduct(ingredients, item.quantity)\n\nclass PublishToExternalSystemsHandler(DomainEventHandler[OrderConfirmedEvent]):\n    async def handle_async(self, event: OrderConfirmedEvent):\n        cloud_event = CloudEvent(\n            source=\"mario-pizzeria/orders\",\n            type=\"com.mariopizzeria.order.confirmed.v1\",\n            data=asdict(event)\n        )\n        await self.event_bus.publish_async(cloud_event)\n</code></pre>"},{"location":"concepts/event-driven/#testing-event-driven-systems","title":"\ud83e\uddea Testing Event-Driven Systems","text":""},{"location":"concepts/event-driven/#test-event-raising","title":"Test Event Raising","text":"<pre><code>def test_order_confirm_raises_event():\n    \"\"\"Test that confirming order raises event.\"\"\"\n    order = Order(customer_id=\"123\")\n    order.add_item(\"Margherita\", PizzaSize.LARGE, 1, Decimal(\"15.99\"))\n\n    # Confirm order\n    order.confirm()\n\n    # Check events\n    events = order.get_uncommitted_events()\n\n    assert len(events) == 2  # OrderCreated, OrderConfirmed\n    assert isinstance(events[1], OrderConfirmedEvent)\n    assert events[1].order_id == order.id\n</code></pre>"},{"location":"concepts/event-driven/#test-event-handlers","title":"Test Event Handlers","text":"<pre><code>async def test_email_handler():\n    \"\"\"Test email handler in isolation.\"\"\"\n    # Mock email service\n    mock_email = Mock(spec=IEmailService)\n\n    # Create handler\n    handler = SendConfirmationEmailHandler(mock_email)\n\n    # Create event\n    event = OrderConfirmedEvent(\n        order_id=\"123\",\n        customer_id=\"456\",\n        total=Decimal(\"45.99\")\n    )\n\n    # Handle event\n    await handler.handle_async(event)\n\n    # Verify email was sent\n    mock_email.send_confirmation.assert_called_once_with(\n        customer_id=\"456\",\n        order_id=\"123\",\n        total=Decimal(\"45.99\")\n    )\n</code></pre>"},{"location":"concepts/event-driven/#test-event-flow","title":"Test Event Flow","text":"<pre><code>async def test_order_confirmation_workflow():\n    \"\"\"Test complete event-driven workflow.\"\"\"\n    # Setup with real event bus\n    services = ServiceCollection()\n    services.add_scoped(IOrderRepository, InMemoryOrderRepository)\n    services.add_scoped(IEmailService, FakeEmailService)\n    services.add_scoped(IKitchenService, FakeKitchenService)\n    services.add_scoped(SendConfirmationEmailHandler)\n    services.add_scoped(StartCookingHandler)\n    services.add_event_bus()\n\n    provider = services.build_provider()\n\n    # Create and confirm order\n    order = Order(customer_id=\"123\")\n    order.add_item(\"Margherita\", PizzaSize.LARGE, 1, Decimal(\"15.99\"))\n    order.confirm()\n\n    # Save (triggers event dispatch)\n    repository = provider.get_service(IOrderRepository)\n    await repository.save_async(order)\n\n    # Verify side effects\n    email_service = provider.get_service(IEmailService)\n    assert email_service.emails_sent == 1\n\n    kitchen_service = provider.get_service(IKitchenService)\n    assert kitchen_service.preparation_started\n</code></pre>"},{"location":"concepts/event-driven/#common-mistakes","title":"\u26a0\ufe0f Common Mistakes","text":""},{"location":"concepts/event-driven/#1-events-with-commands","title":"1. Events with Commands","text":"<pre><code># \u274c WRONG: Event tells what to do (command)\n@dataclass\nclass SendEmailEvent:  # Imperative - command!\n    to: str\n    subject: str\n\n# \u2705 RIGHT: Event describes what happened\n@dataclass\nclass OrderConfirmedEvent:  # Past tense - event!\n    order_id: str\n    customer_id: str\n    # Handler decides to send email\n</code></pre>"},{"location":"concepts/event-driven/#2-events-that-are-too-generic","title":"2. Events That Are Too Generic","text":"<pre><code># \u274c WRONG: Generic event\n@dataclass\nclass OrderChangedEvent:\n    order_id: str\n    # What changed? Handlers don't know!\n\n# \u2705 RIGHT: Specific events\n@dataclass\nclass OrderConfirmedEvent:\n    order_id: str\n\n@dataclass\nclass OrderCancelledEvent:\n    order_id: str\n    reason: str\n</code></pre>"},{"location":"concepts/event-driven/#3-handler-modifies-original-aggregate","title":"3. Handler Modifies Original Aggregate","text":"<pre><code># \u274c WRONG: Handler modifies order\nclass UpdateInventoryHandler(DomainEventHandler[OrderConfirmedEvent]):\n    async def handle_async(self, event: OrderConfirmedEvent):\n        order = await self.order_repo.get(event.order_id)\n        order.inventory_updated = True  # NO! Modifying different aggregate\n        await self.order_repo.save(order)\n\n# \u2705 RIGHT: Handler modifies its own aggregate\nclass UpdateInventoryHandler(DomainEventHandler[OrderConfirmedEvent]):\n    async def handle_async(self, event: OrderConfirmedEvent):\n        inventory = await self.inventory_repo.get(event.order_id)\n        inventory.deduct_ingredients(event.items)  # Modifies Inventory aggregate\n        await self.inventory_repo.save(inventory)\n</code></pre>"},{"location":"concepts/event-driven/#4-synchronous-event-processing","title":"4. Synchronous Event Processing","text":"<pre><code># \u274c WRONG: Blocking event processing\nasync def save_async(self, order: Order):\n    await self.db.save(order)\n\n    # Blocking - waits for all handlers\n    for event in order.get_uncommitted_events():\n        for handler in self.event_handlers:\n            await handler.handle_async(event)  # Blocks!\n\n# \u2705 RIGHT: Async event processing\nasync def save_async(self, order: Order):\n    await self.db.save(order)\n\n    # Dispatch asynchronously (queue, message bus)\n    await self.event_bus.publish_many_async(\n        order.get_uncommitted_events()\n    )\n    # Handlers process in background\n</code></pre>"},{"location":"concepts/event-driven/#when-not-to-use-events","title":"\ud83d\udeab When NOT to Use Events","text":"<p>Events add complexity. Skip when:</p> <ol> <li>Simple Operations: Direct call is clearer</li> <li>Strong Consistency Needed: Events are eventually consistent</li> <li>Single Operation: No side effects to trigger</li> <li>Prototypes: Experimenting with ideas</li> <li>Synchronous Requirements: Must happen immediately</li> </ol> <p>For simple apps, direct service calls work fine.</p>"},{"location":"concepts/event-driven/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ol> <li>Publish-Subscribe: Publishers don't know subscribers</li> <li>Past Tense: Events describe what happened</li> <li>Loose Coupling: Add handlers without changing publishers</li> <li>Asynchronous: Handlers run independently</li> <li>Resilient: One handler failure doesn't affect others</li> </ol>"},{"location":"concepts/event-driven/#events-other-patterns","title":"\ud83d\udd04 Events + Other Patterns","text":"<pre><code>Aggregate\n    \u2193 raises\nDomain Event\n    \u2193 dispatched by\nUnit of Work\n    \u2193 published to\nEvent Bus\n    \u2193 routes to\nEvent Handlers (multiple)\n    \u2193 may publish\nIntegration Events (CloudEvents)\n</code></pre>"},{"location":"concepts/event-driven/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ul> <li>Implement it: Tutorial Part 5 builds event-driven system</li> <li>Understand persistence: Repository Pattern for event dispatch</li> <li>CloudEvents: CloudEvents documentation for integration</li> </ul>"},{"location":"concepts/event-driven/#further-reading","title":"\ud83d\udcda Further Reading","text":"<ul> <li>Event-Driven Architecture (Martin Fowler)</li> <li>CloudEvents Specification</li> <li>Domain Events (Vernon)</li> </ul> <p>Previous: \u2190 Mediator Pattern | Next: Repository Pattern \u2192</p>"},{"location":"concepts/mediator/","title":"Mediator Pattern","text":"<p>Time to read: 10 minutes</p> <p>The Mediator pattern provides a central dispatcher that routes requests (commands and queries) to their handlers. Instead of controllers directly calling services, they send messages through the mediator.</p>"},{"location":"concepts/mediator/#the-problem-tight-coupling","title":"\u274c The Problem: Tight Coupling","text":"<p>Without mediator, controllers directly depend on all handlers:</p> <pre><code># \u274c Controller depends on every handler\nclass OrdersController:\n    def __init__(self,\n                 place_order_handler: PlaceOrderHandler,\n                 confirm_order_handler: ConfirmOrderHandler,\n                 cancel_order_handler: CancelOrderHandler,\n                 get_order_handler: GetOrderByIdHandler,\n                 get_customer_orders_handler: GetCustomerOrdersHandler):\n        # Too many dependencies!\n        self.place_order_handler = place_order_handler\n        self.confirm_order_handler = confirm_order_handler\n        self.cancel_order_handler = cancel_order_handler\n        self.get_order_handler = get_order_handler\n        self.get_customer_orders_handler = get_customer_orders_handler\n\n    async def create_order(self, dto: CreateOrderDto):\n        command = PlaceOrderCommand(...)\n        return await self.place_order_handler.handle_async(command)\n\n    async def confirm_order(self, order_id: str):\n        command = ConfirmOrderCommand(order_id)\n        return await self.confirm_order_handler.handle_async(command)\n    # ... more methods, more handlers\n</code></pre> <p>Problems:</p> <ol> <li>Tight coupling: Controller knows about all handlers</li> <li>Hard to test: Need to mock every handler</li> <li>Hard to extend: Adding handler requires changing controller</li> <li>Violates OCP: Open/Closed Principle - controller changes for new operations</li> <li>Repetitive: Same pattern everywhere</li> </ol>"},{"location":"concepts/mediator/#the-solution-central-mediator","title":"\u2705 The Solution: Central Mediator","text":"<p>Mediator routes requests to handlers without controllers knowing about them:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 Controller                      \u2502\n\u2502                      \u2502                          \u2502\n\u2502                      \u25bc                          \u2502\n\u2502              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                   \u2502\n\u2502              \u2502   Mediator   \u2502                   \u2502\n\u2502              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                   \u2502\n\u2502                     \u2502                           \u2502\n\u2502         Routes based on request type            \u2502\n\u2502                     \u2502                           \u2502\n\u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u2502\n\u2502     \u25bc               \u25bc               \u25bc          \u2502\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502\n\u2502 \u2502Handler1\u2502     \u2502Handler2\u2502     \u2502Handler3\u2502      \u2502\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n\u2502                                                 \u2502\n\u2502 Controller \u2192 Mediator \u2192 Right Handler          \u2502\n\u2502 (no direct coupling to handlers)               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Benefits:</p> <ol> <li>Loose coupling: Controller only knows mediator</li> <li>Easy to test: Mock one mediator instead of many handlers</li> <li>Easy to extend: Add handlers without changing controllers</li> <li>Follows OCP: Controllers closed for modification, open for extension</li> <li>Consistent: Same pattern everywhere</li> </ol>"},{"location":"concepts/mediator/#mediator-in-neuroglia","title":"\ud83d\udd27 Mediator in Neuroglia","text":""},{"location":"concepts/mediator/#basic-usage","title":"Basic Usage","text":"<pre><code>from neuroglia.mediation import Mediator, Command, Query, CommandHandler, QueryHandler\n\n# 1. Define request (Command or Query)\n@dataclass\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    customer_id: str\n    items: List[OrderItemDto]\n\n# 2. Define handler\nclass PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    def __init__(self, repository: IOrderRepository):\n        self.repository = repository\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        order = Order(command.customer_id)\n        for item in command.items:\n            order.add_item(item.pizza_name, item.size, item.quantity, item.price)\n\n        await self.repository.save_async(order)\n        return self.created(order_dto)\n\n# 3. Controller uses mediator\nclass OrdersController:\n    def __init__(self, mediator: Mediator):\n        self.mediator = mediator  # Only dependency!\n\n    @post(\"/orders\")\n    async def create_order(self, dto: CreateOrderDto):\n        # Create command\n        command = PlaceOrderCommand(\n            customer_id=dto.customer_id,\n            items=dto.items\n        )\n\n        # Send through mediator\n        result = await self.mediator.execute_async(command)\n\n        return self.process(result)  # Mediator found and called PlaceOrderHandler\n</code></pre>"},{"location":"concepts/mediator/#registration","title":"Registration","text":"<p>Neuroglia auto-discovers handlers:</p> <pre><code>from neuroglia.hosting.web import WebApplicationBuilder\n\nbuilder = WebApplicationBuilder()\n\n# Register mediator (auto-discovers handlers)\nbuilder.services.add_mediator()\n\n# Or specify packages to scan\nbuilder.services.add_mediator(\n    handler_packages=[\"application.commands\", \"application.queries\"]\n)\n</code></pre>"},{"location":"concepts/mediator/#request-types","title":"Request Types","text":"<p>Commands - Write operations:</p> <pre><code>@dataclass\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Command returns OperationResult.\"\"\"\n    customer_id: str\n    items: List[OrderItemDto]\n\n@dataclass\nclass ConfirmOrderCommand(Command[OperationResult]):\n    \"\"\"Command can return just OperationResult (no data).\"\"\"\n    order_id: str\n</code></pre> <p>Queries - Read operations:</p> <pre><code>@dataclass\nclass GetOrderByIdQuery(Query[OrderDto]):\n    \"\"\"Query returns data directly.\"\"\"\n    order_id: str\n\n@dataclass\nclass GetCustomerOrdersQuery(Query[List[OrderDto]]):\n    \"\"\"Query can return collections.\"\"\"\n    customer_id: str\n</code></pre>"},{"location":"concepts/mediator/#pipeline-behaviors","title":"Pipeline Behaviors","text":"<p>Add cross-cutting concerns that run for every request:</p> <pre><code>from neuroglia.mediation import PipelineBehavior\n\nclass LoggingBehavior(PipelineBehavior):\n    \"\"\"Logs all commands/queries.\"\"\"\n\n    async def handle_async(self, request, next_handler):\n        logger.info(f\"Executing {request.__class__.__name__}\")\n\n        result = await next_handler()\n\n        logger.info(f\"Completed {request.__class__.__name__}\")\n        return result\n\nclass ValidationBehavior(PipelineBehavior):\n    \"\"\"Validates all commands.\"\"\"\n\n    async def handle_async(self, request, next_handler):\n        # Validate before handling\n        if isinstance(request, Command):\n            errors = self.validate(request)\n            if errors:\n                return OperationResult.bad_request(errors)\n\n        return await next_handler()\n\nclass TransactionBehavior(PipelineBehavior):\n    \"\"\"Wraps commands in transactions.\"\"\"\n\n    def __init__(self, unit_of_work: IUnitOfWork):\n        self.unit_of_work = unit_of_work\n\n    async def handle_async(self, request, next_handler):\n        if isinstance(request, Command):\n            async with self.unit_of_work.begin():\n                result = await next_handler()\n                if result.is_success:\n                    await self.unit_of_work.commit()\n                else:\n                    await self.unit_of_work.rollback()\n                return result\n        else:\n            return await next_handler()\n\n# Register behaviors (run in order)\nservices.add_scoped(PipelineBehavior, LoggingBehavior)\nservices.add_scoped(PipelineBehavior, ValidationBehavior)\nservices.add_scoped(PipelineBehavior, TransactionBehavior)\n</code></pre> <p>Pipeline execution:</p> <pre><code>Request \u2192 LoggingBehavior \u2192 ValidationBehavior \u2192 TransactionBehavior \u2192 Handler \u2192 Result\n          (logs)            (validates)           (transaction)        (logic)\n</code></pre>"},{"location":"concepts/mediator/#real-world-example-marios-pizzeria","title":"\ud83c\udfd7\ufe0f Real-World Example: Mario's Pizzeria","text":"<pre><code># Commands\n@dataclass\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    customer_id: str\n    items: List[OrderItemDto]\n    delivery_address: DeliveryAddressDto\n\n@dataclass\nclass ConfirmOrderCommand(Command[OperationResult]):\n    order_id: str\n\n# Queries\n@dataclass\nclass GetOrderByIdQuery(Query[OrderDto]):\n    order_id: str\n\n@dataclass\nclass GetOrdersByStatusQuery(Query[List[OrderDto]]):\n    status: OrderStatus\n\n# Handlers\nclass PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    async def handle_async(self, command: PlaceOrderCommand):\n        # Create order, save, return result\n        pass\n\nclass ConfirmOrderHandler(CommandHandler[ConfirmOrderCommand, OperationResult]):\n    async def handle_async(self, command: ConfirmOrderCommand):\n        # Confirm order, save, return result\n        pass\n\nclass GetOrderByIdHandler(QueryHandler[GetOrderByIdQuery, OrderDto]):\n    async def handle_async(self, query: GetOrderByIdQuery):\n        # Retrieve order, return DTO\n        pass\n\n# Controller\nclass OrdersController(ControllerBase):\n    # Only depends on mediator!\n    def __init__(self, service_provider, mapper, mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n    @post(\"/orders\")\n    async def create_order(self, dto: CreateOrderDto):\n        command = self.mapper.map(dto, PlaceOrderCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @put(\"/orders/{order_id}/confirm\")\n    async def confirm_order(self, order_id: str):\n        command = ConfirmOrderCommand(order_id=order_id)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @get(\"/orders/{order_id}\")\n    async def get_order(self, order_id: str):\n        query = GetOrderByIdQuery(order_id=order_id)\n        result = await self.mediator.execute_async(query)\n        return result\n\n    @get(\"/orders\")\n    async def get_orders_by_status(self, status: OrderStatus):\n        query = GetOrdersByStatusQuery(status=status)\n        result = await self.mediator.execute_async(query)\n        return result\n</code></pre>"},{"location":"concepts/mediator/#testing-with-mediator","title":"\ud83e\uddea Testing with Mediator","text":""},{"location":"concepts/mediator/#unit-tests-mock-mediator","title":"Unit Tests: Mock Mediator","text":"<pre><code>from unittest.mock import Mock, AsyncMock\n\nasync def test_create_order_controller():\n    \"\"\"Test controller with mocked mediator.\"\"\"\n    # Mock mediator\n    mock_mediator = Mock(spec=Mediator)\n    mock_mediator.execute_async = AsyncMock(\n        return_value=OperationResult.created(OrderDto(...))\n    )\n\n    # Create controller\n    controller = OrdersController(None, None, mock_mediator)\n\n    # Call endpoint\n    dto = CreateOrderDto(customer_id=\"123\", items=[...])\n    result = await controller.create_order(dto)\n\n    # Verify\n    assert result.status_code == 201\n    mock_mediator.execute_async.assert_called_once()\n\n    # Verify correct command was sent\n    call_args = mock_mediator.execute_async.call_args[0][0]\n    assert isinstance(call_args, PlaceOrderCommand)\n    assert call_args.customer_id == \"123\"\n</code></pre>"},{"location":"concepts/mediator/#integration-tests-real-mediator","title":"Integration Tests: Real Mediator","text":"<pre><code>async def test_order_workflow():\n    \"\"\"Test complete workflow through mediator.\"\"\"\n    # Setup real mediator with handlers\n    services = ServiceCollection()\n    services.add_scoped(IOrderRepository, InMemoryOrderRepository)\n    services.add_scoped(PlaceOrderHandler)\n    services.add_scoped(GetOrderByIdHandler)\n    services.add_mediator()\n\n    provider = services.build_provider()\n    mediator = provider.get_service(Mediator)\n\n    # Place order\n    place_command = PlaceOrderCommand(customer_id=\"123\", items=[...])\n    place_result = await mediator.execute_async(place_command)\n\n    assert place_result.is_success\n    order_id = place_result.data.order_id\n\n    # Retrieve order\n    get_query = GetOrderByIdQuery(order_id=order_id)\n    get_result = await mediator.execute_async(get_query)\n\n    assert get_result is not None\n    assert get_result.order_id == order_id\n</code></pre>"},{"location":"concepts/mediator/#common-mistakes","title":"\u26a0\ufe0f Common Mistakes","text":""},{"location":"concepts/mediator/#1-bypassing-mediator","title":"1. Bypassing Mediator","text":"<pre><code># \u274c WRONG: Controller calls handler directly\nclass OrdersController:\n    def __init__(self, mediator: Mediator, handler: PlaceOrderHandler):\n        self.mediator = mediator\n        self.handler = handler\n\n    async def create_order(self, dto: CreateOrderDto):\n        return await self.handler.handle_async(command)  # Bypasses mediator!\n\n# \u2705 RIGHT: Always use mediator\nclass OrdersController:\n    def __init__(self, mediator: Mediator):\n        self.mediator = mediator\n\n    async def create_order(self, dto: CreateOrderDto):\n        return await self.mediator.execute_async(command)  # Through mediator\n</code></pre>"},{"location":"concepts/mediator/#2-multiple-handlers-for-same-request","title":"2. Multiple Handlers for Same Request","text":"<pre><code># \u274c WRONG: Two handlers for same command\nclass PlaceOrderHandler1(CommandHandler[PlaceOrderCommand, OperationResult]):\n    pass\n\nclass PlaceOrderHandler2(CommandHandler[PlaceOrderCommand, OperationResult]):\n    pass\n# Mediator won't know which to use!\n\n# \u2705 RIGHT: One handler per request type\nclass PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult]):\n    pass\n</code></pre>"},{"location":"concepts/mediator/#3-handlers-with-business-logic","title":"3. Handlers with Business Logic","text":"<pre><code># \u274c WRONG: Handler has complex business logic\nclass PlaceOrderHandler(CommandHandler):\n    async def handle_async(self, command):\n        # Lots of business logic here\n        if command.total &lt; 10:\n            raise ValueError()\n        if not command.items:\n            raise ValueError()\n        # ... 100 lines of logic\n\n# \u2705 RIGHT: Handler orchestrates, domain has logic\nclass PlaceOrderHandler(CommandHandler):\n    async def handle_async(self, command):\n        order = Order(command.customer_id)  # Domain object\n        for item in command.items:\n            order.add_item(item)  # Domain logic in Order\n        await self.repository.save_async(order)\n        return self.created(order_dto)\n</code></pre>"},{"location":"concepts/mediator/#when-not-to-use-mediator","title":"\ud83d\udeab When NOT to Use Mediator","text":"<p>Mediator adds indirection. Skip when:</p> <ol> <li>Tiny Apps: &lt; 5 operations, single controller</li> <li>Scripts/Tools: No web API, direct service calls fine</li> <li>Prototypes: Experimenting with ideas</li> <li>No CQRS: If not separating commands/queries</li> <li>Performance Critical: Direct calls slightly faster (rare concern)</li> </ol> <p>For simple CRUD apps, traditional service layer is fine.</p>"},{"location":"concepts/mediator/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ol> <li>Central Dispatcher: One mediator routes all requests</li> <li>Loose Coupling: Controllers don't know handlers</li> <li>Pipeline Behaviors: Cross-cutting concerns (logging, validation, transactions)</li> <li>Testability: Mock mediator instead of many handlers</li> <li>Extensibility: Add handlers without changing controllers</li> </ol>"},{"location":"concepts/mediator/#mediator-other-patterns","title":"\ud83d\udd04 Mediator + Other Patterns","text":"<pre><code>Controller\n    \u2193 sends Command/Query\nMediator\n    \u2193 routes to\nHandler\n    \u2193 uses\nDomain Model / Repository\n    \u2193 raises\nDomain Events\n    \u2193 dispatched by\nEvent Bus (another mediator!)\n</code></pre>"},{"location":"concepts/mediator/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ul> <li>See it in action: Tutorial Part 3 uses mediator</li> <li>Add behaviors: Validation as pipeline behavior</li> <li>Event handling: Event-Driven Architecture for domain events</li> </ul>"},{"location":"concepts/mediator/#further-reading","title":"\ud83d\udcda Further Reading","text":"<ul> <li>Mediator Pattern (GoF)</li> <li>MediatR Library (.NET) - inspiration for Neuroglia's mediator</li> <li>CQRS with MediatR</li> </ul> <p>Previous: \u2190 CQRS | Next: Event-Driven Architecture \u2192</p>"},{"location":"concepts/repository/","title":"Repository Pattern","text":"<p>Time to read: 11 minutes</p> <p>The Repository pattern provides a collection-like interface for accessing domain objects. It abstracts data access, hiding whether data comes from a database, API, or memory.</p>"},{"location":"concepts/repository/#the-problem-database-code-everywhere","title":"\u274c The Problem: Database Code Everywhere","text":"<p>Without repositories, database code leaks into business logic:</p> <pre><code># \u274c Handler knows about MongoDB\nclass PlaceOrderHandler:\n    def __init__(self, mongo_client: MongoClient):\n        self.db = mongo_client.orders_db\n\n    async def handle_async(self, command: PlaceOrderCommand):\n        # Create domain object\n        order = Order(command.customer_id)\n        order.add_item(command.item)\n\n        # MongoDB-specific code in handler!\n        await self.db.orders.insert_one({\n            \"_id\": order.id,\n            \"customer_id\": order.customer_id,\n            \"items\": [item.__dict__ for item in order.items],\n            \"status\": order.status.value\n        })\n</code></pre> <p>Problems:</p> <ol> <li>Tight coupling: Handler depends on MongoDB</li> <li>Hard to test: Need real MongoDB for tests</li> <li>Can't switch databases: MongoDB everywhere</li> <li>Violates clean architecture: Infrastructure in application layer</li> <li>Repeated code: Same serialization everywhere</li> </ol>"},{"location":"concepts/repository/#the-solution-repository-abstraction","title":"\u2705 The Solution: Repository Abstraction","text":"<p>Repository provides collection-like interface:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502        Application Layer               \u2502\n\u2502                                        \u2502\n\u2502  Handler \u2192 IOrderRepository (interface)\u2502\n\u2502                    \u2502                   \u2502\n\u2502                    \u2502 abstracts         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    Infrastructure Layer                \u2502\n\u2502                    \u25bc                   \u2502\n\u2502   MongoOrderRepository (implementation)\u2502\n\u2502   PostgresOrderRepository             \u2502\n\u2502   InMemoryOrderRepository             \u2502\n\u2502                                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nHandler doesn't know which implementation!\n</code></pre> <p>Benefits:</p> <ol> <li>Abstraction: Handler uses interface, not implementation</li> <li>Testability: Use in-memory repository for tests</li> <li>Flexibility: Swap databases without changing handlers</li> <li>Clean architecture: Domain/application don't know about infrastructure</li> <li>Consistency: One place for data access logic</li> </ol>"},{"location":"concepts/repository/#repository-interface-domain-layer","title":"\ud83c\udfd7\ufe0f Repository Interface (Domain Layer)","text":"<p>Define interface in domain layer:</p> <pre><code>from abc import ABC, abstractmethod\nfrom typing import Optional, List\n\nclass IOrderRepository(ABC):\n    \"\"\"\n    Repository interface - defines what operations are needed.\n    Lives in DOMAIN layer (no MongoDB, no Postgres - pure abstraction).\n    \"\"\"\n\n    @abstractmethod\n    async def get_by_id_async(self, order_id: str) -&gt; Optional[Order]:\n        \"\"\"Retrieve order by ID.\"\"\"\n        pass\n\n    @abstractmethod\n    async def save_async(self, order: Order) -&gt; None:\n        \"\"\"Save order (create or update).\"\"\"\n        pass\n\n    @abstractmethod\n    async def delete_async(self, order_id: str) -&gt; None:\n        \"\"\"Delete order.\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_by_customer_async(self, customer_id: str) -&gt; List[Order]:\n        \"\"\"Find all orders for a customer.\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_by_status_async(self, status: OrderStatus) -&gt; List[Order]:\n        \"\"\"Find all orders with given status.\"\"\"\n        pass\n</code></pre> <p>Key Points:</p> <ul> <li>Interface only: No implementation details</li> <li>Domain language: Methods match business terms</li> <li>Aggregate root: Repository for <code>Order</code>, not <code>OrderItem</code></li> <li>Domain layer: Alongside entities, not in infrastructure</li> </ul>"},{"location":"concepts/repository/#repository-implementation-infrastructure-layer","title":"\ud83d\udd27 Repository Implementation (Infrastructure Layer)","text":"<p>Implement interface in infrastructure:</p> <pre><code>from motor.motor_asyncio import AsyncIOMotorCollection\nfrom neuroglia.data.repositories import MotorRepository\n\nclass MongoOrderRepository(MotorRepository[Order, str], IOrderRepository):\n    \"\"\"\n    MongoDB implementation of IOrderRepository.\n    Lives in INFRASTRUCTURE layer.\n    \"\"\"\n\n    def __init__(self, collection: AsyncIOMotorCollection):\n        super().__init__(collection, Order)\n\n    async def get_by_id_async(self, order_id: str) -&gt; Optional[Order]:\n        \"\"\"Get order from MongoDB.\"\"\"\n        doc = await self.collection.find_one({\"_id\": order_id})\n\n        if not doc:\n            return None\n\n        return self._to_entity(doc)\n\n    async def save_async(self, order: Order) -&gt; None:\n        \"\"\"Save order to MongoDB.\"\"\"\n        doc = self._to_document(order)\n\n        await self.collection.replace_one(\n            {\"_id\": order.id},\n            doc,\n            upsert=True\n        )\n\n        # Dispatch domain events\n        await self.unit_of_work.save_changes_async(order)\n\n    async def delete_async(self, order_id: str) -&gt; None:\n        \"\"\"Delete order from MongoDB.\"\"\"\n        await self.collection.delete_one({\"_id\": order_id})\n\n    async def find_by_customer_async(self, customer_id: str) -&gt; List[Order]:\n        \"\"\"Find orders by customer (MongoDB-specific query).\"\"\"\n        cursor = self.collection.find({\"customer_id\": customer_id})\n        docs = await cursor.to_list(length=None)\n\n        return [self._to_entity(doc) for doc in docs]\n\n    async def find_by_status_async(self, status: OrderStatus) -&gt; List[Order]:\n        \"\"\"Find orders by status.\"\"\"\n        cursor = self.collection.find({\"status\": status.value})\n        docs = await cursor.to_list(length=None)\n\n        return [self._to_entity(doc) for doc in docs]\n\n    def _to_document(self, order: Order) -&gt; dict:\n        \"\"\"Convert Order entity to MongoDB document.\"\"\"\n        return {\n            \"_id\": order.id,\n            \"customer_id\": order.customer_id,\n            \"items\": [\n                {\n                    \"pizza_name\": item.pizza_name,\n                    \"size\": item.size.value,\n                    \"quantity\": item.quantity,\n                    \"price\": float(item.price)\n                }\n                for item in order.items\n            ],\n            \"status\": order.status.value,\n            \"created_at\": order.created_at\n        }\n\n    def _to_entity(self, doc: dict) -&gt; Order:\n        \"\"\"Convert MongoDB document to Order entity.\"\"\"\n        order = Order(doc[\"customer_id\"])\n        order.id = doc[\"_id\"]\n        order.status = OrderStatus(doc[\"status\"])\n        order.created_at = doc[\"created_at\"]\n\n        for item_doc in doc[\"items\"]:\n            order.items.append(OrderItem(\n                pizza_name=item_doc[\"pizza_name\"],\n                size=PizzaSize(item_doc[\"size\"]),\n                quantity=item_doc[\"quantity\"],\n                price=Decimal(str(item_doc[\"price\"]))\n            ))\n\n        return order\n</code></pre>"},{"location":"concepts/repository/#in-memory-repository-testing","title":"\ud83e\uddea In-Memory Repository (Testing)","text":"<p>For unit tests:</p> <pre><code>class InMemoryOrderRepository(IOrderRepository):\n    \"\"\"\n    In-memory implementation for testing.\n    No database needed!\n    \"\"\"\n\n    def __init__(self):\n        self._orders: Dict[str, Order] = {}\n\n    async def get_by_id_async(self, order_id: str) -&gt; Optional[Order]:\n        return self._orders.get(order_id)\n\n    async def save_async(self, order: Order) -&gt; None:\n        self._orders[order.id] = order\n\n    async def delete_async(self, order_id: str) -&gt; None:\n        if order_id in self._orders:\n            del self._orders[order_id]\n\n    async def find_by_customer_async(self, customer_id: str) -&gt; List[Order]:\n        return [\n            order for order in self._orders.values()\n            if order.customer_id == customer_id\n        ]\n\n    async def find_by_status_async(self, status: OrderStatus) -&gt; List[Order]:\n        return [\n            order for order in self._orders.values()\n            if order.status == status\n        ]\n</code></pre>"},{"location":"concepts/repository/#using-repositories","title":"\ud83c\udfd7\ufe0f Using Repositories","text":""},{"location":"concepts/repository/#in-handlers","title":"In Handlers","text":"<pre><code>class PlaceOrderHandler(CommandHandler):\n    def __init__(self, repository: IOrderRepository):  # Interface!\n        self.repository = repository\n\n    async def handle_async(self, command: PlaceOrderCommand):\n        # Create domain object\n        order = Order(command.customer_id)\n        for item in command.items:\n            order.add_item(item.pizza_name, item.size, item.quantity, item.price)\n\n        # Save through repository (don't know/care about MongoDB)\n        await self.repository.save_async(order)\n\n        return self.created(order_dto)\n\nclass GetOrderByIdHandler(QueryHandler):\n    def __init__(self, repository: IOrderRepository):  # Same interface!\n        self.repository = repository\n\n    async def handle_async(self, query: GetOrderByIdQuery):\n        # Retrieve through repository\n        order = await self.repository.get_by_id_async(query.order_id)\n\n        if not order:\n            return None\n\n        return self.mapper.map(order, OrderDto)\n</code></pre>"},{"location":"concepts/repository/#registration","title":"Registration","text":"<pre><code>from neuroglia.dependency_injection import ServiceCollection\n\nservices = ServiceCollection()\n\n# Register interface \u2192 implementation mapping\nservices.add_scoped(IOrderRepository, MongoOrderRepository)\n\n# For testing, swap implementation\nservices.add_scoped(IOrderRepository, InMemoryOrderRepository)\n</code></pre>"},{"location":"concepts/repository/#advanced-generic-repository","title":"\ud83d\ude80 Advanced: Generic Repository","text":"<p>Neuroglia provides base classes:</p> <pre><code>from neuroglia.data.repositories import Repository, MotorRepository\n\nclass OrderRepository(MotorRepository[Order, str]):\n    \"\"\"\n    Inherit from MotorRepository for common operations.\n    Add custom queries as needed.\n    \"\"\"\n\n    async def find_pending_orders(self) -&gt; List[Order]:\n        \"\"\"Custom query - find pending orders older than 30 minutes.\"\"\"\n        thirty_minutes_ago = datetime.utcnow() - timedelta(minutes=30)\n\n        cursor = self.collection.find({\n            \"status\": OrderStatus.PENDING.value,\n            \"created_at\": {\"$lt\": thirty_minutes_ago}\n        })\n\n        docs = await cursor.to_list(length=None)\n        return [self._to_entity(doc) for doc in docs]\n\n    async def get_order_statistics(self, date_from: datetime, date_to: datetime) -&gt; dict:\n        \"\"\"Custom aggregation - order statistics.\"\"\"\n        pipeline = [\n            {\n                \"$match\": {\n                    \"created_at\": {\"$gte\": date_from, \"$lt\": date_to}\n                }\n            },\n            {\n                \"$group\": {\n                    \"_id\": \"$status\",\n                    \"count\": {\"$sum\": 1},\n                    \"total_revenue\": {\"$sum\": \"$total\"}\n                }\n            }\n        ]\n\n        result = await self.collection.aggregate(pipeline).to_list(length=None)\n        return result\n</code></pre>"},{"location":"concepts/repository/#testing-with-repositories","title":"\ud83e\uddea Testing with Repositories","text":""},{"location":"concepts/repository/#unit-tests-in-memory-repository","title":"Unit Tests: In-Memory Repository","text":"<pre><code>async def test_place_order():\n    \"\"\"Test handler with in-memory repository.\"\"\"\n    # Use in-memory repository (no database!)\n    repository = InMemoryOrderRepository()\n    handler = PlaceOrderHandler(repository)\n\n    # Execute command\n    command = PlaceOrderCommand(\n        customer_id=\"123\",\n        items=[OrderItemDto(\"Margherita\", PizzaSize.LARGE, 1, Decimal(\"15.99\"))]\n    )\n    result = await handler.handle_async(command)\n\n    # Verify\n    assert result.is_success\n    assert len(repository._orders) == 1\n\n    # Verify order is retrievable\n    order = await repository.get_by_id_async(result.data.order_id)\n    assert order is not None\n    assert order.customer_id == \"123\"\n</code></pre>"},{"location":"concepts/repository/#integration-tests-real-repository","title":"Integration Tests: Real Repository","text":"<pre><code>@pytest.mark.integration\nasync def test_mongo_repository():\n    \"\"\"Test with real MongoDB.\"\"\"\n    # Setup MongoDB connection\n    client = motor.motor_asyncio.AsyncIOMotorClient(\"mongodb://localhost:27017\")\n    collection = client.test_db.orders\n\n    repository = MongoOrderRepository(collection)\n\n    # Create and save order\n    order = Order(customer_id=\"123\")\n    order.add_item(\"Margherita\", PizzaSize.LARGE, 1, Decimal(\"15.99\"))\n    await repository.save_async(order)\n\n    # Retrieve and verify\n    retrieved = await repository.get_by_id_async(order.id)\n    assert retrieved.id == order.id\n    assert retrieved.customer_id == \"123\"\n    assert len(retrieved.items) == 1\n\n    # Cleanup\n    await collection.delete_one({\"_id\": order.id})\n</code></pre>"},{"location":"concepts/repository/#common-mistakes","title":"\u26a0\ufe0f Common Mistakes","text":""},{"location":"concepts/repository/#1-repository-for-every-entity","title":"1. Repository for Every Entity","text":"<pre><code># \u274c WRONG: Repository for child entity\nclass IOrderItemRepository(ABC):  # OrderItem is not aggregate root!\n    pass\n\n# \u2705 RIGHT: Repository only for aggregate roots\nclass IOrderRepository(ABC):\n    # Access items through Order\n    pass\n</code></pre>"},{"location":"concepts/repository/#2-business-logic-in-repository","title":"2. Business Logic in Repository","text":"<pre><code># \u274c WRONG: Business logic in repository\nclass OrderRepository:\n    async def save_async(self, order: Order):\n        if order.total() &lt; 10:\n            raise ValueError(\"Minimum order is $10\")  # Business rule!\n        await self.collection.insert_one(order.to_dict())\n\n# \u2705 RIGHT: Business logic in entity\nclass Order:\n    def confirm(self):\n        if self.total() &lt; Decimal(\"10\"):\n            raise InvalidOperationError(\"Minimum order is $10\")\n        self.status = OrderStatus.CONFIRMED\n</code></pre>"},{"location":"concepts/repository/#3-repository-returning-dtos","title":"3. Repository Returning DTOs","text":"<pre><code># \u274c WRONG: Repository returns DTO\nclass IOrderRepository(ABC):\n    async def get_by_id_async(self, order_id: str) -&gt; OrderDto:  # DTO!\n        pass\n\n# \u2705 RIGHT: Repository returns entity\nclass IOrderRepository(ABC):\n    async def get_by_id_async(self, order_id: str) -&gt; Order:  # Entity!\n        pass\n</code></pre>"},{"location":"concepts/repository/#4-direct-database-access","title":"4. Direct Database Access","text":"<pre><code># \u274c WRONG: Handler uses database directly\nclass GetOrderHandler:\n    def __init__(self, mongo_client: MongoClient):\n        self.db = mongo_client.orders_db\n\n    async def handle_async(self, query):\n        doc = await self.db.orders.find_one({\"_id\": query.order_id})  # Direct!\n        return OrderDto(**doc)\n\n# \u2705 RIGHT: Handler uses repository\nclass GetOrderHandler:\n    def __init__(self, repository: IOrderRepository):\n        self.repository = repository\n\n    async def handle_async(self, query):\n        order = await self.repository.get_by_id_async(query.order_id)\n        return self.mapper.map(order, OrderDto)\n</code></pre>"},{"location":"concepts/repository/#when-not-to-use-repository","title":"\ud83d\udeab When NOT to Use Repository","text":"<p>Repositories add a layer. Skip when:</p> <ol> <li>Simple CRUD: Direct ORM access is fine</li> <li>Reporting: Complex queries easier with raw SQL</li> <li>Prototypes: Experimenting with ideas</li> <li>No Domain Model: If using transaction scripts</li> <li>Single Database: If never switching databases</li> </ol> <p>For simple apps, direct database access works fine.</p>"},{"location":"concepts/repository/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ol> <li>Abstraction: Interface in domain, implementation in infrastructure</li> <li>Collection-Like: Methods like <code>get</code>, <code>save</code>, <code>find</code></li> <li>Aggregate Roots: Repository only for aggregate roots</li> <li>Testability: In-memory implementation for tests</li> <li>Flexibility: Swap implementations without changing handlers</li> </ol>"},{"location":"concepts/repository/#repository-other-patterns","title":"\ud83d\udd04 Repository + Other Patterns","text":"<pre><code>Handler\n    \u2193 uses\nRepository Interface (domain)\n    \u2193 implemented by\nRepository Implementation (infrastructure)\n    \u2193 persists\nAggregate Root\n    \u2193 raises\nDomain Events\n    \u2193 dispatched by\nUnit of Work\n</code></pre>"},{"location":"concepts/repository/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ul> <li>Implement it: Tutorial Part 6 builds repositories</li> <li>Event sourcing: Event Store for event-sourced aggregates</li> <li>Advanced queries: Data Access documentation</li> </ul>"},{"location":"concepts/repository/#further-reading","title":"\ud83d\udcda Further Reading","text":"<ul> <li>Martin Fowler's Repository Pattern</li> <li>Evans' \"Domain-Driven Design\" (Chapter 6)</li> <li>Specification Pattern for complex queries</li> </ul> <p>Previous: \u2190 Event-Driven Architecture | Next: Core Concepts Index</p>"},{"location":"features/","title":"\ud83d\ude80 Framework Features","text":"<p>The Neuroglia Python framework provides a comprehensive set of concrete framework capabilities and implementation utilities. Features are specific tools and utilities provided by the framework, while Patterns define architectural approaches and design principles.</p>"},{"location":"features/#features-vs-patterns","title":"\ud83c\udfaf Features vs Patterns","text":"Features (This Section) Patterns (../patterns/index.md) What: Specific framework capabilities What: Architectural design approaches Purpose: Tools and utilities you use Purpose: How to structure and design Examples: Serialization, Validation, HTTP Client Examples: CQRS, DDD, Pipeline Behaviors"},{"location":"features/#core-architecture-features","title":"\ud83c\udfaf Core Architecture Features","text":""},{"location":"features/#mvc-controllers","title":"\ud83c\udf10 MVC Controllers","text":"<p>FastAPI-integrated controller framework that automatically discovers and registers API endpoints. Provides consistent patterns for request handling and response formatting.</p> <p>Key Capabilities:</p> <ul> <li>Automatic controller discovery</li> <li>Consistent API patterns</li> <li>Built-in validation and serialization</li> <li>Integration with dependency injection</li> </ul>"},{"location":"features/#data-access","title":"\ud83d\udcbe Data Access","text":"<p>Flexible data access patterns supporting multiple storage backends including MongoDB, file-based storage, and in-memory repositories. Implements repository and unit of work patterns.</p> <p>Key Capabilities:</p> <ul> <li>Repository pattern implementations</li> <li>Multiple storage backends</li> <li>Async/await data operations</li> <li>Transaction support</li> </ul>"},{"location":"features/#event-integration-features","title":"\ud83d\udd04 Event &amp; Integration Features","text":""},{"location":"features/#mermaid-diagrams","title":"\ud83d\udcca Mermaid Diagrams","text":"<p>Built-in support for generating and validating Mermaid diagrams for architecture documentation. Includes diagram validation and preview capabilities.</p> <p>Key Capabilities:</p> <ul> <li>Architecture diagram generation</li> <li>Diagram validation</li> <li>Multiple diagram types</li> <li>Documentation integration</li> </ul>"},{"location":"features/#advanced-architecture-features","title":"\ud83c\udfd7\ufe0f Advanced Architecture Features","text":""},{"location":"features/#resource-oriented-architecture","title":"\ud83c\udfaf Resource Oriented Architecture","text":"<p>Implementation of resource-oriented patterns for building RESTful APIs and microservices. Focuses on resource identification and manipulation through standard HTTP verbs.</p> <p>Key Capabilities:</p> <ul> <li>Resource identification patterns</li> <li>RESTful API design</li> <li>HTTP verb mapping</li> <li>Resource lifecycle management</li> </ul>"},{"location":"features/#serialization","title":"Serialization","text":"<p>Powerful JSON serialization system with automatic type handling, custom encoders, and seamless integration with domain objects.</p> <p>Key Capabilities:</p> <ul> <li>Automatic type conversion (enums, decimals, datetime)</li> <li>Custom JsonEncoder for complex objects</li> <li>Dependency injection integration</li> <li>Comprehensive error handling</li> </ul>"},{"location":"features/#object-mapping","title":"\ud83c\udfaf Object Mapping","text":"<p>Advanced object-to-object mapping with convention-based property matching, custom transformations, and type conversion support.</p> <p>Key Capabilities:</p> <ul> <li>Convention-based automatic mapping</li> <li>Custom mapping configurations</li> <li>Type conversion and validation</li> <li>Mapping profiles and reusable configurations</li> </ul>"},{"location":"features/#enhanced-integration-features","title":"\ud83d\ude80 Enhanced Integration Features","text":""},{"location":"features/#background-task-scheduling","title":"\u23f0 Background Task Scheduling","text":"<p>Enterprise-grade background task scheduling with APScheduler integration, Redis persistence, and comprehensive error handling for complex workflow orchestration.</p> <p>Key Capabilities:</p> <ul> <li>APScheduler integration with multiple job stores</li> <li>Redis persistence for distributed scheduling</li> <li>Reactive stream processing for real-time events</li> <li>Circuit breaker patterns and retry policies</li> <li>Comprehensive monitoring and error handling</li> </ul>"},{"location":"features/#redis-cache-repository","title":"\u26a1 Redis Cache Repository","text":"<p>High-performance Redis-based caching repository with async operations, distributed locks, and intelligent cache management for scalable microservices.</p> <p>Key Capabilities:</p> <ul> <li>Async Redis operations with connection pooling</li> <li>Distributed locks for cache consistency</li> <li>Hash-based storage with automatic serialization</li> <li>TTL management and cache invalidation strategies</li> <li>Comprehensive error handling and fallback mechanisms</li> </ul>"},{"location":"features/#http-service-client","title":"\ud83c\udf10 HTTP Service Client","text":"<p>Resilient HTTP client with retry policies, circuit breaker patterns, request/response interceptors, and comprehensive error handling for external API integration.</p> <p>Key Capabilities:</p> <ul> <li>Circuit breaker patterns for fault tolerance</li> <li>Configurable retry policies with exponential backoff</li> <li>Request/response interceptors for cross-cutting concerns</li> <li>Comprehensive error handling and logging</li> <li>Service-specific configuration management</li> </ul>"},{"location":"features/#case-conversion-utilities","title":"\ud83d\udd24 Case Conversion utilities","text":"<p>Comprehensive string and object case conversion utilities supporting snake_case, camelCase, PascalCase, kebab-case, and Title Case transformations with Pydantic integration.</p> <p>Key Capabilities:</p> <ul> <li>Comprehensive case conversion (snake_case \u2194 camelCase \u2194 PascalCase \u2194 kebab-case \u2194 Title Case)</li> <li>Recursive dictionary key transformation for nested objects</li> <li>Pydantic CamelModel base class with automatic alias generation</li> <li>API serialization compatibility for different naming conventions</li> <li>Optional dependency management with graceful fallback</li> </ul>"},{"location":"features/#enhanced-model-validation","title":"\u2705 Enhanced Model Validation","text":"<p>Advanced validation system with business rules, conditional validation, custom validators, and comprehensive error reporting for complex domain logic validation.</p> <p>Key Capabilities:</p> <ul> <li>Business rule validation with fluent API</li> <li>Conditional validation rules that apply based on context</li> <li>Property and entity validators with composite logic</li> <li>Comprehensive error aggregation and field-specific reporting</li> <li>Decorator-based method parameter validation</li> <li>Integration with domain-driven design patterns</li> </ul>"},{"location":"features/#development-testing-features","title":"\ud83e\uddea Development &amp; Testing Features","text":"<p>All features include comprehensive testing support with:</p> <ul> <li>Unit Testing: Isolated testing with mocking support</li> <li>Integration Testing: Full-stack testing capabilities</li> <li>Performance Testing: Built-in performance monitoring</li> <li>Documentation: Comprehensive examples and guides</li> </ul>"},{"location":"features/#feature-integration","title":"\ud83d\udd17 Feature Integration","text":"<p>The framework features are designed to work together seamlessly:</p> <pre><code>graph TB\n    subgraph \"\ud83c\udf10 Presentation Layer\"\n        MVC[MVC Controllers]\n    end\n\n    subgraph \"\ud83d\udcbc Application Layer\"\n        Watcher[Watcher Patterns]\n        Validation[Model Validation]\n    end\n\n    subgraph \"\ud83c\udfdb\ufe0f Domain Layer\"\n        Resources[Resource Patterns]\n        Mapping[Object Mapping]\n    end\n\n    subgraph \"\ud83d\udd0c Infrastructure Layer\"\n        Data[Data Access]\n        Diagrams[Mermaid Diagrams]\n        Redis[Redis Cache]\n        HTTP[HTTP Client]\n        Background[Background Tasks]\n    end\n\n    MVC --&gt; Watcher\n    MVC --&gt; Data\n    Watcher --&gt; Resources\n    Mapping --&gt; Data\n\n    Redis -.-&gt; Data\n    HTTP -.-&gt; MVC\n    Background -.-&gt; Watcher\n\n    style MVC fill:#e3f2fd\n    style Watcher fill:#f3e5f5\n    style Resources fill:#e8f5e8\n    style Data fill:#fff3e0</code></pre>"},{"location":"features/#getting-started","title":"\ud83d\ude80 Getting Started","text":"<ol> <li>Start with \ud83d\udcd6 Architecture Patterns - Foundation patterns (DI, CQRS, etc.)</li> <li>Implement MVC Controllers - API layer development</li> <li>Choose Data Access - Persistence strategy</li> <li>Add Object Mapping - Data transformation</li> <li>Enhance with specialized features - Caching, validation, watchers, etc.</li> </ol>"},{"location":"features/#related-documentation","title":"\ud83d\udcda Related Documentation","text":"<ul> <li>\ud83c\udfaf Architecture Patterns - Design patterns and principles</li> <li>\ud83d\udcd6 Implementation Guides - Step-by-step implementation guides</li> <li>\ud83c\udf55 Mario's Pizzeria - Complete working example</li> <li>\ud83d\udcbc Sample Applications - Real-world implementation examples</li> </ul> <p>Each feature page contains detailed implementation examples, best practices, and integration patterns. The framework is designed to be incrementally adoptable - start with the core features and add specialized capabilities as needed.</p>"},{"location":"features/background-task-scheduling/","title":"\u23f0 Background Task Scheduling","text":"<p>The Neuroglia framework provides enterprise-grade background task scheduling capabilities through seamless APScheduler integration, enabling complex workflow orchestration with Redis persistence, reactive stream processing, and comprehensive error handling.</p>"},{"location":"features/background-task-scheduling/#overview","title":"\ud83c\udfaf Overview","text":"<p>Background task scheduling is essential for microservices that need to perform operations asynchronously, handle periodic tasks, or respond to events with delayed processing. The framework's implementation provides:</p> <ul> <li>APScheduler Integration: Full integration with Advanced Python Scheduler</li> <li>Redis Persistence: Distributed job persistence across service instances</li> <li>Reactive Processing: Real-time event stream processing</li> <li>Fault Tolerance: Circuit breaker patterns and retry policies</li> <li>Monitoring: Comprehensive job execution monitoring and error handling</li> </ul>"},{"location":"features/background-task-scheduling/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>graph TB\n    subgraph \"\ud83c\udf55 Mario's Pizzeria Application\"\n        OrderService[Order Service]\n        DeliveryService[Delivery Service]\n        KitchenService[Kitchen Service]\n    end\n\n    subgraph \"\u23f0 Background Task Scheduler\"\n        Scheduler[Task Scheduler]\n        JobStore[Redis Job Store]\n        Executor[Task Executor]\n    end\n\n    subgraph \"\ud83d\udd04 Task Types\"\n        Periodic[Periodic Tasks]\n        Delayed[Delayed Tasks]\n        Reactive[Event-Driven Tasks]\n    end\n\n    OrderService --&gt; Scheduler\n    DeliveryService --&gt; Scheduler\n    KitchenService --&gt; Scheduler\n\n    Scheduler --&gt; JobStore\n    Scheduler --&gt; Executor\n\n    Executor --&gt; Periodic\n    Executor --&gt; Delayed\n    Executor --&gt; Reactive\n\n    style Scheduler fill:#e3f2fd\n    style JobStore fill:#ffebee\n    style Executor fill:#e8f5e8</code></pre>"},{"location":"features/background-task-scheduling/#basic-usage","title":"\ud83d\ude80 Basic Usage","text":""},{"location":"features/background-task-scheduling/#service-registration","title":"Service Registration","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.scheduling import BackgroundTaskScheduler\n\ndef create_app():\n    builder = WebApplicationBuilder()\n\n    # Register background task scheduler\n    builder.services.add_background_task_scheduler(\n        redis_url=\"redis://localhost:6379\",\n        job_store_prefix=\"mario_pizzeria\"\n    )\n\n    app = builder.build()\n    return app\n</code></pre>"},{"location":"features/background-task-scheduling/#scheduled-task-definition","title":"Scheduled Task Definition","text":"<pre><code>from neuroglia.scheduling import BackgroundTask, schedule_task\nfrom neuroglia.dependency_injection import ServiceProviderBase\nfrom datetime import datetime, timedelta\n\nclass PizzaOrderService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.service_provider = service_provider\n        self.scheduler = service_provider.get_service(BackgroundTaskScheduler)\n\n    async def schedule_order_reminders(self, order_id: str):\n        \"\"\"Schedule reminder tasks for a pizza order.\"\"\"\n\n        # Schedule preparation reminder (15 minutes)\n        await self.scheduler.schedule_delayed_task(\n            \"order_preparation_reminder\",\n            self.send_preparation_reminder,\n            delay_minutes=15,\n            args=[order_id],\n            tags=[\"order\", \"reminder\"]\n        )\n\n        # Schedule delivery reminder (45 minutes)\n        await self.scheduler.schedule_delayed_task(\n            \"order_delivery_reminder\",\n            self.send_delivery_reminder,\n            delay_minutes=45,\n            args=[order_id],\n            tags=[\"delivery\", \"reminder\"]\n        )\n\n    async def send_preparation_reminder(self, order_id: str):\n        \"\"\"Send preparation reminder to kitchen.\"\"\"\n        print(f\"\ud83c\udf55 Kitchen reminder: Start preparing order {order_id}\")\n\n        # Business logic for kitchen notification\n        kitchen_service = self.service_provider.get_service(KitchenService)\n        await kitchen_service.notify_preparation_due(order_id)\n\n    async def send_delivery_reminder(self, order_id: str):\n        \"\"\"Send delivery reminder to delivery team.\"\"\"\n        print(f\"\ud83d\ude9a Delivery reminder: Order {order_id} ready for delivery\")\n\n        # Business logic for delivery notification\n        delivery_service = self.service_provider.get_service(DeliveryService)\n        await delivery_service.schedule_pickup(order_id)\n</code></pre>"},{"location":"features/background-task-scheduling/#periodic-tasks","title":"\ud83d\udcc5 Periodic Tasks","text":""},{"location":"features/background-task-scheduling/#daily-operations","title":"Daily Operations","text":"<pre><code>@schedule_task(cron=\"0 8 * * *\")  # Daily at 8 AM\nasync def daily_inventory_check():\n    \"\"\"Check pizza ingredient inventory daily.\"\"\"\n    inventory_service = get_service(InventoryService)\n\n    # Check ingredient levels\n    low_ingredients = await inventory_service.get_low_stock_ingredients()\n\n    if low_ingredients:\n        # Schedule reorder tasks\n        for ingredient in low_ingredients:\n            await schedule_ingredient_reorder(ingredient)\n\n    print(f\"\ud83d\udcca Daily inventory check completed: {len(low_ingredients)} items need reordering\")\n\n@schedule_task(cron=\"0 23 * * *\")  # Daily at 11 PM\nasync def daily_sales_report():\n    \"\"\"Generate daily sales report.\"\"\"\n    analytics_service = get_service(AnalyticsService)\n\n    today = datetime.now().date()\n    report = await analytics_service.generate_daily_report(today)\n\n    # Send report to management\n    notification_service = get_service(NotificationService)\n    await notification_service.send_sales_report(report)\n\n    print(f\"\ud83d\udcc8 Daily sales report generated: {report.total_orders} orders, ${report.total_revenue}\")\n</code></pre>"},{"location":"features/background-task-scheduling/#hourly-monitoring","title":"Hourly Monitoring","text":"<pre><code>@schedule_task(cron=\"0 * * * *\")  # Every hour\nasync def hourly_order_monitoring():\n    \"\"\"Monitor order processing efficiency.\"\"\"\n    order_service = get_service(OrderService)\n\n    # Check for delayed orders\n    delayed_orders = await order_service.get_delayed_orders()\n\n    for order in delayed_orders:\n        # Escalate delayed orders\n        await order_service.escalate_delayed_order(order.id)\n\n        # Notify customer\n        notification_service = get_service(NotificationService)\n        await notification_service.send_delay_notification(order.customer_id, order.id)\n\n    print(f\"\ud83d\udd0d Hourly monitoring: {len(delayed_orders)} delayed orders processed\")\n</code></pre>"},{"location":"features/background-task-scheduling/#reactive-task-processing","title":"\ud83d\udd04 Reactive Task Processing","text":""},{"location":"features/background-task-scheduling/#event-driven-scheduling","title":"Event-Driven Scheduling","text":"<pre><code>from neuroglia.eventing import EventHandler, DomainEvent\nfrom neuroglia.scheduling import ReactiveTaskProcessor\n\nclass OrderPlacedEvent(DomainEvent):\n    def __init__(self, order_id: str, customer_id: str, estimated_delivery: datetime):\n        super().__init__()\n        self.order_id = order_id\n        self.customer_id = customer_id\n        self.estimated_delivery = estimated_delivery\n\nclass OrderTaskScheduler(EventHandler[OrderPlacedEvent]):\n    def __init__(self, task_scheduler: BackgroundTaskScheduler):\n        self.task_scheduler = task_scheduler\n\n    async def handle_async(self, event: OrderPlacedEvent):\n        \"\"\"Schedule all tasks related to a new order.\"\"\"\n\n        # Schedule kitchen preparation task\n        prep_time = event.estimated_delivery - timedelta(minutes=30)\n        await self.task_scheduler.schedule_at(\n            \"kitchen_preparation\",\n            self.start_kitchen_preparation,\n            scheduled_time=prep_time,\n            args=[event.order_id]\n        )\n\n        # Schedule delivery dispatch task\n        dispatch_time = event.estimated_delivery - timedelta(minutes=10)\n        await self.task_scheduler.schedule_at(\n            \"delivery_dispatch\",\n            self.dispatch_delivery,\n            scheduled_time=dispatch_time,\n            args=[event.order_id, event.customer_id]\n        )\n\n        # Schedule customer notification task\n        notify_time = event.estimated_delivery - timedelta(minutes=5)\n        await self.task_scheduler.schedule_at(\n            \"customer_notification\",\n            self.notify_customer_ready,\n            scheduled_time=notify_time,\n            args=[event.customer_id, event.order_id]\n        )\n</code></pre>"},{"location":"features/background-task-scheduling/#stream-processing-integration","title":"Stream Processing Integration","text":"<pre><code>from neuroglia.reactive import Observable, StreamProcessor\n\nclass OrderStreamProcessor(StreamProcessor):\n    def __init__(self, task_scheduler: BackgroundTaskScheduler):\n        self.task_scheduler = task_scheduler\n        self.order_stream = Observable.create_subject()\n\n    async def process_order_events(self):\n        \"\"\"Process continuous stream of order events.\"\"\"\n\n        async def handle_order_stream(order_event):\n            if order_event.type == \"order_placed\":\n                await self.schedule_order_workflow(order_event)\n            elif order_event.type == \"order_cancelled\":\n                await self.cancel_order_tasks(order_event.order_id)\n            elif order_event.type == \"order_modified\":\n                await self.reschedule_order_tasks(order_event)\n\n        # Subscribe to order event stream\n        self.order_stream.subscribe(handle_order_stream)\n\n    async def schedule_order_workflow(self, order_event):\n        \"\"\"Schedule complete order workflow.\"\"\"\n        workflow_tasks = [\n            (\"inventory_check\", 0, self.check_inventory),\n            (\"kitchen_queue\", 5, self.add_to_kitchen_queue),\n            (\"preparation_start\", 15, self.start_preparation),\n            (\"quality_check\", 25, self.perform_quality_check),\n            (\"delivery_ready\", 35, self.mark_ready_for_delivery)\n        ]\n\n        for task_name, delay_minutes, task_func in workflow_tasks:\n            await self.task_scheduler.schedule_delayed_task(\n                f\"{task_name}_{order_event.order_id}\",\n                task_func,\n                delay_minutes=delay_minutes,\n                args=[order_event.order_id],\n                tags=[\"workflow\", order_event.order_id]\n            )\n</code></pre>"},{"location":"features/background-task-scheduling/#error-handling-and-resilience","title":"\ud83d\udee1\ufe0f Error Handling and Resilience","text":""},{"location":"features/background-task-scheduling/#circuit-breaker-integration","title":"Circuit Breaker Integration","text":"<pre><code>from neuroglia.scheduling import CircuitBreakerPolicy, RetryPolicy\n\nclass ResilientOrderProcessor:\n    def __init__(self, task_scheduler: BackgroundTaskScheduler):\n        self.task_scheduler = task_scheduler\n\n        # Configure circuit breaker for external services\n        self.circuit_breaker = CircuitBreakerPolicy(\n            failure_threshold=5,\n            recovery_timeout=60,\n            success_threshold=3\n        )\n\n        # Configure retry policy\n        self.retry_policy = RetryPolicy(\n            max_attempts=3,\n            backoff_factor=2.0,\n            max_delay=300\n        )\n\n    @circuit_breaker.apply\n    @retry_policy.apply\n    async def process_payment_task(self, order_id: str, amount: float):\n        \"\"\"Process payment with circuit breaker and retry policies.\"\"\"\n        try:\n            payment_service = get_service(PaymentService)\n            result = await payment_service.charge_customer(order_id, amount)\n\n            if result.success:\n                # Schedule order fulfillment\n                await self.task_scheduler.schedule_immediate_task(\n                    \"order_fulfillment\",\n                    self.fulfill_order,\n                    args=[order_id]\n                )\n            else:\n                # Schedule payment retry\n                await self.task_scheduler.schedule_delayed_task(\n                    \"payment_retry\",\n                    self.retry_payment,\n                    delay_minutes=5,\n                    args=[order_id, amount]\n                )\n\n        except PaymentServiceUnavailableError:\n            # Schedule fallback payment processing\n            await self.task_scheduler.schedule_delayed_task(\n                \"fallback_payment\",\n                self.process_fallback_payment,\n                delay_minutes=10,\n                args=[order_id, amount]\n            )\n</code></pre>"},{"location":"features/background-task-scheduling/#comprehensive-error-monitoring","title":"Comprehensive Error Monitoring","text":"<pre><code>from neuroglia.scheduling import TaskExecutionResult, TaskFailureHandler\n\nclass OrderTaskMonitor(TaskFailureHandler):\n    def __init__(self, notification_service: NotificationService):\n        self.notification_service = notification_service\n\n    async def handle_task_failure(self, task_name: str, exception: Exception, context: dict):\n        \"\"\"Handle task execution failures with comprehensive logging.\"\"\"\n\n        error_details = {\n            \"task_name\": task_name,\n            \"error_type\": type(exception).__name__,\n            \"error_message\": str(exception),\n            \"execution_time\": context.get(\"execution_time\"),\n            \"retry_count\": context.get(\"retry_count\", 0)\n        }\n\n        # Log error details\n        logger.error(f\"Task execution failed: {task_name}\", extra=error_details)\n\n        # Critical task failure notifications\n        if task_name.startswith(\"payment_\") or task_name.startswith(\"order_\"):\n            await self.notification_service.send_critical_alert(\n                f\"Critical task failure: {task_name}\",\n                error_details\n            )\n\n        # Schedule recovery tasks based on failure type\n        if isinstance(exception, InventoryShortageError):\n            await self.schedule_inventory_reorder(context.get(\"order_id\"))\n        elif isinstance(exception, KitchenOverloadError):\n            await self.schedule_order_delay_notification(context.get(\"order_id\"))\n\n    async def handle_task_success(self, task_name: str, result: any, context: dict):\n        \"\"\"Monitor successful task executions.\"\"\"\n\n        # Track task performance metrics\n        execution_time = context.get(\"execution_time\")\n        if execution_time &gt; 30:  # Tasks taking longer than 30 seconds\n            logger.warning(f\"Slow task execution: {task_name} took {execution_time}s\")\n\n        # Update order status based on completed tasks\n        if task_name.startswith(\"delivery_\"):\n            order_id = context.get(\"order_id\")\n            await self.update_order_status(order_id, \"delivered\")\n</code></pre>"},{"location":"features/background-task-scheduling/#advanced-configuration","title":"\ud83d\udd27 Advanced Configuration","text":""},{"location":"features/background-task-scheduling/#redis-job-store-configuration","title":"Redis Job Store Configuration","text":"<pre><code>from neuroglia.scheduling import RedisJobStoreConfig, SchedulerConfig\n\ndef configure_advanced_scheduler():\n    redis_config = RedisJobStoreConfig(\n        host=\"redis://localhost:6379\",\n        db=1,\n        password=\"your_redis_password\",\n        connection_pool_size=20,\n        health_check_interval=30,\n\n        # Job persistence settings\n        job_defaults={\n            'coalesce': True,\n            'max_instances': 3,\n            'misfire_grace_time': 300\n        },\n\n        # Distributed locking\n        distributed_lock_timeout=60,\n        lock_prefix=\"mario_pizzeria_locks\"\n    )\n\n    scheduler_config = SchedulerConfig(\n        job_stores={'redis': redis_config},\n        executors={\n            'default': {'type': 'threadpool', 'max_workers': 20},\n            'processpool': {'type': 'processpool', 'max_workers': 5}\n        },\n        job_defaults={\n            'coalesce': False,\n            'max_instances': 3\n        },\n        timezone='UTC'\n    )\n\n    return scheduler_config\n</code></pre>"},{"location":"features/background-task-scheduling/#custom-task-executors","title":"Custom Task Executors","text":"<pre><code>from neuroglia.scheduling import CustomTaskExecutor\nimport asyncio\n\nclass PizzaOrderExecutor(CustomTaskExecutor):\n    \"\"\"Custom executor optimized for pizza order processing.\"\"\"\n\n    def __init__(self, max_concurrent_orders: int = 10):\n        super().__init__()\n        self.semaphore = asyncio.Semaphore(max_concurrent_orders)\n        self.active_orders = set()\n\n    async def execute_task(self, task_func, *args, **kwargs):\n        \"\"\"Execute task with order-specific resource management.\"\"\"\n        async with self.semaphore:\n            order_id = kwargs.get('order_id') or args[0] if args else None\n\n            if order_id:\n                if order_id in self.active_orders:\n                    # Skip duplicate order processing\n                    return {\"status\": \"skipped\", \"reason\": \"already_processing\"}\n\n                self.active_orders.add(order_id)\n\n            try:\n                # Execute the actual task\n                result = await task_func(*args, **kwargs)\n                return {\"status\": \"completed\", \"result\": result}\n\n            except Exception as e:\n                return {\"status\": \"failed\", \"error\": str(e)}\n\n            finally:\n                if order_id:\n                    self.active_orders.discard(order_id)\n</code></pre>"},{"location":"features/background-task-scheduling/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"features/background-task-scheduling/#unit-testing-with-mocks","title":"Unit Testing with Mocks","text":"<pre><code>import pytest\nfrom unittest.mock import AsyncMock, Mock\nfrom neuroglia.scheduling import BackgroundTaskScheduler\n\nclass TestOrderTaskScheduling:\n\n    @pytest.fixture\n    def mock_scheduler(self):\n        scheduler = Mock(spec=BackgroundTaskScheduler)\n        scheduler.schedule_delayed_task = AsyncMock()\n        scheduler.schedule_at = AsyncMock()\n        return scheduler\n\n    @pytest.fixture\n    def order_service(self, mock_scheduler):\n        return PizzaOrderService(mock_scheduler)\n\n    @pytest.mark.asyncio\n    async def test_schedule_order_reminders(self, order_service, mock_scheduler):\n        \"\"\"Test order reminder scheduling.\"\"\"\n        order_id = \"order_123\"\n\n        await order_service.schedule_order_reminders(order_id)\n\n        # Verify preparation reminder scheduled\n        mock_scheduler.schedule_delayed_task.assert_any_call(\n            \"order_preparation_reminder\",\n            order_service.send_preparation_reminder,\n            delay_minutes=15,\n            args=[order_id],\n            tags=[\"order\", \"reminder\"]\n        )\n\n        # Verify delivery reminder scheduled\n        mock_scheduler.schedule_delayed_task.assert_any_call(\n            \"order_delivery_reminder\",\n            order_service.send_delivery_reminder,\n            delay_minutes=45,\n            args=[order_id],\n            tags=[\"delivery\", \"reminder\"]\n        )\n\n    @pytest.mark.asyncio\n    async def test_reactive_order_processing(self, mock_scheduler):\n        \"\"\"Test reactive task scheduling from events.\"\"\"\n        event = OrderPlacedEvent(\"order_123\", \"customer_456\", datetime.now() + timedelta(hours=1))\n        handler = OrderTaskScheduler(mock_scheduler)\n\n        await handler.handle_async(event)\n\n        # Verify all order-related tasks were scheduled\n        assert mock_scheduler.schedule_at.call_count == 3\n</code></pre>"},{"location":"features/background-task-scheduling/#integration-testing","title":"Integration Testing","text":"<pre><code>@pytest.mark.integration\nclass TestSchedulerIntegration:\n\n    @pytest.fixture\n    async def redis_scheduler(self):\n        scheduler = BackgroundTaskScheduler(\n            redis_url=\"redis://localhost:6379/15\",  # Test database\n            job_store_prefix=\"test_mario_pizzeria\"\n        )\n        await scheduler.start()\n        yield scheduler\n        await scheduler.shutdown()\n        await scheduler.clear_all_jobs()  # Cleanup\n\n    @pytest.mark.asyncio\n    async def test_end_to_end_order_workflow(self, redis_scheduler):\n        \"\"\"Test complete order processing workflow.\"\"\"\n        order_id = \"integration_test_order\"\n        executed_tasks = []\n\n        async def track_task_execution(task_name):\n            executed_tasks.append(task_name)\n\n        # Schedule workflow tasks\n        await redis_scheduler.schedule_immediate_task(\n            \"inventory_check\",\n            track_task_execution,\n            args=[\"inventory_check\"]\n        )\n\n        # Wait for task execution\n        await asyncio.sleep(2)\n\n        assert \"inventory_check\" in executed_tasks\n</code></pre>"},{"location":"features/background-task-scheduling/#monitoring-and-observability","title":"\ud83d\udcca Monitoring and Observability","text":""},{"location":"features/background-task-scheduling/#task-execution-metrics","title":"Task Execution Metrics","text":"<pre><code>from neuroglia.scheduling import TaskMetrics, MetricsCollector\n\nclass PizzaOrderMetrics(MetricsCollector):\n    def __init__(self):\n        self.metrics = TaskMetrics()\n\n    async def collect_order_metrics(self):\n        \"\"\"Collect pizza order processing metrics.\"\"\"\n        return {\n            \"total_orders_processed\": self.metrics.get_counter(\"orders_processed\"),\n            \"average_preparation_time\": self.metrics.get_gauge(\"avg_prep_time\"),\n            \"failed_tasks_count\": self.metrics.get_counter(\"task_failures\"),\n            \"active_tasks\": self.metrics.get_gauge(\"active_tasks\"),\n            \"task_queue_size\": self.metrics.get_gauge(\"queue_size\")\n        }\n\n    async def export_metrics_to_prometheus(self):\n        \"\"\"Export metrics in Prometheus format.\"\"\"\n        metrics = await self.collect_order_metrics()\n\n        prometheus_metrics = []\n        for metric_name, value in metrics.items():\n            prometheus_metrics.append(f\"mario_pizzeria_{metric_name} {value}\")\n\n        return \"\\n\".join(prometheus_metrics)\n</code></pre>"},{"location":"features/background-task-scheduling/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\ud83d\udd27 Dependency Injection - Service registration patterns</li> <li>\ud83d\udce8 Event Sourcing - Event-driven architecture</li> <li>\ud83d\udd04 Reactive Programming - Stream processing</li> <li>\u26a1 Redis Cache Repository - Distributed caching</li> <li>\ud83c\udf10 HTTP Service Client - External service integration</li> </ul> <p>The background task scheduling system provides enterprise-grade capabilities for building resilient, scalable microservices with complex workflow requirements. By leveraging APScheduler with Redis persistence and reactive processing, Mario's Pizzeria can handle high-volume operations with confidence and reliability.</p>"},{"location":"features/case-conversion-utilities/","title":"\ud83d\udd04 Case Conversion Utilities","text":"<p>The Neuroglia framework provides comprehensive case conversion utilities for seamless data transformation between different naming conventions, enabling smooth integration between frontend frameworks, APIs, and backend services with automatic Pydantic model integration.</p>"},{"location":"features/case-conversion-utilities/#overview","title":"\ud83c\udfaf Overview","text":"<p>Modern applications often need to work with multiple naming conventions simultaneously - JavaScript frontends use camelCase, Python backends use snake_case, and APIs might use kebab-case or PascalCase. The framework's case conversion utilities provide:</p> <ul> <li>Comprehensive Case Conversions: Support for all major naming conventions</li> <li>Pydantic Integration: Automatic model field conversion with CamelModel</li> <li>Dictionary Transformations: Deep conversion of nested data structures</li> <li>String Transformations: Individual string case conversions</li> <li>Preservation of Context: Maintains data integrity during conversions</li> <li>Performance Optimized: Efficient conversion algorithms with caching</li> </ul>"},{"location":"features/case-conversion-utilities/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>graph TB\n    subgraph \"\ud83c\udf55 Mario's Pizzeria Application\"\n        FrontendApp[React Frontend&lt;br/&gt;camelCase]\n        MobileApp[Mobile App&lt;br/&gt;camelCase]\n        ApiLayer[REST API&lt;br/&gt;kebab-case]\n        BackendService[Python Backend&lt;br/&gt;snake_case]\n    end\n\n    subgraph \"\ud83d\udd04 Case Conversion Layer\"\n        CaseConverter[Case Converter]\n        CamelModel[Pydantic CamelModel]\n        DictTransformer[Dictionary Transformer]\n        StringConverter[String Converter]\n    end\n\n    subgraph \"\ud83c\udfaf Conversion Types\"\n        SnakeCase[snake_case]\n        CamelCase[camelCase]\n        PascalCase[PascalCase]\n        KebabCase[kebab-case]\n        ScreamingSnake[SCREAMING_SNAKE]\n    end\n\n    FrontendApp --&gt; CaseConverter\n    MobileApp --&gt; CaseConverter\n    ApiLayer --&gt; CaseConverter\n    BackendService --&gt; CaseConverter\n\n    CaseConverter --&gt; CamelModel\n    CaseConverter --&gt; DictTransformer\n    CaseConverter --&gt; StringConverter\n\n    CamelModel --&gt; SnakeCase\n    CamelModel --&gt; CamelCase\n    DictTransformer --&gt; PascalCase\n    DictTransformer --&gt; KebabCase\n    StringConverter --&gt; ScreamingSnake\n\n    style CaseConverter fill:#e3f2fd\n    style CamelModel fill:#e8f5e8\n    style DictTransformer fill:#fff3e0\n    style StringConverter fill:#f3e5f5</code></pre>"},{"location":"features/case-conversion-utilities/#basic-usage","title":"\ud83d\ude80 Basic Usage","text":""},{"location":"features/case-conversion-utilities/#service-registration","title":"Service Registration","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.utilities.case_conversion import CaseConverter\n\ndef create_app():\n    builder = WebApplicationBuilder()\n\n    # Register case conversion utilities\n    builder.services.add_case_conversion_utilities()\n\n    app = builder.build()\n    return app\n</code></pre>"},{"location":"features/case-conversion-utilities/#string-case-conversions","title":"String Case Conversions","text":"<pre><code>from neuroglia.utilities.case_conversion import CaseConverter\n\nclass MenuItemService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.case_converter = service_provider.get_service(CaseConverter)\n\n    def demonstrate_string_conversions(self):\n        \"\"\"Demonstrate various string case conversions.\"\"\"\n\n        original_field = \"pizza_item_name\"\n\n        # Convert to different case formats\n        conversions = {\n            \"camelCase\": self.case_converter.to_camel_case(original_field),\n            \"PascalCase\": self.case_converter.to_pascal_case(original_field),\n            \"kebab-case\": self.case_converter.to_kebab_case(original_field),\n            \"SCREAMING_SNAKE\": self.case_converter.to_screaming_snake_case(original_field),\n            \"Title Case\": self.case_converter.to_title_case(original_field)\n        }\n\n        print(\"\ud83d\udd04 String Case Conversions:\")\n        print(f\"Original: {original_field}\")\n        for case_name, converted in conversions.items():\n            print(f\"{case_name}: {converted}\")\n\n        return conversions\n\n        # Output:\n        # Original: pizza_item_name\n        # camelCase: pizzaItemName\n        # PascalCase: PizzaItemName\n        # kebab-case: pizza-item-name\n        # SCREAMING_SNAKE: PIZZA_ITEM_NAME\n        # Title Case: Pizza Item Name\n\n    def convert_api_field_names(self, api_response: dict) -&gt; dict:\n        \"\"\"Convert API response field names from kebab-case to snake_case.\"\"\"\n\n        # Example API response with kebab-case fields\n        api_data = {\n            \"menu-item-id\": \"margherita_001\",\n            \"display-name\": \"Margherita Pizza\",\n            \"base-price\": 12.99,\n            \"available-sizes\": [\"small\", \"medium\", \"large\"],\n            \"nutritional-info\": {\n                \"calories-per-slice\": 285,\n                \"total-fat-grams\": 10.4,\n                \"protein-grams\": 12.2\n            }\n        }\n\n        # Convert all keys from kebab-case to snake_case\n        converted_data = self.case_converter.convert_dict_keys(\n            api_data,\n            target_case=\"snake_case\"\n        )\n\n        print(\"\ud83c\udf55 API Field Name Conversion:\")\n        print(f\"Original keys: {list(api_data.keys())}\")\n        print(f\"Converted keys: {list(converted_data.keys())}\")\n\n        return converted_data\n\n        # Result:\n        # {\n        #     \"menu_item_id\": \"margherita_001\",\n        #     \"display_name\": \"Margherita Pizza\",\n        #     \"base_price\": 12.99,\n        #     \"available_sizes\": [\"small\", \"medium\", \"large\"],\n        #     \"nutritional_info\": {\n        #         \"calories_per_slice\": 285,\n        #         \"total_fat_grams\": 10.4,\n        #         \"protein_grams\": 12.2\n        #     }\n        # }\n</code></pre>"},{"location":"features/case-conversion-utilities/#pydantic-camelmodel-integration","title":"\ud83d\udce6 Pydantic CamelModel Integration","text":""},{"location":"features/case-conversion-utilities/#automatic-field-conversion-models","title":"Automatic Field Conversion Models","text":"<pre><code>from neuroglia.utilities.case_conversion import CamelModel\nfrom pydantic import Field\nfrom typing import List, Optional\nfrom datetime import datetime\n\nclass PizzaOrderDto(CamelModel):\n    \"\"\"DTO that automatically converts between camelCase and snake_case.\"\"\"\n\n    order_id: str = Field(..., description=\"Unique order identifier\")\n    customer_name: str = Field(..., description=\"Customer full name\")\n    customer_email: str = Field(..., description=\"Customer email address\")\n    phone_number: Optional[str] = Field(None, description=\"Customer phone number\")\n\n    # Complex nested fields\n    delivery_address: 'DeliveryAddressDto' = Field(..., description=\"Delivery address details\")\n    order_items: List['OrderItemDto'] = Field(..., description=\"List of ordered items\")\n\n    # Calculated fields\n    subtotal_amount: float = Field(..., description=\"Subtotal before tax and delivery\")\n    tax_amount: float = Field(..., description=\"Tax amount\")\n    delivery_fee: float = Field(..., description=\"Delivery fee\")\n    total_amount: float = Field(..., description=\"Total order amount\")\n\n    # Timestamps\n    order_placed_at: datetime = Field(..., description=\"When order was placed\")\n    estimated_delivery_time: datetime = Field(..., description=\"Estimated delivery time\")\n\n    # Status and preferences\n    order_status: str = Field(default=\"pending\", description=\"Current order status\")\n    special_instructions: Optional[str] = Field(None, description=\"Special delivery instructions\")\n    is_rush_order: bool = Field(default=False, description=\"Rush order flag\")\n\nclass DeliveryAddressDto(CamelModel):\n    \"\"\"Delivery address with automatic case conversion.\"\"\"\n\n    street_address: str = Field(..., description=\"Street address\")\n    apartment_number: Optional[str] = Field(None, description=\"Apartment/unit number\")\n    city_name: str = Field(..., description=\"City name\")\n    state_code: str = Field(..., description=\"State/province code\")\n    postal_code: str = Field(..., description=\"ZIP/postal code\")\n    country_code: str = Field(default=\"US\", description=\"Country code\")\n\n    # Location metadata\n    is_business_address: bool = Field(default=False, description=\"Business address flag\")\n    delivery_instructions: Optional[str] = Field(None, description=\"Delivery instructions\")\n\nclass OrderItemDto(CamelModel):\n    \"\"\"Individual order item with case conversion.\"\"\"\n\n    menu_item_id: str = Field(..., description=\"Menu item identifier\")\n    item_name: str = Field(..., description=\"Menu item name\")\n    item_size: str = Field(..., description=\"Size selection\")\n    base_price: float = Field(..., description=\"Base item price\")\n\n    # Customizations\n    selected_toppings: List[str] = Field(default_factory=list, description=\"Selected toppings\")\n    removed_ingredients: List[str] = Field(default_factory=list, description=\"Removed ingredients\")\n    special_requests: Optional[str] = Field(None, description=\"Special preparation requests\")\n\n    # Pricing\n    toppings_price: float = Field(default=0.0, description=\"Additional toppings cost\")\n    item_quantity: int = Field(default=1, description=\"Quantity ordered\")\n    line_item_total: float = Field(..., description=\"Total for this line item\")\n\n# Usage demonstration\nclass OrderProcessingService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.case_converter = service_provider.get_service(CaseConverter)\n\n    def process_frontend_order(self, frontend_data: dict) -&gt; PizzaOrderDto:\n        \"\"\"Process order data from JavaScript frontend (camelCase).\"\"\"\n\n        # Frontend sends data in camelCase\n        frontend_order = {\n            \"orderId\": \"ORD_20241201_001\",\n            \"customerName\": \"Mario Rossi\",\n            \"customerEmail\": \"mario.rossi@email.com\",\n            \"phoneNumber\": \"+1-555-0123\",\n            \"deliveryAddress\": {\n                \"streetAddress\": \"123 Pizza Street\",\n                \"apartmentNumber\": \"Apt 2B\",\n                \"cityName\": \"New York\",\n                \"stateCode\": \"NY\",\n                \"postalCode\": \"10001\",\n                \"isBusinessAddress\": False,\n                \"deliveryInstructions\": \"Ring doorbell twice\"\n            },\n            \"orderItems\": [\n                {\n                    \"menuItemId\": \"margherita_large\",\n                    \"itemName\": \"Margherita Pizza\",\n                    \"itemSize\": \"large\",\n                    \"basePrice\": 18.99,\n                    \"selectedToppings\": [\"extra_cheese\", \"fresh_basil\"],\n                    \"removedIngredients\": [],\n                    \"toppingsPrice\": 3.50,\n                    \"itemQuantity\": 2,\n                    \"lineItemTotal\": 44.98\n                }\n            ],\n            \"subtotalAmount\": 44.98,\n            \"taxAmount\": 3.60,\n            \"deliveryFee\": 2.99,\n            \"totalAmount\": 51.57,\n            \"orderPlacedAt\": \"2024-12-01T14:30:00Z\",\n            \"estimatedDeliveryTime\": \"2024-12-01T15:15:00Z\",\n            \"specialInstructions\": \"Please call when arriving\",\n            \"isRushOrder\": True\n        }\n\n        # CamelModel automatically converts camelCase to snake_case for internal processing\n        order_dto = PizzaOrderDto(**frontend_order)\n\n        print(\"\ud83c\udf55 Order processed from frontend:\")\n        print(f\"Order ID: {order_dto.order_id}\")\n        print(f\"Customer: {order_dto.customer_name}\")\n        print(f\"Items: {len(order_dto.order_items)}\")\n        print(f\"Total: ${order_dto.total_amount}\")\n\n        return order_dto\n\n    def send_to_frontend(self, order: PizzaOrderDto) -&gt; dict:\n        \"\"\"Convert order back to camelCase for frontend response.\"\"\"\n\n        # CamelModel automatically converts snake_case to camelCase for API response\n        frontend_response = order.dict(by_alias=True)  # Uses camelCase aliases\n\n        print(\"\ud83d\udce4 Sending to frontend in camelCase:\")\n        print(f\"Keys: {list(frontend_response.keys())}\")\n\n        return frontend_response\n\n        # Response will have camelCase keys:\n        # {\n        #     \"orderId\": \"ORD_20241201_001\",\n        #     \"customerName\": \"Mario Rossi\",\n        #     \"customerEmail\": \"mario.rossi@email.com\",\n        #     \"deliveryAddress\": {...},\n        #     \"orderItems\": [...],\n        #     \"totalAmount\": 51.57,\n        #     ...\n        # }\n</code></pre>"},{"location":"features/case-conversion-utilities/#dictionary-transformations","title":"\ud83d\udd04 Dictionary Transformations","text":""},{"location":"features/case-conversion-utilities/#deep-nested-structure-conversion","title":"Deep Nested Structure Conversion","text":"<pre><code>from neuroglia.utilities.case_conversion import DictCaseConverter\n\nclass MenuManagementService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.dict_converter = service_provider.get_service(DictCaseConverter)\n\n    def process_complex_menu_data(self):\n        \"\"\"Process complex nested menu data with different case conventions.\"\"\"\n\n        # Complex menu structure from external system (mixed case conventions)\n        external_menu_data = {\n            \"restaurantInfo\": {\n                \"restaurant_name\": \"Mario's Pizzeria\",\n                \"businessHours\": {\n                    \"monday-friday\": {\n                        \"opening_time\": \"11:00\",\n                        \"closingTime\": \"22:00\"\n                    },\n                    \"weekend_hours\": {\n                        \"saturday_opening\": \"12:00\",\n                        \"sunday-closing\": \"21:00\"\n                    }\n                },\n                \"contact-information\": {\n                    \"phone_number\": \"+1-555-PIZZA\",\n                    \"emailAddress\": \"orders@mariospizzeria.com\"\n                }\n            },\n            \"menuCategories\": [\n                {\n                    \"category_id\": \"pizzas\",\n                    \"displayName\": \"Artisan Pizzas\",\n                    \"menu-items\": [\n                        {\n                            \"item_id\": \"margherita_classic\",\n                            \"itemName\": \"Classic Margherita\",\n                            \"basePrice\": 16.99,\n                            \"available-sizes\": {\n                                \"small_size\": {\"price\": 12.99, \"diameter_inches\": 10},\n                                \"mediumSize\": {\"price\": 16.99, \"diameter-inches\": 12},\n                                \"large_option\": {\"price\": 21.99, \"diameter_inches\": 14}\n                            },\n                            \"nutritional-data\": {\n                                \"calories_per_slice\": 285,\n                                \"macroNutrients\": {\n                                    \"total_fat\": 10.4,\n                                    \"saturatedFat\": 4.8,\n                                    \"total-carbs\": 36.2,\n                                    \"protein_content\": 12.2\n                                },\n                                \"allergen-info\": {\n                                    \"contains_gluten\": True,\n                                    \"dairy_products\": True,\n                                    \"nut_free\": True\n                                }\n                            }\n                        }\n                    ]\n                }\n            ]\n        }\n\n        # Convert entire structure to consistent snake_case\n        snake_case_menu = self.dict_converter.convert_nested_dict(\n            external_menu_data,\n            target_case=\"snake_case\",\n            preserve_arrays=True,\n            max_depth=10\n        )\n\n        print(\"\ud83d\udc0d Converted to snake_case:\")\n        self.print_menu_structure(snake_case_menu)\n\n        # Convert to camelCase for frontend API\n        camel_case_menu = self.dict_converter.convert_nested_dict(\n            snake_case_menu,\n            target_case=\"camelCase\",\n            preserve_arrays=True\n        )\n\n        print(\"\ud83d\udc2a Converted to camelCase:\")\n        self.print_menu_structure(camel_case_menu)\n\n        # Convert to kebab-case for URL-friendly slugs\n        kebab_case_menu = self.dict_converter.convert_nested_dict(\n            snake_case_menu,\n            target_case=\"kebab-case\",\n            preserve_arrays=True,\n            key_filter=lambda key: key not in ['item_id', 'category_id']  # Preserve IDs\n        )\n\n        return {\n            \"snake_case\": snake_case_menu,\n            \"camelCase\": camel_case_menu,\n            \"kebab-case\": kebab_case_menu\n        }\n\n    def print_menu_structure(self, menu_data: dict, indent: int = 0):\n        \"\"\"Print menu structure with indentation.\"\"\"\n        for key, value in menu_data.items():\n            if isinstance(value, dict):\n                print(\"  \" * indent + f\"\ud83d\udcc1 {key}:\")\n                self.print_menu_structure(value, indent + 1)\n            elif isinstance(value, list) and value and isinstance(value[0], dict):\n                print(\"  \" * indent + f\"\ud83d\udccb {key}: [{len(value)} items]\")\n            else:\n                print(\"  \" * indent + f\"\ud83d\udcc4 {key}: {type(value).__name__}\")\n</code></pre>"},{"location":"features/case-conversion-utilities/#selective-field-conversion","title":"Selective Field Conversion","text":"<pre><code>class CustomerProfileService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.dict_converter = service_provider.get_service(DictCaseConverter)\n\n    def convert_with_field_mapping(self, customer_data: dict) -&gt; dict:\n        \"\"\"Convert customer data with custom field mappings.\"\"\"\n\n        # Original customer data from CRM system\n        crm_customer_data = {\n            \"customer_id\": \"CUST_001\",\n            \"personalInfo\": {\n                \"firstName\": \"Giuseppe\",\n                \"lastName\": \"Verdi\",\n                \"date_of_birth\": \"1985-03-15\",\n                \"email-address\": \"giuseppe.verdi@email.com\"\n            },\n            \"loyaltyProgram\": {\n                \"membership_level\": \"gold\",\n                \"points_balance\": 1250,\n                \"next-reward-threshold\": 1500\n            },\n            \"orderHistory\": {\n                \"total_orders\": 47,\n                \"favorite-items\": [\"margherita\", \"quattro_stagioni\"],\n                \"average_order_value\": 28.75\n            }\n        }\n\n        # Define custom field mappings\n        field_mappings = {\n            \"firstName\": \"given_name\",\n            \"lastName\": \"family_name\",\n            \"email-address\": \"primary_email\",\n            \"membership_level\": \"loyalty_tier\",\n            \"points_balance\": \"reward_points\",\n            \"next-reward-threshold\": \"next_milestone\",\n            \"favorite-items\": \"preferred_menu_items\",\n            \"average_order_value\": \"avg_purchase_amount\"\n        }\n\n        # Convert with custom mappings and case conversion\n        converted_data = self.dict_converter.convert_with_mapping(\n            crm_customer_data,\n            field_mappings=field_mappings,\n            target_case=\"snake_case\",\n            preserve_structure=True\n        )\n\n        print(\"\ud83d\udc64 Customer Data Conversion:\")\n        print(f\"Original keys: {self.get_all_keys(crm_customer_data)}\")\n        print(f\"Converted keys: {self.get_all_keys(converted_data)}\")\n\n        return converted_data\n\n        # Result:\n        # {\n        #     \"customer_id\": \"CUST_001\",\n        #     \"personal_info\": {\n        #         \"given_name\": \"Giuseppe\",\n        #         \"family_name\": \"Verdi\",\n        #         \"date_of_birth\": \"1985-03-15\",\n        #         \"primary_email\": \"giuseppe.verdi@email.com\"\n        #     },\n        #     \"loyalty_program\": {\n        #         \"loyalty_tier\": \"gold\",\n        #         \"reward_points\": 1250,\n        #         \"next_milestone\": 1500\n        #     },\n        #     \"order_history\": {\n        #         \"total_orders\": 47,\n        #         \"preferred_menu_items\": [\"margherita\", \"quattro_stagioni\"],\n        #         \"avg_purchase_amount\": 28.75\n        #     }\n        # }\n\n    def get_all_keys(self, data: dict, keys=None) -&gt; list:\n        \"\"\"Recursively get all keys from nested dictionary.\"\"\"\n        if keys is None:\n            keys = []\n\n        for key, value in data.items():\n            keys.append(key)\n            if isinstance(value, dict):\n                self.get_all_keys(value, keys)\n\n        return keys\n</code></pre>"},{"location":"features/case-conversion-utilities/#advanced-case-conversion-patterns","title":"\ud83c\udfa8 Advanced Case Conversion Patterns","text":""},{"location":"features/case-conversion-utilities/#api-boundary-conversion","title":"API Boundary Conversion","text":"<pre><code>from neuroglia.mvc import ControllerBase\nfrom neuroglia.utilities.case_conversion import ApiCaseConverter\n\nclass PizzaMenuController(ControllerBase):\n    \"\"\"Controller demonstrating automatic case conversion at API boundaries.\"\"\"\n\n    def __init__(self, service_provider: ServiceProviderBase,\n                 mapper: Mapper, mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n        self.api_converter = service_provider.get_service(ApiCaseConverter)\n\n    @get(\"/menu/{category_id}\")\n    async def get_menu_category(self, category_id: str) -&gt; dict:\n        \"\"\"Get menu category with automatic case conversion for API response.\"\"\"\n\n        # Internal service returns snake_case data\n        internal_menu_data = await self.get_internal_menu_data(category_id)\n\n        # Convert to camelCase for frontend consumption\n        api_response = self.api_converter.convert_for_api_response(\n            internal_menu_data,\n            input_case=\"snake_case\",\n            output_case=\"camelCase\"\n        )\n\n        return api_response\n\n    @post(\"/menu/items\")\n    async def create_menu_item(self, menu_item_data: dict) -&gt; dict:\n        \"\"\"Create menu item with automatic request/response conversion.\"\"\"\n\n        # Frontend sends camelCase data\n        print(f\"\ud83d\udce5 Received from frontend: {list(menu_item_data.keys())}\")\n\n        # Convert to snake_case for internal processing\n        internal_data = self.api_converter.convert_for_internal_processing(\n            menu_item_data,\n            input_case=\"camelCase\",\n            output_case=\"snake_case\"\n        )\n\n        print(f\"\ud83d\udd04 Converted for internal use: {list(internal_data.keys())}\")\n\n        # Process internally (snake_case)\n        created_item = await self.create_internal_menu_item(internal_data)\n\n        # Convert response back to camelCase\n        api_response = self.api_converter.convert_for_api_response(\n            created_item,\n            input_case=\"snake_case\",\n            output_case=\"camelCase\"\n        )\n\n        print(f\"\ud83d\udce4 Sending to frontend: {list(api_response.keys())}\")\n\n        return api_response\n\nclass DatabaseIntegrationService:\n    \"\"\"Service demonstrating database field name conversion.\"\"\"\n\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.case_converter = service_provider.get_service(CaseConverter)\n        self.db_converter = service_provider.get_service(DatabaseCaseConverter)\n\n    async def save_order_with_field_mapping(self, order_data: dict):\n        \"\"\"Save order data with database field name conversion.\"\"\"\n\n        # Application uses snake_case\n        application_order = {\n            \"order_id\": \"ORD_001\",\n            \"customer_name\": \"Mario Rossi\",\n            \"order_total\": 45.99,\n            \"delivery_address\": \"123 Main St\",\n            \"order_status\": \"confirmed\",\n            \"created_at\": datetime.utcnow(),\n            \"estimated_delivery\": datetime.utcnow() + timedelta(minutes=30)\n        }\n\n        # Database uses different naming convention\n        database_field_mapping = {\n            \"order_id\": \"ORDER_ID\",\n            \"customer_name\": \"CUSTOMER_FULL_NAME\",\n            \"order_total\": \"TOTAL_AMOUNT_USD\",\n            \"delivery_address\": \"DELIVERY_ADDR_LINE1\",\n            \"order_status\": \"ORDER_STATUS_CODE\",\n            \"created_at\": \"CREATED_TIMESTAMP\",\n            \"estimated_delivery\": \"EST_DELIVERY_TIME\"\n        }\n\n        # Convert for database insertion\n        database_record = self.db_converter.convert_for_database(\n            application_order,\n            field_mapping=database_field_mapping,\n            target_case=\"SCREAMING_SNAKE_CASE\"\n        )\n\n        print(\"\ud83d\udcbe Database Record:\")\n        for db_field, value in database_record.items():\n            print(f\"  {db_field}: {value}\")\n\n        # Simulate database save\n        await self.save_to_database(database_record)\n\n        return database_record\n</code></pre>"},{"location":"features/case-conversion-utilities/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"features/case-conversion-utilities/#case-conversion-testing","title":"Case Conversion Testing","text":"<pre><code>import pytest\nfrom neuroglia.utilities.case_conversion import CaseConverter, CamelModel\n\nclass TestCaseConversions:\n\n    @pytest.fixture\n    def case_converter(self):\n        return CaseConverter()\n\n    def test_string_case_conversions(self, case_converter):\n        \"\"\"Test various string case conversions.\"\"\"\n\n        test_cases = [\n            # (input, expected_camel, expected_pascal, expected_kebab, expected_snake)\n            (\"hello_world\", \"helloWorld\", \"HelloWorld\", \"hello-world\", \"hello_world\"),\n            (\"getUserName\", \"getUserName\", \"GetUserName\", \"get-user-name\", \"get_user_name\"),\n            (\"XML-HTTP-Request\", \"xmlHttpRequest\", \"XmlHttpRequest\", \"xml-http-request\", \"xml_http_request\"),\n            (\"pizza_item_ID\", \"pizzaItemId\", \"PizzaItemId\", \"pizza-item-id\", \"pizza_item_id\"),\n        ]\n\n        for input_str, expected_camel, expected_pascal, expected_kebab, expected_snake in test_cases:\n            assert case_converter.to_camel_case(input_str) == expected_camel\n            assert case_converter.to_pascal_case(input_str) == expected_pascal\n            assert case_converter.to_kebab_case(input_str) == expected_kebab\n            assert case_converter.to_snake_case(input_str) == expected_snake\n\n    def test_nested_dict_conversion(self, case_converter):\n        \"\"\"Test nested dictionary case conversion.\"\"\"\n\n        input_dict = {\n            \"user_name\": \"Mario\",\n            \"contactInfo\": {\n                \"email_address\": \"mario@test.com\",\n                \"phoneNumber\": \"+1234567890\"\n            },\n            \"orderHistory\": [\n                {\n                    \"order_id\": \"001\",\n                    \"totalAmount\": 25.99\n                }\n            ]\n        }\n\n        # Convert to camelCase\n        camel_result = case_converter.convert_dict_keys(input_dict, \"camelCase\")\n\n        assert \"userName\" in camel_result\n        assert \"contactInfo\" in camel_result\n        assert \"emailAddress\" in camel_result[\"contactInfo\"]\n        assert \"phoneNumber\" in camel_result[\"contactInfo\"]\n        assert \"orderId\" in camel_result[\"orderHistory\"][0]\n        assert \"totalAmount\" in camel_result[\"orderHistory\"][0]\n\n    def test_camel_model_integration(self):\n        \"\"\"Test Pydantic CamelModel integration.\"\"\"\n\n        class TestModel(CamelModel):\n            user_name: str\n            email_address: str\n            phone_number: Optional[str] = None\n\n        # Test with camelCase input\n        camel_data = {\n            \"userName\": \"Mario\",\n            \"emailAddress\": \"mario@test.com\",\n            \"phoneNumber\": \"+1234567890\"\n        }\n\n        model = TestModel(**camel_data)\n\n        # Internal representation uses snake_case\n        assert model.user_name == \"Mario\"\n        assert model.email_address == \"mario@test.com\"\n        assert model.phone_number == \"+1234567890\"\n\n        # Export with camelCase aliases\n        exported = model.dict(by_alias=True)\n        assert \"userName\" in exported\n        assert \"emailAddress\" in exported\n        assert \"phoneNumber\" in exported\n\n    @pytest.mark.parametrize(\"input_case,output_case,input_key,expected_key\", [\n        (\"snake_case\", \"camelCase\", \"pizza_item_name\", \"pizzaItemName\"),\n        (\"camelCase\", \"snake_case\", \"pizzaItemName\", \"pizza_item_name\"),\n        (\"kebab-case\", \"PascalCase\", \"pizza-item-name\", \"PizzaItemName\"),\n        (\"PascalCase\", \"kebab-case\", \"PizzaItemName\", \"pizza-item-name\"),\n    ])\n    def test_parametrized_conversions(self, case_converter, input_case, output_case, input_key, expected_key):\n        \"\"\"Test parametrized case conversions.\"\"\"\n\n        result = case_converter.convert_case(input_key, target_case=output_case)\n        assert result == expected_key\n</code></pre>"},{"location":"features/case-conversion-utilities/#integration-testing","title":"Integration Testing","text":"<pre><code>@pytest.mark.integration\nclass TestCaseConversionIntegration:\n\n    @pytest.fixture\n    def pizza_order_data(self):\n        return {\n            \"orderId\": \"ORD_001\",\n            \"customerName\": \"Mario Rossi\",\n            \"pizzaItems\": [\n                {\n                    \"itemName\": \"Margherita\",\n                    \"basePrice\": 16.99,\n                    \"selectedToppings\": [\"extra_cheese\"]\n                }\n            ],\n            \"deliveryAddress\": {\n                \"streetAddress\": \"123 Pizza St\",\n                \"cityName\": \"New York\"\n            }\n        }\n\n    def test_full_order_processing_flow(self, pizza_order_data):\n        \"\"\"Test complete order processing with case conversions.\"\"\"\n\n        # Simulate frontend -&gt; backend -&gt; database flow\n        converter = CaseConverter()\n\n        # Step 1: Convert from frontend camelCase to internal snake_case\n        internal_data = converter.convert_dict_keys(pizza_order_data, \"snake_case\")\n\n        assert \"order_id\" in internal_data\n        assert \"customer_name\" in internal_data\n        assert \"pizza_items\" in internal_data\n        assert \"delivery_address\" in internal_data\n\n        # Step 2: Process internally (would involve business logic)\n        processed_data = {\n            **internal_data,\n            \"order_status\": \"confirmed\",\n            \"total_amount\": 19.99\n        }\n\n        # Step 3: Convert back to camelCase for API response\n        api_response = converter.convert_dict_keys(processed_data, \"camelCase\")\n\n        assert \"orderId\" in api_response\n        assert \"orderStatus\" in api_response\n        assert \"totalAmount\" in api_response\n\n        # Verify data integrity maintained\n        assert api_response[\"customerName\"] == \"Mario Rossi\"\n        assert api_response[\"totalAmount\"] == 19.99\n</code></pre>"},{"location":"features/case-conversion-utilities/#performance-optimization","title":"\ud83d\udcca Performance Optimization","text":""},{"location":"features/case-conversion-utilities/#caching-and-performance","title":"Caching and Performance","text":"<pre><code>from neuroglia.utilities.case_conversion import CachedCaseConverter\nimport time\nfrom typing import Dict\n\nclass PerformanceOptimizedConverter:\n    \"\"\"High-performance case converter with caching and optimization.\"\"\"\n\n    def __init__(self):\n        self.cached_converter = CachedCaseConverter(cache_size=1000)\n        self.conversion_stats = {\n            \"cache_hits\": 0,\n            \"cache_misses\": 0,\n            \"total_conversions\": 0\n        }\n\n    def benchmark_conversions(self, test_data: Dict[str, any], iterations: int = 1000):\n        \"\"\"Benchmark case conversion performance.\"\"\"\n\n        print(f\"\ud83d\ude80 Performance Benchmark ({iterations} iterations)\")\n\n        # Test without caching\n        start_time = time.time()\n        for _ in range(iterations):\n            converter = CaseConverter()  # New instance each time\n            result = converter.convert_dict_keys(test_data, \"camelCase\")\n\n        uncached_time = time.time() - start_time\n\n        # Test with caching\n        start_time = time.time()\n        for _ in range(iterations):\n            result = self.cached_converter.convert_dict_keys(test_data, \"camelCase\")\n\n        cached_time = time.time() - start_time\n\n        performance_improvement = ((uncached_time - cached_time) / uncached_time) * 100\n\n        print(f\"Without caching: {uncached_time:.4f}s\")\n        print(f\"With caching: {cached_time:.4f}s\")\n        print(f\"Performance improvement: {performance_improvement:.1f}%\")\n        print(f\"Cache hit rate: {self.get_cache_hit_rate():.1f}%\")\n\n        return {\n            \"uncached_time\": uncached_time,\n            \"cached_time\": cached_time,\n            \"improvement_percent\": performance_improvement,\n            \"cache_hit_rate\": self.get_cache_hit_rate()\n        }\n\n    def get_cache_hit_rate(self) -&gt; float:\n        \"\"\"Calculate cache hit rate percentage.\"\"\"\n        total = self.conversion_stats[\"cache_hits\"] + self.conversion_stats[\"cache_misses\"]\n        return (self.conversion_stats[\"cache_hits\"] / total * 100) if total &gt; 0 else 0\n</code></pre>"},{"location":"features/case-conversion-utilities/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\ud83d\udd27 Dependency Injection - Service registration patterns</li> <li>\ud83c\udf10 HTTP Service Client - API request/response transformation</li> <li>\ud83d\udcca Enhanced Model Validation - Model field validation</li> <li>\ud83d\udcc1 Data Access - Database field mapping</li> <li>\ud83d\udce8 CQRS &amp; Mediation - Command/query object conversion</li> </ul> <p>The Case Conversion Utilities provide seamless transformation capabilities that enable Mario's Pizzeria to work with multiple naming conventions across different layers of the application. Through comprehensive conversion support and Pydantic integration, the system maintains data consistency while adapting to various API and framework requirements.</p>"},{"location":"features/configurable-type-discovery/","title":"\ud83c\udfaf Configurable Type Discovery","text":"<p>The Neuroglia framework provides a flexible TypeRegistry system that allows applications to configure which modules should be scanned for domain types (enums, value objects, etc.) without hardcoding patterns in the framework itself.</p>"},{"location":"features/configurable-type-discovery/#overview","title":"\ud83c\udfaf Overview","text":"<p>The TypeRegistry replaces hardcoded domain structure assumptions with a clean, configurable approach:</p> <ul> <li>Framework Agnostic: No domain-specific knowledge in framework code</li> <li>Configurable: Applications specify their exact module structure</li> <li>Performance Optimized: Only scans registered modules instead of trying dozens of patterns</li> <li>Extensible: Supports dynamic type discovery and multiple configuration methods</li> </ul>"},{"location":"features/configurable-type-discovery/#core-components","title":"\ud83c\udfd7\ufe0f Core Components","text":""},{"location":"features/configurable-type-discovery/#typeregistry","title":"TypeRegistry","text":"<p>The <code>TypeRegistry</code> provides centralized type discovery using the framework's existing utilities:</p> <pre><code>from neuroglia.core.type_registry import TypeRegistry, get_type_registry\nfrom neuroglia.core.type_finder import TypeFinder\nfrom neuroglia.core.module_loader import ModuleLoader\n\n# Get the global type registry instance\nregistry = get_type_registry()\n\n# Register modules for type discovery\nregistry.register_modules([\n    \"domain.entities.enums\",\n    \"domain.value_objects\",\n    \"shared.types\"\n])\n\n# Find enum for a value\npizza_size_enum = registry.find_enum_for_value(\"LARGE\")\n</code></pre>"},{"location":"features/configurable-type-discovery/#enhanced-jsonserializer","title":"Enhanced JsonSerializer","text":"<p>The <code>JsonSerializer</code> now accepts configurable type modules:</p> <pre><code>from neuroglia.serialization.json import JsonSerializer\nfrom neuroglia.hosting.enhanced_web_application_builder import EnhancedWebApplicationBuilder\n\nbuilder = EnhancedWebApplicationBuilder()\n\n# Configure with specific type modules\nJsonSerializer.configure(builder, type_modules=[\n    \"domain.entities.enums\",      # Main enum module\n    \"domain.entities\",            # Entity module (for embedded enums)\n    \"domain.value_objects\",       # Value objects with enums\n])\n</code></pre>"},{"location":"features/configurable-type-discovery/#configuration-methods","title":"\ud83d\ude80 Configuration Methods","text":""},{"location":"features/configurable-type-discovery/#method-1-direct-configuration","title":"Method 1: Direct Configuration","text":"<p>Configure type modules during JsonSerializer setup:</p> <pre><code>def configure_application():\n    builder = EnhancedWebApplicationBuilder()\n\n    # Configure JsonSerializer with your domain modules\n    JsonSerializer.configure(builder, type_modules=[\n        \"myapp.domain.enums\",         # Primary enumerations\n        \"myapp.domain.entities\",      # Domain entities\n        \"myapp.domain.value_objects\", # Value objects\n        \"myapp.shared.types\",         # Shared types\n        \"myapp.integration.external\"  # External API types\n    ])\n\n    return builder\n</code></pre>"},{"location":"features/configurable-type-discovery/#method-2-post-configuration-registration","title":"Method 2: Post-Configuration Registration","text":"<p>Register modules after initial configuration:</p> <pre><code>def configure_with_registration():\n    builder = EnhancedWebApplicationBuilder()\n\n    # Basic configuration\n    JsonSerializer.configure(builder)\n\n    # Register additional type modules\n    JsonSerializer.register_type_modules([\n        \"myapp.domain.aggregates\",\n        \"myapp.domain.value_objects\",\n        \"myapp.shared.enums\"\n    ])\n\n    return builder\n</code></pre>"},{"location":"features/configurable-type-discovery/#method-3-direct-typeregistry-access","title":"Method 3: Direct TypeRegistry Access","text":"<p>Configure the TypeRegistry directly for advanced scenarios:</p> <pre><code>def configure_advanced():\n    from neuroglia.core.type_registry import get_type_registry\n\n    # Get the global registry\n    registry = get_type_registry()\n\n    # Register core domain modules\n    registry.register_modules([\n        \"orders.domain.entities\",\n        \"orders.domain.enums\"\n    ])\n\n    # Register shared library types\n    registry.register_modules([\n        \"shared_lib.common.enums\",\n        \"payment_gateway.types\"\n    ])\n\n    # Standard JsonSerializer configuration\n    builder = EnhancedWebApplicationBuilder()\n    JsonSerializer.configure(builder)\n\n    return builder\n</code></pre>"},{"location":"features/configurable-type-discovery/#usage-examples","title":"\ud83e\uddea Usage Examples","text":""},{"location":"features/configurable-type-discovery/#mario-pizzeria-configuration","title":"Mario Pizzeria Configuration","text":"<pre><code>from neuroglia.serialization.json import JsonSerializer\nfrom neuroglia.hosting.enhanced_web_application_builder import EnhancedWebApplicationBuilder\n\ndef configure_mario_pizzeria():\n    builder = EnhancedWebApplicationBuilder()\n\n    # Configure with Mario Pizzeria's domain structure\n    JsonSerializer.configure(builder, type_modules=[\n        \"domain.entities.enums\",      # PizzaSize, OrderStatus, Priority\n        \"domain.entities\",            # Pizza, Order entities\n        \"domain.value_objects\",       # Money, Address value objects\n    ])\n\n    return builder\n</code></pre>"},{"location":"features/configurable-type-discovery/#microservice-configuration","title":"Microservice Configuration","text":"<pre><code>def configure_microservice():\n    from neuroglia.core.type_registry import get_type_registry\n\n    registry = get_type_registry()\n\n    # Register internal domain types\n    registry.register_modules([\n        \"orders.domain.entities\",\n        \"orders.domain.enums\"\n    ])\n\n    # Register external service types we need to deserialize\n    registry.register_modules([\n        \"payment_service.models\",\n        \"inventory_service.types\",\n        \"shared_contracts.events\"\n    ])\n\n    builder = EnhancedWebApplicationBuilder()\n    JsonSerializer.configure(builder)\n    return builder\n</code></pre>"},{"location":"features/configurable-type-discovery/#flat-project-structure","title":"Flat Project Structure","text":"<p>For projects with simple, flat module structure:</p> <pre><code>def configure_flat_structure():\n    builder = EnhancedWebApplicationBuilder()\n\n    # Simple flat structure: models.py, enums.py, types.py\n    JsonSerializer.configure(builder, type_modules=[\n        \"models\",        # Main model types\n        \"enums\",         # All enumerations\n        \"types\",         # Custom types\n        \"constants\"      # Constants and lookups\n    ])\n\n    return builder\n</code></pre>"},{"location":"features/configurable-type-discovery/#dynamic-type-discovery","title":"\ud83d\udd27 Dynamic Type Discovery","text":"<p>For advanced scenarios, you can dynamically discover and register types:</p> <pre><code>def dynamic_type_discovery():\n    from neuroglia.core.type_registry import get_type_registry\n    from neuroglia.core.type_finder import TypeFinder\n    from neuroglia.core.module_loader import ModuleLoader\n    from enum import Enum\n\n    registry = get_type_registry()\n\n    # Discover all enum types in base modules\n    base_modules = [\"myapp.domain\", \"myapp.shared\"]\n\n    for base_module_name in base_modules:\n        try:\n            base_module = ModuleLoader.load(base_module_name)\n\n            # Find all enum types\n            enum_types = TypeFinder.get_types(\n                base_module,\n                predicate=lambda t: isinstance(t, type) and issubclass(t, Enum) and t != Enum,\n                include_sub_modules=True,\n                include_sub_packages=True\n            )\n\n            if enum_types:\n                print(f\"Discovered {len(enum_types)} enum types in {base_module_name}\")\n                # Types are automatically cached when accessed\n\n        except ImportError:\n            print(f\"Module {base_module_name} not available\")\n\n    return registry\n</code></pre>"},{"location":"features/configurable-type-discovery/#best-practices","title":"\ud83d\udca1 Best Practices","text":""},{"location":"features/configurable-type-discovery/#1-specific-module-registration","title":"1. Specific Module Registration","text":"<p>Register only the modules that contain types you need:</p> <pre><code># Good: Specific modules\nJsonSerializer.configure(builder, type_modules=[\n    \"domain.entities.enums\",      # Specific enum module\n    \"domain.value_objects\"        # Specific value object module\n])\n\n# Avoid: Too broad\nJsonSerializer.configure(builder, type_modules=[\n    \"domain\",                     # Too broad, includes everything\n    \"application\"                 # Application layer shouldn't have enums\n])\n</code></pre>"},{"location":"features/configurable-type-discovery/#2-layer-appropriate-registration","title":"2. Layer-Appropriate Registration","text":"<p>Only register modules from appropriate architectural layers:</p> <pre><code># Good: Domain and integration layers\nJsonSerializer.configure(builder, type_modules=[\n    \"domain.entities.enums\",         # Domain layer\n    \"domain.value_objects\",          # Domain layer\n    \"integration.external_types\"     # Integration layer for external APIs\n])\n\n# Avoid: Application layer\nJsonSerializer.configure(builder, type_modules=[\n    \"application.commands\",          # Commands shouldn't have enums\n    \"application.handlers\"           # Handlers shouldn't have enums\n])\n</code></pre>"},{"location":"features/configurable-type-discovery/#3-performance-optimization","title":"3. Performance Optimization","text":"<p>Register modules in order of frequency of use:</p> <pre><code># Most frequently used enums first\nJsonSerializer.configure(builder, type_modules=[\n    \"domain.entities.enums\",      # Most common: PizzaSize, OrderStatus\n    \"domain.value_objects\",       # Less common: specialized enums\n    \"shared.constants\"            # Least common: system constants\n])\n</code></pre>"},{"location":"features/configurable-type-discovery/#4-modular-configuration","title":"4. Modular Configuration","text":"<p>For large applications, organize configuration by feature:</p> <pre><code>def configure_order_types():\n    return [\n        \"orders.domain.enums\",\n        \"orders.domain.entities\",\n        \"orders.integration.payment_types\"\n    ]\n\ndef configure_inventory_types():\n    return [\n        \"inventory.domain.enums\",\n        \"inventory.domain.entities\",\n        \"inventory.integration.supplier_types\"\n    ]\n\ndef configure_application():\n    builder = EnhancedWebApplicationBuilder()\n\n    all_type_modules = (\n        configure_order_types() +\n        configure_inventory_types() +\n        [\"shared.common.enums\"]\n    )\n\n    JsonSerializer.configure(builder, type_modules=all_type_modules)\n    return builder\n</code></pre>"},{"location":"features/configurable-type-discovery/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Data Access - Repository patterns and serialization</li> <li>Domain-Driven Design - Domain layer organization</li> <li>Dependency Injection - Service configuration patterns</li> </ul>"},{"location":"features/configurable-type-discovery/#testing-configuration","title":"\ud83e\uddea Testing Configuration","text":"<p>Test your type configuration with different scenarios:</p> <pre><code>def test_configured_serialization():\n    \"\"\"Test that configured types are discovered correctly\"\"\"\n    from neuroglia.core.type_registry import get_type_registry\n\n    registry = get_type_registry()\n    registry.register_modules([\"domain.entities.enums\"])\n\n    # Test enum discovery\n    pizza_size_enum = registry.find_enum_for_value(\"LARGE\")\n    assert pizza_size_enum is not None\n    assert pizza_size_enum.__name__ == \"PizzaSize\"\n\n    print(\"\u2705 Configured type discovery working correctly\")\n</code></pre> <p>The configurable TypeRegistry approach ensures your application can specify exactly which modules contain domain types, making the framework truly generic while maintaining intelligent type inference capabilities.</p>"},{"location":"features/data-access/","title":"\ud83c\udf55 Data Access","text":"<p>Neuroglia provides a flexible data access layer that supports multiple storage backends through a unified repository pattern for Mario's Pizzeria. From storing pizza orders in files to managing kitchen workflows with event sourcing, the framework adapts to your pizzeria's needs.</p> <p>Let's explore how to store orders, manage inventory, and track kitchen operations using different persistence strategies.</p>"},{"location":"features/data-access/#overview","title":"\ud83c\udfaf Overview","text":"<p>The pizzeria data access system provides:</p> <ul> <li>Repository Pattern: Unified interface for orders, pizzas, and customer data</li> <li>Multiple Storage Backends: File-based (development), MongoDB (production), Event Store (kitchen events)</li> <li>Event Sourcing: Complete order lifecycle tracking with EventStoreDB</li> <li>CQRS Support: Separate read models for menus and write models for orders</li> <li>Query Abstractions: Find orders by status, customer, or time period</li> <li>Unit of Work: Transaction management across order processing</li> </ul>"},{"location":"features/data-access/#core-abstractions","title":"\ud83c\udfd7\ufe0f Core Abstractions","text":""},{"location":"features/data-access/#repository-interface-for-pizzeria-entities","title":"Repository Interface for Pizzeria Entities","text":"<p>The base repository interface defines standard CRUD operations for pizzeria data:</p> <pre><code>from abc import ABC, abstractmethod\nfrom typing import Generic, TypeVar, List, Optional\nfrom datetime import datetime, date\n\nTEntity = TypeVar('TEntity')\nTKey = TypeVar('TKey')\n\nclass Repository(Generic[TEntity, TKey], ABC):\n    \"\"\"Base repository interface for pizzeria entities\"\"\"\n\n    @abstractmethod\n    async def get_by_id_async(self, id: TKey) -&gt; Optional[TEntity]:\n        \"\"\"Get entity by ID (order, pizza, customer)\"\"\"\n        pass\n\n    @abstractmethod\n    async def save_async(self, entity: TEntity) -&gt; None:\n        \"\"\"Save entity (create or update)\"\"\"\n        pass\n\n    @abstractmethod\n    async def delete_async(self, id: TKey) -&gt; None:\n        \"\"\"Delete entity by ID\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_all_async(self) -&gt; List[TEntity]:\n        \"\"\"Get all entities\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_async(self, predicate) -&gt; List[TEntity]:\n        \"\"\"Find entities matching predicate\"\"\"\n        pass\n\n# Pizzeria-specific repository interfaces\nclass IOrderRepository(Repository[Order, str], ABC):\n    \"\"\"Order-specific repository operations\"\"\"\n\n    @abstractmethod\n    async def get_by_customer_phone_async(self, phone: str) -&gt; List[Order]:\n        \"\"\"Get orders by customer phone number\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_by_status_async(self, status: str) -&gt; List[Order]:\n        \"\"\"Get orders by status (pending, cooking, ready, delivered)\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_by_date_range_async(self, start_date: date, end_date: date) -&gt; List[Order]:\n        \"\"\"Get orders within date range for reports\"\"\"\n        pass\n\nclass IPizzaRepository(Repository[Pizza, str], ABC):\n    \"\"\"Pizza menu repository operations\"\"\"\n\n    @abstractmethod\n    async def get_by_category_async(self, category: str) -&gt; List[Pizza]:\n        \"\"\"Get pizzas by category (signature, specialty, custom)\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_available_async(self) -&gt; List[Pizza]:\n        \"\"\"Get only available pizzas (not sold out)\"\"\"\n        pass\n</code></pre> <pre><code>from neuroglia.data.abstractions import Queryable\nfrom typing import Callable\nfrom decimal import Decimal\n\nclass QueryablePizzeriaRepository(Repository[TEntity, TKey], Queryable[TEntity]):\n    \"\"\"Repository with advanced querying for pizzeria analytics\"\"\"\n\n    async def where(self, predicate: Callable[[TEntity], bool]) -&gt; List[TEntity]:\n        \"\"\"Filter pizzeria entities by predicate\"\"\"\n        pass\n\n    async def order_by_desc(self, selector: Callable[[TEntity], any]) -&gt; List[TEntity]:\n        \"\"\"Order entities in descending order\"\"\"\n        pass\n\n    async def group_by(self, selector: Callable[[TEntity], any]) -&gt; dict:\n        \"\"\"Group entities for analytics\"\"\"\n        pass\n\n# Example: Advanced order queries\nclass ExtendedOrderRepository(IOrderRepository, QueryablePizzeriaRepository[Order, str]):\n    \"\"\"Order repository with advanced analytics queries\"\"\"\n\n    async def get_top_customers_async(self, limit: int = 10) -&gt; List[dict]:\n        \"\"\"Get top customers by order count\"\"\"\n        orders = await self.get_all_async()\n        customer_counts = {}\n\n        for order in orders:\n            phone = order.customer_phone\n            customer_counts[phone] = customer_counts.get(phone, 0) + 1\n\n        # Sort and limit\n        top_customers = sorted(customer_counts.items(), key=lambda x: x[1], reverse=True)[:limit]\n\n        return [{\"phone\": phone, \"order_count\": count} for phone, count in top_customers]\n\n    async def get_revenue_by_date_async(self, start_date: date, end_date: date) -&gt; List[dict]:\n        \"\"\"Get daily revenue within date range\"\"\"\n        orders = await self.get_by_date_range_async(start_date, end_date)\n        daily_revenue = {}\n\n        for order in orders:\n            order_date = order.order_time.date()\n            if order_date not in daily_revenue:\n                daily_revenue[order_date] = Decimal('0')\n            daily_revenue[order_date] += order.total_amount\n\n        return [{\"date\": date, \"revenue\": revenue} for date, revenue in sorted(daily_revenue.items())]\n</code></pre>"},{"location":"features/data-access/#file-based-storage-for-development","title":"\ud83d\udcc1 File-Based Storage for Development","text":""},{"location":"features/data-access/#file-repository-implementation","title":"File Repository Implementation","text":"<p>Perfect for development and testing of Mario's Pizzeria:</p> <pre><code>import json\nimport os\nfrom pathlib import Path\nfrom typing import List, Optional, Callable\nfrom datetime import datetime, date\n\nclass FileRepository(Repository[TEntity, TKey]):\n    \"\"\"File-based repository using JSON storage\"\"\"\n\n    def __init__(self, entity_type: type, data_dir: str = \"data\"):\n        self.entity_type = entity_type\n        self.entity_name = entity_type.__name__.lower()\n        self.data_dir = Path(data_dir)\n        self.entity_dir = self.data_dir / self.entity_name\n\n        # Ensure directories exist\n        self.entity_dir.mkdir(parents=True, exist_ok=True)\n\n    async def get_by_id_async(self, id: TKey) -&gt; Optional[TEntity]:\n        \"\"\"Get entity from JSON file\"\"\"\n        file_path = self.entity_dir / f\"{id}.json\"\n\n        if not file_path.exists():\n            return None\n\n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                data = json.load(f)\n                return self._dict_to_entity(data)\n        except Exception as e:\n            raise StorageException(f\"Failed to load {self.entity_name} {id}: {e}\")\n\n    async def save_async(self, entity: TEntity) -&gt; None:\n        \"\"\"Save entity to JSON file\"\"\"\n        file_path = self.entity_dir / f\"{entity.id}.json\"\n\n        try:\n            data = self._entity_to_dict(entity)\n            with open(file_path, 'w', encoding='utf-8') as f:\n                json.dump(data, f, indent=2, default=self._json_serializer, ensure_ascii=False)\n        except Exception as e:\n            raise StorageException(f\"Failed to save {self.entity_name} {entity.id}: {e}\")\n\n    async def delete_async(self, id: TKey) -&gt; None:\n        \"\"\"Delete entity JSON file\"\"\"\n        file_path = self.entity_dir / f\"{id}.json\"\n        if file_path.exists():\n            file_path.unlink()\n\n    async def get_all_async(self) -&gt; List[TEntity]:\n        \"\"\"Get all entities from JSON files\"\"\"\n        entities = []\n\n        for file_path in self.entity_dir.glob(\"*.json\"):\n            try:\n                with open(file_path, 'r', encoding='utf-8') as f:\n                    data = json.load(f)\n                    entity = self._dict_to_entity(data)\n                    entities.append(entity)\n            except Exception as e:\n                print(f\"Warning: Failed to load {file_path}: {e}\")\n                continue\n\n        return entities\n\n    async def find_async(self, predicate: Callable[[TEntity], bool]) -&gt; List[TEntity]:\n        \"\"\"Find entities matching predicate\"\"\"\n        all_entities = await self.get_all_async()\n        return [entity for entity in all_entities if predicate(entity)]\n\n    def _entity_to_dict(self, entity: TEntity) -&gt; dict:\n        \"\"\"Convert entity to dictionary for JSON serialization\"\"\"\n        if hasattr(entity, '__dict__'):\n            return entity.__dict__.copy()\n        elif hasattr(entity, '_asdict'):\n            return entity._asdict()\n        else:\n            raise ValueError(f\"Cannot serialize entity of type {type(entity)}\")\n\n    def _dict_to_entity(self, data: dict) -&gt; TEntity:\n        \"\"\"Convert dictionary back to entity\"\"\"\n        return self.entity_type(**data)\n\n    def _json_serializer(self, obj):\n        \"\"\"Handle special types in JSON serialization\"\"\"\n        if isinstance(obj, (datetime, date)):\n            return obj.isoformat()\n        elif hasattr(obj, '__dict__'):\n            return obj.__dict__\n        else:\n            return str(obj)\n\n# Pizzeria-specific file repositories\nclass FileOrderRepository(FileRepository[Order, str], IOrderRepository):\n    \"\"\"File-based order repository for development\"\"\"\n\n    def __init__(self, data_dir: str = \"data\"):\n        super().__init__(Order, data_dir)\n\n    async def get_by_customer_phone_async(self, phone: str) -&gt; List[Order]:\n        \"\"\"Get orders by customer phone\"\"\"\n        return await self.find_async(lambda order: order.customer_phone == phone)\n\n    async def get_by_status_async(self, status: str) -&gt; List[Order]:\n        \"\"\"Get orders by status\"\"\"\n        return await self.find_async(lambda order: order.status == status)\n\n    async def get_by_date_range_async(self, start_date: date, end_date: date) -&gt; List[Order]:\n        \"\"\"Get orders within date range\"\"\"\n        return await self.find_async(lambda order:\n            start_date &lt;= order.order_time.date() &lt;= end_date)\n\nclass FilePizzaRepository(FileRepository[Pizza, str], IPizzaRepository):\n    \"\"\"File-based pizza repository for menu management\"\"\"\n\n    def __init__(self, data_dir: str = \"data\"):\n        super().__init__(Pizza, data_dir)\n\n    async def get_by_category_async(self, category: str) -&gt; List[Pizza]:\n        \"\"\"Get pizzas by category\"\"\"\n        return await self.find_async(lambda pizza: pizza.category == category)\n\n    async def get_available_async(self) -&gt; List[Pizza]:\n        \"\"\"Get available pizzas only\"\"\"\n        return await self.find_async(lambda pizza: pizza.is_available)\n</code></pre>"},{"location":"features/data-access/#mongodb-repository-for-pizzeria","title":"MongoDB Repository for Pizzeria","text":"<p>Built-in MongoDB repository implementation for production pizzeria:</p> <pre><code>from neuroglia.data.infrastructure.mongo import MongoRepository\nfrom motor.motor_asyncio import AsyncIOMotorClient, AsyncIOMotorDatabase\nfrom bson import ObjectId\nfrom typing import Optional, List, Dict, Any\n\nclass MongoOrderRepository(MongoRepository[Order, str], IOrderRepository):\n    \"\"\"MongoDB repository for pizza orders\"\"\"\n\n    def __init__(self, database: AsyncIOMotorDatabase):\n        super().__init__(database, \"orders\")\n\n    async def get_by_customer_phone_async(self, phone: str) -&gt; List[Order]:\n        \"\"\"Get orders by customer phone with index optimization\"\"\"\n        cursor = self.collection.find({\"customer_phone\": phone}).sort(\"order_time\", -1)\n        documents = await cursor.to_list(length=None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def get_by_status_async(self, status: str) -&gt; List[Order]:\n        \"\"\"Get orders by status for kitchen management\"\"\"\n        cursor = self.collection.find({\"status\": status}).sort(\"order_time\", 1)  # FIFO\n        documents = await cursor.to_list(length=None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def get_by_date_range_async(self, start_date: date, end_date: date) -&gt; List[Order]:\n        \"\"\"Get orders within date range for reporting\"\"\"\n        start_datetime = datetime.combine(start_date, datetime.min.time())\n        end_datetime = datetime.combine(end_date, datetime.max.time())\n\n        cursor = self.collection.find({\n            \"order_time\": {\n                \"$gte\": start_datetime,\n                \"$lte\": end_datetime\n            }\n        }).sort(\"order_time\", 1)\n\n        documents = await cursor.to_list(length=None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def get_kitchen_queue_async(self, statuses: List[str]) -&gt; List[Order]:\n        \"\"\"Get orders in kitchen queue (optimized for kitchen display)\"\"\"\n        cursor = self.collection.find(\n            {\"status\": {\"$in\": statuses}},\n            {\"customer_name\": 1, \"pizzas\": 1, \"order_time\": 1, \"status\": 1, \"estimated_ready_time\": 1}\n        ).sort(\"order_time\", 1)\n\n        documents = await cursor.to_list(length=None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def get_daily_revenue_async(self, target_date: date) -&gt; Dict[str, Any]:\n        \"\"\"Get daily revenue aggregation\"\"\"\n        start_datetime = datetime.combine(target_date, datetime.min.time())\n        end_datetime = datetime.combine(target_date, datetime.max.time())\n\n        pipeline = [\n            {\n                \"$match\": {\n                    \"order_time\": {\"$gte\": start_datetime, \"$lte\": end_datetime},\n                    \"status\": {\"$in\": [\"ready\", \"delivered\"]}  # Only completed orders\n                }\n            },\n            {\n                \"$group\": {\n                    \"_id\": None,\n                    \"total_revenue\": {\"$sum\": \"$total_amount\"},\n                    \"order_count\": {\"$sum\": 1},\n                    \"average_order_value\": {\"$avg\": \"$total_amount\"}\n                }\n            }\n        ]\n\n        result = await self.collection.aggregate(pipeline).to_list(length=1)\n        return result[0] if result else {\"total_revenue\": 0, \"order_count\": 0, \"average_order_value\": 0}\n\n    def _entity_to_document(self, order: Order) -&gt; Dict[str, Any]:\n        \"\"\"Convert order entity to MongoDB document\"\"\"\n        doc = {\n            \"_id\": order.id,\n            \"customer_name\": order.customer_name,\n            \"customer_phone\": order.customer_phone,\n            \"customer_address\": order.customer_address,\n            \"pizzas\": [self._pizza_to_dict(pizza) for pizza in order.pizzas],\n            \"status\": order.status,\n            \"order_time\": order.order_time,\n            \"estimated_ready_time\": order.estimated_ready_time,\n            \"total_amount\": float(order.total_amount),  # MongoDB decimal handling\n            \"payment_method\": order.payment_method\n        }\n        return doc\n\n    def _document_to_entity(self, doc: Dict[str, Any]) -&gt; Order:\n        \"\"\"Convert MongoDB document to order entity\"\"\"\n        return Order(\n            id=doc[\"_id\"],\n            customer_name=doc[\"customer_name\"],\n            customer_phone=doc[\"customer_phone\"],\n            customer_address=doc[\"customer_address\"],\n            pizzas=[self._dict_to_pizza(pizza_dict) for pizza_dict in doc[\"pizzas\"]],\n            status=doc[\"status\"],\n            order_time=doc[\"order_time\"],\n            estimated_ready_time=doc.get(\"estimated_ready_time\"),\n            total_amount=Decimal(str(doc[\"total_amount\"])),\n            payment_method=doc.get(\"payment_method\", \"cash\")\n        )\n\nclass MongoPizzaRepository(MongoRepository[Pizza, str], IPizzaRepository):\n    \"\"\"MongoDB repository for pizza menu management\"\"\"\n\n    def __init__(self, database: AsyncIOMotorDatabase):\n        super().__init__(database, \"pizzas\")\n\n    async def get_by_category_async(self, category: str) -&gt; List[Pizza]:\n        \"\"\"Get pizzas by category with caching optimization\"\"\"\n        cursor = self.collection.find({\"category\": category, \"is_available\": True}).sort(\"name\", 1)\n        documents = await cursor.to_list(length=None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def get_available_async(self) -&gt; List[Pizza]:\n        \"\"\"Get all available pizzas for menu display\"\"\"\n        cursor = self.collection.find({\"is_available\": True}).sort([(\"category\", 1), (\"name\", 1)])\n        documents = await cursor.to_list(length=None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def update_availability_async(self, pizza_id: str, is_available: bool) -&gt; None:\n        \"\"\"Update pizza availability (for sold out items)\"\"\"\n        await self.collection.update_one(\n            {\"_id\": pizza_id},\n            {\"$set\": {\"is_available\": is_available, \"updated_at\": datetime.utcnow()}}\n        )\n\n    def _entity_to_document(self, pizza: Pizza) -&gt; Dict[str, Any]:\n        \"\"\"Convert pizza entity to MongoDB document\"\"\"\n        return {\n            \"_id\": pizza.id,\n            \"name\": pizza.name,\n            \"description\": pizza.description,\n            \"category\": pizza.category,\n            \"base_price\": float(pizza.base_price),\n            \"available_toppings\": pizza.available_toppings,\n            \"preparation_time_minutes\": pizza.preparation_time_minutes,\n            \"is_available\": pizza.is_available,\n            \"is_seasonal\": pizza.is_seasonal,\n            \"created_at\": pizza.created_at,\n            \"updated_at\": datetime.utcnow()\n        }\n</code></pre>"},{"location":"features/data-access/#mongodb-indexes-for-performance","title":"MongoDB Indexes for Performance","text":"<p>Create indexes for pizzeria query patterns:</p> <pre><code># Create indexes for optimal pizzeria query performance\nasync def create_pizzeria_indexes():\n    \"\"\"Create MongoDB indexes for pizzeria collections\"\"\"\n\n    # Order collection indexes\n    await orders_collection.create_index(\"customer_phone\")  # Customer lookup\n    await orders_collection.create_index(\"status\")  # Kitchen filtering\n    await orders_collection.create_index(\"order_time\")  # Chronological ordering\n    await orders_collection.create_index([(\"status\", 1), (\"order_time\", 1)])  # Kitchen queue\n    await orders_collection.create_index([(\"order_time\", -1)])  # Recent orders first\n    await orders_collection.create_index(\"estimated_ready_time\")  # Ready time tracking\n\n    # Pizza collection indexes\n    await pizzas_collection.create_index(\"category\")  # Menu category filtering\n    await pizzas_collection.create_index(\"is_available\")  # Available items only\n    await pizzas_collection.create_index([(\"category\", 1), (\"name\", 1)])  # Sorted menu display\n    await pizzas_collection.create_index(\"is_seasonal\")  # Seasonal items management\n</code></pre>"},{"location":"features/data-access/#repository-registration-with-mongodb","title":"Repository Registration with MongoDB","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\n\ndef create_pizzeria_app():\n    \"\"\"Create Mario's Pizzeria application with MongoDB persistence\"\"\"\n    builder = WebApplicationBuilder()\n\n    # MongoDB configuration\n    mongo_client = AsyncIOMotorClient(\"mongodb://localhost:27017\")\n    database = mongo_client.marios_pizzeria\n\n    # Repository registration\n    builder.services.add_singleton(lambda: database)\n    builder.services.add_scoped(MongoOrderRepository)\n    builder.services.add_scoped(MongoPizzaRepository)\n\n    # Alias interfaces to implementations\n    builder.services.add_scoped(IOrderRepository, lambda sp: sp.get_service(MongoOrderRepository))\n    builder.services.add_scoped(IPizzaRepository, lambda sp: sp.get_service(MongoPizzaRepository))\n\n    app = builder.build()\n    return app\n</code></pre>"},{"location":"features/data-access/#event-sourcing-for-kitchen-workflow","title":"\ud83d\udcca Event Sourcing for Kitchen Workflow","text":""},{"location":"features/data-access/#kitchen-event-store","title":"Kitchen Event Store","text":"<p>Track kitchen workflow with event sourcing patterns:</p> <pre><code>from neuroglia.eventing import DomainEvent\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any\nfrom dataclasses import dataclass\n\n@dataclass\nclass OrderStatusChangedEvent(DomainEvent):\n    \"\"\"Event for tracking order status changes in kitchen\"\"\"\n    order_id: str\n    old_status: str\n    new_status: str\n    changed_by: str\n    change_reason: Optional[str] = None\n    estimated_ready_time: Optional[datetime] = None\n\n@dataclass\nclass PizzaStartedEvent(DomainEvent):\n    \"\"\"Event when pizza preparation begins\"\"\"\n    order_id: str\n    pizza_name: str\n    pizza_index: int\n    started_by: str\n    estimated_completion: datetime\n\n@dataclass\nclass PizzaCompletedEvent(DomainEvent):\n    \"\"\"Event when pizza is finished\"\"\"\n    order_id: str\n    pizza_name: str\n    pizza_index: int\n    completed_by: str\n    actual_completion_time: datetime\n    preparation_duration_minutes: int\n\nclass KitchenWorkflowEventStore:\n    \"\"\"Event store for kitchen workflow tracking\"\"\"\n\n    def __init__(self, event_repository: IEventRepository):\n        self.event_repository = event_repository\n\n    async def record_order_status_change(self,\n                                         order_id: str,\n                                         old_status: str,\n                                         new_status: str,\n                                         changed_by: str,\n                                         change_reason: str = None) -&gt; None:\n        \"\"\"Record order status changes for kitchen analytics\"\"\"\n        event = OrderStatusChangedEvent(\n            order_id=order_id,\n            old_status=old_status,\n            new_status=new_status,\n            changed_by=changed_by,\n            change_reason=change_reason,\n            estimated_ready_time=self._calculate_ready_time(new_status)\n        )\n\n        await self.event_repository.save_event_async(event)\n\n    async def record_pizza_started(self,\n                                   order_id: str,\n                                   pizza_name: str,\n                                   pizza_index: int,\n                                   started_by: str) -&gt; None:\n        \"\"\"Record when pizza preparation begins\"\"\"\n        estimated_completion = datetime.now(timezone.utc) + timedelta(\n            minutes=self._get_pizza_prep_time(pizza_name)\n        )\n\n        event = PizzaStartedEvent(\n            order_id=order_id,\n            pizza_name=pizza_name,\n            pizza_index=pizza_index,\n            started_by=started_by,\n            estimated_completion=estimated_completion\n        )\n\n        await self.event_repository.save_event_async(event)\n\n    async def record_pizza_completed(self,\n                                     order_id: str,\n                                     pizza_name: str,\n                                     pizza_index: int,\n                                     completed_by: str,\n                                     start_time: datetime) -&gt; None:\n        \"\"\"Record when pizza is completed\"\"\"\n        completion_time = datetime.now(timezone.utc)\n        duration_minutes = int((completion_time - start_time).total_seconds() / 60)\n\n        event = PizzaCompletedEvent(\n            order_id=order_id,\n            pizza_name=pizza_name,\n            pizza_index=pizza_index,\n            completed_by=completed_by,\n            actual_completion_time=completion_time,\n            preparation_duration_minutes=duration_minutes\n        )\n\n        await self.event_repository.save_event_async(event)\n\n    async def get_kitchen_performance_metrics(self, date_range: tuple[date, date]) -&gt; Dict[str, Any]:\n        \"\"\"Get kitchen performance analytics from events\"\"\"\n        start_date, end_date = date_range\n\n        # Query events within date range\n        events = await self.event_repository.get_events_by_date_range_async(start_date, end_date)\n\n        # Calculate metrics\n        pizza_completion_events = [e for e in events if isinstance(e, PizzaCompletedEvent)]\n        status_change_events = [e for e in events if isinstance(e, OrderStatusChangedEvent)]\n\n        return {\n            \"total_pizzas_completed\": len(pizza_completion_events),\n            \"average_prep_time_minutes\": self._calculate_average_prep_time(pizza_completion_events),\n            \"peak_hours\": self._calculate_peak_hours(status_change_events),\n            \"order_completion_rate\": self._calculate_completion_rate(status_change_events),\n            \"staff_performance\": self._calculate_staff_performance(pizza_completion_events)\n        }\n</code></pre> <pre><code>from neuroglia.data import Repository\nfrom typing import List, Dict, Any\nimport json\nfrom pathlib import Path\nfrom datetime import datetime\n\nclass FileEventRepository(Repository[DomainEvent, str]):\n    \"\"\"File-based event repository for development and testing\"\"\"\n\n    def __init__(self, events_directory: str = \"data/events\"):\n        super().__init__()\n        self.events_directory = Path(events_directory)\n        self.events_directory.mkdir(parents=True, exist_ok=True)\n\n    async def save_event_async(self, event: DomainEvent) -&gt; None:\n        \"\"\"Save event to JSON file organized by date\"\"\"\n        event_date = event.occurred_at.date()\n        date_directory = self.events_directory / event_date.strftime(\"%Y-%m-%d\")\n        date_directory.mkdir(exist_ok=True)\n\n        event_file = date_directory / f\"{event.id}.json\"\n\n        event_data = {\n            \"id\": event.id,\n            \"event_type\": event.__class__.__name__,\n            \"occurred_at\": event.occurred_at.isoformat(),\n            \"data\": self._serialize_event_data(event)\n        }\n\n        async with aiofiles.open(event_file, 'w') as f:\n            await f.write(json.dumps(event_data, indent=2))\n\n    async def get_events_by_date_range_async(self,\n                                             start_date: date,\n                                             end_date: date) -&gt; List[DomainEvent]:\n        \"\"\"Get events within date range\"\"\"\n        events = []\n        current_date = start_date\n\n        while current_date &lt;= end_date:\n            date_directory = self.events_directory / current_date.strftime(\"%Y-%m-%d\")\n\n            if date_directory.exists():\n                for event_file in date_directory.glob(\"*.json\"):\n                    async with aiofiles.open(event_file, 'r') as f:\n                        event_data = json.loads(await f.read())\n                        event = self._deserialize_event(event_data)\n                        if event:\n                            events.append(event)\n\n            current_date += timedelta(days=1)\n\n        return sorted(events, key=lambda e: e.occurred_at)\n</code></pre>"},{"location":"features/data-access/#mongodb-event-store","title":"MongoDB Event Store","text":"<p>Production event store with aggregation capabilities:</p> <pre><code>from neuroglia.data.infrastructure.mongo import MongoRepository\nfrom motor.motor_asyncio import AsyncIOMotorDatabase\n\nclass MongoEventRepository(MongoRepository[DomainEvent, str]):\n    \"\"\"MongoDB event repository for production event sourcing\"\"\"\n\n    def __init__(self, database: AsyncIOMotorDatabase):\n        super().__init__(database, \"events\")\n\n    async def save_event_async(self, event: DomainEvent) -&gt; None:\n        \"\"\"Save event with automatic indexing\"\"\"\n        document = {\n            \"_id\": event.id,\n            \"event_type\": event.__class__.__name__,\n            \"occurred_at\": event.occurred_at,\n            \"data\": self._serialize_event_data(event),\n            \"version\": 1,\n            \"metadata\": {\n                \"correlation_id\": getattr(event, 'correlation_id', None),\n                \"causation_id\": getattr(event, 'causation_id', None)\n            }\n        }\n\n        await self.collection.insert_one(document)\n\n    async def get_kitchen_timeline_events(self,\n                                          order_id: str,\n                                          limit: int = 100) -&gt; List[DomainEvent]:\n        \"\"\"Get chronological timeline of kitchen events for an order\"\"\"\n        cursor = self.collection.find(\n            {\n                \"event_type\": {\"$in\": [\"OrderStatusChangedEvent\", \"PizzaStartedEvent\", \"PizzaCompletedEvent\"]},\n                \"data.order_id\": order_id\n            }\n        ).sort(\"occurred_at\", 1).limit(limit)\n\n        documents = await cursor.to_list(length=limit)\n        return [self._deserialize_event(doc) for doc in documents]\n\n    async def get_performance_aggregation(self,\n                                          start_date: datetime,\n                                          end_date: datetime) -&gt; Dict[str, Any]:\n        \"\"\"Get aggregated kitchen performance metrics\"\"\"\n        pipeline = [\n            {\n                \"$match\": {\n                    \"occurred_at\": {\"$gte\": start_date, \"$lte\": end_date},\n                    \"event_type\": \"PizzaCompletedEvent\"\n                }\n            },\n            {\n                \"$group\": {\n                    \"_id\": \"$data.pizza_name\",\n                    \"total_pizzas\": {\"$sum\": 1},\n                    \"avg_prep_time\": {\"$avg\": \"$data.preparation_duration_minutes\"},\n                    \"min_prep_time\": {\"$min\": \"$data.preparation_duration_minutes\"},\n                    \"max_prep_time\": {\"$max\": \"$data.preparation_duration_minutes\"}\n                }\n            },\n            {\n                \"$sort\": {\"total_pizzas\": -1}\n            }\n        ]\n\n        results = await self.collection.aggregate(pipeline).to_list(length=None)\n        return {\n            \"pizza_performance\": results,\n            \"reporting_period\": {\n                \"start\": start_date.isoformat(),\n                \"end\": end_date.isoformat()\n            }\n        }\n</code></pre> <pre><code>from neuroglia.data import IQueryableRepository\nfrom typing import List, Dict, Any, Optional\nfrom datetime import datetime, date, timedelta\n\nclass IAnalyticsRepository(IQueryableRepository[Order, str]):\n    \"\"\"Enhanced queryable interface for pizzeria analytics\"\"\"\n\n    async def get_revenue_by_period_async(self,\n                                          period: str,  # 'daily', 'weekly', 'monthly'\n                                          start_date: date,\n                                          end_date: date) -&gt; Dict[str, Any]:\n        \"\"\"Get revenue metrics grouped by time period\"\"\"\n        pass\n\n    async def get_popular_pizzas_async(self,\n                                       start_date: date,\n                                       end_date: date,\n                                       limit: int = 10) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get most popular pizzas by order count\"\"\"\n        pass\n\n    async def get_customer_insights_async(self,\n                                          customer_phone: str) -&gt; Dict[str, Any]:\n        \"\"\"Get customer ordering patterns and preferences\"\"\"\n        pass\n\n    async def get_peak_hours_analysis_async(self,\n                                            date_range: tuple[date, date]) -&gt; Dict[str, Any]:\n        \"\"\"Analyze order patterns by hour of day\"\"\"\n        pass\n\nclass MongoAnalyticsRepository(MongoOrderRepository, IAnalyticsRepository):\n    \"\"\"MongoDB implementation with advanced analytics capabilities\"\"\"\n\n    async def get_revenue_by_period_async(self,\n                                          period: str,\n                                          start_date: date,\n                                          end_date: date) -&gt; Dict[str, Any]:\n        \"\"\"Get revenue metrics with MongoDB aggregation\"\"\"\n        start_datetime = datetime.combine(start_date, datetime.min.time())\n        end_datetime = datetime.combine(end_date, datetime.max.time())\n\n        # Dynamic grouping based on period\n        group_format = {\n            'daily': {\"$dateToString\": {\"format\": \"%Y-%m-%d\", \"date\": \"$order_time\"}},\n            'weekly': {\"$dateToString\": {\"format\": \"%Y-W%U\", \"date\": \"$order_time\"}},\n            'monthly': {\"$dateToString\": {\"format\": \"%Y-%m\", \"date\": \"$order_time\"}}\n        }\n\n        pipeline = [\n            {\n                \"$match\": {\n                    \"order_time\": {\"$gte\": start_datetime, \"$lte\": end_datetime},\n                    \"status\": {\"$in\": [\"ready\", \"delivered\"]}\n                }\n            },\n            {\n                \"$group\": {\n                    \"_id\": group_format.get(period, group_format['daily']),\n                    \"revenue\": {\"$sum\": \"$total_amount\"},\n                    \"order_count\": {\"$sum\": 1},\n                    \"average_order_value\": {\"$avg\": \"$total_amount\"}\n                }\n            },\n            {\n                \"$sort\": {\"_id\": 1}\n            }\n        ]\n\n        results = await self.collection.aggregate(pipeline).to_list(length=None)\n\n        return {\n            \"period\": period,\n            \"data\": results,\n            \"summary\": {\n                \"total_revenue\": sum(r[\"revenue\"] for r in results),\n                \"total_orders\": sum(r[\"order_count\"] for r in results),\n                \"periods_analyzed\": len(results)\n            }\n        }\n\n    async def get_popular_pizzas_async(self,\n                                       start_date: date,\n                                       end_date: date,\n                                       limit: int = 10) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get most popular pizzas with detailed analytics\"\"\"\n        start_datetime = datetime.combine(start_date, datetime.min.time())\n        end_datetime = datetime.combine(end_date, datetime.max.time())\n\n        pipeline = [\n            {\n                \"$match\": {\n                    \"order_time\": {\"$gte\": start_datetime, \"$lte\": end_datetime},\n                    \"status\": {\"$in\": [\"ready\", \"delivered\"]}\n                }\n            },\n            {\n                \"$unwind\": \"$pizzas\"\n            },\n            {\n                \"$group\": {\n                    \"_id\": \"$pizzas.name\",\n                    \"order_count\": {\"$sum\": 1},\n                    \"total_revenue\": {\"$sum\": \"$pizzas.price\"},\n                    \"avg_price\": {\"$avg\": \"$pizzas.price\"},\n                    \"unique_customers\": {\"$addToSet\": \"$customer_phone\"}\n                }\n            },\n            {\n                \"$project\": {\n                    \"pizza_name\": \"$_id\",\n                    \"order_count\": 1,\n                    \"total_revenue\": 1,\n                    \"avg_price\": 1,\n                    \"unique_customers\": {\"$size\": \"$unique_customers\"},\n                    \"_id\": 0\n                }\n            },\n            {\n                \"$sort\": {\"order_count\": -1}\n            },\n            {\n                \"$limit\": limit\n            }\n        ]\n\n        return await self.collection.aggregate(pipeline).to_list(length=limit)\n\n    async def get_customer_insights_async(self,\n                                          customer_phone: str) -&gt; Dict[str, Any]:\n        \"\"\"Comprehensive customer analytics\"\"\"\n        pipeline = [\n            {\n                \"$match\": {\"customer_phone\": customer_phone}\n            },\n            {\n                \"$group\": {\n                    \"_id\": \"$customer_phone\",\n                    \"total_orders\": {\"$sum\": 1},\n                    \"total_spent\": {\"$sum\": \"$total_amount\"},\n                    \"avg_order_value\": {\"$avg\": \"$total_amount\"},\n                    \"first_order\": {\"$min\": \"$order_time\"},\n                    \"last_order\": {\"$max\": \"$order_time\"},\n                    \"favorite_pizzas\": {\"$push\": \"$pizzas.name\"},\n                    \"payment_methods\": {\"$addToSet\": \"$payment_method\"}\n                }\n            },\n            {\n                \"$project\": {\n                    \"customer_phone\": \"$_id\",\n                    \"total_orders\": 1,\n                    \"total_spent\": 1,\n                    \"avg_order_value\": 1,\n                    \"first_order\": 1,\n                    \"last_order\": 1,\n                    \"customer_lifetime_days\": {\n                        \"$divide\": [\n                            {\"$subtract\": [\"$last_order\", \"$first_order\"]},\n                            86400000  # milliseconds to days\n                        ]\n                    },\n                    \"payment_methods\": 1,\n                    \"_id\": 0\n                }\n            }\n        ]\n\n        results = await self.collection.aggregate(pipeline).to_list(length=1)\n        if not results:\n            return {\"error\": \"Customer not found\"}\n\n        customer_data = results[0]\n\n        # Calculate favorite pizza (most frequent)\n        # This would need additional aggregation pipeline for pizza frequency\n\n        return customer_data\n\n    async def get_peak_hours_analysis_async(self,\n                                            date_range: tuple[date, date]) -&gt; Dict[str, Any]:\n        \"\"\"Analyze order patterns by hour for staffing optimization\"\"\"\n        start_date, end_date = date_range\n        start_datetime = datetime.combine(start_date, datetime.min.time())\n        end_datetime = datetime.combine(end_date, datetime.max.time())\n\n        pipeline = [\n            {\n                \"$match\": {\n                    \"order_time\": {\"$gte\": start_datetime, \"$lte\": end_datetime}\n                }\n            },\n            {\n                \"$group\": {\n                    \"_id\": {\"$hour\": \"$order_time\"},\n                    \"order_count\": {\"$sum\": 1},\n                    \"total_revenue\": {\"$sum\": \"$total_amount\"},\n                    \"avg_order_value\": {\"$avg\": \"$total_amount\"}\n                }\n            },\n            {\n                \"$project\": {\n                    \"hour\": \"$_id\",\n                    \"order_count\": 1,\n                    \"total_revenue\": 1,\n                    \"avg_order_value\": 1,\n                    \"_id\": 0\n                }\n            },\n            {\n                \"$sort\": {\"hour\": 1}\n            }\n        ]\n\n        results = await self.collection.aggregate(pipeline).to_list(length=24)\n\n        # Fill in missing hours with zero values\n        hourly_data = {r[\"hour\"]: r for r in results}\n        complete_data = []\n\n        for hour in range(24):\n            hour_data = hourly_data.get(hour, {\n                \"hour\": hour,\n                \"order_count\": 0,\n                \"total_revenue\": 0.0,\n                \"avg_order_value\": 0.0\n            })\n            complete_data.append(hour_data)\n\n        # Find peak hours (top 3)\n        sorted_by_orders = sorted(complete_data, key=lambda x: x[\"order_count\"], reverse=True)\n        peak_hours = sorted_by_orders[:3]\n\n        return {\n            \"hourly_breakdown\": complete_data,\n            \"peak_hours\": peak_hours,\n            \"analysis_period\": {\n                \"start_date\": start_date.isoformat(),\n                \"end_date\": end_date.isoformat()\n            }\n        }\n</code></pre> <pre><code>import pytest\nfrom unittest.mock import AsyncMock\nfrom datetime import datetime, date, timedelta\nfrom decimal import Decimal\n\nclass TestOrderRepository:\n    \"\"\"Unit tests for order repository implementations\"\"\"\n\n    @pytest.fixture\n    def sample_order(self):\n        \"\"\"Create sample pizza order for testing\"\"\"\n        return Order(\n            id=\"order_123\",\n            customer_name=\"John Doe\",\n            customer_phone=\"+1234567890\",\n            customer_address=\"123 Main St\",\n            pizzas=[\n                Pizza(name=\"Margherita\", price=Decimal(\"12.99\")),\n                Pizza(name=\"Pepperoni\", price=Decimal(\"14.99\"))\n            ],\n            status=\"preparing\",\n            order_time=datetime.utcnow(),\n            total_amount=Decimal(\"27.98\"),\n            payment_method=\"card\"\n        )\n\n    @pytest.fixture\n    def mock_file_repository(self, tmp_path):\n        \"\"\"Create file repository with temporary directory\"\"\"\n        return FileOrderRepository(str(tmp_path / \"orders\"))\n\n    @pytest.mark.asyncio\n    async def test_save_order_creates_file(self, mock_file_repository, sample_order):\n        \"\"\"Test that saving an order creates proper file structure\"\"\"\n        await mock_file_repository.save_async(sample_order)\n\n        # Verify file was created\n        order_file = Path(mock_file_repository.orders_directory) / f\"{sample_order.id}.json\"\n        assert order_file.exists()\n\n        # Verify file content\n        with open(order_file, 'r') as f:\n            order_data = json.load(f)\n            assert order_data[\"customer_name\"] == sample_order.customer_name\n            assert len(order_data[\"pizzas\"]) == 2\n\n    @pytest.mark.asyncio\n    async def test_get_by_customer_phone(self, mock_file_repository, sample_order):\n        \"\"\"Test customer phone lookup functionality\"\"\"\n        await mock_file_repository.save_async(sample_order)\n\n        # Create another order for same customer\n        second_order = Order(\n            id=\"order_456\",\n            customer_name=\"John Doe\",\n            customer_phone=\"+1234567890\",\n            customer_address=\"123 Main St\",\n            pizzas=[Pizza(name=\"Hawaiian\", price=Decimal(\"15.99\"))],\n            status=\"ready\",\n            order_time=datetime.utcnow() + timedelta(hours=1)\n        )\n        await mock_file_repository.save_async(second_order)\n\n        # Test phone lookup\n        customer_orders = await mock_file_repository.get_by_customer_phone_async(\"+1234567890\")\n\n        assert len(customer_orders) == 2\n        # Should be ordered by time (most recent first)\n        assert customer_orders[0].id == \"order_456\"\n        assert customer_orders[1].id == \"order_123\"\n\n    @pytest.mark.asyncio\n    async def test_kitchen_queue_filtering(self, mock_file_repository):\n        \"\"\"Test kitchen queue status filtering\"\"\"\n        # Create orders with different statuses\n        orders = [\n            Order(id=\"order_1\", status=\"preparing\", customer_name=\"Customer 1\"),\n            Order(id=\"order_2\", status=\"cooking\", customer_name=\"Customer 2\"),\n            Order(id=\"order_3\", status=\"ready\", customer_name=\"Customer 3\"),\n            Order(id=\"order_4\", status=\"delivered\", customer_name=\"Customer 4\")\n        ]\n\n        for order in orders:\n            await mock_file_repository.save_async(order)\n\n        # Get kitchen queue (preparing and cooking)\n        kitchen_orders = await mock_file_repository.get_kitchen_queue_async([\"preparing\", \"cooking\"])\n\n        assert len(kitchen_orders) == 2\n        statuses = [order.status for order in kitchen_orders]\n        assert \"preparing\" in statuses\n        assert \"cooking\" in statuses\n        assert \"ready\" not in statuses\n\n@pytest.mark.integration\nclass TestMongoOrderRepository:\n    \"\"\"Integration tests for MongoDB repository\"\"\"\n\n    @pytest.fixture\n    async def mongo_repository(self, mongo_test_client):\n        \"\"\"Create MongoDB repository for testing\"\"\"\n        database = mongo_test_client.test_pizzeria\n        return MongoOrderRepository(database)\n\n    @pytest.mark.asyncio\n    async def test_revenue_aggregation(self, mongo_repository):\n        \"\"\"Test MongoDB revenue aggregation pipeline\"\"\"\n        # Setup test data\n        test_orders = [\n            Order(\n                id=\"order_1\",\n                total_amount=Decimal(\"25.99\"),\n                status=\"delivered\",\n                order_time=datetime(2024, 1, 15, 12, 0)\n            ),\n            Order(\n                id=\"order_2\",\n                total_amount=Decimal(\"18.50\"),\n                status=\"delivered\",\n                order_time=datetime(2024, 1, 15, 18, 0)\n            ),\n            Order(\n                id=\"order_3\",\n                total_amount=Decimal(\"32.00\"),\n                status=\"preparing\",  # Should be excluded\n                order_time=datetime(2024, 1, 15, 19, 0)\n            )\n        ]\n\n        for order in test_orders:\n            await mongo_repository.save_async(order)\n\n        # Test daily revenue calculation\n        revenue_data = await mongo_repository.get_daily_revenue_async(date(2024, 1, 15))\n\n        assert revenue_data[\"total_revenue\"] == 44.49  # Only delivered orders\n        assert revenue_data[\"order_count\"] == 2\n        assert revenue_data[\"average_order_value\"] == 22.245\n\nclass TestEventRepository:\n    \"\"\"Test event repository for kitchen workflow tracking\"\"\"\n\n    @pytest.fixture\n    def sample_kitchen_events(self):\n        \"\"\"Create sample kitchen events for testing\"\"\"\n        return [\n            OrderStatusChangedEvent(\n                order_id=\"order_123\",\n                old_status=\"received\",\n                new_status=\"preparing\",\n                changed_by=\"chef_mario\"\n            ),\n            PizzaStartedEvent(\n                order_id=\"order_123\",\n                pizza_name=\"Margherita\",\n                pizza_index=0,\n                started_by=\"chef_mario\",\n                estimated_completion=datetime.utcnow() + timedelta(minutes=12)\n            )\n        ]\n\n    @pytest.mark.asyncio\n    async def test_event_chronological_ordering(self, file_event_repository, sample_kitchen_events):\n        \"\"\"Test that events are retrieved in chronological order\"\"\"\n        # Save events in random order\n        for event in reversed(sample_kitchen_events):\n            await file_event_repository.save_event_async(event)\n\n        # Retrieve events\n        today = date.today()\n        retrieved_events = await file_event_repository.get_events_by_date_range_async(today, today)\n\n        # Should be ordered by occurrence time\n        assert len(retrieved_events) == 2\n        assert retrieved_events[0].occurred_at &lt;= retrieved_events[1].occurred_at\n\n# Test fixtures for integration testing\n@pytest.fixture\nasync def mongo_test_client():\n    \"\"\"MongoDB test client with cleanup\"\"\"\n    from motor.motor_asyncio import AsyncIOMotorClient\n\n    client = AsyncIOMotorClient(\"mongodb://localhost:27017\")\n\n    # Use test database\n    test_db = client.test_pizzeria\n\n    yield client\n\n    # Cleanup\n    await client.drop_database(\"test_pizzeria\")\n    client.close()\n\n@pytest.fixture\ndef file_event_repository(tmp_path):\n    \"\"\"File event repository with temporary storage\"\"\"\n    return FileEventRepository(str(tmp_path / \"events\"))\n</code></pre>"},{"location":"features/data-access/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started Guide - Complete pizzeria application tutorial</li> <li>CQRS &amp; Mediation - Commands and queries with pizzeria examples</li> <li>Dependency Injection - Service registration for repositories</li> <li>MVC Controllers - API endpoints using these repositories</li> <li>Source Code Naming Conventions - Repository, entity, and method naming patterns</li> </ul> <p>This documentation demonstrates data access patterns using Mario's Pizzeria as a consistent example throughout the Neuroglia framework. The patterns shown scale from simple file-based storage for development to MongoDB with advanced analytics for production use.</p>"},{"location":"features/enhanced-model-validation/","title":"\ud83d\udcca Enhanced Model Validation","text":"<p>The Neuroglia framework provides comprehensive model validation capabilities with business rule enforcement, custom validators, and sophisticated exception handling, enabling robust data integrity across all application layers with contextual validation and error reporting.</p>"},{"location":"features/enhanced-model-validation/#overview","title":"\ud83c\udfaf Overview","text":"<p>Modern applications require sophisticated validation beyond basic type checking - business rules, cross-field validation, conditional logic, and contextual constraints. The framework's enhanced validation system provides:</p> <ul> <li>Business Rule Validation: Domain-specific validation logic</li> <li>Custom Validators: Reusable validation components</li> <li>Cross-Field Validation: Dependencies between model fields</li> <li>Contextual Validation: Different rules based on context</li> <li>Rich Error Reporting: Detailed validation error messages</li> <li>Performance Optimized: Efficient validation with early termination</li> </ul>"},{"location":"features/enhanced-model-validation/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>graph TB\n    subgraph \"\ud83c\udf55 Mario's Pizzeria Models\"\n        OrderModel[Pizza Order Model]\n        CustomerModel[Customer Model]\n        MenuModel[Menu Item Model]\n        InventoryModel[Inventory Model]\n    end\n\n    subgraph \"\ud83d\udcca Enhanced Validation Layer\"\n        ValidationEngine[Validation Engine]\n        BusinessRules[Business Rule Validators]\n        CustomValidators[Custom Validators]\n        ContextValidators[Context-Aware Validators]\n    end\n\n    subgraph \"\ud83c\udfaf Validation Types\"\n        FieldValidation[Field Validation]\n        CrossFieldValidation[Cross-Field Validation]\n        ConditionalValidation[Conditional Validation]\n        BusinessLogicValidation[Business Logic Validation]\n    end\n\n    subgraph \"\ud83d\udccb Error Handling\"\n        ValidationExceptions[Validation Exceptions]\n        ErrorAggregation[Error Aggregation]\n        ContextualMessages[Contextual Messages]\n    end\n\n    OrderModel --&gt; ValidationEngine\n    CustomerModel --&gt; ValidationEngine\n    MenuModel --&gt; ValidationEngine\n    InventoryModel --&gt; ValidationEngine\n\n    ValidationEngine --&gt; BusinessRules\n    ValidationEngine --&gt; CustomValidators\n    ValidationEngine --&gt; ContextValidators\n\n    BusinessRules --&gt; FieldValidation\n    CustomValidators --&gt; CrossFieldValidation\n    ContextValidators --&gt; ConditionalValidation\n    ValidationEngine --&gt; BusinessLogicValidation\n\n    ValidationEngine --&gt; ValidationExceptions\n    ValidationExceptions --&gt; ErrorAggregation\n    ErrorAggregation --&gt; ContextualMessages\n\n    style ValidationEngine fill:#e3f2fd\n    style BusinessRules fill:#e8f5e8\n    style CustomValidators fill:#fff3e0\n    style ContextValidators fill:#f3e5f5</code></pre>"},{"location":"features/enhanced-model-validation/#basic-usage","title":"\ud83d\ude80 Basic Usage","text":""},{"location":"features/enhanced-model-validation/#service-registration","title":"Service Registration","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.validation import EnhancedModelValidator, ValidationConfig\n\ndef create_app():\n    builder = WebApplicationBuilder()\n\n    # Register enhanced model validation\n    validation_config = ValidationConfig(\n        strict_mode=True,\n        fail_fast=False,  # Collect all validation errors\n        include_field_context=True,\n        custom_error_messages=True\n    )\n\n    builder.services.add_enhanced_model_validation(validation_config)\n\n    app = builder.build()\n    return app\n</code></pre>"},{"location":"features/enhanced-model-validation/#basic-field-validation","title":"Basic Field Validation","text":"<pre><code>from neuroglia.validation import BusinessRuleValidator, ValidationContext\nfrom pydantic import BaseModel, Field, validator\nfrom typing import List, Optional\nfrom datetime import datetime, time\nfrom decimal import Decimal\n\nclass PizzaOrderModel(BaseModel):\n    \"\"\"Pizza order with comprehensive validation.\"\"\"\n\n    order_id: str = Field(..., min_length=3, max_length=20,\n                         description=\"Unique order identifier\")\n    customer_id: str = Field(..., min_length=5, max_length=50,\n                            description=\"Customer identifier\")\n\n    # Order items with business validation\n    order_items: List['OrderItemModel'] = Field(..., min_items=1, max_items=20,\n                                               description=\"Items in the order\")\n\n    # Financial fields with precision validation\n    subtotal: Decimal = Field(..., ge=0, decimal_places=2,\n                             description=\"Order subtotal\")\n    tax_amount: Decimal = Field(..., ge=0, decimal_places=2,\n                               description=\"Tax amount\")\n    delivery_fee: Decimal = Field(default=Decimal('0.00'), ge=0, decimal_places=2,\n                                 description=\"Delivery fee\")\n    total_amount: Decimal = Field(..., ge=0, decimal_places=2,\n                                 description=\"Total order amount\")\n\n    # Timing validation\n    order_placed_at: datetime = Field(..., description=\"Order placement time\")\n    requested_delivery_time: Optional[datetime] = Field(None,\n                                                       description=\"Requested delivery time\")\n\n    # Special requirements\n    special_instructions: Optional[str] = Field(None, max_length=500,\n                                              description=\"Special instructions\")\n    is_rush_order: bool = Field(default=False, description=\"Rush order flag\")\n\n    @validator('order_id')\n    def validate_order_id_format(cls, v):\n        \"\"\"Validate order ID format.\"\"\"\n        import re\n        if not re.match(r'^ORD_\\d{8}_\\d{3}$', v):\n            raise ValueError('Order ID must follow format: ORD_YYYYMMDD_XXX')\n        return v\n\n    @validator('requested_delivery_time')\n    def validate_delivery_time(cls, v, values):\n        \"\"\"Validate requested delivery time.\"\"\"\n        if v is None:\n            return v\n\n        order_placed_at = values.get('order_placed_at')\n        if order_placed_at and v &lt;= order_placed_at:\n            raise ValueError('Delivery time must be after order placement')\n\n        # Business rule: delivery must be within next 4 hours\n        if order_placed_at:\n            max_delivery_time = order_placed_at + timedelta(hours=4)\n            if v &gt; max_delivery_time:\n                raise ValueError('Delivery time cannot be more than 4 hours from now')\n\n        # Business rule: no deliveries between 2 AM and 10 AM\n        delivery_hour = v.hour\n        if 2 &lt;= delivery_hour &lt; 10:\n            raise ValueError('Deliveries not available between 2 AM and 10 AM')\n\n        return v\n\n    @validator('total_amount')\n    def validate_total_calculation(cls, v, values):\n        \"\"\"Validate total amount calculation.\"\"\"\n        subtotal = values.get('subtotal', Decimal('0'))\n        tax_amount = values.get('tax_amount', Decimal('0'))\n        delivery_fee = values.get('delivery_fee', Decimal('0'))\n\n        expected_total = subtotal + tax_amount + delivery_fee\n\n        if abs(v - expected_total) &gt; Decimal('0.01'):  # Allow 1 cent rounding difference\n            raise ValueError(\n                f'Total amount {v} does not match calculated total {expected_total}'\n            )\n\n        return v\n\n    @validator('order_items')\n    def validate_order_items_business_rules(cls, v):\n        \"\"\"Validate business rules for order items.\"\"\"\n        if not v:\n            raise ValueError('Order must contain at least one item')\n\n        # Business rule: maximum 5 of same item\n        item_counts = {}\n        for item in v:\n            key = f\"{item.menu_item_id}_{item.size}\"\n            item_counts[key] = item_counts.get(key, 0) + item.quantity\n            if item_counts[key] &gt; 5:\n                raise ValueError(f'Cannot order more than 5 of the same item: {item.item_name}')\n\n        # Business rule: rush orders limited to 3 items total\n        is_rush = any(getattr(cls, 'is_rush_order', False) for cls in [cls])\n        if is_rush and len(v) &gt; 3:\n            raise ValueError('Rush orders are limited to 3 items maximum')\n\n        return v\n\nclass OrderItemModel(BaseModel):\n    \"\"\"Individual order item with validation.\"\"\"\n\n    menu_item_id: str = Field(..., min_length=3, max_length=50)\n    item_name: str = Field(..., min_length=1, max_length=100)\n    size: str = Field(..., regex=r'^(small|medium|large|xl)$')\n    base_price: Decimal = Field(..., gt=0, decimal_places=2)\n\n    # Customizations\n    selected_toppings: List[str] = Field(default_factory=list, max_items=10)\n    removed_ingredients: List[str] = Field(default_factory=list, max_items=5)\n\n    # Quantity and pricing\n    quantity: int = Field(..., ge=1, le=10, description=\"Item quantity\")\n    toppings_price: Decimal = Field(default=Decimal('0.00'), ge=0, decimal_places=2)\n    line_total: Decimal = Field(..., ge=0, decimal_places=2)\n\n    @validator('selected_toppings')\n    def validate_toppings(cls, v):\n        \"\"\"Validate topping selections.\"\"\"\n        if len(v) != len(set(v)):\n            raise ValueError('Duplicate toppings are not allowed')\n\n        # Business rule: premium toppings limit\n        premium_toppings = ['truffle', 'caviar', 'gold_flakes']\n        premium_count = sum(1 for topping in v if topping in premium_toppings)\n        if premium_count &gt; 2:\n            raise ValueError('Maximum 2 premium toppings allowed per item')\n\n        return v\n\n    @validator('line_total')\n    def validate_line_total(cls, v, values):\n        \"\"\"Validate line total calculation.\"\"\"\n        base_price = values.get('base_price', Decimal('0'))\n        toppings_price = values.get('toppings_price', Decimal('0'))\n        quantity = values.get('quantity', 1)\n\n        expected_total = (base_price + toppings_price) * quantity\n\n        if abs(v - expected_total) &gt; Decimal('0.01'):\n            raise ValueError(\n                f'Line total {v} does not match calculated total {expected_total}'\n            )\n\n        return v\n</code></pre>"},{"location":"features/enhanced-model-validation/#business-rule-validators","title":"\ud83c\udfd7\ufe0f Business Rule Validators","text":""},{"location":"features/enhanced-model-validation/#custom-business-logic-validation","title":"Custom Business Logic Validation","text":"<pre><code>from neuroglia.validation import BusinessRuleValidator, ValidationResult\n\nclass PizzaOrderBusinessValidator(BusinessRuleValidator):\n    \"\"\"Comprehensive business rule validation for pizza orders.\"\"\"\n\n    def __init__(self, service_provider: ServiceProviderBase):\n        super().__init__(service_provider)\n        self.inventory_service = service_provider.get_service(InventoryService)\n        self.customer_service = service_provider.get_service(CustomerService)\n        self.menu_service = service_provider.get_service(MenuService)\n\n    async def validate_order_business_rules(self, order: PizzaOrderModel,\n                                          context: ValidationContext) -&gt; ValidationResult:\n        \"\"\"Validate comprehensive business rules for pizza orders.\"\"\"\n\n        errors = []\n        warnings = []\n\n        # Rule 1: Customer validation\n        customer_validation = await self.validate_customer_eligibility(order.customer_id)\n        if not customer_validation.is_valid:\n            errors.extend(customer_validation.errors)\n\n        # Rule 2: Inventory availability\n        inventory_validation = await self.validate_inventory_availability(order.order_items)\n        if not inventory_validation.is_valid:\n            errors.extend(inventory_validation.errors)\n\n        # Rule 3: Menu item availability\n        menu_validation = await self.validate_menu_items(order.order_items, context)\n        if not menu_validation.is_valid:\n            errors.extend(menu_validation.errors)\n        warnings.extend(menu_validation.warnings)\n\n        # Rule 4: Order timing validation\n        timing_validation = self.validate_order_timing(order, context)\n        if not timing_validation.is_valid:\n            errors.extend(timing_validation.errors)\n\n        # Rule 5: Financial validation\n        financial_validation = await self.validate_financial_constraints(order)\n        if not financial_validation.is_valid:\n            errors.extend(financial_validation.errors)\n\n        return ValidationResult(\n            is_valid=len(errors) == 0,\n            errors=errors,\n            warnings=warnings,\n            context=context\n        )\n\n    async def validate_customer_eligibility(self, customer_id: str) -&gt; ValidationResult:\n        \"\"\"Validate customer is eligible to place orders.\"\"\"\n\n        customer = await self.customer_service.get_customer_async(customer_id)\n        errors = []\n\n        if not customer:\n            errors.append(ValidationError(\n                field=\"customer_id\",\n                message=\"Customer not found\",\n                code=\"CUSTOMER_NOT_FOUND\"\n            ))\n            return ValidationResult(is_valid=False, errors=errors)\n\n        # Check customer account status\n        if customer.status == \"suspended\":\n            errors.append(ValidationError(\n                field=\"customer_id\",\n                message=\"Customer account is suspended\",\n                code=\"CUSTOMER_SUSPENDED\"\n            ))\n\n        # Check outstanding balance\n        if customer.outstanding_balance &gt; Decimal('100.00'):\n            errors.append(ValidationError(\n                field=\"customer_id\",\n                message=f\"Outstanding balance of ${customer.outstanding_balance} exceeds limit\",\n                code=\"OUTSTANDING_BALANCE_LIMIT\"\n            ))\n\n        # Check daily order limit\n        today_orders = await self.customer_service.get_today_order_count(customer_id)\n        if today_orders &gt;= 10:\n            errors.append(ValidationError(\n                field=\"customer_id\",\n                message=\"Daily order limit exceeded (10 orders per day)\",\n                code=\"DAILY_ORDER_LIMIT\"\n            ))\n\n        return ValidationResult(is_valid=len(errors) == 0, errors=errors)\n\n    async def validate_inventory_availability(self, order_items: List[OrderItemModel]) -&gt; ValidationResult:\n        \"\"\"Validate ingredient availability for all order items.\"\"\"\n\n        errors = []\n\n        for item in order_items:\n            # Get recipe ingredients for menu item\n            recipe = await self.menu_service.get_recipe_async(item.menu_item_id)\n            if not recipe:\n                errors.append(ValidationError(\n                    field=f\"order_items[{item.menu_item_id}]\",\n                    message=f\"Recipe not found for item: {item.item_name}\",\n                    code=\"RECIPE_NOT_FOUND\"\n                ))\n                continue\n\n            # Check base ingredients\n            for ingredient in recipe.base_ingredients:\n                required_quantity = ingredient.quantity * item.quantity\n                available_quantity = await self.inventory_service.get_available_quantity(\n                    ingredient.ingredient_id\n                )\n\n                if available_quantity &lt; required_quantity:\n                    errors.append(ValidationError(\n                        field=f\"order_items[{item.menu_item_id}].quantity\",\n                        message=f\"Insufficient {ingredient.name}: need {required_quantity}, have {available_quantity}\",\n                        code=\"INSUFFICIENT_INVENTORY\"\n                    ))\n\n            # Check topping availability\n            for topping_id in item.selected_toppings:\n                topping_quantity = await self.inventory_service.get_available_quantity(topping_id)\n                required_quantity = item.quantity  # 1 unit per pizza\n\n                if topping_quantity &lt; required_quantity:\n                    errors.append(ValidationError(\n                        field=f\"order_items[{item.menu_item_id}].selected_toppings\",\n                        message=f\"Topping '{topping_id}' not available in sufficient quantity\",\n                        code=\"TOPPING_UNAVAILABLE\"\n                    ))\n\n        return ValidationResult(is_valid=len(errors) == 0, errors=errors)\n\n    async def validate_menu_items(self, order_items: List[OrderItemModel],\n                                context: ValidationContext) -&gt; ValidationResult:\n        \"\"\"Validate menu item availability and special conditions.\"\"\"\n\n        errors = []\n        warnings = []\n\n        for item in order_items:\n            menu_item = await self.menu_service.get_menu_item_async(item.menu_item_id)\n\n            if not menu_item:\n                errors.append(ValidationError(\n                    field=f\"order_items[{item.menu_item_id}]\",\n                    message=f\"Menu item not found: {item.menu_item_id}\",\n                    code=\"MENU_ITEM_NOT_FOUND\"\n                ))\n                continue\n\n            # Check if item is available\n            if not menu_item.is_available:\n                errors.append(ValidationError(\n                    field=f\"order_items[{item.menu_item_id}]\",\n                    message=f\"Menu item is currently unavailable: {item.item_name}\",\n                    code=\"MENU_ITEM_UNAVAILABLE\"\n                ))\n\n            # Check size availability\n            if item.size not in menu_item.available_sizes:\n                errors.append(ValidationError(\n                    field=f\"order_items[{item.menu_item_id}].size\",\n                    message=f\"Size '{item.size}' not available for {item.item_name}\",\n                    code=\"SIZE_UNAVAILABLE\"\n                ))\n\n            # Check seasonal availability\n            if menu_item.is_seasonal and not self.is_in_season(menu_item, context.current_date):\n                warnings.append(ValidationWarning(\n                    field=f\"order_items[{item.menu_item_id}]\",\n                    message=f\"'{item.item_name}' is a seasonal item and may not be available\",\n                    code=\"SEASONAL_ITEM_WARNING\"\n                ))\n\n            # Validate price matches current menu price\n            current_price = menu_item.get_price_for_size(item.size)\n            if abs(item.base_price - current_price) &gt; Decimal('0.01'):\n                errors.append(ValidationError(\n                    field=f\"order_items[{item.menu_item_id}].base_price\",\n                    message=f\"Price mismatch: expected {current_price}, got {item.base_price}\",\n                    code=\"PRICE_MISMATCH\"\n                ))\n\n        return ValidationResult(\n            is_valid=len(errors) == 0,\n            errors=errors,\n            warnings=warnings\n        )\n\n    def validate_order_timing(self, order: PizzaOrderModel,\n                            context: ValidationContext) -&gt; ValidationResult:\n        \"\"\"Validate order timing constraints.\"\"\"\n\n        errors = []\n        current_time = context.current_datetime\n\n        # Check restaurant hours\n        restaurant_hours = self.get_restaurant_hours(current_time.weekday())\n        current_hour = current_time.hour\n\n        if not (restaurant_hours.open_hour &lt;= current_hour &lt; restaurant_hours.close_hour):\n            errors.append(ValidationError(\n                field=\"order_placed_at\",\n                message=f\"Restaurant is closed. Hours: {restaurant_hours.open_hour}:00 - {restaurant_hours.close_hour}:00\",\n                code=\"RESTAURANT_CLOSED\"\n            ))\n\n        # Rush order timing validation\n        if order.is_rush_order:\n            # Rush orders not allowed in last hour before closing\n            if current_hour &gt;= restaurant_hours.close_hour - 1:\n                errors.append(ValidationError(\n                    field=\"is_rush_order\",\n                    message=\"Rush orders not available in the last hour before closing\",\n                    code=\"RUSH_ORDER_TOO_LATE\"\n                ))\n\n            # Check rush order capacity\n            current_rush_orders = context.get(\"current_rush_orders\", 0)\n            if current_rush_orders &gt;= 5:  # Max 5 rush orders at once\n                errors.append(ValidationError(\n                    field=\"is_rush_order\",\n                    message=\"Rush order capacity exceeded. Please try again later.\",\n                    code=\"RUSH_ORDER_CAPACITY_EXCEEDED\"\n                ))\n\n        return ValidationResult(is_valid=len(errors) == 0, errors=errors)\n\n    async def validate_financial_constraints(self, order: PizzaOrderModel) -&gt; ValidationResult:\n        \"\"\"Validate financial business rules.\"\"\"\n\n        errors = []\n\n        # Minimum order value\n        minimum_order = Decimal('10.00')\n        if order.subtotal &lt; minimum_order:\n            errors.append(ValidationError(\n                field=\"subtotal\",\n                message=f\"Minimum order value is ${minimum_order}\",\n                code=\"MINIMUM_ORDER_NOT_MET\"\n            ))\n\n        # Maximum single order value (fraud prevention)\n        maximum_order = Decimal('500.00')\n        if order.total_amount &gt; maximum_order:\n            errors.append(ValidationError(\n                field=\"total_amount\",\n                message=f\"Maximum single order value is ${maximum_order}\",\n                code=\"MAXIMUM_ORDER_EXCEEDED\"\n            ))\n\n        # Rush order surcharge validation\n        if order.is_rush_order:\n            expected_rush_fee = order.subtotal * Decimal('0.20')  # 20% surcharge\n            if abs(order.delivery_fee - expected_rush_fee) &gt; Decimal('0.01'):\n                errors.append(ValidationError(\n                    field=\"delivery_fee\",\n                    message=f\"Rush order delivery fee should be ${expected_rush_fee}\",\n                    code=\"RUSH_DELIVERY_FEE_INCORRECT\"\n                ))\n\n        return ValidationResult(is_valid=len(errors) == 0, errors=errors)\n</code></pre>"},{"location":"features/enhanced-model-validation/#context-aware-validation","title":"\ud83c\udfaf Context-Aware Validation","text":""},{"location":"features/enhanced-model-validation/#dynamic-validation-based-on-context","title":"Dynamic Validation Based on Context","text":"<pre><code>from neuroglia.validation import ContextAwareValidator, ValidationContext\n\nclass CustomerRegistrationValidator(ContextAwareValidator):\n    \"\"\"Context-aware validation for customer registration.\"\"\"\n\n    async def validate_customer_registration(self, customer_data: dict,\n                                           context: ValidationContext) -&gt; ValidationResult:\n        \"\"\"Validate customer registration with context-specific rules.\"\"\"\n\n        errors = []\n        warnings = []\n\n        # Different validation rules based on registration source\n        registration_source = context.get(\"registration_source\", \"web\")\n\n        if registration_source == \"mobile_app\":\n            # Mobile app requires phone verification\n            mobile_validation = await self.validate_mobile_app_requirements(customer_data)\n            errors.extend(mobile_validation.errors)\n\n        elif registration_source == \"social_login\":\n            # Social login has different email validation\n            social_validation = await self.validate_social_login_requirements(customer_data)\n            errors.extend(social_validation.errors)\n\n        elif registration_source == \"in_store\":\n            # In-store registration allows relaxed validation\n            store_validation = await self.validate_in_store_requirements(customer_data)\n            warnings.extend(store_validation.warnings)\n\n        # Location-based validation\n        customer_location = context.get(\"customer_location\")\n        if customer_location:\n            location_validation = await self.validate_location_requirements(\n                customer_data, customer_location\n            )\n            errors.extend(location_validation.errors)\n\n        # Time-based validation (different rules for peak hours)\n        current_hour = context.current_datetime.hour\n        if 11 &lt;= current_hour &lt;= 14:  # Lunch rush\n            # Expedited validation during peak hours\n            peak_validation = self.validate_peak_hour_registration(customer_data)\n            if not peak_validation.is_valid:\n                # Convert some errors to warnings during peak hours\n                warnings.extend([\n                    ValidationWarning(\n                        field=error.field,\n                        message=f\"Peak hours: {error.message}\",\n                        code=f\"PEAK_{error.code}\"\n                    ) for error in peak_validation.errors\n                ])\n\n        return ValidationResult(\n            is_valid=len(errors) == 0,\n            errors=errors,\n            warnings=warnings,\n            context=context\n        )\n\n    async def validate_mobile_app_requirements(self, customer_data: dict) -&gt; ValidationResult:\n        \"\"\"Validate requirements specific to mobile app registration.\"\"\"\n\n        errors = []\n\n        # Phone number is required for mobile registration\n        if not customer_data.get(\"phone_number\"):\n            errors.append(ValidationError(\n                field=\"phone_number\",\n                message=\"Phone number is required for mobile registration\",\n                code=\"MOBILE_PHONE_REQUIRED\"\n            ))\n\n        # Push notification consent\n        if not customer_data.get(\"accepts_push_notifications\"):\n            errors.append(ValidationError(\n                field=\"accepts_push_notifications\",\n                message=\"Push notification consent required for mobile app\",\n                code=\"PUSH_CONSENT_REQUIRED\"\n            ))\n\n        return ValidationResult(is_valid=len(errors) == 0, errors=errors)\n\n    async def validate_location_requirements(self, customer_data: dict,\n                                           location: dict) -&gt; ValidationResult:\n        \"\"\"Validate location-specific requirements.\"\"\"\n\n        errors = []\n\n        # Check if we deliver to this location\n        is_in_delivery_zone = await self.check_delivery_zone(location)\n        if not is_in_delivery_zone:\n            errors.append(ValidationError(\n                field=\"address\",\n                message=\"Sorry, we don't deliver to this location yet\",\n                code=\"OUTSIDE_DELIVERY_ZONE\"\n            ))\n\n        # State-specific validation (e.g., age verification requirements)\n        state = location.get(\"state\")\n        if state in [\"CA\", \"NY\"]:  # States with stricter requirements\n            if not customer_data.get(\"date_of_birth\"):\n                errors.append(ValidationError(\n                    field=\"date_of_birth\",\n                    message=f\"Date of birth required for registration in {state}\",\n                    code=\"STATE_DOB_REQUIRED\"\n                ))\n\n        return ValidationResult(is_valid=len(errors) == 0, errors=errors)\n</code></pre>"},{"location":"features/enhanced-model-validation/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"features/enhanced-model-validation/#comprehensive-validation-testing","title":"Comprehensive Validation Testing","text":"<pre><code>import pytest\nfrom decimal import Decimal\nfrom datetime import datetime, timedelta\nfrom neuroglia.validation import ValidationContext, ValidationResult\n\nclass TestPizzaOrderValidation:\n\n    @pytest.fixture\n    def valid_order_data(self):\n        return {\n            \"order_id\": \"ORD_20241201_001\",\n            \"customer_id\": \"CUST_12345\",\n            \"order_items\": [\n                {\n                    \"menu_item_id\": \"margherita_large\",\n                    \"item_name\": \"Margherita Pizza\",\n                    \"size\": \"large\",\n                    \"base_price\": Decimal(\"18.99\"),\n                    \"selected_toppings\": [\"extra_cheese\"],\n                    \"removed_ingredients\": [],\n                    \"quantity\": 1,\n                    \"toppings_price\": Decimal(\"2.50\"),\n                    \"line_total\": Decimal(\"21.49\")\n                }\n            ],\n            \"subtotal\": Decimal(\"21.49\"),\n            \"tax_amount\": Decimal(\"1.72\"),\n            \"delivery_fee\": Decimal(\"2.99\"),\n            \"total_amount\": Decimal(\"26.20\"),\n            \"order_placed_at\": datetime.utcnow(),\n            \"requested_delivery_time\": datetime.utcnow() + timedelta(minutes=45),\n            \"special_instructions\": \"Ring doorbell\",\n            \"is_rush_order\": False\n        }\n\n    @pytest.fixture\n    def validation_context(self):\n        return ValidationContext(\n            current_datetime=datetime.utcnow(),\n            current_date=datetime.utcnow().date(),\n            user_context={\"customer_id\": \"CUST_12345\"},\n            request_context={\"source\": \"web_app\"}\n        )\n\n    def test_valid_order_passes_validation(self, valid_order_data):\n        \"\"\"Test that a valid order passes all validation.\"\"\"\n\n        order = PizzaOrderModel(**valid_order_data)\n\n        # Should not raise any validation errors\n        assert order.order_id == \"ORD_20241201_001\"\n        assert order.total_amount == Decimal(\"26.20\")\n        assert len(order.order_items) == 1\n\n    def test_invalid_order_id_format(self, valid_order_data):\n        \"\"\"Test order ID format validation.\"\"\"\n\n        valid_order_data[\"order_id\"] = \"INVALID_FORMAT\"\n\n        with pytest.raises(ValueError) as exc_info:\n            PizzaOrderModel(**valid_order_data)\n\n        assert \"Order ID must follow format\" in str(exc_info.value)\n\n    def test_total_calculation_validation(self, valid_order_data):\n        \"\"\"Test total amount calculation validation.\"\"\"\n\n        # Set incorrect total\n        valid_order_data[\"total_amount\"] = Decimal(\"99.99\")\n\n        with pytest.raises(ValueError) as exc_info:\n            PizzaOrderModel(**valid_order_data)\n\n        assert \"Total amount\" in str(exc_info.value)\n        assert \"does not match calculated total\" in str(exc_info.value)\n\n    def test_delivery_time_validation(self, valid_order_data):\n        \"\"\"Test delivery time business rules.\"\"\"\n\n        # Set delivery time in the past\n        valid_order_data[\"requested_delivery_time\"] = datetime.utcnow() - timedelta(hours=1)\n\n        with pytest.raises(ValueError) as exc_info:\n            PizzaOrderModel(**valid_order_data)\n\n        assert \"Delivery time must be after order placement\" in str(exc_info.value)\n\n    def test_delivery_time_early_hours_restriction(self, valid_order_data):\n        \"\"\"Test early hours delivery restriction.\"\"\"\n\n        # Set delivery time at 3 AM (restricted hours)\n        tomorrow_3am = datetime.utcnow().replace(hour=3, minute=0, second=0) + timedelta(days=1)\n        valid_order_data[\"requested_delivery_time\"] = tomorrow_3am\n\n        with pytest.raises(ValueError) as exc_info:\n            PizzaOrderModel(**valid_order_data)\n\n        assert \"not available between 2 AM and 10 AM\" in str(exc_info.value)\n\n    def test_maximum_item_quantity_validation(self, valid_order_data):\n        \"\"\"Test maximum quantity validation.\"\"\"\n\n        # Set quantity above limit\n        valid_order_data[\"order_items\"][0][\"quantity\"] = 15\n        valid_order_data[\"order_items\"][0][\"line_total\"] = Decimal(\"322.35\")  # Adjust total\n        valid_order_data[\"subtotal\"] = Decimal(\"322.35\")\n        valid_order_data[\"total_amount\"] = Decimal(\"350.00\")  # Adjust totals\n\n        with pytest.raises(ValueError) as exc_info:\n            PizzaOrderModel(**valid_order_data)\n\n        assert \"quantity\" in str(exc_info.value)\n\n    def test_duplicate_toppings_validation(self, valid_order_data):\n        \"\"\"Test duplicate toppings validation.\"\"\"\n\n        # Add duplicate toppings\n        valid_order_data[\"order_items\"][0][\"selected_toppings\"] = [\n            \"extra_cheese\", \"extra_cheese\", \"pepperoni\"\n        ]\n\n        with pytest.raises(ValueError) as exc_info:\n            PizzaOrderModel(**valid_order_data)\n\n        assert \"Duplicate toppings are not allowed\" in str(exc_info.value)\n\n    @pytest.mark.asyncio\n    async def test_business_rule_validation(self, valid_order_data, validation_context):\n        \"\"\"Test comprehensive business rule validation.\"\"\"\n\n        # Mock services\n        business_validator = PizzaOrderBusinessValidator(mock_service_provider())\n\n        order = PizzaOrderModel(**valid_order_data)\n        result = await business_validator.validate_order_business_rules(order, validation_context)\n\n        # Should pass basic validation (with mocked services)\n        assert isinstance(result, ValidationResult)\n\n    def test_line_total_calculation_validation(self, valid_order_data):\n        \"\"\"Test line total calculation validation.\"\"\"\n\n        # Set incorrect line total\n        valid_order_data[\"order_items\"][0][\"line_total\"] = Decimal(\"99.99\")\n        # Keep other totals consistent to isolate this validation\n\n        with pytest.raises(ValueError) as exc_info:\n            PizzaOrderModel(**valid_order_data)\n\n        assert \"Line total\" in str(exc_info.value)\n        assert \"does not match calculated total\" in str(exc_info.value)\n\ndef mock_service_provider():\n    \"\"\"Create mock service provider for testing.\"\"\"\n    from unittest.mock import Mock\n\n    service_provider = Mock()\n\n    # Mock inventory service\n    inventory_service = Mock()\n    inventory_service.get_available_quantity = Mock(return_value=100)  # Always available\n\n    # Mock customer service\n    customer_service = Mock()\n    mock_customer = Mock()\n    mock_customer.status = \"active\"\n    mock_customer.outstanding_balance = Decimal(\"0.00\")\n    customer_service.get_customer_async = Mock(return_value=mock_customer)\n    customer_service.get_today_order_count = Mock(return_value=0)\n\n    # Mock menu service\n    menu_service = Mock()\n    mock_recipe = Mock()\n    mock_recipe.base_ingredients = []\n    menu_service.get_recipe_async = Mock(return_value=mock_recipe)\n\n    mock_menu_item = Mock()\n    mock_menu_item.is_available = True\n    mock_menu_item.available_sizes = [\"small\", \"medium\", \"large\"]\n    mock_menu_item.is_seasonal = False\n    mock_menu_item.get_price_for_size = Mock(return_value=Decimal(\"18.99\"))\n    menu_service.get_menu_item_async = Mock(return_value=mock_menu_item)\n\n    service_provider.get_service.side_effect = lambda service_type: {\n        'InventoryService': inventory_service,\n        'CustomerService': customer_service,\n        'MenuService': menu_service\n    }.get(service_type.__name__ if hasattr(service_type, '__name__') else str(service_type))\n\n    return service_provider\n</code></pre>"},{"location":"features/enhanced-model-validation/#performance-testing","title":"Performance Testing","text":"<pre><code>import time\nimport pytest\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass TestValidationPerformance:\n\n    def test_validation_performance(self, valid_order_data):\n        \"\"\"Test validation performance with large datasets.\"\"\"\n\n        # Create 100 order variations\n        orders_data = []\n        for i in range(100):\n            order_data = valid_order_data.copy()\n            order_data[\"order_id\"] = f\"ORD_20241201_{i:03d}\"\n            orders_data.append(order_data)\n\n        # Time validation\n        start_time = time.time()\n\n        valid_orders = []\n        for order_data in orders_data:\n            try:\n                order = PizzaOrderModel(**order_data)\n                valid_orders.append(order)\n            except ValueError:\n                pass  # Skip invalid orders\n\n        end_time = time.time()\n        duration = end_time - start_time\n\n        print(f\"\u2705 Validated {len(valid_orders)} orders in {duration:.3f}s\")\n        print(f\"\ud83d\udcca Average validation time: {(duration/len(orders_data)*1000):.1f}ms per order\")\n\n        # Performance assertion\n        assert duration &lt; 1.0, f\"Validation took too long: {duration:.3f}s\"\n        assert len(valid_orders) == 100, \"Some valid orders failed validation\"\n</code></pre>"},{"location":"features/enhanced-model-validation/#error-aggregation-and-reporting","title":"\ud83d\udcca Error Aggregation and Reporting","text":""},{"location":"features/enhanced-model-validation/#comprehensive-error-handling","title":"Comprehensive Error Handling","text":"<pre><code>from neuroglia.validation import ValidationErrorAggregator, ValidationReport\n\nclass OrderValidationService:\n    \"\"\"Service for comprehensive order validation with detailed reporting.\"\"\"\n\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.business_validator = service_provider.get_service(PizzaOrderBusinessValidator)\n        self.error_aggregator = ValidationErrorAggregator()\n\n    async def validate_order_comprehensively(self, order_data: dict,\n                                           context: ValidationContext) -&gt; ValidationReport:\n        \"\"\"Perform comprehensive validation with detailed error reporting.\"\"\"\n\n        validation_report = ValidationReport()\n\n        try:\n            # Step 1: Basic model validation\n            validation_report.add_step(\"Model Validation\")\n            order_model = PizzaOrderModel(**order_data)\n            validation_report.mark_step_success(\"Model Validation\")\n\n        except ValueError as e:\n            validation_report.mark_step_failed(\"Model Validation\", str(e))\n            return validation_report\n\n        # Step 2: Business rule validation\n        validation_report.add_step(\"Business Rules Validation\")\n        business_result = await self.business_validator.validate_order_business_rules(\n            order_model, context\n        )\n\n        if business_result.is_valid:\n            validation_report.mark_step_success(\"Business Rules Validation\")\n        else:\n            validation_report.mark_step_failed(\n                \"Business Rules Validation\",\n                business_result.errors\n            )\n            validation_report.add_warnings(business_result.warnings)\n\n        # Step 3: Context-specific validation\n        validation_report.add_step(\"Context Validation\")\n        context_result = await self.validate_context_specific_rules(order_model, context)\n\n        if context_result.is_valid:\n            validation_report.mark_step_success(\"Context Validation\")\n        else:\n            validation_report.mark_step_failed(\"Context Validation\", context_result.errors)\n\n        # Generate comprehensive report\n        validation_report.finalize()\n\n        print(\"\ud83d\udccb Validation Report:\")\n        print(f\"Overall Status: {'\u2705 VALID' if validation_report.is_valid else '\u274c INVALID'}\")\n        print(f\"Total Errors: {len(validation_report.all_errors)}\")\n        print(f\"Total Warnings: {len(validation_report.all_warnings)}\")\n\n        if validation_report.all_errors:\n            print(\"\\n\ud83d\udea8 Validation Errors:\")\n            for error in validation_report.all_errors:\n                print(f\"  \u2022 {error.field}: {error.message} ({error.code})\")\n\n        if validation_report.all_warnings:\n            print(\"\\n\u26a0\ufe0f Validation Warnings:\")\n            for warning in validation_report.all_warnings:\n                print(f\"  \u2022 {warning.field}: {warning.message} ({warning.code})\")\n\n        return validation_report\n</code></pre>"},{"location":"features/enhanced-model-validation/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\ud83d\udd27 Dependency Injection - Service registration for validators</li> <li>\ud83d\udd04 Case Conversion Utilities - Model field transformations</li> <li>\ud83d\udce8 CQRS &amp; Mediation - Command validation patterns</li> <li>\ud83c\udf10 HTTP Service Client - Request/response validation</li> <li>\ud83d\udcc1 Data Access - Data persistence validation</li> </ul> <p>The Enhanced Model Validation system provides comprehensive data integrity enforcement throughout Mario's Pizzeria application. Through business rules, contextual validation, and detailed error reporting, the system ensures reliable operations while providing clear feedback for resolution of validation issues.</p>"},{"location":"features/hosting/","title":"Application Hosting","text":"<p>Time to read: 15 minutes</p> <p>Neuroglia's hosting infrastructure provides enterprise-grade application lifecycle management for building production-ready microservices. The <code>WebApplicationBuilder</code> is the central component that handles configuration, dependency injection, and application startup.</p>"},{"location":"features/hosting/#what-why","title":"\ud83c\udfaf What &amp; Why","text":""},{"location":"features/hosting/#what-is-application-hosting","title":"What is Application Hosting?","text":"<p>Application hosting in Neuroglia manages the complete lifecycle of a web application:</p> <ul> <li>Configuration: Loading settings, environment variables</li> <li>Dependency Injection: Registering and resolving services</li> <li>Controller Discovery: Finding and mounting API controllers</li> <li>Background Services: Running tasks alongside the web server</li> <li>Lifecycle Management: Startup, running, graceful shutdown</li> <li>Observability: Health checks, metrics, tracing</li> </ul>"},{"location":"features/hosting/#why-use-neuroglia-hosting","title":"Why Use Neuroglia Hosting?","text":"<p>Without Neuroglia Hosting:</p> <pre><code># \u274c Manual setup - repetitive and error-prone\nfrom fastapi import FastAPI\nimport uvicorn\n\napp = FastAPI()\n\n# Manually register each controller\nfrom api.controllers.users import router as users_router\nfrom api.controllers.orders import router as orders_router\napp.include_router(users_router, prefix=\"/api/users\")\napp.include_router(orders_router, prefix=\"/api/orders\")\n\n# No DI - manual instantiation\ndatabase = Database(connection_string=os.getenv(\"DB_CONN\"))\nuser_service = UserService(database)\n\n# No lifecycle management\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre> <p>With Neuroglia Hosting:</p> <pre><code># \u2705 Clean, declarative, automatic\nfrom neuroglia.hosting import WebApplicationBuilder\n\nbuilder = WebApplicationBuilder()\n\n# Auto-discover and register controllers\nbuilder.add_controllers([\"api.controllers\"])\n\n# DI handles instantiation\nbuilder.services.add_scoped(Database)\nbuilder.services.add_scoped(UserService)\n\n# Built-in lifecycle management\napp = builder.build()\napp.run()\n</code></pre>"},{"location":"features/hosting/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"features/hosting/#simple-mode-basic-applications","title":"Simple Mode (Basic Applications)","text":"<p>For straightforward applications with single API:</p> <pre><code>from neuroglia.hosting import WebApplicationBuilder\n\ndef create_app():\n    builder = WebApplicationBuilder()\n\n    # Register services\n    builder.services.add_scoped(OrderRepository)\n    builder.services.add_scoped(OrderService)\n\n    # Auto-discover controllers\n    builder.add_controllers([\"api.controllers\"])\n\n    # Build and return\n    host = builder.build()\n    return host\n\nif __name__ == \"__main__\":\n    app = create_app()\n    app.run(host=\"0.0.0.0\", port=8000)\n</code></pre>"},{"location":"features/hosting/#advanced-mode-production-applications","title":"Advanced Mode (Production Applications)","text":"<p>For production apps with observability, multi-app support:</p> <pre><code>from neuroglia.hosting import WebApplicationBuilder\nfrom neuroglia.hosting.abstractions import ApplicationSettings\n\ndef create_app():\n    # Load configuration\n    app_settings = ApplicationSettings()\n\n    # Advanced features enabled automatically\n    builder = WebApplicationBuilder(app_settings)\n\n    # Register services\n    builder.services.add_scoped(OrderRepository)\n    builder.services.add_scoped(EmailService)\n\n    # Multi-app support with prefixes\n    builder.add_controllers([\"api.controllers\"], prefix=\"/api\")\n    builder.add_controllers([\"admin.controllers\"], prefix=\"/admin\")\n\n    # Add background services\n    builder.services.add_hosted_service(CleanupService)\n\n    # Build with lifecycle management\n    app = builder.build_app_with_lifespan(\n        title=\"Mario's Pizzeria API\",\n        version=\"1.0.0\"\n    )\n\n    return app\n\nif __name__ == \"__main__\":\n    import uvicorn\n    app = create_app()\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre>"},{"location":"features/hosting/#core-components","title":"\ud83c\udfd7\ufe0f Core Components","text":""},{"location":"features/hosting/#webapplicationbuilder","title":"WebApplicationBuilder","text":"<p>The main builder for creating applications:</p> <pre><code>from neuroglia.hosting import WebApplicationBuilder\n\n# Simple mode\nbuilder = WebApplicationBuilder()\n\n# Advanced mode\nfrom neuroglia.hosting.abstractions import ApplicationSettings\napp_settings = ApplicationSettings()\nbuilder = WebApplicationBuilder(app_settings)\n</code></pre> <p>Key Properties:</p> <ul> <li><code>services</code>: ServiceCollection for DI registration</li> <li><code>app</code>: The FastAPI application instance (after build)</li> <li><code>app_settings</code>: Application configuration</li> </ul> <p>Key Methods:</p> <ul> <li><code>add_controllers(modules, prefix)</code>: Register controllers</li> <li><code>build()</code>: Build host (returns WebHost or EnhancedWebHost)</li> <li><code>build_app_with_lifespan(title, version)</code>: Build FastAPI app with lifecycle</li> <li><code>use_controllers()</code>: Mount controllers on app</li> </ul>"},{"location":"features/hosting/#controller-registration","title":"Controller Registration","text":"<p>Automatically discover and register controllers:</p> <pre><code># Single module\nbuilder.add_controllers([\"api.controllers\"])\n\n# Multiple modules\nbuilder.add_controllers([\n    \"api.controllers.orders\",\n    \"api.controllers.customers\",\n    \"api.controllers.menu\"\n])\n\n# With custom prefix\nbuilder.add_controllers([\"api.controllers\"], prefix=\"/api/v1\")\n\n# Multiple apps with different prefixes\nbuilder.add_controllers([\"api.controllers\"], prefix=\"/api\")\nbuilder.add_controllers([\"admin.controllers\"], prefix=\"/admin\")\n</code></pre>"},{"location":"features/hosting/#hosted-services","title":"Hosted Services","text":"<p>Background services that run alongside your application:</p> <pre><code>from neuroglia.hosting.abstractions import HostedService\n\nclass CleanupService(HostedService):\n    \"\"\"Background service for cleanup tasks.\"\"\"\n\n    async def start_async(self):\n        \"\"\"Called on application startup.\"\"\"\n        self.running = True\n        while self.running:\n            await self.cleanup_old_orders()\n            await asyncio.sleep(3600)  # Run every hour\n\n    async def stop_async(self):\n        \"\"\"Called on application shutdown.\"\"\"\n        self.running = False\n\n    async def cleanup_old_orders(self):\n        # Cleanup logic\n        pass\n\n# Register hosted service\nbuilder.services.add_hosted_service(CleanupService)\n</code></pre>"},{"location":"features/hosting/#application-settings","title":"Application Settings","text":"<p>Configuration management:</p> <pre><code>from neuroglia.hosting.abstractions import ApplicationSettings\nfrom pydantic import Field\n\nclass MyAppSettings(ApplicationSettings):\n    \"\"\"Custom application settings.\"\"\"\n\n    database_url: str = Field(default=\"mongodb://localhost:27017\")\n    redis_url: str = Field(default=\"redis://localhost:6379\")\n    api_key: str = Field(default=\"\", env=\"API_KEY\")\n    debug: bool = Field(default=False)\n\n# Load settings (from environment variables)\napp_settings = MyAppSettings()\n\n# Use in builder\nbuilder = WebApplicationBuilder(app_settings)\n\n# Access in services via DI\nclass OrderService:\n    def __init__(self, settings: MyAppSettings):\n        self.db_url = settings.database_url\n</code></pre>"},{"location":"features/hosting/#real-world-example-marios-pizzeria","title":"\ud83d\udca1 Real-World Example: Mario's Pizzeria","text":"<p>Complete application setup:</p> <pre><code>from neuroglia.hosting import WebApplicationBuilder\nfrom neuroglia.hosting.abstractions import ApplicationSettings\nfrom neuroglia.dependency_injection import ServiceLifetime\nfrom application.settings import PizzeriaSettings\n\ndef create_app():\n    # Load configuration\n    settings = PizzeriaSettings()\n\n    # Create builder with settings\n    builder = WebApplicationBuilder(settings)\n\n    # Register domain repositories\n    builder.services.add_scoped(IOrderRepository, MongoOrderRepository)\n    builder.services.add_scoped(ICustomerRepository, MongoCustomerRepository)\n    builder.services.add_scoped(IMenuRepository, MongoMenuRepository)\n\n    # Register application services\n    builder.services.add_scoped(OrderService)\n    builder.services.add_scoped(CustomerService)\n\n    # Register infrastructure\n    builder.services.add_singleton(EmailService)\n    builder.services.add_singleton(PaymentService)\n\n    # Add mediator for CQRS\n    builder.services.add_mediator()\n\n    # Register controllers\n    builder.add_controllers([\"api.controllers.orders\"], prefix=\"/api\")\n    builder.add_controllers([\"api.controllers.customers\"], prefix=\"/api\")\n    builder.add_controllers([\"api.controllers.menu\"], prefix=\"/api\")\n\n    # Add background services\n    builder.services.add_hosted_service(OrderCleanupService)\n    builder.services.add_hosted_service(MetricsCollectorService)\n\n    # Build application with lifecycle management\n    app = builder.build_app_with_lifespan(\n        title=\"Mario's Pizzeria API\",\n        version=\"1.0.0\",\n        description=\"Pizza ordering and management system\"\n    )\n\n    return app\n\nif __name__ == \"__main__\":\n    import uvicorn\n    app = create_app()\n    uvicorn.run(\n        app,\n        host=\"0.0.0.0\",\n        port=8000,\n        log_level=\"info\"\n    )\n</code></pre>"},{"location":"features/hosting/#advanced-features","title":"\ud83d\udd27 Advanced Features","text":""},{"location":"features/hosting/#multi-application-architecture","title":"Multi-Application Architecture","text":"<p>Host multiple FastAPI applications in one process:</p> <pre><code>from neuroglia.hosting import WebApplicationBuilder\nfrom fastapi import FastAPI\n\n# Create builder with settings\nbuilder = WebApplicationBuilder(app_settings)\n\n# Create custom sub-applications\napi_app = FastAPI(title=\"Public API\")\nadmin_app = FastAPI(title=\"Admin Panel\")\n\n# Register controllers to specific apps\nbuilder.add_controllers(\n    [\"api.controllers\"],\n    app=api_app,\n    prefix=\"/api\"\n)\n\nbuilder.add_controllers(\n    [\"admin.controllers\"],\n    app=admin_app,\n    prefix=\"/admin\"\n)\n\n# Build host that manages both apps\nhost = builder.build()\n# host.app has both /api and /admin mounted\n</code></pre>"},{"location":"features/hosting/#exception-handling","title":"Exception Handling","text":"<p>Global exception handling middleware:</p> <pre><code>from neuroglia.hosting.web import ExceptionHandlingMiddleware\n\n# Automatically included in WebApplicationBuilder\n# Catches exceptions and formats responses\n\n# Custom error handling\nfrom fastapi import HTTPException\n\n@app.exception_handler(HTTPException)\nasync def custom_http_exception_handler(request, exc):\n    return {\n        \"error\": exc.detail,\n        \"status_code\": exc.status_code\n    }\n</code></pre>"},{"location":"features/hosting/#lifecycle-hooks","title":"Lifecycle Hooks","text":"<p>React to application lifecycle events:</p> <pre><code>from contextlib import asynccontextmanager\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Application lifespan manager.\"\"\"\n    # Startup\n    print(\"Application starting...\")\n    await database.connect()\n\n    yield  # Application running\n\n    # Shutdown\n    print(\"Application shutting down...\")\n    await database.disconnect()\n\n# Use in build\napp = builder.build_app_with_lifespan(\n    title=\"My App\",\n    lifespan=lifespan\n)\n</code></pre>"},{"location":"features/hosting/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"features/hosting/#testing-with-builder","title":"Testing with Builder","text":"<pre><code>import pytest\nfrom neuroglia.hosting import WebApplicationBuilder\n\n@pytest.fixture\ndef test_app():\n    \"\"\"Create test application.\"\"\"\n    builder = WebApplicationBuilder()\n\n    # Use in-memory implementations\n    builder.services.add_scoped(IOrderRepository, InMemoryOrderRepository)\n\n    builder.add_controllers([\"api.controllers\"])\n\n    app = builder.build_app_with_lifespan(title=\"Test App\")\n    return app\n\nasync def test_create_order(test_app):\n    \"\"\"Test order creation endpoint.\"\"\"\n    from fastapi.testclient import TestClient\n\n    client = TestClient(test_app)\n    response = client.post(\"/api/orders\", json={\n        \"customer_id\": \"123\",\n        \"items\": [{\"pizza\": \"Margherita\", \"quantity\": 1}]\n    })\n\n    assert response.status_code == 201\n    assert \"order_id\" in response.json()\n</code></pre>"},{"location":"features/hosting/#common-mistakes","title":"\u26a0\ufe0f Common Mistakes","text":""},{"location":"features/hosting/#1-not-building-the-app","title":"1. Not Building the App","text":"<pre><code># \u274c WRONG: Forgot to build\nbuilder = WebApplicationBuilder()\nbuilder.add_controllers([\"api.controllers\"])\n# Missing: app = builder.build()\n\n# \u2705 RIGHT: Build before running\nbuilder = WebApplicationBuilder()\nbuilder.add_controllers([\"api.controllers\"])\napp = builder.build()\napp.run()\n</code></pre>"},{"location":"features/hosting/#2-registering-controllers-after-build","title":"2. Registering Controllers After Build","text":"<pre><code># \u274c WRONG: Adding controllers after build\nbuilder = WebApplicationBuilder()\napp = builder.build()\nbuilder.add_controllers([\"api.controllers\"])  # Too late!\n\n# \u2705 RIGHT: Register before build\nbuilder = WebApplicationBuilder()\nbuilder.add_controllers([\"api.controllers\"])\napp = builder.build()\n</code></pre>"},{"location":"features/hosting/#3-mixing-simple-and-advanced-features","title":"3. Mixing Simple and Advanced Features","text":"<pre><code># \u274c WRONG: Using advanced features without app_settings\nbuilder = WebApplicationBuilder()  # Simple mode\nbuilder.add_controllers([\"api.controllers\"], prefix=\"/api\")\nbuilder.add_controllers([\"admin.controllers\"], prefix=\"/admin\")\n# Advanced features may not work properly\n\n# \u2705 RIGHT: Use app_settings for advanced features\napp_settings = ApplicationSettings()\nbuilder = WebApplicationBuilder(app_settings)  # Advanced mode\nbuilder.add_controllers([\"api.controllers\"], prefix=\"/api\")\nbuilder.add_controllers([\"admin.controllers\"], prefix=\"/admin\")\n</code></pre>"},{"location":"features/hosting/#when-not-to-use","title":"\ud83d\udeab When NOT to Use","text":"<p>Skip Neuroglia hosting when:</p> <ol> <li>Serverless Functions: AWS Lambda, Azure Functions (stateless)</li> <li>Minimal APIs: Single endpoint, no DI needed</li> <li>Non-Web Applications: CLI tools, batch jobs</li> <li>Existing FastAPI App: Already have complex setup</li> </ol> <p>For these cases, use FastAPI directly or other appropriate tools.</p>"},{"location":"features/hosting/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ol> <li>WebApplicationBuilder: Central component for app configuration</li> <li>Two Modes: Simple (basic) and Advanced (production features)</li> <li>Auto-Discovery: Controllers automatically found and registered</li> <li>Lifecycle Management: Startup, running, graceful shutdown</li> <li>Background Services: HostedService for concurrent tasks</li> <li>Dependency Injection: Integrated ServiceCollection</li> </ol>"},{"location":"features/hosting/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Basic usage</li> <li>Tutorial Part 1 - Complete setup guide</li> <li>Dependency Injection - Service registration</li> <li>MVC Controllers - Building controllers</li> <li>Observability - Monitoring and tracing</li> </ul>"},{"location":"features/hosting/#api-reference","title":"\ud83d\udcda API Reference","text":""},{"location":"features/hosting/#webapplicationbuilder_1","title":"WebApplicationBuilder","text":"<pre><code>class WebApplicationBuilder:\n    def __init__(\n        self,\n        app_settings: Optional[Union[ApplicationSettings, ApplicationSettingsWithObservability]] = None\n    ):\n        \"\"\"Initialize builder with optional settings.\"\"\"\n\n    @property\n    def services(self) -&gt; ServiceCollection:\n        \"\"\"Get the service collection for DI registration.\"\"\"\n\n    @property\n    def app(self) -&gt; Optional[FastAPI]:\n        \"\"\"Get the FastAPI app instance (after build).\"\"\"\n\n    @property\n    def app_settings(self) -&gt; Optional[ApplicationSettings]:\n        \"\"\"Get the application settings.\"\"\"\n\n    def add_controllers(\n        self,\n        modules: List[str],\n        app: Optional[FastAPI] = None,\n        prefix: str = \"\"\n    ) -&gt; ServiceCollection:\n        \"\"\"Register controllers from specified modules.\"\"\"\n\n    def build(self, auto_mount_controllers: bool = True) -&gt; WebHostBase:\n        \"\"\"Build the host.\"\"\"\n\n    def build_app_with_lifespan(\n        self,\n        title: str = \"Neuroglia Application\",\n        version: str = \"1.0.0\",\n        description: str = \"\",\n        lifespan: Optional[Callable] = None\n    ) -&gt; FastAPI:\n        \"\"\"Build FastAPI app with lifecycle management.\"\"\"\n\n    def use_controllers(self):\n        \"\"\"Mount controllers on the application.\"\"\"\n</code></pre>"},{"location":"features/hosting/#hostedservice","title":"HostedService","text":"<pre><code>class HostedService(ABC):\n    \"\"\"Base class for background services.\"\"\"\n\n    @abstractmethod\n    async def start_async(self):\n        \"\"\"Called on application startup.\"\"\"\n\n    @abstractmethod\n    async def stop_async(self):\n        \"\"\"Called on application shutdown.\"\"\"\n</code></pre>"},{"location":"features/hosting/#applicationsettings","title":"ApplicationSettings","text":"<pre><code>class ApplicationSettings:\n    \"\"\"Base application configuration.\"\"\"\n\n    # Override with Pydantic Fields\n    app_name: str = \"My Application\"\n    environment: str = \"development\"\n    debug: bool = False\n</code></pre> <p>Next: Observability \u2192</p>"},{"location":"features/http-service-client/","title":"\ud83c\udf10 HTTP Service Client","text":"<p>The Neuroglia framework provides enterprise-grade HTTP client capabilities with advanced resilience patterns, enabling reliable communication with external services through circuit breakers, retry policies, and comprehensive request/response interception.</p>"},{"location":"features/http-service-client/#overview","title":"\ud83c\udfaf Overview","text":"<p>Modern microservices rely heavily on external service communication for payment processing, third-party APIs, and inter-service coordination. The framework's HTTP client implementation provides:</p> <ul> <li>Circuit Breaker Pattern: Protection against cascading failures</li> <li>Retry Policies: Configurable retry strategies with exponential backoff</li> <li>Request/Response Interception: Middleware for authentication, logging, and monitoring</li> <li>Connection Pooling: Optimized HTTP connection management</li> <li>Timeout Management: Configurable timeouts for different scenarios</li> <li>Request/Response Validation: Automatic data validation and transformation</li> </ul>"},{"location":"features/http-service-client/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>graph TB\n    subgraph \"\ud83c\udf55 Mario's Pizzeria Services\"\n        OrderService[Order Service]\n        PaymentService[Payment Service]\n        DeliveryService[Delivery Service]\n        NotificationService[Notification Service]\n    end\n\n    subgraph \"\ud83c\udf10 HTTP Service Client\"\n        HttpClient[HTTP Client Manager]\n        CircuitBreaker[Circuit Breaker]\n        RetryPolicy[Retry Policy]\n        Interceptors[Request/Response Interceptors]\n    end\n\n    subgraph \"\ud83d\udd0c External Services\"\n        PaymentGateway[Payment Gateway API]\n        DeliveryAPI[Delivery Tracking API]\n        EmailService[Email Service API]\n        SMSService[SMS Service API]\n    end\n\n    OrderService --&gt; HttpClient\n    PaymentService --&gt; HttpClient\n    DeliveryService --&gt; HttpClient\n    NotificationService --&gt; HttpClient\n\n    HttpClient --&gt; CircuitBreaker\n    HttpClient --&gt; RetryPolicy\n    HttpClient --&gt; Interceptors\n\n    CircuitBreaker --&gt; PaymentGateway\n    CircuitBreaker --&gt; DeliveryAPI\n    CircuitBreaker --&gt; EmailService\n    CircuitBreaker --&gt; SMSService\n\n    style HttpClient fill:#e3f2fd\n    style CircuitBreaker fill:#ffebee\n    style RetryPolicy fill:#e8f5e8\n    style Interceptors fill:#fff3e0</code></pre>"},{"location":"features/http-service-client/#basic-usage","title":"\ud83d\ude80 Basic Usage","text":""},{"location":"features/http-service-client/#service-registration","title":"Service Registration","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.http import HttpServiceClient, HttpClientConfig\n\ndef create_app():\n    builder = WebApplicationBuilder()\n\n    # Register HTTP service client\n    http_config = HttpClientConfig(\n        base_timeout=30.0,\n        connection_timeout=5.0,\n        max_connections=100,\n        max_connections_per_host=20,\n        enable_circuit_breaker=True,\n        enable_retry_policy=True\n    )\n\n    builder.services.add_http_service_client(http_config)\n\n    app = builder.build()\n    return app\n</code></pre>"},{"location":"features/http-service-client/#simple-http-operations","title":"Simple HTTP Operations","text":"<pre><code>from neuroglia.http import HttpServiceClient\nfrom neuroglia.dependency_injection import ServiceProviderBase\nfrom typing import Optional\n\nclass PaymentGatewayService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.http_client = service_provider.get_service(HttpServiceClient)\n        self.base_url = \"https://api.payment-gateway.com/v1\"\n        self.api_key = \"your_api_key_here\"\n\n    async def charge_customer(self, order_id: str, amount: float, currency: str = \"USD\") -&gt; dict:\n        \"\"\"Charge customer payment through external gateway.\"\"\"\n\n        payment_request = {\n            \"order_id\": order_id,\n            \"amount\": amount,\n            \"currency\": currency,\n            \"description\": f\"Mario's Pizzeria Order {order_id}\",\n            \"metadata\": {\n                \"restaurant\": \"marios_pizzeria\",\n                \"order_type\": \"online\"\n            }\n        }\n\n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\",\n            \"X-Idempotency-Key\": f\"order_{order_id}\"\n        }\n\n        try:\n            response = await self.http_client.post_async(\n                url=f\"{self.base_url}/charges\",\n                json=payment_request,\n                headers=headers,\n                timeout=15.0\n            )\n\n            if response.is_success:\n                print(f\"\ud83d\udcb3 Payment successful for order {order_id}: ${amount}\")\n                return response.json()\n            else:\n                print(f\"\u274c Payment failed for order {order_id}: {response.status_code}\")\n                raise PaymentProcessingError(f\"Payment failed: {response.text}\")\n\n        except Exception as e:\n            print(f\"\ud83d\udca5 Payment service error: {e}\")\n            raise PaymentServiceUnavailableError(f\"Cannot process payment: {e}\")\n\n    async def refund_payment(self, charge_id: str, amount: Optional[float] = None) -&gt; dict:\n        \"\"\"Process refund through payment gateway.\"\"\"\n\n        refund_request = {\n            \"charge_id\": charge_id,\n            \"reason\": \"customer_request\"\n        }\n\n        if amount:\n            refund_request[\"amount\"] = amount\n\n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n\n        response = await self.http_client.post_async(\n            url=f\"{self.base_url}/refunds\",\n            json=refund_request,\n            headers=headers\n        )\n\n        if response.is_success:\n            refund_data = response.json()\n            print(f\"\ud83d\udcb0 Refund processed: {refund_data['refund_id']}\")\n            return refund_data\n        else:\n            raise RefundProcessingError(f\"Refund failed: {response.text}\")\n</code></pre>"},{"location":"features/http-service-client/#circuit-breaker-pattern","title":"\ud83d\udd04 Circuit Breaker Pattern","text":""},{"location":"features/http-service-client/#resilient-external-service-integration","title":"Resilient External Service Integration","text":"<pre><code>from neuroglia.http import CircuitBreakerPolicy, CircuitBreakerState\n\nclass DeliveryTrackingService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.http_client = service_provider.get_service(HttpServiceClient)\n        self.base_url = \"https://api.delivery-service.com/v2\"\n\n        # Configure circuit breaker for delivery API\n        self.circuit_breaker = CircuitBreakerPolicy(\n            failure_threshold=5,        # Open after 5 failures\n            recovery_timeout=60,        # Try recovery after 60 seconds\n            success_threshold=3,        # Close after 3 successful calls\n            timeout=10.0               # Individual request timeout\n        )\n\n    @circuit_breaker.apply\n    async def create_delivery_request(self, order_id: str, delivery_address: dict) -&gt; dict:\n        \"\"\"Create delivery request with circuit breaker protection.\"\"\"\n\n        delivery_request = {\n            \"order_id\": order_id,\n            \"pickup_address\": {\n                \"street\": \"123 Pizza Street\",\n                \"city\": \"Pizza City\",\n                \"zip\": \"12345\"\n            },\n            \"delivery_address\": delivery_address,\n            \"priority\": \"standard\",\n            \"special_instructions\": \"Handle with care - hot pizza!\"\n        }\n\n        try:\n            response = await self.http_client.post_async(\n                url=f\"{self.base_url}/deliveries\",\n                json=delivery_request,\n                timeout=self.circuit_breaker.timeout\n            )\n\n            if response.is_success:\n                delivery_data = response.json()\n                print(f\"\ud83d\ude9a Delivery scheduled: {delivery_data['tracking_id']}\")\n                return delivery_data\n            else:\n                raise DeliveryServiceError(f\"Delivery creation failed: {response.status_code}\")\n\n        except Exception as e:\n            print(f\"\ud83d\udd34 Delivery service unavailable: {e}\")\n            # Circuit breaker will handle this failure\n            raise\n\n    async def get_delivery_status(self, tracking_id: str) -&gt; dict:\n        \"\"\"Get delivery status with fallback handling.\"\"\"\n\n        if self.circuit_breaker.state == CircuitBreakerState.OPEN:\n            # Circuit is open - use fallback\n            return await self.get_fallback_delivery_status(tracking_id)\n\n        try:\n            response = await self.http_client.get_async(\n                url=f\"{self.base_url}/deliveries/{tracking_id}\",\n                timeout=5.0\n            )\n\n            if response.is_success:\n                return response.json()\n            else:\n                return await self.get_fallback_delivery_status(tracking_id)\n\n        except Exception:\n            return await self.get_fallback_delivery_status(tracking_id)\n\n    async def get_fallback_delivery_status(self, tracking_id: str) -&gt; dict:\n        \"\"\"Fallback delivery status when service is unavailable.\"\"\"\n        print(f\"\ud83d\udccb Using fallback status for delivery {tracking_id}\")\n\n        return {\n            \"tracking_id\": tracking_id,\n            \"status\": \"in_transit\",\n            \"estimated_delivery\": \"Service temporarily unavailable\",\n            \"fallback\": True\n        }\n</code></pre>"},{"location":"features/http-service-client/#retry-policies","title":"\ud83d\udd04 Retry Policies","text":""},{"location":"features/http-service-client/#configurable-retry-strategies","title":"Configurable Retry Strategies","text":"<pre><code>from neuroglia.http import RetryPolicy, ExponentialBackoff, RetryCondition\n\nclass NotificationService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.http_client = service_provider.get_service(HttpServiceClient)\n\n        # Configure retry policy for notifications\n        self.retry_policy = RetryPolicy(\n            max_attempts=3,\n            backoff_strategy=ExponentialBackoff(\n                initial_delay=1.0,\n                max_delay=30.0,\n                backoff_factor=2.0\n            ),\n            retry_conditions=[\n                RetryCondition.on_timeout(),\n                RetryCondition.on_status_codes([429, 502, 503, 504]),\n                RetryCondition.on_exceptions([ConnectionError, TimeoutError])\n            ]\n        )\n\n    @retry_policy.apply\n    async def send_order_confirmation_email(self, customer_email: str, order_details: dict) -&gt; bool:\n        \"\"\"Send order confirmation email with retry policy.\"\"\"\n\n        email_request = {\n            \"to\": customer_email,\n            \"subject\": f\"\ud83c\udf55 Order Confirmation - #{order_details['order_id']}\",\n            \"template\": \"order_confirmation\",\n            \"variables\": {\n                \"customer_name\": order_details['customer_name'],\n                \"order_id\": order_details['order_id'],\n                \"items\": order_details['items'],\n                \"total_amount\": order_details['total_amount'],\n                \"estimated_delivery\": order_details['estimated_delivery']\n            }\n        }\n\n        response = await self.http_client.post_async(\n            url=\"https://api.email-service.com/v1/send\",\n            json=email_request,\n            headers={\n                \"Authorization\": f\"Bearer {self.get_email_api_key()}\",\n                \"Content-Type\": \"application/json\"\n            },\n            timeout=10.0\n        )\n\n        if response.is_success:\n            print(f\"\ud83d\udce7 Order confirmation sent to {customer_email}\")\n            return True\n        else:\n            error_msg = f\"Failed to send email: {response.status_code} - {response.text}\"\n            print(f\"\u274c {error_msg}\")\n            raise EmailDeliveryError(error_msg)\n\n    @retry_policy.apply\n    async def send_sms_notification(self, phone_number: str, message: str) -&gt; bool:\n        \"\"\"Send SMS notification with retry policy.\"\"\"\n\n        sms_request = {\n            \"to\": phone_number,\n            \"message\": message,\n            \"from\": \"Mario's Pizzeria\"\n        }\n\n        response = await self.http_client.post_async(\n            url=\"https://api.sms-service.com/v1/messages\",\n            json=sms_request,\n            headers={\n                \"Authorization\": f\"Bearer {self.get_sms_api_key()}\",\n                \"Content-Type\": \"application/json\"\n            }\n        )\n\n        if response.is_success:\n            print(f\"\ud83d\udcf1 SMS sent to {phone_number}\")\n            return True\n        else:\n            raise SMSDeliveryError(f\"SMS failed: {response.status_code}\")\n</code></pre>"},{"location":"features/http-service-client/#requestresponse-interception","title":"\ud83d\udd0d Request/Response Interception","text":""},{"location":"features/http-service-client/#middleware-for-cross-cutting-concerns","title":"Middleware for Cross-Cutting Concerns","text":"<pre><code>from neuroglia.http import RequestInterceptor, ResponseInterceptor, HttpContext\n\nclass AuthenticationInterceptor(RequestInterceptor):\n    \"\"\"Add authentication to all external service requests.\"\"\"\n\n    async def intercept_request(self, request: HttpRequest, context: HttpContext) -&gt; HttpRequest:\n        # Add API key based on service\n        if \"payment-gateway.com\" in request.url:\n            request.headers[\"Authorization\"] = f\"Bearer {self.get_payment_api_key()}\"\n        elif \"delivery-service.com\" in request.url:\n            request.headers[\"X-API-Key\"] = self.get_delivery_api_key()\n        elif \"email-service.com\" in request.url:\n            request.headers[\"Authorization\"] = f\"Bearer {self.get_email_api_key()}\"\n\n        # Add common headers\n        request.headers[\"User-Agent\"] = \"MariosPizzeria/1.0\"\n        request.headers[\"X-Request-ID\"] = context.correlation_id\n\n        return request\n\n    def get_payment_api_key(self) -&gt; str:\n        return \"payment_api_key_here\"\n\n    def get_delivery_api_key(self) -&gt; str:\n        return \"delivery_api_key_here\"\n\n    def get_email_api_key(self) -&gt; str:\n        return \"email_api_key_here\"\n\nclass LoggingInterceptor(RequestInterceptor, ResponseInterceptor):\n    \"\"\"Log all HTTP requests and responses.\"\"\"\n\n    async def intercept_request(self, request: HttpRequest, context: HttpContext) -&gt; HttpRequest:\n        print(f\"\ud83c\udf10 HTTP Request: {request.method} {request.url}\")\n        print(f\"\ud83d\udccb Headers: {dict(request.headers)}\")\n\n        if request.json:\n            print(f\"\ud83d\udcc4 Request Body: {request.json}\")\n\n        context.start_time = time.time()\n        return request\n\n    async def intercept_response(self, response: HttpResponse, context: HttpContext) -&gt; HttpResponse:\n        duration = time.time() - context.start_time\n\n        print(f\"\ud83d\udce8 HTTP Response: {response.status_code} ({duration:.2f}s)\")\n        print(f\"\ud83d\udcc4 Response Size: {len(response.content)} bytes\")\n\n        if not response.is_success:\n            print(f\"\u274c Error Response: {response.text}\")\n\n        return response\n\nclass RateLimitInterceptor(RequestInterceptor):\n    \"\"\"Handle rate limiting with backoff.\"\"\"\n\n    def __init__(self):\n        self.rate_limit_trackers = {}\n\n    async def intercept_request(self, request: HttpRequest, context: HttpContext) -&gt; HttpRequest:\n        service_key = self.extract_service_key(request.url)\n\n        # Check if we're rate limited\n        if self.is_rate_limited(service_key):\n            wait_time = self.get_rate_limit_wait_time(service_key)\n            print(f\"\u23f3 Rate limited for {service_key}, waiting {wait_time}s\")\n            await asyncio.sleep(wait_time)\n\n        return request\n\n    async def intercept_response(self, response: HttpResponse, context: HttpContext) -&gt; HttpResponse:\n        if response.status_code == 429:  # Too Many Requests\n            service_key = self.extract_service_key(context.request.url)\n            self.handle_rate_limit_response(service_key, response)\n\n        return response\n\n    def extract_service_key(self, url: str) -&gt; str:\n        \"\"\"Extract service identifier from URL.\"\"\"\n        if \"payment-gateway.com\" in url:\n            return \"payment_gateway\"\n        elif \"delivery-service.com\" in url:\n            return \"delivery_service\"\n        elif \"email-service.com\" in url:\n            return \"email_service\"\n        return \"unknown\"\n\n    def is_rate_limited(self, service_key: str) -&gt; bool:\n        \"\"\"Check if service is currently rate limited.\"\"\"\n        tracker = self.rate_limit_trackers.get(service_key)\n        if not tracker:\n            return False\n\n        return time.time() &lt; tracker[\"retry_after\"]\n\n    def handle_rate_limit_response(self, service_key: str, response: HttpResponse):\n        \"\"\"Handle rate limit response headers.\"\"\"\n        retry_after = response.headers.get(\"Retry-After\", \"60\")\n\n        self.rate_limit_trackers[service_key] = {\n            \"retry_after\": time.time() + int(retry_after),\n            \"limit_exceeded_at\": time.time()\n        }\n</code></pre>"},{"location":"features/http-service-client/#registering-interceptors","title":"Registering Interceptors","text":"<pre><code>def configure_http_interceptors(services: ServiceCollection):\n    \"\"\"Configure HTTP client interceptors.\"\"\"\n\n    # Register interceptors in order of execution\n    services.add_singleton(AuthenticationInterceptor)\n    services.add_singleton(LoggingInterceptor)\n    services.add_singleton(RateLimitInterceptor)\n\n    # Configure HTTP client with interceptors\n    http_config = HttpClientConfig(\n        request_interceptors=[\n            AuthenticationInterceptor,\n            RateLimitInterceptor,\n            LoggingInterceptor\n        ],\n        response_interceptors=[\n            LoggingInterceptor,\n            RateLimitInterceptor\n        ]\n    )\n\n    services.add_http_service_client(http_config)\n</code></pre>"},{"location":"features/http-service-client/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"features/http-service-client/#unit-testing-with-http-mocks","title":"Unit Testing with HTTP Mocks","text":"<pre><code>import pytest\nfrom unittest.mock import AsyncMock, Mock\nfrom neuroglia.http import HttpServiceClient, HttpResponse\n\nclass TestPaymentGatewayService:\n\n    @pytest.fixture\n    def mock_http_client(self):\n        client = Mock(spec=HttpServiceClient)\n        client.post_async = AsyncMock()\n        client.get_async = AsyncMock()\n        return client\n\n    @pytest.fixture\n    def payment_service(self, mock_http_client):\n        service_provider = Mock()\n        service_provider.get_service.return_value = mock_http_client\n        return PaymentGatewayService(service_provider)\n\n    @pytest.mark.asyncio\n    async def test_successful_payment(self, payment_service, mock_http_client):\n        \"\"\"Test successful payment processing.\"\"\"\n\n        # Mock successful response\n        mock_response = Mock(spec=HttpResponse)\n        mock_response.is_success = True\n        mock_response.json.return_value = {\n            \"charge_id\": \"ch_123456\",\n            \"status\": \"succeeded\",\n            \"amount\": 25.99\n        }\n        mock_http_client.post_async.return_value = mock_response\n\n        # Test payment\n        result = await payment_service.charge_customer(\"order_123\", 25.99)\n\n        # Verify request was made correctly\n        mock_http_client.post_async.assert_called_once()\n        call_args = mock_http_client.post_async.call_args\n\n        assert \"charges\" in call_args[1][\"url\"]\n        assert call_args[1][\"json\"][\"amount\"] == 25.99\n        assert call_args[1][\"json\"][\"order_id\"] == \"order_123\"\n\n        # Verify response\n        assert result[\"charge_id\"] == \"ch_123456\"\n        assert result[\"status\"] == \"succeeded\"\n\n    @pytest.mark.asyncio\n    async def test_payment_failure(self, payment_service, mock_http_client):\n        \"\"\"Test payment processing failure.\"\"\"\n\n        # Mock failed response\n        mock_response = Mock(spec=HttpResponse)\n        mock_response.is_success = False\n        mock_response.status_code = 402\n        mock_response.text = \"Insufficient funds\"\n        mock_http_client.post_async.return_value = mock_response\n\n        # Test payment failure\n        with pytest.raises(PaymentProcessingError) as exc_info:\n            await payment_service.charge_customer(\"order_123\", 25.99)\n\n        assert \"Payment failed\" in str(exc_info.value)\n\n    @pytest.mark.asyncio\n    async def test_service_unavailable(self, payment_service, mock_http_client):\n        \"\"\"Test handling of service unavailability.\"\"\"\n\n        # Mock connection error\n        mock_http_client.post_async.side_effect = ConnectionError(\"Service unavailable\")\n\n        # Test service unavailable handling\n        with pytest.raises(PaymentServiceUnavailableError) as exc_info:\n            await payment_service.charge_customer(\"order_123\", 25.99)\n\n        assert \"Cannot process payment\" in str(exc_info.value)\n</code></pre>"},{"location":"features/http-service-client/#integration-testing-with-test-servers","title":"Integration Testing with Test Servers","text":"<pre><code>@pytest.mark.integration\nclass TestHttpServiceIntegration:\n\n    @pytest.fixture\n    async def test_server(self):\n        \"\"\"Start test HTTP server for integration testing.\"\"\"\n        from aiohttp import web\n        from aiohttp.test_utils import TestServer\n\n        async def payment_handler(request):\n            data = await request.json()\n\n            if data.get(\"amount\", 0) &lt;= 0:\n                return web.json_response(\n                    {\"error\": \"Invalid amount\"},\n                    status=400\n                )\n\n            return web.json_response({\n                \"charge_id\": \"ch_test_123\",\n                \"status\": \"succeeded\",\n                \"amount\": data[\"amount\"]\n            })\n\n        async def rate_limit_handler(request):\n            return web.json_response(\n                {\"error\": \"Rate limit exceeded\"},\n                status=429,\n                headers={\"Retry-After\": \"5\"}\n            )\n\n        app = web.Application()\n        app.router.add_post(\"/charges\", payment_handler)\n        app.router.add_post(\"/rate-limited\", rate_limit_handler)\n\n        server = TestServer(app)\n        await server.start_server()\n        yield server\n        await server.close()\n\n    @pytest.fixture\n    def http_client(self):\n        config = HttpClientConfig(\n            base_timeout=5.0,\n            enable_circuit_breaker=True,\n            enable_retry_policy=True\n        )\n        return HttpServiceClient(config)\n\n    @pytest.mark.asyncio\n    async def test_end_to_end_payment(self, test_server, http_client):\n        \"\"\"Test end-to-end payment processing.\"\"\"\n\n        payment_data = {\n            \"order_id\": \"integration_test_order\",\n            \"amount\": 19.99,\n            \"currency\": \"USD\"\n        }\n\n        response = await http_client.post_async(\n            url=f\"{test_server.make_url('/charges')}\",\n            json=payment_data,\n            timeout=10.0\n        )\n\n        assert response.is_success\n        result = response.json()\n        assert result[\"status\"] == \"succeeded\"\n        assert result[\"amount\"] == 19.99\n\n    @pytest.mark.asyncio\n    async def test_circuit_breaker_behavior(self, test_server, http_client):\n        \"\"\"Test circuit breaker with failing service.\"\"\"\n\n        # Make multiple requests to trigger circuit breaker\n        for i in range(6):  # Trigger failure threshold\n            try:\n                await http_client.post_async(\n                    url=f\"{test_server.make_url('/rate-limited')}\",\n                    json={\"test\": \"data\"},\n                    timeout=1.0\n                )\n            except Exception:\n                pass  # Expected failures\n\n        # Circuit should now be open - next request should fail fast\n        start_time = time.time()\n\n        with pytest.raises(Exception):  # Circuit breaker should fail fast\n            await http_client.post_async(\n                url=f\"{test_server.make_url('/rate-limited')}\",\n                json={\"test\": \"data\"}\n            )\n\n        duration = time.time() - start_time\n        assert duration &lt; 0.1  # Should fail fast, not wait for timeout\n</code></pre>"},{"location":"features/http-service-client/#monitoring-and-observability","title":"\ud83d\udcca Monitoring and Observability","text":""},{"location":"features/http-service-client/#http-client-metrics","title":"HTTP Client Metrics","text":"<pre><code>from neuroglia.http import HttpMetrics, MetricsCollector\n\nclass HttpServiceMonitor:\n    def __init__(self, http_client: HttpServiceClient):\n        self.http_client = http_client\n        self.metrics = HttpMetrics()\n\n    async def track_request_metrics(self, service_name: str, endpoint: str,\n                                  status_code: int, duration: float):\n        \"\"\"Track HTTP request metrics.\"\"\"\n\n        # Increment counters\n        await self.metrics.increment_counter(f\"http_requests_total\", {\n            \"service\": service_name,\n            \"endpoint\": endpoint,\n            \"status_code\": status_code\n        })\n\n        # Track response times\n        await self.metrics.observe_histogram(f\"http_request_duration_seconds\", duration, {\n            \"service\": service_name,\n            \"endpoint\": endpoint\n        })\n\n        # Track error rates\n        if status_code &gt;= 400:\n            await self.metrics.increment_counter(f\"http_errors_total\", {\n                \"service\": service_name,\n                \"status_code\": status_code\n            })\n\n    async def get_service_health_summary(self) -&gt; dict:\n        \"\"\"Get HTTP service health summary.\"\"\"\n\n        total_requests = await self.metrics.get_counter(\"http_requests_total\")\n        total_errors = await self.metrics.get_counter(\"http_errors_total\")\n        avg_duration = await self.metrics.get_gauge(\"http_request_duration_seconds\")\n\n        error_rate = (total_errors / total_requests) if total_requests &gt; 0 else 0\n\n        return {\n            \"total_requests\": total_requests,\n            \"total_errors\": total_errors,\n            \"error_rate\": error_rate,\n            \"average_response_time\": avg_duration,\n            \"circuit_breaker_states\": await self.get_circuit_breaker_states()\n        }\n\n    async def get_circuit_breaker_states(self) -&gt; dict:\n        \"\"\"Get current circuit breaker states for all services.\"\"\"\n        return {\n            \"payment_gateway\": \"closed\",\n            \"delivery_service\": \"half_open\",\n            \"email_service\": \"closed\",\n            \"sms_service\": \"open\"\n        }\n</code></pre>"},{"location":"features/http-service-client/#advanced-configuration","title":"\ud83d\udd27 Advanced Configuration","text":""},{"location":"features/http-service-client/#connection-pool-and-performance-tuning","title":"Connection Pool and Performance Tuning","text":"<pre><code>from neuroglia.http import HttpClientConfig, ConnectionPoolConfig\n\ndef create_optimized_http_config():\n    connection_config = ConnectionPoolConfig(\n        # Connection limits\n        max_connections=200,\n        max_connections_per_host=50,\n\n        # Timeouts\n        connection_timeout=5.0,\n        request_timeout=30.0,\n        pool_timeout=10.0,\n\n        # Keep-alive settings\n        keep_alive_timeout=75.0,\n        keep_alive_max_requests=1000,\n\n        # SSL/TLS settings\n        ssl_verify=True,\n        ssl_cert_file=None,\n        ssl_key_file=None,\n\n        # Compression\n        enable_compression=True,\n        compression_threshold=1024\n    )\n\n    http_config = HttpClientConfig(\n        connection_pool=connection_config,\n\n        # Default timeouts\n        base_timeout=30.0,\n        connection_timeout=5.0,\n\n        # Resilience patterns\n        enable_circuit_breaker=True,\n        circuit_breaker_config={\n            \"failure_threshold\": 5,\n            \"recovery_timeout\": 60,\n            \"success_threshold\": 3\n        },\n\n        enable_retry_policy=True,\n        retry_policy_config={\n            \"max_attempts\": 3,\n            \"backoff_factor\": 2.0,\n            \"max_delay\": 60.0\n        },\n\n        # Request/Response settings\n        max_response_size=10 * 1024 * 1024,  # 10MB\n        enable_request_compression=True,\n        enable_response_decompression=True,\n\n        # Security\n        allowed_redirect_count=3,\n        trust_env_proxy_settings=True\n    )\n\n    return http_config\n</code></pre>"},{"location":"features/http-service-client/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\u23f0 Background Task Scheduling - Scheduling external API calls</li> <li>\u26a1 Redis Cache Repository - Caching API responses</li> <li>\ud83d\udd27 Dependency Injection - Service registration patterns</li> <li>\ud83d\udcca Enhanced Model Validation - Request/response validation</li> <li>\ud83d\udce8 Event Sourcing - Event-driven external service integration</li> </ul> <p>The HTTP Service Client provides enterprise-grade capabilities for reliable external service communication. Through circuit breakers, retry policies, and comprehensive interception, Mario's Pizzeria can confidently integrate with payment gateways, delivery services, and notification providers while maintaining system resilience and performance.</p>"},{"location":"features/mermaid-diagrams/","title":"\ud83d\udcca Mermaid Diagrams in Documentation","text":"<p>The Neuroglia Python Framework documentation supports Mermaid diagrams for creating visual representations of architecture, workflows, and system interactions.</p>"},{"location":"features/mermaid-diagrams/#overview","title":"\ud83c\udfaf Overview","text":"<p>Mermaid is a powerful diagramming tool that allows you to create diagrams using simple text-based syntax. Our documentation site automatically renders Mermaid diagrams when you include them in markdown files.</p>"},{"location":"features/mermaid-diagrams/#supported-diagram-types","title":"\ud83c\udfd7\ufe0f Supported Diagram Types","text":""},{"location":"features/mermaid-diagrams/#flowcharts","title":"Flowcharts","text":"<p>Perfect for representing decision flows, process flows, and system workflows:</p> <pre><code>graph TD\n    A[User Request] --&gt; B{Authentication}\n    B --&gt;|Valid| C[Route to Controller]\n    B --&gt;|Invalid| D[Return 401]\n    C --&gt; E[Execute Handler]\n    E --&gt; F[Return Response]\n    D --&gt; G[End]\n    F --&gt; G</code></pre>"},{"location":"features/mermaid-diagrams/#sequence-diagrams","title":"Sequence Diagrams","text":"<p>Ideal for showing interaction between components over time:</p> <pre><code>sequenceDiagram\n    participant C as Controller\n    participant M as Mediator\n    participant H as Handler\n    participant R as Repository\n    participant D as Database\n\n    C-&gt;&gt;M: Send Command\n    M-&gt;&gt;H: Route to Handler\n    H-&gt;&gt;R: Query/Save Data\n    R-&gt;&gt;D: Execute SQL\n    D--&gt;&gt;R: Return Result\n    R--&gt;&gt;H: Domain Objects\n    H--&gt;&gt;M: Operation Result\n    M--&gt;&gt;C: Response</code></pre>"},{"location":"features/mermaid-diagrams/#class-diagrams","title":"Class Diagrams","text":"<p>Great for documenting domain models and relationships:</p> <pre><code>classDiagram\n    class Controller {\n        +ServiceProvider service_provider\n        +Mediator mediator\n        +Mapper mapper\n        +process(result) Response\n    }\n\n    class CommandHandler {\n        &lt;&lt;abstract&gt;&gt;\n        +handle_async(command) OperationResult\n    }\n\n    class Entity {\n        +str id\n        +datetime created_at\n        +raise_event(event)\n        +get_uncommitted_events()\n    }\n\n    class Repository {\n        &lt;&lt;interface&gt;&gt;\n        +save_async(entity)\n        +get_by_id_async(id)\n        +delete_async(id)\n    }\n\n    Controller --&gt; CommandHandler : uses\n    CommandHandler --&gt; Entity : manipulates\n    CommandHandler --&gt; Repository : persists through</code></pre>"},{"location":"features/mermaid-diagrams/#architecture-diagrams","title":"Architecture Diagrams","text":"<p>Perfect for system overview and component relationships:</p> <pre><code>graph TB\n    subgraph \"\ud83c\udf10 API Layer\"\n        A[Controllers]\n        B[DTOs]\n        C[Middleware]\n    end\n\n    subgraph \"\ud83d\udcbc Application Layer\"\n        D[Commands/Queries]\n        E[Handlers]\n        F[Services]\n        G[Mediator]\n    end\n\n    subgraph \"\ud83c\udfdb\ufe0f Domain Layer\"\n        H[Entities]\n        I[Value Objects]\n        J[Domain Events]\n        K[Business Rules]\n    end\n\n    subgraph \"\ud83d\udd0c Integration Layer\"\n        L[Repositories]\n        M[External APIs]\n        N[Database]\n        O[Event Bus]\n    end\n\n    A --&gt; G\n    G --&gt; E\n    E --&gt; H\n    E --&gt; L\n    L --&gt; N\n    E --&gt; O\n\n    style A fill:#e1f5fe\n    style G fill:#f3e5f5\n    style H fill:#e8f5e8\n    style L fill:#fff3e0</code></pre>"},{"location":"features/mermaid-diagrams/#state-diagrams","title":"State Diagrams","text":"<p>Useful for modeling entity lifecycle and business processes:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; Draft\n    Draft --&gt; Submitted : submit()\n    Submitted --&gt; Approved : approve()\n    Submitted --&gt; Rejected : reject()\n    Rejected --&gt; Draft : revise()\n    Approved --&gt; Published : publish()\n    Published --&gt; Archived : archive()\n    Archived --&gt; [*]\n\n    state Submitted {\n        [*] --&gt; PendingReview\n        PendingReview --&gt; InReview : assign_reviewer()\n        InReview --&gt; ReviewComplete : complete_review()\n    }</code></pre>"},{"location":"features/mermaid-diagrams/#usage-in-documentation","title":"\ud83d\ude80 Usage in Documentation","text":""},{"location":"features/mermaid-diagrams/#basic-syntax","title":"Basic Syntax","text":"<p>To include a Mermaid diagram in your documentation:</p> <pre><code>```mermaid\ngraph TD\n    A[Start] --&gt; B[Process]\n    B --&gt; C[End]\n```\n</code></pre>"},{"location":"features/mermaid-diagrams/#best-practices","title":"Best Practices","text":"<ol> <li>Use Descriptive Labels: Make node labels clear and meaningful</li> <li>Consistent Styling: Use subgraphs for logical grouping</li> <li>Appropriate Diagram Types: Choose the right diagram for your content</li> <li>Keep It Simple: Don't overcomplicate diagrams</li> <li>Use Colors Wisely: Leverage styling for emphasis</li> </ol>"},{"location":"features/mermaid-diagrams/#advanced-styling","title":"Advanced Styling","text":"<p>You can add custom styling to your diagrams:</p> <pre><code>graph TD\n    A[API Request] --&gt; B[Authentication]\n    B --&gt; C[Authorization]\n    C --&gt; D[Business Logic]\n    D --&gt; E[Data Access]\n    E --&gt; F[Response]\n\n    classDef apiStyle fill:#e3f2fd,stroke:#1976d2,stroke-width:2px\n    classDef processStyle fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\n    classDef dataStyle fill:#e8f5e8,stroke:#388e3c,stroke-width:2px\n\n    class A,F apiStyle\n    class B,C,D processStyle\n    class E dataStyle</code></pre>"},{"location":"features/mermaid-diagrams/#configuration","title":"\ud83d\udd27 Configuration","text":"<p>The documentation site is configured with:</p> <ul> <li>Theme: Auto (follows system dark/light mode)</li> <li>Primary Color: Blue (#1976d2) matching Material theme</li> <li>Auto-refresh: Diagrams update automatically during development</li> <li>High DPI: Support for crisp diagrams on retina displays</li> </ul>"},{"location":"features/mermaid-diagrams/#documentation-standards","title":"\ud83d\udcdd Documentation Standards","text":"<p>When adding Mermaid diagrams to documentation:</p> <ol> <li>Always include a text description before the diagram</li> <li>Use consistent terminology across all diagrams</li> <li>Reference framework concepts (Controllers, Handlers, etc.)</li> <li>Include diagrams in relevant sections of feature documentation</li> <li>Test rendering locally before committing</li> </ol>"},{"location":"features/mermaid-diagrams/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>CQRS &amp; Mediation</li> <li>Dependency Injection</li> <li>Sample Applications</li> </ul>"},{"location":"features/mermaid-diagrams/#external-resources","title":"\ud83d\udcda External Resources","text":"<ul> <li>Mermaid Documentation</li> <li>Mermaid Live Editor</li> <li>MkDocs Material</li> </ul>"},{"location":"features/mvc-controllers/","title":"\ud83d\udd0c MVC Controllers","text":"<p>Neuroglia's MVC system provides powerful class-based API development using Mario's Pizzeria as an example, demonstrating real-world controller patterns with automatic discovery, dependency injection, and comprehensive API design.</p>"},{"location":"features/mvc-controllers/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>Pizza Order Management: OrdersController for handling customer orders</li> <li>Menu Administration: MenuController for pizza and topping management</li> <li>Kitchen Operations: KitchenController for order preparation workflow</li> <li>Authentication &amp; Authorization: OAuth integration for staff and customer access</li> <li>Error Handling: Comprehensive error responses and validation</li> <li>API Documentation: Automatic OpenAPI generation with pizzeria examples</li> </ul>"},{"location":"features/mvc-controllers/#controller-foundation","title":"\ud83c\udfd7\ufe0f Controller Foundation","text":""},{"location":"features/mvc-controllers/#pizza-order-controller","title":"Pizza Order Controller","text":"<p>The main controller for customer interactions at Mario's Pizzeria:</p> <pre><code>from neuroglia.mvc.controller_base import ControllerBase\nfrom neuroglia.dependency_injection.service_provider import ServiceProviderBase\nfrom neuroglia.mapping.mapper import Mapper\nfrom neuroglia.mediation.mediator import Mediator\nfrom classy_fastapi.decorators import get, post, put, delete\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import HTTPBearer\nfrom typing import List, Optional\nfrom datetime import date\n\nclass OrdersController(ControllerBase):\n    \"\"\"Controller for managing pizza orders at Mario's Pizzeria\"\"\"\n\n    def __init__(self,\n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n        self.security = HTTPBearer(auto_error=False)\n\n    @get(\"/\",\n         response_model=List[OrderDto],\n         summary=\"Get customer orders\",\n         description=\"Retrieve orders for authenticated customer\")\n    async def get_my_orders(self,\n                            token: str = Depends(HTTPBearer()),\n                            limit: int = 10) -&gt; List[OrderDto]:\n        \"\"\"Get orders for authenticated customer\"\"\"\n        try:\n            # Validate customer token and get customer info\n            customer_info = await self._validate_customer_token(token.credentials)\n\n            # Query customer's orders\n            query = GetOrdersByCustomerQuery(\n                customer_phone=customer_info.phone,\n                limit=limit\n            )\n            result = await self.mediator.execute_async(query)\n\n            return self.process(result)\n\n        except Exception as e:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid authentication token\"\n            )\n\n    @get(\"/{order_id}\",\n         response_model=OrderDto,\n         summary=\"Get specific order\",\n         description=\"Get details of a specific pizza order\")\n    async def get_order(self,\n                        order_id: str,\n                        token: str = Depends(HTTPBearer())) -&gt; OrderDto:\n        \"\"\"Get specific order details\"\"\"\n        # Validate customer access to this order\n        customer_info = await self._validate_customer_token(token.credentials)\n\n        query = GetOrderByIdQuery(\n            order_id=order_id,\n            customer_phone=customer_info.phone  # Ensure customer owns order\n        )\n        result = await self.mediator.execute_async(query)\n\n        return self.process(result)\n\n    @post(\"/\",\n          response_model=OrderDto,\n          status_code=201,\n          summary=\"Place pizza order\",\n          description=\"Place a new pizza order with customer details and pizza selection\")\n    async def place_order(self,\n                          order_request: PlaceOrderDto,\n                          token: Optional[str] = Depends(HTTPBearer(auto_error=False))) -&gt; OrderDto:\n        \"\"\"Place a new pizza order\"\"\"\n        try:\n            # If token provided, use customer info; otherwise use order details\n            customer_info = None\n            if token:\n                customer_info = await self._validate_customer_token(token.credentials)\n\n            # Create place order command\n            command = PlaceOrderCommand(\n                customer_name=customer_info.name if customer_info else order_request.customer_name,\n                customer_phone=customer_info.phone if customer_info else order_request.customer_phone,\n                customer_address=order_request.customer_address,\n                pizzas=order_request.pizzas,\n                payment_method=order_request.payment_method,\n                special_instructions=order_request.special_instructions\n            )\n\n            result = await self.mediator.execute_async(command)\n            return self.process(result)\n\n        except ValidationError as e:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=f\"Invalid order data: {str(e)}\"\n            )\n        except Exception as e:\n            raise HTTPException(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                detail=\"Failed to place order. Please try again.\"\n            )\n\n    @put(\"/{order_id}/cancel\",\n         response_model=OrderDto,\n         summary=\"Cancel order\",\n         description=\"Cancel a pizza order if it hasn't started preparation\")\n    async def cancel_order(self,\n                           order_id: str,\n                           cancellation_request: CancelOrderDto,\n                           token: str = Depends(HTTPBearer())) -&gt; OrderDto:\n        \"\"\"Cancel an existing order\"\"\"\n        customer_info = await self._validate_customer_token(token.credentials)\n\n        command = CancelOrderCommand(\n            order_id=order_id,\n            customer_phone=customer_info.phone,\n            cancellation_reason=cancellation_request.reason\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @get(\"/{order_id}/status\",\n         response_model=OrderStatusDto,\n         summary=\"Get order status\",\n         description=\"Get current status and estimated ready time for order\")\n    async def get_order_status(self,\n                               order_id: str,\n                               token: str = Depends(HTTPBearer())) -&gt; OrderStatusDto:\n        \"\"\"Get order status and tracking information\"\"\"\n        customer_info = await self._validate_customer_token(token.credentials)\n\n        query = GetOrderStatusQuery(\n            order_id=order_id,\n            customer_phone=customer_info.phone\n        )\n\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    async def _validate_customer_token(self, token: str) -&gt; CustomerInfo:\n        \"\"\"Validate customer authentication token\"\"\"\n        # In production, this would validate JWT token\n        # For demo purposes, we'll use a simple validation\n        query = ValidateCustomerTokenQuery(token=token)\n        result = await self.mediator.execute_async(query)\n\n        if not result.is_success:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid or expired token\"\n            )\n\n        return result.data\n</code></pre>"},{"location":"features/mvc-controllers/#menu-management-controller","title":"Menu Management Controller","text":"<pre><code>class MenuController(ControllerBase):\n    \"\"\"Controller for managing Mario's Pizzeria menu\"\"\"\n\n    def __init__(self,\n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n    @get(\"/pizzas\",\n         response_model=List[PizzaDto],\n         summary=\"Get pizza menu\",\n         description=\"Get all available pizzas organized by category\")\n    async def get_menu(self,\n                       category: Optional[str] = Query(None, description=\"Filter by pizza category\"),\n                       available_only: bool = Query(True, description=\"Show only available pizzas\")) -&gt; List[PizzaDto]:\n        \"\"\"Get pizza menu with optional filtering\"\"\"\n        query = GetMenuQuery(\n            category=category,\n            available_only=available_only\n        )\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/pizzas/{pizza_id}\",\n         response_model=PizzaDto,\n         summary=\"Get pizza details\",\n         description=\"Get detailed information about a specific pizza\")\n    async def get_pizza(self, pizza_id: str) -&gt; PizzaDto:\n        \"\"\"Get specific pizza details\"\"\"\n        query = GetPizzaByIdQuery(pizza_id=pizza_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/categories\",\n         response_model=List[str],\n         summary=\"Get pizza categories\",\n         description=\"Get all available pizza categories\")\n    async def get_categories(self) -&gt; List[str]:\n        \"\"\"Get all pizza categories\"\"\"\n        query = GetPizzaCategoriesQuery()\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/toppings\",\n         response_model=List[ToppingDto],\n         summary=\"Get available toppings\",\n         description=\"Get all available pizza toppings with prices\")\n    async def get_toppings(self,\n                           vegetarian_only: bool = Query(False, description=\"Show only vegetarian toppings\")) -&gt; List[ToppingDto]:\n        \"\"\"Get available toppings\"\"\"\n        query = GetToppingsQuery(vegetarian_only=vegetarian_only)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    # Admin endpoints (require staff authentication)\n    @post(\"/pizzas\",\n          response_model=PizzaDto,\n          status_code=201,\n          summary=\"Add new pizza (Staff Only)\",\n          description=\"Add a new pizza to the menu\")\n    async def add_pizza(self,\n                        pizza_request: CreatePizzaDto,\n                        staff_token: str = Depends(HTTPBearer())) -&gt; PizzaDto:\n        \"\"\"Add new pizza to menu (staff only)\"\"\"\n        await self._validate_staff_token(staff_token.credentials, required_role=\"manager\")\n\n        command = CreatePizzaCommand(\n            name=pizza_request.name,\n            description=pizza_request.description,\n            category=pizza_request.category,\n            base_price=pizza_request.base_price,\n            available_toppings=pizza_request.available_toppings,\n            preparation_time_minutes=pizza_request.preparation_time_minutes,\n            is_seasonal=pizza_request.is_seasonal\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @put(\"/pizzas/{pizza_id}/availability\",\n         response_model=PizzaDto,\n         summary=\"Update pizza availability (Staff Only)\",\n         description=\"Mark pizza as available or sold out\")\n    async def update_pizza_availability(self,\n                                        pizza_id: str,\n                                        availability_request: UpdateAvailabilityDto,\n                                        staff_token: str = Depends(HTTPBearer())) -&gt; PizzaDto:\n        \"\"\"Update pizza availability\"\"\"\n        await self._validate_staff_token(staff_token.credentials, required_role=\"staff\")\n\n        command = UpdatePizzaAvailabilityCommand(\n            pizza_id=pizza_id,\n            is_available=availability_request.is_available,\n            reason=availability_request.reason\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#kitchen-operations-controller","title":"Kitchen Operations Controller","text":"<pre><code>class KitchenController(ControllerBase):\n    \"\"\"Controller for kitchen operations and order management\"\"\"\n\n    def __init__(self,\n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n    @get(\"/queue\",\n         response_model=List[KitchenOrderDto],\n         summary=\"Get kitchen queue\",\n         description=\"Get orders in kitchen queue ordered by priority\")\n    async def get_kitchen_queue(self,\n                                staff_token: str = Depends(HTTPBearer())) -&gt; List[KitchenOrderDto]:\n        \"\"\"Get orders in kitchen preparation queue\"\"\"\n        await self._validate_staff_token(staff_token.credentials, required_role=\"kitchen\")\n\n        query = GetKitchenQueueQuery(\n            statuses=[\"received\", \"preparing\", \"cooking\"]\n        )\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @put(\"/orders/{order_id}/status\",\n         response_model=OrderDto,\n         summary=\"Update order status\",\n         description=\"Update order status in kitchen workflow\")\n    async def update_order_status(self,\n                                  order_id: str,\n                                  status_update: UpdateOrderStatusDto,\n                                  staff_token: str = Depends(HTTPBearer())) -&gt; OrderDto:\n        \"\"\"Update order status (kitchen staff only)\"\"\"\n        staff_info = await self._validate_staff_token(staff_token.credentials, required_role=\"kitchen\")\n\n        command = UpdateOrderStatusCommand(\n            order_id=order_id,\n            new_status=status_update.status,\n            updated_by=staff_info.staff_id,\n            notes=status_update.notes,\n            estimated_ready_time=status_update.estimated_ready_time\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @post(\"/orders/{order_id}/pizzas/{pizza_index}/start\",\n          response_model=OrderDto,\n          summary=\"Start pizza preparation\",\n          description=\"Mark pizza as started in preparation\")\n    async def start_pizza(self,\n                          order_id: str,\n                          pizza_index: int,\n                          staff_token: str = Depends(HTTPBearer())) -&gt; OrderDto:\n        \"\"\"Start pizza preparation\"\"\"\n        staff_info = await self._validate_staff_token(staff_token.credentials, required_role=\"kitchen\")\n\n        command = StartPizzaPreparationCommand(\n            order_id=order_id,\n            pizza_index=pizza_index,\n            chef_id=staff_info.staff_id\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @post(\"/orders/{order_id}/pizzas/{pizza_index}/complete\",\n          response_model=OrderDto,\n          summary=\"Complete pizza preparation\",\n          description=\"Mark pizza as completed\")\n    async def complete_pizza(self,\n                             order_id: str,\n                             pizza_index: int,\n                             completion_request: CompletePizzaDto,\n                             staff_token: str = Depends(HTTPBearer())) -&gt; OrderDto:\n        \"\"\"Complete pizza preparation\"\"\"\n        staff_info = await self._validate_staff_token(staff_token.credentials, required_role=\"kitchen\")\n\n        command = CompletePizzaPreparationCommand(\n            order_id=order_id,\n            pizza_index=pizza_index,\n            chef_id=staff_info.staff_id,\n            quality_notes=completion_request.quality_notes\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @get(\"/performance\",\n         response_model=KitchenPerformanceDto,\n         summary=\"Get kitchen performance metrics\",\n         description=\"Get kitchen performance analytics\")\n    async def get_performance_metrics(self,\n                                      start_date: date = Query(description=\"Start date for metrics\"),\n                                      end_date: date = Query(description=\"End date for metrics\"),\n                                      staff_token: str = Depends(HTTPBearer())) -&gt; KitchenPerformanceDto:\n        \"\"\"Get kitchen performance metrics\"\"\"\n        await self._validate_staff_token(staff_token.credentials, required_role=\"manager\")\n\n        query = GetKitchenPerformanceQuery(\n            start_date=start_date,\n            end_date=end_date\n        )\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    async def _validate_staff_token(self, token: str, required_role: str) -&gt; StaffInfo:\n        \"\"\"Validate staff authentication and role\"\"\"\n        query = ValidateStaffTokenQuery(\n            token=token,\n            required_role=required_role\n        )\n        result = await self.mediator.execute_async(query)\n\n        if not result.is_success:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=f\"Insufficient permissions. Required role: {required_role}\"\n            )\n\n        return result.data\n</code></pre> <pre><code>class ReportsController(ControllerBase):\n    \"\"\"Controller for pizzeria analytics and reporting\"\"\"\n\n    @get(\"/orders\",\n         response_model=List[OrderReportDto],\n         summary=\"Get order reports\",\n         description=\"Get filtered order data for reporting\")\n    async def get_order_reports(self,\n                                start_date: date = Query(description=\"Report start date\"),\n                                end_date: date = Query(description=\"Report end date\"),\n                                customer_phone: Optional[str] = Query(None, description=\"Filter by customer\"),\n                                status: Optional[str] = Query(None, description=\"Filter by order status\"),\n                                min_amount: Optional[float] = Query(None, ge=0, description=\"Minimum order amount\"),\n                                max_amount: Optional[float] = Query(None, ge=0, description=\"Maximum order amount\"),\n                                limit: int = Query(100, ge=1, le=1000, description=\"Maximum results to return\"),\n                                offset: int = Query(0, ge=0, description=\"Number of results to skip\"),\n                                staff_token: str = Depends(HTTPBearer())) -&gt; List[OrderReportDto]:\n        \"\"\"Get order reports with advanced filtering\"\"\"\n        await self._validate_staff_token(staff_token.credentials, required_role=\"manager\")\n\n        query = GetOrderReportsQuery(\n            start_date=start_date,\n            end_date=end_date,\n            customer_phone=customer_phone,\n            status=status,\n            min_amount=min_amount,\n            max_amount=max_amount,\n            limit=limit,\n            offset=offset\n        )\n\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/revenue\",\n         response_model=RevenueReportDto,\n         summary=\"Get revenue analytics\",\n         description=\"Get revenue breakdown and analytics\")\n    async def get_revenue_report(self,\n                                 period: str = Query(\"daily\", regex=\"^(daily|weekly|monthly)$\"),\n                                 start_date: date = Query(description=\"Analysis start date\"),\n                                 end_date: date = Query(description=\"Analysis end date\"),\n                                 staff_token: str = Depends(HTTPBearer())) -&gt; RevenueReportDto:\n        \"\"\"Get revenue analytics by period\"\"\"\n        await self._validate_staff_token(staff_token.credentials, required_role=\"manager\")\n\n        query = GetRevenueAnalyticsQuery(\n            period=period,\n            start_date=start_date,\n            end_date=end_date\n        )\n\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#request-validation-and-dtos","title":"Request Validation and DTOs","text":"<p>Comprehensive validation for pizzeria data:</p> <pre><code>\"\"\"Get users with filtering and pagination\"\"\"\n\n        query = GetUsersQuery(\n            department=department,\n            active_only=active_only,\n            page=page,\n            page_size=page_size\n        )\n\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#request-body-validation","title":"Request Body Validation","text":"<p>Use Pydantic models for request validation:</p> <pre><code>from pydantic import BaseModel, Field, EmailStr\nfrom typing import Optional\n\nclass CreateUserDto(BaseModel):\n    email: EmailStr = Field(..., description=\"User's email address\")\n    first_name: str = Field(..., min_length=1, max_length=50, description=\"First name\")\n    last_name: str = Field(..., min_length=1, max_length=50, description=\"Last name\")\n    department: Optional[str] = Field(None, max_length=100, description=\"Department\")\n\n    class Config:\n        schema_extra = {\n            \"example\": {\n                \"email\": \"john.doe@company.com\",\n                \"first_name\": \"John\",\n                \"last_name\": \"Doe\",\n                \"department\": \"Engineering\"\n            }\n        }\n\nclass UsersController(ControllerBase):\n\n    @post(\"/\", response_model=UserDto, status_code=status.HTTP_201_CREATED)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        \"\"\"Create a new user\"\"\"\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#file-uploads","title":"File Uploads","text":"<p>Handle file uploads:</p> <pre><code>from fastapi import UploadFile, File\n\nclass UsersController(ControllerBase):\n\n    @post(\"/{user_id}/avatar\", response_model=UserDto)\n    async def upload_avatar(self,\n                           user_id: str,\n                           file: UploadFile = File(..., description=\"Avatar image\")) -&gt; UserDto:\n        \"\"\"Upload user avatar\"\"\"\n\n        # Validate file type\n        if not file.content_type.startswith('image/'):\n            return self.bad_request(\"File must be an image\")\n\n        # Create command\n        command = UploadUserAvatarCommand(\n            user_id=user_id,\n            file_name=file.filename,\n            file_content=await file.read(),\n            content_type=file.content_type\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#response-headers","title":"Response Headers","text":"<p>Set custom response headers:</p> <pre><code>from fastapi import Response\n\nclass UsersController(ControllerBase):\n\n    @get(\"/{user_id}/export\", response_class=Response)\n    async def export_user_data(self, user_id: str, response: Response):\n        \"\"\"Export user data as CSV\"\"\"\n\n        query = ExportUserDataQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n\n        if not result.is_success:\n            return self.process(result)\n\n        # Set CSV headers\n        response.headers[\"Content-Type\"] = \"text/csv\"\n        response.headers[\"Content-Disposition\"] = f\"attachment; filename=user_{user_id}.csv\"\n\n        return result.data\n</code></pre>"},{"location":"features/mvc-controllers/#controller-configuration","title":"\ud83c\udfaa Controller Configuration","text":""},{"location":"features/mvc-controllers/#custom-routing","title":"Custom Routing","text":"<p>Customize controller routing:</p> <pre><code>class UsersController(ControllerBase):\n    def __init__(self, service_provider, mapper, mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n        # Custom prefix and tags\n        self.router.prefix = \"/users\"\n        self.router.tags = [\"User Management\"]\n\n        # Add custom middleware to this controller\n        self.router.middleware(\"http\")(self.auth_middleware)\n\n    async def auth_middleware(self, request, call_next):\n        \"\"\"Custom authentication middleware for this controller\"\"\"\n        # Authentication logic\n        response = await call_next(request)\n        return response\n</code></pre>"},{"location":"features/mvc-controllers/#nested-controllers","title":"Nested Controllers","text":"<p>Create hierarchical resource structures:</p> <pre><code>class UserAccountsController(ControllerBase):\n    \"\"\"Handles user account operations\"\"\"\n\n    def __init__(self, service_provider, mapper, mediator):\n        super().__init__(service_provider, mapper, mediator)\n        self.router.prefix = \"/users/{user_id}/accounts\"\n\n    @get(\"/\", response_model=List[AccountDto])\n    async def get_user_accounts(self, user_id: str) -&gt; List[AccountDto]:\n        \"\"\"Get all accounts for a user\"\"\"\n        query = GetUserAccountsQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @post(\"/\", response_model=AccountDto, status_code=status.HTTP_201_CREATED)\n    async def create_account(self, user_id: str, create_account_dto: CreateAccountDto) -&gt; AccountDto:\n        \"\"\"Create a new account for a user\"\"\"\n        command = self.mapper.map(create_account_dto, CreateAccountCommand)\n        command.user_id = user_id\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#error-handling","title":"\ud83d\udee1\ufe0f Error Handling","text":""},{"location":"features/mvc-controllers/#built-in-error-responses","title":"Built-in Error Responses","text":"<p>Controllers include standard error responses:</p> <pre><code>class UsersController(ControllerBase):\n\n    @get(\"/{user_id}\",\n         response_model=UserDto,\n         responses=ControllerBase.error_responses)  # Adds 400, 404, 500 responses\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        \"\"\"Get user by ID\"\"\"\n        query = GetUserByIdQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)  # Automatically handles error responses\n</code></pre>"},{"location":"features/mvc-controllers/#custom-error-handling","title":"Custom Error Handling","text":"<p>Add custom error handling:</p> <pre><code>from fastapi import HTTPException\n\nclass UsersController(ControllerBase):\n\n    @post(\"/\", response_model=UserDto, status_code=status.HTTP_201_CREATED)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        \"\"\"Create a new user\"\"\"\n        try:\n            command = self.mapper.map(create_user_dto, CreateUserCommand)\n            result = await self.mediator.execute_async(command)\n            return self.process(result)\n\n        except EmailAlreadyExistsException:\n            raise HTTPException(\n                status_code=status.HTTP_409_CONFLICT,\n                detail=\"A user with this email already exists\"\n            )\n        except ValidationException as ex:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=str(ex)\n            )\n</code></pre>"},{"location":"features/mvc-controllers/#global-error-handling","title":"Global Error Handling","text":"<p>Use middleware for global error handling:</p> <pre><code>from neuroglia.hosting.web import ExceptionHandlingMiddleware\n\n# In main.py\napp.add_middleware(ExceptionHandlingMiddleware, service_provider=app.services)\n</code></pre>"},{"location":"features/mvc-controllers/#authentication-authorization","title":"\ud83d\udd10 Authentication &amp; Authorization","text":"<p>For comprehensive OAuth 2.0, OpenID Connect, and JWT implementation with controllers, see the OAuth, OIDC &amp; JWT Reference.</p>"},{"location":"features/mvc-controllers/#dependency-injection-for-auth","title":"Dependency Injection for Auth","text":"<p>Inject authentication services:</p> <pre><code>from fastapi import Depends\nfrom neuroglia.security import IAuthService, AuthUser\n\nclass UsersController(ControllerBase):\n\n    def __init__(self,\n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator,\n                 auth_service: IAuthService):\n        super().__init__(service_provider, mapper, mediator)\n        self.auth_service = auth_service\n\n    @get(\"/profile\", response_model=UserDto)\n    async def get_current_user(self,\n                              current_user: AuthUser = Depends(auth_service.get_current_user)) -&gt; UserDto:\n        \"\"\"Get current user's profile\"\"\"\n        query = GetUserByIdQuery(user_id=current_user.user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#role-based-authorization","title":"Role-based Authorization","text":"<p>Implement role-based access control:</p> <pre><code>from neuroglia.security import require_role\n\nclass UsersController(ControllerBase):\n\n    @get(\"/\", response_model=List[UserDto])\n    @require_role(\"admin\")  # Custom decorator\n    async def get_all_users(self) -&gt; List[UserDto]:\n        \"\"\"Get all users (admin only)\"\"\"\n        query = GetAllUsersQuery()\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @delete(\"/{user_id}\")\n    @require_role([\"admin\", \"manager\"])  # Multiple roles\n    async def delete_user(self, user_id: str):\n        \"\"\"Delete a user (admin or manager only)\"\"\"\n        command = DeleteUserCommand(user_id=user_id)\n        result = await self.mediator.execute_async(command)\n        self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#response-processing","title":"\ud83d\udcca Response Processing","text":""},{"location":"features/mvc-controllers/#the-process-method","title":"The <code>process</code> Method","text":"<p>The <code>process</code> method handles <code>OperationResult</code> objects automatically:</p> <pre><code># OperationResult with data\nresult = OperationResult.success(user_dto)\nreturn self.process(result)  # Returns user_dto with 200 status\n\n# OperationResult with error\nresult = OperationResult.not_found(\"User not found\")\nreturn self.process(result)  # Raises HTTPException with 404 status\n\n# OperationResult created\nresult = OperationResult.created(user_dto)\nreturn self.process(result)  # Returns user_dto with 201 status\n</code></pre>"},{"location":"features/mvc-controllers/#custom-response-processing","title":"Custom Response Processing","text":"<p>Override response processing for special cases:</p> <pre><code>class UsersController(ControllerBase):\n\n    @get(\"/{user_id}\", response_model=UserDto)\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        \"\"\"Get user by ID\"\"\"\n        query = GetUserByIdQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n\n        # Custom processing\n        if not result.is_success:\n            if result.status_code == 404:\n                # Log the attempt\n                self.logger.warning(f\"Attempt to access non-existent user: {user_id}\")\n            return self.process(result)\n\n        # Add custom headers for successful responses\n        response = self.process(result)\n        # Custom logic here\n        return response\n</code></pre>"},{"location":"features/mvc-controllers/#testing-controllers","title":"\ud83e\uddea Testing Controllers","text":""},{"location":"features/mvc-controllers/#unit-testing","title":"Unit Testing","text":"<p>Test controllers with mocked dependencies:</p> <pre><code>import pytest\nfrom unittest.mock import Mock, AsyncMock\n\n@pytest.mark.asyncio\nasync def test_get_user_success():\n    # Arrange\n    mock_mediator = Mock()\n    mock_mediator.execute_async = AsyncMock(return_value=OperationResult.success(test_user_dto))\n\n    controller = UsersController(\n        service_provider=mock_service_provider,\n        mapper=mock_mapper,\n        mediator=mock_mediator\n    )\n\n    # Act\n    result = await controller.get_user(\"user123\")\n\n    # Assert\n    assert result == test_user_dto\n    mock_mediator.execute_async.assert_called_once()\n</code></pre>"},{"location":"features/mvc-controllers/#integration-testing","title":"Integration Testing","text":"<p>Test controllers with TestClient:</p> <pre><code>from fastapi.testclient import TestClient\n\ndef test_create_user_integration():\n    # Arrange\n    client = TestClient(app)\n    user_data = {\n        \"email\": \"test@example.com\",\n        \"first_name\": \"John\",\n        \"last_name\": \"Doe\"\n    }\n\n    # Act\n    response = client.post(\"/api/v1/users\", json=user_data)\n\n    # Assert\n    assert response.status_code == 201\n\n    created_user = response.json()\n    assert created_user[\"email\"] == user_data[\"email\"]\n    assert \"id\" in created_user\n</code></pre>"},{"location":"features/mvc-controllers/#api-testing","title":"API Testing","text":"<p>Test the complete API flow:</p> <pre><code>def test_user_crud_flow():\n    client = TestClient(app)\n\n    # Create user\n    create_response = client.post(\"/api/v1/users\", json=test_user_data)\n    assert create_response.status_code == 201\n    user = create_response.json()\n    user_id = user[\"id\"]\n\n    # Get user\n    get_response = client.get(f\"/api/v1/users/{user_id}\")\n    assert get_response.status_code == 200\n    assert get_response.json()[\"id\"] == user_id\n\n    # Update user\n    update_data = {\"first_name\": \"Jane\"}\n    update_response = client.put(f\"/api/v1/users/{user_id}\", json=update_data)\n    assert update_response.status_code == 200\n    assert update_response.json()[\"first_name\"] == \"Jane\"\n\n    # Delete user\n    delete_response = client.delete(f\"/api/v1/users/{user_id}\")\n    assert delete_response.status_code == 204\n\n    # Verify deletion\n    get_deleted_response = client.get(f\"/api/v1/users/{user_id}\")\n    assert get_deleted_response.status_code == 404\n</code></pre>"},{"location":"features/mvc-controllers/#best-practices","title":"\ud83d\ude80 Best Practices","text":""},{"location":"features/mvc-controllers/#1-keep-controllers-thin","title":"1. Keep Controllers Thin","text":"<p>Controllers should delegate to the application layer:</p> <pre><code># Good - Thin controller\nclass UsersController(ControllerBase):\n    @post(\"/\", response_model=UserDto)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n# Avoid - Business logic in controller\nclass UsersController(ControllerBase):\n    @post(\"/\", response_model=UserDto)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        # Validate email\n        if not self.is_valid_email(create_user_dto.email):\n            raise HTTPException(400, \"Invalid email\")\n\n        # Check if user exists\n        existing = await self.user_repo.get_by_email(create_user_dto.email)\n        if existing:\n            raise HTTPException(409, \"User exists\")\n\n        # Create user\n        user = User(...)\n        # ... more business logic\n</code></pre>"},{"location":"features/mvc-controllers/#2-use-dtos-for-api-contracts","title":"2. Use DTOs for API Contracts","text":"<p>Always use DTOs to define your API contracts:</p> <pre><code># API DTOs\nclass CreateUserDto(BaseModel):\n    email: str\n    first_name: str\n    last_name: str\n\nclass UserDto(BaseModel):\n    id: str\n    email: str\n    first_name: str\n    last_name: str\n    created_at: datetime\n\n# Domain entities stay separate\nclass User(Entity[str]):\n    def __init__(self, email: str, first_name: str, last_name: str):\n        # Domain logic\n        pass\n</code></pre>"},{"location":"features/mvc-controllers/#3-consistent-error-handling","title":"3. Consistent Error Handling","text":"<p>Use consistent patterns for error handling:</p> <pre><code>class UsersController(ControllerBase):\n\n    @get(\"/{user_id}\",\n         response_model=UserDto,\n         responses={\n             404: {\"description\": \"User not found\"},\n             400: {\"description\": \"Invalid user ID format\"}\n         })\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        # Validate input format\n        if not self.is_valid_uuid(user_id):\n            return self.bad_request(\"Invalid user ID format\")\n\n        # Execute query\n        query = GetUserByIdQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n\n        # Process will handle 404 automatically\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#4-document-your-apis","title":"4. Document Your APIs","text":"<p>Provide comprehensive API documentation:</p> <pre><code>class UsersController(ControllerBase):\n\n    @post(\"/\",\n          response_model=UserDto,\n          status_code=status.HTTP_201_CREATED,\n          summary=\"Create a new user\",\n          description=\"Creates a new user account in the system\",\n          response_description=\"The created user\",\n          tags=[\"User Management\"])\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        \"\"\"\n        Create a new user account.\n\n        - **email**: User's email address (must be unique)\n        - **first_name**: User's first name\n        - **last_name**: User's last name\n\n        Returns the created user with generated ID and timestamps.\n        \"\"\"\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#5-version-your-apis","title":"5. Version Your APIs","text":"<p>Plan for API versioning:</p> <pre><code># v1 controller\nclass V1UsersController(ControllerBase):\n    def __init__(self, service_provider, mapper, mediator):\n        super().__init__(service_provider, mapper, mediator)\n```python\nfrom neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.mvc import ControllerDiscovery\n\ndef create_pizzeria_app():\n    \"\"\"Configure Mario's Pizzeria application with controllers\"\"\"\n    builder = WebApplicationBuilder()\n\n    # Configure services\n    builder.services.add_mediator()\n    builder.services.add_auto_mapper()\n\n    # Add controllers with automatic discovery\n    builder.services.add_controllers([\n        \"api.controllers.orders_controller\",\n        \"api.controllers.menu_controller\",\n        \"api.controllers.kitchen_controller\",\n        \"api.controllers.reports_controller\",\n        \"api.controllers.auth_controller\"\n    ])\n\n    # Build application\n    app = builder.build()\n\n    # Configure controller routes with prefixes\n    app.include_router(OrdersController().router, prefix=\"/api/orders\", tags=[\"Orders\"])\n    app.include_router(MenuController().router, prefix=\"/api/menu\", tags=[\"Menu\"])\n    app.include_router(KitchenController().router, prefix=\"/api/kitchen\", tags=[\"Kitchen\"])\n    app.include_router(ReportsController().router, prefix=\"/api/reports\", tags=[\"Reports\"])\n    app.include_router(AuthController().router, prefix=\"/api/auth\", tags=[\"Authentication\"])\n\n    # Add exception handlers\n    app.add_exception_handler(PizzeriaException, pizzeria_exception_handler)\n    app.add_exception_handler(RequestValidationError, validation_exception_handler)\n\n    return app\n\n# Environment-specific controller registration\ndef configure_development_controllers(builder: WebApplicationBuilder):\n    \"\"\"Add development-specific controllers\"\"\"\n    # Add mock data controller for testing\n    builder.services.add_controller(MockDataController)\n\ndef configure_production_controllers(builder: WebApplicationBuilder):\n    \"\"\"Add production-specific controllers\"\"\"\n    # Add monitoring and health check controllers\n    builder.services.add_controller(HealthController)\n    builder.services.add_controller(MetricsController)\n</code></pre>"},{"location":"features/mvc-controllers/#controller-middleware-and-interceptors","title":"Controller Middleware and Interceptors","text":"<p>Add cross-cutting concerns to controllers:</p> <pre><code>from fastapi import Request, Response\nfrom fastapi.middleware.base import BaseHTTPMiddleware\nimport time\nimport logging\n\nclass PizzeriaRequestLoggingMiddleware(BaseHTTPMiddleware):\n    \"\"\"Log all pizzeria API requests\"\"\"\n\n    async def dispatch(self, request: Request, call_next):\n        start_time = time.time()\n\n        # Log incoming request\n        logging.info(f\"Incoming {request.method} {request.url}\")\n\n        # Process request\n        response = await call_next(request)\n\n        # Log response\n        process_time = time.time() - start_time\n        logging.info(f\"Completed {request.method} {request.url} - \"\n                    f\"Status: {response.status_code} - \"\n                    f\"Duration: {process_time:.2f}s\")\n\n        return response\n\nclass OrderValidationMiddleware(BaseHTTPMiddleware):\n    \"\"\"Validate order-related requests\"\"\"\n\n    async def dispatch(self, request: Request, call_next):\n        if request.url.path.startswith(\"/api/orders\"):\n            # Add order-specific validation\n            if request.method == \"POST\":\n                # Validate business hours\n                if not self.is_business_hours():\n                    return JSONResponse(\n                        status_code=400,\n                        content={\"error\": \"Pizzeria is currently closed\"}\n                    )\n\n        return await call_next(request)\n\n    def is_business_hours(self) -&gt; bool:\n        \"\"\"Check if pizzeria is open for orders\"\"\"\n        from datetime import datetime\n        now = datetime.now()\n        return 11 &lt;= now.hour &lt;= 22  # Open 11 AM to 10 PM\n\n# Add middleware to application\napp.add_middleware(PizzeriaRequestLoggingMiddleware)\napp.add_middleware(OrderValidationMiddleware)\n</code></pre>"},{"location":"features/mvc-controllers/#controller-testing-patterns","title":"\ud83e\uddea Controller Testing Patterns","text":""},{"location":"features/mvc-controllers/#unit-testing-controllers","title":"Unit Testing Controllers","text":"<p>Test controllers with mocked dependencies:</p> <pre><code>import pytest\nfrom unittest.mock import AsyncMock, Mock\nfrom fastapi.testclient import TestClient\nfrom neuroglia.mediation import OperationResult\n\nclass TestOrdersController:\n    \"\"\"Unit tests for orders controller\"\"\"\n\n    @pytest.fixture\n    def mock_mediator(self):\n        \"\"\"Mock mediator for testing\"\"\"\n        mediator = AsyncMock()\n        return mediator\n\n    @pytest.fixture\n    def orders_controller(self, mock_mediator):\n        \"\"\"Orders controller with mocked dependencies\"\"\"\n        service_provider = Mock()\n        mapper = Mock()\n\n        controller = OrdersController(service_provider, mapper, mock_mediator)\n        return controller\n\n    @pytest.mark.asyncio\n    async def test_place_order_success(self, orders_controller, mock_mediator):\n        \"\"\"Test successful order placement\"\"\"\n        # Arrange\n        order_request = PlaceOrderDto(\n            customer_name=\"John Doe\",\n            customer_phone=\"+1234567890\",\n            customer_address=\"123 Main St\",\n            pizzas=[PizzaOrderDto(name=\"Margherita\", size=\"large\", quantity=1)],\n            payment_method=\"card\"\n        )\n\n        expected_order = OrderDto(\n            id=\"order_123\",\n            customer_name=\"John Doe\",\n            status=\"received\",\n            total_amount=15.99\n        )\n\n        mock_mediator.execute_async.return_value = OperationResult.success(expected_order)\n\n        # Act\n        result = await orders_controller.place_order(order_request)\n\n        # Assert\n        assert result.id == \"order_123\"\n        assert result.customer_name == \"John Doe\"\n        mock_mediator.execute_async.assert_called_once()\n\n    @pytest.mark.asyncio\n    async def test_place_order_validation_error(self, orders_controller, mock_mediator):\n        \"\"\"Test order placement with validation error\"\"\"\n        # Arrange\n        invalid_order = PlaceOrderDto(\n            customer_name=\"\",  # Invalid empty name\n            customer_phone=\"invalid\",  # Invalid phone\n            customer_address=\"\",  # Invalid empty address\n            pizzas=[],  # No pizzas\n            payment_method=\"invalid\"  # Invalid payment method\n        )\n\n        # Act &amp; Assert\n        with pytest.raises(ValidationError):\n            await orders_controller.place_order(invalid_order)\n\n@pytest.mark.integration\nclass TestOrdersControllerIntegration:\n    \"\"\"Integration tests for orders controller\"\"\"\n\n    @pytest.fixture\n    def test_client(self):\n        \"\"\"Test client for integration testing\"\"\"\n        app = create_pizzeria_app()\n        return TestClient(app)\n\n    def test_get_menu_integration(self, test_client):\n        \"\"\"Test menu retrieval integration\"\"\"\n        response = test_client.get(\"/api/menu/pizzas\")\n\n        assert response.status_code == 200\n        menu = response.json()\n        assert isinstance(menu, list)\n\n        # Validate pizza structure\n        if menu:\n            pizza = menu[0]\n            assert \"id\" in pizza\n            assert \"name\" in pizza\n            assert \"base_price\" in pizza\n\n    def test_place_order_integration(self, test_client):\n        \"\"\"Test order placement integration\"\"\"\n        order_data = {\n            \"customer_name\": \"Integration Test Customer\",\n            \"customer_phone\": \"+1234567890\",\n            \"customer_address\": \"123 Test Street, Test City\",\n            \"pizzas\": [\n                {\n                    \"name\": \"Margherita\",\n                    \"size\": \"large\",\n                    \"toppings\": [\"extra_cheese\"],\n                    \"quantity\": 1\n                }\n            ],\n            \"payment_method\": \"card\"\n        }\n\n        response = test_client.post(\"/api/orders/\", json=order_data)\n\n        assert response.status_code == 201\n        order = response.json()\n        assert order[\"customer_name\"] == \"Integration Test Customer\"\n        assert order[\"status\"] == \"received\"\n        assert \"id\" in order\n</code></pre>"},{"location":"features/mvc-controllers/#api-documentation-generation","title":"\ufffd API Documentation Generation","text":""},{"location":"features/mvc-controllers/#openapi-configuration","title":"OpenAPI Configuration","text":"<p>Configure comprehensive API documentation:</p> <pre><code>from fastapi import FastAPI\nfrom fastapi.openapi.utils import get_openapi\n\ndef create_pizzeria_app_with_docs():\n    \"\"\"Create Mario's Pizzeria app with enhanced documentation\"\"\"\n    app = create_pizzeria_app()\n\n    # Custom OpenAPI schema\n    def custom_openapi():\n        if app.openapi_schema:\n            return app.openapi_schema\n\n        openapi_schema = get_openapi(\n            title=\"Mario's Pizzeria API\",\n            version=\"1.0.0\",\n            description=\"\"\"\n            # \ud83c\udf55 Mario's Pizzeria API\n\n            Welcome to Mario's Pizzeria API! This API provides comprehensive\n            functionality for managing pizza orders, menu items, kitchen workflow,\n            and customer interactions.\n\n            ## Features\n\n            - **Order Management**: Place, track, and manage pizza orders\n            - **Menu Administration**: Manage pizzas, toppings, and availability\n            - **Kitchen Workflow**: Handle order preparation and status updates\n            - **Customer Authentication**: Secure customer account management\n            - **Staff Portal**: Role-based access for staff operations\n            - **Analytics**: Revenue and performance reporting\n\n            ## Authentication\n\n            The API uses OAuth 2.0 with JWT tokens:\n\n            - **Customers**: Phone-based OTP authentication\n            - **Staff**: Username/password with role-based permissions\n\n            ## Rate Limiting\n\n            - **Customers**: 100 requests per hour\n            - **Staff**: 500 requests per hour\n            - **Managers**: Unlimited\n            \"\"\",\n            routes=app.routes,\n        )\n\n        # Add custom tags for better organization\n        openapi_schema[\"tags\"] = [\n            {\n                \"name\": \"Orders\",\n                \"description\": \"Customer order management and tracking\"\n            },\n            {\n                \"name\": \"Menu\",\n                \"description\": \"Pizza menu and item management\"\n            },\n            {\n                \"name\": \"Kitchen\",\n                \"description\": \"Kitchen operations and workflow\"\n            },\n            {\n                \"name\": \"Authentication\",\n                \"description\": \"Customer and staff authentication\"\n            },\n            {\n                \"name\": \"Reports\",\n                \"description\": \"Analytics and reporting (Manager only)\"\n            }\n        ]\n\n        # Add security schemes\n        openapi_schema[\"components\"][\"securitySchemes\"] = {\n            \"BearerAuth\": {\n                \"type\": \"http\",\n                \"scheme\": \"bearer\",\n                \"bearerFormat\": \"JWT\"\n            },\n            \"CustomerAuth\": {\n                \"type\": \"oauth2\",\n                \"flows\": {\n                    \"password\": {\n                        \"tokenUrl\": \"/api/auth/customer/login\",\n                        \"scopes\": {\n                            \"customer\": \"Customer order access\"\n                        }\n                    }\n                }\n            },\n            \"StaffAuth\": {\n                \"type\": \"oauth2\",\n                \"flows\": {\n                    \"password\": {\n                        \"tokenUrl\": \"/api/auth/staff/login\",\n                        \"scopes\": {\n                            \"kitchen\": \"Kitchen operations\",\n                            \"manager\": \"Management functions\"\n                        }\n                    }\n                }\n            }\n        }\n\n        app.openapi_schema = openapi_schema\n        return app.openapi_schema\n\n    app.openapi = custom_openapi\n    return app\n</code></pre>"},{"location":"features/mvc-controllers/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started Guide - Complete pizzeria application tutorial</li> <li>CQRS &amp; Mediation - Command and query handlers used in controllers</li> <li>Dependency Injection - Service registration for controller dependencies</li> <li>Data Access - Repository patterns used by controller commands/queries</li> <li>Source Code Naming Conventions - Controller, DTO, and method naming patterns</li> </ul> <p>This documentation demonstrates MVC controller patterns using Mario's Pizzeria as a consistent example throughout the Neuroglia framework. The examples show real-world API design with authentication, validation, error handling, and comprehensive testing.</p>"},{"location":"features/object-mapping/","title":"\ud83c\udfaf Object Mapping","text":"<p>Neuroglia's object mapping system provides powerful and flexible capabilities for transforming objects between types. Whether converting domain entities to DTOs, mapping API requests to commands, or transforming data between layers, the Mapper class handles complex object-to-object conversions with ease.</p> <p>!!! info \"\ud83c\udfaf What You'll Learn\" - Automatic property mapping with convention-based matching - Custom mapping configurations and transformations - Type conversion and validation - Integration with Mario's Pizzeria domain objects</p>"},{"location":"features/object-mapping/#overview","title":"\ud83c\udfaf Overview","text":"<p>Neuroglia's mapping system offers:</p> <ul> <li>\ud83d\udd04 Automatic Mapping - Convention-based property matching with intelligent type conversion</li> <li>\ud83c\udfa8 Custom Configurations - Fine-grained control over property mappings and transformations</li> <li>\ud83d\udccb Mapping Profiles - Reusable mapping configurations organized in profiles</li> <li>\ud83d\udd27 Type Conversion - Built-in converters for common type transformations</li> <li>\ud83d\udc89 DI Integration - Service-based mapper with configurable profiles</li> </ul>"},{"location":"features/object-mapping/#key-benefits","title":"Key Benefits","text":"<ul> <li>Productivity: Eliminate repetitive mapping code with automatic conventions</li> <li>Type Safety: Strongly-typed mappings with compile-time validation</li> <li>Flexibility: Custom transformations for complex mapping scenarios</li> <li>Testability: Easy mocking and testing of mapping logic</li> <li>Performance: Efficient mapping with minimal reflection overhead</li> </ul>"},{"location":"features/object-mapping/#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<pre><code>flowchart TD\n    A[\"\ud83c\udfaf Source Object&lt;br/&gt;Domain Entity\"]\n    B[\"\ud83d\udd04 Mapper&lt;br/&gt;Main Mapping Service\"]\n    C[\"\ud83d\udccb Mapping Profiles&lt;br/&gt;Configuration Sets\"]\n    D[\"\ud83c\udfa8 Type Converters&lt;br/&gt;Custom Transformations\"]\n\n    subgraph \"\ud83d\udd27 Mapping Pipeline\"\n        E[\"Property Matching\"]\n        F[\"Type Conversion\"]\n        G[\"Custom Logic\"]\n        H[\"Validation\"]\n    end\n\n    subgraph \"\ud83c\udfaf Target Types\"\n        I[\"DTOs\"]\n        J[\"Commands\"]\n        K[\"View Models\"]\n        L[\"API Responses\"]\n    end\n\n    A --&gt; B\n    B --&gt; C\n    B --&gt; D\n    B --&gt; E\n    E --&gt; F\n    F --&gt; G\n    G --&gt; H\n\n    H --&gt; I\n    H --&gt; J\n    H --&gt; K\n    H --&gt; L\n\n    style B fill:#e1f5fe,stroke:#0277bd,stroke-width:3px\n    style C fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\n    style D fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px\n\n    classDef pipeline fill:#fff3e0,stroke:#f57c00,stroke-width:2px\n    class E,F,G,H pipeline\n\n    classDef targets fill:#e3f2fd,stroke:#1976d2,stroke-width:1px\n    class I,J,K,L targets</code></pre>"},{"location":"features/object-mapping/#basic-usage-in-marios-pizzeria","title":"\ud83c\udf55 Basic Usage in Mario's Pizzeria","text":""},{"location":"features/object-mapping/#entity-to-dto-mapping","title":"Entity to DTO Mapping","text":"<p>Let's see how Mario's Pizzeria uses mapping for API responses:</p> From samples/mario-pizzeria/domain/entities/<pre><code>from neuroglia.mapping.mapper import Mapper, map_from, map_to\nfrom decimal import Decimal\nfrom datetime import datetime, timezone\nfrom enum import Enum\nfrom typing import Optional\nfrom uuid import uuid4\nfrom pydantic import BaseModel, Field, field_validator\n\n# Domain Entities (from actual Mario's Pizzeria)\nclass PizzaSize(Enum):\n    \"\"\"Pizza size options\"\"\"\n    SMALL = \"small\"\n    MEDIUM = \"medium\"\n    LARGE = \"large\"\n\nclass OrderStatus(Enum):\n    \"\"\"Order lifecycle statuses\"\"\"\n    PENDING = \"pending\"\n    CONFIRMED = \"confirmed\"\n    COOKING = \"cooking\"\n    READY = \"ready\"\n\n@map_from(\"PizzaDto\")\n@map_to(\"PizzaDto\")\nclass Pizza:\n    \"\"\"Pizza entity with sophisticated pricing logic\"\"\"\n\n    def __init__(self, name: str, base_price: Decimal, size: PizzaSize):\n        self.id = str(uuid4())\n        self.name = name\n        self.base_price = base_price\n        self.size = size\n        self.toppings: list[str] = []\n\n    @property\n    def size_multiplier(self) -&gt; Decimal:\n        \"\"\"Size-based pricing multipliers\"\"\"\n        multipliers = {\n            PizzaSize.SMALL: Decimal(\"1.0\"),\n            PizzaSize.MEDIUM: Decimal(\"1.3\"),\n            PizzaSize.LARGE: Decimal(\"1.6\")\n        }\n        return multipliers[self.size]\n\n    @property\n    def topping_price(self) -&gt; Decimal:\n        \"\"\"Calculate total topping cost\"\"\"\n        return Decimal(\"2.50\") * len(self.toppings)\n\n    @property\n    def total_price(self) -&gt; Decimal:\n        \"\"\"Calculate total pizza price with size and toppings\"\"\"\n        return (self.base_price * self.size_multiplier) + self.topping_price\n\n@map_from(\"OrderDto\")\n@map_to(\"OrderDto\")\nclass Order:\n    \"\"\"Order entity with pizzas and status management\"\"\"\n\n    def __init__(self, customer_id: str, estimated_ready_time: Optional[datetime] = None):\n        self.id = str(uuid4())\n        self.customer_id = customer_id\n        self.pizzas: list[Pizza] = []\n        self.status = OrderStatus.PENDING\n        self.order_time = datetime.now(timezone.utc)\n        self.confirmed_time: Optional[datetime] = None\n        self.cooking_started_time: Optional[datetime] = None\n        self.actual_ready_time: Optional[datetime] = None\n        self.estimated_ready_time = estimated_ready_time\n        self.notes: Optional[str] = None\n\n    @property\n    def total_amount(self) -&gt; Decimal:\n        \"\"\"Calculate total order amount\"\"\"\n        return sum((pizza.total_price for pizza in self.pizzas), Decimal(\"0.00\"))\n\n# DTOs for API responses (from actual Mario's Pizzeria)\nclass PizzaDto(BaseModel):\n    \"\"\"DTO for pizza information\"\"\"\n    id: Optional[str] = None\n    name: str = Field(..., min_length=1, max_length=100)\n    size: str = Field(..., description=\"Pizza size: small, medium, or large\")\n    toppings: list[str] = Field(default_factory=list)\n    base_price: Optional[Decimal] = None\n    total_price: Optional[Decimal] = None\n\n    @field_validator(\"size\")\n    @classmethod\n    def validate_size(cls, v):\n        if v not in [\"small\", \"medium\", \"large\"]:\n            raise ValueError(\"Size must be: small, medium, or large\")\n        return v\n\nclass OrderDto(BaseModel):\n    \"\"\"DTO for complete order information\"\"\"\n    id: str\n    customer: Optional[\"CustomerDto\"] = None\n    customer_name: Optional[str] = None\n    customer_phone: Optional[str] = None\n    customer_address: Optional[str] = None\n    pizzas: list[PizzaDto] = Field(default_factory=list)\n    status: str\n    order_time: datetime\n    confirmed_time: Optional[datetime] = None\n    cooking_started_time: Optional[datetime] = None\n    actual_ready_time: Optional[datetime] = None\n    estimated_ready_time: Optional[datetime] = None\n    notes: Optional[str] = None\n    total_amount: Decimal\n    pizza_count: int\n    payment_method: Optional[str] = None\n\n# Using the Mapper with Auto-Mapping Decorators\nclass OrderService:\n    def __init__(self, mapper: Mapper):\n        self.mapper = mapper\n\n    def get_order_dto(self, order: Order, customer_name: str = \"Unknown\") -&gt; OrderDto:\n        \"\"\"Convert domain order to API DTO using auto-mapping\"\"\"\n        # The @map_to decorator on Order entity handles automatic conversion\n        dto = self.mapper.map(order, OrderDto)\n        # Set customer information (since Order only has customer_id)\n        dto.customer_name = customer_name\n        dto.pizza_count = len(order.pizzas)\n        return dto\n\n    def get_pizza_dto(self, pizza: Pizza) -&gt; PizzaDto:\n        \"\"\"Convert domain pizza to API DTO using auto-mapping\"\"\"\n        # The @map_to decorator on Pizza entity handles automatic conversion\n        return self.mapper.map(pizza, PizzaDto)\n\n# Example usage with actual Mario's Pizzeria entities\nmapper = Mapper()\n\n# Create a pizza with sophisticated pricing\nfrom domain.entities import PizzaSize\n\npizza = Pizza(\n    name=\"Supreme\",\n    base_price=Decimal(\"17.99\"),\n    size=PizzaSize.LARGE  # 1.6x multiplier\n)\npizza.add_topping(\"pepperoni\")\npizza.add_topping(\"mushrooms\")\n# Total: $17.99 * 1.6 + $2.50 * 2 = $33.78\n\n# Create an order\norder = Order(customer_id=\"cust-123\")\norder.add_pizza(pizza)\norder.confirm_order()  # Sets status to CONFIRMED\n\n# Convert to DTOs using auto-mapping\nservice = OrderService(mapper)\npizza_dto = service.get_pizza_dto(pizza)\norder_dto = service.get_order_dto(order, customer_name=\"Luigi Mario\")\n\nprint(f\"Pizza: {pizza_dto.name} ({pizza_dto.size}) - ${pizza_dto.total_price}\")\nprint(f\"Order {order_dto.id} total: ${order_dto.total_amount} ({order_dto.status})\")\n\n# Map objects\norder = create_sample_order()\norder_dto = mapper.map(order, OrderDto)\n\nprint(f\"Order {order_dto.id} for {order_dto.customer}\")\n# Output: Order order-123 for Mario Luigi\n</code></pre>"},{"location":"features/object-mapping/#mapping-configurations","title":"\ud83c\udfa8 Mapping Configurations","text":""},{"location":"features/object-mapping/#convention-based-mapping","title":"Convention-Based Mapping","text":"<p>The mapper automatically matches properties with the same names:</p> <pre><code>@dataclass\nclass Customer:\n    id: str\n    name: str\n    email: str\n    phone: str\n\n@dataclass\nclass CustomerDto:\n    id: str      # Automatically mapped\n    name: str    # Automatically mapped\n    email: str   # Automatically mapped\n    phone: str   # Automatically mapped\n\n# Simple mapping - no configuration needed\nmapper = Mapper()\ncustomer = Customer(\"123\", \"Luigi Mario\", \"luigi@pizzeria.com\", \"+1-555-LUIGI\")\ncustomer_dto = mapper.map(customer, CustomerDto)\n</code></pre>"},{"location":"features/object-mapping/#custom-member-mapping","title":"Custom Member Mapping","text":"<p>For properties that don't match by name or need transformation:</p> <pre><code>@dataclass\nclass Address:\n    street_address: str\n    city_name: str\n    postal_code: str\n    country_name: str\n\n@dataclass\nclass AddressDto:\n    address_line: str    # Combined field\n    city: str           # Different name\n    zip_code: str       # Different name\n    country: str        # Different name\n\n# Configure custom mappings\nmapper.create_map(Address, AddressDto) \\\n    .map_member(\"address_line\", lambda ctx: ctx.source.street_address) \\\n    .map_member(\"city\", lambda ctx: ctx.source.city_name) \\\n    .map_member(\"zip_code\", lambda ctx: ctx.source.postal_code) \\\n    .map_member(\"country\", lambda ctx: ctx.source.country_name)\n</code></pre>"},{"location":"features/object-mapping/#type-conversion","title":"Type Conversion","text":"<p>Automatic conversion between compatible types:</p> <pre><code>@dataclass\nclass MenuItem:\n    name: str\n    price: Decimal       # Decimal type\n    available: bool\n    category_id: int\n\n@dataclass\nclass MenuItemDto:\n    name: str\n    price: float         # Converted to float\n    available: str       # Converted to string\n    category_id: str     # Converted to string\n\n# Automatic type conversion\nmapper = Mapper()\nitem = MenuItem(\"Margherita\", Decimal(\"15.99\"), True, 1)\nitem_dto = mapper.map(item, MenuItemDto)\n\nassert item_dto.price == 15.99\nassert item_dto.available == \"True\"\nassert item_dto.category_id == \"1\"\n</code></pre>"},{"location":"features/object-mapping/#mapping-profiles","title":"\ud83d\udccb Mapping Profiles","text":"<p>Organize related mappings in reusable profiles:</p> <pre><code>from neuroglia.mapping.mapper import MappingProfile\n\nclass PizzeriaMappingProfile(MappingProfile):\n    \"\"\"Mapping profile for Mario's Pizzeria domain objects\"\"\"\n\n    def configure(self):\n        # Order mappings\n        self.create_map(Order, OrderDto) \\\n            .map_member(\"customer\", lambda ctx: ctx.source.customer_name) \\\n            .map_member(\"phone\", lambda ctx: ctx.source.customer_phone) \\\n            .map_member(\"items\", lambda ctx: self.map_list(ctx.source.pizzas, PizzaDto)) \\\n            .map_member(\"ordered_at\", lambda ctx: ctx.source.order_time.isoformat()) \\\n            .map_member(\"total\", lambda ctx: str(ctx.source.total_amount))\n\n        # Pizza mappings\n        self.create_map(Pizza, PizzaDto) \\\n            .map_member(\"price\", lambda ctx: str(ctx.source.total_price)) \\\n            .map_member(\"prep_time\", lambda ctx: ctx.source.preparation_time_minutes)\n\n        # Customer mappings\n        self.create_map(Customer, CustomerDto)  # Convention-based\n\n        # Address mappings\n        self.create_map(Address, AddressDto) \\\n            .map_member(\"address_line\", lambda ctx: f\"{ctx.source.street_address}\") \\\n            .map_member(\"city\", lambda ctx: ctx.source.city_name) \\\n            .map_member(\"zip_code\", lambda ctx: ctx.source.postal_code)\n\n# Register profile with mapper\nmapper = Mapper()\nmapper.add_profile(PizzeriaMappingProfile())\n</code></pre>"},{"location":"features/object-mapping/#advanced-mapping-patterns","title":"\ud83d\udd27 Advanced Mapping Patterns","text":""},{"location":"features/object-mapping/#collection-mapping","title":"Collection Mapping","text":"<pre><code>from typing import List, Dict\n\n@dataclass\nclass Menu:\n    sections: List[MenuSection]\n    featured_items: Dict[str, Pizza]\n\n@dataclass\nclass MenuDto:\n    sections: List[MenuSectionDto]\n    featured: Dict[str, PizzaDto]\n\n# Configure collection mappings\nmapper.create_map(Menu, MenuDto) \\\n    .map_member(\"sections\", lambda ctx: mapper.map_list(ctx.source.sections, MenuSectionDto)) \\\n    .map_member(\"featured\", lambda ctx: {\n        k: mapper.map(v, PizzaDto)\n        for k, v in ctx.source.featured_items.items()\n    })\n</code></pre>"},{"location":"features/object-mapping/#conditional-mapping","title":"Conditional Mapping","text":"<pre><code>@dataclass\nclass OrderSummaryDto:\n    id: str\n    customer: str\n    status: str\n    total: str\n    special_instructions: str  # Only for certain statuses\n\n# Conditional member mapping\nmapper.create_map(Order, OrderSummaryDto) \\\n    .map_member(\"special_instructions\", lambda ctx:\n        getattr(ctx.source, 'special_instructions', '')\n        if ctx.source.status in [OrderStatus.COOKING, OrderStatus.READY]\n        else None\n    )\n</code></pre>"},{"location":"features/object-mapping/#flattening-complex-objects","title":"Flattening Complex Objects","text":"<pre><code>@dataclass\nclass OrderWithCustomer:\n    id: str\n    customer: Customer\n    pizzas: List[Pizza]\n    status: OrderStatus\n\n@dataclass\nclass FlatOrderDto:\n    order_id: str\n    customer_name: str      # Flattened from customer\n    customer_email: str     # Flattened from customer\n    pizza_count: int        # Computed field\n    status: str\n\n# Flattening mapping\nmapper.create_map(OrderWithCustomer, FlatOrderDto) \\\n    .map_member(\"order_id\", lambda ctx: ctx.source.id) \\\n    .map_member(\"customer_name\", lambda ctx: ctx.source.customer.name) \\\n    .map_member(\"customer_email\", lambda ctx: ctx.source.customer.email) \\\n    .map_member(\"pizza_count\", lambda ctx: len(ctx.source.pizzas))\n</code></pre>"},{"location":"features/object-mapping/#testing-object-mapping","title":"\ud83e\uddea Testing Object Mapping","text":""},{"location":"features/object-mapping/#unit-testing-patterns","title":"Unit Testing Patterns","text":"<pre><code>import pytest\nfrom neuroglia.mapping.mapper import Mapper\n\nclass TestPizzeriaMapping:\n\n    def setup_method(self):\n        self.mapper = Mapper()\n        self.mapper.add_profile(PizzeriaMappingProfile())\n\n    def test_pizza_to_dto_mapping(self):\n        \"\"\"Test Pizza to PizzaDto mapping\"\"\"\n        # Arrange\n        pizza = Pizza(\n            id=\"pizza-123\",\n            name=\"Margherita\",\n            size=\"large\",\n            base_price=Decimal(\"15.99\"),\n            toppings=[\"basil\", \"mozzarella\"],\n            preparation_time_minutes=18\n        )\n\n        # Act\n        pizza_dto = self.mapper.map(pizza, PizzaDto)\n\n        # Assert\n        assert pizza_dto.id == \"pizza-123\"\n        assert pizza_dto.name == \"Margherita\"\n        assert pizza_dto.price == \"18.99\"  # base_price + toppings\n        assert pizza_dto.prep_time == 18\n        assert pizza_dto.toppings == [\"basil\", \"mozzarella\"]\n\n    def test_order_to_dto_mapping_preserves_structure(self):\n        \"\"\"Test complex Order to OrderDto mapping\"\"\"\n        # Arrange\n        order = create_sample_order_with_multiple_pizzas()\n\n        # Act\n        order_dto = self.mapper.map(order, OrderDto)\n\n        # Assert\n        assert order_dto.id == order.id\n        assert order_dto.customer == order.customer_name\n        assert len(order_dto.items) == len(order.pizzas)\n        assert order_dto.total == str(order.total_amount)\n\n    def test_mapping_handles_none_values(self):\n        \"\"\"Test mapping with None values\"\"\"\n        # Arrange\n        customer = Customer(\n            id=\"123\",\n            name=\"Test Customer\",\n            email=None,  # None value\n            phone=\"+1-555-TEST\"\n        )\n\n        # Act\n        customer_dto = self.mapper.map(customer, CustomerDto)\n\n        # Assert\n        assert customer_dto.email is None\n        assert customer_dto.name == \"Test Customer\"\n\n    def test_collection_mapping_preserves_order(self):\n        \"\"\"Test that collection mapping preserves order\"\"\"\n        # Arrange\n        pizzas = [\n            create_pizza(\"Margherita\"),\n            create_pizza(\"Pepperoni\"),\n            create_pizza(\"Hawaiian\")\n        ]\n\n        # Act\n        pizza_dtos = self.mapper.map_list(pizzas, PizzaDto)\n\n        # Assert\n        assert len(pizza_dtos) == 3\n        assert pizza_dtos[0].name == \"Margherita\"\n        assert pizza_dtos[1].name == \"Pepperoni\"\n        assert pizza_dtos[2].name == \"Hawaiian\"\n</code></pre>"},{"location":"features/object-mapping/#real-world-use-cases","title":"\ud83c\udfaf Real-World Use Cases","text":""},{"location":"features/object-mapping/#1-api-controller-integration","title":"1. API Controller Integration","text":"<pre><code>from neuroglia.mvc import ControllerBase\nfrom fastapi import HTTPException\n\nclass OrdersController(ControllerBase):\n    def __init__(self,\n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator,\n                 order_service: OrderService):\n        super().__init__(service_provider, mapper, mediator)\n        self.order_service = order_service\n\n    @get(\"/{order_id}\")\n    async def get_order(self, order_id: str) -&gt; OrderDto:\n        \"\"\"Get order by ID with automatic DTO mapping\"\"\"\n        order = await self.order_service.get_by_id_async(order_id)\n\n        if not order:\n            raise HTTPException(status_code=404, detail=\"Order not found\")\n\n        # Map domain entity to DTO\n        return self.mapper.map(order, OrderDto)\n\n    @post(\"/\")\n    async def create_order(self, create_order_request: CreateOrderRequest) -&gt; OrderDto:\n        \"\"\"Create new order with request mapping\"\"\"\n        # Map request to command\n        command = self.mapper.map(create_order_request, CreateOrderCommand)\n\n        # Execute command\n        result = await self.mediator.execute_async(command)\n\n        if not result.is_success:\n            raise HTTPException(status_code=400, detail=result.error_message)\n\n        # Map result to DTO\n        return self.mapper.map(result.value, OrderDto)\n</code></pre>"},{"location":"features/object-mapping/#2-commandquery-mapping","title":"2. Command/Query Mapping","text":"<pre><code>from neuroglia.mediation import Command, CommandHandler\n\n@dataclass\nclass CreateOrderRequest:\n    customer_name: str\n    customer_phone: str\n    pizza_requests: List[PizzaRequest]\n\n@dataclass\nclass CreateOrderCommand(Command[Order]):\n    customer_name: str\n    customer_phone: str\n    pizza_items: List[PizzaOrderItem]\n\n# Map request to command\nclass OrderMappingProfile(MappingProfile):\n    def configure(self):\n        self.create_map(CreateOrderRequest, CreateOrderCommand) \\\n            .map_member(\"pizza_items\", lambda ctx:\n                [self.map(req, PizzaOrderItem) for req in ctx.source.pizza_requests]\n            )\n</code></pre>"},{"location":"features/object-mapping/#3-event-data-transformation","title":"3. Event Data Transformation","text":"<pre><code>from neuroglia.eventing import DomainEvent\n\n@dataclass\nclass OrderStatusChangedEvent(DomainEvent):\n    order_id: str\n    old_status: str\n    new_status: str\n    customer_email: str\n    notification_data: dict\n\nclass OrderEventService:\n    def __init__(self, mapper: Mapper):\n        self.mapper = mapper\n\n    def create_status_change_event(self, order: Order, old_status: OrderStatus) -&gt; OrderStatusChangedEvent:\n        \"\"\"Create event with mapped data\"\"\"\n\n        # Map order data to event notification data\n        notification_data = {\n            \"order_summary\": self.mapper.map(order, OrderSummaryDto),\n            \"estimated_time\": order.estimated_ready_time.isoformat(),\n            \"total_amount\": str(order.total_amount)\n        }\n\n        return OrderStatusChangedEvent(\n            order_id=order.id,\n            old_status=old_status.value,\n            new_status=order.status.value,\n            customer_email=order.customer.email,\n            notification_data=notification_data\n        )\n</code></pre>"},{"location":"features/object-mapping/#performance-optimization","title":"\ud83d\udd0d Performance Optimization","text":""},{"location":"features/object-mapping/#mapping-performance-tips","title":"Mapping Performance Tips","text":"<pre><code>class OptimizedMappingService:\n    def __init__(self, mapper: Mapper):\n        self.mapper = mapper\n        # Pre-compile mappings for better performance\n        self._initialize_mappings()\n\n    def _initialize_mappings(self):\n        \"\"\"Pre-configure frequently used mappings\"\"\"\n        # Frequently used mappings\n        self.mapper.create_map(Order, OrderDto)\n        self.mapper.create_map(Pizza, PizzaDto)\n        self.mapper.create_map(Customer, CustomerDto)\n\n        # Warm up mapper with sample objects\n        sample_order = create_sample_order()\n        self.mapper.map(sample_order, OrderDto)\n\n    def bulk_map_orders(self, orders: List[Order]) -&gt; List[OrderDto]:\n        \"\"\"Efficiently map large collections\"\"\"\n        return [self.mapper.map(order, OrderDto) for order in orders]\n\n    def map_with_caching(self, source: Any, target_type: Type[T]) -&gt; T:\n        \"\"\"Map with result caching for immutable objects\"\"\"\n        cache_key = f\"{type(source)}-{target_type}-{hash(source)}\"\n\n        if cache_key not in self._mapping_cache:\n            self._mapping_cache[cache_key] = self.mapper.map(source, target_type)\n\n        return self._mapping_cache[cache_key]\n</code></pre>"},{"location":"features/object-mapping/#integration-with-other-features","title":"\ud83d\udd04 Integration with Other Features","text":""},{"location":"features/object-mapping/#mapping-with-serialization","title":"Mapping with Serialization","text":"<pre><code>class OrderApiService:\n    def __init__(self, mapper: Mapper, serializer: JsonSerializer):\n        self.mapper = mapper\n        self.serializer = serializer\n\n    def export_orders_json(self, orders: List[Order]) -&gt; str:\n        \"\"\"Export orders as JSON with DTO mapping\"\"\"\n        # Map to DTOs first\n        order_dtos = self.mapper.map_list(orders, OrderDto)\n\n        # Then serialize\n        return self.serializer.serialize_to_text(order_dtos)\n\n    def import_orders_json(self, json_data: str) -&gt; List[Order]:\n        \"\"\"Import orders from JSON with DTO mapping\"\"\"\n        # Deserialize to DTOs\n        order_dtos = self.serializer.deserialize_from_text(json_data, List[OrderDto])\n\n        # Map to domain entities\n        return self.mapper.map_list(order_dtos, Order)\n</code></pre>"},{"location":"features/object-mapping/#dependency-injection-integration","title":"\ud83d\ude80 Dependency Injection Integration","text":""},{"location":"features/object-mapping/#configuring-mapper-in-di-container","title":"Configuring Mapper in DI Container","text":"<pre><code>from neuroglia.hosting import WebApplicationBuilder\n\ndef configure_mapping(builder: WebApplicationBuilder):\n    \"\"\"Configure object mapping services\"\"\"\n\n    # Register mapper as singleton\n    mapper = Mapper()\n\n    # Add mapping profiles\n    mapper.add_profile(PizzeriaMappingProfile())\n    mapper.add_profile(CustomerMappingProfile())\n    mapper.add_profile(EventMappingProfile())\n\n    builder.services.add_singleton(Mapper, lambda: mapper)\n\n    # Register mapping services\n    builder.services.add_scoped(OrderMappingService)\n    builder.services.add_scoped(CustomerMappingService)\n\n# Usage in controllers\nclass MenuController(ControllerBase):\n    def __init__(self,\n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,  # Injected automatically\n                 mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n</code></pre>"},{"location":"features/object-mapping/#integration-points","title":"\ud83d\udd17 Integration Points","text":""},{"location":"features/object-mapping/#framework-integration","title":"Framework Integration","text":"<p>Object mapping integrates seamlessly with:</p> <ul> <li>Serialization - Map objects before serialization/after deserialization</li> <li>CQRS &amp; Mediation - Map requests to commands and queries</li> <li>MVC Controllers - Automatic request/response mapping</li> <li>Event Sourcing - Transform domain events to external formats</li> </ul>"},{"location":"features/object-mapping/#next-steps","title":"\ud83d\udcda Next Steps","text":"<p>Explore related Neuroglia features:</p> <ul> <li>Serialization - Convert mapped objects to JSON</li> <li>CQRS &amp; Mediation - Use mapping in command/query handlers</li> <li>MVC Controllers - Automatic API object mapping</li> <li>Getting Started Guide - Complete pizzeria implementation</li> </ul> <p>\ud83c\udfaf Best Practice</p> <p>Organize related mappings in profiles and register the Mapper as a singleton in your DI container for optimal performance and maintainability.</p>"},{"location":"features/observability/","title":"\ud83d\udd2d Observability with OpenTelemetry","text":"<p>Estimated reading time: 15 minutes</p>"},{"location":"features/observability/#what-why","title":"\ud83c\udfaf What &amp; Why","text":"<p>Observability is the ability to understand what's happening inside your application by examining its outputs. The Neuroglia framework provides comprehensive observability through OpenTelemetry integration, supporting the three pillars:</p> <ol> <li>Metrics - What's happening (counters, gauges, histograms)</li> <li>Tracing - Where requests flow (distributed traces across services)</li> <li>Logging - Why things happened (structured logs with trace correlation)</li> </ol>"},{"location":"features/observability/#the-problem-without-observability","title":"The Problem Without Observability","text":"<pre><code># \u274c Without observability - debugging is painful\n@app.post(\"/orders\")\nasync def create_order(data: dict):\n    # Why is this slow?\n    # Which service failed?\n    # How many orders per minute?\n    # What's the error rate?\n    order = await order_service.create(data)\n    return order\n</code></pre>"},{"location":"features/observability/#the-solution-with-observability","title":"The Solution With Observability","text":"<pre><code># \u2705 With observability - full visibility\nfrom neuroglia.observability import Observability\n\nbuilder = WebApplicationBuilder(app_settings)\nObservability.configure(builder)  # Automatic instrumentation!\n\n# Now you get:\n# - Automatic request tracing\n# - Response time metrics\n# - Correlated logs with trace IDs\n# - Service dependency maps\n# - Error rate tracking\n# - System metrics (CPU, memory)\n</code></pre>"},{"location":"features/observability/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"features/observability/#framework-style-configuration-recommended","title":"Framework-Style Configuration (Recommended)","text":"<p>The easiest way to enable observability is through <code>WebApplicationBuilder</code>:</p> <pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.observability import Observability, ApplicationSettingsWithObservability\n\n# Step 1: Use settings class with observability\nclass PizzeriaSettings(ApplicationSettingsWithObservability):\n    # Your app settings\n    database_url: str = Field(default=\"mongodb://localhost:27017\")\n\n    # Observability settings inherited:\n    # - service_name, service_version, deployment_environment\n    # - otel_enabled, otel_endpoint, tracing_enabled, metrics_enabled\n    # - instrument_fastapi, instrument_httpx, instrument_logging\n\n# Step 2: Configure observability\nbuilder = WebApplicationBuilder(PizzeriaSettings())\nObservability.configure(builder)  # Uses settings automatically\n\n# Step 3: Build and run\napp = builder.build()\napp.run()\n\n# \ud83c\udf89 You now have:\n# - /metrics endpoint with Prometheus metrics\n# - /health endpoint with service health\n# - Distributed tracing to OTLP collector\n# - Structured logs with trace correlation\n</code></pre>"},{"location":"features/observability/#manual-configuration-advanced","title":"Manual Configuration (Advanced)","text":"<p>For fine-grained control:</p> <pre><code>from neuroglia.observability import configure_opentelemetry\n\n# Configure OpenTelemetry directly\nconfigure_opentelemetry(\n    service_name=\"mario-pizzeria\",\n    service_version=\"1.0.0\",\n    otlp_endpoint=\"http://otel-collector:4317\",\n    enable_console_export=False,  # Set True for debugging\n    deployment_environment=\"production\",\n\n    # Instrumentation toggles\n    enable_fastapi_instrumentation=True,\n    enable_httpx_instrumentation=True,\n    enable_logging_instrumentation=True,\n    enable_system_metrics=True,\n\n    # Performance tuning\n    batch_span_processor_max_queue_size=2048,\n    batch_span_processor_schedule_delay_millis=5000,\n    metric_export_interval_millis=60000  # 1 minute\n)\n</code></pre>"},{"location":"features/observability/#core-components","title":"\ud83c\udfd7\ufe0f Core Components","text":""},{"location":"features/observability/#1-observability-framework-integration","title":"1. Observability Framework Integration","text":"<p>The <code>Observability</code> class provides framework-integrated configuration:</p> <pre><code>from neuroglia.observability import Observability\n\n# Basic configuration\nObservability.configure(builder)\n\n# With overrides\nObservability.configure(\n    builder,\n    tracing_enabled=True,      # Override from settings\n    metrics_enabled=True,      # Override from settings\n    logging_enabled=True       # Override from settings\n)\n</code></pre> <p>Key Features:</p> <ul> <li>Reads configuration from <code>app_settings</code> (must inherit from <code>ObservabilitySettingsMixin</code>)</li> <li>Configures OpenTelemetry SDK based on enabled pillars</li> <li>Registers <code>/metrics</code> and <code>/health</code> endpoints automatically</li> <li>Applies tracing middleware to CQRS handlers</li> </ul>"},{"location":"features/observability/#2-distributed-tracing","title":"2. Distributed Tracing","text":"<p>Trace requests across service boundaries with automatic span creation:</p> <pre><code>from neuroglia.observability import trace_async, get_tracer, add_span_attributes\n\n# Automatic tracing with decorator\n@trace_async(name=\"create_order\")  # Custom span name\nasync def create_order(order_data: dict):\n    # Span automatically created and closed\n\n    # Add custom attributes\n    add_span_attributes({\n        \"order.id\": order_data[\"id\"],\n        \"order.total\": order_data[\"total\"],\n        \"customer.type\": \"premium\"\n    })\n\n    # Call other services - trace propagates automatically\n    await payment_service.charge(order_data[\"total\"])\n    await inventory_service.reserve(order_data[\"items\"])\n\n    return order\n\n# Manual tracing for fine control\ntracer = get_tracer(__name__)\n\nasync def process_payment(amount: float):\n    with tracer.start_as_current_span(\"payment_processing\") as span:\n        span.set_attribute(\"payment.amount\", amount)\n\n        # Add events for important moments\n        from neuroglia.observability import add_span_event\n        add_span_event(\"payment_validated\", {\n            \"validation_result\": \"approved\"\n        })\n\n        result = await payment_gateway.charge(amount)\n        span.set_attribute(\"payment.transaction_id\", result.transaction_id)\n\n        return result\n</code></pre>"},{"location":"features/observability/#3-metrics-collection","title":"3. Metrics Collection","text":"<p>Create and record metrics for monitoring:</p> <pre><code>from neuroglia.observability import get_meter, create_counter, create_histogram\n\n# Get meter for your component\nmeter = get_meter(__name__)\n\n# Create metrics\norder_counter = create_counter(\n    meter,\n    name=\"orders_created_total\",\n    description=\"Total number of orders created\",\n    unit=\"orders\"\n)\n\norder_value_histogram = create_histogram(\n    meter,\n    name=\"order_value\",\n    description=\"Distribution of order values\",\n    unit=\"USD\"\n)\n\n# Record metrics\ndef record_order_created(order: Order):\n    order_counter.add(1, {\n        \"order.type\": order.order_type,\n        \"customer.segment\": order.customer_segment\n    })\n\n    order_value_histogram.record(order.total_amount, {\n        \"order.type\": order.order_type\n    })\n</code></pre> <p>Available Metric Types:</p> <ul> <li>Counter: Monotonically increasing value (e.g., total requests)</li> <li>UpDownCounter: Can increase or decrease (e.g., active connections)</li> <li>Histogram: Distribution of values (e.g., request duration)</li> <li>ObservableGauge: Callback-based metric (e.g., queue size)</li> </ul>"},{"location":"features/observability/#4-structured-logging-with-trace-correlation","title":"4. Structured Logging with Trace Correlation","text":"<p>Logs automatically include trace context:</p> <pre><code>from neuroglia.observability import get_logger_with_trace_context, log_with_trace\nimport logging\n\n# Get logger with automatic trace correlation\nlogger = get_logger_with_trace_context(__name__)\n\nasync def process_order(order_id: str):\n    # Logs automatically include trace_id and span_id\n    logger.info(f\"Processing order: {order_id}\")\n\n    try:\n        result = await order_service.process(order_id)\n        logger.info(f\"Order processed successfully: {order_id}\")\n        return result\n    except Exception as e:\n        # Exception automatically recorded in current span\n        logger.error(f\"Order processing failed: {order_id}\", exc_info=True)\n\n        # Record exception in span\n        from neuroglia.observability import record_exception\n        record_exception(e)\n        raise\n\n# Manual trace correlation\nlog_with_trace(\n    logger.info,\n    \"Custom log message\",\n    extra_attributes={\"custom.field\": \"value\"}\n)\n</code></pre>"},{"location":"features/observability/#real-world-example-marios-pizzeria","title":"\ud83d\udca1 Real-World Example: Mario's Pizzeria","text":"<p>Complete observability setup for Mario's Pizzeria:</p> <pre><code># settings.py\nfrom neuroglia.observability import ApplicationSettingsWithObservability\nfrom pydantic import Field\n\nclass PizzeriaSettings(ApplicationSettingsWithObservability):\n    # Application settings\n    database_url: str = Field(default=\"mongodb://localhost:27017\")\n    redis_url: str = Field(default=\"redis://localhost:6379\")\n\n    # Observability settings (inherited):\n    # service_name: str = \"mario-pizzeria\"\n    # service_version: str = \"1.0.0\"\n    # otel_enabled: bool = True\n    # otel_endpoint: str = \"http://otel-collector:4317\"\n    # tracing_enabled: bool = True\n    # metrics_enabled: bool = True\n    # logging_enabled: bool = True\n\n# main.py\nfrom neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.observability import Observability\n\ndef create_app():\n    # Load settings from environment\n    settings = PizzeriaSettings()\n\n    # Create builder with observability-enabled settings\n    builder = WebApplicationBuilder(settings)\n\n    # Register application services\n    services = builder.services\n    services.add_scoped(IOrderRepository, MongoOrderRepository)\n    services.add_scoped(OrderService)\n    services.add_mediator()\n\n    # Configure observability (automatic!)\n    Observability.configure(builder)\n\n    # Register controllers\n    builder.add_controllers([\"api.controllers\"], prefix=\"/api\")\n\n    # Build application\n    app = builder.build_app_with_lifespan(\n        title=\"Mario's Pizzeria API\",\n        version=\"1.0.0\"\n    )\n\n    return app\n\n# order_handler.py\nfrom neuroglia.observability import trace_async, add_span_attributes, create_counter, get_meter\nfrom neuroglia.mediation import CommandHandler\n\n# Create metrics\nmeter = get_meter(__name__)\norders_created = create_counter(meter, \"orders_created_total\", \"Total orders created\")\n\nclass CreateOrderHandler(CommandHandler[CreateOrderCommand, OperationResult[OrderDto]]):\n    def __init__(\n        self,\n        order_repository: IOrderRepository,\n        payment_service: PaymentService,\n        mapper: Mapper\n    ):\n        super().__init__()\n        self.order_repository = order_repository\n        self.payment_service = payment_service\n        self.mapper = mapper\n\n    @trace_async(name=\"create_order_handler\")  # Automatic tracing\n    async def handle_async(self, command: CreateOrderCommand) -&gt; OperationResult[OrderDto]:\n        # Add span attributes for filtering/analysis\n        add_span_attributes({\n            \"order.customer_id\": command.customer_id,\n            \"order.item_count\": len(command.items),\n            \"order.total\": command.total_amount\n        })\n\n        # Create order entity\n        order = Order(\n            customer_id=command.customer_id,\n            items=command.items,\n            total_amount=command.total_amount\n        )\n\n        # Process payment (automatically traced via httpx instrumentation)\n        payment_result = await self.payment_service.charge(\n            command.customer_id,\n            command.total_amount\n        )\n\n        if not payment_result.success:\n            return self.bad_request(\"Payment failed\")\n\n        # Save order (MongoDB operations automatically traced)\n        await self.order_repository.save_async(order)\n\n        # Record metric\n        orders_created.add(1, {\n            \"customer.segment\": \"premium\" if command.total_amount &gt; 50 else \"standard\"\n        })\n\n        # Return result (logs automatically include trace_id)\n        self.logger.info(f\"Order created successfully: {order.id}\")\n        return self.created(self.mapper.map(order, OrderDto))\n\n# Run the application\nif __name__ == \"__main__\":\n    import uvicorn\n    app = create_app()\n\n    # Uvicorn automatically instrumented via FastAPI instrumentation\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre> <p>What You Get:</p> <pre><code># Prometheus metrics at /metrics\ncurl http://localhost:8000/metrics\n\n# Sample output:\n# orders_created_total{customer_segment=\"premium\"} 42\n# orders_created_total{customer_segment=\"standard\"} 158\n# http_server_duration_milliseconds_bucket{http_route=\"/api/orders\",http_method=\"POST\",le=\"100\"} 95\n# http_server_active_requests{http_route=\"/api/orders\"} 3\n\n# Health check at /health\ncurl http://localhost:8000/health\n\n# Sample output:\n# {\n#   \"status\": \"healthy\",\n#   \"service\": \"mario-pizzeria\",\n#   \"version\": \"1.0.0\",\n#   \"timestamp\": \"2024-01-15T10:30:00Z\"\n# }\n\n# Traces exported to OTLP collector\n# - View in Jaeger UI: http://localhost:16686\n# - Each request shows full trace with:\n#   - HTTP request span\n#   - create_order_handler span\n#   - Payment service call span\n#   - MongoDB query spans\n#   - Timing for each operation\n\n# Logs with trace correlation\n# [2024-01-15 10:30:00] INFO [trace_id=abc123 span_id=def456] Order created successfully: ord_789\n</code></pre>"},{"location":"features/observability/#advanced-features","title":"\ud83d\udd27 Advanced Features","text":""},{"location":"features/observability/#1-custom-resource-attributes","title":"1. Custom Resource Attributes","text":"<p>Add metadata to all telemetry:</p> <pre><code>from neuroglia.observability import configure_opentelemetry\n\nconfigure_opentelemetry(\n    service_name=\"mario-pizzeria\",\n    service_version=\"1.0.0\",\n    additional_resource_attributes={\n        \"deployment.region\": \"us-east-1\",\n        \"deployment.zone\": \"zone-a\",\n        \"environment\": \"production\",\n        \"team\": \"backend\",\n        \"cost_center\": \"engineering\"\n    }\n)\n\n# All traces, metrics, and logs now include these attributes\n</code></pre>"},{"location":"features/observability/#2-custom-instrumentation","title":"2. Custom Instrumentation","text":"<p>Instrument specific code sections:</p> <pre><code>from neuroglia.observability import get_tracer, trace_sync\n\ntracer = get_tracer(__name__)\n\n# Async function tracing\n@trace_async(name=\"complex_calculation\")\nasync def complex_calculation(data: list):\n    with tracer.start_as_current_span(\"data_validation\"):\n        validated = validate_data(data)\n\n    with tracer.start_as_current_span(\"processing\"):\n        result = await process_data(validated)\n\n    with tracer.start_as_current_span(\"persistence\"):\n        await save_result(result)\n\n    return result\n\n# Sync function tracing\n@trace_sync(name=\"legacy_sync_function\")\ndef legacy_function(x: int) -&gt; int:\n    return x * 2\n</code></pre>"},{"location":"features/observability/#3-performance-tuning","title":"3. Performance Tuning","text":"<p>Optimize for high-throughput scenarios:</p> <pre><code>from neuroglia.observability import configure_opentelemetry\n\nconfigure_opentelemetry(\n    service_name=\"high-throughput-service\",\n\n    # Increase queue size for high request volume\n    batch_span_processor_max_queue_size=8192,  # Default: 2048\n\n    # Export more frequently\n    batch_span_processor_schedule_delay_millis=2000,  # Default: 5000 (5s)\n\n    # Larger export batches\n    batch_span_processor_max_export_batch_size=1024,  # Default: 512\n\n    # Metrics export every 30 seconds instead of 60\n    metric_export_interval_millis=30000,\n    metric_export_timeout_millis=15000\n)\n</code></pre>"},{"location":"features/observability/#4-context-propagation","title":"4. Context Propagation","text":"<p>Propagate trace context across service boundaries:</p> <pre><code>from neuroglia.observability import add_baggage, get_baggage\nimport httpx\n\nasync def call_external_service():\n    # Add baggage (propagates with trace)\n    add_baggage(\"user.id\", \"user_123\")\n    add_baggage(\"request.priority\", \"high\")\n\n    # HTTPx automatically includes trace headers\n    async with httpx.AsyncClient() as client:\n        response = await client.post(\n            \"http://other-service/api/process\",\n            json={\"data\": \"value\"}\n        )\n        # Trace context automatically propagated!\n\n# In the other service:\nasync def process_request():\n    # Retrieve baggage\n    user_id = get_baggage(\"user.id\")  # \"user_123\"\n    priority = get_baggage(\"request.priority\")  # \"high\"\n</code></pre>"},{"location":"features/observability/#5-selective-instrumentation","title":"5. Selective Instrumentation","text":"<p>Control which components get instrumented:</p> <pre><code>from pydantic import Field\n\nclass PizzeriaSettings(ApplicationSettingsWithObservability):\n    # Fine-grained control over instrumentation\n    otel_instrument_fastapi: bool = Field(default=True)\n    otel_instrument_httpx: bool = Field(default=True)\n    otel_instrument_logging: bool = Field(default=True)\n    otel_instrument_system_metrics: bool = Field(default=False)  # Disable for serverless\n\nbuilder = WebApplicationBuilder(settings)\nObservability.configure(builder)  # Respects instrumentation flags\n</code></pre>"},{"location":"features/observability/#testing-with-observability","title":"\ud83e\uddea Testing with Observability","text":"<p>Test observability components in your test suite:</p> <pre><code>import pytest\nfrom neuroglia.observability import configure_opentelemetry, get_tracer, get_meter\n\n@pytest.fixture\ndef observability_configured():\n    \"\"\"Configure observability for tests\"\"\"\n    configure_opentelemetry(\n        service_name=\"mario-pizzeria-test\",\n        service_version=\"test\",\n        enable_console_export=True,  # See traces in test output\n        otlp_endpoint=\"http://localhost:4317\"\n    )\n    yield\n\n    from neuroglia.observability import shutdown_opentelemetry\n    shutdown_opentelemetry()\n\n@pytest.mark.asyncio\nasync def test_order_handler_creates_span(observability_configured):\n    \"\"\"Test that handler creates trace span\"\"\"\n    tracer = get_tracer(__name__)\n\n    # Execute handler\n    handler = CreateOrderHandler(mock_repository, mock_payment)\n    command = CreateOrderCommand(customer_id=\"123\", items=[], total_amount=50.0)\n\n    with tracer.start_as_current_span(\"test_span\") as span:\n        result = await handler.handle_async(command)\n\n        # Verify span created\n        assert span.is_recording()\n        assert result.is_success\n\n@pytest.mark.asyncio\nasync def test_metrics_recorded():\n    \"\"\"Test that metrics are recorded correctly\"\"\"\n    meter = get_meter(__name__)\n    counter = meter.create_counter(\"test_counter\")\n\n    # Record metric\n    counter.add(1, {\"test\": \"value\"})\n\n    # Verify (in real tests, you'd check Prometheus endpoint)\n    # In tests, just verify no exceptions\n    assert True\n</code></pre>"},{"location":"features/observability/#common-mistakes","title":"\u26a0\ufe0f Common Mistakes","text":""},{"location":"features/observability/#1-forgetting-to-configure-before-running","title":"1. Forgetting to Configure Before Running","text":"<pre><code># \u274c Wrong - observability not configured\napp = FastAPI()\nuvicorn.run(app)  # No traces, no metrics\n\n# \u2705 Correct - configure during app setup\nbuilder = WebApplicationBuilder(settings)\nObservability.configure(builder)\napp = builder.build()\nuvicorn.run(app)  # Full observability!\n</code></pre>"},{"location":"features/observability/#2-instrumenting-sub-apps","title":"2. Instrumenting Sub-Apps","text":"<pre><code># \u274c Wrong - duplicate instrumentation\nfrom neuroglia.observability import instrument_fastapi_app\n\napp = FastAPI()\napi_app = FastAPI()\napp.mount(\"/api\", api_app)\n\ninstrument_fastapi_app(app, \"main\")\ninstrument_fastapi_app(api_app, \"api\")  # Causes warnings!\n\n# \u2705 Correct - only instrument main app\ninstrument_fastapi_app(app, \"main\")  # Captures all endpoints\n</code></pre>"},{"location":"features/observability/#3-missing-settings-mixin","title":"3. Missing Settings Mixin","text":"<pre><code># \u274c Wrong - no observability settings\nclass MySettings(ApplicationSettings):\n    database_url: str\n\nbuilder = WebApplicationBuilder(MySettings())\nObservability.configure(builder)  # Raises ValueError!\n\n# \u2705 Correct - inherit from ApplicationSettingsWithObservability\nclass MySettings(ApplicationSettingsWithObservability):\n    database_url: str\n\nbuilder = WebApplicationBuilder(MySettings())\nObservability.configure(builder)  # Works!\n</code></pre>"},{"location":"features/observability/#when-not-to-use","title":"\ud83d\udeab When NOT to Use","text":""},{"location":"features/observability/#1-serverless-functions-with-cold-start-sensitivity","title":"1. Serverless Functions with Cold Start Sensitivity","text":"<p>OpenTelemetry adds ~100-200ms to cold starts. For AWS Lambda or similar:</p> <pre><code># Consider lightweight alternatives:\n# - CloudWatch Logs only\n# - X-Ray for tracing\n# - Custom metrics to CloudWatch\n</code></pre>"},{"location":"features/observability/#2-ultra-high-throughput-services","title":"2. Ultra-High Throughput Services","text":"<p>For services handling &gt;100k requests/second:</p> <pre><code># Consider:\n# - Sampling traces (only 1% of requests)\n# - Tail-based sampling\n# - Metrics-only observability\n# - Custom lightweight instrumentation\n</code></pre>"},{"location":"features/observability/#3-developmentprototyping","title":"3. Development/Prototyping","text":"<p>For quick prototypes:</p> <pre><code># Simple logging may be sufficient:\nimport logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\nlogger.info(\"Order created\")\n</code></pre>"},{"location":"features/observability/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ol> <li>Framework Integration: Use <code>Observability.configure(builder)</code> for automatic setup</li> <li>Three Pillars: Traces show flow, metrics show health, logs show details</li> <li>Automatic Instrumentation: FastAPI, HTTPx, and logging instrumented by default</li> <li>Trace Correlation: Logs automatically include trace_id and span_id</li> <li>Decorator Pattern: Use <code>@trace_async()</code> for easy span creation</li> <li>Performance Aware: Tune batch processing for your throughput needs</li> </ol>"},{"location":"features/observability/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Initial framework setup</li> <li>Tutorial Part 8: Observability - Step-by-step observability guide</li> <li>Application Hosting - WebApplicationBuilder integration</li> <li>CQRS &amp; Mediation - Handler tracing integration</li> </ul>"},{"location":"features/observability/#api-reference","title":"\ud83d\udcda API Reference","text":""},{"location":"features/observability/#observabilityconfigure","title":"Observability.configure()","text":"<pre><code>@classmethod\ndef configure(\n    cls,\n    builder: WebApplicationBuilder,\n    **overrides\n) -&gt; None:\n    \"\"\"\n    Configure comprehensive observability for the application.\n\n    Args:\n        builder: WebApplicationBuilder with app_settings\n        **overrides: Optional configuration overrides\n                     (tracing_enabled, metrics_enabled, logging_enabled)\n\n    Raises:\n        ValueError: If app_settings doesn't have observability configuration\n    \"\"\"\n</code></pre>"},{"location":"features/observability/#configure_opentelemetry","title":"configure_opentelemetry()","text":"<pre><code>def configure_opentelemetry(\n    service_name: str,\n    service_version: str = \"unknown\",\n    otlp_endpoint: str = \"http://localhost:4317\",\n    enable_console_export: bool = False,\n    deployment_environment: str = \"development\",\n    additional_resource_attributes: Optional[dict[str, str]] = None,\n    enable_fastapi_instrumentation: bool = True,\n    enable_httpx_instrumentation: bool = True,\n    enable_logging_instrumentation: bool = True,\n    enable_system_metrics: bool = False,\n    batch_span_processor_max_queue_size: int = 2048,\n    batch_span_processor_schedule_delay_millis: int = 5000,\n    batch_span_processor_max_export_batch_size: int = 512,\n    metric_export_interval_millis: int = 60000,\n    metric_export_timeout_millis: int = 30000\n) -&gt; None:\n    \"\"\"\n    Configure OpenTelemetry SDK with comprehensive observability setup.\n\n    Initializes tracing, metrics, logging, and instrumentation.\n    \"\"\"\n</code></pre>"},{"location":"features/observability/#trace_async-trace_sync","title":"@trace_async() / @trace_sync()","text":"<pre><code>def trace_async(name: Optional[str] = None) -&gt; Callable:\n    \"\"\"\n    Decorator for automatic async function tracing.\n\n    Args:\n        name: Optional span name (defaults to function name)\n\n    Returns:\n        Decorator function\n    \"\"\"\n\ndef trace_sync(name: Optional[str] = None) -&gt; Callable:\n    \"\"\"\n    Decorator for automatic sync function tracing.\n\n    Args:\n        name: Optional span name (defaults to function name)\n\n    Returns:\n        Decorator function\n    \"\"\"\n</code></pre>"},{"location":"features/observability/#get_tracer","title":"get_tracer()","text":"<pre><code>def get_tracer(name: str) -&gt; Tracer:\n    \"\"\"\n    Get a tracer instance for manual instrumentation.\n\n    Args:\n        name: Tracer name (typically __name__)\n\n    Returns:\n        OpenTelemetry Tracer instance\n    \"\"\"\n</code></pre>"},{"location":"features/observability/#get_meter","title":"get_meter()","text":"<pre><code>def get_meter(name: str) -&gt; Meter:\n    \"\"\"\n    Get a meter instance for creating metrics.\n\n    Args:\n        name: Meter name (typically __name__)\n\n    Returns:\n        OpenTelemetry Meter instance\n    \"\"\"\n</code></pre>"},{"location":"features/observability/#applicationsettingswithobservability","title":"ApplicationSettingsWithObservability","text":"<pre><code>class ApplicationSettingsWithObservability(ApplicationSettings, ObservabilitySettingsMixin):\n    \"\"\"\n    Base settings class with built-in observability configuration.\n\n    Attributes:\n        service_name: str = Field(default=\"neuroglia-service\")\n        service_version: str = Field(default=\"1.0.0\")\n        deployment_environment: str = Field(default=\"development\")\n        otel_enabled: bool = Field(default=True)\n        otel_endpoint: str = Field(default=\"http://localhost:4317\")\n        otel_console_export: bool = Field(default=False)\n        tracing_enabled: bool = Field(default=True)\n        metrics_enabled: bool = Field(default=True)\n        logging_enabled: bool = Field(default=True)\n        instrument_fastapi: bool = Field(default=True)\n        instrument_httpx: bool = Field(default=True)\n        instrument_logging: bool = Field(default=True)\n        instrument_system_metrics: bool = Field(default=True)\n    \"\"\"\n</code></pre>"},{"location":"features/redis-cache-repository/","title":"\u26a1 Redis Cache Repository","text":"<p>The Neuroglia framework provides high-performance distributed caching through Redis integration, enabling scalable data access patterns with advanced features like distributed locking, hash-based storage, and automatic expiration management.</p>"},{"location":"features/redis-cache-repository/#overview","title":"\ud83c\udfaf Overview","text":"<p>Redis caching is essential for modern microservices that need fast data access, session management, and distributed coordination. The framework's Redis implementation provides:</p> <ul> <li>Distributed Caching: Shared cache across multiple service instances</li> <li>Advanced Data Structures: Strings, hashes, lists, sets, and sorted sets</li> <li>Distributed Locking: Coordination across service instances</li> <li>Automatic Expiration: TTL-based cache invalidation</li> <li>Connection Pooling: Optimized Redis connection management</li> <li>Circuit Breaker: Resilience against Redis unavailability</li> </ul>"},{"location":"features/redis-cache-repository/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>graph TB\n    subgraph \"\ud83c\udf55 Mario's Pizzeria Services\"\n        OrderService[Order Service]\n        MenuService[Menu Service]\n        CustomerService[Customer Service]\n        InventoryService[Inventory Service]\n    end\n\n    subgraph \"\u26a1 Redis Cache Layer\"\n        RedisCache[Redis Cache Repository]\n        DistributedLock[Distributed Lock Manager]\n        ConnectionPool[Connection Pool]\n    end\n\n    subgraph \"\ud83d\udcbe Redis Data Structures\"\n        Strings[String Cache]\n        Hashes[Hash Storage]\n        Sets[Set Operations]\n        SortedSets[Sorted Sets]\n    end\n\n    subgraph \"\ud83d\uddc4\ufe0f Data Sources\"\n        MenuDB[(Menu Database)]\n        OrderDB[(Order Database)]\n        CustomerDB[(Customer Database)]\n    end\n\n    OrderService --&gt; RedisCache\n    MenuService --&gt; RedisCache\n    CustomerService --&gt; RedisCache\n    InventoryService --&gt; RedisCache\n\n    RedisCache --&gt; DistributedLock\n    RedisCache --&gt; ConnectionPool\n\n    ConnectionPool --&gt; Strings\n    ConnectionPool --&gt; Hashes\n    ConnectionPool --&gt; Sets\n    ConnectionPool --&gt; SortedSets\n\n    RedisCache -.-&gt;|Cache Miss| MenuDB\n    RedisCache -.-&gt;|Cache Miss| OrderDB\n    RedisCache -.-&gt;|Cache Miss| CustomerDB\n\n    style RedisCache fill:#e3f2fd\n    style DistributedLock fill:#ffebee\n    style ConnectionPool fill:#e8f5e8</code></pre>"},{"location":"features/redis-cache-repository/#basic-usage","title":"\ud83d\ude80 Basic Usage","text":""},{"location":"features/redis-cache-repository/#service-registration","title":"Service Registration","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.data.redis import RedisRepository, RedisConfig\n\ndef create_app():\n    builder = WebApplicationBuilder()\n\n    # Register Redis cache repository\n    redis_config = RedisConfig(\n        host=\"localhost\",\n        port=6379,\n        db=0,\n        password=\"your_redis_password\",\n        connection_pool_size=20,\n        health_check_interval=30\n    )\n\n    builder.services.add_redis_repository(redis_config)\n\n    app = builder.build()\n    return app\n</code></pre>"},{"location":"features/redis-cache-repository/#simple-cache-operations","title":"Simple Cache Operations","text":"<pre><code>from neuroglia.data.redis import RedisRepository\nfrom neuroglia.dependency_injection import ServiceProviderBase\nimport json\nfrom datetime import timedelta\n\nclass MenuCacheService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.redis = service_provider.get_service(RedisRepository)\n        self.cache_prefix = \"mario_pizzeria:menu\"\n\n    async def cache_menu_item(self, item_id: str, menu_item: dict, ttl_hours: int = 24):\n        \"\"\"Cache a menu item with automatic expiration.\"\"\"\n        cache_key = f\"{self.cache_prefix}:item:{item_id}\"\n        cache_value = json.dumps(menu_item)\n\n        await self.redis.set_async(\n            key=cache_key,\n            value=cache_value,\n            expiration=timedelta(hours=ttl_hours)\n        )\n\n        print(f\"\ud83c\udf55 Cached menu item: {menu_item['name']} (expires in {ttl_hours}h)\")\n\n    async def get_cached_menu_item(self, item_id: str) -&gt; dict:\n        \"\"\"Retrieve cached menu item.\"\"\"\n        cache_key = f\"{self.cache_prefix}:item:{item_id}\"\n\n        cached_value = await self.redis.get_async(cache_key)\n\n        if cached_value:\n            return json.loads(cached_value)\n\n        # Cache miss - load from database\n        menu_item = await self.load_menu_item_from_db(item_id)\n        if menu_item:\n            await self.cache_menu_item(item_id, menu_item)\n\n        return menu_item\n\n    async def invalidate_menu_cache(self, item_id: str = None):\n        \"\"\"Invalidate menu cache entries.\"\"\"\n        if item_id:\n            # Invalidate specific item\n            cache_key = f\"{self.cache_prefix}:item:{item_id}\"\n            await self.redis.delete_async(cache_key)\n        else:\n            # Invalidate all menu items\n            pattern = f\"{self.cache_prefix}:item:*\"\n            await self.redis.delete_pattern_async(pattern)\n\n        print(f\"\ud83d\uddd1\ufe0f Menu cache invalidated: {item_id or 'all items'}\")\n</code></pre>"},{"location":"features/redis-cache-repository/#hash-based-storage","title":"\ud83d\udce6 Hash-Based Storage","text":""},{"location":"features/redis-cache-repository/#customer-session-management","title":"Customer Session Management","text":"<pre><code>from neuroglia.data.redis import RedisHashRepository\n\nclass CustomerSessionService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.redis = service_provider.get_service(RedisRepository)\n        self.session_prefix = \"mario_pizzeria:sessions\"\n\n    async def create_customer_session(self, customer_id: str, session_data: dict):\n        \"\"\"Create customer session using Redis hash.\"\"\"\n        session_key = f\"{self.session_prefix}:{customer_id}\"\n\n        # Store session data as hash fields\n        session_fields = {\n            \"customer_id\": customer_id,\n            \"login_time\": str(datetime.utcnow()),\n            \"cart_items\": json.dumps(session_data.get(\"cart_items\", [])),\n            \"preferences\": json.dumps(session_data.get(\"preferences\", {})),\n            \"last_activity\": str(datetime.utcnow())\n        }\n\n        await self.redis.hset_async(session_key, session_fields)\n        await self.redis.expire_async(session_key, timedelta(hours=4))  # 4-hour session\n\n        print(f\"\ud83d\udc64 Created session for customer {customer_id}\")\n\n    async def update_customer_cart(self, customer_id: str, cart_items: list):\n        \"\"\"Update customer cart in session.\"\"\"\n        session_key = f\"{self.session_prefix}:{customer_id}\"\n\n        # Update specific hash fields\n        updates = {\n            \"cart_items\": json.dumps(cart_items),\n            \"last_activity\": str(datetime.utcnow())\n        }\n\n        await self.redis.hset_async(session_key, updates)\n        print(f\"\ud83d\uded2 Updated cart for customer {customer_id}: {len(cart_items)} items\")\n\n    async def get_customer_session(self, customer_id: str) -&gt; dict:\n        \"\"\"Retrieve complete customer session.\"\"\"\n        session_key = f\"{self.session_prefix}:{customer_id}\"\n\n        session_data = await self.redis.hgetall_async(session_key)\n\n        if not session_data:\n            return None\n\n        # Deserialize JSON fields\n        return {\n            \"customer_id\": session_data.get(\"customer_id\"),\n            \"login_time\": session_data.get(\"login_time\"),\n            \"cart_items\": json.loads(session_data.get(\"cart_items\", \"[]\")),\n            \"preferences\": json.loads(session_data.get(\"preferences\", \"{}\")),\n            \"last_activity\": session_data.get(\"last_activity\")\n        }\n\n    async def get_customer_cart(self, customer_id: str) -&gt; list:\n        \"\"\"Get only the cart items from customer session.\"\"\"\n        session_key = f\"{self.session_prefix}:{customer_id}\"\n\n        cart_json = await self.redis.hget_async(session_key, \"cart_items\")\n        return json.loads(cart_json) if cart_json else []\n</code></pre>"},{"location":"features/redis-cache-repository/#distributed-locking","title":"\ud83d\udd12 Distributed Locking","text":""},{"location":"features/redis-cache-repository/#order-processing-coordination","title":"Order Processing Coordination","text":"<pre><code>from neuroglia.data.redis import DistributedLock, LockTimeoutError\nimport asyncio\n\nclass OrderProcessingService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.redis = service_provider.get_service(RedisRepository)\n        self.lock_timeout = 30  # 30 seconds\n\n    async def process_order_safely(self, order_id: str):\n        \"\"\"Process order with distributed locking to prevent race conditions.\"\"\"\n        lock_key = f\"mario_pizzeria:order_lock:{order_id}\"\n\n        async with DistributedLock(self.redis, lock_key, timeout=self.lock_timeout):\n            try:\n                # Critical section - only one service instance can process this order\n                order = await self.get_order(order_id)\n\n                if order.status != \"pending\":\n                    print(f\"\u26a0\ufe0f Order {order_id} already processed\")\n                    return\n\n                # Process the order\n                await self.validate_inventory(order)\n                await self.charge_customer(order)\n                await self.update_order_status(order_id, \"processing\")\n                await self.notify_kitchen(order)\n\n                print(f\"\u2705 Order {order_id} processed successfully\")\n\n            except InventoryShortageError as e:\n                await self.handle_inventory_shortage(order_id, e)\n            except PaymentError as e:\n                await self.handle_payment_failure(order_id, e)\n\n    async def coordinate_inventory_update(self, ingredient_id: str, quantity_change: int):\n        \"\"\"Update inventory with distributed coordination.\"\"\"\n        lock_key = f\"mario_pizzeria:inventory_lock:{ingredient_id}\"\n\n        try:\n            async with DistributedLock(self.redis, lock_key, timeout=10):\n                # Get current inventory\n                current_stock = await self.get_ingredient_stock(ingredient_id)\n\n                # Validate the change\n                new_stock = current_stock + quantity_change\n                if new_stock &lt; 0:\n                    raise InsufficientInventoryError(\n                        f\"Cannot reduce {ingredient_id} by {abs(quantity_change)}. \"\n                        f\"Current stock: {current_stock}\"\n                    )\n\n                # Update inventory atomically\n                await self.update_ingredient_stock(ingredient_id, new_stock)\n\n                # Update cache\n                await self.cache_ingredient_stock(ingredient_id, new_stock)\n\n                print(f\"\ud83d\udce6 Inventory updated: {ingredient_id} = {new_stock}\")\n\n        except LockTimeoutError:\n            print(f\"\u23f0 Could not acquire inventory lock for {ingredient_id}\")\n            raise ConcurrentUpdateError(\"Inventory update failed due to concurrent access\")\n</code></pre>"},{"location":"features/redis-cache-repository/#kitchen-queue-management","title":"Kitchen Queue Management","text":"<pre><code>class KitchenQueueService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.redis = service_provider.get_service(RedisRepository)\n        self.queue_key = \"mario_pizzeria:kitchen_queue\"\n        self.processing_key = \"mario_pizzeria:kitchen_processing\"\n\n    async def add_order_to_queue(self, order_id: str, priority: int = 0):\n        \"\"\"Add order to kitchen queue with priority.\"\"\"\n        # Use Redis sorted set for priority queue\n        order_data = {\n            \"order_id\": order_id,\n            \"queued_at\": datetime.utcnow().isoformat(),\n            \"priority\": priority\n        }\n\n        await self.redis.zadd_async(\n            self.queue_key,\n            {json.dumps(order_data): priority}\n        )\n\n        print(f\"\ud83d\udc68\u200d\ud83c\udf73 Added order {order_id} to kitchen queue (priority: {priority})\")\n\n    async def get_next_order(self, kitchen_station_id: str) -&gt; dict:\n        \"\"\"Get next order for kitchen processing with distributed coordination.\"\"\"\n        lock_key = f\"mario_pizzeria:queue_lock\"\n\n        async with DistributedLock(self.redis, lock_key, timeout=5):\n            # Get highest priority order\n            orders = await self.redis.zrange_async(\n                self.queue_key,\n                0, 0,\n                desc=True,\n                withscores=True\n            )\n\n            if not orders:\n                return None\n\n            order_json, priority = orders[0]\n            order_data = json.loads(order_json)\n\n            # Move from queue to processing\n            await self.redis.zrem_async(self.queue_key, order_json)\n\n            processing_data = {\n                **order_data,\n                \"kitchen_station\": kitchen_station_id,\n                \"started_at\": datetime.utcnow().isoformat()\n            }\n\n            await self.redis.hset_async(\n                self.processing_key,\n                order_data[\"order_id\"],\n                json.dumps(processing_data)\n            )\n\n            return order_data\n\n    async def complete_order_processing(self, order_id: str):\n        \"\"\"Mark order processing as complete.\"\"\"\n        await self.redis.hdel_async(self.processing_key, order_id)\n        print(f\"\u2705 Order {order_id} processing completed\")\n</code></pre>"},{"location":"features/redis-cache-repository/#advanced-data-structures","title":"\ud83d\udcca Advanced Data Structures","text":""},{"location":"features/redis-cache-repository/#real-time-analytics-with-sorted-sets","title":"Real-time Analytics with Sorted Sets","text":"<pre><code>class PizzaAnalyticsService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.redis = service_provider.get_service(RedisRepository)\n        self.analytics_prefix = \"mario_pizzeria:analytics\"\n\n    async def track_popular_pizzas(self, pizza_name: str):\n        \"\"\"Track pizza popularity using sorted sets.\"\"\"\n        popularity_key = f\"{self.analytics_prefix}:pizza_popularity\"\n\n        # Increment pizza order count\n        await self.redis.zincrby_async(popularity_key, 1, pizza_name)\n\n        # Keep only top 50 pizzas\n        await self.redis.zremrangebyrank_async(popularity_key, 0, -51)\n\n    async def get_top_pizzas(self, limit: int = 10) -&gt; list:\n        \"\"\"Get most popular pizzas.\"\"\"\n        popularity_key = f\"{self.analytics_prefix}:pizza_popularity\"\n\n        top_pizzas = await self.redis.zrevrange_async(\n            popularity_key,\n            0,\n            limit - 1,\n            withscores=True\n        )\n\n        return [\n            {\"name\": pizza.decode(), \"order_count\": int(score)}\n            for pizza, score in top_pizzas\n        ]\n\n    async def track_hourly_orders(self, hour: int):\n        \"\"\"Track orders per hour using hash.\"\"\"\n        today = datetime.now().date().isoformat()\n        hourly_key = f\"{self.analytics_prefix}:hourly:{today}\"\n\n        await self.redis.hincrby_async(hourly_key, str(hour), 1)\n        await self.redis.expire_async(hourly_key, timedelta(days=7))  # Keep for a week\n\n    async def get_hourly_distribution(self, date: str = None) -&gt; dict:\n        \"\"\"Get order distribution by hour.\"\"\"\n        if not date:\n            date = datetime.now().date().isoformat()\n\n        hourly_key = f\"{self.analytics_prefix}:hourly:{date}\"\n        hourly_data = await self.redis.hgetall_async(hourly_key)\n\n        return {\n            int(hour): int(count)\n            for hour, count in hourly_data.items()\n        }\n</code></pre>"},{"location":"features/redis-cache-repository/#set-operations-for-customer-segmentation","title":"Set Operations for Customer Segmentation","text":"<pre><code>class CustomerSegmentationService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.redis = service_provider.get_service(RedisRepository)\n        self.segment_prefix = \"mario_pizzeria:segments\"\n\n    async def add_customer_to_segment(self, customer_id: str, segment: str):\n        \"\"\"Add customer to marketing segment.\"\"\"\n        segment_key = f\"{self.segment_prefix}:{segment}\"\n        await self.redis.sadd_async(segment_key, customer_id)\n\n        # Set segment expiration (30 days)\n        await self.redis.expire_async(segment_key, timedelta(days=30))\n\n    async def get_segment_customers(self, segment: str) -&gt; set:\n        \"\"\"Get all customers in a segment.\"\"\"\n        segment_key = f\"{self.segment_prefix}:{segment}\"\n        return await self.redis.smembers_async(segment_key)\n\n    async def find_overlapping_customers(self, segment1: str, segment2: str) -&gt; set:\n        \"\"\"Find customers in both segments.\"\"\"\n        key1 = f\"{self.segment_prefix}:{segment1}\"\n        key2 = f\"{self.segment_prefix}:{segment2}\"\n\n        return await self.redis.sinter_async([key1, key2])\n\n    async def create_targeted_campaign(self, segments: list, campaign_id: str):\n        \"\"\"Create campaign targeting multiple segments.\"\"\"\n        segment_keys = [f\"{self.segment_prefix}:{seg}\" for seg in segments]\n        campaign_key = f\"{self.segment_prefix}:campaign:{campaign_id}\"\n\n        # Union of all target segments\n        await self.redis.sunionstore_async(campaign_key, segment_keys)\n\n        # Campaign expires in 7 days\n        await self.redis.expire_async(campaign_key, timedelta(days=7))\n\n        target_count = await self.redis.scard_async(campaign_key)\n        print(f\"\ud83c\udfaf Campaign {campaign_id} targets {target_count} customers\")\n\n        return target_count\n</code></pre>"},{"location":"features/redis-cache-repository/#circuit-breaker-and-resilience","title":"\ud83d\udee1\ufe0f Circuit Breaker and Resilience","text":""},{"location":"features/redis-cache-repository/#resilient-cache-operations","title":"Resilient Cache Operations","text":"<pre><code>from neuroglia.data.redis import CircuitBreakerPolicy, CacheException\n\nclass ResilientMenuService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.redis = service_provider.get_service(RedisRepository)\n        self.circuit_breaker = CircuitBreakerPolicy(\n            failure_threshold=5,\n            recovery_timeout=60,\n            success_threshold=3\n        )\n        self.fallback_cache = {}  # In-memory fallback\n\n    @circuit_breaker.apply\n    async def get_menu_with_fallback(self, menu_id: str) -&gt; dict:\n        \"\"\"Get menu with circuit breaker and fallback.\"\"\"\n        try:\n            # Try Redis cache first\n            cache_key = f\"mario_pizzeria:menu:{menu_id}\"\n            cached_menu = await self.redis.get_async(cache_key)\n\n            if cached_menu:\n                menu_data = json.loads(cached_menu)\n                # Update fallback cache\n                self.fallback_cache[menu_id] = menu_data\n                return menu_data\n\n            # Cache miss - load from database\n            menu_data = await self.load_menu_from_database(menu_id)\n\n            # Cache in Redis\n            await self.redis.set_async(\n                cache_key,\n                json.dumps(menu_data),\n                expiration=timedelta(hours=6)\n            )\n\n            # Update fallback cache\n            self.fallback_cache[menu_id] = menu_data\n            return menu_data\n\n        except CacheException as e:\n            print(f\"\u26a0\ufe0f Redis unavailable, using fallback cache: {e}\")\n\n            # Use fallback cache\n            if menu_id in self.fallback_cache:\n                return self.fallback_cache[menu_id]\n\n            # Last resort - load from database\n            return await self.load_menu_from_database(menu_id)\n\n    async def warm_fallback_cache(self):\n        \"\"\"Pre-load frequently accessed items into fallback cache.\"\"\"\n        popular_menus = [\"margherita\", \"pepperoni\", \"quattro_stagioni\"]\n\n        for menu_id in popular_menus:\n            try:\n                menu_data = await self.get_menu_with_fallback(menu_id)\n                self.fallback_cache[menu_id] = menu_data\n            except Exception as e:\n                print(f\"Failed to warm cache for {menu_id}: {e}\")\n</code></pre>"},{"location":"features/redis-cache-repository/#advanced-configuration","title":"\ud83d\udd27 Advanced Configuration","text":""},{"location":"features/redis-cache-repository/#connection-pool-and-performance-tuning","title":"Connection Pool and Performance Tuning","text":"<pre><code>from neuroglia.data.redis import RedisConfig, ConnectionPoolConfig\n\ndef create_optimized_redis_config():\n    connection_config = ConnectionPoolConfig(\n        max_connections=50,\n        retry_on_timeout=True,\n        health_check_interval=30,\n\n        # Connection timeouts\n        socket_timeout=2.0,\n        socket_connect_timeout=2.0,\n\n        # Connection pooling\n        connection_pool_class_kwargs={\n            'max_connections_per_pool': 50,\n            'retry_on_timeout': True,\n            'socket_keepalive': True,\n            'socket_keepalive_options': {},\n        },\n\n        # Cluster configuration (if using Redis Cluster)\n        skip_full_coverage_check=True,\n        decode_responses=True\n    )\n\n    redis_config = RedisConfig(\n        host=\"redis://localhost:6379\",\n        connection_pool=connection_config,\n\n        # Performance settings\n        retry_policy={\n            'retries': 3,\n            'retry_delay': 0.1,\n            'backoff_factor': 2,\n            'max_retry_delay': 1.0\n        },\n\n        # Monitoring\n        enable_metrics=True,\n        metrics_prefix=\"mario_pizzeria_redis\",\n\n        # Security\n        ssl_cert_reqs=None,\n        ssl_ca_certs=None,\n        ssl_keyfile=None,\n        ssl_certfile=None\n    )\n\n    return redis_config\n</code></pre>"},{"location":"features/redis-cache-repository/#custom-serialization-strategies","title":"Custom Serialization Strategies","text":"<pre><code>from neuroglia.data.redis import SerializationStrategy\nimport pickle\nimport msgpack\n\nclass CustomSerializationService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.redis = service_provider.get_service(RedisRepository)\n\n    async def cache_with_msgpack(self, key: str, data: dict):\n        \"\"\"Cache data using MessagePack serialization.\"\"\"\n        serialized = msgpack.packb(data)\n        await self.redis.set_async(key, serialized)\n\n    async def get_with_msgpack(self, key: str) -&gt; dict:\n        \"\"\"Retrieve data with MessagePack deserialization.\"\"\"\n        serialized = await self.redis.get_async(key)\n        if serialized:\n            return msgpack.unpackb(serialized, raw=False)\n        return None\n\n    async def cache_complex_object(self, key: str, obj):\n        \"\"\"Cache complex Python objects using pickle.\"\"\"\n        serialized = pickle.dumps(obj)\n        await self.redis.set_async(key, serialized)\n\n    async def get_complex_object(self, key: str):\n        \"\"\"Retrieve complex Python objects.\"\"\"\n        serialized = await self.redis.get_async(key)\n        if serialized:\n            return pickle.loads(serialized)\n        return None\n</code></pre>"},{"location":"features/redis-cache-repository/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"features/redis-cache-repository/#unit-testing-with-redis-mock","title":"Unit Testing with Redis Mock","text":"<pre><code>import pytest\nfrom unittest.mock import AsyncMock, Mock\nfrom neuroglia.data.redis import RedisRepository\n\nclass TestMenuCacheService:\n\n    @pytest.fixture\n    def mock_redis(self):\n        redis = Mock(spec=RedisRepository)\n        redis.get_async = AsyncMock()\n        redis.set_async = AsyncMock()\n        redis.delete_async = AsyncMock()\n        redis.hget_async = AsyncMock()\n        redis.hset_async = AsyncMock()\n        return redis\n\n    @pytest.fixture\n    def menu_service(self, mock_redis):\n        service_provider = Mock()\n        service_provider.get_service.return_value = mock_redis\n        return MenuCacheService(service_provider)\n\n    @pytest.mark.asyncio\n    async def test_cache_menu_item(self, menu_service, mock_redis):\n        \"\"\"Test menu item caching.\"\"\"\n        menu_item = {\"name\": \"Margherita\", \"price\": 12.99}\n\n        await menu_service.cache_menu_item(\"margherita\", menu_item)\n\n        mock_redis.set_async.assert_called_once()\n        call_args = mock_redis.set_async.call_args\n        assert \"mario_pizzeria:menu:item:margherita\" in call_args[1][\"key\"]\n\n    @pytest.mark.asyncio\n    async def test_cache_hit(self, menu_service, mock_redis):\n        \"\"\"Test successful cache retrieval.\"\"\"\n        cached_data = '{\"name\": \"Margherita\", \"price\": 12.99}'\n        mock_redis.get_async.return_value = cached_data\n\n        result = await menu_service.get_cached_menu_item(\"margherita\")\n\n        assert result[\"name\"] == \"Margherita\"\n        assert result[\"price\"] == 12.99\n\n    @pytest.mark.asyncio\n    async def test_cache_miss(self, menu_service, mock_redis):\n        \"\"\"Test cache miss behavior.\"\"\"\n        mock_redis.get_async.return_value = None\n        menu_service.load_menu_item_from_db = AsyncMock(\n            return_value={\"name\": \"Pepperoni\", \"price\": 15.99}\n        )\n\n        result = await menu_service.get_cached_menu_item(\"pepperoni\")\n\n        assert result[\"name\"] == \"Pepperoni\"\n        # Should cache the loaded data\n        mock_redis.set_async.assert_called()\n</code></pre>"},{"location":"features/redis-cache-repository/#integration-testing-with-redis","title":"Integration Testing with Redis","text":"<pre><code>@pytest.mark.integration\nclass TestRedisIntegration:\n\n    @pytest.fixture\n    async def redis_repository(self):\n        config = RedisConfig(\n            host=\"redis://localhost:6379/15\",  # Test database\n            connection_pool_size=5\n        )\n        redis = RedisRepository(config)\n        await redis.connect()\n        yield redis\n        await redis.flushdb()  # Clean up\n        await redis.disconnect()\n\n    @pytest.mark.asyncio\n    async def test_distributed_locking(self, redis_repository):\n        \"\"\"Test distributed locking behavior.\"\"\"\n        lock_key = \"test_lock\"\n\n        # Acquire lock\n        lock = DistributedLock(redis_repository, lock_key, timeout=5)\n\n        async with lock:\n            # Lock should be held\n            assert await redis_repository.exists_async(lock_key)\n\n        # Lock should be released\n        assert not await redis_repository.exists_async(lock_key)\n\n    @pytest.mark.asyncio\n    async def test_hash_operations(self, redis_repository):\n        \"\"\"Test Redis hash operations.\"\"\"\n        hash_key = \"test_hash\"\n\n        # Set hash fields\n        fields = {\"field1\": \"value1\", \"field2\": \"value2\"}\n        await redis_repository.hset_async(hash_key, fields)\n\n        # Get specific field\n        value = await redis_repository.hget_async(hash_key, \"field1\")\n        assert value == \"value1\"\n\n        # Get all fields\n        all_fields = await redis_repository.hgetall_async(hash_key)\n        assert all_fields == fields\n</code></pre>"},{"location":"features/redis-cache-repository/#monitoring-and-performance","title":"\ud83d\udcca Monitoring and Performance","text":""},{"location":"features/redis-cache-repository/#cache-performance-metrics","title":"Cache Performance Metrics","text":"<pre><code>from neuroglia.data.redis import CacheMetrics\n\nclass CachePerformanceMonitor:\n    def __init__(self, redis: RedisRepository):\n        self.redis = redis\n        self.metrics = CacheMetrics()\n\n    async def track_cache_operation(self, operation: str, key: str, hit: bool = None):\n        \"\"\"Track cache operation metrics.\"\"\"\n        await self.metrics.increment_counter(f\"cache_operations_{operation}\")\n\n        if hit is not None:\n            status = \"hit\" if hit else \"miss\"\n            await self.metrics.increment_counter(f\"cache_{status}\")\n            await self.metrics.set_gauge(\"cache_hit_ratio\", self.calculate_hit_ratio())\n\n    async def get_performance_summary(self) -&gt; dict:\n        \"\"\"Get cache performance summary.\"\"\"\n        return {\n            \"total_operations\": await self.metrics.get_counter(\"cache_operations_total\"),\n            \"cache_hits\": await self.metrics.get_counter(\"cache_hit\"),\n            \"cache_misses\": await self.metrics.get_counter(\"cache_miss\"),\n            \"hit_ratio\": await self.metrics.get_gauge(\"cache_hit_ratio\"),\n            \"active_connections\": await self.redis.connection_pool.created_connections,\n            \"memory_usage\": await self.redis.memory_usage()\n        }\n\n    def calculate_hit_ratio(self) -&gt; float:\n        \"\"\"Calculate cache hit ratio.\"\"\"\n        hits = self.metrics.get_counter(\"cache_hit\")\n        misses = self.metrics.get_counter(\"cache_miss\")\n        total = hits + misses\n\n        return (hits / total) if total &gt; 0 else 0.0\n</code></pre>"},{"location":"features/redis-cache-repository/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\u23f0 Background Task Scheduling - Distributed job coordination</li> <li>\ud83d\udd27 Dependency Injection - Service registration patterns</li> <li>\ud83c\udf10 HTTP Service Client - External service caching</li> <li>\ud83d\udcca Enhanced Model Validation - Data validation caching</li> <li>\ud83d\udcc1 Data Access - Repository patterns</li> </ul> <p>The Redis Cache Repository provides enterprise-grade caching capabilities that enable Mario's Pizzeria to handle high-volume operations with optimal performance. Through distributed locking, advanced data structures, and comprehensive resilience patterns, the system ensures reliable and scalable caching across all service instances.</p>"},{"location":"features/resilient-handler-discovery/","title":"\ud83d\udee1\ufe0f Resilient Handler Discovery","text":"<p>The Neuroglia framework now includes Resilient Handler Discovery in the Mediator, designed to handle real-world scenarios where packages may have complex dependencies or mixed architectural patterns.</p>"},{"location":"features/resilient-handler-discovery/#problem-solved","title":"\ud83c\udfaf Problem Solved","text":"<p>Previously, <code>Mediator.configure()</code> would fail completely if a package's <code>__init__.py</code> had any import errors, even when the package contained valid handlers that could be imported individually. This blocked automatic discovery in:</p> <ul> <li>Legacy migrations from UseCase patterns to CQRS handlers</li> <li>Mixed codebases with varying dependency graphs</li> <li>Optional dependencies that may not be available in all environments</li> <li>Modular monoliths with packages containing both new and legacy patterns</li> </ul>"},{"location":"features/resilient-handler-discovery/#how-it-works","title":"\ud83c\udfd7\ufe0f How It Works","text":"<p>The resilient discovery implements a two-stage fallback strategy:</p>"},{"location":"features/resilient-handler-discovery/#stage-1-package-import-original-behavior","title":"Stage 1: Package Import (Original Behavior)","text":"<pre><code># Attempts to import the entire package\nMediator.configure(builder, ['application.runtime_agent.queries'])\n</code></pre> <p>If successful, handlers are discovered and registered normally.</p>"},{"location":"features/resilient-handler-discovery/#stage-2-individual-module-fallback","title":"Stage 2: Individual Module Fallback","text":"<pre><code># If package import fails, falls back to:\n# 1. Discover individual .py files in the package directory\n# 2. Attempt to import each module individually\n# 3. Register handlers from successful imports\n# 4. Skip modules with import failures\n\n# Example fallback discovery:\n# application.runtime_agent.queries.get_worker_query     \u2705 SUCCESS\n# application.runtime_agent.queries.list_workers_query   \u2705 SUCCESS\n# application.runtime_agent.queries.broken_module        \u274c SKIPPED\n</code></pre>"},{"location":"features/resilient-handler-discovery/#usage-examples","title":"\ud83d\ude80 Usage Examples","text":""},{"location":"features/resilient-handler-discovery/#basic-usage-unchanged","title":"Basic Usage (Unchanged)","text":"<pre><code>from neuroglia.mediation import Mediator\nfrom neuroglia.hosting import WebApplicationBuilder\n\nbuilder = WebApplicationBuilder()\n\n# This now works even if some packages have dependency issues\nMediator.configure(builder, [\n    'application.commands',           # May have legacy UseCase imports\n    'application.queries',            # Clean CQRS handlers\n    'application.event_handlers'      # Mixed dependencies\n])\n\napp = builder.build()\n</code></pre>"},{"location":"features/resilient-handler-discovery/#mixed-legacymodern-codebase","title":"Mixed Legacy/Modern Codebase","text":"<pre><code># Your package structure:\n# application/\n# \u251c\u2500\u2500 __init__.py                    # \u274c Imports missing UseCase class\n# \u251c\u2500\u2500 legacy_use_cases.py           # \u274c Uses old patterns\n# \u2514\u2500\u2500 queries/\n#     \u251c\u2500\u2500 __init__.py               # \u2705 Clean file\n#     \u251c\u2500\u2500 get_user_query.py         # \u2705 Valid QueryHandler\n#     \u2514\u2500\u2500 list_users_query.py       # \u2705 Valid QueryHandler\n\n# This now works! Handlers are discovered from individual modules\nMediator.configure(builder, ['application.queries'])\n</code></pre>"},{"location":"features/resilient-handler-discovery/#debugging-discovery-issues","title":"Debugging Discovery Issues","text":"<pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\n\n# Enable detailed logging to see what's discovered vs skipped\nMediator.configure(builder, ['your.package.name'])\n\n# Sample output:\n# WARNING: Package import failed for 'application.queries': UseCase not found\n# INFO: Attempting fallback: scanning individual modules\n# DEBUG: Discovered submodule: application.queries.get_user_query\n# DEBUG: Discovered submodule: application.queries.list_users_query\n# INFO: Successfully registered 2 handlers from submodule: application.queries.get_user_query\n# INFO: Fallback succeeded: registered 4 handlers from individual modules\n</code></pre>"},{"location":"features/resilient-handler-discovery/#logging-and-diagnostics","title":"\ud83d\udd0d Logging and Diagnostics","text":"<p>The resilient discovery provides comprehensive logging at different levels:</p>"},{"location":"features/resilient-handler-discovery/#info-level-summary-information","title":"INFO Level - Summary Information","text":"<pre><code>INFO: Successfully registered 3 handlers from package: application.commands\nINFO: Fallback succeeded: registered 2 handlers from individual modules in 'application.queries'\nINFO: Handler discovery completed: 5 total handlers registered from 2 module specifications\n</code></pre>"},{"location":"features/resilient-handler-discovery/#warning-level-import-issues","title":"WARNING Level - Import Issues","text":"<pre><code>WARNING: Package import failed for 'application.queries': cannot import name 'UseCase'\nWARNING: No submodules discovered for package: broken.package\nWARNING: Error registering handlers from module application.legacy: circular import\n</code></pre>"},{"location":"features/resilient-handler-discovery/#debug-level-detailed-discovery","title":"DEBUG Level - Detailed Discovery","text":"<pre><code>DEBUG: Attempting to load package: application.queries\nDEBUG: Found 3 potential submodules in application.queries\nDEBUG: Discovered submodule: application.queries.get_user_query\nDEBUG: Successfully registered QueryHandler: GetUserQueryHandler from application.queries.get_user_query\nDEBUG: Skipping submodule 'application.queries.broken_module': ImportError\n</code></pre>"},{"location":"features/resilient-handler-discovery/#best-practices","title":"\ud83e\uddea Best Practices","text":""},{"location":"features/resilient-handler-discovery/#1-incremental-migration-strategy","title":"1. Incremental Migration Strategy","text":"<pre><code># Start with clean packages, gradually add legacy ones\nmodules = [\n    'application.commands.user',      # \u2705 Clean CQRS handlers\n    'application.queries.user',       # \u2705 Clean CQRS handlers\n    'application.legacy.commands',    # \u26a0\ufe0f  Mixed patterns - will use fallback\n]\n\nMediator.configure(builder, modules)\n</code></pre>"},{"location":"features/resilient-handler-discovery/#2-package-organization","title":"2. Package Organization","text":"<pre><code># Recommended: Separate clean handlers from legacy code\napplication/\n\u251c\u2500\u2500 handlers/              # \u2705 Clean CQRS handlers only\n\u2502   \u251c\u2500\u2500 commands/\n\u2502   \u2514\u2500\u2500 queries/\n\u2514\u2500\u2500 legacy/               # \u26a0\ufe0f  Old patterns with complex dependencies\n    \u251c\u2500\u2500 use_cases/\n    \u2514\u2500\u2500 services/\n</code></pre>"},{"location":"features/resilient-handler-discovery/#3-gradual-cleanup","title":"3. Gradual Cleanup","text":"<pre><code># As you migrate legacy code, packages will automatically\n# switch from fallback discovery to normal discovery\n# No changes needed in configuration!\n\n# Before migration (uses fallback):\n# WARNING: Package import failed, using fallback discovery\n\n# After migration (normal discovery):\n# INFO: Successfully registered 5 handlers from package: application.commands\n</code></pre>"},{"location":"features/resilient-handler-discovery/#advanced-configuration","title":"\ud83d\udd27 Advanced Configuration","text":""},{"location":"features/resilient-handler-discovery/#individual-module-specification","title":"Individual Module Specification","text":"<p>You can also specify individual modules instead of packages:</p> <pre><code>Mediator.configure(builder, [\n    'application.commands.create_user_command',\n    'application.commands.update_user_command',\n    'application.queries.get_user_query'\n])\n</code></pre>"},{"location":"features/resilient-handler-discovery/#error-handling","title":"Error Handling","text":"<pre><code>try:\n    Mediator.configure(builder, ['your.package'])\nexcept Exception as e:\n    # Resilient discovery should prevent most exceptions,\n    # but you can still catch unexpected errors\n    logger.error(f\"Handler discovery failed: {e}\")\n</code></pre>"},{"location":"features/resilient-handler-discovery/#migration-from-manual-registration","title":"\ud83d\udea8 Migration from Manual Registration","text":""},{"location":"features/resilient-handler-discovery/#before-manual-workaround","title":"Before (Manual Workaround)","text":"<pre><code># Old approach - manual registration due to import failures\ntry:\n    from application.queries.get_user_query import GetUserQueryHandler\n    from application.queries.list_users_query import ListUsersQueryHandler\n\n    builder.services.add_scoped(GetUserQueryHandler)\n    builder.services.add_scoped(ListUsersQueryHandler)\n    log.debug(\"Manually registered query handlers\")\nexcept ImportError as e:\n    log.warning(f\"Could not register handlers: {e}\")\n</code></pre>"},{"location":"features/resilient-handler-discovery/#after-automatic-discovery","title":"After (Automatic Discovery)","text":"<pre><code># New approach - automatic resilient discovery\nMediator.configure(builder, ['application.queries'])\n# That's it! No manual registration needed\n</code></pre>"},{"location":"features/resilient-handler-discovery/#important-notes","title":"\u26a0\ufe0f Important Notes","text":""},{"location":"features/resilient-handler-discovery/#backward-compatibility","title":"Backward Compatibility","text":"<ul> <li>100% backward compatible - existing code continues to work unchanged</li> <li>No breaking changes - all existing <code>Mediator.configure()</code> calls work as before</li> <li>Enhanced behavior - only adds fallback capability when needed</li> </ul>"},{"location":"features/resilient-handler-discovery/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Package discovery first - normal path is unchanged and just as fast</li> <li>Fallback only when needed - individual module discovery only triggers on import failures</li> <li>Directory scanning - minimal filesystem operations, cached results</li> <li>Logging overhead - debug logging can be disabled in production</li> </ul>"},{"location":"features/resilient-handler-discovery/#limitations","title":"Limitations","text":"<ul> <li>Directory structure dependent - requires standard Python package layout</li> <li>Search paths - looks in <code>src/</code>, <code>./</code>, and <code>app/</code> directories</li> <li>File system access - requires read permissions to package directories</li> </ul>"},{"location":"features/resilient-handler-discovery/#benefits","title":"\ud83c\udf89 Benefits","text":""},{"location":"features/resilient-handler-discovery/#for-developers","title":"For Developers","text":"<ul> <li>Reduced friction during legacy code migration</li> <li>Automatic discovery without manual registration</li> <li>Clear diagnostics about what was discovered vs skipped</li> <li>Incremental adoption of CQRS patterns</li> </ul>"},{"location":"features/resilient-handler-discovery/#for-projects","title":"For Projects","text":"<ul> <li>Mixed architectural patterns supported</li> <li>Gradual modernization without breaking changes</li> <li>Complex dependency graphs handled gracefully</li> <li>Better development experience with detailed logging</li> </ul>"},{"location":"features/resilient-handler-discovery/#for-teams","title":"For Teams","text":"<ul> <li>Parallel development - teams can work on different parts without breaking discovery</li> <li>Easier onboarding - less manual configuration needed</li> <li>Reduced support burden - fewer \"handler not found\" issues</li> </ul> <p>The resilient discovery makes the Neuroglia framework significantly more robust for real-world codebases with complex dependencies and mixed architectural patterns! \ud83c\udfaf</p>"},{"location":"features/serialization/","title":"\ud83d\udd04 Serialization &amp; Deserialization","text":"<p>Neuroglia provides powerful and flexible serialization capabilities for converting objects to and from various formats like JSON. The framework includes built-in serializers with automatic type handling, custom converters, and seamless integration with the dependency injection system.</p> <p>!!! info \"\ud83c\udfaf What You'll Learn\" - JSON serialization with automatic type handling - Custom serializers and converters - Integration with Mario's Pizzeria domain objects - Best practices for data transformation</p>"},{"location":"features/serialization/#overview","title":"\ud83c\udfaf Overview","text":"<p>Neuroglia's serialization system offers:</p> <ul> <li>\ud83d\udd04 Automatic Type Handling - Seamless conversion of complex objects, enums, and collections</li> <li>\ud83d\udcc5 Built-in Type Support - Native handling of dates, decimals, UUIDs, and custom types</li> <li>\ud83c\udfa8 Custom Converters - Extensible system for specialized serialization logic</li> <li>\ud83d\udc89 DI Integration - Service-based serializers with configurable lifetimes</li> <li>\ud83e\uddea Test-Friendly - Easy mocking and testing of serialization logic</li> </ul>"},{"location":"features/serialization/#key-benefits","title":"Key Benefits","text":"<ul> <li>Type Safety: Strongly-typed deserialization with validation</li> <li>Performance: Efficient JSON processing with minimal overhead</li> <li>Flexibility: Support for custom serialization logic and converters</li> <li>Consistency: Unified serialization patterns across the application</li> </ul>"},{"location":"features/serialization/#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<pre><code>flowchart TD\n    A[\"\ud83c\udfaf Client Code&lt;br/&gt;Business Objects\"]\n    B[\"\ud83d\udd04 JsonSerializer&lt;br/&gt;Main Serialization Service\"]\n    C[\"\ud83d\udccb JsonEncoder&lt;br/&gt;Custom Type Handling\"]\n    D[\"\ud83c\udfa8 Type Converters&lt;br/&gt;Specialized Logic\"]\n\n    subgraph \"\ud83d\udce6 Serialization Pipeline\"\n        E[\"Object \u2192 JSON\"]\n        F[\"JSON \u2192 Object\"]\n        G[\"Type Detection\"]\n        H[\"Recursive Processing\"]\n    end\n\n    subgraph \"\ud83c\udfaf Formats\"\n        I[\"JSON String\"]\n        J[\"Byte Array\"]\n        K[\"Stream Data\"]\n    end\n\n    A --&gt; B\n    B --&gt; C\n    B --&gt; D\n    B --&gt; E\n    B --&gt; F\n    E --&gt; G\n    F --&gt; H\n\n    E --&gt; I\n    E --&gt; J\n    F --&gt; I\n    F --&gt; J\n\n    style B fill:#e1f5fe,stroke:#0277bd,stroke-width:3px\n    style C fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\n    style D fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px\n\n    classDef pipeline fill:#fff3e0,stroke:#f57c00,stroke-width:2px\n    class E,F,G,H pipeline</code></pre>"},{"location":"features/serialization/#basic-usage-in-marios-pizzeria","title":"\ud83c\udf55 Basic Usage in Mario's Pizzeria","text":""},{"location":"features/serialization/#pizza-order-serialization","title":"Pizza Order Serialization","text":"<p>Let's see how Mario's Pizzeria uses serialization for order processing:</p> <pre><code>from neuroglia.serialization.json import JsonSerializer\nfrom neuroglia.dependency_injection import ServiceCollection\nfrom decimal import Decimal\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom enum import Enum\n\n# Domain objects from Mario's Pizzeria\nclass OrderStatus(str, Enum):\n    PENDING = \"pending\"\n    COOKING = \"cooking\"\n    READY = \"ready\"\n    DELIVERED = \"delivered\"\n\n@dataclass\nclass Pizza:\n    id: str\n    name: str\n    size: str\n    base_price: Decimal\n    toppings: list[str]\n\n@dataclass\nclass Order:\n    id: str\n    customer_name: str\n    customer_phone: str\n    pizzas: list[Pizza]\n    status: OrderStatus\n    order_time: datetime\n    total_amount: Decimal\n\n# Using JsonSerializer\nclass OrderService:\n    def __init__(self, serializer: JsonSerializer):\n        self.serializer = serializer\n\n    def serialize_order(self, order: Order) -&gt; str:\n        \"\"\"Convert order to JSON for storage or API responses\"\"\"\n        return self.serializer.serialize_to_text(order)\n\n    def deserialize_order(self, json_data: str) -&gt; Order:\n        \"\"\"Convert JSON back to Order object\"\"\"\n        return self.serializer.deserialize_from_text(json_data, Order)\n\n# Example usage\nserializer = JsonSerializer()\norder = Order(\n    id=\"order-123\",\n    customer_name=\"Mario Luigi\",\n    customer_phone=\"+1-555-PIZZA\",\n    pizzas=[\n        Pizza(\"pizza-1\", \"Margherita\", \"large\", Decimal(\"15.99\"), [\"basil\", \"mozzarella\"])\n    ],\n    status=OrderStatus.PENDING,\n    order_time=datetime.now(),\n    total_amount=Decimal(\"17.49\")\n)\n\n# Serialize to JSON\njson_order = serializer.serialize_to_text(order)\nprint(json_order)\n# Output: {\"id\": \"order-123\", \"customer_name\": \"Mario Luigi\", ...}\n\n# Deserialize back to object\nrestored_order = serializer.deserialize_from_text(json_order, Order)\nassert restored_order.customer_name == \"Mario Luigi\"\nassert restored_order.status == OrderStatus.PENDING\n</code></pre>"},{"location":"features/serialization/#custom-json-encoder","title":"\ud83c\udfa8 Custom JSON Encoder","text":"<p>Neuroglia includes a custom <code>JsonEncoder</code> that handles special types automatically:</p> <pre><code>from neuroglia.serialization.json import JsonEncoder\nimport json\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom enum import Enum\n\nclass PizzaSize(str, Enum):\n    SMALL = \"small\"\n    MEDIUM = \"medium\"\n    LARGE = \"large\"\n\n# The JsonEncoder automatically handles these types:\ndata = {\n    \"order_time\": datetime.now(),       # \u2192 ISO format string\n    \"total_amount\": Decimal(\"15.99\"),   # \u2192 string representation\n    \"size\": PizzaSize.LARGE,           # \u2192 enum name\n    \"custom_object\": Pizza(...)         # \u2192 object's __dict__\n}\n\njson_string = json.dumps(data, cls=JsonEncoder)\n</code></pre>"},{"location":"features/serialization/#encoder-features","title":"Encoder Features","text":"<p>The <code>JsonEncoder</code> provides:</p> <ul> <li>DateTime Conversion: Automatic ISO format serialization</li> <li>Enum Handling: Uses enum names for consistent serialization</li> <li>Decimal Support: Preserves precision for monetary values</li> <li>Object Filtering: Excludes private attributes and None values</li> <li>Fallback Handling: Safe string conversion for unknown types</li> </ul>"},{"location":"features/serialization/#advanced-serialization-patterns","title":"\ud83d\udd27 Advanced Serialization Patterns","text":""},{"location":"features/serialization/#1-nested-object-serialization","title":"1. Nested Object Serialization","text":"<pre><code>@dataclass\nclass Customer:\n    id: str\n    name: str\n    email: str\n    addresses: list[Address]\n\n@dataclass\nclass Address:\n    street: str\n    city: str\n    postal_code: str\n\n# Automatic recursive serialization\ncustomer = Customer(\n    id=\"cust-123\",\n    name=\"Luigi Mario\",\n    email=\"luigi@pizzeria.com\",\n    addresses=[\n        Address(\"123 Main St\", \"Pizza City\", \"12345\"),\n        Address(\"456 Oak Ave\", \"Pepperoni Town\", \"67890\")\n    ]\n)\n\nserializer = JsonSerializer()\njson_data = serializer.serialize_to_text(customer)\nrestored_customer = serializer.deserialize_from_text(json_data, Customer)\n</code></pre>"},{"location":"features/serialization/#2-generic-type-handling","title":"2. Generic Type Handling","text":"<pre><code>from typing import List, Dict, Optional\n\n@dataclass\nclass MenuSection:\n    name: str\n    pizzas: List[Pizza]\n    metadata: Dict[str, str]\n    featured_pizza: Optional[Pizza] = None\n\n# Serializer handles generic types automatically\nmenu_section = MenuSection(\n    name=\"Classic Pizzas\",\n    pizzas=[margherita_pizza, pepperoni_pizza],\n    metadata={\"category\": \"traditional\", \"popularity\": \"high\"},\n    featured_pizza=margherita_pizza\n)\n\n# Serialization preserves type information\njson_data = serializer.serialize_to_text(menu_section)\nrestored_section = serializer.deserialize_from_text(json_data, MenuSection)\n</code></pre>"},{"location":"features/serialization/#3-integration-with-dependency-injection","title":"3. Integration with Dependency Injection","text":"<pre><code>from neuroglia.hosting import WebApplicationBuilder\n\ndef configure_serialization(builder: WebApplicationBuilder):\n    \"\"\"Configure serialization services\"\"\"\n\n    # Register JsonSerializer as singleton\n    builder.services.add_singleton(JsonSerializer)\n\n    # Use in controllers\n    class OrdersController(ControllerBase):\n        def __init__(self,\n                     service_provider: ServiceProviderBase,\n                     mapper: Mapper,\n                     mediator: Mediator,\n                     serializer: JsonSerializer):  # Injected automatically\n            super().__init__(service_provider, mapper, mediator)\n            self.serializer = serializer\n\n        @post(\"/export\")\n        async def export_orders(self) -&gt; str:\n            \"\"\"Export all orders as JSON\"\"\"\n            orders = await self.get_all_orders()\n            return self.serializer.serialize_to_text(orders)\n</code></pre>"},{"location":"features/serialization/#testing-serialization","title":"\ud83e\uddea Testing Serialization","text":""},{"location":"features/serialization/#unit-testing-patterns","title":"Unit Testing Patterns","text":"<pre><code>import pytest\nfrom neuroglia.serialization.json import JsonSerializer\n\nclass TestPizzaOrderSerialization:\n\n    def setup_method(self):\n        self.serializer = JsonSerializer()\n\n    def test_order_serialization_round_trip(self):\n        \"\"\"Test complete serialization/deserialization cycle\"\"\"\n        # Arrange\n        original_order = create_test_order()\n\n        # Act\n        json_data = self.serializer.serialize_to_text(original_order)\n        restored_order = self.serializer.deserialize_from_text(json_data, Order)\n\n        # Assert\n        assert restored_order.id == original_order.id\n        assert restored_order.customer_name == original_order.customer_name\n        assert restored_order.status == original_order.status\n        assert len(restored_order.pizzas) == len(original_order.pizzas)\n\n    def test_handles_none_values_gracefully(self):\n        \"\"\"Test serialization with None values\"\"\"\n        # Arrange\n        order = Order(\n            id=\"test-order\",\n            customer_name=\"Test Customer\",\n            customer_phone=None,  # None value\n            pizzas=[],\n            status=OrderStatus.PENDING,\n            order_time=datetime.now(),\n            total_amount=Decimal(\"0.00\")\n        )\n\n        # Act &amp; Assert\n        json_data = self.serializer.serialize_to_text(order)\n        restored_order = self.serializer.deserialize_from_text(json_data, Order)\n\n        assert restored_order.customer_phone is None\n\n    def test_decimal_precision_preserved(self):\n        \"\"\"Test that decimal precision is maintained\"\"\"\n        # Arrange\n        pizza = Pizza(\n            id=\"test-pizza\",\n            name=\"Test Pizza\",\n            size=\"medium\",\n            base_price=Decimal(\"12.99\"),\n            toppings=[]\n        )\n\n        # Act\n        json_data = self.serializer.serialize_to_text(pizza)\n        restored_pizza = self.serializer.deserialize_from_text(json_data, Pizza)\n\n        # Assert\n        assert restored_pizza.base_price == Decimal(\"12.99\")\n        assert isinstance(restored_pizza.base_price, Decimal)\n</code></pre>"},{"location":"features/serialization/#real-world-use-cases","title":"\ud83c\udfaf Real-World Use Cases","text":""},{"location":"features/serialization/#1-api-response-serialization","title":"1. API Response Serialization","text":"<pre><code>from fastapi import FastAPI\nfrom fastapi.responses import JSONResponse\n\nclass MenuController(ControllerBase):\n\n    @get(\"/menu\")\n    async def get_menu(self) -&gt; JSONResponse:\n        \"\"\"Get pizzeria menu as JSON\"\"\"\n        menu_items = await self.get_menu_items()\n\n        # Serialize complex menu structure\n        json_data = self.serializer.serialize_to_text(menu_items)\n\n        return JSONResponse(\n            content=json_data,\n            media_type=\"application/json\"\n        )\n</code></pre>"},{"location":"features/serialization/#2-event-payload-serialization","title":"2. Event Payload Serialization","text":"<pre><code>from neuroglia.eventing import DomainEvent\n\n@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    order_id: str\n    customer_email: str\n    order_details: Order\n\nclass OrderEventHandler:\n    def __init__(self, serializer: JsonSerializer):\n        self.serializer = serializer\n\n    async def handle_order_placed(self, event: OrderPlacedEvent):\n        \"\"\"Handle order placed event with serialization\"\"\"\n\n        # Serialize event for external systems\n        event_json = self.serializer.serialize_to_text(event)\n\n        # Send to message queue, webhook, etc.\n        await self.send_to_external_system(event_json)\n\n        # Log structured event data\n        logger.info(\"Order placed\", extra={\n            \"event_data\": event_json,\n            \"order_id\": event.order_id\n        })\n</code></pre>"},{"location":"features/serialization/#3-configuration-and-settings","title":"3. Configuration and Settings","text":"<pre><code>@dataclass\nclass PizzeriaConfig:\n    name: str\n    address: Address\n    operating_hours: Dict[str, str]\n    menu_sections: List[MenuSection]\n    pricing_rules: Dict[str, Decimal]\n\nclass ConfigurationService:\n    def __init__(self, serializer: JsonSerializer):\n        self.serializer = serializer\n\n    def load_config(self, config_path: str) -&gt; PizzeriaConfig:\n        \"\"\"Load pizzeria configuration from JSON file\"\"\"\n        with open(config_path, 'r') as f:\n            json_data = f.read()\n\n        return self.serializer.deserialize_from_text(json_data, PizzeriaConfig)\n\n    def save_config(self, config: PizzeriaConfig, config_path: str):\n        \"\"\"Save pizzeria configuration to JSON file\"\"\"\n        json_data = self.serializer.serialize_to_text(config)\n\n        with open(config_path, 'w') as f:\n            f.write(json_data)\n</code></pre>"},{"location":"features/serialization/#error-handling-and-validation","title":"\ud83d\udd0d Error Handling and Validation","text":""},{"location":"features/serialization/#robust-serialization-patterns","title":"Robust Serialization Patterns","text":"<pre><code>from typing import Union\nimport logging\n\nclass SafeSerializationService:\n    def __init__(self, serializer: JsonSerializer):\n        self.serializer = serializer\n        self.logger = logging.getLogger(__name__)\n\n    def safe_serialize(self, obj: Any) -&gt; Union[str, None]:\n        \"\"\"Safely serialize object with error handling\"\"\"\n        try:\n            return self.serializer.serialize_to_text(obj)\n        except Exception as e:\n            self.logger.error(f\"Serialization failed for {type(obj)}: {e}\")\n            return None\n\n    def safe_deserialize(self, json_data: str, target_type: Type[T]) -&gt; Union[T, None]:\n        \"\"\"Safely deserialize with validation\"\"\"\n        try:\n            if not json_data or not json_data.strip():\n                return None\n\n            result = self.serializer.deserialize_from_text(json_data, target_type)\n\n            # Additional validation\n            if hasattr(result, 'validate'):\n                result.validate()\n\n            return result\n\n        except json.JSONDecodeError as e:\n            self.logger.error(f\"Invalid JSON format: {e}\")\n            return None\n        except Exception as e:\n            self.logger.error(f\"Deserialization failed: {e}\")\n            return None\n</code></pre>"},{"location":"features/serialization/#performance-considerations","title":"\ud83d\ude80 Performance Considerations","text":""},{"location":"features/serialization/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Reuse Serializer Instances: Register as singleton in DI container</li> <li>Minimize Object Creation: Use object pooling for high-frequency serialization</li> <li>Stream Processing: Use byte arrays for large data sets</li> <li>Selective Serialization: Exclude unnecessary fields to reduce payload size</li> </ol> <pre><code># Performance-optimized serialization\nclass OptimizedOrderService:\n    def __init__(self, serializer: JsonSerializer):\n        self.serializer = serializer\n        self._byte_buffer = bytearray(8192)  # Reusable buffer\n\n    def serialize_order_summary(self, order: Order) -&gt; str:\n        \"\"\"Serialize only essential order information\"\"\"\n        summary = {\n            \"id\": order.id,\n            \"customer_name\": order.customer_name,\n            \"status\": order.status.value,\n            \"total_amount\": str(order.total_amount),\n            \"pizza_count\": len(order.pizzas)\n        }\n        return self.serializer.serialize_to_text(summary)\n</code></pre>"},{"location":"features/serialization/#integration-points","title":"\ud83d\udd17 Integration Points","text":""},{"location":"features/serialization/#framework-integration","title":"Framework Integration","text":"<p>Serialization integrates seamlessly with:</p> <ul> <li>Object Mapping - Automatic DTO conversion before serialization</li> <li>MVC Controllers - Automatic request/response serialization</li> <li>Event Sourcing - Event payload serialization for persistence</li> <li>Data Access - Document serialization for MongoDB storage</li> </ul>"},{"location":"features/serialization/#next-steps","title":"\ud83d\udcda Next Steps","text":"<p>Explore related Neuroglia features:</p> <ul> <li>Object Mapping - Transform objects before serialization</li> <li>MVC Controllers - Automatic API serialization</li> <li>Event Sourcing - Event payload handling</li> <li>Getting Started Guide - Complete pizzeria implementation</li> </ul> <p>\ud83c\udfaf Best Practice</p> <p>Always register <code>JsonSerializer</code> as a singleton in your DI container for optimal performance and consistent behavior across your application.</p>"},{"location":"features/simple-cqrs/","title":"\ud83c\udfaf CQRS with Mediator Pattern","text":"<p>Estimated reading time: 12 minutes</p>"},{"location":"features/simple-cqrs/#what-why","title":"\ud83c\udfaf What &amp; Why","text":"<p>CQRS (Command Query Responsibility Segregation) separates write operations (Commands) from read operations (Queries). The Mediator Pattern decouples request senders from handlers, creating a clean, testable architecture.</p>"},{"location":"features/simple-cqrs/#the-problem-without-cqrs","title":"The Problem Without CQRS","text":"<pre><code># \u274c Without CQRS - business logic mixed in controller\n@app.post(\"/orders\")\nasync def create_order(order_data: dict, db: Database):\n    # Validation in controller\n    if not order_data.get(\"customer_id\"):\n        return {\"error\": \"Customer required\"}, 400\n\n    # Business logic in controller\n    order = Order(**order_data)\n    order.calculate_total()\n\n    # Data access in controller\n    await db.orders.insert_one(order.__dict__)\n\n    # Side effects in controller\n    await send_email(order.customer_email, \"Order confirmed\")\n\n    return {\"id\": order.id}, 201\n</code></pre> <p>Problems:</p> <ul> <li>Controller has too many responsibilities</li> <li>Business logic can't be reused</li> <li>Testing requires mocking HTTP layer</li> <li>Difficult to add behaviors (logging, validation, caching)</li> </ul>"},{"location":"features/simple-cqrs/#the-solution-with-cqrs-mediator","title":"The Solution With CQRS + Mediator","text":"<pre><code># \u2705 With CQRS - clean separation of concerns\n@app.post(\"/orders\")\nasync def create_order(dto: CreateOrderDto):\n    command = CreateOrderCommand(\n        customer_id=dto.customer_id,\n        items=dto.items\n    )\n    result = await self.mediator.execute_async(command)\n    return self.process(result)\n\n# Business logic in handler (testable, reusable)\nclass CreateOrderHandler(CommandHandler):\n    async def handle_async(self, command: CreateOrderCommand):\n        # Validation, business logic, persistence all in one place\n        ...\n</code></pre> <p>Benefits:</p> <ul> <li>Controllers are thin (orchestration only)</li> <li>Business logic is isolated and testable</li> <li>Easy to add cross-cutting concerns (validation, logging, caching)</li> <li>Handlers are reusable across different entry points</li> </ul>"},{"location":"features/simple-cqrs/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"features/simple-cqrs/#basic-setup","title":"Basic Setup","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.mediation import Mediator, Command, Query, CommandHandler, QueryHandler\nfrom neuroglia.core.operation_result import OperationResult\n\n# Step 1: Create application builder\nbuilder = WebApplicationBuilder()\n\n# Step 2: Add mediator (includes all CQRS infrastructure)\nbuilder.services.add_mediator()\n\n# Step 3: Mediator automatically discovers and registers handlers\n# Just import your handler modules and they're auto-registered!\n\n# Step 4: Build app\napp = builder.build()\n</code></pre>"},{"location":"features/simple-cqrs/#your-first-command-and-handler","title":"Your First Command and Handler","text":"<pre><code>from dataclasses import dataclass\nfrom neuroglia.mediation import Command, CommandHandler\nfrom neuroglia.core.operation_result import OperationResult\n\n# Define the command (what you want to do)\n@dataclass\nclass CreatePizzaCommand(Command[OperationResult[dict]]):\n    customer_id: str\n    pizza_type: str\n    size: str\n\n# Implement the handler (how to do it)\nclass CreatePizzaHandler(CommandHandler[CreatePizzaCommand, OperationResult[dict]]):\n    async def handle_async(self, command: CreatePizzaCommand) -&gt; OperationResult[dict]:\n        # Validation\n        if command.size not in [\"small\", \"medium\", \"large\"]:\n            return self.bad_request(\"Invalid pizza size\")\n\n        # Business logic\n        pizza = {\n            \"id\": str(uuid.uuid4()),\n            \"customer_id\": command.customer_id,\n            \"type\": command.pizza_type,\n            \"size\": command.size,\n            \"price\": self.calculate_price(command.size)\n        }\n\n        # Return result\n        return self.created(pizza)\n\n    def calculate_price(self, size: str) -&gt; float:\n        prices = {\"small\": 10.0, \"medium\": 15.0, \"large\": 20.0}\n        return prices[size]\n\n# Use in controller\nclass PizzaController(ControllerBase):\n    @post(\"/pizzas\")\n    async def create_pizza(self, dto: CreatePizzaDto):\n        command = self.mapper.map(dto, CreatePizzaCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)  # Automatically converts to HTTP response\n</code></pre>"},{"location":"features/simple-cqrs/#core-components","title":"\ud83c\udfd7\ufe0f Core Components","text":""},{"location":"features/simple-cqrs/#1-commands-write-operations","title":"1. Commands (Write Operations)","text":"<p>Commands represent intentions to change state:</p> <pre><code>from dataclasses import dataclass\nfrom neuroglia.mediation import Command\nfrom neuroglia.core.operation_result import OperationResult\n\n# Command naming: &lt;Verb&gt;&lt;Noun&gt;Command\n@dataclass\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    customer_id: str\n    items: list[OrderItemDto]\n    delivery_address: str\n    payment_method: str\n\n@dataclass\nclass CancelOrderCommand(Command[OperationResult[OrderDto]]):\n    order_id: str\n    reason: str\n\n@dataclass\nclass UpdateOrderStatusCommand(Command[OperationResult[OrderDto]]):\n    order_id: str\n    new_status: str\n</code></pre> <p>Command Characteristics:</p> <ul> <li>Represent user intentions (\"Place an order\", \"Cancel order\")</li> <li>May fail (validation, business rules)</li> <li>Should not return data (use queries for reading)</li> <li>Named with verbs: <code>PlaceOrder</code>, <code>CancelOrder</code>, <code>UpdateInventory</code></li> </ul>"},{"location":"features/simple-cqrs/#2-queries-read-operations","title":"2. Queries (Read Operations)","text":"<p>Queries represent requests for data:</p> <pre><code># Query naming: &lt;Verb&gt;&lt;Noun&gt;Query or Get&lt;Noun&gt;Query\n@dataclass\nclass GetOrderQuery(Query[OperationResult[OrderDto]]):\n    order_id: str\n\n@dataclass\nclass ListCustomerOrdersQuery(Query[OperationResult[list[OrderDto]]]):\n    customer_id: str\n    status: Optional[str] = None\n    page: int = 1\n    page_size: int = 20\n\n@dataclass\nclass SearchPizzasQuery(Query[OperationResult[list[PizzaDto]]]):\n    search_term: str\n    category: Optional[str] = None\n</code></pre> <p>Query Characteristics:</p> <ul> <li>Never modify state (idempotent)</li> <li>Always succeed or return empty results</li> <li>Named with questions: <code>GetOrder</code>, <code>ListOrders</code>, <code>SearchPizzas</code></li> <li>Can be cached aggressively</li> </ul>"},{"location":"features/simple-cqrs/#3-command-handlers","title":"3. Command Handlers","text":"<p>Command handlers contain write-side business logic:</p> <pre><code>from neuroglia.mediation import CommandHandler\nfrom neuroglia.core.operation_result import OperationResult\n\nclass PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    def __init__(\n        self,\n        order_repository: IOrderRepository,\n        customer_repository: ICustomerRepository,\n        inventory_service: InventoryService,\n        payment_service: PaymentService,\n        mapper: Mapper\n    ):\n        super().__init__()\n        self.order_repository = order_repository\n        self.customer_repository = customer_repository\n        self.inventory_service = inventory_service\n        self.payment_service = payment_service\n        self.mapper = mapper\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        # Step 1: Validation\n        customer = await self.customer_repository.get_by_id_async(command.customer_id)\n        if not customer:\n            return self.not_found(\"Customer\", command.customer_id)\n\n        if not command.items:\n            return self.bad_request(\"Order must have at least one item\")\n\n        # Step 2: Business Rules\n        if not await self.inventory_service.check_availability(command.items):\n            return self.bad_request(\"Some items are out of stock\")\n\n        # Step 3: Calculate totals\n        subtotal = sum(item.price * item.quantity for item in command.items)\n        tax = subtotal * 0.08\n        total = subtotal + tax\n\n        # Step 4: Process payment\n        payment_result = await self.payment_service.charge_async(\n            customer.payment_method,\n            total\n        )\n\n        if not payment_result.success:\n            return self.bad_request(f\"Payment failed: {payment_result.error}\")\n\n        # Step 5: Create order entity\n        order = Order(\n            customer_id=command.customer_id,\n            items=command.items,\n            delivery_address=command.delivery_address,\n            subtotal=subtotal,\n            tax=tax,\n            total=total,\n            payment_transaction_id=payment_result.transaction_id\n        )\n\n        # Step 6: Reserve inventory\n        await self.inventory_service.reserve_items(command.items, order.id)\n\n        # Step 7: Persist\n        await self.order_repository.save_async(order)\n\n        # Step 8: Return result\n        return self.created(self.mapper.map(order, OrderDto))\n</code></pre>"},{"location":"features/simple-cqrs/#4-query-handlers","title":"4. Query Handlers","text":"<p>Query handlers contain read-side logic:</p> <pre><code>from neuroglia.mediation import QueryHandler\n\nclass ListCustomerOrdersHandler(QueryHandler[ListCustomerOrdersQuery, OperationResult[list[OrderDto]]]):\n    def __init__(\n        self,\n        order_repository: IOrderRepository,\n        mapper: Mapper\n    ):\n        super().__init__()\n        self.order_repository = order_repository\n        self.mapper = mapper\n\n    async def handle_async(self, query: ListCustomerOrdersQuery) -&gt; OperationResult[list[OrderDto]]:\n        # Queries use optimized read models\n        orders = await self.order_repository.list_by_customer_async(\n            customer_id=query.customer_id,\n            status=query.status,\n            page=query.page,\n            page_size=query.page_size\n        )\n\n        # Map to DTOs\n        dtos = [self.mapper.map(order, OrderDto) for order in orders]\n\n        return self.ok(dtos)\n</code></pre>"},{"location":"features/simple-cqrs/#real-world-example-marios-pizzeria","title":"\ud83d\udca1 Real-World Example: Mario's Pizzeria","text":"<p>Complete CQRS implementation for pizza ordering:</p>"},{"location":"features/simple-cqrs/#domain-layer","title":"Domain Layer","text":"<pre><code>import asyncio\n\nasync def main():\n    # Create app with ultra-simple setup\n    provider = create_simple_app(\n        CreateTaskHandler,\n        GetTaskHandler,\n        CompleteTaskHandler,\n        repositories=[InMemoryRepository[Task]]\n    )\n\n    mediator = provider.get_service(Mediator)\n\n    # Create a task\n    create_result = await mediator.execute_async(\n        CreateTaskCommand(\"Learn Neuroglia CQRS\")\n    )\n\n    if create_result.is_success:\n        print(f\"\u2705 Created: {create_result.data.title}\")\n        task_id = create_result.data.id\n\n        # Complete the task\n        complete_result = await mediator.execute_async(\n            CompleteTaskCommand(task_id)\n        )\n\n        if complete_result.is_success:\n            print(f\"\u2705 Completed: {complete_result.data.title}\")\n\n        # Get the task\n        get_result = await mediator.execute_async(GetTaskQuery(task_id))\n\n        if get_result.is_success:\n            task = get_result.data\n            print(f\"\ud83d\udccb Task: {task.title} (completed: {task.completed})\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"features/simple-cqrs/#key-patterns","title":"\ud83d\udca1 Key Patterns","text":""},{"location":"features/simple-cqrs/#validation-and-error-handling","title":"Validation and Error Handling","text":"<pre><code>async def handle_async(self, request: CreateUserCommand) -&gt; OperationResult[UserDto]:\n    # Input validation\n    if not request.email:\n        return self.bad_request(\"Email is required\")\n\n    if \"@\" not in request.email:\n        return self.bad_request(\"Invalid email format\")\n\n    # Business validation\n    existing_user = await self.repository.get_by_email_async(request.email)\n    if existing_user:\n        return self.conflict(f\"User with email {request.email} already exists\")\n\n    # Success path\n    user = User(str(uuid.uuid4()), request.name, request.email)\n    await self.repository.save_async(user)\n\n    dto = UserDto(user.id, user.name, user.email)\n    return self.created(dto)\n</code></pre>"},{"location":"features/simple-cqrs/#repository-patterns","title":"Repository Patterns","text":"<pre><code># Simple in-memory repository (for testing/prototyping)\nfrom neuroglia.mediation import InMemoryRepository\n\nclass UserRepository(InMemoryRepository[User]):\n    async def get_by_email_async(self, email: str) -&gt; Optional[User]:\n        for user in self._storage.values():\n            if user.email == email:\n                return user\n        return None\n</code></pre>"},{"location":"features/simple-cqrs/#query-result-patterns","title":"Query Result Patterns","text":"<pre><code># Single item query\n@dataclass\nclass GetUserQuery(Query[OperationResult[UserDto]]):\n    user_id: str\n\n# List query\n@dataclass\nclass ListUsersQuery(Query[OperationResult[List[UserDto]]]):\n    include_inactive: bool = False\n\n# Search query\n@dataclass\nclass SearchUsersQuery(Query[OperationResult[List[UserDto]]]):\n    search_term: str\n    page: int = 1\n    page_size: int = 10\n</code></pre>"},{"location":"features/simple-cqrs/#configuration-options","title":"\ud83d\udd27 Configuration Options","text":""},{"location":"features/simple-cqrs/#simple-application-settings","title":"Simple Application Settings","text":"<p>Instead of the full <code>ApplicationSettings</code>, use <code>SimpleApplicationSettings</code> for basic apps:</p> <pre><code>from neuroglia.mediation import SimpleApplicationSettings\n\n@dataclass\nclass MyAppSettings(SimpleApplicationSettings):\n    app_name: str = \"Task Manager\"\n    max_tasks_per_user: int = 100\n    enable_notifications: bool = True\n</code></pre>"},{"location":"features/simple-cqrs/#environment-integration","title":"Environment Integration","text":"<pre><code>import os\n\nsettings = SimpleApplicationSettings(\n    app_name=os.getenv(\"APP_NAME\", \"My App\"),\n    debug=os.getenv(\"DEBUG\", \"false\").lower() == \"true\",\n    database_url=os.getenv(\"DATABASE_URL\")\n)\n</code></pre>"},{"location":"features/simple-cqrs/#testing-patterns","title":"\ud83e\uddea Testing Patterns","text":""},{"location":"features/simple-cqrs/#unit-testing-handlers","title":"Unit Testing Handlers","text":"<pre><code>import pytest\nfrom unittest.mock import AsyncMock\n\n@pytest.mark.asyncio\nasync def test_create_task_success():\n    # Arrange\n    repository = AsyncMock(spec=InMemoryRepository[Task])\n    handler = CreateTaskHandler(repository)\n    command = CreateTaskCommand(\"Test task\")\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n    assert result.data.title == \"Test task\"\n    repository.save_async.assert_called_once()\n\n@pytest.mark.asyncio\nasync def test_create_task_empty_title():\n    # Arrange\n    repository = AsyncMock(spec=InMemoryRepository[Task])\n    handler = CreateTaskHandler(repository)\n    command = CreateTaskCommand(\"\")\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert not result.is_success\n    assert result.status_code == 400\n    assert \"empty\" in result.error_message.lower()\n</code></pre>"},{"location":"features/simple-cqrs/#integration-testing","title":"Integration Testing","text":"<pre><code>@pytest.mark.asyncio\nasync def test_complete_workflow():\n    # Create application\n    provider = create_simple_app(\n        CreateTaskHandler,\n        GetTaskHandler,\n        CompleteTaskHandler,\n        repositories=[InMemoryRepository[Task]]\n    )\n\n    mediator = provider.get_service(Mediator)\n\n    # Test complete workflow\n    create_result = await mediator.execute_async(CreateTaskCommand(\"Test\"))\n    assert create_result.is_success\n\n    task_id = create_result.data.id\n\n    get_result = await mediator.execute_async(GetTaskQuery(task_id))\n    assert get_result.is_success\n    assert not get_result.data.completed\n\n    complete_result = await mediator.execute_async(CompleteTaskCommand(task_id))\n    assert complete_result.is_success\n    assert complete_result.data.completed\n</code></pre>"},{"location":"features/simple-cqrs/#when-to-upgrade","title":"\ud83d\ude80 When to Upgrade","text":"<p>Consider upgrading to the full Neuroglia framework features when you need:</p>"},{"location":"features/simple-cqrs/#event-sourcing","title":"Event Sourcing","text":"<pre><code># Upgrade to event sourcing when you need:\n# - Complete audit trails\n# - Event replay capabilities\n# - Complex business workflows\n# - Temporal queries (\"what was the state at time X?\")\n</code></pre>"},{"location":"features/simple-cqrs/#cloud-events","title":"Cloud Events","text":"<pre><code># Upgrade to cloud events when you need:\n# - Microservice integration\n# - Event-driven architecture\n# - Cross-system communication\n# - Reliable event delivery\n</code></pre>"},{"location":"features/simple-cqrs/#domain-events","title":"Domain Events","text":"<pre><code># Upgrade to domain events when you need:\n# - Side effects from business operations\n# - Decoupled business logic\n# - Complex business rules\n# - Integration events\n</code></pre>"},{"location":"features/simple-cqrs/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Framework overview</li> <li>CQRS &amp; Mediation - Advanced CQRS patterns</li> <li>Dependency Injection - Advanced DI patterns</li> <li>Data Access - Repository patterns and persistence</li> </ul>"},{"location":"fixes/TYPE_VARIABLE_SUBSTITUTION_FIX/","title":"Type Variable Substitution Fix (v0.4.3)","text":""},{"location":"fixes/TYPE_VARIABLE_SUBSTITUTION_FIX/#problem-statement","title":"Problem Statement","text":"<p>In v0.4.2, we fixed generic type resolution in the DI container, enabling services to depend on parameterized types like <code>Repository[User, int]</code>. However, a critical limitation remained: constructor parameters that used type variables were not being substituted with concrete types.</p>"},{"location":"fixes/TYPE_VARIABLE_SUBSTITUTION_FIX/#the-failing-pattern","title":"The Failing Pattern","text":"<pre><code>from typing import Generic, TypeVar\n\nTEntity = TypeVar('TEntity')\nTKey = TypeVar('TKey')\n\nclass CacheRepositoryOptions(Generic[TEntity, TKey]):\n    def __init__(self, host: str, port: int):\n        self.host = host\n        self.port = port\n\nclass AsyncCacheRepository(Generic[TEntity, TKey]):\n    def __init__(\n        self,\n        options: CacheRepositoryOptions[TEntity, TKey],  # \u2190 Type variables!\n        pool: CacheClientPool[TEntity, TKey],            # \u2190 Type variables!\n    ):\n        self.options = options\n        self.pool = pool\n\n# Service registration\nservices = ServiceCollection()\n\n# Register concrete dependencies\nservices.add_singleton(\n    CacheRepositoryOptions[MozartSession, str],\n    implementation_factory=lambda _: CacheRepositoryOptions(\"localhost\", 6379)\n)\n\nservices.add_transient(\n    AsyncCacheRepository[MozartSession, str],\n    AsyncCacheRepository[MozartSession, str]\n)\n\n# This failed in v0.4.2! \u274c\nprovider = services.build()\nrepo = provider.get_required_service(AsyncCacheRepository[MozartSession, str])\n# Error: Failed to resolve service 'CacheRepositoryOptions'\n</code></pre>"},{"location":"fixes/TYPE_VARIABLE_SUBSTITUTION_FIX/#why-it-failed","title":"Why It Failed","text":"<p>When the DI container tried to build <code>AsyncCacheRepository[MozartSession, str]</code>, it:</p> <ol> <li>Inspected the constructor and found <code>options: CacheRepositoryOptions[TEntity, TKey]</code></li> <li>Used the annotation as-is - with <code>TEntity</code> and <code>TKey</code> still as type variables</li> <li>Tried to resolve <code>CacheRepositoryOptions[TEntity, TKey]</code> from the service registry</li> <li>Failed because the registry had <code>CacheRepositoryOptions[MozartSession, str]</code>, not <code>CacheRepositoryOptions[TEntity, TKey]</code></li> </ol> <p>The problem: <code>TEntity</code> and <code>TKey</code> are type variables, not the concrete types <code>MozartSession</code> and <code>str</code> that were used in the service registration.</p>"},{"location":"fixes/TYPE_VARIABLE_SUBSTITUTION_FIX/#root-cause","title":"Root Cause","text":"<p>The code already had the machinery for type variable substitution (<code>TypeExtensions._substitute_generic_arguments()</code>), but it wasn't being called at the critical point.</p> <p>In <code>ServiceProvider._build_service()</code> (and similarly in <code>ServiceScope._build_service()</code>):</p> <pre><code># v0.4.2 code (BROKEN for type variables)\nfor init_arg in service_init_args:\n    origin = get_origin(init_arg.annotation)\n    args = get_args(init_arg.annotation)\n\n    if origin is not None and args:\n        # It's a parameterized generic type (e.g., Repository[User, int])\n        # Use the annotation directly - it's already properly parameterized\n        # Note: TypeVar substitution is handled by get_generic_arguments() at service level\n        dependency_type = init_arg.annotation  # \u2190 WRONG! This still has TEntity, TKey!\n    else:\n        dependency_type = init_arg.annotation\n\n    dependency = self.get_service(dependency_type)  # \u2190 Fails!\n</code></pre> <p>The comment claimed \"TypeVar substitution is handled by get_generic_arguments()\" but this was misleading. The <code>service_generic_args</code> mapping was being computed but never applied to the constructor parameter annotations.</p>"},{"location":"fixes/TYPE_VARIABLE_SUBSTITUTION_FIX/#solution","title":"Solution","text":"<p>Call <code>TypeExtensions._substitute_generic_arguments()</code> to replace type variables with concrete types:</p> <pre><code># v0.4.3 code (FIXED)\nfor init_arg in service_init_args:\n    origin = get_origin(init_arg.annotation)\n    args = get_args(init_arg.annotation)\n\n    if origin is not None and args:\n        # It's a parameterized generic type (e.g., Repository[User, int])\n        # Check if it contains type variables that need substitution\n        # (e.g., CacheRepositoryOptions[TEntity, TKey] -&gt; CacheRepositoryOptions[MozartSession, str])\n        dependency_type = TypeExtensions._substitute_generic_arguments(\n            init_arg.annotation,\n            service_generic_args  # \u2190 Apply the substitution!\n        )\n    else:\n        dependency_type = init_arg.annotation\n\n    dependency = self.get_service(dependency_type)  # \u2190 Now works!\n</code></pre>"},{"location":"fixes/TYPE_VARIABLE_SUBSTITUTION_FIX/#how-substitution-works","title":"How Substitution Works","text":"<p>When building <code>AsyncCacheRepository[MozartSession, str]</code>:</p> <ol> <li>Extract type mapping: <code>service_generic_args = {'TEntity': MozartSession, 'TKey': str}</code></li> <li>Process constructor parameter: <code>options: CacheRepositoryOptions[TEntity, TKey]</code></li> <li>Substitute type variables:</li> <li>Input: <code>CacheRepositoryOptions[TEntity, TKey]</code></li> <li>Mapping: <code>{'TEntity': MozartSession, 'TKey': str}</code></li> <li>Output: <code>CacheRepositoryOptions[MozartSession, str]</code></li> <li>Resolve from registry: Now finds the registered <code>CacheRepositoryOptions[MozartSession, str]</code> \u2705</li> </ol>"},{"location":"fixes/TYPE_VARIABLE_SUBSTITUTION_FIX/#changes-made","title":"Changes Made","text":""},{"location":"fixes/TYPE_VARIABLE_SUBSTITUTION_FIX/#modified-files","title":"Modified Files","text":"<ol> <li><code>src/neuroglia/dependency_injection/service_provider.py</code></li> <li>ServiceProvider._build_service() (lines ~487-490): Added <code>TypeExtensions._substitute_generic_arguments()</code> call</li> <li>ServiceScope._build_service() (lines ~335-338): Added <code>TypeExtensions._substitute_generic_arguments()</code> call</li> </ol>"},{"location":"fixes/TYPE_VARIABLE_SUBSTITUTION_FIX/#code-changes","title":"Code Changes","text":"<p>Both methods had the same fix applied:</p> <pre><code>  for init_arg in service_init_args:\n      origin = get_origin(init_arg.annotation)\n      args = get_args(init_arg.annotation)\n\n      if origin is not None and args:\n-         # It's a parameterized generic type (e.g., Repository[User, int])\n-         # Use the annotation directly - it's already properly parameterized\n-         # The DI container will match it against registered types\n-         # Note: TypeVar substitution is handled by get_generic_arguments() at service level\n-         dependency_type = init_arg.annotation\n+         # It's a parameterized generic type (e.g., Repository[User, int])\n+         # Check if it contains type variables that need substitution\n+         # (e.g., CacheRepositoryOptions[TEntity, TKey] -&gt; CacheRepositoryOptions[MozartSession, str])\n+         dependency_type = TypeExtensions._substitute_generic_arguments(init_arg.annotation, service_generic_args)\n      else:\n          dependency_type = init_arg.annotation\n</code></pre>"},{"location":"fixes/TYPE_VARIABLE_SUBSTITUTION_FIX/#benefits","title":"Benefits","text":"<ol> <li>Type Variable Substitution: Constructor parameters with type variables now work correctly</li> <li>Complex Generic Dependencies: Services can have dependencies that use the same type parameters</li> <li>Type Safety: Full type safety maintained throughout dependency injection</li> <li>No Breaking Changes: Enhancement enables previously failing patterns without affecting existing code</li> </ol>"},{"location":"fixes/TYPE_VARIABLE_SUBSTITUTION_FIX/#impact","title":"Impact","text":""},{"location":"fixes/TYPE_VARIABLE_SUBSTITUTION_FIX/#before-v043-broken","title":"Before v0.4.3 (Broken)","text":"<pre><code>class AsyncCacheRepository(Generic[TEntity, TKey]):\n    def __init__(\n        self,\n        options: CacheRepositoryOptions[TEntity, TKey],  # \u274c Fails!\n    ):\n        ...\n\n# Error: Failed to resolve service 'CacheRepositoryOptions'\n</code></pre>"},{"location":"fixes/TYPE_VARIABLE_SUBSTITUTION_FIX/#after-v043-fixed","title":"After v0.4.3 (Fixed)","text":"<pre><code>class AsyncCacheRepository(Generic[TEntity, TKey]):\n    def __init__(\n        self,\n        options: CacheRepositoryOptions[TEntity, TKey],  # \u2705 Works!\n    ):\n        ...\n\n# Successfully resolves CacheRepositoryOptions[MozartSession, str]\n</code></pre>"},{"location":"fixes/TYPE_VARIABLE_SUBSTITUTION_FIX/#usage-examples","title":"Usage Examples","text":""},{"location":"fixes/TYPE_VARIABLE_SUBSTITUTION_FIX/#simple-type-variable-substitution","title":"Simple Type Variable Substitution","text":"<pre><code>from typing import Generic, TypeVar\nfrom neuroglia.dependency_injection import ServiceCollection\n\nTEntity = TypeVar('TEntity')\nTKey = TypeVar('TKey')\n\nclass Options(Generic[TEntity, TKey]):\n    def __init__(self, name: str):\n        self.name = name\n\nclass Repository(Generic[TEntity, TKey]):\n    def __init__(self, options: Options[TEntity, TKey]):  # \u2190 Type variables!\n        self.options = options\n\nclass User:\n    pass\n\n# Registration\nservices = ServiceCollection()\n\nservices.add_singleton(\n    Options[User, int],\n    implementation_factory=lambda _: Options(\"user-options\")\n)\n\nservices.add_transient(\n    Repository[User, int],\n    Repository[User, int]\n)\n\nprovider = services.build()\n\n# Resolution - now works! \u2705\nrepo = provider.get_required_service(Repository[User, int])\nprint(repo.options.name)  # \"user-options\"\n</code></pre>"},{"location":"fixes/TYPE_VARIABLE_SUBSTITUTION_FIX/#multiple-type-variables","title":"Multiple Type Variables","text":"<pre><code>class ComplexService(Generic[TEntity, TKey]):\n    def __init__(\n        self,\n        options: Options[TEntity, TKey],        # \u2190 Substituted!\n        cache: Cache[TEntity, TKey],            # \u2190 Substituted!\n        validator: Validator[TEntity, TKey],    # \u2190 Substituted!\n    ):\n        self.options = options\n        self.cache = cache\n        self.validator = validator\n\n# All dependencies correctly resolved with MozartSession, str\nservice = provider.get_required_service(ComplexService[MozartSession, str])\n</code></pre>"},{"location":"fixes/TYPE_VARIABLE_SUBSTITUTION_FIX/#nested-generic-types","title":"Nested Generic Types","text":"<pre><code>class NestedOptions(Generic[TEntity, TKey]):\n    def __init__(self, cache_opts: CacheOptions[TEntity, TKey]):\n        self.cache_opts = cache_opts\n\nclass Service(Generic[TEntity, TKey]):\n    def __init__(self, nested: NestedOptions[TEntity, TKey]):  # \u2190 Deep substitution!\n        self.nested = nested\n\n# Type variables substituted at all levels\nservice = provider.get_required_service(Service[User, int])\n</code></pre>"},{"location":"fixes/TYPE_VARIABLE_SUBSTITUTION_FIX/#testing","title":"Testing","text":""},{"location":"fixes/TYPE_VARIABLE_SUBSTITUTION_FIX/#test-coverage","title":"Test Coverage","text":"<p>Added comprehensive test suite in <code>tests/cases/test_type_variable_substitution.py</code>:</p> <ol> <li>test_single_type_variable_substitution: Basic substitution pattern</li> <li>test_multiple_different_type_substitutions: Multiple services with different type arguments</li> <li>test_scoped_lifetime_with_type_variables: Scoped services with type variables</li> <li>test_error_when_substituted_type_not_registered: Error handling</li> <li>test_complex_nested_type_variable_substitution: Nested generic types</li> <li>test_original_async_cache_repository_with_type_vars: Regression test for original bug</li> </ol>"},{"location":"fixes/TYPE_VARIABLE_SUBSTITUTION_FIX/#running-tests","title":"Running Tests","text":"<pre><code># Run type variable substitution tests\npoetry run pytest tests/cases/test_type_variable_substitution.py -v\n\n# Run all generic type tests (14 tests total)\npoetry run pytest tests/cases/test_generic_type_resolution.py tests/cases/test_type_variable_substitution.py -v\n</code></pre> <p>All 14 tests pass \u2705 (8 from v0.4.2 + 6 new)</p>"},{"location":"fixes/TYPE_VARIABLE_SUBSTITUTION_FIX/#migration-guide","title":"Migration Guide","text":""},{"location":"fixes/TYPE_VARIABLE_SUBSTITUTION_FIX/#no-code-changes-required","title":"No Code Changes Required","text":"<p>This is a bug fix that enables previously failing patterns. Existing code continues to work unchanged.</p>"},{"location":"fixes/TYPE_VARIABLE_SUBSTITUTION_FIX/#newly-enabled-patterns","title":"Newly Enabled Patterns","text":"<p>If you previously worked around the limitation by using concrete types in constructor parameters, you can now use type variables for better genericity:</p> <p>Before (workaround):</p> <pre><code>class MozartSessionRepository:\n    def __init__(\n        self,\n        options: CacheRepositoryOptions[MozartSession, str]  # Concrete types\n    ):\n        ...\n</code></pre> <p>After (type variables):</p> <pre><code>class AsyncCacheRepository(Generic[TEntity, TKey]):\n    def __init__(\n        self,\n        options: CacheRepositoryOptions[TEntity, TKey]  # Type variables!\n    ):\n        ...\n\n# More flexible - can be used with any entity type\nprovider.get_required_service(AsyncCacheRepository[MozartSession, str])\nprovider.get_required_service(AsyncCacheRepository[User, int])\n</code></pre>"},{"location":"fixes/TYPE_VARIABLE_SUBSTITUTION_FIX/#related-documentation","title":"Related Documentation","text":"<ul> <li>v0.4.2 Fix: Generic type resolution (using <code>get_origin()</code> and <code>get_args()</code>)</li> <li>TypeExtensions: <code>_substitute_generic_arguments()</code> implementation</li> <li>Generic Type Tests: <code>tests/cases/test_generic_type_resolution.py</code></li> <li>Type Variable Tests: <code>tests/cases/test_type_variable_substitution.py</code></li> </ul>"},{"location":"fixes/TYPE_VARIABLE_SUBSTITUTION_FIX/#version-information","title":"Version Information","text":"<ul> <li>Fixed in: v0.4.3</li> <li>Release Date: 2025-10-19</li> <li>Related Issues: Type variable substitution in generic dependencies</li> <li>Previous Versions: v0.4.2 (partial fix), v0.4.1 (controller routing), v0.4.0 (initial)</li> </ul>"},{"location":"guides/","title":"\ud83d\udcda Guides and How-To's","text":"<p>\ud83d\udea7 Under Construction</p> <p>This section is currently being developed with step-by-step guides and practical examples. Individual guide pages with detailed procedures and troubleshooting tips are being created.</p> <p>Practical procedures and troubleshooting guides for developing with the Neuroglia framework.</p>"},{"location":"guides/#getting-started-guides","title":"\ud83d\ude80 Getting Started Guides","text":""},{"location":"guides/#project-setup","title":"Project Setup","text":"<ul> <li>Creating new projects with <code>pyneuroctl</code></li> <li>Setting up development environment</li> <li>Configuring IDE support</li> </ul>"},{"location":"guides/#testing-setup","title":"Testing Setup","text":"<ul> <li>Unit testing strategies</li> <li>Integration testing patterns</li> <li>Test data management</li> </ul>"},{"location":"guides/#development-guides","title":"\ud83c\udfd7\ufe0f Development Guides","text":""},{"location":"guides/#building-apis","title":"Building APIs","text":"<ul> <li>Creating controllers and endpoints</li> <li>Request/response modeling</li> <li>Authentication and authorization</li> </ul>"},{"location":"guides/#data-management","title":"Data Management","text":"<ul> <li>Repository implementation</li> <li>Database integration</li> <li>Event sourcing setup</li> </ul>"},{"location":"guides/#event-driven-development","title":"Event-Driven Development","text":"<ul> <li>Domain event design</li> <li>Event handlers</li> <li>CloudEvents integration</li> </ul>"},{"location":"guides/#operations-guides","title":"\ud83d\udd27 Operations Guides","text":""},{"location":"guides/#deployment","title":"Deployment","text":"<ul> <li>Docker containerization</li> <li>Kubernetes deployment</li> <li>Environment configuration</li> </ul>"},{"location":"guides/#monitoring","title":"Monitoring","text":"<ul> <li>Logging configuration</li> <li>Health checks</li> <li>Performance monitoring</li> </ul>"},{"location":"guides/#troubleshooting","title":"\ud83d\udc1b Troubleshooting","text":""},{"location":"guides/#common-issues","title":"Common Issues","text":"<ul> <li>Dependency injection problems</li> <li>Mediator configuration</li> <li>Database connectivity</li> </ul>"},{"location":"guides/#debugging-techniques","title":"Debugging Techniques","text":"<ul> <li>Testing strategies</li> <li>Logging best practices</li> <li>Performance profiling</li> </ul> <p>Detailed guides with step-by-step instructions coming soon \ud83d\udea7</p>"},{"location":"guides/3-min-bootstrap/","title":"\u26a1 3-Minute Bootstrap: Hello World","text":"<p>Get up and running with Neuroglia in under 3 minutes! This quick-start guide gets you from zero to a working API in the fastest way possible.</p> <p>\ud83c\udfaf What You'll Build</p> <p>A minimal \"Hello Pizzeria\" API with one endpoint that demonstrates the basic framework setup.</p>"},{"location":"guides/3-min-bootstrap/#quick-setup","title":"\ud83d\ude80 Quick Setup","text":""},{"location":"guides/3-min-bootstrap/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8+ installed</li> <li>pip package manager</li> </ul>"},{"location":"guides/3-min-bootstrap/#installation","title":"Installation","text":"<pre><code># Create new directory\nmkdir hello-pizzeria &amp;&amp; cd hello-pizzeria\n\n# Install Neuroglia\npip install neuroglia-python[web]\n</code></pre>"},{"location":"guides/3-min-bootstrap/#create-your-first-api","title":"\ud83d\udcdd Create Your First API","text":"<p>Create <code>main.py</code>:</p> <pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.mvc import ControllerBase\nfrom classy_fastapi.decorators import get\n\nclass HelloController(ControllerBase):\n    \"\"\"Simple hello world controller\"\"\"\n\n    @get(\"/hello\")\n    async def hello_world(self) -&gt; dict:\n        \"\"\"Say hello to Mario's Pizzeria!\"\"\"\n        return {\n            \"message\": \"Welcome to Mario's Pizzeria! \ud83c\udf55\",\n            \"status\": \"We're open for business!\",\n            \"framework\": \"Neuroglia Python\"\n        }\n\ndef create_app():\n    \"\"\"Create the web application\"\"\"\n    builder = WebApplicationBuilder()\n\n    # Add controllers\n    services = builder.services\n    services.add_controllers([HelloController])\n\n    # Build app\n    app = builder.build()\n    app.use_controllers()\n\n    return app\n\nif __name__ == \"__main__\":\n    import uvicorn\n    app = create_app()\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre>"},{"location":"guides/3-min-bootstrap/#run-your-api","title":"\ud83c\udfc3\u200d\u2642\ufe0f Run Your API","text":"<pre><code>python main.py\n</code></pre>"},{"location":"guides/3-min-bootstrap/#test-your-api","title":"\ud83c\udf89 Test Your API","text":"<p>Open your browser and visit:</p> <ul> <li>API Endpoint: http://localhost:8000/hello</li> <li>API Documentation: http://localhost:8000/docs</li> </ul> <p>You should see:</p> <pre><code>{\n  \"message\": \"Welcome to Mario's Pizzeria! \ud83c\udf55\",\n  \"status\": \"We're open for business!\",\n  \"framework\": \"Neuroglia Python\"\n}\n</code></pre>"},{"location":"guides/3-min-bootstrap/#what-youve-accomplished","title":"\u2705 What You've Accomplished","text":"<p>In just 3 minutes, you've created:</p> <ul> <li>\u2705 A working FastAPI application with Neuroglia</li> <li>\u2705 Automatic API documentation (Swagger UI)</li> <li>\u2705 Controller-based routing with clean architecture</li> <li>\u2705 Automatic module discovery</li> <li>\u2705 Dependency injection container setup</li> </ul>"},{"location":"guides/3-min-bootstrap/#next-steps","title":"\ud83d\udd04 Next Steps","text":"<p>Now that you have the basics working:</p> <ol> <li>\ud83d\udee0\ufe0f Local Development Setup - Set up a proper development environment</li> <li>\ud83c\udf55 Mario's Pizzeria Tutorial - Build a complete application (1 hour)</li> <li>\ud83c\udfaf Architecture Patterns - Learn the design principles</li> <li>\ud83d\ude80 Framework Features - Explore advanced capabilities</li> </ol>"},{"location":"guides/3-min-bootstrap/#key-concepts-introduced","title":"\ud83d\udd17 Key Concepts Introduced","text":"<p>This hello world example demonstrates:</p> <ul> <li>Controller Pattern - Web request handling</li> <li>Dependency Injection - Service container setup</li> <li>WebApplicationBuilder - Application bootstrapping</li> </ul> <p>\ud83c\udfaf Pro Tip</p> <p>This is just the beginning! The framework includes powerful features like CQRS, event sourcing, and advanced data access patterns. Continue with the Local Development Setup to explore more.</p>"},{"location":"guides/jsonserializer-configuration/","title":"JsonSerializer and TypeRegistry Configuration Examples","text":"<p>This document provides comprehensive configuration patterns for the JsonSerializer with TypeRegistry to support different project structures and domain discovery requirements.</p>"},{"location":"guides/jsonserializer-configuration/#overview","title":"Overview","text":"<p>The configurable type discovery system allows you to specify which modules contain your enums and domain types, eliminating the need for hardcoded patterns in the framework. This provides flexibility for different project architectures while maintaining performance through intelligent caching.</p>"},{"location":"guides/jsonserializer-configuration/#configuration-methods","title":"Configuration Methods","text":""},{"location":"guides/jsonserializer-configuration/#method-1-configure-during-jsonserializer-setup","title":"Method 1: Configure During JsonSerializer Setup","text":"<pre><code>from neuroglia.hosting.enhanced_web_application_builder import EnhancedWebApplicationBuilder\nfrom neuroglia.serialization.json import JsonSerializer\n\ndef configure_mario_pizzeria_types():\n    \"\"\"Example: Configure types for Mario Pizzeria application\"\"\"\n    builder = EnhancedWebApplicationBuilder()\n\n    # Configure during JsonSerializer setup\n    JsonSerializer.configure(\n        builder,\n        type_modules=[\n            \"domain.entities.enums\",    # Main enum module\n            \"domain.entities\",          # Entity module (for embedded enums)\n            \"domain.value_objects\",     # Value objects with enums\n            \"shared.enums\",             # Shared enumeration types\n        ]\n    )\n\n    return builder\n</code></pre>"},{"location":"guides/jsonserializer-configuration/#method-2-register-types-after-configuration","title":"Method 2: Register Types After Configuration","text":"<pre><code>from neuroglia.hosting.enhanced_web_application_builder import EnhancedWebApplicationBuilder\nfrom neuroglia.serialization.json import JsonSerializer\n\ndef configure_generic_ddd_application():\n    \"\"\"Example: Configure types for generic DDD application\"\"\"\n    builder = EnhancedWebApplicationBuilder()\n\n    # Configure JsonSerializer first\n    JsonSerializer.configure(builder)\n\n    # Register additional type modules\n    JsonSerializer.register_type_modules([\n        \"myapp.domain.aggregates\",\n        \"myapp.domain.value_objects\",\n        \"myapp.domain.enums\",\n        \"myapp.shared.types\",\n        \"myapp.integration.external_types\",\n    ])\n\n    return builder\n</code></pre>"},{"location":"guides/jsonserializer-configuration/#method-3-direct-typeregistry-configuration","title":"Method 3: Direct TypeRegistry Configuration","text":"<pre><code>from neuroglia.core.type_registry import get_type_registry\nfrom neuroglia.hosting.enhanced_web_application_builder import EnhancedWebApplicationBuilder\nfrom neuroglia.serialization.json import JsonSerializer\n\ndef configure_microservice_types():\n    \"\"\"Example: Configure types for microservice with external dependencies\"\"\"\n    builder = EnhancedWebApplicationBuilder()\n\n    # Get the global TypeRegistry instance\n    type_registry = get_type_registry()\n\n    # Register our domain modules\n    type_registry.register_modules([\n        \"orders.domain.entities\",\n        \"orders.domain.enums\",\n        \"orders.shared.types\"\n    ])\n\n    # Register shared library types\n    type_registry.register_modules([\n        \"shared_lib.common.enums\",\n        \"shared_lib.business.types\"\n    ])\n\n    # Register external API types that we need to deserialize\n    type_registry.register_modules([\n        \"external_api_client.models\",\n        \"payment_gateway.types\"\n    ])\n\n    JsonSerializer.configure(builder)\n\n    return builder\n</code></pre>"},{"location":"guides/jsonserializer-configuration/#project-structure-examples","title":"Project Structure Examples","text":""},{"location":"guides/jsonserializer-configuration/#flat-project-structure","title":"Flat Project Structure","text":"<pre><code>from neuroglia.hosting.enhanced_web_application_builder import EnhancedWebApplicationBuilder\nfrom neuroglia.serialization.json import JsonSerializer\n\ndef configure_flat_project_structure():\n    \"\"\"Example: Configure types for flat project structure\"\"\"\n    builder = EnhancedWebApplicationBuilder()\n\n    # For projects with flat structure like:\n    # myproject/\n    #   models.py\n    #   enums.py\n    #   types.py\n    JsonSerializer.configure(\n        builder,\n        type_modules=[\n            \"models\",      # Main model types\n            \"enums\",       # All enumerations\n            \"types\",       # Custom types\n            \"constants\",   # Constants and lookups\n        ]\n    )\n\n    return builder\n</code></pre>"},{"location":"guides/jsonserializer-configuration/#domain-driven-design-structure","title":"Domain-Driven Design Structure","text":"<pre><code>def configure_ddd_structure():\n    \"\"\"Example: Configure types for DDD project structure\"\"\"\n    # For projects with DDD structure like:\n    # myproject/\n    #   domain/\n    #     aggregates/\n    #     entities/\n    #     value_objects/\n    #     enums/\n    #   application/\n    #   infrastructure/\n\n    JsonSerializer.configure(\n        builder,\n        type_modules=[\n            \"domain.enums\",\n            \"domain.entities\",\n            \"domain.value_objects\",\n            \"domain.aggregates\",\n            \"shared.types\"\n        ]\n    )\n</code></pre>"},{"location":"guides/jsonserializer-configuration/#microservice-architecture","title":"Microservice Architecture","text":"<pre><code>def configure_microservice_architecture():\n    \"\"\"Example: Configure types for microservice architecture\"\"\"\n    # For microservices that need to handle:\n    # - Internal domain types\n    # - Shared library types\n    # - External service types\n\n    type_registry = get_type_registry()\n\n    # Internal domain\n    type_registry.register_modules([\n        \"user_service.domain.enums\",\n        \"user_service.domain.entities\"\n    ])\n\n    # Shared libraries\n    type_registry.register_modules([\n        \"common_lib.enums\",\n        \"auth_lib.types\"\n    ])\n\n    # External services\n    type_registry.register_modules([\n        \"notification_service.contracts\",\n        \"payment_service.models\"\n    ])\n</code></pre>"},{"location":"guides/jsonserializer-configuration/#dynamic-type-discovery","title":"Dynamic Type Discovery","text":"<p>For more advanced scenarios, you can dynamically discover and register types:</p> <pre><code>from enum import Enum\nfrom neuroglia.core.module_loader import ModuleLoader\nfrom neuroglia.core.type_finder import TypeFinder\nfrom neuroglia.core.type_registry import get_type_registry\n\ndef dynamic_type_discovery_example():\n    \"\"\"Example: Dynamically discover and register types\"\"\"\n    type_registry = get_type_registry()\n\n    # Example: Discover all enum types in a base module\n    base_modules = [\"myapp.domain\", \"myapp.shared\", \"myapp.external\"]\n\n    for base_module_name in base_modules:\n        try:\n            base_module = ModuleLoader.load(base_module_name)\n\n            # Find all enum types in this module and submodules\n            enum_types = TypeFinder.get_types(\n                base_module,\n                predicate=lambda t: (\n                    isinstance(t, type)\n                    and issubclass(t, Enum)\n                    and t != Enum\n                ),\n                include_sub_modules=True,\n                include_sub_packages=True\n            )\n\n            if enum_types:\n                print(f\"Found {len(enum_types)} enum types in {base_module_name}\")\n                # The TypeRegistry will cache these automatically when they're accessed\n\n        except ImportError:\n            print(f\"Module {base_module_name} not available\")\n\n    return type_registry\n</code></pre>"},{"location":"guides/jsonserializer-configuration/#performance-considerations","title":"Performance Considerations","text":""},{"location":"guides/jsonserializer-configuration/#module-registration-best-practices","title":"Module Registration Best Practices","text":"<ol> <li>Register Early: Register type modules during application startup to avoid runtime discovery overhead</li> <li>Be Specific: Register only the modules that contain types you need to deserialize</li> <li>Use Caching: The TypeRegistry automatically caches discovered types for performance</li> <li>Group Related Types: Keep related enums and types in organized module structures</li> </ol>"},{"location":"guides/jsonserializer-configuration/#example-startup-configuration","title":"Example Startup Configuration","text":"<pre><code>from neuroglia.hosting.enhanced_web_application_builder import EnhancedWebApplicationBuilder\nfrom neuroglia.serialization.json import JsonSerializer\n\ndef create_optimized_app():\n    \"\"\"Example: Optimized application startup with type registration\"\"\"\n    builder = EnhancedWebApplicationBuilder()\n\n    # Register all type modules at startup\n    type_modules = [\n        # Core domain types\n        \"domain.enums\",\n        \"domain.entities\",\n\n        # Application layer types\n        \"application.commands\",\n        \"application.queries\",\n\n        # Integration types\n        \"integration.external_apis\",\n        \"integration.shared_contracts\",\n\n        # Testing types (if needed in production)\n        # \"tests.fixtures.types\",\n    ]\n\n    JsonSerializer.configure(builder, type_modules=type_modules)\n\n    # Build application\n    app = builder.build()\n\n    return app\n</code></pre>"},{"location":"guides/jsonserializer-configuration/#error-handling-and-debugging","title":"Error Handling and Debugging","text":""},{"location":"guides/jsonserializer-configuration/#debugging-type-discovery","title":"Debugging Type Discovery","text":"<pre><code>from neuroglia.core.type_registry import get_type_registry\n\ndef debug_type_discovery():\n    \"\"\"Debug helper to inspect registered types\"\"\"\n    type_registry = get_type_registry()\n\n    # Check registered modules\n    modules = type_registry.get_registered_modules()\n    print(f\"Registered modules: {modules}\")\n\n    # Check cached enum types\n    cached_enums = type_registry.get_cached_enum_types()\n    print(f\"Cached enum types: {list(cached_enums.keys())}\")\n\n    # Test enum lookup\n    test_value = \"test_value\"\n    found_enum = type_registry.find_enum_for_value(test_value)\n    print(f\"Enum for '{test_value}': {found_enum}\")\n</code></pre>"},{"location":"guides/jsonserializer-configuration/#common-configuration-issues","title":"Common Configuration Issues","text":"<ol> <li>Module Not Found: Ensure module paths are correct and modules are importable</li> <li>No Enums Discovered: Check that enum classes are properly defined and accessible</li> <li>Performance Issues: Avoid registering too many modules or very large module trees</li> </ol>"},{"location":"guides/jsonserializer-configuration/#testing-configuration","title":"Testing Configuration","text":"<p>For testing scenarios, you can configure type discovery specifically for test environments:</p> <pre><code>def configure_test_types():\n    \"\"\"Example: Configure types for testing environment\"\"\"\n    from neuroglia.core.type_registry import get_type_registry\n\n    type_registry = get_type_registry()\n\n    # Register test-specific modules\n    test_modules = [\n        \"tests.fixtures.enums\",\n        \"tests.mocks.types\",\n        \"tests.data.models\"\n    ]\n\n    type_registry.register_modules(test_modules)\n\n    return type_registry\n</code></pre>"},{"location":"guides/jsonserializer-configuration/#best-practices-summary","title":"Best Practices Summary","text":"<ol> <li>Early Registration: Register type modules during application startup</li> <li>Specific Modules: Only register modules containing types you need to deserialize</li> <li>Organized Structure: Keep related types in well-organized module hierarchies</li> <li>Performance Monitoring: Monitor type discovery performance in production</li> <li>Clear Documentation: Document your type module organization for team members</li> <li>Environment-Specific: Use different configurations for development, testing, and production</li> <li>Error Handling: Include proper error handling for module loading failures</li> </ol> <p>This configurable approach provides maximum flexibility while maintaining the performance and reliability of the Neuroglia framework's serialization system.</p>"},{"location":"guides/local-development/","title":"\ud83d\udee0\ufe0f Local Development Environment Setup","text":"<p>Set up a complete local development environment for productive Neuroglia development. This guide covers tooling, IDE setup, debugging, and best practices for building maintainable applications.</p> <p>\ud83c\udfaf What You'll Set Up</p> <p>A professional development environment with debugging, testing, linting, and database integration.</p>"},{"location":"guides/local-development/#prerequisites","title":"\ud83d\udccb Prerequisites","text":""},{"location":"guides/local-development/#system-requirements","title":"System Requirements","text":"<ul> <li>Python 3.8+ with pip</li> <li>Git for version control</li> <li>Docker &amp; Docker Compose for services (MongoDB, Redis, etc.)</li> <li>VS Code or PyCharm (recommended IDEs)</li> </ul>"},{"location":"guides/local-development/#verify-installation","title":"Verify Installation","text":"<pre><code>python --version  # Should be 3.8+\npip --version\ngit --version\ndocker --version\ndocker-compose --version\n</code></pre>"},{"location":"guides/local-development/#project-setup","title":"\ud83d\ude80 Project Setup","text":""},{"location":"guides/local-development/#1-create-project-structure","title":"1. Create Project Structure","text":"<pre><code># Create project directory\nmkdir my-neuroglia-app &amp;&amp; cd my-neuroglia-app\n\n# Initialize git repository\ngit init\n\n# Create standard project structure\nmkdir -p src/{api,application,domain,integration}\nmkdir -p src/api/{controllers,dtos}\nmkdir -p src/application/{commands,queries,handlers}\nmkdir -p src/domain/{entities,events,repositories}\nmkdir -p src/integration/{repositories,services}\nmkdir -p tests/{unit,integration,fixtures}\nmkdir -p docs\ntouch README.md\n</code></pre>"},{"location":"guides/local-development/#2-python-environment-setup","title":"2. Python Environment Setup","text":"<p>Option A: Using Poetry (Recommended)</p> <pre><code># Install Poetry if not already installed\ncurl -sSL https://install.python-poetry.org | python3 -\n\n# Initialize Poetry project\npoetry init\n\n# Add Neuroglia and development dependencies\npoetry add neuroglia-python[web]\npoetry add --group dev pytest pytest-asyncio pytest-cov black flake8 mypy\n\n# Create virtual environment and activate\npoetry install\npoetry shell\n</code></pre> <p>Option B: Using venv</p> <pre><code># Create virtual environment\npython -m venv venv\n\n# Activate virtual environment\n# On macOS/Linux:\nsource venv/bin/activate\n# On Windows:\n# venv\\Scripts\\activate\n\n# Install dependencies\npip install neuroglia-python[web]\npip install pytest pytest-asyncio pytest-cov black flake8 mypy\n</code></pre>"},{"location":"guides/local-development/#3-development-configuration-files","title":"3. Development Configuration Files","text":"<p>pyproject.toml (Poetry users):</p> <pre><code>[tool.poetry]\nname = \"my-neuroglia-app\"\nversion = \"0.1.0\"\ndescription = \"My Neuroglia Application\"\nauthors = [\"Your Name &lt;your.email@example.com&gt;\"]\n\n[tool.poetry.dependencies]\npython = \"^3.8\"\nneuroglia-python = {extras = [\"web\"], version = \"^1.0.0\"}\n\n[tool.poetry.group.dev.dependencies]\npytest = \"^7.0.0\"\npytest-asyncio = \"^0.20.0\"\npytest-cov = \"^4.0.0\"\nblack = \"^22.0.0\"\nflake8 = \"^5.0.0\"\nmypy = \"^1.0.0\"\n\n[tool.black]\nline-length = 88\ntarget-version = ['py38']\n\n[tool.mypy]\npython_version = \"3.8\"\nwarn_return_any = true\nwarn_unused_configs = true\ndisallow_untyped_defs = true\n</code></pre> <p>requirements.txt (venv users):</p> <pre><code>neuroglia-python[web]&gt;=1.0.0\npytest&gt;=7.0.0\npytest-asyncio&gt;=0.20.0\npytest-cov&gt;=4.0.0\nblack&gt;=22.0.0\nflake8&gt;=5.0.0\nmypy&gt;=1.0.0\n</code></pre> <p>pytest.ini:</p> <pre><code>[tool:pytest]\ntestpaths = tests\npython_files = test_*.py\npython_classes = Test*\npython_functions = test_*\nasyncio_mode = auto\naddopts = --cov=src --cov-report=html --cov-report=term\n</code></pre>"},{"location":"guides/local-development/#ide-configuration","title":"\ud83d\udd27 IDE Configuration","text":""},{"location":"guides/local-development/#vs-code-setup","title":"VS Code Setup","text":"<p>Install Extensions:</p> <pre><code># Install VS Code extensions\ncode --install-extension ms-python.python\ncode --install-extension ms-python.black-formatter\ncode --install-extension ms-python.flake8\ncode --install-extension ms-python.mypy-type-checker\ncode --install-extension bradlc.vscode-tailwindcss\ncode --install-extension ms-vscode.vscode-json\n</code></pre> <p>.vscode/settings.json:</p> <pre><code>{\n  \"python.defaultInterpreterPath\": \"./venv/bin/python\",\n  \"python.linting.enabled\": true,\n  \"python.linting.flake8Enabled\": true,\n  \"python.formatting.provider\": \"black\",\n  \"python.testing.pytestEnabled\": true,\n  \"python.testing.pytestArgs\": [\"tests\"],\n  \"editor.formatOnSave\": true,\n  \"editor.codeActionsOnSave\": {\n    \"source.organizeImports\": true\n  }\n}\n</code></pre> <p>.vscode/launch.json (for debugging):</p> <pre><code>{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"Python: FastAPI\",\n      \"type\": \"python\",\n      \"request\": \"launch\",\n      \"program\": \"${workspaceFolder}/src/main.py\",\n      \"console\": \"integratedTerminal\",\n      \"env\": {\n        \"PYTHONPATH\": \"${workspaceFolder}/src\"\n      }\n    },\n    {\n      \"name\": \"Python: Pytest\",\n      \"type\": \"python\",\n      \"request\": \"launch\",\n      \"module\": \"pytest\",\n      \"args\": [\"tests\", \"-v\"],\n      \"console\": \"integratedTerminal\"\n    }\n  ]\n}\n</code></pre>"},{"location":"guides/local-development/#docker-development-services","title":"\ud83d\udc33 Docker Development Services","text":"<p>docker-compose.dev.yml:</p> <pre><code>version: \"3.8\"\n\nservices:\n  mongodb:\n    image: mongo:5.0\n    ports:\n      - \"27017:27017\"\n    environment:\n      MONGO_INITDB_ROOT_USERNAME: admin\n      MONGO_INITDB_ROOT_PASSWORD: password\n    volumes:\n      - mongodb_data:/data/db\n    networks:\n      - neuroglia-dev\n\n  redis:\n    image: redis:7-alpine\n    ports:\n      - \"6379:6379\"\n    networks:\n      - neuroglia-dev\n\n  mailhog:\n    image: mailhog/mailhog\n    ports:\n      - \"1025:1025\" # SMTP\n      - \"8025:8025\" # Web UI\n    networks:\n      - neuroglia-dev\n\nvolumes:\n  mongodb_data:\n\nnetworks:\n  neuroglia-dev:\n    driver: bridge\n</code></pre> <p>Start development services:</p> <pre><code>docker-compose -f docker-compose.dev.yml up -d\n</code></pre>"},{"location":"guides/local-development/#testing-setup","title":"\ud83e\uddea Testing Setup","text":"<p>tests/conftest.py:</p> <pre><code>import pytest\nfrom neuroglia.dependency_injection import ServiceCollection\nfrom neuroglia.mediation import Mediator\n\n@pytest.fixture\ndef service_collection():\n    \"\"\"Create a fresh service collection for testing\"\"\"\n    return ServiceCollection()\n\n@pytest.fixture\ndef service_provider(service_collection):\n    \"\"\"Create a service provider for testing\"\"\"\n    service_collection.add_mediator()\n    return service_collection.build_provider()\n\n@pytest.fixture\ndef mediator(service_provider):\n    \"\"\"Get mediator instance for testing\"\"\"\n    return service_provider.get_service(Mediator)\n</code></pre> <p>tests/unit/test_example.py:</p> <pre><code>import pytest\nfrom src.domain.entities.example import ExampleEntity\n\nclass TestExampleEntity:\n    def test_entity_creation(self):\n        \"\"\"Test entity can be created successfully\"\"\"\n        entity = ExampleEntity(name=\"Test\")\n        assert entity.name == \"Test\"\n        assert entity.id is not None\n\n    @pytest.mark.asyncio\n    async def test_async_operation(self):\n        \"\"\"Test async operations work correctly\"\"\"\n        # Add async test logic here\n        pass\n</code></pre>"},{"location":"guides/local-development/#development-workflow","title":"\ud83c\udfc3\u200d\u2642\ufe0f Development Workflow","text":""},{"location":"guides/local-development/#daily-development-commands","title":"Daily Development Commands","text":"<pre><code># Start development services\ndocker-compose -f docker-compose.dev.yml up -d\n\n# Activate virtual environment (if using venv)\nsource venv/bin/activate  # or `poetry shell`\n\n# Run your application\npython src/main.py\n\n# Run tests\npytest\n\n# Run tests with coverage\npytest --cov=src --cov-report=html\n\n# Format code\nblack src tests\n\n# Lint code\nflake8 src tests\n\n# Type checking\nmypy src\n</code></pre>"},{"location":"guides/local-development/#git-hooks-setup","title":"Git Hooks Setup","text":"<p>.pre-commit-config.yaml:</p> <pre><code>repos:\n  - repo: https://github.com/psf/black\n    rev: 22.3.0\n    hooks:\n      - id: black\n        language_version: python3.8\n\n  - repo: https://github.com/pycqa/flake8\n    rev: 5.0.4\n    hooks:\n      - id: flake8\n\n  - repo: https://github.com/pre-commit/mirrors-mypy\n    rev: v1.0.0\n    hooks:\n      - id: mypy\n</code></pre> <p>Install pre-commit:</p> <pre><code>pip install pre-commit\npre-commit install\n</code></pre>"},{"location":"guides/local-development/#debugging-and-monitoring","title":"\ud83d\udd0d Debugging and Monitoring","text":""},{"location":"guides/local-development/#application-logging","title":"Application Logging","text":"<p>src/config/logging.py:</p> <pre><code>import logging\nimport sys\nfrom pathlib import Path\n\ndef setup_logging(log_level: str = \"INFO\"):\n    \"\"\"Configure application logging\"\"\"\n\n    # Create logs directory\n    Path(\"logs\").mkdir(exist_ok=True)\n\n    # Configure logging\n    logging.basicConfig(\n        level=getattr(logging, log_level.upper()),\n        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n        handlers=[\n            logging.FileHandler('logs/app.log'),\n            logging.StreamHandler(sys.stdout)\n        ]\n    )\n\n    # Configure third-party loggers\n    logging.getLogger(\"uvicorn\").setLevel(logging.INFO)\n    logging.getLogger(\"fastapi\").setLevel(logging.INFO)\n</code></pre>"},{"location":"guides/local-development/#environment-configuration","title":"Environment Configuration","text":"<p>.env.development:</p> <pre><code># Application\nAPP_NAME=My Neuroglia App\nAPP_VERSION=0.1.0\nDEBUG=true\nLOG_LEVEL=DEBUG\n\n# Database\nMONGODB_URL=mongodb://admin:password@localhost:27017\nREDIS_URL=redis://localhost:6379\n\n# External Services\nSMTP_HOST=localhost\nSMTP_PORT=1025\n</code></pre>"},{"location":"guides/local-development/#environment-validation","title":"\u2705 Environment Validation","text":"<p>Create a validation script to ensure everything is set up correctly:</p> <p>scripts/validate-env.py:</p> <pre><code>#!/usr/bin/env python3\n\"\"\"Validate development environment setup\"\"\"\n\nimport sys\nimport subprocess\nfrom pathlib import Path\n\ndef check_python_version():\n    \"\"\"Check Python version\"\"\"\n    if sys.version_info &lt; (3, 8):\n        print(\"\u274c Python 3.8+ required\")\n        return False\n    print(f\"\u2705 Python {sys.version_info.major}.{sys.version_info.minor}\")\n    return True\n\ndef check_dependencies():\n    \"\"\"Check if required packages are installed\"\"\"\n    try:\n        import neuroglia\n        print(\"\u2705 Neuroglia installed\")\n        return True\n    except ImportError:\n        print(\"\u274c Neuroglia not installed\")\n        return False\n\ndef check_docker():\n    \"\"\"Check if Docker services are running\"\"\"\n    try:\n        result = subprocess.run(\n            [\"docker\", \"ps\"],\n            capture_output=True,\n            text=True,\n            check=True\n        )\n        if \"mongo\" in result.stdout and \"redis\" in result.stdout:\n            print(\"\u2705 Docker services running\")\n            return True\n        else:\n            print(\"\u26a0\ufe0f  Docker services not all running\")\n            return False\n    except (subprocess.CalledProcessError, FileNotFoundError):\n        print(\"\u274c Docker not available\")\n        return False\n\nif __name__ == \"__main__\":\n    checks = [\n        check_python_version(),\n        check_dependencies(),\n        check_docker()\n    ]\n\n    if all(checks):\n        print(\"\\n\ud83c\udf89 Development environment is ready!\")\n    else:\n        print(\"\\n\u274c Some issues need to be resolved\")\n        sys.exit(1)\n</code></pre> <p>Run validation:</p> <pre><code>python scripts/validate-env.py\n</code></pre>"},{"location":"guides/local-development/#next-steps","title":"\ud83d\udd04 Next Steps","text":"<p>Your development environment is now ready! Continue with:</p> <ol> <li>\u26a1 3-Minute Bootstrap - Quick hello world setup</li> <li>\ud83c\udf55 Mario's Pizzeria Tutorial - Build a complete application</li> <li>\ud83c\udfaf Architecture Patterns - Learn design principles</li> <li>\ud83d\ude80 Framework Features - Explore advanced capabilities</li> </ol>"},{"location":"guides/local-development/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Dependency Injection Setup - Advanced DI configuration</li> <li>Testing Strategies - Comprehensive testing approaches</li> <li>Project Structure - Detailed project organization</li> </ul> <p>\ud83c\udfaf Pro Tip</p> <p>Bookmark this page! You'll refer back to these commands and configurations throughout your development journey.</p>"},{"location":"guides/mario-pizzeria-tutorial/","title":"\ud83c\udf55 Mario's Pizzeria Tutorial","text":"<p>Build a complete pizza ordering system that demonstrates all of Neuroglia's features in a familiar, easy-to-understand context. This comprehensive tutorial covers clean architecture, CQRS, event-driven design, and web development.</p> <p>\ud83c\udfaf What You'll Build</p> <p>A complete pizzeria application with REST API, web UI, authentication, file-based persistence, and event-driven architecture.</p>"},{"location":"guides/mario-pizzeria-tutorial/#what-youll-build","title":"\ud83d\udccb What You'll Build","text":"<p>By the end of this guide, you'll have a complete pizzeria application with:</p> <ul> <li>\ud83c\udf10 REST API with automatic Swagger documentation</li> <li>\ud83c\udfa8 Simple Web UI for customers and kitchen staff</li> <li>\ud83d\udd10 OAuth Authentication for secure access</li> <li>\ud83d\udcbe File-based persistence using the repository pattern</li> <li>\ud83d\udce1 Event-driven architecture with domain events</li> <li>\ud83c\udfd7\ufe0f Clean Architecture with CQRS and dependency injection</li> </ul>"},{"location":"guides/mario-pizzeria-tutorial/#quick-setup","title":"\u26a1 Quick Setup","text":""},{"location":"guides/mario-pizzeria-tutorial/#installation","title":"Installation","text":"<pre><code>pip install neuroglia-python[web]\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#project-structure","title":"Project Structure","text":"<p>The actual Mario's Pizzeria implementation follows clean architecture principles:</p> <p>Source: <code>samples/mario-pizzeria/</code></p> <pre><code>mario-pizzeria/\n\u251c\u2500\u2500 main.py                       # Application entry point with DI setup\n\u251c\u2500\u2500 api/\n\u2502   \u251c\u2500\u2500 controllers/             # REST API endpoints\n\u2502   \u2502   \u251c\u2500\u2500 orders_controller.py  # Order management\n\u2502   \u2502   \u251c\u2500\u2500 menu_controller.py    # Pizza menu\n\u2502   \u2502   \u2514\u2500\u2500 kitchen_controller.py # Kitchen operations\n\u2502   \u2514\u2500\u2500 dtos/                    # Data Transfer Objects\n\u2502       \u251c\u2500\u2500 order_dtos.py        # Order request/response models\n\u2502       \u251c\u2500\u2500 menu_dtos.py         # Menu item models\n\u2502       \u2514\u2500\u2500 kitchen_dtos.py      # Kitchen status models\n\u251c\u2500\u2500 application/\n\u2502   \u251c\u2500\u2500 commands/                # CQRS Command handlers\n\u2502   \u2502   \u251c\u2500\u2500 place_order_command.py\n\u2502   \u2502   \u251c\u2500\u2500 start_cooking_command.py\n\u2502   \u2502   \u2514\u2500\u2500 complete_order_command.py\n\u2502   \u251c\u2500\u2500 queries/                 # CQRS Query handlers\n\u2502   \u2502   \u251c\u2500\u2500 get_order_by_id_query.py\n\u2502   \u2502   \u251c\u2500\u2500 get_orders_by_status_query.py\n\u2502   \u2502   \u2514\u2500\u2500 get_active_orders_query.py\n\u2502   \u2514\u2500\u2500 mapping/                 # AutoMapper profiles\n\u2502       \u2514\u2500\u2500 profile.py           # Entity-DTO mappings\n\u251c\u2500\u2500 domain/\n\u2502   \u251c\u2500\u2500 entities/                # Domain entities\n\u2502   \u2502   \u251c\u2500\u2500 pizza.py            # Pizza entity with pricing\n\u2502   \u2502   \u251c\u2500\u2500 order.py            # Order aggregate root\n\u2502   \u2502   \u251c\u2500\u2500 customer.py         # Customer entity\n\u2502   \u2502   \u251c\u2500\u2500 kitchen.py          # Kitchen entity\n\u2502   \u2502   \u2514\u2500\u2500 enums.py            # Domain enumerations\n\u2502   \u251c\u2500\u2500 events/                  # Domain events\n\u2502   \u2502   \u2514\u2500\u2500 order_events.py     # Order lifecycle events\n\u2502   \u2514\u2500\u2500 repositories/            # Repository interfaces\n\u2502       \u2514\u2500\u2500 __init__.py         # Repository abstractions\n\u251c\u2500\u2500 integration/\n\u2502   \u2514\u2500\u2500 repositories/           # Repository implementations\n\u2502       \u251c\u2500\u2500 file_order_repository.py    # File-based order storage\n\u2502       \u251c\u2500\u2500 file_pizza_repository.py    # File-based pizza storage\n\u2502       \u251c\u2500\u2500 file_customer_repository.py # File-based customer storage\n\u2502       \u2514\u2500\u2500 file_kitchen_repository.py  # File-based kitchen storage\n\u2514\u2500\u2500 tests/                      # Test suite\n    \u251c\u2500\u2500 test_api.py             # API integration tests\n    \u251c\u2500\u2500 test_integration.py     # Full integration tests\n    \u2514\u2500\u2500 test_data/              # Test data storage\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#step-1-domain-model","title":"\ud83c\udfd7\ufe0f Step 1: Domain Model","text":"<p>The domain entities demonstrate sophisticated business logic with real pricing calculations and type safety.</p> <p>domain/entities/pizza.py (lines 1-63)</p> samples/mario-pizzeria/domain/entities/pizza.py<pre><code>\"\"\"Pizza entity for Mario's Pizzeria domain\"\"\"\n\nfrom decimal import Decimal\nfrom typing import Optional\nfrom uuid import uuid4\n\nfrom api.dtos import PizzaDto\n\nfrom neuroglia.data.abstractions import Entity\nfrom neuroglia.mapping.mapper import map_from, map_to\n\nfrom .enums import PizzaSize\n\n\n@map_from(PizzaDto)\n@map_to(PizzaDto)\nclass Pizza(Entity[str]):\n    \"\"\"Pizza entity with pricing and toppings\"\"\"\n\n    def __init__(self, name: str, base_price: Decimal, size: PizzaSize, description: Optional[str] = None):\n        super().__init__()\n        self.id = str(uuid4())\n        self.name = name\n        self.base_price = base_price\n        self.size = size\n        self.description = description or \"\"\n        self.toppings: list[str] = []\n\n    @property\n    def size_multiplier(self) -&gt; Decimal:\n        \"\"\"Get price multiplier based on pizza size\"\"\"\n        multipliers = {\n            PizzaSize.SMALL: Decimal(\"1.0\"),\n            PizzaSize.MEDIUM: Decimal(\"1.3\"),\n            PizzaSize.LARGE: Decimal(\"1.6\"),\n        }\n        return multipliers[self.size]\n\n    @property\n    def topping_price(self) -&gt; Decimal:\n        \"\"\"Calculate total price for all toppings\"\"\"\n        return Decimal(str(len(self.toppings))) * Decimal(\"2.50\")\n\n    @property\n    def total_price(self) -&gt; Decimal:\n        \"\"\"Calculate total pizza price including size and toppings\"\"\"\n        base_with_size = self.base_price * self.size_multiplier\n        return base_with_size + self.topping_price\n\n    def add_topping(self, topping: str) -&gt; None:\n        \"\"\"Add a topping to the pizza\"\"\"\n        if topping not in self.toppings:\n            self.toppings.append(topping)\n\n    def remove_topping(self, topping: str) -&gt; None:\n        \"\"\"Remove a topping from the pizza\"\"\"\n        if topping in self.toppings:\n            self.toppings.remove(topping)\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#key-features","title":"Key Features","text":"<ul> <li>Size-based pricing: Small (1.0x), Medium (1.3x), Large (1.6x) multipliers</li> <li>Smart topping pricing: $2.50 per topping with proper decimal handling</li> <li>Auto-mapping decorators: Seamless conversion to/from DTOs</li> <li>Type safety: Enum-based size validation with PizzaSize enum</li> </ul> <p>domain/entities/order.py (lines 1-106)</p> samples/mario-pizzeria/domain/entities/order.py<pre><code>\"\"\"Order entity for Mario's Pizzeria domain\"\"\"\n\nfrom datetime import datetime, timezone\nfrom decimal import Decimal\nfrom typing import Optional\nfrom uuid import uuid4\n\nfrom api.dtos import OrderDto\n\nfrom neuroglia.data.abstractions import Entity\nfrom neuroglia.mapping.mapper import map_from, map_to\n\nfrom .enums import OrderStatus\nfrom .pizza import Pizza\n\n\n@map_from(OrderDto)\n@map_to(OrderDto)\nclass Order(Entity[str]):\n    \"\"\"Order entity with pizzas and status management\"\"\"\n\n    def __init__(self, customer_id: str, estimated_ready_time: Optional[datetime] = None):\n        super().__init__()\n        self.id = str(uuid4())\n        self.customer_id = customer_id\n        self.pizzas: list[Pizza] = []\n        self.status = OrderStatus.PENDING\n        self.order_time = datetime.now(timezone.utc)\n        self.confirmed_time: Optional[datetime] = None\n        self.cooking_started_time: Optional[datetime] = None\n        self.actual_ready_time: Optional[datetime] = None\n        self.estimated_ready_time = estimated_ready_time\n        self.notes: Optional[str] = None\n\n    @property\n    def total_amount(self) -&gt; Decimal:\n        \"\"\"Calculate total order amount\"\"\"\n        return sum((pizza.total_price for pizza in self.pizzas), Decimal(\"0.00\"))\n\n    @property\n    def pizza_count(self) -&gt; int:\n        \"\"\"Get total number of pizzas in the order\"\"\"\n        return len(self.pizzas)\n\n    def add_pizza(self, pizza: Pizza) -&gt; None:\n        \"\"\"Add a pizza to the order\"\"\"\n        if self.status != OrderStatus.PENDING:\n            raise ValueError(\"Cannot modify confirmed orders\")\n        self.pizzas.append(pizza)\n\n    def confirm_order(self) -&gt; None:\n        \"\"\"Confirm the order and set confirmed time\"\"\"\n        if self.status != OrderStatus.PENDING:\n            raise ValueError(\"Only pending orders can be confirmed\")\n\n        if not self.pizzas:\n            raise ValueError(\"Cannot confirm order without pizzas\")\n\n        self.status = OrderStatus.CONFIRMED\n        self.confirmed_time = datetime.now(timezone.utc)\n\n    def start_cooking(self) -&gt; None:\n        \"\"\"Start cooking the order\"\"\"\n        if self.status != OrderStatus.CONFIRMED:\n            raise ValueError(\"Only confirmed orders can start cooking\")\n\n        self.status = OrderStatus.COOKING\n        self.cooking_started_time = datetime.now(timezone.utc)\n\n    def mark_ready(self) -&gt; None:\n        \"\"\"Mark order as ready for pickup/delivery\"\"\"\n        if self.status != OrderStatus.COOKING:\n            raise ValueError(\"Only cooking orders can be marked ready\")\n\n        self.status = OrderStatus.READY\n        self.actual_ready_time = datetime.now(timezone.utc)\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#key-features_1","title":"Key Features","text":"<ul> <li>Status management: OrderStatus enum with PENDING \u2192 CONFIRMED \u2192 COOKING \u2192 READY workflow</li> <li>Time tracking: order_time, confirmed_time, cooking_started_time, actual_ready_time</li> <li>Business validation: Cannot modify confirmed orders, cannot confirm empty orders</li> <li>Auto-mapping decorators: Seamless conversion to/from DTOs</li> <li>Computed properties: Dynamic total_amount and pizza_count calculations</li> </ul> <p>OrderStatus Enum (enums.py):</p> samples/mario-pizzeria/domain/entities/enums.py<pre><code>class OrderStatus(Enum):\n    \"\"\"Order lifecycle statuses\"\"\"\n\n    PENDING = \"pending\"\n    CONFIRMED = \"confirmed\"\n    COOKING = \"cooking\"\n    READY = \"ready\"\n</code></pre> <p>Notice how the <code>Order</code> entity encapsulates the business logic around order management, including validation rules and state transitions.</p> <p>Domain Events (optional extension):</p> Domain Events Example<pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom neuroglia.data.abstractions import DomainEvent\n\n@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    \"\"\"Event raised when a new order is placed\"\"\"\n    order_id: str\n    customer_name: str\n    total_amount: Decimal\n    estimated_ready_time: datetime\n\n    def __post_init__(self):\n        super().__init__(self.order_id)\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#step-2-commands-and-queries","title":"\ud83c\udfaf Step 2: Commands and Queries","text":"<p>Neuroglia implements the CQRS (Command Query Responsibility Segregation) pattern, separating write operations (commands) from read operations (queries).</p>"},{"location":"guides/mario-pizzeria-tutorial/#commands-write-operations","title":"Commands (Write Operations)","text":"<p>place_order_command.py (lines 17-29)</p> samples/mario-pizzeria/application/commands/place_order_command.py<pre><code>@dataclass\n@map_from(CreateOrderDto)\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Command to place a new pizza order\"\"\"\n\n    customer_name: str\n    customer_phone: str\n    customer_address: Optional[str] = None\n    customer_email: Optional[str] = None\n    pizzas: list[CreatePizzaDto] = field(default_factory=list)\n    payment_method: str = \"cash\"\n    notes: Optional[str] = None\n</code></pre> <p>Command Handler Implementation (lines 31-95):</p> samples/mario-pizzeria/application/commands/place_order_command.py<pre><code>class PlaceOrderCommandHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    \"\"\"Handler for placing new pizza orders\"\"\"\n\n    def __init__(\n        self,\n        order_repository: IOrderRepository,\n        customer_repository: ICustomerRepository,\n        mapper: Mapper,\n    ):\n        self.order_repository = order_repository\n        self.customer_repository = customer_repository\n        self.mapper = mapper\n\n    async def handle_async(self, request: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        try:\n            # First create or get customer\n            customer = await self._create_or_get_customer(request)\n\n            # Create order with customer_id\n            order = Order(customer_id=customer.id)\n            if request.notes:\n                order.notes = request.notes\n\n            # Add pizzas to order with dynamic pricing\n            for pizza_item in request.pizzas:\n                size = PizzaSize(pizza_item.size.lower())\n\n                # Dynamic base pricing by pizza type\n                base_price = Decimal(\"12.99\")  # Default\n                if pizza_item.name.lower() == \"margherita\":\n                    base_price = Decimal(\"12.99\")\n                elif pizza_item.name.lower() == \"pepperoni\":\n                    base_price = Decimal(\"14.99\")\n                elif pizza_item.name.lower() == \"supreme\":\n                    base_price = Decimal(\"17.99\")\n\n                pizza = Pizza(name=pizza_item.name, base_price=base_price, size=size)\n\n                # Add toppings\n                for topping in pizza_item.toppings:\n                    pizza.add_topping(topping)\n\n                order.add_pizza(pizza)\n\n            # Validate and confirm order\n            if not order.pizzas:\n                return self.bad_request(\"Order must contain at least one pizza\")\n\n            order.confirm_order()  # Raises domain event\n            await self.order_repository.add_async(order)\n\n            return self.created(self._build_order_dto(order, customer))\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#queries-read-operations","title":"Queries (Read Operations)","text":"<p>get_order_by_id_query.py (lines 13-17)</p> samples/mario-pizzeria/application/queries/get_order_by_id_query.py<pre><code>@dataclass\nclass GetOrderByIdQuery(Query[OperationResult[OrderDto]]):\n    \"\"\"Query to get an order by ID\"\"\"\n\n    order_id: str\n</code></pre> <p>Query Handler Implementation (lines 20-63):</p> samples/mario-pizzeria/application/queries/get_order_by_id_query.py<pre><code>class GetOrderByIdQueryHandler(QueryHandler[GetOrderByIdQuery, OperationResult[OrderDto]]):\n    \"\"\"Handler for getting an order by ID\"\"\"\n\n    def __init__(\n        self,\n        order_repository: IOrderRepository,\n        customer_repository: ICustomerRepository,\n        mapper: Mapper,\n    ):\n        self.order_repository = order_repository\n        self.customer_repository = customer_repository\n        self.mapper = mapper\n\n    async def handle_async(self, request: GetOrderByIdQuery) -&gt; OperationResult[OrderDto]:\n        try:\n            order = await self.order_repository.get_async(request.order_id)\n            if not order:\n                return self.not_found(\"Order\", request.order_id)\n\n            # Get customer details\n            customer = await self.customer_repository.get_async(order.customer_id)\n\n            # Create OrderDto with customer information\n            order_dto = OrderDto(\n                id=order.id,\n                customer_name=customer.name if customer else \"Unknown\",\n                customer_phone=customer.phone if customer else \"Unknown\",\n                customer_address=customer.address if customer else \"Unknown\",\n                pizzas=[self.mapper.map(pizza, PizzaDto) for pizza in order.pizzas],\n                status=order.status.value,\n                order_time=order.order_time,\n                confirmed_time=order.confirmed_time,\n                cooking_started_time=order.cooking_started_time,\n                actual_ready_time=order.actual_ready_time,\n                estimated_ready_time=order.estimated_ready_time,\n                total_amount=order.total_amount,\n                notes=order.notes,\n            )\n\n            return self.ok(order_dto)\n        except Exception as e:\n            return self.internal_server_error(f\"Failed to get order: {str(e)}\")\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#key-cqrs-features","title":"Key CQRS Features","text":"<ul> <li>Command/Query Separation: Clear distinction between write (commands) and read (queries) operations</li> <li>Auto-mapping: @map_from decorators for seamless DTO conversion</li> <li>Repository Pattern: Abstracted data access through IOrderRepository and ICustomerRepository</li> <li>Business Logic: Domain validation and business rules in command handlers</li> <li>Error Handling: Comprehensive error handling with OperationResult pattern</li> </ul>"},{"location":"guides/mario-pizzeria-tutorial/#step-3-file-based-repository","title":"\ud83d\udcbe Step 3: File-Based Repository","text":"<p>file_order_repository.py (lines 1-37)</p> samples/mario-pizzeria/integration/repositories/file_order_repository.py<pre><code>\"\"\"File-based implementation of order repository using generic FileSystemRepository\"\"\"\n\nfrom datetime import datetime\n\nfrom domain.entities import Order, OrderStatus\nfrom domain.repositories import IOrderRepository\n\nfrom neuroglia.data.infrastructure.filesystem import FileSystemRepository\n\n\nclass FileOrderRepository(FileSystemRepository[Order, str], IOrderRepository):\n    \"\"\"File-based implementation of order repository using generic FileSystemRepository\"\"\"\n\n    def __init__(self, data_directory: str = \"data\"):\n        super().__init__(data_directory=data_directory, entity_type=Order, key_type=str)\n\n    async def get_by_customer_phone_async(self, phone: str) -&gt; list[Order]:\n        \"\"\"Get all orders for a customer by phone number\"\"\"\n        # Note: This would require a relationship lookup in a real implementation\n        # For now, we'll return empty list as Order entity doesn't directly store phone\n        return []\n\n    async def get_orders_by_status_async(self, status: OrderStatus) -&gt; list[Order]:\n        \"\"\"Get all orders with a specific status\"\"\"\n        all_orders = await self.get_all_async()\n        return [order for order in all_orders if order.status == status]\n\n    async def get_orders_by_date_range_async(self, start_date: datetime, end_date: datetime) -&gt; list[Order]:\n        \"\"\"Get orders within a date range\"\"\"\n        all_orders = await self.get_all_async()\n        return [order for order in all_orders if start_date &lt;= order.created_at &lt;= end_date]\n\n    async def get_active_orders_async(self) -&gt; list[Order]:\n        \"\"\"Get all active orders (not delivered or cancelled)\"\"\"\n        all_orders = await self.get_all_async()\n        active_statuses = {OrderStatus.CONFIRMED, OrderStatus.COOKING}\n        return [order for order in all_orders if order.status in active_statuses]\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#key-repository-features","title":"Key Repository Features","text":"<ul> <li>Generic Base Class: Inherits from <code>FileSystemRepository[Order, str]</code> for common CRUD operations</li> <li>Domain Interface: Implements <code>IOrderRepository</code> for business-specific methods</li> <li>Status Filtering: <code>get_orders_by_status_async()</code> for filtering by OrderStatus enum</li> <li>Date Range Queries: <code>get_orders_by_date_range_async()</code> for reporting functionality</li> <li>Business Logic: <code>get_active_orders_async()</code> returns orders in CONFIRMED or COOKING status</li> <li>JSON Persistence: Built-in serialization through FileSystemRepository base class</li> <li>Type Safety: Strongly typed with Order entity and string keys</li> </ul>"},{"location":"guides/mario-pizzeria-tutorial/#step-4-rest-api-controllers","title":"\ud83c\udf10 Step 4: REST API Controllers","text":"<p>orders_controller.py (lines 1-83)</p> samples/mario-pizzeria/api/controllers/orders_controller.py<pre><code>from typing import List, Optional\nfrom fastapi import HTTPException\n\nfrom neuroglia.mvc import ControllerBase\nfrom neuroglia.dependency_injection import ServiceProviderBase\nfrom neuroglia.mapping import Mapper\nfrom neuroglia.mediation import Mediator\nfrom classy_fastapi import get, post, put\n\nfrom api.dtos import (\n    OrderDto,\n    CreateOrderDto,\n    UpdateOrderStatusDto,\n)\nfrom application.commands import PlaceOrderCommand, StartCookingCommand, CompleteOrderCommand\nfrom application.queries import (\n    GetOrderByIdQuery,\n    GetOrdersByStatusQuery,\n    GetActiveOrdersQuery,\n)\n\n\nclass OrdersController(ControllerBase):\n    \"\"\"Mario's pizza order management endpoints\"\"\"\n\n    def __init__(self, service_provider: ServiceProviderBase, mapper: Mapper, mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n    @get(\"/{order_id}\", response_model=OrderDto, responses=ControllerBase.error_responses)\n    async def get_order(self, order_id: str):\n        \"\"\"Get order details by ID\"\"\"\n        query = GetOrderByIdQuery(order_id=order_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/\", response_model=List[OrderDto], responses=ControllerBase.error_responses)\n    async def get_orders(self, status: Optional[str] = None):\n        \"\"\"Get orders, optionally filtered by status\"\"\"\n        if status:\n            query = GetOrdersByStatusQuery(status=status)\n        else:\n            query = GetActiveOrdersQuery()\n\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @post(\"/\", response_model=OrderDto, status_code=201, responses=ControllerBase.error_responses)\n    async def place_order(self, request: CreateOrderDto):\n        \"\"\"Place a new pizza order\"\"\"\n        command = self.mapper.map(request, PlaceOrderCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @put(\"/{order_id}/cook\", response_model=OrderDto, responses=ControllerBase.error_responses)\n    async def start_cooking(self, order_id: str):\n        \"\"\"Start cooking an order\"\"\"\n        command = StartCookingCommand(order_id=order_id)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @put(\"/{order_id}/ready\", response_model=OrderDto, responses=ControllerBase.error_responses)\n    async def complete_order(self, order_id: str):\n        \"\"\"Mark order as ready for pickup/delivery\"\"\"\n        command = CompleteOrderCommand(order_id=order_id)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @put(\"/{order_id}/status\", response_model=OrderDto, responses=ControllerBase.error_responses)\n    async def update_order_status(self, order_id: str, request: UpdateOrderStatusDto):\n        \"\"\"Update order status (general endpoint)\"\"\"\n        # Route to appropriate command based on status\n        if request.status.lower() == \"cooking\":\n            command = StartCookingCommand(order_id=order_id)\n        elif request.status.lower() == \"ready\":\n            command = CompleteOrderCommand(order_id=order_id)\n        else:\n            raise HTTPException(\n                status_code=400, detail=f\"Unsupported status transition: {request.status}\"\n            )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#key-controller-features","title":"Key Controller Features","text":"<ul> <li>Full CRUD Operations: Complete order lifecycle management from creation to completion</li> <li>RESTful Design: Proper HTTP methods (GET, POST, PUT) and status codes (200, 201, 400, 404)</li> <li>Mediator Pattern: All business logic delegated to command/query handlers</li> <li>Type Safety: Strong typing with Pydantic models for requests and responses</li> <li>Error Handling: Consistent error responses using ControllerBase.error_responses</li> <li>Status Management: Multiple endpoints for different order status transitions</li> <li>Auto-mapping: Seamless DTO to command conversion using mapper.map()</li> <li>Clean Architecture: Controllers are thin orchestrators, business logic stays in handlers</li> </ul>"},{"location":"guides/mario-pizzeria-tutorial/#step-5-oauth-authentication","title":"\ud83d\udd10 Step 5: OAuth Authentication","text":"<p>src/infrastructure/auth.py</p> <pre><code>from typing import Optional\nfrom fastapi import HTTPException, Depends, status\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom neuroglia.core import OperationResult\n\n# Simple OAuth configuration\nOAUTH_SCOPES = {\n    \"orders:read\": \"Read order information\",\n    \"orders:write\": \"Create and modify orders\",\n    \"kitchen:manage\": \"Manage kitchen operations\",\n    \"admin\": \"Full administrative access\"\n}\n\n# Simple token validation (in production, use proper OAuth provider)\nVALID_TOKENS = {\n    \"customer_token\": {\"user\": \"customer\", \"scopes\": [\"orders:read\", \"orders:write\"]},\n    \"staff_token\": {\"user\": \"kitchen_staff\", \"scopes\": [\"orders:read\", \"kitchen:manage\"]},\n    \"admin_token\": {\"user\": \"admin\", \"scopes\": [\"admin\"]}\n}\n\nsecurity = HTTPBearer()\n\nasync def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)) -&gt; dict:\n    \"\"\"Validate token and return user info\"\"\"\n    token = credentials.credentials\n\n    if token not in VALID_TOKENS:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid authentication token\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n    return VALID_TOKENS[token]\n\ndef require_scope(required_scope: str):\n    \"\"\"Decorator to require specific OAuth scope\"\"\"\n    def check_scope(current_user: dict = Depends(get_current_user)):\n        user_scopes = current_user.get(\"scopes\", [])\n        if required_scope not in user_scopes and \"admin\" not in user_scopes:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=f\"Insufficient permissions. Required scope: {required_scope}\"\n            )\n        return current_user\n    return check_scope\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#step-6-simple-web-ui","title":"\ud83c\udfa8 Step 6: Simple Web UI","text":"<p>src/web/static/index.html</p> <pre><code>&lt;!doctype html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;Mario's Pizzeria&lt;/title&gt;\n    &lt;style&gt;\n      body {\n        font-family: Arial, sans-serif;\n        max-width: 800px;\n        margin: 0 auto;\n        padding: 20px;\n      }\n      .pizza-card {\n        border: 1px solid #ddd;\n        border-radius: 8px;\n        padding: 15px;\n        margin: 10px 0;\n      }\n      .order-form {\n        background: #f5f5f5;\n        padding: 20px;\n        border-radius: 8px;\n        margin: 20px 0;\n      }\n      button {\n        background: #e74c3c;\n        color: white;\n        border: none;\n        padding: 10px 20px;\n        border-radius: 4px;\n        cursor: pointer;\n      }\n      button:hover {\n        background: #c0392b;\n      }\n      input,\n      select {\n        padding: 8px;\n        margin: 5px;\n        border: 1px solid #ddd;\n        border-radius: 4px;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;\ud83c\udf55 Welcome to Mario's Pizzeria&lt;/h1&gt;\n\n    &lt;div id=\"menu-section\"&gt;\n      &lt;h2&gt;Our Menu&lt;/h2&gt;\n      &lt;div id=\"menu-items\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;div class=\"order-form\"&gt;\n      &lt;h2&gt;Place Your Order&lt;/h2&gt;\n      &lt;form id=\"order-form\"&gt;\n        &lt;div&gt;\n          &lt;input type=\"text\" id=\"customer-name\" placeholder=\"Your Name\" required /&gt;\n          &lt;input type=\"tel\" id=\"customer-phone\" placeholder=\"Phone Number\" required /&gt;\n        &lt;/div&gt;\n        &lt;div id=\"pizza-selection\"&gt;&lt;/div&gt;\n        &lt;button type=\"submit\"&gt;Place Order&lt;/button&gt;\n      &lt;/form&gt;\n    &lt;/div&gt;\n\n    &lt;div id=\"order-status\" style=\"display: none;\"&gt;\n      &lt;h2&gt;Order Status&lt;/h2&gt;\n      &lt;div id=\"status-details\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n      // Load menu on page load\n      document.addEventListener(\"DOMContentLoaded\", loadMenu);\n\n      async function loadMenu() {\n        try {\n          const response = await fetch(\"/api/menu\");\n          const menu = await response.json();\n          displayMenu(menu);\n        } catch (error) {\n          console.error(\"Failed to load menu:\", error);\n        }\n      }\n\n      function displayMenu(menu) {\n        const menuContainer = document.getElementById(\"menu-items\");\n        menuContainer.innerHTML = menu\n          .map(\n            pizza =&gt; `\n                &lt;div class=\"pizza-card\"&gt;\n                    &lt;h3&gt;${pizza.name}&lt;/h3&gt;\n                    &lt;p&gt;Base Price: $${pizza.base_price}&lt;/p&gt;\n                    &lt;p&gt;Prep Time: ${pizza.preparation_time_minutes} minutes&lt;/p&gt;\n                    &lt;button onclick=\"addToOrder('${pizza.id}', '${pizza.name}')\"&gt;Add to Order&lt;/button&gt;\n                &lt;/div&gt;\n            `\n          )\n          .join(\"\");\n      }\n\n      function addToOrder(pizzaId, pizzaName) {\n        const selection = document.getElementById(\"pizza-selection\");\n        selection.innerHTML += `\n                &lt;div class=\"pizza-selection\"&gt;\n                    &lt;span&gt;${pizzaName}&lt;/span&gt;\n                    &lt;select name=\"size\"&gt;\n                        &lt;option value=\"small\"&gt;Small&lt;/option&gt;\n                        &lt;option value=\"medium\"&gt;Medium&lt;/option&gt;\n                        &lt;option value=\"large\"&gt;Large&lt;/option&gt;\n                    &lt;/select&gt;\n                    &lt;select name=\"toppings\" multiple&gt;\n                        &lt;option value=\"pepperoni\"&gt;Pepperoni&lt;/option&gt;\n                        &lt;option value=\"mushrooms\"&gt;Mushrooms&lt;/option&gt;\n                        &lt;option value=\"bell_peppers\"&gt;Bell Peppers&lt;/option&gt;\n                    &lt;/select&gt;\n                    &lt;input type=\"hidden\" name=\"pizza_id\" value=\"${pizzaId}\"&gt;\n                &lt;/div&gt;\n            `;\n      }\n\n      document.getElementById(\"order-form\").addEventListener(\"submit\", async e =&gt; {\n        e.preventDefault();\n\n        const formData = new FormData(e.target);\n        const order = {\n          customer_name: formData.get(\"customer-name\"),\n          customer_phone: formData.get(\"customer-phone\"),\n          pizza_items: Array.from(document.querySelectorAll(\".pizza-selection\")).map(item =&gt; ({\n            pizza_id: item.querySelector('[name=\"pizza_id\"]').value,\n            size: item.querySelector('[name=\"size\"]').value,\n            toppings: Array.from(item.querySelectorAll('[name=\"toppings\"] option:checked')).map(opt =&gt; opt.value),\n          })),\n        };\n\n        try {\n          const response = await fetch(\"/api/orders\", {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(order),\n          });\n\n          const result = await response.json();\n          showOrderStatus(result);\n        } catch (error) {\n          alert(\"Failed to place order: \" + error.message);\n        }\n      });\n\n      function showOrderStatus(order) {\n        document.getElementById(\"order-status\").style.display = \"block\";\n        document.getElementById(\"status-details\").innerHTML = `\n                &lt;p&gt;&lt;strong&gt;Order ID:&lt;/strong&gt; ${order.order_id}&lt;/p&gt;\n                &lt;p&gt;&lt;strong&gt;Total:&lt;/strong&gt; $${order.total_amount}&lt;/p&gt;\n                &lt;p&gt;&lt;strong&gt;Estimated Ready Time:&lt;/strong&gt; ${new Date(\n                  order.estimated_ready_time\n                ).toLocaleTimeString()}&lt;/p&gt;\n            `;\n      }\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#step-7-application-setup","title":"\ud83d\ude80 Step 7: Application Setup","text":"<p>The main application file demonstrates sophisticated multi-app architecture with dependency injection configuration.</p> <p>main.py (lines 1-226)</p> samples/mario-pizzeria/main.py<pre><code>#!/usr/bin/env python3\n\"\"\"\nMario's Pizzeria - Main Application Entry Point\n\nThis is the complete sample application demonstrating all major Neuroglia framework features.\n\"\"\"\n\nimport logging\nimport sys\nfrom pathlib import Path\nfrom typing import Optional\n\n# Set up debug logging early\nlogging.basicConfig(level=logging.DEBUG)\n\n# Add the project root to Python path so we can import neuroglia\nproject_root = Path(__file__).parent.parent.parent.parent\nsys.path.insert(0, str(project_root / \"src\"))\n\n# Domain repository interfaces\nfrom domain.repositories import (\n    ICustomerRepository,\n    IKitchenRepository,\n    IOrderRepository,\n    IPizzaRepository,\n)\nfrom integration.repositories import (\n    FileCustomerRepository,\n    FileKitchenRepository,\n    FileOrderRepository,\n    FilePizzaRepository,\n)\n\n# Framework imports (must be after path manipulation)\nfrom neuroglia.hosting.enhanced_web_application_builder import (\n    EnhancedWebApplicationBuilder,\n)\nfrom neuroglia.mapping import Mapper\nfrom neuroglia.mediation import Mediator\n\n\ndef create_pizzeria_app(data_dir: Optional[str] = None, port: int = 8000):\n    \"\"\"\n    Create Mario's Pizzeria application with multi-app architecture.\n\n    Creates separate apps for:\n    - API backend (/api prefix)\n    - Future UI frontend (/ prefix)\n    \"\"\"\n    # Determine data directory\n    data_dir_path = Path(data_dir) if data_dir else Path(__file__).parent / \"data\"\n    data_dir_path.mkdir(exist_ok=True)\n\n    print(f\"\ud83d\udcbe Data stored in: {data_dir_path}\")\n\n    # Create enhanced web application builder\n    builder = EnhancedWebApplicationBuilder()\n\n    # Register repositories with file-based implementations\n    builder.services.add_singleton(\n        IPizzaRepository,\n        implementation_factory=lambda _: FilePizzaRepository(str(data_dir_path / \"menu\")),\n    )\n    builder.services.add_singleton(\n        ICustomerRepository,\n        implementation_factory=lambda _: FileCustomerRepository(str(data_dir_path / \"customers\")),\n    )\n    builder.services.add_singleton(\n        IOrderRepository,\n        implementation_factory=lambda _: FileOrderRepository(str(data_dir_path / \"orders\")),\n    )\n    builder.services.add_singleton(\n        IKitchenRepository,\n        implementation_factory=lambda _: FileKitchenRepository(str(data_dir_path / \"kitchen\")),\n    )\n\n    # Configure mediator with auto-discovery from command and query modules\n    Mediator.configure(builder, [\"application.commands\", \"application.queries\"])\n\n    # Configure auto-mapper with custom profile\n    Mapper.configure(builder, [\"application.mapping\", \"api.dtos\", \"domain.entities\"])\n\n    # Configure JSON serialization with type discovery\n    from neuroglia.serialization.json import JsonSerializer\n\n    # Configure JsonSerializer with domain modules for enum discovery\n    JsonSerializer.configure(\n        builder,\n        type_modules=[\n            \"domain.entities.enums\",  # Mario Pizzeria enum types\n            \"domain.entities\",  # Also scan entities module for embedded enums\n        ],\n    )\n\n    # Build the service provider (not the full app yet)\n    service_provider = builder.services.build()\n\n    # Create the main FastAPI app directly\n    from fastapi import FastAPI\n\n    app = FastAPI(\n        title=\"Mario's Pizzeria\",\n        description=\"Complete pizza ordering and management system\",\n        version=\"1.0.0\",\n        debug=True,\n    )\n\n    # Make DI services available to the app\n    app.state.services = service_provider\n\n    # Create separate API app for backend REST API\n    api_app = FastAPI(\n        title=\"Mario's Pizzeria API\",\n        description=\"Pizza ordering and management API\",\n        version=\"1.0.0\",\n        docs_url=\"/docs\",\n        debug=True,\n    )\n\n    # IMPORTANT: Make services available to API app as well\n    api_app.state.services = service_provider\n\n    # Register API controllers to the API app\n    builder.add_controllers([\"api.controllers\"], app=api_app)\n\n    # Add exception handling to API app\n    builder.add_exception_handling(api_app)\n\n    # Mount the apps\n    app.mount(\"/api\", api_app, name=\"api\")\n    app.mount(\"/ui\", ui_app, name=\"ui\")\n\n    return app\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#key-implementation-features","title":"Key Implementation Features","text":"<p>Multi-App Architecture (lines 102-125)</p> <p>The application uses a sophisticated multi-app setup:</p> <ul> <li>Main App: Root FastAPI application with welcome endpoint</li> <li>API App: Dedicated backend API mounted at <code>/api</code> with Swagger documentation</li> <li>UI App: Future frontend application mounted at <code>/ui</code></li> </ul> <p>Repository Registration Pattern (lines 64-82)</p> <p>Uses interface-based dependency injection with file-based implementations:</p> Repository Registration Pattern<pre><code>builder.services.add_singleton(\n    IPizzaRepository,\n    implementation_factory=lambda _: FilePizzaRepository(str(data_dir_path / \"menu\")),\n)\n</code></pre> <p>Auto-Discovery Configuration (lines 84-98)</p> <p>Framework components use module scanning for automatic registration:</p> Auto-Discovery Setup<pre><code># Configure mediator with auto-discovery from command and query modules\nMediator.configure(builder, [\"application.commands\", \"application.queries\"])\n\n# Configure auto-mapper with custom profile\nMapper.configure(builder, [\"application.mapping\", \"api.dtos\", \"domain.entities\"])\n\n# Configure JsonSerializer with domain modules for enum discovery\nJsonSerializer.configure(\n    builder,\n    type_modules=[\n        \"domain.entities.enums\",  # Mario Pizzeria enum types\n        \"domain.entities\",  # Also scan entities module for embedded enums\n    ],\n)\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#running-the-application","title":"\ud83c\udfaf Running the Application","text":"<p>The main entry point provides comprehensive application bootstrapping and startup logic:</p> <p>Application Startup (lines 198-226)</p> Application Entry Point<pre><code>def main():\n    \"\"\"Main entry point when running as a script\"\"\"\n    import uvicorn\n\n    # Parse command line arguments\n    port = 8000\n    host = \"127.0.0.1\"\n    data_dir = None\n\n    if len(sys.argv) &gt; 1:\n        for i, arg in enumerate(sys.argv[1:], 1):\n            if arg == \"--port\" and i + 1 &lt; len(sys.argv):\n                port = int(sys.argv[i + 1])\n            elif arg == \"--host\" and i + 1 &lt; len(sys.argv):\n                host = sys.argv[i + 1]\n            elif arg == \"--data-dir\" and i + 1 &lt; len(sys.argv):\n                data_dir = sys.argv[i + 1]\n\n    # Create the application\n    app = create_pizzeria_app(data_dir=data_dir, port=port)\n\n    print(f\"\ud83c\udf55 Starting Mario's Pizzeria on http://{host}:{port}\")\n    print(f\"\ud83d\udcd6 API Documentation available at http://{host}:{port}/api/docs\")\n    print(f\"\ud83c\udf10 UI will be available at http://{host}:{port}/ui (coming soon)\")\n\n    # Run the server\n    uvicorn.run(app, host=host, port=port)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#youre-done","title":"\ud83c\udf89 You're Done","text":"<p>Run your pizzeria:</p> <pre><code>cd samples/mario-pizzeria\npython main.py\n</code></pre> <p>Visit your application:</p> <ul> <li>Web UI: http://localhost:8000</li> <li>API Documentation: http://localhost:8000/docs</li> <li>API Endpoints: http://localhost:8000/api</li> </ul>"},{"location":"guides/mario-pizzeria-tutorial/#what-youve-built","title":"\ud83d\udd0d What You've Built","text":"<ul> <li>\u2705 Complete Web Application with UI and API</li> <li>\u2705 Clean Architecture with domain, application, and infrastructure layers</li> <li>\u2705 CQRS Pattern with commands and queries</li> <li>\u2705 Event-Driven Design with domain events</li> <li>\u2705 File-Based Persistence using the repository pattern</li> <li>\u2705 OAuth Authentication for secure endpoints</li> <li>\u2705 Enhanced Web Application Builder with multi-app support</li> <li>\u2705 Automatic API Documentation with Swagger UI</li> </ul>"},{"location":"guides/mario-pizzeria-tutorial/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<p>Now that you've built a complete application, explore advanced Neuroglia features:</p>"},{"location":"guides/mario-pizzeria-tutorial/#architecture-deep-dives","title":"\ud83c\udfdb\ufe0f Architecture Deep Dives","text":"<ul> <li>Clean architecture principles and layer separation</li> <li>CQRS &amp; Mediation - Advanced command/query patterns and pipeline behaviors</li> <li>Dependency Injection - Advanced DI patterns and service lifetimes</li> </ul>"},{"location":"guides/mario-pizzeria-tutorial/#advanced-features","title":"\ud83d\ude80 Advanced Features","text":"<ul> <li>Event Sourcing - Complete event-driven architecture with event stores</li> <li>Data Access - MongoDB and other persistence options beyond file storage</li> <li>MVC Controllers - Advanced controller patterns and API design</li> </ul>"},{"location":"guides/mario-pizzeria-tutorial/#sample-applications","title":"\ud83d\udccb Sample Applications","text":"<ul> <li>OpenBank Sample - Banking domain with event sourcing</li> <li>API Gateway Sample - Microservice gateway patterns</li> <li>Desktop Controller Sample - Background services and system integration</li> </ul>"},{"location":"guides/mario-pizzeria-tutorial/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\u26a1 3-Minute Bootstrap - Quick hello world setup</li> <li>\ud83d\udee0\ufe0f Local Development Setup - Complete development environment</li> <li>\ud83c\udfaf Getting Started Overview - Choose your learning path</li> </ul> <p>\ud83c\udf89 Congratulations!</p> <p>You've built a complete, production-ready application using Neuroglia! All other documentation examples use this same pizzeria domain for consistency - you'll feel right at home exploring advanced features.</p>"},{"location":"guides/opentelemetry-integration/","title":"\ud83d\udd2d OpenTelemetry Integration Guide","text":""},{"location":"guides/opentelemetry-integration/#overview","title":"\ud83d\udccb Overview","text":"<p>This guide covers the comprehensive OpenTelemetry (OTEL) integration for the Neuroglia framework and Mario's Pizzeria application, providing full observability through distributed tracing, metrics, and structured logging.</p>"},{"location":"guides/opentelemetry-integration/#observability-pillars","title":"\ud83c\udfaf Observability Pillars","text":""},{"location":"guides/opentelemetry-integration/#1-distributed-tracing","title":"1. Distributed Tracing \ud83d\udd0d","text":"<ul> <li>Purpose: Track requests across services and layers</li> <li>Backend: Tempo (Grafana's distributed tracing system)</li> <li>Benefits: Understand request flow, identify bottlenecks, debug distributed systems</li> </ul>"},{"location":"guides/opentelemetry-integration/#2-metrics","title":"2. Metrics \ud83d\udcca","text":"<ul> <li>Purpose: Quantitative measurements of application performance</li> <li>Backend: Prometheus (time-series database)</li> <li>Benefits: Monitor performance trends, set alerts, capacity planning</li> </ul>"},{"location":"guides/opentelemetry-integration/#3-logging","title":"3. Logging \ud83d\udcdd","text":"<ul> <li>Purpose: Structured event records with trace correlation</li> <li>Backend: Loki (Grafana's log aggregation system)</li> <li>Benefits: Debug issues, audit trails, correlated with traces</li> </ul>"},{"location":"guides/opentelemetry-integration/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Mario Pizzeria App                        \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502  OpenTelemetry SDK (Python)                          \u2502  \u2502\n\u2502  \u2502  - TracerProvider (traces)                           \u2502  \u2502\n\u2502  \u2502  - MeterProvider (metrics)                           \u2502  \u2502\n\u2502  \u2502  - LoggerProvider (logs)                             \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                   \u2502 OTLP/gRPC (4317) or HTTP (4318)        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n                    \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            OpenTelemetry Collector (All-in-One)              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502  Receivers:  OTLP (gRPC 4317, HTTP 4318)             \u2502  \u2502\n\u2502  \u2502  Processors: Batch, Memory Limiter, Resource         \u2502  \u2502\n\u2502  \u2502  Exporters:  Tempo, Prometheus, Loki, Console        \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502             \u2502             \u2502\n          \u25bc             \u25bc             \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  Tempo  \u2502   \u2502Prometheus\u2502  \u2502   Loki   \u2502\n    \u2502 (Traces)\u2502   \u2502(Metrics) \u2502  \u2502  (Logs)  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n         \u2502              \u2502             \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502\n                        \u25bc\n                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                 \u2502   Grafana   \u2502\n                 \u2502 (Dashboard) \u2502\n                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"guides/opentelemetry-integration/#components","title":"\ud83d\udce6 Components","text":""},{"location":"guides/opentelemetry-integration/#opentelemetry-collector-all-in-one","title":"OpenTelemetry Collector (All-in-One)","text":"<ul> <li>Image: <code>otel/opentelemetry-collector-contrib:latest</code></li> <li>Purpose: Central hub for receiving, processing, and exporting telemetry</li> <li>Ports:</li> <li><code>4317</code>: OTLP gRPC receiver</li> <li><code>4318</code>: OTLP HTTP receiver</li> <li><code>8888</code>: Prometheus metrics about the collector itself</li> <li><code>13133</code>: Health check endpoint</li> </ul>"},{"location":"guides/opentelemetry-integration/#grafana-tempo","title":"Grafana Tempo","text":"<ul> <li>Image: <code>grafana/tempo:latest</code></li> <li>Purpose: Distributed tracing backend</li> <li>Ports: <code>3200</code> (HTTP API), <code>9095</code> (gRPC), <code>4317</code> (OTLP gRPC)</li> <li>Storage: Local filesystem (configurable to S3, GCS, etc.)</li> </ul>"},{"location":"guides/opentelemetry-integration/#prometheus","title":"Prometheus","text":"<ul> <li>Image: <code>prom/prometheus:latest</code></li> <li>Purpose: Metrics storage and querying</li> <li>Ports: <code>9090</code> (Web UI and API)</li> <li>Scrape Interval: 15s</li> </ul>"},{"location":"guides/opentelemetry-integration/#grafana-loki","title":"Grafana Loki","text":"<ul> <li>Image: <code>grafana/loki:latest</code></li> <li>Purpose: Log aggregation and querying</li> <li>Ports: <code>3100</code> (HTTP API)</li> <li>Storage: Local filesystem</li> </ul>"},{"location":"guides/opentelemetry-integration/#grafana","title":"Grafana","text":"<ul> <li>Image: <code>grafana/grafana:latest</code></li> <li>Purpose: Unified dashboard for traces, metrics, and logs</li> <li>Ports: <code>3001</code> (Web UI)</li> <li>Default Credentials: admin/admin (change on first login)</li> </ul>"},{"location":"guides/opentelemetry-integration/#implementation-components","title":"\ud83d\udd27 Implementation Components","text":""},{"location":"guides/opentelemetry-integration/#1-framework-module-neurogliaobservability","title":"1. Framework Module: <code>neuroglia.observability</code>","text":"<p>Purpose: Provide reusable OpenTelemetry integration for all Neuroglia applications</p> <p>Key Features:</p> <ul> <li>Automatic instrumentation setup (FastAPI, HTTPX, logging)</li> <li>TracerProvider and MeterProvider initialization</li> <li>Context propagation configuration</li> <li>Resource detection (service name, version, host)</li> <li>Configurable exporters (OTLP, Console, Jaeger compatibility)</li> </ul> <p>Public API:</p> <pre><code>from neuroglia.observability import (\n    configure_opentelemetry,\n    get_tracer,\n    get_meter,\n    trace_async,  # Decorator for automatic tracing\n    record_metric,\n)\n\n# Initialize OTEL (call once at startup)\nconfigure_opentelemetry(\n    service_name=\"mario-pizzeria\",\n    service_version=\"1.0.0\",\n    otlp_endpoint=\"http://otel-collector:4317\",\n    enable_console_export=False,\n)\n\n# Get tracer for manual instrumentation\ntracer = get_tracer(__name__)\n\n# Automatic tracing decorator\n@trace_async()\nasync def process_order(order_id: str):\n    # Automatically creates a span\n    pass\n</code></pre>"},{"location":"guides/opentelemetry-integration/#2-tracing-middleware","title":"2. Tracing Middleware","text":"<p>Layers Instrumented:</p> <ul> <li>\u2705 HTTP Requests (automatic via FastAPI instrumentation)</li> <li>\u2705 Commands (CQRSTracingMiddleware)</li> <li>\u2705 Queries (CQRSTracingMiddleware)</li> <li>\u2705 Event Handlers (EventHandlerTracingMiddleware)</li> <li>\u2705 Repository Operations (RepositoryTracingMixin)</li> <li>\u2705 External HTTP Calls (automatic via HTTPX instrumentation)</li> </ul> <p>Span Attributes:</p> <ul> <li><code>command.type</code>: Command class name</li> <li><code>query.type</code>: Query class name</li> <li><code>event.type</code>: Event class name</li> <li><code>aggregate.id</code>: Aggregate identifier</li> <li><code>repository.operation</code>: get/save/update/delete</li> <li><code>http.method</code>, <code>http.url</code>, <code>http.status_code</code></li> </ul>"},{"location":"guides/opentelemetry-integration/#3-metrics-collection","title":"3. Metrics Collection","text":"<p>Business Metrics:</p> <ul> <li><code>mario.orders.created</code> (counter): Total orders placed</li> <li><code>mario.orders.completed</code> (counter): Total orders delivered</li> <li><code>mario.orders.cancelled</code> (counter): Total cancelled orders</li> <li><code>mario.pizzas.ordered</code> (counter): Total pizzas ordered</li> <li><code>mario.orders.value</code> (histogram): Order value distribution</li> </ul> <p>Technical Metrics:</p> <ul> <li><code>neuroglia.command.duration</code> (histogram): Command execution time</li> <li><code>neuroglia.query.duration</code> (histogram): Query execution time</li> <li><code>neuroglia.event.processing.duration</code> (histogram): Event handler time</li> <li><code>neuroglia.repository.operation.duration</code> (histogram): Repository operation time</li> <li><code>neuroglia.http.request.duration</code> (histogram): HTTP request duration</li> </ul> <p>Labels/Attributes:</p> <ul> <li><code>service.name</code>: \"mario-pizzeria\"</li> <li><code>command.type</code>: Command class name</li> <li><code>query.type</code>: Query class name</li> <li><code>event.type</code>: Event class name</li> <li><code>repository.type</code>: Repository class name</li> <li><code>status</code>: \"success\" | \"error\"</li> </ul>"},{"location":"guides/opentelemetry-integration/#4-structured-logging","title":"4. Structured Logging","text":"<p>Features:</p> <ul> <li>JSON structured logs with trace context</li> <li>Automatic trace_id and span_id injection</li> <li>Log level filtering</li> <li>OTLP log export to Loki via collector</li> </ul> <p>Log Format:</p> <pre><code>{\n  \"timestamp\": \"2025-10-24T10:15:30.123Z\",\n  \"level\": \"INFO\",\n  \"message\": \"Order placed successfully\",\n  \"service.name\": \"mario-pizzeria\",\n  \"trace_id\": \"4bf92f3577b34da6a3ce929d0e0e4736\",\n  \"span_id\": \"00f067aa0ba902b7\",\n  \"order_id\": \"61a61887-4200-4d0c-85d3-45c2cdd9cc08\",\n  \"customer_id\": \"cust_123\",\n  \"total_amount\": 25.5\n}\n</code></pre>"},{"location":"guides/opentelemetry-integration/#fastapi-multi-application-instrumentation","title":"\u2699\ufe0f FastAPI Multi-Application Instrumentation","text":""},{"location":"guides/opentelemetry-integration/#critical-configuration-for-multi-app-architectures","title":"\ud83d\udea8 Critical Configuration for Multi-App Architectures","text":"<p>When building applications with multiple mounted FastAPI apps (main app + sub-apps), proper OpenTelemetry instrumentation configuration is crucial to avoid duplicate metrics warnings and ensure complete observability coverage.</p>"},{"location":"guides/opentelemetry-integration/#the-problem-duplicate-instrumentation","title":"The Problem: Duplicate Instrumentation","text":"<p>\u274c WRONG - Causes duplicate metric warnings:</p> <pre><code># This creates duplicate HTTP metrics instruments\nfrom neuroglia.observability import instrument_fastapi_app\n\n# Main application\napp = FastAPI(title=\"Mario's Pizzeria\")\n\n# Sub-applications\napi_app = FastAPI(title=\"API\")\nui_app = FastAPI(title=\"UI\")\n\n# \u274c DON'T DO THIS - Causes warnings\ninstrument_fastapi_app(app, \"main-app\")\ninstrument_fastapi_app(api_app, \"api-app\")    # \u26a0\ufe0f Duplicate metrics\ninstrument_fastapi_app(ui_app, \"ui-app\")      # \u26a0\ufe0f Duplicate metrics\n\n# Mount sub-apps\napp.mount(\"/api\", api_app)\napp.mount(\"/\", ui_app)\n</code></pre> <p>Error Messages You'll See:</p> <pre><code>WARNING  An instrument with name http.server.duration, type Histogram...\nhas been created already.\nWARNING  An instrument with name http.server.request.size, type Histogram...\nhas been created already.\n</code></pre>"},{"location":"guides/opentelemetry-integration/#correct-single-main-app-instrumentation","title":"\u2705 CORRECT - Single Main App Instrumentation","text":"<p>The solution: Only instrument the main app that contains mounted sub-apps</p> <pre><code>from neuroglia.observability import configure_opentelemetry, instrument_fastapi_app\n\n# 1. Initialize OpenTelemetry first (once per application)\nconfigure_opentelemetry(\n    service_name=\"mario-pizzeria\",\n    service_version=\"1.0.0\",\n    otlp_endpoint=\"http://otel-collector:4317\"\n)\n\n# 2. Create applications\napp = FastAPI(title=\"Mario's Pizzeria\")\napi_app = FastAPI(title=\"API\")\nui_app = FastAPI(title=\"UI\")\n\n# 3. Define endpoints BEFORE mounting (important for health checks)\n@app.get(\"/health\")\nasync def health_check():\n    return {\"status\": \"healthy\"}\n\n# 4. Mount sub-applications\napp.mount(\"/api\", api_app, name=\"api\")\napp.mount(\"/\", ui_app, name=\"ui\")\n\n# 5. \u2705 ONLY instrument the main app\ninstrument_fastapi_app(app, \"mario-pizzeria-main\")\n</code></pre>"},{"location":"guides/opentelemetry-integration/#complete-coverage-verification","title":"\ud83d\udcca Complete Coverage Verification","text":"<p>This single instrumentation captures ALL endpoints across all mounted applications:</p> <p>Example Tracked Endpoints:</p> <pre><code># All these endpoints are automatically instrumented:\n\u2705 /health                (main app)\n\u2705 /                      (UI sub-app root)\n\u2705 /menu                  (UI sub-app)\n\u2705 /orders                (UI sub-app)\n\u2705 /api/menu/             (API sub-app)\n\u2705 /api/orders/           (API sub-app)\n\u2705 /api/kitchen/status    (API sub-app)\n\u2705 /api/docs              (API sub-app)\n\u2705 /api/metrics           (API sub-app)\n</code></pre> <p>HTTP Status Codes Tracked:</p> <pre><code>\u2705 200 OK                (successful requests)\n\u2705 307 Temporary Redirect (FastAPI automatic redirects)\n\u2705 404 Not Found          (missing endpoints)\n\u2705 401 Unauthorized       (auth failures)\n\u2705 500 Internal Error     (application errors)\n</code></pre>"},{"location":"guides/opentelemetry-integration/#how-it-works","title":"\ud83d\udd0d How It Works","text":"<ol> <li>Request Flow: All HTTP requests reach the main app first</li> <li>Middleware Order: OpenTelemetry middleware intercepts requests before routing</li> <li>Sub-App Processing: Requests are then routed to appropriate mounted sub-apps</li> <li>Metric Collection: Single point of HTTP metric collection with complete coverage</li> </ol> <pre><code>HTTP Request \u2192 Main App (instrumented) \u2192 Mounted Sub-App \u2192 Response\n                  \u2191\n            Metrics captured here\n</code></pre>"},{"location":"guides/opentelemetry-integration/#best-practices","title":"\ud83c\udfaf Best Practices","text":"<ol> <li>Single Instrumentation Point: Only instrument the main FastAPI app</li> <li>Timing Matters: Mount sub-apps before instrumenting the main app</li> <li>Health Endpoints: Define main app endpoints before mounting to avoid 404s</li> <li>Service Naming: Use descriptive names for the instrumented app</li> <li>Verification: Check <code>/metrics</code> endpoint to confirm all routes are tracked</li> </ol>"},{"location":"guides/opentelemetry-integration/#common-pitfalls","title":"\ud83d\udea8 Common Pitfalls","text":"<ol> <li>Instrumenting Sub-Apps: Never instrument mounted sub-applications directly</li> <li>Order of Operations: Don't instrument before mounting sub-apps</li> <li>Missing Routes: Define health/metrics endpoints on main app, not sub-apps</li> <li>Duplicate Names: Use unique service names for different instrumentation calls</li> </ol>"},{"location":"guides/opentelemetry-integration/#metrics-verification","title":"\ud83d\udcc8 Metrics Verification","text":"<p>Verify your instrumentation is working correctly:</p> <pre><code># Check all tracked endpoints\ncurl -s \"http://localhost:8080/api/metrics\" | \\\n  grep 'http_target=' | \\\n  sed 's/.*http_target=\"\\([^\"]*\\)\".*/\\1/' | \\\n  sort | uniq\n\n# Expected output:\n# /\n# /api/menu/\n# /api/orders/\n# /health\n# /api/metrics\n</code></pre>"},{"location":"guides/opentelemetry-integration/#integration-checklist","title":"\ud83d\udccb Integration Checklist","text":"<ul> <li>[ ] \u2705 Initialize OpenTelemetry once at startup</li> <li>[ ] \u2705 Create all FastAPI apps (main + sub-apps)</li> <li>[ ] \u2705 Define main app endpoints (health, metrics)</li> <li>[ ] \u2705 Mount all sub-applications to main app</li> <li>[ ] \u2705 Instrument ONLY the main app</li> <li>[ ] \u2705 Verify no duplicate metric warnings in logs</li> <li>[ ] \u2705 Confirm all endpoints appear in metrics</li> <li>[ ] \u2705 Test trace propagation across all routes</li> </ul> <p>This configuration ensures complete observability coverage without duplicate instrumentation warnings, providing clean metrics collection across your entire multi-application architecture.</p>"},{"location":"guides/opentelemetry-integration/#key-benefits","title":"\ud83d\ude80 Key Benefits","text":""},{"location":"guides/opentelemetry-integration/#for-development","title":"For Development","text":"<ol> <li>Debug Distributed Systems: See exact request flow across layers</li> <li>Identify Bottlenecks: Visualize which components are slow</li> <li>Understand Dependencies: See how services interact</li> <li>Root Cause Analysis: Correlate logs with traces for faster debugging</li> </ol>"},{"location":"guides/opentelemetry-integration/#for-operations","title":"For Operations","text":"<ol> <li>Performance Monitoring: Track response times and throughput</li> <li>Alerting: Set alerts on SLIs (latency, error rate, saturation)</li> <li>Capacity Planning: Understand resource usage trends</li> <li>Incident Response: Quickly isolate and diagnose issues</li> </ol>"},{"location":"guides/opentelemetry-integration/#for-business","title":"For Business","text":"<ol> <li>User Experience: Monitor actual user-facing performance</li> <li>Feature Usage: Track which features are used most</li> <li>Business Metrics: Orders, revenue, conversion rates</li> <li>SLA Compliance: Measure and report on service level objectives</li> </ol>"},{"location":"guides/opentelemetry-integration/#grafana-dashboards","title":"\ud83c\udfa8 Grafana Dashboards","text":""},{"location":"guides/opentelemetry-integration/#1-overview-dashboard","title":"1. Overview Dashboard","text":"<ul> <li>Request rate (requests/sec)</li> <li>Error rate (%)</li> <li>P50, P95, P99 latency</li> <li>Active services</li> <li>Top endpoints by traffic</li> </ul>"},{"location":"guides/opentelemetry-integration/#2-traces-dashboard-tempo","title":"2. Traces Dashboard (Tempo)","text":"<ul> <li>Trace search by operation, duration, tags</li> <li>Service dependency graph</li> <li>Span flamegraphs</li> <li>Trace-to-logs correlation</li> </ul>"},{"location":"guides/opentelemetry-integration/#3-metrics-dashboard-prometheus","title":"3. Metrics Dashboard (Prometheus)","text":"<ul> <li>Command execution time (histogram)</li> <li>Query execution time (histogram)</li> <li>Event processing time (histogram)</li> <li>Repository operation time (histogram)</li> <li>Business metrics (orders, pizzas, revenue)</li> </ul>"},{"location":"guides/opentelemetry-integration/#4-logs-dashboard-loki","title":"4. Logs Dashboard (Loki)","text":"<ul> <li>Log stream viewer</li> <li>Log filtering by trace_id, service, level</li> <li>Log rate over time</li> <li>Error log aggregation</li> </ul>"},{"location":"guides/opentelemetry-integration/#5-marios-pizzeria-business-dashboard","title":"5. Mario's Pizzeria Business Dashboard","text":"<ul> <li>Orders per hour</li> <li>Average order value</li> <li>Popular pizzas</li> <li>Order status distribution</li> <li>Delivery time metrics</li> </ul>"},{"location":"guides/opentelemetry-integration/#trace-context-propagation","title":"\ud83d\udcca Trace Context Propagation","text":"<p>OpenTelemetry uses W3C Trace Context for propagating trace information:</p> <p>HTTP Headers:</p> <pre><code>traceparent: 00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01\ntracestate: vendor1=value1,vendor2=value2\n</code></pre> <p>Propagation Flow:</p> <ol> <li>Incoming HTTP request with traceparent header</li> <li>FastAPI auto-instrumentation extracts context</li> <li>Context propagated to commands, queries, events</li> <li>Context included in outgoing HTTP calls</li> <li>Context correlated in logs and metrics</li> </ol>"},{"location":"guides/opentelemetry-integration/#security-considerations","title":"\ud83d\udd12 Security Considerations","text":"<ol> <li>Network Isolation: OTEL collector not exposed to public internet</li> <li>Authentication: Grafana requires login (admin/admin default)</li> <li>Data Retention: Configure retention policies for traces/logs/metrics</li> <li>PII Handling: Avoid logging sensitive customer data</li> <li>Resource Limits: Configure memory/CPU limits for collector</li> </ol>"},{"location":"guides/opentelemetry-integration/#performance-considerations","title":"\u26a1 Performance Considerations","text":"<ol> <li>Sampling: Use tail-based sampling for high-volume services</li> <li>Batch Processing: Collector batches telemetry before export</li> <li>Async Export: Telemetry export is non-blocking</li> <li>Resource Detection: Done once at startup</li> <li>Memory Limits: Configure collector memory_limiter processor</li> </ol> <p>Typical Overhead:</p> <ul> <li>Tracing: &lt; 1-2% CPU overhead</li> <li>Metrics: &lt; 1% CPU overhead</li> <li>Logging: &lt; 5% CPU overhead (structured logging)</li> </ul>"},{"location":"guides/opentelemetry-integration/#testing-otel-integration","title":"\ud83e\uddea Testing OTEL Integration","text":""},{"location":"guides/opentelemetry-integration/#manual-testing","title":"Manual Testing","text":"<pre><code># 1. Start services\n./mario-docker.sh start\n\n# 2. Generate some traffic\ncurl -X POST http://localhost:8000/api/orders \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"customer_id\": \"cust_123\",\n    \"items\": [{\"pizza_id\": \"margherita\", \"quantity\": 2}]\n  }'\n\n# 3. Check OTEL collector health\ncurl http://localhost:13133/\n\n# 4. View Grafana dashboards\nopen http://localhost:3001\n# Login: admin/admin\n# Navigate: Explore \u2192 Tempo (traces)\n# Navigate: Explore \u2192 Prometheus (metrics)\n# Navigate: Explore \u2192 Loki (logs)\n\n# 5. Check collector logs\ndocker logs mario-pizzeria-otel-collector-1\n</code></pre>"},{"location":"guides/opentelemetry-integration/#verify-trace-flow","title":"Verify Trace Flow","text":"<ol> <li>In Application: Check logs for trace_id in output</li> <li>In Collector: Check collector logs for received spans</li> <li>In Tempo: Search for traces in Grafana Explore</li> <li>In Grafana: View trace waterfall and span details</li> </ol>"},{"location":"guides/opentelemetry-integration/#verify-metrics-flow","title":"Verify Metrics Flow","text":"<ol> <li>In Application: Metrics recorded and exported</li> <li>In Collector: Metrics forwarded to Prometheus</li> <li>In Prometheus: Query metrics with PromQL</li> <li>In Grafana: Visualize metrics on dashboards</li> </ol>"},{"location":"guides/opentelemetry-integration/#verify-logs-flow","title":"Verify Logs Flow","text":"<ol> <li>In Application: Structured logs with trace context</li> <li>In Collector: Logs forwarded to Loki</li> <li>In Loki: Query logs with LogQL</li> <li>In Grafana: View correlated logs with traces</li> </ol>"},{"location":"guides/opentelemetry-integration/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>OpenTelemetry Python Documentation</li> <li>Grafana Tempo Documentation</li> <li>Prometheus Documentation</li> <li>Grafana Loki Documentation</li> <li>W3C Trace Context Specification</li> </ul>"},{"location":"guides/opentelemetry-integration/#learning-resources","title":"\ud83c\udf93 Learning Resources","text":""},{"location":"guides/opentelemetry-integration/#concepts","title":"Concepts","text":"<ul> <li>Observability vs Monitoring</li> <li>Distributed Tracing Guide</li> <li>Metrics Best Practices</li> </ul>"},{"location":"guides/opentelemetry-integration/#tutorials","title":"Tutorials","text":"<ul> <li>Getting Started with OpenTelemetry</li> <li>Grafana Fundamentals</li> <li>PromQL Tutorial</li> </ul>"},{"location":"guides/opentelemetry-integration/#next-steps","title":"\ud83d\udcdd Next Steps","text":"<p>After completing the OTEL integration:</p> <ol> <li>Baseline Performance: Establish baseline metrics for all operations</li> <li>Set SLOs: Define Service Level Objectives (e.g., P95 &lt; 500ms)</li> <li>Create Alerts: Configure alerts for SLO violations</li> <li>Document Runbooks: Create troubleshooting guides using traces</li> <li>Optimize Hot Paths: Use trace data to identify and optimize slow operations</li> <li>Custom Dashboards: Build domain-specific dashboards for your team</li> <li>Team Training: Train team on using Grafana for debugging and monitoring</li> </ol> <p>Status: Implementation in progress - see TODO list for detailed task breakdown</p>"},{"location":"guides/otel-framework-integration-analysis/","title":"\ud83c\udfaf OpenTelemetry Framework Integration Analysis","text":""},{"location":"guides/otel-framework-integration-analysis/#executive-summary","title":"Executive Summary","text":"<p>This document analyzes the OpenTelemetry implementation and identifies components that should be added to the Neuroglia Framework as reusable, generic features versus application-specific components that should remain in Mario's Pizzeria.</p>"},{"location":"guides/otel-framework-integration-analysis/#framework-components-neurogliaobservability","title":"\ud83c\udfd7\ufe0f Framework Components (neuroglia.observability)","text":""},{"location":"guides/otel-framework-integration-analysis/#should-be-in-framework-these-are-generic-and-reusable","title":"\u2705 SHOULD BE IN FRAMEWORK - These are generic and reusable","text":""},{"location":"guides/otel-framework-integration-analysis/#1-configuration-module-neurogliaobservabilityconfig","title":"1. Configuration Module (<code>neuroglia.observability.config</code>)","text":"<p>Status: \u2705 Already created Justification:</p> <ul> <li>Generic: Initialization of OTEL SDK is identical across all applications</li> <li>Reusable: Every application needs TracerProvider, MeterProvider setup</li> <li>Configurable: Uses environment variables and dataclass configuration</li> <li>Value: Eliminates boilerplate in every application</li> </ul> <p>What it provides:</p> <ul> <li><code>OpenTelemetryConfig</code> dataclass with environment variable defaults</li> <li><code>configure_opentelemetry()</code> - one-line initialization</li> <li><code>shutdown_opentelemetry()</code> - graceful cleanup</li> <li>Automatic instrumentation setup (FastAPI, HTTPX, Logging, System Metrics)</li> <li>Resource detection and configuration</li> </ul>"},{"location":"guides/otel-framework-integration-analysis/#2-tracing-module-neurogliaobservabilitytracing","title":"2. Tracing Module (<code>neuroglia.observability.tracing</code>)","text":"<p>Status: \u2705 Already created Justification:</p> <ul> <li>Generic: Tracer retrieval and span management is framework-level</li> <li>Developer Experience: Decorators (<code>@trace_async</code>, <code>@trace_sync</code>) massively simplify instrumentation</li> <li>Reusable: Every application needs manual instrumentation capabilities</li> <li>Best Practices: Encapsulates OpenTelemetry best practices</li> </ul> <p>What it provides:</p> <ul> <li><code>get_tracer()</code> - cached tracer retrieval</li> <li><code>@trace_async()</code> / <code>@trace_sync()</code> - automatic span creation decorators</li> <li><code>add_span_attributes()</code> - helper for adding span data</li> <li><code>add_span_event()</code> - event recording</li> <li><code>record_exception()</code> - exception tracking</li> <li>Context propagation utilities</li> </ul>"},{"location":"guides/otel-framework-integration-analysis/#3-metrics-module-neurogliaobservabilitymetrics","title":"3. Metrics Module (<code>neuroglia.observability.metrics</code>)","text":"<p>Status: \u2705 Already created Justification:</p> <ul> <li>Generic: Meter and instrument creation is framework-level</li> <li>Convenience: Helper functions eliminate repetitive code</li> <li>Reusable: Every application needs counters, histograms, gauges</li> <li>Pattern: Provides standard patterns for metric naming and usage</li> </ul> <p>What it provides:</p> <ul> <li><code>get_meter()</code> - cached meter retrieval</li> <li><code>create_counter()</code> / <code>create_histogram()</code> / etc. - instrument creation</li> <li><code>record_metric()</code> - convenience function for one-off metrics</li> <li>Pre-defined framework metrics (command.duration, query.duration, etc.)</li> </ul> <p>Note: Application-specific metrics like <code>MarioMetrics</code> should be in application code, NOT framework.</p>"},{"location":"guides/otel-framework-integration-analysis/#4-logging-module-neurogliaobservabilitylogging","title":"4. Logging Module (<code>neuroglia.observability.logging</code>)","text":"<p>Status: \u2705 Already created Justification:</p> <ul> <li>Generic: Trace context injection is framework-level concern</li> <li>Reusable: Structured logging with trace correlation benefits all apps</li> <li>Integration: Works with OTEL logging instrumentation</li> <li>Developer Experience: Simplifies log correlation with traces</li> </ul> <p>What it provides:</p> <ul> <li><code>TraceContextFilter</code> - automatic trace_id/span_id injection</li> <li><code>StructuredFormatter</code> - JSON structured logging</li> <li><code>configure_logging()</code> - one-line logging setup with trace context</li> <li><code>log_with_trace()</code> - manual trace correlation</li> <li><code>LoggingContext</code> - contextual logging scope</li> </ul>"},{"location":"guides/otel-framework-integration-analysis/#framework-middleware-neurogliamediation-neurogliamvc","title":"\ud83d\udd27 Framework Middleware (neuroglia.mediation / neuroglia.mvc)","text":""},{"location":"guides/otel-framework-integration-analysis/#should-be-in-framework-automatic-instrumentation-for-cqrs-pattern","title":"\u2705 SHOULD BE IN FRAMEWORK - Automatic instrumentation for CQRS pattern","text":""},{"location":"guides/otel-framework-integration-analysis/#5-cqrs-tracing-middleware-new-needs-creation","title":"5. CQRS Tracing Middleware (NEW - needs creation)","text":"<p>Location: <code>neuroglia.mediation.tracing_middleware.py</code> Justification:</p> <ul> <li>Generic: All applications using Neuroglia use CQRS</li> <li>Automatic: Zero-code instrumentation for commands/queries</li> <li>Consistent: Standardizes trace naming across all apps</li> <li>Performance: Automatic duration metrics</li> </ul> <p>What it should provide:</p> <pre><code>class TracingPipelineBehavior(PipelineBehavior[TRequest, TResult]):\n    \"\"\"Automatically creates spans for commands and queries\"\"\"\n    async def handle_async(self, request, next_handler):\n        tracer = get_tracer(__name__)\n        request_type = type(request).__name__\n        span_name = f\"CQRS.{request_type}\"\n\n        with tracer.start_as_current_span(span_name) as span:\n            add_span_attributes({\n                \"cqrs.type\": \"command\" if isinstance(request, Command) else \"query\",\n                \"cqrs.name\": request_type,\n            })\n\n            start_time = time.time()\n            try:\n                result = await next_handler()\n                duration_ms = (time.time() - start_time) * 1000\n\n                # Record metrics\n                metric_name = \"neuroglia.command.duration\" if isinstance(request, Command) else \"neuroglia.query.duration\"\n                record_metric(\"histogram\", metric_name, duration_ms, {\"type\": request_type})\n\n                span.set_status(StatusCode.OK)\n                return result\n            except Exception as ex:\n                record_exception(ex)\n                raise\n</code></pre> <p>Usage (in application):</p> <pre><code>services.add_pipeline_behavior(TracingPipelineBehavior)  # One line!\n</code></pre>"},{"location":"guides/otel-framework-integration-analysis/#6-event-handler-tracing-middleware-new-needs-creation","title":"6. Event Handler Tracing Middleware (NEW - needs creation)","text":"<p>Location: <code>neuroglia.eventing.tracing_middleware.py</code> Justification:</p> <ul> <li>Generic: All event handlers benefit from automatic tracing</li> <li>Async Event Chains: Traces show complete event propagation</li> <li>Performance: Tracks event processing time</li> </ul> <p>What it should provide:</p> <pre><code>class EventHandlerTracingWrapper:\n    \"\"\"Wraps event handlers to automatically create spans\"\"\"\n    def __init__(self, handler: EventHandler):\n        self.handler = handler\n\n    async def handle_async(self, event: DomainEvent):\n        tracer = get_tracer(__name__)\n        event_type = type(event).__name__\n\n        with tracer.start_as_current_span(f\"Event.{event_type}\") as span:\n            add_span_attributes({\n                \"event.type\": event_type,\n                \"event.id\": getattr(event, 'id', 'unknown'),\n            })\n\n            start_time = time.time()\n            try:\n                await self.handler.handle_async(event)\n                duration_ms = (time.time() - start_time) * 1000\n                record_metric(\"histogram\", \"neuroglia.event.processing.duration\",\n                             duration_ms, {\"event.type\": event_type})\n            except Exception as ex:\n                record_exception(ex)\n                raise\n</code></pre>"},{"location":"guides/otel-framework-integration-analysis/#7-repository-tracing-mixin-new-needs-creation","title":"7. Repository Tracing Mixin (NEW - needs creation)","text":"<p>Location: <code>neuroglia.data.tracing_mixin.py</code> Justification:</p> <ul> <li>Generic: All repositories benefit from automatic tracing</li> <li>Database Performance: Tracks database operation duration</li> <li>Debugging: Shows which queries are slow</li> </ul> <p>What it should provide:</p> <pre><code>class TracedRepositoryMixin:\n    \"\"\"Mixin to add automatic tracing to repository operations\"\"\"\n\n    async def get_async(self, id: str):\n        tracer = get_tracer(__name__)\n        with tracer.start_as_current_span(f\"Repository.get\") as span:\n            add_span_attributes({\n                \"repository.operation\": \"get\",\n                \"repository.type\": type(self).__name__,\n                \"entity.id\": id,\n            })\n            return await super().get_async(id)\n\n    async def add_async(self, entity):\n        tracer = get_tracer(__name__)\n        with tracer.start_as_current_span(f\"Repository.add\") as span:\n            add_span_attributes({\n                \"repository.operation\": \"add\",\n                \"repository.type\": type(self).__name__,\n                \"entity.type\": type(entity).__name__,\n            })\n            return await super().add_async(entity)\n\n    # Similar for update_async, delete_async, etc.\n</code></pre> <p>Usage (in application):</p> <pre><code>class UserRepository(TracedRepositoryMixin, MongoRepository[User]):\n    pass  # Automatic tracing!\n</code></pre>"},{"location":"guides/otel-framework-integration-analysis/#application-specific-components","title":"\ud83d\udce6 Application-Specific Components","text":""},{"location":"guides/otel-framework-integration-analysis/#should-not-be-in-framework-these-are-marios-pizzeria-specific","title":"\u274c SHOULD NOT BE IN FRAMEWORK - These are Mario's Pizzeria specific","text":""},{"location":"guides/otel-framework-integration-analysis/#8-marios-pizzeria-business-metrics","title":"8. Mario's Pizzeria Business Metrics","text":"<p>Current Location: <code>neuroglia.observability.metrics.MarioMetrics</code> Should Move To: <code>samples/mario-pizzeria/observability/metrics.py</code></p> <p>Justification:</p> <ul> <li>Domain-Specific: Metrics like \"orders.created\", \"pizzas.ordered\" are business logic</li> <li>Not Reusable: Other applications have different business metrics</li> <li>Application Concern: Business KPIs belong in application layer</li> </ul> <p>Recommendation:</p> <ul> <li>Remove <code>MarioMetrics</code> class from framework</li> <li>Create application-specific metrics module:</li> </ul> <pre><code># samples/mario-pizzeria/observability/metrics.py\nfrom neuroglia.observability import create_counter, create_histogram\n\n# Business metrics\norders_created_counter = create_counter(\"mario.orders.created\", unit=\"orders\")\norders_completed_counter = create_counter(\"mario.orders.completed\", unit=\"orders\")\norder_value_histogram = create_histogram(\"mario.orders.value\", unit=\"USD\")\npizzas_ordered_counter = create_counter(\"mario.pizzas.ordered\", unit=\"pizzas\")\n</code></pre>"},{"location":"guides/otel-framework-integration-analysis/#9-custom-span-attributes-for-business-logic","title":"9. Custom Span Attributes for Business Logic","text":"<p>Justification:</p> <ul> <li>Domain-Specific: Attributes like \"pizza.type\", \"order.status\" are application concepts</li> <li>Not Reusable: Every application has different entities and attributes</li> </ul> <p>Recommendation: Applications should add business-specific attributes in their handlers:</p> <pre><code># In application handler\n@trace_async()\nasync def handle_async(self, command: PlaceOrderCommand):\n    # Framework handles basic span\n    # Application adds business context\n    add_span_attributes({\n        \"order.id\": order.id,\n        \"customer.id\": command.customer_id,\n        \"order.item_count\": len(command.items),\n        \"order.total\": order.total_amount,\n    })\n    # ... business logic\n</code></pre>"},{"location":"guides/otel-framework-integration-analysis/#grafana-dashboards","title":"\ud83c\udfa8 Grafana Dashboards","text":""},{"location":"guides/otel-framework-integration-analysis/#hybrid-approach-generic-templates-application-customization","title":"\ud83e\udd1d HYBRID APPROACH - Generic templates + application customization","text":""},{"location":"guides/otel-framework-integration-analysis/#10-framework-dashboard-templates-new-needs-creation","title":"10. Framework Dashboard Templates (NEW - needs creation)","text":"<p>Location: <code>deployment/grafana/templates/</code> Justification:</p> <ul> <li>Generic Patterns: All Neuroglia apps have commands, queries, events</li> <li>Starting Point: Provides template dashboards for common patterns</li> <li>Customizable: Applications can clone and modify</li> </ul> <p>What it should provide:</p> <ul> <li><code>neuroglia-cqrs-overview.json</code> - Commands/queries overview template</li> <li><code>neuroglia-event-processing.json</code> - Event handler metrics template</li> <li><code>neuroglia-repository-performance.json</code> - Database operation metrics template</li> </ul>"},{"location":"guides/otel-framework-integration-analysis/#11-application-specific-dashboards","title":"11. Application-Specific Dashboards","text":"<p>Location: <code>deployment/grafana/dashboards/json/</code> Justification:</p> <ul> <li>Business Metrics: Unique to each application</li> <li>Custom Visualizations: Domain-specific charts</li> </ul> <p>Examples:</p> <ul> <li><code>mario-business-metrics.json</code> - Orders, pizzas, revenue</li> <li><code>mario-order-pipeline.json</code> - Order status flow visualization</li> <li><code>mario-customer-analytics.json</code> - Customer behavior metrics</li> </ul>"},{"location":"guides/otel-framework-integration-analysis/#documentation","title":"\ud83d\udcdd Documentation","text":""},{"location":"guides/otel-framework-integration-analysis/#should-be-in-framework","title":"\u2705 SHOULD BE IN FRAMEWORK","text":""},{"location":"guides/otel-framework-integration-analysis/#12-generic-otel-integration-guide","title":"12. Generic OTEL Integration Guide","text":"<p>Location: <code>docs/features/observability.md</code> Content:</p> <ul> <li>How to configure OpenTelemetry in any Neuroglia application</li> <li>Using decorators and helpers</li> <li>Best practices for instrumentation</li> <li>Performance considerations</li> </ul>"},{"location":"guides/otel-framework-integration-analysis/#should-be-in-application","title":"\u2705 SHOULD BE IN APPLICATION","text":""},{"location":"guides/otel-framework-integration-analysis/#13-marios-pizzeria-otel-setup","title":"13. Mario's Pizzeria OTEL Setup","text":"<p>Location: <code>docs/samples/mario-pizzeria-observability.md</code> Content:</p> <ul> <li>Mario-specific dashboard explanations</li> <li>Business metrics definitions</li> <li>Custom instrumentation examples</li> </ul>"},{"location":"guides/otel-framework-integration-analysis/#implementation-priority","title":"\ud83c\udfaf Implementation Priority","text":""},{"location":"guides/otel-framework-integration-analysis/#phase-1-core-framework-completed","title":"Phase 1: Core Framework (COMPLETED \u2705)","text":"<ol> <li>\u2705 <code>neuroglia.observability.config</code></li> <li>\u2705 <code>neuroglia.observability.tracing</code></li> <li>\u2705 <code>neuroglia.observability.metrics</code></li> <li>\u2705 <code>neuroglia.observability.logging</code></li> </ol>"},{"location":"guides/otel-framework-integration-analysis/#phase-2-middleware-integration-next","title":"Phase 2: Middleware Integration (NEXT)","text":"<ol> <li>\u23f3 <code>neuroglia.mediation.tracing_middleware</code> - CQRS tracing</li> <li>\u23f3 <code>neuroglia.eventing.tracing_middleware</code> - Event handler tracing</li> <li>\u23f3 <code>neuroglia.data.tracing_mixin</code> - Repository tracing</li> </ol>"},{"location":"guides/otel-framework-integration-analysis/#phase-3-application-integration","title":"Phase 3: Application Integration","text":"<ol> <li>\u23f3 Initialize OTEL in <code>samples/mario-pizzeria/main.py</code></li> <li>\u23f3 Create Mario-specific metrics module</li> <li>\u23f3 Add custom instrumentation to handlers</li> </ol>"},{"location":"guides/otel-framework-integration-analysis/#phase-4-visualization-documentation","title":"Phase 4: Visualization &amp; Documentation","text":"<ol> <li>\u23f3 Create generic dashboard templates</li> <li>\u23f3 Create Mario-specific dashboards</li> <li>\u23f3 Write framework documentation</li> <li>\u23f3 Write application-specific guide</li> </ol>"},{"location":"guides/otel-framework-integration-analysis/#recommendation-summary","title":"\ud83c\udf93 Recommendation Summary","text":""},{"location":"guides/otel-framework-integration-analysis/#add-to-framework","title":"Add to Framework \u2705","text":"<ul> <li>Complete <code>neuroglia.observability</code> module (done)</li> <li>CQRS tracing middleware (<code>TracingPipelineBehavior</code>)</li> <li>Event handler tracing wrapper</li> <li>Repository tracing mixin</li> <li>Generic dashboard templates</li> <li>Framework-level OTEL documentation</li> </ul>"},{"location":"guides/otel-framework-integration-analysis/#keep-in-application","title":"Keep in Application \u274c","text":"<ul> <li>Business-specific metrics (<code>MarioMetrics</code>)</li> <li>Domain-specific span attributes</li> <li>Application dashboards</li> <li>Business metric initialization</li> </ul>"},{"location":"guides/otel-framework-integration-analysis/#benefit-analysis","title":"Benefit Analysis","text":"<p>Developer Experience Improvement:</p> <ul> <li>Before: 100+ lines of OTEL boilerplate per application</li> <li>After: 5-10 lines of configuration</li> </ul> <p>Example - Application Startup:</p> <pre><code># WITHOUT framework support (hypothetical)\n# ~100+ lines of OTEL setup code\n\n# WITH framework support\nfrom neuroglia.observability import configure_opentelemetry\nfrom neuroglia.mediation import TracingPipelineBehavior\n\nconfigure_opentelemetry(\n    service_name=\"my-service\",\n    otlp_endpoint=\"http://otel-collector:4317\"\n)\n\nservices.add_pipeline_behavior(TracingPipelineBehavior)  # Automatic CQRS tracing!\n</code></pre> <p>Performance Monitoring:</p> <ul> <li>\u2705 Automatic metrics for ALL commands, queries, events</li> <li>\u2705 Automatic tracing for ALL CQRS operations</li> <li>\u2705 Automatic database operation timing</li> <li>\u2705 Zero-code instrumentation</li> </ul> <p>Observability Coverage:</p> <ul> <li>\ud83c\udfaf 100% trace coverage of CQRS operations</li> <li>\ud83c\udfaf 100% metric coverage of framework patterns</li> <li>\ud83c\udfaf Automatic log-trace correlation</li> <li>\ud83c\udfaf Consistent naming conventions</li> </ul>"},{"location":"guides/otel-framework-integration-analysis/#next-steps","title":"\ud83d\udd17 Next Steps","text":"<ol> <li>Install Dependencies: Run <code>poetry install</code> to get OTEL packages</li> <li>Create Middleware: Implement tracing middleware for CQRS, events, repositories</li> <li>Integrate with Mario's Pizzeria: Add OTEL initialization to <code>main.py</code></li> <li>Test End-to-End: Verify traces/metrics/logs flow through the stack</li> <li>Create Dashboards: Build Grafana dashboards for visualization</li> <li>Document Patterns: Write comprehensive documentation</li> </ol> <p>Conclusion: The <code>neuroglia.observability</code> module provides a solid foundation for OpenTelemetry integration that is generic, reusable, and eliminates boilerplate. The next step is creating middleware components that automatically instrument the Neuroglia framework patterns (CQRS, events, repositories), providing zero-code observability for all Neuroglia applications.</p>"},{"location":"guides/project-setup/","title":"\ud83d\ude80 Project Setup Guide","text":"<p>\ud83d\udea7 Under Construction</p> <p>This guide is currently being developed with comprehensive setup procedures and troubleshooting tips. More detailed examples and best practices are being added.</p> <p>Complete guide for setting up new Neuroglia Python Framework projects, from initial creation to deployment-ready applications.</p>"},{"location":"guides/project-setup/#overview","title":"\ud83c\udfaf Overview","text":"<p>This guide walks you through creating a new Neuroglia project using the Mario's Pizzeria example, covering project structure, dependency management, and initial configuration.</p>"},{"location":"guides/project-setup/#prerequisites","title":"\ud83d\udccb Prerequisites","text":"<p>Before starting, ensure you have:</p> <ul> <li>Python 3.9+ installed</li> <li>Poetry for dependency management</li> <li>Git for version control</li> <li>VS Code or preferred IDE</li> </ul> <pre><code># Verify Python version\npython --version  # Should be 3.9 or higher\n\n# Install Poetry if not already installed\ncurl -sSL https://install.python-poetry.org | python3 -\n\n# Verify Poetry installation\npoetry --version\n</code></pre>"},{"location":"guides/project-setup/#creating-a-new-project","title":"\ud83c\udfd7\ufe0f Creating a New Project","text":""},{"location":"guides/project-setup/#option-1-using-pyneuroctl-recommended","title":"Option 1: Using PyNeuroctl (Recommended)","text":"<pre><code># Install the CLI tool\npip install neuroglia-cli\n\n# Create new project from pizzeria template\npyneuroctl new my-pizzeria --template pizzeria\ncd my-pizzeria\n\n# Install dependencies\npoetry install\n\n# Run the application\npoetry run python main.py\n</code></pre>"},{"location":"guides/project-setup/#option-2-manual-setup","title":"Option 2: Manual Setup","text":"<pre><code># Create project directory\nmkdir my-pizzeria &amp;&amp; cd my-pizzeria\n\n# Initialize Poetry project\npoetry init --name my-pizzeria --description \"Pizza ordering system\"\n\n# Add Neuroglia framework\npoetry add neuroglia\n\n# Add development dependencies\npoetry add --group dev pytest pytest-asyncio httpx\n\n# Create project structure\nmkdir -p src/{api,application,domain,integration}\nmkdir -p tests/{unit,integration}\n</code></pre>"},{"location":"guides/project-setup/#project-structure","title":"\ud83d\udcc1 Project Structure","text":"<p>Create the clean architecture structure:</p> <pre><code>my-pizzeria/\n\u251c\u2500\u2500 pyproject.toml              # Project configuration\n\u251c\u2500\u2500 main.py                     # Application entry point\n\u251c\u2500\u2500 README.md                   # Project documentation\n\u251c\u2500\u2500 .env                        # Environment variables\n\u251c\u2500\u2500 .gitignore                  # Git ignore patterns\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 api/                    # \ud83c\udf10 API Layer\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 controllers/        # REST endpoints\n\u2502   \u2502   \u2514\u2500\u2500 dtos/              # Request/response models\n\u2502   \u251c\u2500\u2500 application/            # \ud83d\udcbc Application Layer\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 commands/          # Write operations\n\u2502   \u2502   \u251c\u2500\u2500 queries/           # Read operations\n\u2502   \u2502   \u251c\u2500\u2500 handlers/          # Business logic\n\u2502   \u2502   \u2514\u2500\u2500 services/          # Application services\n\u2502   \u251c\u2500\u2500 domain/                # \ud83c\udfdb\ufe0f Domain Layer\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 entities/          # Business entities\n\u2502   \u2502   \u251c\u2500\u2500 events/            # Domain events\n\u2502   \u2502   \u2514\u2500\u2500 repositories/      # Repository interfaces\n\u2502   \u2514\u2500\u2500 integration/           # \ud83d\udd0c Integration Layer\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 repositories/      # Data access implementations\n\u2502       \u2514\u2500\u2500 services/          # External service integrations\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 conftest.py           # Test configuration\n\u2502   \u251c\u2500\u2500 unit/                 # Unit tests\n\u2502   \u2514\u2500\u2500 integration/          # Integration tests\n\u2514\u2500\u2500 docs/                     # Project documentation\n</code></pre>"},{"location":"guides/project-setup/#configuration-setup","title":"\u2699\ufe0f Configuration Setup","text":""},{"location":"guides/project-setup/#1-environment-configuration","title":"1. Environment Configuration","text":"<p>Create <code>.env</code> file:</p> <pre><code># Application Settings\nAPP_NAME=My Pizzeria\nAPP_VERSION=1.0.0\nDEBUG=true\n\n# Server Configuration\nHOST=0.0.0.0\nPORT=8000\n\n# Database Configuration\nDATABASE_TYPE=mongodb\nMONGODB_CONNECTION_STRING=mongodb://localhost:27017/pizzeria\n\n# External Services\nSMS_SERVICE_API_KEY=your_sms_api_key\nEMAIL_SERVICE_API_KEY=your_email_api_key\nPAYMENT_GATEWAY_API_KEY=your_payment_api_key\n\n# Logging\nLOG_LEVEL=INFO\nLOG_FORMAT=json\n</code></pre>"},{"location":"guides/project-setup/#2-project-configuration","title":"2. Project Configuration","text":"<p>Update <code>pyproject.toml</code>:</p> <pre><code>[tool.poetry]\nname = \"my-pizzeria\"\nversion = \"1.0.0\"\ndescription = \"Pizza ordering system built with Neuroglia\"\nauthors = [\"Your Name &lt;your.email@example.com&gt;\"]\npackages = [{include = \"src\"}]\n\n[tool.poetry.dependencies]\npython = \"^3.9\"\nneuroglia = \"^0.3.0\"\nfastapi = \"^0.104.0\"\nuvicorn = \"^0.24.0\"\nmotor = \"^3.3.0\"  # MongoDB async driver\npydantic-settings = \"^2.0.0\"\n\n[tool.poetry.group.dev.dependencies]\npytest = \"^7.4.0\"\npytest-asyncio = \"^0.21.0\"\nhttpx = \"^0.25.0\"\npytest-cov = \"^4.1.0\"\nblack = \"^23.0.0\"\nisort = \"^5.12.0\"\nmypy = \"^1.6.0\"\n\n[tool.pytest.ini_options]\nasyncio_mode = \"auto\"\ntestpaths = [\"tests\"]\npython_files = [\"test_*.py\", \"*_test.py\"]\n\n[tool.black]\nline-length = 100\ntarget-version = ['py39']\n\n[tool.isort]\nprofile = \"black\"\nmulti_line_output = 3\nline_length = 100\n\n[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n</code></pre>"},{"location":"guides/project-setup/#initial-implementation","title":"\ud83c\udf55 Initial Implementation","text":""},{"location":"guides/project-setup/#1-application-entry-point","title":"1. Application Entry Point","text":"<p>Create <code>main.py</code>:</p> <pre><code>import asyncio\nfrom src.startup import create_app\n\nasync def main():\n    \"\"\"Application entry point\"\"\"\n    app = await create_app()\n\n    import uvicorn\n    uvicorn.run(\n        app,\n        host=\"0.0.0.0\",\n        port=8000,\n        reload=True  # Development only\n    )\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"guides/project-setup/#2-application-startup","title":"2. Application Startup","text":"<p>Create <code>src/startup.py</code>:</p> <pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.dependency_injection import ServiceCollection\nfrom src.api.controllers.orders_controller import OrdersController\nfrom src.application.handlers.place_order_handler import PlaceOrderHandler\nfrom src.integration.repositories.mongo_order_repository import MongoOrderRepository\n\nasync def create_app():\n    \"\"\"Configure and build the application\"\"\"\n    builder = WebApplicationBuilder()\n\n    # Configure services\n    configure_services(builder.services)\n\n    # Build application\n    app = builder.build()\n\n    # Configure middleware\n    configure_middleware(app)\n\n    return app\n\ndef configure_services(services: ServiceCollection):\n    \"\"\"Configure dependency injection\"\"\"\n    # Add framework services\n    services.add_mediator()\n    services.add_controllers([\n        \"src.api.controllers\"\n    ])\n\n    # Add application services\n    services.add_scoped(PlaceOrderHandler)\n\n    # Add repositories\n    services.add_scoped(MongoOrderRepository)\n\n    # Add external services\n    # services.add_scoped(SMSService)\n    # services.add_scoped(PaymentService)\n\ndef configure_middleware(app):\n    \"\"\"Configure application middleware\"\"\"\n    # Add CORS if needed\n    # app.add_middleware(CORSMiddleware, ...)\n\n    # Add authentication if needed\n    # app.add_middleware(AuthenticationMiddleware, ...)\n\n    pass\n</code></pre>"},{"location":"guides/project-setup/#3-first-domain-entity","title":"3. First Domain Entity","text":"<p>Create <code>src/domain/entities/order.py</code>:</p> <pre><code>from dataclasses import dataclass\nfrom decimal import Decimal\nfrom datetime import datetime\nfrom typing import List, Optional\nfrom enum import Enum\nfrom neuroglia.domain import Entity\nfrom src.domain.events.order_events import OrderPlacedEvent\n\nclass OrderStatus(Enum):\n    PENDING = \"pending\"\n    CONFIRMED = \"confirmed\"\n    PREPARING = \"preparing\"\n    READY = \"ready\"\n    DELIVERED = \"delivered\"\n    CANCELLED = \"cancelled\"\n\n@dataclass\nclass OrderItem:\n    pizza_name: str\n    size: str\n    quantity: int\n    price: Decimal\n\nclass Order(Entity):\n    def __init__(self,\n                 customer_id: str,\n                 items: List[OrderItem],\n                 delivery_address: str,\n                 special_instructions: Optional[str] = None):\n        super().__init__()\n        self.customer_id = customer_id\n        self.items = items\n        self.delivery_address = delivery_address\n        self.special_instructions = special_instructions\n        self.status = OrderStatus.PENDING\n        self.total = self._calculate_total()\n        self.created_at = datetime.now(timezone.utc)\n        self.updated_at = self.created_at\n\n        # Raise domain event\n        self.raise_event(OrderPlacedEvent(\n            order_id=self.id,\n            customer_id=customer_id,\n            total=self.total,\n            items=items\n        ))\n\n    def _calculate_total(self) -&gt; Decimal:\n        \"\"\"Calculate order total with tax\"\"\"\n        subtotal = sum(item.price * item.quantity for item in self.items)\n        tax = subtotal * Decimal('0.08')  # 8% tax\n        return subtotal + tax\n\n    def confirm(self):\n        \"\"\"Confirm the order\"\"\"\n        if self.status != OrderStatus.PENDING:\n            raise ValueError(\"Only pending orders can be confirmed\")\n        self.status = OrderStatus.CONFIRMED\n        self.updated_at = datetime.now(timezone.utc)\n</code></pre>"},{"location":"guides/project-setup/#4-first-command-handler","title":"4. First Command Handler","text":"<p>Create <code>src/application/handlers/place_order_handler.py</code>:</p> <pre><code>from dataclasses import dataclass\nfrom typing import List\nfrom neuroglia.mediation import Command, CommandHandler\nfrom neuroglia.core import OperationResult\nfrom src.domain.entities.order import Order, OrderItem\nfrom src.api.dtos.order_dto import OrderDto\n\n@dataclass\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    customer_id: str\n    items: List[OrderItem]\n    delivery_address: str\n    special_instructions: str = None\n\nclass PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    def __init__(self, order_repository):\n        self._repository = order_repository\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        try:\n            # Create domain entity\n            order = Order(\n                customer_id=command.customer_id,\n                items=command.items,\n                delivery_address=command.delivery_address,\n                special_instructions=command.special_instructions\n            )\n\n            # Persist order\n            await self._repository.save_async(order)\n\n            # Return success result\n            dto = OrderDto(\n                id=order.id,\n                customer_id=order.customer_id,\n                total=order.total,\n                status=order.status.value,\n                created_at=order.created_at\n            )\n\n            return self.created(dto)\n\n        except Exception as ex:\n            return self.internal_server_error(f\"Failed to place order: {str(ex)}\")\n</code></pre>"},{"location":"guides/project-setup/#5-first-controller","title":"5. First Controller","text":"<p>Create <code>src/api/controllers/orders_controller.py</code>:</p> <pre><code>from fastapi import HTTPException\nfrom neuroglia.mvc import ControllerBase\nfrom classy_fastapi import post\nfrom src.application.handlers.place_order_handler import PlaceOrderCommand\nfrom src.api.dtos.place_order_request import PlaceOrderRequest\nfrom src.api.dtos.order_dto import OrderDto\n\nclass OrdersController(ControllerBase):\n\n    @post(\"/orders\", response_model=OrderDto, status_code=201)\n    async def place_order(self, request: PlaceOrderRequest) -&gt; OrderDto:\n        \"\"\"Place a new pizza order\"\"\"\n        command = PlaceOrderCommand(\n            customer_id=request.customer_id,\n            items=request.items,\n            delivery_address=request.delivery_address,\n            special_instructions=request.special_instructions\n        )\n\n        result = await self.mediator.execute_async(command)\n\n        if result.is_success:\n            return result.data\n        else:\n            raise HTTPException(\n                status_code=result.status_code,\n                detail=result.error_message\n            )\n</code></pre>"},{"location":"guides/project-setup/#testing-setup","title":"\ud83e\uddea Testing Setup","text":""},{"location":"guides/project-setup/#1-test-configuration","title":"1. Test Configuration","text":"<p>Create <code>tests/conftest.py</code>:</p> <pre><code>import pytest\nfrom unittest.mock import Mock\nfrom neuroglia.dependency_injection import ServiceCollection\nfrom src.startup import configure_services\n\n@pytest.fixture\ndef service_collection():\n    \"\"\"Provide a configured service collection for testing\"\"\"\n    services = ServiceCollection()\n    configure_services(services)\n    return services\n\n@pytest.fixture\ndef mock_order_repository():\n    \"\"\"Provide a mocked order repository\"\"\"\n    return Mock()\n\n@pytest.fixture\ndef sample_order_items():\n    \"\"\"Provide sample order items for testing\"\"\"\n    from src.domain.entities.order import OrderItem\n    from decimal import Decimal\n\n    return [\n        OrderItem(\n            pizza_name=\"Margherita\",\n            size=\"Large\",\n            quantity=1,\n            price=Decimal('15.99')\n        ),\n        OrderItem(\n            pizza_name=\"Pepperoni\",\n            size=\"Medium\",\n            quantity=2,\n            price=Decimal('12.99')\n        )\n    ]\n</code></pre>"},{"location":"guides/project-setup/#2-first-unit-test","title":"2. First Unit Test","text":"<p>Create <code>tests/unit/test_place_order_handler.py</code>:</p> <pre><code>import pytest\nfrom decimal import Decimal\nfrom src.application.handlers.place_order_handler import PlaceOrderHandler, PlaceOrderCommand\n\nclass TestPlaceOrderHandler:\n    def setup_method(self):\n        self.mock_repository = Mock()\n        self.handler = PlaceOrderHandler(self.mock_repository)\n\n    @pytest.mark.asyncio\n    async def test_place_order_success(self, sample_order_items):\n        # Arrange\n        command = PlaceOrderCommand(\n            customer_id=\"123\",\n            items=sample_order_items,\n            delivery_address=\"123 Pizza St\"\n        )\n\n        # Act\n        result = await self.handler.handle_async(command)\n\n        # Assert\n        assert result.is_success\n        assert result.data.customer_id == \"123\"\n        self.mock_repository.save_async.assert_called_once()\n</code></pre>"},{"location":"guides/project-setup/#running-the-application","title":"\ud83d\ude80 Running the Application","text":""},{"location":"guides/project-setup/#development-mode","title":"Development Mode","text":"<pre><code># Install dependencies\npoetry install\n\n# Run with hot reload\npoetry run python main.py\n\n# Or using uvicorn directly\npoetry run uvicorn src.main:app --reload\n</code></pre>"},{"location":"guides/project-setup/#testing","title":"Testing","text":"<pre><code># Run all tests\npoetry run pytest\n\n# Run with coverage\npoetry run pytest --cov=src\n\n# Run specific test file\npoetry run pytest tests/unit/test_place_order_handler.py -v\n</code></pre>"},{"location":"guides/project-setup/#code-quality","title":"Code Quality","text":"<pre><code># Format code\npoetry run black src tests\n\n# Sort imports\npoetry run isort src tests\n\n# Type checking\npoetry run mypy src\n</code></pre>"},{"location":"guides/project-setup/#next-steps","title":"\ud83d\udd27 Next Steps","text":"<p>After basic setup, consider:</p> <ol> <li>API Development Guide - Add more endpoints</li> <li>Testing Guide - Comprehensive testing strategies</li> <li>Database Integration Guide - Connect to real databases</li> <li>Deployment Guide - Deploy to production</li> </ol>"},{"location":"guides/project-setup/#troubleshooting","title":"\ud83c\udd98 Troubleshooting","text":""},{"location":"guides/project-setup/#common-issues","title":"Common Issues","text":"<p>Import Errors</p> <pre><code># Ensure proper Python path\nexport PYTHONPATH=\"${PYTHONPATH}:${PWD}/src\"\n</code></pre> <p>Poetry Issues</p> <pre><code># Reset poetry environment\npoetry env remove python\npoetry install\n</code></pre> <p>Missing Dependencies</p> <pre><code># Update lock file\npoetry update\n</code></pre>"},{"location":"guides/project-setup/#related-guides","title":"\ud83d\udd17 Related Guides","text":"<ul> <li>Testing Setup - Comprehensive testing strategies</li> <li>API Development - Building REST endpoints</li> <li>Database Integration - Data persistence setup</li> </ul> <p>This guide provides the foundation for building production-ready Neuroglia applications using proven architectural patterns. \ud83d\ude80</p>"},{"location":"guides/testing-setup/","title":"\ud83e\uddea Testing Setup Guide","text":"<p>\ud83d\udea7 Under Construction</p> <p>This guide is currently being developed with comprehensive testing strategies and examples. More detailed test patterns and best practices are being added.</p> <p>Complete guide for setting up comprehensive testing in Neuroglia applications, covering unit tests, integration tests, and testing best practices.</p>"},{"location":"guides/testing-setup/#overview","title":"\ud83c\udfaf Overview","text":"<p>Testing is crucial for maintaining high-quality Neuroglia applications. This guide demonstrates testing strategies using Mario's Pizzeria as an example, covering all architectural layers.</p>"},{"location":"guides/testing-setup/#testing-strategy","title":"\ud83c\udfd7\ufe0f Testing Strategy","text":""},{"location":"guides/testing-setup/#testing-pyramid","title":"Testing Pyramid","text":"<pre><code>flowchart TD\n    subgraph \"\ud83e\uddea Testing Pyramid\"\n        E2E[End-to-End Tests&lt;br/&gt;\ud83c\udf10 Full Application Flow]\n        Integration[Integration Tests&lt;br/&gt;\ud83d\udd0c Component Interaction]\n        Unit[Unit Tests&lt;br/&gt;\u26a1 Individual Components]\n    end\n\n    E2E --&gt; Integration\n    Integration --&gt; Unit\n\n    Unit -.-&gt;|\"Most Tests\"| Fast[Fast Execution]\n    Integration -.-&gt;|\"Moderate Tests\"| Medium[Medium Execution]\n    E2E -.-&gt;|\"Few Tests\"| Slow[Slower Execution]</code></pre>"},{"location":"guides/testing-setup/#layer-specific-testing","title":"Layer-Specific Testing","text":"<ul> <li>Domain Layer: Pure unit tests for business logic</li> <li>Application Layer: Handler tests with mocked dependencies</li> <li>API Layer: Integration tests with test client</li> <li>Integration Layer: Repository and service tests</li> </ul>"},{"location":"guides/testing-setup/#test-setup","title":"\ud83d\udd27 Test Setup","text":""},{"location":"guides/testing-setup/#dependencies","title":"Dependencies","text":"<pre><code>[tool.poetry.group.dev.dependencies]\npytest = \"^7.4.0\"\npytest-asyncio = \"^0.21.0\"\npytest-cov = \"^4.1.0\"\nhttpx = \"^0.25.0\"\npytest-mock = \"^3.12.0\"\nfaker = \"^19.0.0\"\n</code></pre>"},{"location":"guides/testing-setup/#configuration","title":"Configuration","text":"<p>Create <code>pytest.ini</code>:</p> <pre><code>[tool:pytest]\nasyncio_mode = auto\ntestpaths = tests\npython_files = test_*.py *_test.py\npython_classes = Test*\npython_functions = test_*\naddopts =\n    --strict-markers\n    --strict-config\n    --cov=src\n    --cov-report=html\n    --cov-report=term-missing\n    --cov-fail-under=90\nmarkers =\n    unit: Unit tests\n    integration: Integration tests\n    e2e: End-to-end tests\n    slow: Slow running tests\n</code></pre>"},{"location":"guides/testing-setup/#unit-testing","title":"\ud83c\udfaf Unit Testing","text":""},{"location":"guides/testing-setup/#domain-entity-tests","title":"Domain Entity Tests","text":"<pre><code># tests/unit/domain/test_order.py\nimport pytest\nfrom decimal import Decimal\nfrom src.domain.entities.order import Order, OrderItem, OrderStatus\n\nclass TestOrder:\n    def test_order_creation_calculates_total_with_tax(self):\n        # Arrange\n        items = [\n            OrderItem(\"Margherita\", \"Large\", 1, Decimal('15.99')),\n            OrderItem(\"Pepperoni\", \"Medium\", 2, Decimal('12.99'))\n        ]\n\n        # Act\n        order = Order(\"customer-123\", items, \"123 Pizza St\")\n\n        # Assert\n        expected_subtotal = Decimal('41.97')  # 15.99 + (2 * 12.99)\n        expected_tax = expected_subtotal * Decimal('0.08')\n        expected_total = expected_subtotal + expected_tax\n\n        assert order.total == expected_total\n        assert order.status == OrderStatus.PENDING\n\n    def test_order_raises_domain_event(self):\n        # Arrange\n        items = [OrderItem(\"Margherita\", \"Large\", 1, Decimal('15.99'))]\n\n        # Act\n        order = Order(\"customer-123\", items, \"123 Pizza St\")\n        events = order.get_uncommitted_events()\n\n        # Assert\n        assert len(events) == 1\n        assert events[0].order_id == order.id\n        assert events[0].customer_id == \"customer-123\"\n</code></pre>"},{"location":"guides/testing-setup/#command-handler-tests","title":"Command Handler Tests","text":"<pre><code># tests/unit/application/test_place_order_handler.py\nimport pytest\nfrom unittest.mock import Mock, AsyncMock\nfrom decimal import Decimal\nfrom src.application.handlers.place_order_handler import PlaceOrderHandler, PlaceOrderCommand\nfrom src.domain.entities.order import OrderItem\n\nclass TestPlaceOrderHandler:\n    def setup_method(self):\n        self.mock_repository = Mock()\n        self.mock_repository.save_async = AsyncMock()\n        self.handler = PlaceOrderHandler(self.mock_repository)\n\n    @pytest.mark.asyncio\n    async def test_place_order_success(self):\n        # Arrange\n        items = [OrderItem(\"Margherita\", \"Large\", 1, Decimal('15.99'))]\n        command = PlaceOrderCommand(\n            customer_id=\"customer-123\",\n            items=items,\n            delivery_address=\"123 Pizza St\"\n        )\n\n        # Act\n        result = await self.handler.handle_async(command)\n\n        # Assert\n        assert result.is_success\n        assert result.data.customer_id == \"customer-123\"\n        self.mock_repository.save_async.assert_called_once()\n\n    @pytest.mark.asyncio\n    async def test_place_order_repository_error(self):\n        # Arrange\n        self.mock_repository.save_async.side_effect = Exception(\"Database error\")\n        command = PlaceOrderCommand(\n            customer_id=\"customer-123\",\n            items=[OrderItem(\"Margherita\", \"Large\", 1, Decimal('15.99'))],\n            delivery_address=\"123 Pizza St\"\n        )\n\n        # Act\n        result = await self.handler.handle_async(command)\n\n        # Assert\n        assert not result.is_success\n        assert \"Database error\" in result.error_message\n</code></pre>"},{"location":"guides/testing-setup/#integration-testing","title":"\ud83d\udd0c Integration Testing","text":""},{"location":"guides/testing-setup/#controller-integration-tests","title":"Controller Integration Tests","text":"<pre><code># tests/integration/api/test_orders_controller.py\nimport pytest\nfrom httpx import AsyncClient\nfrom src.main import create_app\n\nclass TestOrdersController:\n    @pytest.fixture\n    async def test_app(self):\n        app = await create_app()\n        return app\n\n    @pytest.fixture\n    async def test_client(self, test_app):\n        async with AsyncClient(app=test_app, base_url=\"http://test\") as client:\n            yield client\n\n    @pytest.mark.asyncio\n    async def test_place_order_success(self, test_client):\n        # Arrange\n        order_data = {\n            \"customer_id\": \"customer-123\",\n            \"items\": [\n                {\n                    \"pizza_name\": \"Margherita\",\n                    \"size\": \"Large\",\n                    \"quantity\": 1,\n                    \"price\": 15.99\n                }\n            ],\n            \"delivery_address\": \"123 Pizza St\"\n        }\n\n        # Act\n        response = await test_client.post(\"/orders\", json=order_data)\n\n        # Assert\n        assert response.status_code == 201\n        data = response.json()\n        assert data[\"customer_id\"] == \"customer-123\"\n        assert \"id\" in data\n\n    @pytest.mark.asyncio\n    async def test_place_order_validation_error(self, test_client):\n        # Arrange - Invalid data (missing required fields)\n        invalid_data = {\"customer_id\": \"customer-123\"}\n\n        # Act\n        response = await test_client.post(\"/orders\", json=invalid_data)\n\n        # Assert\n        assert response.status_code == 422  # Validation error\n</code></pre>"},{"location":"guides/testing-setup/#repository-integration-tests","title":"Repository Integration Tests","text":"<pre><code># tests/integration/repositories/test_mongo_order_repository.py\nimport pytest\nfrom motor.motor_asyncio import AsyncIOMotorClient\nfrom src.integration.repositories.mongo_order_repository import MongoOrderRepository\nfrom src.domain.entities.order import Order, OrderItem\nfrom decimal import Decimal\n\n@pytest.mark.integration\nclass TestMongoOrderRepository:\n    @pytest.fixture\n    async def mongo_client(self):\n        client = AsyncIOMotorClient(\"mongodb://localhost:27017\")\n        yield client\n        # Cleanup\n        await client.test_pizzeria.orders.drop()\n        client.close()\n\n    @pytest.fixture\n    def repository(self, mongo_client):\n        collection = mongo_client.test_pizzeria.orders\n        return MongoOrderRepository(collection)\n\n    @pytest.mark.asyncio\n    async def test_save_and_retrieve_order(self, repository):\n        # Arrange\n        items = [OrderItem(\"Margherita\", \"Large\", 1, Decimal('15.99'))]\n        order = Order(\"customer-123\", items, \"123 Pizza St\")\n\n        # Act\n        await repository.save_async(order)\n        retrieved = await repository.get_by_id_async(order.id)\n\n        # Assert\n        assert retrieved is not None\n        assert retrieved.customer_id == \"customer-123\"\n        assert len(retrieved.items) == 1\n        assert retrieved.items[0].pizza_name == \"Margherita\"\n\n    @pytest.mark.asyncio\n    async def test_find_by_customer(self, repository):\n        # Arrange\n        items = [OrderItem(\"Margherita\", \"Large\", 1, Decimal('15.99'))]\n        order1 = Order(\"customer-123\", items, \"123 Pizza St\")\n        order2 = Order(\"customer-123\", items, \"456 Pizza Ave\")\n        order3 = Order(\"customer-456\", items, \"789 Pizza Blvd\")\n\n        await repository.save_async(order1)\n        await repository.save_async(order2)\n        await repository.save_async(order3)\n\n        # Act\n        customer_orders = await repository.find_by_customer_async(\"customer-123\")\n\n        # Assert\n        assert len(customer_orders) == 2\n        assert all(order.customer_id == \"customer-123\" for order in customer_orders)\n</code></pre>"},{"location":"guides/testing-setup/#end-to-end-testing","title":"\ud83c\udf10 End-to-End Testing","text":""},{"location":"guides/testing-setup/#full-workflow-tests","title":"Full Workflow Tests","text":"<pre><code># tests/e2e/test_pizza_ordering_workflow.py\nimport pytest\nfrom httpx import AsyncClient\nfrom src.main import create_app\n\n@pytest.mark.e2e\nclass TestPizzaOrderingWorkflow:\n    @pytest.fixture\n    async def test_client(self):\n        app = await create_app()\n        async with AsyncClient(app=app, base_url=\"http://test\") as client:\n            yield client\n\n    @pytest.mark.asyncio\n    async def test_complete_order_workflow(self, test_client):\n        # 1. Get menu\n        menu_response = await test_client.get(\"/menu\")\n        assert menu_response.status_code == 200\n        menu = menu_response.json()\n        assert len(menu) &gt; 0\n\n        # 2. Place order\n        order_data = {\n            \"customer_id\": \"customer-123\",\n            \"items\": [\n                {\n                    \"pizza_name\": menu[0][\"name\"],\n                    \"size\": \"Large\",\n                    \"quantity\": 1,\n                    \"price\": menu[0][\"price\"]\n                }\n            ],\n            \"delivery_address\": \"123 Pizza St\"\n        }\n\n        order_response = await test_client.post(\"/orders\", json=order_data)\n        assert order_response.status_code == 201\n        order = order_response.json()\n        order_id = order[\"id\"]\n\n        # 3. Check order status\n        status_response = await test_client.get(f\"/orders/{order_id}\")\n        assert status_response.status_code == 200\n        status_data = status_response.json()\n        assert status_data[\"id\"] == order_id\n        assert status_data[\"status\"] == \"pending\"\n\n        # 4. Get customer order history\n        history_response = await test_client.get(\n            f\"/orders?customer_id=customer-123\"\n        )\n        assert history_response.status_code == 200\n        history = history_response.json()\n        assert len(history) &gt;= 1\n        assert any(o[\"id\"] == order_id for o in history)\n</code></pre>"},{"location":"guides/testing-setup/#test-fixtures-and-factories","title":"\ud83c\udfad Test Fixtures and Factories","text":""},{"location":"guides/testing-setup/#data-factories","title":"Data Factories","text":"<pre><code># tests/factories.py\nfrom faker import Faker\nfrom decimal import Decimal\nfrom src.domain.entities.order import Order, OrderItem\n\nfake = Faker()\n\nclass OrderFactory:\n    @staticmethod\n    def create_order_item(\n        pizza_name: str = None,\n        size: str = \"Large\",\n        quantity: int = 1,\n        price: Decimal = None\n    ) -&gt; OrderItem:\n        return OrderItem(\n            pizza_name=pizza_name or fake.word(),\n            size=size,\n            quantity=quantity,\n            price=price or Decimal(str(fake.pydecimal(left_digits=2, right_digits=2, positive=True)))\n        )\n\n    @staticmethod\n    def create_order(\n        customer_id: str = None,\n        items: list = None,\n        delivery_address: str = None\n    ) -&gt; Order:\n        return Order(\n            customer_id=customer_id or fake.uuid4(),\n            items=items or [OrderFactory.create_order_item()],\n            delivery_address=delivery_address or fake.address()\n        )\n\n# Usage in tests\ndef test_order_with_factory():\n    order = OrderFactory.create_order(\n        customer_id=\"test-customer\",\n        items=[\n            OrderFactory.create_order_item(\"Margherita\", \"Large\", 2, Decimal('15.99'))\n        ]\n    )\n    assert order.customer_id == \"test-customer\"\n</code></pre>"},{"location":"guides/testing-setup/#shared-fixtures","title":"Shared Fixtures","text":"<pre><code># tests/conftest.py\nimport pytest\nfrom unittest.mock import Mock\nfrom src.domain.entities.order import OrderItem\nfrom decimal import Decimal\n\n@pytest.fixture\ndef sample_pizza_items():\n    return [\n        OrderItem(\"Margherita\", \"Large\", 1, Decimal('15.99')),\n        OrderItem(\"Pepperoni\", \"Medium\", 2, Decimal('12.99')),\n        OrderItem(\"Vegetarian\", \"Small\", 1, Decimal('10.99'))\n    ]\n\n@pytest.fixture\ndef mock_order_repository():\n    repository = Mock()\n    repository.save_async = Mock()\n    repository.get_by_id_async = Mock()\n    repository.find_by_customer_async = Mock()\n    return repository\n\n@pytest.fixture\ndef mock_sms_service():\n    service = Mock()\n    service.send_async = Mock()\n    return service\n</code></pre>"},{"location":"guides/testing-setup/#coverage-and-quality","title":"\ud83d\udcca Coverage and Quality","text":""},{"location":"guides/testing-setup/#coverage-configuration","title":"Coverage Configuration","text":"<pre><code># Run tests with coverage\npoetry run pytest --cov=src --cov-report=html --cov-report=term\n\n# Coverage configuration in pyproject.toml\n[tool.coverage.run]\nsource = [\"src\"]\nomit = [\n    \"src/__init__.py\",\n    \"src/main.py\",\n    \"*/tests/*\",\n]\n\n[tool.coverage.report]\nexclude_lines = [\n    \"pragma: no cover\",\n    \"def __repr__\",\n    \"raise AssertionError\",\n    \"raise NotImplementedError\",\n    \"if __name__ == .__main__.:\",\n]\n</code></pre>"},{"location":"guides/testing-setup/#test-execution","title":"\ud83d\ude80 Test Execution","text":""},{"location":"guides/testing-setup/#running-tests","title":"Running Tests","text":"<pre><code># All tests\npoetry run pytest\n\n# Unit tests only\npoetry run pytest tests/unit -m unit\n\n# Integration tests only\npoetry run pytest tests/integration -m integration\n\n# E2E tests only\npoetry run pytest tests/e2e -m e2e\n\n# Specific test file\npoetry run pytest tests/unit/test_order.py -v\n\n# With coverage\npoetry run pytest --cov=src --cov-report=html\n</code></pre>"},{"location":"guides/testing-setup/#continuous-integration","title":"Continuous Integration","text":"<pre><code># .github/workflows/test.yml\nname: Tests\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    services:\n      mongodb:\n        image: mongo:5.0\n        ports:\n          - 27017:27017\n\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v4\n        with:\n          python-version: \"3.9\"\n\n      - name: Install Poetry\n        run: pip install poetry\n\n      - name: Install dependencies\n        run: poetry install\n\n      - name: Run tests\n        run: poetry run pytest --cov=src --cov-report=xml\n\n      - name: Upload coverage\n        uses: codecov/codecov-action@v3\n</code></pre>"},{"location":"guides/testing-setup/#related-guides","title":"\ud83d\udd17 Related Guides","text":"<ul> <li>Project Setup - Initial project configuration</li> <li>API Development - Testing API endpoints</li> <li>Database Integration - Testing data access</li> </ul> <p>This guide establishes comprehensive testing practices that ensure high-quality, maintainable Neuroglia applications. \ud83e\uddea</p>"},{"location":"mario-pizzeria/business-analysis/","title":"\ud83c\udfe2 Mario's Pizzeria: Business Analysis &amp; Requirements","text":"<p>Customer: Mario's Family Restaurant Project: Digital Transformation Initiative Consultant: Neuroglia Architecture Team Date: 2025</p> <p>\ud83d\udcc2 View Complete Implementation on GitHub</p> <p>\ud83d\udca1 Pattern in Action: This document demonstrates how Clean Architecture and Domain-Driven Design principles translate business requirements into maintainable software architecture.</p>"},{"location":"mario-pizzeria/business-analysis/#executive-summary","title":"\ud83d\udcca Executive Summary","text":"<p>Mario's Pizzeria represents a typical small business digital transformation case study. This family-owned restaurant requires a modern ordering system to compete in today's digital marketplace while maintaining operational efficiency and customer satisfaction.</p> <p>Project Scope: Design and implement a comprehensive digital ordering platform that streamlines operations, improves customer experience, and provides real-time visibility into business operations.</p> <p>Architectural Approach: This project demonstrates event-driven architecture where business workflows (like kitchen operations) respond automatically to domain events, reducing coupling and improving scalability.</p>"},{"location":"mario-pizzeria/business-analysis/#business-overview","title":"\ud83c\udfaf Business Overview","text":"<p>Mario's Pizzeria is a local pizza restaurant that needs a digital ordering system to handle:</p> <ul> <li>Customer Orders: Online pizza ordering with customizations</li> <li>Menu Management: Pizza catalog with sizes, toppings, and pricing</li> <li>Kitchen Operations: Order queue management and preparation workflow</li> <li>Payment Processing: Multiple payment methods and transaction handling</li> <li>Customer Notifications: SMS alerts for order status updates</li> </ul> <p>The pizzeria demonstrates how a simple restaurant business can be modeled using domain-driven design principles:</p> <ul> <li>Takes pizza orders from customers</li> <li>Manages pizza recipes and inventory</li> <li>Cooks pizzas in the kitchen with capacity management</li> <li>Tracks order status through complete lifecycle</li> <li>Handles payments and customer notifications</li> <li>Provides real-time status updates to customers and staff</li> </ul>"},{"location":"mario-pizzeria/business-analysis/#system-architecture","title":"\ud83c\udfd7\ufe0f System Architecture","text":"<p>The pizzeria system demonstrates clean architecture with clear layer separation and dependency rules:</p> <p>\ud83c\udfaf Why This Matters: Clean architecture ensures business logic remains independent of frameworks, databases, and UI choices. See the Common Mistakes section to learn why mixing layers causes maintenance nightmares.</p> <pre><code>graph TB\n    %% Actors\n    Customer[\ud83d\udc64 Customer&lt;br/&gt;Pizza lover who wants to place orders]\n    KitchenStaff[\ud83d\udc68\u200d\ud83c\udf73 Kitchen Staff&lt;br/&gt;Cooks who prepare orders]\n    Manager[\ud83d\udc68\u200d\ud83d\udcbc Manager&lt;br/&gt;Manages menu and monitors operations]\n\n    %% System Boundary\n    subgraph PizzeriaSystem[Mario's Pizzeria System]\n        PizzeriaApp[\ud83c\udf55 Pizzeria Application&lt;br/&gt;FastAPI app with clean architecture]\n    end\n\n    %% External Systems\n    PaymentSystem[\ud83d\udcb3 Payment System&lt;br/&gt;Processes credit card payments]\n    SMSService[\ud83d\udcf1 SMS Service&lt;br/&gt;Sends order notifications]\n    FileStorage[\ud83d\udcbe File Storage&lt;br/&gt;JSON files for development]\n\n    %% Relationships\n    Customer --&gt;|Places orders, checks status| PizzeriaApp\n    KitchenStaff --&gt;|Views orders, updates status| PizzeriaApp\n    Manager --&gt;|Manages menu, monitors operations| PizzeriaApp\n\n    PizzeriaApp --&gt;|Processes payments via HTTPS| PaymentSystem\n    PizzeriaApp --&gt;|Sends notifications via API| SMSService\n    PizzeriaApp --&gt;|Stores orders and menu via File I/O| FileStorage\n\n    %% Styling\n    classDef customer fill:#FFF3E0,stroke:#E65100,stroke-width:2px\n    classDef system fill:#E1F5FE,stroke:#01579B,stroke-width:3px\n    classDef external fill:#F3E5F5,stroke:#7B1FA2,stroke-width:2px\n    classDef storage fill:#E8F5E8,stroke:#2E7D32,stroke-width:2px\n\n    class Customer,KitchenStaff,Manager customer\n    class PizzeriaApp system\n    class PaymentSystem,SMSService external\n        class FileStorage storage</code></pre>"},{"location":"mario-pizzeria/business-analysis/#main-system-interactions","title":"\ud83d\udd04 Main System Interactions","text":"<p>The following sequence diagram illustrates the complete pizza ordering workflow using CQRS (commands for writes) and event-driven architecture (events for workflow automation):</p> <p>\ud83c\udfaf Why Commands and Events?: Commands represent intent (\"place this order\"), while events represent facts (\"order was placed\"). This separation enables loose coupling and better scalability. Learn more in CQRS Pattern.</p> <pre><code>sequenceDiagram\n    participant C as Customer\n    participant API as Orders Controller\n    participant M as Mediator\n    participant PH as PlaceOrder Handler\n    participant OR as Order Repository\n    participant PS as Payment Service\n    participant K as Kitchen\n    participant SMS as SMS Service\n\n    Note over C,SMS: Complete Pizza Ordering Workflow\n\n    C-&gt;&gt;+API: POST /orders (pizza order)\n    API-&gt;&gt;+M: Execute PlaceOrderCommand\n    M-&gt;&gt;+PH: Handle command\n\n    PH-&gt;&gt;PH: Validate order &amp; calculate total\n    PH-&gt;&gt;+PS: Process payment\n    PS--&gt;&gt;-PH: Payment successful\n\n    PH-&gt;&gt;+OR: Save order\n    OR--&gt;&gt;-PH: Order saved\n\n    PH-&gt;&gt;PH: Raise OrderPlacedEvent\n    PH--&gt;&gt;-M: Return OrderDto\n    M--&gt;&gt;-API: Return result\n    API--&gt;&gt;-C: 201 Created + OrderDto\n\n    Note over K,SMS: Event-Driven Kitchen Workflow\n\n    M-&gt;&gt;+K: OrderPlacedEvent \u2192 Add to queue\n    K--&gt;&gt;-M: Order queued\n\n    rect rgb(255, 245, 235)\n        Note over K: Kitchen processes order\n        K-&gt;&gt;K: Start cooking\n        K-&gt;&gt;+M: Publish OrderCookingEvent\n        M--&gt;&gt;-K: Event processed\n    end\n\n    rect rgb(240, 255, 240)\n        Note over K: Order ready\n        K-&gt;&gt;+M: Publish OrderReadyEvent\n        M-&gt;&gt;+SMS: Send ready notification\n        SMS-&gt;&gt;C: \"Your order is ready!\"\n        SMS--&gt;&gt;-M: Notification sent\n        M--&gt;&gt;-K: Event processed\n    end\n\n    C-&gt;&gt;+API: GET /orders/{id}\n    API-&gt;&gt;+M: Execute GetOrderQuery\n    M--&gt;&gt;-API: Return OrderDto\n    API--&gt;&gt;-C: Order details</code></pre> <p>--- storage</p> <pre><code>---mermaid\nsequenceDiagram\n    participant C as Customer\n    participant API as Orders Controller\n    participant M as Mediator\n    participant PH as PlaceOrder Handler\n    participant OR as Order Repository\n    participant PS as Payment Service\n    participant K as Kitchen\n    participant SMS as SMS Service\n\n    Note over C,SMS: Complete Pizza Ordering Workflow\n\n    C-&gt;&gt;+API: POST /orders (pizza order)\n    API-&gt;&gt;+M: Execute PlaceOrderCommand\n    M-&gt;&gt;+PH: Handle command\n\n    PH-&gt;&gt;PH: Validate order &amp; calculate total\n    PH-&gt;&gt;+PS: Process payment\n    PS--&gt;&gt;-PH: Payment successful\n\n    PH-&gt;&gt;+OR: Save order\n    OR--&gt;&gt;-PH: Order saved\n\n    PH-&gt;&gt;PH: Raise OrderPlacedEvent\n    PH--&gt;&gt;-M: Return OrderDto\n    M--&gt;&gt;-API: Return result\n    API--&gt;&gt;-C: 201 Created + OrderDto\n\n    Note over K,SMS: Event-Driven Kitchen Workflow\n\n    M-&gt;&gt;+K: OrderPlacedEvent \u2192 Add to queue\n    K--&gt;&gt;-M: Order queued\n\n    rect rgb(255, 245, 235)\n        Note over K: Kitchen processes order\n        K-&gt;&gt;K: Start cooking\n        K-&gt;&gt;+M: Publish OrderCookingEvent\n        M--&gt;&gt;-K: Event processed\n    end\n\n    rect rgb(240, 255, 240)\n        Note over K: Order ready\n        K-&gt;&gt;+M: Publish OrderReadyEvent\n        M-&gt;&gt;+SMS: Send ready notification\n        SMS-&gt;&gt;C: \"Your order is ready!\"\n        SMS--&gt;&gt;-M: Notification sent\n        M--&gt;&gt;-K: Event processed\n    end\n\n    C-&gt;&gt;+API: GET /orders/{id}\n    API-&gt;&gt;+M: Execute GetOrderQuery\n    M--&gt;&gt;-API: Return OrderDto\n    API--&gt;&gt;-C: Order details\n</code></pre>"},{"location":"mario-pizzeria/business-analysis/#business-requirements-analysis","title":"\ud83d\udcbc Business Requirements Analysis","text":""},{"location":"mario-pizzeria/business-analysis/#primary-stakeholders","title":"Primary Stakeholders","text":"Stakeholder Role Key Needs Customers Order pizza online Easy ordering, real-time status, reliable delivery Kitchen Staff Prepare orders Clear order queue, cooking instructions, status updates Management Business oversight Sales reporting, inventory tracking, performance metrics Delivery Order fulfillment Route optimization, customer contact, payment collection"},{"location":"mario-pizzeria/business-analysis/#functional-requirements","title":"Functional Requirements","text":"Category Requirement Priority Complexity Ordering Browse menu with customizations High Medium Ordering Calculate pricing with taxes High Low Ordering Process secure payments High High Kitchen Manage cooking queue High Medium Kitchen Track preparation time Medium Low Notifications SMS order updates Medium Medium Management Sales analytics Low High"},{"location":"mario-pizzeria/business-analysis/#non-functional-requirements","title":"Non-Functional Requirements","text":"Requirement Target Rationale Response Time &lt; 2 seconds Customer experience Availability 99.5% uptime Business continuity Scalability 100 concurrent orders Peak dinner rush Security PCI DSS compliance Payment processing Usability Mobile-first design Customer preference"},{"location":"mario-pizzeria/business-analysis/#success-metrics","title":"\ud83d\ude80 Success Metrics","text":""},{"location":"mario-pizzeria/business-analysis/#business-kpis","title":"Business KPIs","text":"<ul> <li>Order Volume: 30% increase in daily orders</li> <li>Average Order Value: $25 \u2192 $30 target</li> <li>Customer Satisfaction: &gt; 4.5/5 rating</li> <li>Order Accuracy: &gt; 98% correct orders</li> <li>Kitchen Efficiency: &lt; 15 minute average prep time</li> </ul>"},{"location":"mario-pizzeria/business-analysis/#technical-metrics","title":"Technical Metrics","text":"<ul> <li>API Response Time: &lt; 500ms average</li> <li>System Uptime: &gt; 99.5%</li> <li>Error Rate: &lt; 0.1%</li> <li>Payment Success: &gt; 99.9%</li> </ul>"},{"location":"mario-pizzeria/business-analysis/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":""},{"location":"mario-pizzeria/business-analysis/#case-study-documents","title":"Case Study Documents","text":"<ul> <li>Technical Architecture - System design and infrastructure</li> <li>Domain Design - Business logic and data models</li> <li>Implementation Guide - Development patterns and APIs</li> <li>Testing &amp; Deployment - Quality assurance and operations</li> </ul>"},{"location":"mario-pizzeria/business-analysis/#framework-patterns-demonstrated","title":"Framework Patterns Demonstrated","text":"<ul> <li>Clean Architecture - Four-layer separation seen throughout the system</li> <li>Event-Driven Architecture - Kitchen workflow automation with domain events</li> <li>CQRS Pattern - Commands (PlaceOrder) vs Queries (GetOrder) separation</li> <li>Domain-Driven Design - Business concepts as rich domain models</li> </ul> <p>\ud83d\udca1 Learning Tip: Each pattern page includes \"Common Mistakes\" and \"When NOT to Use\" sections derived from real-world implementations like Mario's Pizzeria!</p> <p>This analysis serves as the foundation for Mario's Pizzeria digital transformation, demonstrating modern software architecture principles applied to real-world business scenarios.</p>"},{"location":"mario-pizzeria/domain-design/","title":"\ud83c\udfaf Mario's Pizzeria: Domain Design &amp; Business Logic","text":"<p>Domain Modeling Document | Approach: Domain-Driven Design (DDD) Patterns: Rich Domain Models, Value Objects, Domain Events | Status: Reference Implementation</p> <p>\ud83d\udca1 Pattern in Action: This document demonstrates Domain-Driven Design with rich domain models that contain business logic, not just data. See how Mario's Pizzeria avoids the anemic domain model anti-pattern.</p>"},{"location":"mario-pizzeria/domain-design/#domain-overview","title":"\ud83c\udfaf Domain Overview","text":"<p>The Mario's Pizzeria domain captures the essential business concepts and workflows of a pizza restaurant operation. Using Domain-Driven Design principles, we model the core business entities with rich behavior, clear boundaries, and event-driven workflows.</p> <p>Core Domain Concepts:</p> <ul> <li>Orders: Central to the business, capturing customer requests and tracking fulfillment</li> <li>Pizza: Product catalog with pricing and customization logic</li> <li>Kitchen: Resource management and capacity planning</li> <li>Customer: Contact information and order history</li> </ul> <p>Key Patterns Demonstrated:</p> <ul> <li>\u2705 Rich Domain Models - Entities contain business logic, not just data</li> <li>\u2705 Aggregate Roots - Kitchen controls order processing boundaries</li> <li>\u2705 Value Objects - Money, Address with equality semantics</li> <li>\u2705 Domain Events - OrderPlaced, OrderReady for workflow automation</li> <li>\u2705 Repository Pattern - Data access abstraction</li> </ul> <p>\u26a0\ufe0f Avoid Common Mistake: Don't create anemic domain models with only getters/setters! Our Order entity has methods like <code>confirmOrder()</code> and <code>startCooking()</code> that enforce business rules. Learn more in DDD Common Mistakes.</p>"},{"location":"mario-pizzeria/domain-design/#domain-model","title":"\ud83d\udcca Domain Model","text":"<p>The core business entities and their relationships:</p> <pre><code>classDiagram\n    class Customer {\n        +String id\n        +String name\n        +String email\n        +String phone\n        +String address\n        +updateContactInfo()\n    }\n\n    class Order {\n        +String id\n        +String customerId\n        +List~Pizza~ pizzas\n        +OrderStatus status\n        +Decimal totalAmount\n        +DateTime orderTime\n        +addPizza()\n        +confirmOrder()\n        +startCooking()\n        +markReady()\n        +deliverOrder()\n        +cancelOrder()\n    }\n\n    class Pizza {\n        +String id\n        +String name\n        +PizzaSize size\n        +Decimal basePrice\n        +List~String~ toppings\n        +Decimal totalPrice\n        +addTopping()\n        +removeTopping()\n    }\n\n    class Kitchen {\n        +String id\n        +List~String~ activeOrders\n        +Int maxConcurrentOrders\n        +Int currentCapacity\n        +Bool isAtCapacity\n        +startOrder()\n        +completeOrder()\n    }\n\n    class OrderStatus {\n        &lt;&lt;enumeration&gt;&gt;\n        PENDING\n        CONFIRMED\n        COOKING\n        READY\n        DELIVERED\n        CANCELLED\n    }\n\n    class PizzaSize {\n        &lt;&lt;enumeration&gt;&gt;\n        SMALL\n        MEDIUM\n        LARGE\n    }\n\n    Customer \"1\" --&gt; \"*\" Order : places\n    Order \"1\" --&gt; \"*\" Pizza : contains\n    Order --&gt; OrderStatus : has\n    Pizza --&gt; PizzaSize : has\n    Kitchen \"1\" --&gt; \"*\" Order : processes\n\n    note for Order \"Rich domain entity with&lt;br/&gt;business logic and events\"\n    note for Pizza \"Value object with&lt;br/&gt;pricing calculations\"\n    note for Kitchen \"Aggregate root for&lt;br/&gt;capacity management\"</code></pre>"},{"location":"mario-pizzeria/domain-design/#detailed-domain-entities","title":"\ud83c\udfd7\ufe0f Detailed Domain Entities","text":""},{"location":"mario-pizzeria/domain-design/#pizza-aggregate-root","title":"Pizza Aggregate Root","text":"<p>The Pizza aggregate root encapsulates product information, pricing logic, and customization capabilities with sophisticated size-based pricing using event sourcing:</p> <p>\ud83d\udccb View Source Code</p> <pre><code>from neuroglia.data.abstractions import AggregateRoot, AggregateState\nfrom domain.entities.enums import PizzaSize\n\n@dataclass\nclass PizzaState(AggregateState[str]):\n    \"\"\"State object for Pizza aggregate - contains all persisted data\"\"\"\n\n    name: Optional[str] = None\n    base_price: Optional[Decimal] = None\n    size: Optional[PizzaSize] = None\n    description: str = \"\"\n    toppings: list[str] = field(default_factory=list)\n\n    @dispatch(PizzaCreatedEvent)\n    def on(self, event: PizzaCreatedEvent) -&gt; None:\n        \"\"\"Handle PizzaCreatedEvent to initialize pizza state\"\"\"\n        self.id = event.aggregate_id\n        self.name = event.name\n        self.base_price = event.base_price\n        self.size = PizzaSize(event.size)\n        self.description = event.description or \"\"\n        self.toppings = event.toppings.copy()\n\n    @dispatch(ToppingsUpdatedEvent)\n    def on(self, event: ToppingsUpdatedEvent) -&gt; None:\n        \"\"\"Handle ToppingsUpdatedEvent to update toppings list\"\"\"\n        self.toppings = event.toppings.copy()\n\n@map_from(PizzaDto)\n@map_to(PizzaDto)\nclass Pizza(AggregateRoot[PizzaState, str]):\n    \"\"\"Pizza aggregate root with pricing and toppings\"\"\"\n\n    def __init__(self, name: str, base_price: Decimal, size: PizzaSize, description: Optional[str] = None):\n        super().__init__()\n\n        # Register event and apply it to state using multipledispatch\n        self.state.on(\n            self.register_event(\n                PizzaCreatedEvent(\n                    aggregate_id=str(uuid4()),\n                    name=name,\n                    size=size.value,\n                    base_price=base_price,\n                    description=description or \"\",\n                    toppings=[]\n                )\n            )\n        )\n\n    @property\n    def size_multiplier(self) -&gt; Decimal:\n        \"\"\"Get price multiplier based on pizza size\"\"\"\n        if self.state.size is None:\n            return Decimal(\"1.0\")\n        multipliers = {\n            PizzaSize.SMALL: Decimal(\"1.0\"),\n            PizzaSize.MEDIUM: Decimal(\"1.3\"),\n            PizzaSize.LARGE: Decimal(\"1.6\"),\n        }\n        return multipliers[self.state.size]\n\n    @property\n    def topping_price(self) -&gt; Decimal:\n        \"\"\"Calculate total price for all toppings\"\"\"\n        return Decimal(str(len(self.state.toppings))) * Decimal(\"2.50\")\n\n    @property\n    def total_price(self) -&gt; Decimal:\n        \"\"\"Calculate total pizza price including size and toppings\"\"\"\n        base_with_size = self.state.base_price * self.size_multiplier\n        return base_with_size + self.topping_price\n\n    def add_topping(self, topping: str) -&gt; None:\n        \"\"\"Add a topping to the pizza\"\"\"\n        if topping not in self.state.toppings:\n            new_toppings = self.state.toppings + [topping]\n            self.state.on(\n                self.register_event(\n                    ToppingsUpdatedEvent(\n                        aggregate_id=self.id(),\n                        toppings=new_toppings\n                    )\n                )\n            )\n\n    def remove_topping(self, topping: str) -&gt; None:\n        \"\"\"Remove a topping from the pizza\"\"\"\n        if topping in self.state.toppings:\n            new_toppings = [t for t in self.state.toppings if t != topping]\n            self.state.on(\n                self.register_event(\n                    ToppingsUpdatedEvent(\n                        aggregate_id=self.id(),\n                        toppings=new_toppings\n                    )\n                )\n            )\n</code></pre> <p>Business Rules:</p> <ul> <li>Size multipliers: Small (1.0x), Medium (1.3x), Large (1.6x) of base price</li> <li>Each topping adds $2.50 to the total price</li> <li>Automatic mapping to/from DTOs using <code>@map_from</code> and <code>@map_to</code> decorators</li> <li>UUID-based entity identification</li> </ul>"},{"location":"mario-pizzeria/domain-design/#order-aggregate-root","title":"Order Aggregate Root","text":"<p>The Order aggregate root manages the complete order lifecycle and business rules using event sourcing with separate state management:</p> <p>\ud83d\udccb View Source Code</p> <pre><code>from neuroglia.data.abstractions import AggregateRoot, AggregateState\nfrom domain.entities.enums import OrderStatus\nfrom domain.entities.order_item import OrderItem\n\nclass OrderState(AggregateState[str]):\n    \"\"\"State for Order aggregate - contains all persisted data\"\"\"\n\n    customer_id: Optional[str]\n    order_items: list[OrderItem]\n    status: OrderStatus\n    order_time: Optional[datetime]\n    confirmed_time: Optional[datetime]\n    cooking_started_time: Optional[datetime]\n    actual_ready_time: Optional[datetime]\n    estimated_ready_time: Optional[datetime]\n    delivery_person_id: Optional[str]\n    out_for_delivery_time: Optional[datetime]\n    notes: Optional[str]\n\n    # User tracking fields\n    chef_user_id: Optional[str]\n    chef_name: Optional[str]\n    ready_by_user_id: Optional[str]\n    ready_by_name: Optional[str]\n    delivery_user_id: Optional[str]\n    delivery_name: Optional[str]\n\n@map_from(OrderDto)\n@map_to(OrderDto)\nclass Order(AggregateRoot[OrderState, str]):\n    \"\"\"Order aggregate root with pizzas and status management\"\"\"\n\n    def __init__(self, customer_id: str, estimated_ready_time: Optional[datetime] = None):\n        super().__init__()\n\n        # Register event and apply it to state\n        self.state.on(\n            self.register_event(\n                OrderCreatedEvent(\n                    aggregate_id=str(uuid4()),\n                    customer_id=customer_id,\n                    order_time=datetime.now(timezone.utc)\n                )\n            )\n        )\n\n        if estimated_ready_time:\n            self.state.estimated_ready_time = estimated_ready_time\n\n    @property\n    def total_amount(self) -&gt; Decimal:\n        \"\"\"Calculate total order amount\"\"\"\n        return sum((item.total_price for item in self.state.order_items), Decimal(\"0.00\"))\n\n    @property\n    def pizza_count(self) -&gt; int:\n        \"\"\"Get total number of pizzas in the order\"\"\"\n        return len(self.state.order_items)\n\n    def add_order_item(self, order_item: OrderItem) -&gt; None:\n        \"\"\"Add an order item (pizza) to the order\"\"\"\n        if self.state.status != OrderStatus.PENDING:\n            raise ValueError(\"Cannot modify confirmed orders\")\n\n        self.state.order_items.append(order_item)\n\n        self.state.on(\n            self.register_event(\n                PizzaAddedToOrderEvent(\n                    aggregate_id=self.id(),\n                    line_item_id=order_item.line_item_id,\n                    pizza_name=order_item.name,\n                    pizza_size=order_item.size.value,\n                    price=order_item.total_price\n                )\n            )\n        )\n\n    def confirm_order(self) -&gt; None:\n        \"\"\"Confirm the order and set status to confirmed\"\"\"\n        if self.state.status != OrderStatus.PENDING:\n            raise ValueError(\"Only pending orders can be confirmed\")\n\n        if not self.state.order_items:\n            raise ValueError(\"Cannot confirm empty order\")\n\n        self.state.on(\n            self.register_event(\n                OrderConfirmedEvent(\n                    aggregate_id=self.id(),\n                    confirmed_time=datetime.now(timezone.utc),\n                    total_amount=self.total_amount,\n                    pizza_count=self.pizza_count\n                )\n            )\n        )\n\n    def start_cooking(self, user_id: str, user_name: str) -&gt; None:\n        \"\"\"Start cooking the order\"\"\"\n        if self.state.status != OrderStatus.CONFIRMED:\n            raise ValueError(\"Only confirmed orders can start cooking\")\n\n        self.state.on(\n            self.register_event(\n                CookingStartedEvent(\n                    aggregate_id=self.id(),\n                    cooking_started_time=datetime.now(timezone.utc),\n                    user_id=user_id,\n                    user_name=user_name\n                )\n            )\n        )\n\n    def mark_ready(self, user_id: str, user_name: str) -&gt; None:\n        \"\"\"Mark order as ready for pickup/delivery\"\"\"\n        if self.state.status != OrderStatus.COOKING:\n            raise ValueError(\"Only cooking orders can be marked ready\")\n\n        self.state.on(\n            self.register_event(\n                OrderReadyEvent(\n                    aggregate_id=self.id(),\n                    ready_time=datetime.now(timezone.utc),\n                    user_id=user_id,\n                    user_name=user_name\n                )\n            )\n        )\n</code></pre> <p>Key Architectural Patterns:</p> <ul> <li>Aggregate Root: Order is the entry point for all order-related operations</li> <li>Separate State: OrderState class holds all persisted data (event sourcing pattern)</li> <li>Event Sourcing: All state changes happen through domain events</li> <li>Business Rules: State transitions validated before raising events</li> <li>User Tracking: Records who performed cooking, ready, and delivery actions</li> </ul>"},{"location":"mario-pizzeria/domain-design/#kitchen-entity","title":"Kitchen Entity","text":"<p>The Kitchen entity manages cooking capacity and workflow coordination:</p> <p>\ud83d\udccb View Source Code</p> <pre><code>from neuroglia.data.abstractions import Entity\n\n@map_from(KitchenStatusDto)\n@map_to(KitchenStatusDto)\nclass Kitchen(Entity[str]):\n    \"\"\"Kitchen state and capacity management\"\"\"\n\n    def __init__(self, max_concurrent_orders: int = 3):\n        super().__init__()\n        self.id = \"kitchen\"  # Singleton kitchen\n        self.active_orders: list[str] = []  # Order IDs currently being prepared\n        self.max_concurrent_orders = max_concurrent_orders\n        self.total_orders_processed = 0\n\n    @property\n    def current_capacity(self) -&gt; int:\n        \"\"\"Get current number of orders being prepared\"\"\"\n        return len(self.active_orders)\n\n    @property\n    def available_capacity(self) -&gt; int:\n        \"\"\"Get remaining capacity for new orders\"\"\"\n        return self.max_concurrent_orders - self.current_capacity\n\n    @property\n    def is_at_capacity(self) -&gt; bool:\n        \"\"\"Check if kitchen is at maximum capacity\"\"\"\n        return self.current_capacity &gt;= self.max_concurrent_orders\n\n    def start_order(self, order_id: str) -&gt; bool:\n        \"\"\"Start cooking an order if capacity allows\"\"\"\n        if self.is_at_capacity:\n            return False\n\n        self.active_orders.append(order_id)\n        return True\n\n    def complete_order(self, order_id: str) -&gt; None:\n        \"\"\"Complete cooking an order and free up capacity\"\"\"\n        if order_id in self.active_orders:\n            self.active_orders.remove(order_id)\n            self.total_orders_processed += 1\n\n    def adjust_capacity(self, new_max: int) -&gt; None:\n        \"\"\"Adjust maximum capacity based on staffing\"\"\"\n        if new_max &lt; len(self.active_orders):\n            raise CapacityError(\"Cannot reduce capacity below current active orders\")\n\n        old_capacity = self.max_concurrent_orders\n        self.max_concurrent_orders = new_max\n\n        # Raise domain event\n        self.raise_event(KitchenCapacityAdjustedEvent(\n            kitchen_id=self.id,\n            old_capacity=old_capacity,\n            new_capacity=new_max\n        ))\n</code></pre>"},{"location":"mario-pizzeria/domain-design/#value-objects","title":"\ud83d\udcca Value Objects","text":""},{"location":"mario-pizzeria/domain-design/#address-value-object","title":"Address Value Object","text":"<pre><code>@dataclass(frozen=True)\nclass Address:\n    \"\"\"Immutable address value object\"\"\"\n    street: str\n    city: str\n    zip_code: str\n    state: str = \"CA\"\n\n    def __str__(self) -&gt; str:\n        return f\"{self.street}, {self.city}, {self.state} {self.zip_code}\"\n\n    def is_valid(self) -&gt; bool:\n        \"\"\"Validate address format\"\"\"\n        return (\n            len(self.street) &gt; 0 and\n            len(self.city) &gt; 0 and\n            len(self.zip_code) == 5 and\n            self.zip_code.isdigit()\n        )\n</code></pre>"},{"location":"mario-pizzeria/domain-design/#money-value-object","title":"Money Value Object","text":"<pre><code>@dataclass(frozen=True)\nclass Money:\n    \"\"\"Immutable money value object\"\"\"\n    amount: Decimal\n    currency: str = \"USD\"\n\n    def __str__(self) -&gt; str:\n        return f\"${self.amount:.2f}\"\n\n    def add(self, other: 'Money') -&gt; 'Money':\n        \"\"\"Add two money amounts\"\"\"\n        if self.currency != other.currency:\n            raise ValueError(\"Cannot add different currencies\")\n        return Money(self.amount + other.amount, self.currency)\n\n    def multiply(self, factor: Decimal) -&gt; 'Money':\n        \"\"\"Multiply money by a factor\"\"\"\n        return Money(self.amount * factor, self.currency)\n\n    def is_positive(self) -&gt; bool:\n        \"\"\"Check if amount is positive\"\"\"\n        return self.amount &gt; 0\n</code></pre>"},{"location":"mario-pizzeria/domain-design/#domain-events","title":"\ud83d\udce1 Domain Events","text":"<p>Domain events capture important business occurrences and enable loose coupling through event-driven architecture:</p> <p>\ud83c\udfaf Why Domain Events?: Events decouple the order placement from kitchen processing and customer notifications. The order handler doesn't need to know about the kitchen or SMS service! Learn more about Event-Driven Architecture.</p> <p>\u26a0\ufe0f Common Mistake Alert: Don't forget to use Unit of Work to automatically collect and dispatch events! See the Unit of Work pattern to avoid manual event management.</p>"},{"location":"mario-pizzeria/domain-design/#order-lifecycle-events","title":"Order Lifecycle Events","text":"<pre><code>@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    \"\"\"Raised when customer places an order\"\"\"\n    order_id: str\n    customer_name: str\n    customer_phone: str\n    total_amount: Decimal\n    estimated_ready_time: datetime\n\n@dataclass\nclass OrderConfirmedEvent(DomainEvent):\n    \"\"\"Raised when order payment is processed\"\"\"\n    order_id: str\n    customer_name: str\n    estimated_ready_time: datetime\n\n@dataclass\nclass CookingStartedEvent(DomainEvent):\n    \"\"\"Raised when kitchen starts cooking order\"\"\"\n    order_id: str\n    started_at: datetime\n    estimated_completion: datetime\n\n@dataclass\nclass OrderReadyEvent(DomainEvent):\n    \"\"\"Raised when order is ready for pickup\"\"\"\n    order_id: str\n    customer_name: str\n    customer_phone: str\n    ready_at: datetime\n</code></pre>"},{"location":"mario-pizzeria/domain-design/#kitchen-events","title":"Kitchen Events","text":"<pre><code>@dataclass\nclass KitchenOrderStartedEvent(DomainEvent):\n    \"\"\"Raised when kitchen starts processing order\"\"\"\n    kitchen_id: str\n    order_id: str\n    remaining_capacity: int\n\n@dataclass\nclass KitchenCapacityAdjustedEvent(DomainEvent):\n    \"\"\"Raised when kitchen capacity changes\"\"\"\n    kitchen_id: str\n    old_capacity: int\n    new_capacity: int\n    reason: str\n</code></pre>"},{"location":"mario-pizzeria/domain-design/#pizza-size-enumeration","title":"Pizza Size Enumeration","text":"<p>The pizza size enumeration defines the available size options with clear business values:</p> <p>Source: <code>samples/mario-pizzeria/domain/entities/enums.py</code></p> samples/mario-pizzeria/domain/entities/enums.py<pre><code>class PizzaSize(Enum):\n    \"\"\"Pizza size options\"\"\"\n\n    SMALL = \"small\"\n    MEDIUM = \"medium\"\n    LARGE = \"large\"\n</code></pre>"},{"location":"mario-pizzeria/domain-design/#order-status-enumeration","title":"Order Status Enumeration","text":"<p>The order status enumeration tracks the complete order lifecycle:</p> samples/mario-pizzeria/domain/entities/enums.py<pre><code>class OrderStatus(Enum):\n    \"\"\"Order lifecycle statuses\"\"\"\n\n    PENDING = \"pending\"\n    CONFIRMED = \"confirmed\"\n    COOKING = \"cooking\"\n    READY = \"ready\"\n    DELIVERED = \"delivered\"\n    CANCELLED = \"cancelled\"\n</code></pre> <p>Status Flow: <code>PENDING</code> \u2192 <code>CONFIRMED</code> \u2192 <code>COOKING</code> \u2192 <code>READY</code> \u2192 <code>DELIVERED</code></p> <p>Alternative flow: Any status \u2192 <code>CANCELLED</code> (with business rules)</p>"},{"location":"mario-pizzeria/domain-design/#business-rules-invariants","title":"\ud83c\udfaf Business Rules &amp; Invariants","text":""},{"location":"mario-pizzeria/domain-design/#order-rules","title":"Order Rules","text":"<ul> <li>Orders must have at least one pizza</li> <li>Total amount must be positive</li> <li>Status transitions must follow: pending \u2192 confirmed \u2192 cooking \u2192 ready \u2192 delivered</li> <li>Orders cannot be cancelled once cooking starts</li> </ul>"},{"location":"mario-pizzeria/domain-design/#kitchen-rules","title":"Kitchen Rules","text":"<ul> <li>Maximum concurrent orders based on staff capacity</li> <li>Orders processed in first-in-first-out order</li> <li>Capacity adjustments cannot go below current active orders</li> </ul>"},{"location":"mario-pizzeria/domain-design/#pizza-rules","title":"Pizza Rules","text":"<ul> <li>Maximum 10 toppings per pizza</li> <li>All toppings must be from approved list</li> <li>Pricing must include all applicable taxes and fees</li> </ul>"},{"location":"mario-pizzeria/domain-design/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":""},{"location":"mario-pizzeria/domain-design/#case-study-documents","title":"Case Study Documents","text":"<ul> <li>Business Analysis - Requirements and stakeholder analysis</li> <li>Technical Architecture - System design and infrastructure</li> <li>Implementation Guide - Development patterns and APIs</li> <li>Testing &amp; Deployment - Quality assurance and operations</li> </ul>"},{"location":"mario-pizzeria/domain-design/#framework-patterns-demonstrated","title":"Framework Patterns Demonstrated","text":"<ul> <li>Domain-Driven Design - Rich domain models with business logic</li> <li>Event-Driven Architecture - Domain events for workflow automation</li> <li>Repository Pattern - Data access abstraction for entities</li> <li>Unit of Work - Automatic domain event collection and dispatching</li> <li>Clean Architecture - Domain layer independence</li> </ul> <p>\ud83d\udca1 Learning Tip: See how Mario's Pizzeria domain entities avoid the anemic domain model anti-pattern by keeping business logic where it belongs - in the domain!</p> <p>This domain model provides a solid foundation for implementing Mario's Pizzeria using Domain-Driven Design principles, ensuring the code reflects the actual business operations.</p>"},{"location":"mario-pizzeria/implementation-guide/","title":"\ud83d\ude80 Mario's Pizzeria: Implementation Guide","text":"<p>Development Guide | Patterns: CQRS, Event Sourcing, OAuth 2.0 Framework: Neuroglia + FastAPI | Status: Production Examples</p> <p>\ud83d\udccb Source Code: View Complete Implementation</p> <p>\ud83d\udca1 Pattern in Action: This guide demonstrates CQRS, Dependency Injection, Pipeline Behaviors, and Event-Driven Architecture working together in production code.</p>"},{"location":"mario-pizzeria/implementation-guide/#implementation-overview","title":"\ud83c\udfaf Implementation Overview","text":"<p>This guide provides comprehensive implementation details for building Mario's Pizzeria using the Neuroglia framework. It covers CQRS patterns, event-driven workflows, authentication, and practical code examples ready for production use.</p> <p>Key Implementation Patterns:</p> <ul> <li>CQRS Commands &amp; Queries: Separate read and write operations</li> <li>Event-Driven Architecture: Asynchronous business workflow processing</li> <li>Dependency Injection: Service lifetimes and constructor injection</li> <li>Pipeline Behaviors: Validation, logging, error handling</li> <li>OAuth 2.0 Security: Role-based access control with JWT tokens</li> <li>Data Transfer Objects: Clean API contracts and validation</li> </ul> <p>\u26a0\ufe0f Common Mistake Alert: Don't mix commands and queries! Commands modify state and return results. Queries read data without side effects. See CQRS Common Mistakes for details.</p>"},{"location":"mario-pizzeria/implementation-guide/#cqrs-commands-and-queries","title":"\ud83c\udfaf CQRS Commands and Queries","text":"<p>The system uses CQRS pattern with clear separation between write and read operations:</p> <p>\ud83d\udccb Commands Source: application/commands/</p> <p>\ud83d\udccb Queries Source: application/queries/</p> <p>\ud83c\udfaf Why CQRS?: Commands handle write operations (like placing an order) with validation and business logic. Queries handle read operations optimized for display. This separation enables independent scaling and optimization. Learn more: CQRS Pattern.</p>"},{"location":"mario-pizzeria/implementation-guide/#commands-write-operations","title":"Commands (Write Operations)","text":"<p>\ud83d\udccb PlaceOrderCommand Source</p> <pre><code>from neuroglia.mediation import Command, CommandHandler\nfrom neuroglia.core import OperationResult\nfrom api.dtos import CreateOrderDto, OrderDto, CreatePizzaDto\n\n@dataclass\n@map_from(CreateOrderDto)\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Command to place a new pizza order\"\"\"\n\n    customer_name: str\n    customer_phone: str\n    customer_address: Optional[str] = None\n    customer_email: Optional[str] = None\n    pizzas: list[CreatePizzaDto] = field(default_factory=list)\n    payment_method: str = \"cash\"\n    notes: Optional[str] = None\n    customer_id: Optional[str] = None  # Optional - will be created/retrieved\n\n@dataclass\nclass StartCookingCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Command to start cooking an order\"\"\"\n    order_id: str\n    user_id: str  # Chef who is starting cooking\n    user_name: str  # Chef's name\n\n@dataclass\nclass CompleteOrderCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Command to mark order as ready\"\"\"\n    order_id: str\n    user_id: str  # Who marked order ready\n    user_name: str  # User's name\n</code></pre> <p>\ud83d\udccb More Commands: start_cooking_command.py, complete_order_command.py, assign_order_to_delivery_command.py</p>"},{"location":"mario-pizzeria/implementation-guide/#queries-read-operations","title":"Queries (Read Operations)","text":"<p>Queries retrieve data without side effects:</p> <p>\ud83d\udccb GetActiveOrdersQuery Source</p> <pre><code>from neuroglia.mediation import Query, QueryHandler\nfrom neuroglia.core import OperationResult\n\n@dataclass\nclass GetActiveOrdersQuery(Query[OperationResult[List[OrderDto]]]):\n    \"\"\"Query to get all active orders (not delivered or cancelled)\"\"\"\n    pass\n\n@dataclass\nclass GetOrdersByCustomerQuery(Query[OperationResult[List[OrderDto]]]):\n    \"\"\"Query to get customer's order history\"\"\"\n    customer_id: str\n    limit: int = 10\n</code></pre> <p>\ud83d\udccb More Queries: get_ready_orders_query.py, get_orders_by_customer_query.py, get_customer_profile_query.py</p>"},{"location":"mario-pizzeria/implementation-guide/#command-handlers","title":"Command Handlers","text":"<p>Command handlers implement business logic and coordinate with domain entities using Dependency Injection:</p> <p>\ud83c\udfaf Why Constructor Injection?: Dependencies like repositories and services are injected through the constructor, making testing easier and dependencies explicit. See Dependency Injection pattern.</p> <p>\u26a0\ufe0f Avoid Fat Constructors: Don't inject too many dependencies! If a handler needs many services, it might be doing too much. See DI Common Mistakes.</p> <pre><code>class PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    \"\"\"Handler for placing new orders\"\"\"\n\n    def __init__(self,\n                 order_repository: OrderRepository,\n                 payment_service: PaymentService,\n                 kitchen_repository: KitchenRepository,\n                 mapper: Mapper):\n        self.order_repository = order_repository\n        self.payment_service = payment_service\n        self.kitchen_repository = kitchen_repository\n        self.mapper = mapper\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        try:\n            # Validate command\n            validation_errors = command.validate()\n            if validation_errors:\n                return self.bad_request(\"; \".join(validation_errors))\n\n            # Check kitchen capacity\n            kitchen = await self.kitchen_repository.get_default_kitchen()\n            if kitchen.is_at_capacity:\n                return self.bad_request(\"Kitchen is at capacity. Please try again later.\")\n\n            # Create order entity (rich domain model with behavior!)\n            order = Order(\n                id=str(uuid.uuid4()),\n                customer_name=command.customer_name,\n                customer_phone=command.customer_phone,\n                pizzas=self.mapper.map_list(command.pizzas, Pizza),\n                status=\"pending\",\n                order_time=datetime.utcnow()\n            )\n\n            # Process payment\n            payment_result = await self.payment_service.process_payment_async(\n                amount=order.total_amount,\n                payment_method=command.payment_method\n            )\n\n            if not payment_result.success:\n                return self.bad_request(f\"Payment failed: {payment_result.error_message}\")\n\n            # Confirm order (domain method enforces business rules)\n            order.confirm_order()\n\n            # Save order (repository abstracts persistence)\n            await self.order_repository.save_async(order)\n\n            # Unit of Work automatically dispatches domain events here!\n            # See: https://github.com/.../patterns/unit-of-work.md\n\n            # Return success result\n            order_dto = self.mapper.map(order, OrderDto)\n            return self.created(order_dto)\n\n        except Exception as ex:\n            return self.internal_server_error(f\"Failed to place order: {str(ex)}\")\n</code></pre> <p>\ud83d\udca1 Pattern Highlights in This Handler:</p> <ul> <li>\u2705 Dependency Injection - Constructor injection of repositories and services</li> <li>\u2705 Repository Pattern - <code>order_repository.save_async()</code> abstracts storage</li> <li>\u2705 Domain-Driven Design - <code>order.confirm_order()</code> enforces business rules</li> <li>\u2705 Unit of Work - Automatic domain event collection and dispatching</li> <li>\u2705 CQRS - Command handler returns OperationResult, not void</li> </ul>"},{"location":"mario-pizzeria/implementation-guide/#event-driven-workflow","title":"\ud83d\udce1 Event-Driven Workflow","text":"<p>The system uses domain events to handle complex business workflows with loose coupling:</p> <p>\ud83c\udfaf Why Events?: When an order is placed, the kitchen needs to be notified, customers need SMS alerts, and analytics need updating. Events decouple these concerns! Learn more: Event-Driven Architecture.</p> <pre><code>flowchart TD\n    A[Customer Places Order] --&gt; B[OrderPlacedEvent]\n    B --&gt; C[Kitchen Queue Updated]\n    B --&gt; D[Payment Processed]\n\n    C --&gt; E[Staff Views Kitchen Queue]\n    E --&gt; F[Staff Starts Cooking]\n    F --&gt; G[OrderCookingEvent]\n\n    G --&gt; H[Update Order Status]\n    G --&gt; I[Start Preparation Timer]\n\n    I --&gt; J[Order Completed]\n    J --&gt; K[OrderReadyEvent]\n\n    K --&gt; L[SMS Notification Sent]\n    K --&gt; M[Kitchen Capacity Freed]\n\n    L --&gt; N[Customer Notified]\n    M --&gt; O[Next Order Can Start]\n\n    style A fill:#FFE0B2\n    style B fill:#E1F5FE\n    style G fill:#E1F5FE\n    style K fill:#E1F5FE\n    style N fill:#C8E6C9</code></pre>"},{"location":"mario-pizzeria/implementation-guide/#event-handlers","title":"Event Handlers","text":"<p>Event handlers process domain events asynchronously using event-driven architecture:</p> <p>\ud83d\udca1 Loose Coupling: Event handlers don't know about command handlers! The kitchen handler reacts to OrderPlacedEvent without the order placement code knowing about kitchens. See Event-Driven Benefits.</p> <pre><code>class OrderPlacedEventHandler(EventHandler[OrderPlacedEvent]):\n    \"\"\"Handle order placed events\"\"\"\n\n    def __init__(self,\n                 kitchen_service: KitchenService,\n                 notification_service: NotificationService):\n        self.kitchen_service = kitchen_service\n        self.notification_service = notification_service\n\n    async def handle_async(self, event: OrderPlacedEvent) -&gt; None:\n        # Add order to kitchen queue\n        await self.kitchen_service.add_to_queue_async(event.order_id)\n\n        # Send confirmation to customer\n        await self.notification_service.send_order_confirmation_async(\n            phone=event.customer_phone,\n            order_id=event.order_id,\n            estimated_ready_time=event.estimated_ready_time\n        )\n\nclass OrderReadyEventHandler(EventHandler[OrderReadyEvent]):\n    \"\"\"Handle order ready events\"\"\"\n\n    def __init__(self,\n                 sms_service: SMSService,\n                 kitchen_repository: KitchenRepository):\n        self.sms_service = sms_service\n        self.kitchen_repository = kitchen_repository\n\n    async def handle_async(self, event: OrderReadyEvent) -&gt; None:\n        # Send SMS notification\n        message = f\"Hi {event.customer_name}! Your order #{event.order_id} is ready for pickup!\"\n        await self.sms_service.send_sms_async(event.customer_phone, message)\n\n        # Free up kitchen capacity\n        kitchen = await self.kitchen_repository.get_default_kitchen()\n        kitchen.complete_order(event.order_id)\n        await self.kitchen_repository.save_async(kitchen)\n</code></pre>"},{"location":"mario-pizzeria/implementation-guide/#key-domain-events","title":"Key Domain Events","text":"<pre><code>@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    \"\"\"Raised when customer places an order\"\"\"\n    order_id: str\n    customer_name: str\n    customer_phone: str\n    total_amount: Decimal\n    estimated_ready_time: datetime\n\n@dataclass\nclass OrderConfirmedEvent(DomainEvent):\n    \"\"\"Raised when payment is processed successfully\"\"\"\n    order_id: str\n    customer_name: str\n    estimated_ready_time: datetime\n    payment_method: str\n\n@dataclass\nclass CookingStartedEvent(DomainEvent):\n    \"\"\"Raised when kitchen starts cooking\"\"\"\n    order_id: str\n    started_at: datetime\n    kitchen_staff_id: str\n\n@dataclass\nclass OrderReadyEvent(DomainEvent):\n    \"\"\"Raised when order is ready for pickup\"\"\"\n    order_id: str\n    customer_name: str\n    customer_phone: str\n    ready_at: datetime\n\n@dataclass\nclass OrderDeliveredEvent(DomainEvent):\n    \"\"\"Raised when order is picked up or delivered\"\"\"\n    order_id: str\n    delivered_at: datetime\n    delivery_method: str  # \"pickup\" or \"delivery\"\n</code></pre>"},{"location":"mario-pizzeria/implementation-guide/#data-transfer-objects-dtos","title":"\ud83d\udccb Data Transfer Objects (DTOs)","text":"<p>DTOs provide clean API contracts with validation:</p>"},{"location":"mario-pizzeria/implementation-guide/#request-dtos","title":"Request DTOs","text":"<pre><code>@dataclass\nclass CreateOrderDto:\n    \"\"\"DTO for creating new orders\"\"\"\n    customer_name: str\n    customer_phone: str\n    pizzas: List[PizzaOrderItem]\n    delivery_address: Optional[AddressDto] = None\n    special_instructions: Optional[str] = None\n    payment_method: str = \"credit_card\"\n\n    def __post_init__(self):\n        if not self.customer_name.strip():\n            raise ValueError(\"Customer name is required\")\n        if not self.pizzas:\n            raise ValueError(\"At least one pizza is required\")\n\n@dataclass\nclass PizzaOrderItem:\n    \"\"\"DTO for pizza items in orders\"\"\"\n    pizza_id: str\n    size: str  # \"small\", \"medium\", \"large\"\n    toppings: List[str] = field(default_factory=list)\n    quantity: int = 1\n\n    def __post_init__(self):\n        if self.quantity &lt; 1:\n            raise ValueError(\"Quantity must be at least 1\")\n        if len(self.toppings) &gt; 10:\n            raise ValueError(\"Maximum 10 toppings per pizza\")\n</code></pre>"},{"location":"mario-pizzeria/implementation-guide/#response-dtos","title":"Response DTOs","text":"<pre><code>@dataclass\nclass OrderDto:\n    \"\"\"DTO for order responses\"\"\"\n    id: str\n    customer_name: str\n    customer_phone: str\n    pizzas: List[PizzaDto]\n    status: str\n    total_amount: str  # Formatted money\n    order_time: str   # ISO datetime\n    estimated_ready_time: Optional[str] = None\n    special_instructions: Optional[str] = None\n\n@dataclass\nclass PizzaDto:\n    \"\"\"DTO for pizza responses\"\"\"\n    id: str\n    name: str\n    size: str\n    toppings: List[str]\n    price: str  # Formatted money\n    estimated_cooking_time: int\n\n@dataclass\nclass KitchenStatusDto:\n    \"\"\"DTO for kitchen status\"\"\"\n    current_capacity: int\n    max_concurrent_orders: int\n    active_orders: List[OrderSummaryDto]\n    is_at_capacity: bool\n    average_cooking_time: int\n\n@dataclass\nclass OrderAnalyticsDto:\n    \"\"\"DTO for business analytics\"\"\"\n    total_orders: int\n    total_revenue: str\n    average_order_value: str\n    popular_pizzas: List[PizzaPopularityDto]\n    peak_hours: List[HourlyStatsDto]\n</code></pre>"},{"location":"mario-pizzeria/implementation-guide/#authentication-authorization","title":"\ud83d\udd10 Authentication &amp; Authorization","text":"<p>Mario's Pizzeria demonstrates secure authentication using OAuth 2.0, OpenID Connect, and JWT tokens:</p>"},{"location":"mario-pizzeria/implementation-guide/#oauth-scopes","title":"OAuth Scopes","text":"<pre><code>SCOPES = {\n    \"orders:read\": \"Read order information\",\n    \"orders:write\": \"Create and modify orders\",\n    \"kitchen:read\": \"View kitchen status\",\n    \"kitchen:manage\": \"Manage kitchen operations\",\n    \"menu:read\": \"View menu items\",\n    \"menu:write\": \"Modify menu items\",\n    \"reports:read\": \"View business reports\",\n    \"admin\": \"Full administrative access\"\n}\n</code></pre>"},{"location":"mario-pizzeria/implementation-guide/#controller-security","title":"Controller Security","text":"<pre><code>from neuroglia.mvc import ControllerBase\nfrom fastapi import Depends, HTTPException\nfrom neuroglia.security import require_scope\n\nclass OrdersController(ControllerBase):\n\n    @get(\"/\", response_model=List[OrderDto])\n    @require_scope(\"orders:read\")\n    async def get_orders(self,\n                        current_user: dict = Depends(get_current_user),\n                        status: Optional[str] = None) -&gt; List[OrderDto]:\n        \"\"\"Get orders - requires orders:read scope\"\"\"\n\n        # Customer can only see their own orders\n        if \"customer\" in current_user.get(\"roles\", []):\n            query = GetOrdersByCustomerQuery(\n                customer_phone=current_user.get(\"phone\"),\n                status_filter=status\n            )\n        else:\n            # Staff can see all orders\n            query = GetAllOrdersQuery(status_filter=status)\n\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @post(\"/\", response_model=OrderDto, status_code=201)\n    @require_scope(\"orders:write\")\n    async def create_order(self,\n                          create_order_dto: CreateOrderDto,\n                          current_user: dict = Depends(get_current_user)) -&gt; OrderDto:\n        \"\"\"Create new order - requires orders:write scope\"\"\"\n\n        command = self.mapper.map(create_order_dto, PlaceOrderCommand)\n\n        # Add user context\n        command.customer_phone = current_user.get(\"phone\", command.customer_phone)\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"mario-pizzeria/implementation-guide/#user-roles-permissions","title":"User Roles &amp; Permissions","text":"Role Scopes Permissions \ud83d\udc64 Customer <code>orders:read</code>, <code>orders:write</code>, <code>menu:read</code> Place orders, view own orders, browse menu \ud83d\udc68\u200d\ud83c\udf73 Kitchen Staff <code>kitchen:read</code>, <code>kitchen:manage</code>, <code>orders:read</code> Manage cooking queue, view all orders \ud83d\udc68\u200d\ud83d\udcbc Manager All kitchen scopes + <code>menu:write</code>, <code>reports:read</code> Full operational control \ud83d\udd27 Admin <code>admin</code> Complete system access"},{"location":"mario-pizzeria/implementation-guide/#complete-authentication-guide","title":"\ud83d\udcd6 Complete Authentication Guide","text":"<p>For comprehensive OAuth 2.0, OpenID Connect, and JWT implementation details:</p> <p>\ud83d\udc49 Read the Complete OAuth/OIDC/JWT Reference</p> <p>This includes:</p> <ul> <li>\ud83c\udfaf OAuth 2.0 Flow Diagrams</li> <li>\ud83d\udd0d JWT Validation Process</li> <li>\ud83c\udfd7\ufe0f Keycloak Integration</li> <li>\ud83c\udfad Role-Based Access Control</li> <li>\ud83e\uddea Authentication Testing</li> <li>\ud83d\udccb Security Best Practices</li> </ul>"},{"location":"mario-pizzeria/implementation-guide/#api-integration-examples","title":"\ud83c\udfa8 API Integration Examples","text":""},{"location":"mario-pizzeria/implementation-guide/#javascript-client","title":"JavaScript Client","text":"<pre><code>class PizzeriaClient {\n  constructor(baseUrl, accessToken) {\n    this.baseUrl = baseUrl;\n    this.accessToken = accessToken;\n  }\n\n  async placeOrder(orderData) {\n    const response = await fetch(`${this.baseUrl}/orders`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${this.accessToken}`,\n      },\n      body: JSON.stringify(orderData),\n    });\n\n    if (!response.ok) {\n      throw new Error(`Order failed: ${response.statusText}`);\n    }\n\n    return await response.json();\n  }\n\n  async getOrderStatus(orderId) {\n    const response = await fetch(`${this.baseUrl}/orders/${orderId}`, {\n      headers: {\n        Authorization: `Bearer ${this.accessToken}`,\n      },\n    });\n\n    return await response.json();\n  }\n}\n</code></pre>"},{"location":"mario-pizzeria/implementation-guide/#python-client","title":"Python Client","text":"<pre><code>import httpx\nfrom typing import Dict, List, Optional\n\nclass PizzeriaClient:\n    def __init__(self, base_url: str, access_token: str):\n        self.base_url = base_url\n        self.headers = {\"Authorization\": f\"Bearer {access_token}\"}\n\n    async def place_order(self, order_data: Dict) -&gt; Dict:\n        async with httpx.AsyncClient() as client:\n            response = await client.post(\n                f\"{self.base_url}/orders\",\n                json=order_data,\n                headers=self.headers\n            )\n            response.raise_for_status()\n            return response.json()\n\n    async def get_menu(self) -&gt; List[Dict]:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                f\"{self.base_url}/menu/pizzas\",\n                headers=self.headers\n            )\n            return response.json()\n</code></pre>"},{"location":"mario-pizzeria/implementation-guide/#implementation-benefits","title":"\ud83d\ude80 Implementation Benefits","text":"<p>The implementation patterns demonstrated in Mario's Pizzeria provide significant advantages:</p> <ul> <li>\ud83c\udfaf Clean Separation: CQRS provides clear read/write boundaries enabling independent scaling</li> <li>\u26a1 Event-Driven: Event-Driven Architecture enables loose coupling and scalable async processing</li> <li>\ud83d\udc89 Dependency Injection: DI Pattern makes testing easy with mockable dependencies</li> <li>\ud83d\udd27 Cross-Cutting Concerns: Pipeline Behaviors centralize validation and logging</li> <li>\ud83d\udd12 Secure: OAuth 2.0 with fine-grained role-based access control</li> <li>\ud83d\udccb Type-Safe: Strong typing with DTOs, rich domain models, and validation</li> <li>\ud83e\uddea Testable: Repository Pattern enables easy test data setup</li> <li>\ud83d\udcca Observable: Built-in logging, metrics, and monitoring capabilities</li> <li>\ud83d\udd04 Maintainable: Framework patterns ensure consistency and reduce cognitive load</li> </ul> <p>\ud83d\udca1 Real-World Impact: By following these patterns, Mario's Pizzeria achieved 40% more order capacity, 60% faster processing, and zero security incidents. See Business Analysis for full metrics.</p>"},{"location":"mario-pizzeria/implementation-guide/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":""},{"location":"mario-pizzeria/implementation-guide/#case-study-documents","title":"Case Study Documents","text":"<ul> <li>Business Analysis - Requirements and stakeholder analysis</li> <li>Technical Architecture - System design and infrastructure</li> <li>Domain Design - Business logic and data models</li> <li>Testing &amp; Deployment - Quality assurance and operations</li> </ul>"},{"location":"mario-pizzeria/implementation-guide/#framework-patterns-demonstrated","title":"Framework Patterns Demonstrated","text":"<ul> <li>CQRS &amp; Mediation - Commands, queries, and handlers throughout</li> <li>Dependency Injection - Constructor injection in all handlers</li> <li>Event-Driven Architecture - Domain events for workflow automation</li> <li>Pipeline Behaviors - Validation, logging, error handling</li> <li>Repository Pattern - Data access abstraction</li> <li>Unit of Work - Automatic event collection and dispatching</li> <li>Domain-Driven Design - Rich domain models with business logic</li> </ul> <p>\ud83d\udca1 Learning Tip: Each pattern page includes \"Common Mistakes\" sections with anti-patterns discovered while building Mario's Pizzeria. Learn from real implementation challenges!</p> <p>This implementation guide provides production-ready patterns for building scalable, secure, and maintainable applications using the Neuroglia framework.</p>"},{"location":"mario-pizzeria/technical-architecture/","title":"\ud83c\udfd7\ufe0f Mario's Pizzeria: Technical Architecture","text":"<p>System Design Document &gt; Architecture: Clean Architecture + CQRS + Event Sourcing Technology Stack: FastAPI, Python, MongoDB, OAuth 2.0 Status: Production Ready</p> <p>\ud83d\udccb Source Code: View Complete Implementation</p> <p>\ud83d\udca1 Pattern in Action: This document demonstrates Clean Architecture layer separation with the Repository Pattern for data access abstraction and Event-Driven Architecture for scalability.</p>"},{"location":"mario-pizzeria/technical-architecture/#architecture-overview","title":"\ud83d\udccb Architecture Overview","text":"<p>Mario's Pizzeria implements a modern, scalable architecture following clean architecture principles with CQRS (Command Query Responsibility Segregation) and event-driven patterns. This design ensures maintainability, testability, and scalability for a growing restaurant business.</p> <p>Key Architectural Decisions:</p> <ul> <li>Clean Architecture: Clear separation of concerns across four distinct layers</li> <li>CQRS Pattern: Separate models for read and write operations</li> <li>Event-Driven Design: Asynchronous processing and loose coupling</li> <li>Repository Pattern: Abstracted data access with multiple storage options</li> <li>Dependency Injection: Testable and maintainable service management</li> </ul> <p>\u26a0\ufe0f Architecture Principle: Dependencies point INWARD only (API \u2192 Application \u2192 Domain \u2190 Integration). The domain layer has ZERO dependencies on outer layers! See Clean Architecture for why this matters.</p>"},{"location":"mario-pizzeria/technical-architecture/#clean-architecture-layers","title":"\ud83c\udfdb\ufe0f Clean Architecture Layers","text":"<p>Mario's Pizzeria demonstrates the four-layer clean architecture:</p> <pre><code>graph TB\n    %% API Layer\n    subgraph APILayer[\"\ud83c\udf10 API Layer\"]\n        OrdersController[\"\ud83d\udccb OrdersController&lt;br/&gt;FastAPI&lt;br/&gt;Order management endpoints\"]\n        MenuController[\"\ud83c\udf55 MenuController&lt;br/&gt;FastAPI&lt;br/&gt;Menu browsing endpoints\"]\n        KitchenController[\"\ud83d\udc68\u200d\ud83c\udf73 KitchenController&lt;br/&gt;FastAPI&lt;br/&gt;Kitchen status endpoints\"]\n        DTOs[\"\ud83d\udcc4 DTOs&lt;br/&gt;Pydantic&lt;br/&gt;Request/Response models\"]\n    end\n\n    %% Application Layer\n    subgraph AppLayer[\"\ud83d\udcbc Application Layer\"]\n        Mediator[\"\ud83c\udfaf Mediator&lt;br/&gt;CQRS&lt;br/&gt;Command/Query dispatcher\"]\n        PlaceOrderHandler[\"\ud83d\udcdd PlaceOrderHandler&lt;br/&gt;Command Handler&lt;br/&gt;Order placement logic\"]\n        GetMenuHandler[\"\ud83d\udcd6 GetMenuHandler&lt;br/&gt;Query Handler&lt;br/&gt;Menu retrieval logic\"]\n        KitchenHandlers[\"\u26a1 KitchenHandlers&lt;br/&gt;Event Handlers&lt;br/&gt;Kitchen workflow\"]\n    end\n\n    %% Domain Layer\n    subgraph DomainLayer[\"\ud83c\udfdb\ufe0f Domain Layer\"]\n        OrderEntity[\"\ud83d\udccb Order&lt;br/&gt;AggregateRoot&lt;br/&gt;Order business logic\"]\n        PizzaEntity[\"\ud83c\udf55 Pizza&lt;br/&gt;AggregateRoot&lt;br/&gt;Pizza with pricing\"]\n        CustomerEntity[\"\ud83d\udc64 Customer&lt;br/&gt;AggregateRoot&lt;br/&gt;Customer information\"]\n        KitchenEntity[\"\ud83c\udfe0 Kitchen&lt;br/&gt;Entity&lt;br/&gt;Kitchen capacity\"]\n        DomainEvents[\"\u26a1 Domain Events&lt;br/&gt;Events&lt;br/&gt;OrderPlaced, OrderReady\"]\n    end\n\n    %% Integration Layer\n    subgraph IntegrationLayer[\"\ud83d\udd0c Integration Layer\"]\n        OrderRepo[\"\ud83d\udcbe OrderRepository&lt;br/&gt;File/Mongo&lt;br/&gt;Order persistence\"]\n        PaymentService[\"\ud83d\udcb3 PaymentService&lt;br/&gt;External API&lt;br/&gt;Payment processing\"]\n        SMSService[\"\ud83d\udcf1 SMSService&lt;br/&gt;External API&lt;br/&gt;Customer notifications\"]\n    end\n\n    %% API to Application connections\n    OrdersController --&gt;|Sends commands/queries| Mediator\n    MenuController --&gt;|Sends queries| Mediator\n    KitchenController --&gt;|Sends queries| Mediator\n\n    %% Application Layer connections\n    Mediator --&gt;|Routes PlaceOrderCommand| PlaceOrderHandler\n    Mediator --&gt;|Routes GetMenuQuery| GetMenuHandler\n    Mediator --&gt;|Routes events| KitchenHandlers\n\n    %% Application to Domain connections\n    PlaceOrderHandler --&gt;|Creates/manipulates| OrderEntity\n    GetMenuHandler --&gt;|Reads menu data| PizzaEntity\n\n    %% Application to Integration connections\n    PlaceOrderHandler --&gt;|Persists orders| OrderRepo\n    PlaceOrderHandler --&gt;|Processes payments| PaymentService\n    KitchenHandlers --&gt;|Sends notifications| SMSService\n\n    %% Styling\n    classDef apiLayer fill:#E3F2FD,stroke:#1976D2,stroke-width:2px\n    classDef appLayer fill:#F3E5F5,stroke:#7B1FA2,stroke-width:2px\n    classDef domainLayer fill:#E8F5E8,stroke:#388E3C,stroke-width:2px\n    classDef integrationLayer fill:#FFF3E0,stroke:#F57C00,stroke-width:2px\n\n    class OrdersController,MenuController,KitchenController,DTOs apiLayer\n    class Mediator,PlaceOrderHandler,GetMenuHandler,KitchenHandlers appLayer\n    class OrderEntity,PizzaEntity,CustomerEntity,KitchenEntity,DomainEvents domainLayer\n    class OrderRepo,PaymentService,SMSService integrationLayer</code></pre>"},{"location":"mario-pizzeria/technical-architecture/#data-storage-strategy","title":"\ud83d\uddc4\ufe0f Data Storage Strategy","text":"<p>Mario's Pizzeria demonstrates multiple persistence approaches to support different deployment scenarios:</p>"},{"location":"mario-pizzeria/technical-architecture/#file-based-storage-development","title":"File-Based Storage (Development)","text":"<p>Perfect for development and testing environments with simple JSON persistence:</p> <pre><code>pizzeria_data/\n\u251c\u2500\u2500 orders/\n\u2502   \u251c\u2500\u2500 2024-09-22/           # Orders by date\n\u2502   \u2502   \u251c\u2500\u2500 order_001.json\n\u2502   \u2502   \u251c\u2500\u2500 order_002.json\n\u2502   \u2502   \u2514\u2500\u2500 order_003.json\n\u2502   \u2514\u2500\u2500 index.json            # Order index\n\u251c\u2500\u2500 menu/\n\u2502   \u2514\u2500\u2500 pizzas.json           # Available pizzas\n\u251c\u2500\u2500 kitchen/\n\u2502   \u2514\u2500\u2500 status.json           # Kitchen state\n\u2514\u2500\u2500 customers/\n    \u2514\u2500\u2500 customers.json        # Customer history\n</code></pre> <p>Benefits: Zero configuration, version control friendly, fast local development</p>"},{"location":"mario-pizzeria/technical-architecture/#mongodb-storage-production","title":"MongoDB Storage (Production)","text":"<p>Scalable document database for production workloads:</p> <pre><code>// Orders Collection\n{\n  \"_id\": \"order_001\",\n  \"customer_name\": \"Mario Rossi\",\n  \"customer_phone\": \"+1-555-0123\",\n  \"pizzas\": [\n    {\n      \"name\": \"Margherita\",\n      \"size\": \"large\",\n      \"toppings\": [\"extra cheese\"],\n      \"price\": 15.99\n    }\n  ],\n  \"total_amount\": 15.99,\n  \"status\": \"ready\",\n  \"order_time\": \"2025-09-25T10:30:00Z\"\n}\n</code></pre> <p>Benefits: Horizontal scaling, rich queries, built-in replication, ACID transactions</p>"},{"location":"mario-pizzeria/technical-architecture/#event-sourcing-advanced","title":"Event Sourcing (Advanced)","text":"<p>Complete audit trail and temporal queries using event streams:</p> <pre><code>Event Store:\n\u251c\u2500\u2500 order_001_stream\n\u2502   \u251c\u2500\u2500 OrderPlacedEvent\n\u2502   \u251c\u2500\u2500 PaymentProcessedEvent\n\u2502   \u251c\u2500\u2500 OrderConfirmedEvent\n\u2502   \u251c\u2500\u2500 CookingStartedEvent\n\u2502   \u2514\u2500\u2500 OrderReadyEvent\n</code></pre> <p>Benefits: Complete audit trail, temporal queries, replay capability, debugging</p>"},{"location":"mario-pizzeria/technical-architecture/#api-endpoints","title":"\ud83c\udf10 API Endpoints","text":"<p>Complete RESTful API designed for different client types (web, mobile, POS systems):</p>"},{"location":"mario-pizzeria/technical-architecture/#order-management","title":"Order Management","text":"Method Endpoint Description Auth Required <code>POST</code> <code>/orders</code> Place new pizza order Customer <code>GET</code> <code>/orders</code> List orders (with status filter) Staff <code>GET</code> <code>/orders/{id}</code> Get specific order details Owner/Customer <code>PUT</code> <code>/orders/{id}/status</code> Update order status Kitchen <code>DELETE</code> <code>/orders/{id}</code> Cancel order Customer/Manager"},{"location":"mario-pizzeria/technical-architecture/#menu-operations","title":"Menu Operations","text":"Method Endpoint Description Auth Required <code>GET</code> <code>/menu/pizzas</code> Get available pizzas Public <code>GET</code> <code>/menu/pizzas/{id}</code> Get pizza details Public <code>GET</code> <code>/menu/toppings</code> Get available toppings Public"},{"location":"mario-pizzeria/technical-architecture/#kitchen-management","title":"Kitchen Management","text":"Method Endpoint Description Auth Required <code>GET</code> <code>/kitchen/status</code> Get kitchen capacity status Staff <code>GET</code> <code>/kitchen/queue</code> Get current cooking queue Kitchen <code>POST</code> <code>/kitchen/orders/{id}/start</code> Start cooking order Kitchen <code>POST</code> <code>/kitchen/orders/{id}/complete</code> Complete order Kitchen"},{"location":"mario-pizzeria/technical-architecture/#security-architecture","title":"\ud83d\udd10 Security Architecture","text":""},{"location":"mario-pizzeria/technical-architecture/#oauth-20-scopes","title":"OAuth 2.0 Scopes","text":"<p>Fine-grained access control using OAuth2 scopes:</p> <pre><code>SCOPES = {\n    \"orders:read\": \"Read order information\",\n    \"orders:write\": \"Create and modify orders\",\n    \"kitchen:read\": \"View kitchen status\",\n    \"kitchen:manage\": \"Manage kitchen operations\",\n    \"menu:read\": \"View menu items\",\n    \"admin\": \"Full administrative access\"\n}\n</code></pre>"},{"location":"mario-pizzeria/technical-architecture/#role-based-access-control","title":"Role-Based Access Control","text":"Role Scopes Permissions Customer <code>orders:write</code>, <code>menu:read</code> Place orders, view menu Kitchen Staff <code>kitchen:manage</code>, <code>orders:read</code> Manage cooking queue Manager <code>admin</code> Full system access Public <code>menu:read</code> Browse menu only"},{"location":"mario-pizzeria/technical-architecture/#scalability-considerations","title":"\ud83d\ude80 Scalability Considerations","text":""},{"location":"mario-pizzeria/technical-architecture/#horizontal-scaling","title":"Horizontal Scaling","text":"<ul> <li>API Layer: Stateless controllers scale horizontally behind load balancer (see Clean Architecture)</li> <li>Application Layer: Event handlers can be distributed across multiple instances (see Event-Driven Architecture)</li> <li>Database Layer: MongoDB supports sharding and replica sets (see Repository Pattern)</li> <li>External Services: Circuit breakers prevent cascade failures</li> </ul> <p>\ud83d\udca1 Event-Driven Scalability: Kitchen event handlers can run on separate servers from order handlers, scaling independently based on load! Learn more: Event-Driven Architecture Benefits.</p>"},{"location":"mario-pizzeria/technical-architecture/#performance-optimizations","title":"Performance Optimizations","text":"<ul> <li>Caching: Redis for frequently accessed menu items and customer data</li> <li>Background Processing: Event-driven async handling for notifications and reporting</li> <li>Database Indexing: Optimized queries for order status and customer lookups</li> <li>CDN: Static assets (images, CSS) served from edge locations</li> <li>Read Models: Separate CQRS read models optimized for queries</li> </ul>"},{"location":"mario-pizzeria/technical-architecture/#monitoring-observability","title":"Monitoring &amp; Observability","text":"<ul> <li>Health Checks: Endpoint monitoring for all critical services</li> <li>Metrics: Custom business metrics (orders/hour, kitchen efficiency)</li> <li>Logging: Structured logging with correlation IDs using Pipeline Behaviors</li> <li>Tracing: Distributed tracing for request flows</li> </ul> <p>\ud83d\udca1 Cross-Cutting Concerns: Logging, metrics, and tracing are implemented as Pipeline Behaviors that automatically wrap all command and query handlers!</p>"},{"location":"mario-pizzeria/technical-architecture/#infrastructure-requirements","title":"\ud83d\udd27 Infrastructure Requirements","text":""},{"location":"mario-pizzeria/technical-architecture/#development-environment","title":"Development Environment","text":"<ul> <li>Python: 3.9+ with FastAPI and Neuroglia framework</li> <li>Storage: Local JSON files for rapid development (see Repository Pattern)</li> <li>Authentication: Development OAuth server (Keycloak)</li> </ul>"},{"location":"mario-pizzeria/technical-architecture/#production-environment","title":"Production Environment","text":"<ul> <li>Compute: 2+ CPU cores, 4GB RAM minimum per instance</li> <li>Database: MongoDB cluster with replica sets</li> <li>Caching: Redis cluster for session and menu caching</li> <li>Load Balancer: NGINX or cloud load balancer</li> <li>Authentication: Production OAuth provider (Auth0, Keycloak)</li> </ul>"},{"location":"mario-pizzeria/technical-architecture/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":""},{"location":"mario-pizzeria/technical-architecture/#case-study-documents","title":"Case Study Documents","text":"<ul> <li>Business Analysis - Requirements and stakeholder analysis</li> <li>Domain Design - Business logic and data models</li> <li>Implementation Guide - Development patterns and APIs</li> <li>Testing &amp; Deployment - Quality assurance and operations</li> </ul>"},{"location":"mario-pizzeria/technical-architecture/#framework-patterns-used","title":"Framework Patterns Used","text":"<ul> <li>Clean Architecture - Four-layer separation with dependency rules</li> <li>CQRS Pattern - Separate read and write models for scalability</li> <li>Event-Driven Architecture - Async workflows and loose coupling</li> <li>Repository Pattern - Multiple storage implementations (File, MongoDB)</li> <li>Dependency Injection - Service lifetimes and testability</li> <li>Pipeline Behaviors - Logging, validation, error handling</li> </ul> <p>\ud83d\udca1 Architecture Learning: See how Mario's Pizzeria avoids common clean architecture mistakes like mixing layers and breaking dependency rules!</p> <p>This technical architecture provides a scalable, maintainable foundation for Mario's Pizzeria using proven patterns from the Neuroglia framework.</p> <ul> <li>Testing &amp; Deployment - Quality assurance and operations</li> </ul> <p>This technical architecture ensures Mario's Pizzeria can scale from a single location to a multi-restaurant franchise while maintaining code quality and operational excellence.</p>"},{"location":"mario-pizzeria/testing-deployment/","title":"\ud83e\uddea Mario's Pizzeria: Testing &amp; Deployment","text":"<p>Quality Assurance Guide | Testing Strategy: Unit, Integration, E2E Deployment: Docker, CI/CD, Production Monitoring | Status: Production Ready</p> <p>\ud83d\udcc2 View Tests on GitHub</p> <p>\ud83d\udca1 Pattern in Action: This document demonstrates how Repository Pattern, Dependency Injection, and Unit of Work make testing easier with clean mocking strategies.</p>"},{"location":"mario-pizzeria/testing-deployment/#testing-overview","title":"\ud83c\udfaf Testing Overview","text":"<p>Mario's Pizzeria demonstrates comprehensive testing strategies across all application layers. The testing approach leverages Dependency Injection for easy mocking and Repository Pattern for test data setup.</p> <p>Testing Pyramid:</p> <ul> <li>Unit Tests (70%): Fast, isolated tests for business logic with mocked dependencies</li> <li>Integration Tests (20%): API endpoints and data access layer testing</li> <li>End-to-End Tests (10%): Complete workflow validation</li> </ul> <p>\ud83c\udfaf Why Dependency Injection Helps Testing: Constructor injection makes it trivial to replace real repositories with mocks! See DI Benefits.</p>"},{"location":"mario-pizzeria/testing-deployment/#unit-testing-strategy","title":"\ud83e\uddea Unit Testing Strategy","text":"<p>Unit tests focus on individual components in isolation with comprehensive mocking:</p>"},{"location":"mario-pizzeria/testing-deployment/#domain-entity-testing","title":"Domain Entity Testing","text":"<pre><code>import pytest\nfrom decimal import Decimal\nfrom datetime import datetime\nfrom mario_pizzeria.domain.entities import Order, Pizza, Kitchen\nfrom mario_pizzeria.domain.enums import OrderStatus, PizzaSize\n\nclass TestOrderEntity:\n    \"\"\"Test Order domain entity business logic\"\"\"\n\n    def test_order_creation_with_defaults(self):\n        \"\"\"Test order creation with default values\"\"\"\n        order = Order(\n            id=\"order_001\",\n            customer_name=\"Mario Rossi\",\n            customer_phone=\"+1-555-0123\",\n            pizzas=[],\n            status=\"pending\",\n            order_time=datetime.utcnow()\n        )\n\n        assert order.id == \"order_001\"\n        assert order.status == \"pending\"\n        assert order.total_amount == Decimal('0.00')\n        assert len(order.pizzas) == 0\n\n    def test_add_pizza_to_order(self):\n        \"\"\"Test adding pizza updates total amount\"\"\"\n        order = Order(\n            id=\"order_001\",\n            customer_name=\"Mario Rossi\",\n            customer_phone=\"+1-555-0123\",\n            pizzas=[],\n            status=\"pending\",\n            order_time=datetime.utcnow()\n        )\n\n        pizza = Pizza(\n            id=\"pizza_001\",\n            name=\"Margherita\",\n            size=\"large\",\n            base_price=Decimal('15.99'),\n            toppings=[\"extra cheese\"],\n            preparation_time_minutes=15\n        )\n\n        order.add_pizza(pizza)\n\n        assert len(order.pizzas) == 1\n        assert order.total_amount == Decimal('17.49')  # 15.99 + 1.50 topping\n\n    def test_order_status_transitions(self):\n        \"\"\"Test valid order status transitions\"\"\"\n        order = Order(\n            id=\"order_001\",\n            customer_name=\"Mario Rossi\",\n            customer_phone=\"+1-555-0123\",\n            pizzas=[self._create_test_pizza()],\n            status=\"pending\",\n            order_time=datetime.utcnow()\n        )\n\n        # Test valid transitions\n        order.confirm_order()\n        assert order.status == \"confirmed\"\n\n        order.start_cooking()\n        assert order.status == \"cooking\"\n\n        order.mark_ready()\n        assert order.status == \"ready\"\n\n    def test_invalid_status_transitions_raise_error(self):\n        \"\"\"Test invalid status transitions raise domain errors\"\"\"\n        order = Order(\n            id=\"order_001\",\n            customer_name=\"Mario Rossi\",\n            customer_phone=\"+1-555-0123\",\n            pizzas=[self._create_test_pizza()],\n            status=\"pending\",\n            order_time=datetime.utcnow()\n        )\n\n        # Cannot start cooking before confirming\n        with pytest.raises(InvalidOrderStateError):\n            order.start_cooking()\n\n    def _create_test_pizza(self) -&gt; Pizza:\n        return Pizza(\n            id=\"pizza_001\",\n            name=\"Margherita\",\n            size=\"large\",\n            base_price=Decimal('15.99'),\n            toppings=[],\n            preparation_time_minutes=15\n        )\n\nclass TestKitchenEntity:\n    \"\"\"Test Kitchen domain entity capacity management\"\"\"\n\n    def test_kitchen_capacity_management(self):\n        \"\"\"Test kitchen capacity tracking\"\"\"\n        kitchen = Kitchen(\n            id=\"kitchen_001\",\n            active_orders=[],\n            max_concurrent_orders=3\n        )\n\n        assert kitchen.current_capacity == 0\n        assert kitchen.available_capacity == 3\n        assert not kitchen.is_at_capacity\n\n        # Add orders to capacity\n        assert kitchen.start_order(\"order_001\") == True\n        assert kitchen.start_order(\"order_002\") == True\n        assert kitchen.start_order(\"order_003\") == True\n\n        assert kitchen.current_capacity == 3\n        assert kitchen.available_capacity == 0\n        assert kitchen.is_at_capacity\n\n        # Cannot add more orders when at capacity\n        assert kitchen.start_order(\"order_004\") == False\n\n    def test_kitchen_order_completion(self):\n        \"\"\"Test completing orders frees capacity\"\"\"\n        kitchen = Kitchen(\n            id=\"kitchen_001\",\n            active_orders=[\"order_001\", \"order_002\"],\n            max_concurrent_orders=3\n        )\n\n        kitchen.complete_order(\"order_001\")\n\n        assert kitchen.current_capacity == 1\n        assert kitchen.available_capacity == 2\n        assert not kitchen.is_at_capacity\n</code></pre>"},{"location":"mario-pizzeria/testing-deployment/#command-handler-testing","title":"Command Handler Testing","text":"<pre><code>from unittest.mock import Mock, AsyncMock\nimport pytest\nfrom mario_pizzeria.application.handlers import PlaceOrderHandler\nfrom mario_pizzeria.application.commands import PlaceOrderCommand\n\nclass TestPlaceOrderHandler:\n    \"\"\"Test PlaceOrderHandler business logic\"\"\"\n\n    def setup_method(self):\n        # Mock all dependencies\n        self.order_repository = Mock()\n        self.payment_service = Mock()\n        self.kitchen_repository = Mock()\n        self.mapper = Mock()\n\n        self.handler = PlaceOrderHandler(\n            self.order_repository,\n            self.payment_service,\n            self.kitchen_repository,\n            self.mapper\n        )\n\n    @pytest.mark.asyncio\n    async def test_place_order_success_scenario(self):\n        \"\"\"Test successful order placement\"\"\"\n        # Arrange\n        command = PlaceOrderCommand(\n            customer_name=\"Mario Rossi\",\n            customer_phone=\"+1-555-0123\",\n            customer_address=\"123 Main St\",\n            pizzas=[self._create_test_pizza_dto()],\n            payment_method=\"credit_card\"\n        )\n\n        # Mock successful payment\n        self.payment_service.process_payment_async = AsyncMock(\n            return_value=PaymentResult(success=True, transaction_id=\"txn_123\")\n        )\n\n        # Mock kitchen availability\n        mock_kitchen = Mock()\n        mock_kitchen.is_at_capacity = False\n        self.kitchen_repository.get_default_kitchen = AsyncMock(return_value=mock_kitchen)\n\n        # Mock repository save\n        self.order_repository.save_async = AsyncMock()\n\n        # Act\n        result = await self.handler.handle_async(command)\n\n        # Assert\n        assert result.is_success\n        assert result.status_code == 201\n        self.order_repository.save_async.assert_called_once()\n        self.payment_service.process_payment_async.assert_called_once()\n\n    @pytest.mark.asyncio\n    async def test_place_order_kitchen_at_capacity(self):\n        \"\"\"Test order rejection when kitchen is at capacity\"\"\"\n        # Arrange\n        command = PlaceOrderCommand(\n            customer_name=\"Mario Rossi\",\n            customer_phone=\"+1-555-0123\",\n            customer_address=\"123 Main St\",\n            pizzas=[self._create_test_pizza_dto()],\n            payment_method=\"credit_card\"\n        )\n\n        # Mock kitchen at capacity\n        mock_kitchen = Mock()\n        mock_kitchen.is_at_capacity = True\n        self.kitchen_repository.get_default_kitchen = AsyncMock(return_value=mock_kitchen)\n\n        # Act\n        result = await self.handler.handle_async(command)\n\n        # Assert\n        assert not result.is_success\n        assert result.status_code == 400\n        assert \"capacity\" in result.error_message.lower()\n\n        # Ensure payment was not processed\n        self.payment_service.process_payment_async.assert_not_called()\n\n    @pytest.mark.asyncio\n    async def test_place_order_payment_failure(self):\n        \"\"\"Test order failure when payment fails\"\"\"\n        # Arrange\n        command = PlaceOrderCommand(\n            customer_name=\"Mario Rossi\",\n            customer_phone=\"+1-555-0123\",\n            customer_address=\"123 Main St\",\n            pizzas=[self._create_test_pizza_dto()],\n            payment_method=\"credit_card\"\n        )\n\n        # Mock kitchen availability\n        mock_kitchen = Mock()\n        mock_kitchen.is_at_capacity = False\n        self.kitchen_repository.get_default_kitchen = AsyncMock(return_value=mock_kitchen)\n\n        # Mock payment failure\n        self.payment_service.process_payment_async = AsyncMock(\n            return_value=PaymentResult(success=False, error_message=\"Card declined\")\n        )\n\n        # Act\n        result = await self.handler.handle_async(command)\n\n        # Assert\n        assert not result.is_success\n        assert result.status_code == 400\n        assert \"payment failed\" in result.error_message.lower()\n\n        # Ensure order was not saved\n        self.order_repository.save_async.assert_not_called()\n</code></pre>"},{"location":"mario-pizzeria/testing-deployment/#integration-testing","title":"\ud83d\udd27 Integration Testing","text":"<p>Integration tests validate API endpoints and database interactions:</p>"},{"location":"mario-pizzeria/testing-deployment/#controller-integration-tests","title":"Controller Integration Tests","text":"<pre><code>import pytest\nfrom httpx import AsyncClient\nfrom mario_pizzeria.main import create_app\n\nclass TestOrdersController:\n    \"\"\"Integration tests for Orders API\"\"\"\n\n    @pytest.fixture\n    def test_app(self):\n        \"\"\"Create test application with in-memory database\"\"\"\n        app = create_app()\n        app.configure_test_environment()\n        return app\n\n    @pytest.fixture\n    async def test_client(self, test_app):\n        \"\"\"Create test client\"\"\"\n        async with AsyncClient(app=test_app, base_url=\"http://test\") as client:\n            yield client\n\n    @pytest.mark.integration\n    async def test_place_order_success(self, test_client):\n        \"\"\"Test successful order placement via API\"\"\"\n        order_data = {\n            \"customer_name\": \"Mario Rossi\",\n            \"customer_phone\": \"+1-555-0123\",\n            \"customer_address\": \"123 Main St\",\n            \"pizzas\": [\n                {\n                    \"pizza_id\": \"margherita\",\n                    \"size\": \"large\",\n                    \"toppings\": [\"extra cheese\"],\n                    \"quantity\": 1\n                }\n            ],\n            \"payment_method\": \"credit_card\"\n        }\n\n        response = await test_client.post(\"/orders\", json=order_data)\n\n        assert response.status_code == 201\n        data = response.json()\n\n        assert data[\"customer_name\"] == \"Mario Rossi\"\n        assert data[\"status\"] == \"confirmed\"\n        assert len(data[\"pizzas\"]) == 1\n        assert \"id\" in data\n        assert \"estimated_ready_time\" in data\n\n    @pytest.mark.integration\n    async def test_place_order_validation_error(self, test_client):\n        \"\"\"Test order placement with invalid data\"\"\"\n        invalid_order_data = {\n            \"customer_name\": \"\",  # Invalid: empty name\n            \"customer_phone\": \"+1-555-0123\",\n            \"pizzas\": []  # Invalid: no pizzas\n        }\n\n        response = await test_client.post(\"/orders\", json=invalid_order_data)\n\n        assert response.status_code == 400\n        error_data = response.json()\n        assert \"validation\" in error_data[\"error\"].lower()\n\n    @pytest.mark.integration\n    async def test_get_order_by_id(self, test_client):\n        \"\"\"Test retrieving order by ID\"\"\"\n        # First create an order\n        order_data = self._create_test_order_data()\n        create_response = await test_client.post(\"/orders\", json=order_data)\n        order_id = create_response.json()[\"id\"]\n\n        # Then retrieve it\n        get_response = await test_client.get(f\"/orders/{order_id}\")\n\n        assert get_response.status_code == 200\n        data = get_response.json()\n        assert data[\"id\"] == order_id\n        assert data[\"customer_name\"] == order_data[\"customer_name\"]\n\n    @pytest.mark.integration\n    async def test_get_kitchen_status(self, test_client):\n        \"\"\"Test kitchen status endpoint\"\"\"\n        response = await test_client.get(\"/kitchen/status\")\n\n        assert response.status_code == 200\n        data = response.json()\n\n        assert \"current_capacity\" in data\n        assert \"max_concurrent_orders\" in data\n        assert \"active_orders\" in data\n        assert \"is_at_capacity\" in data\n        assert isinstance(data[\"current_capacity\"], int)\n\n    @pytest.mark.integration\n    async def test_start_cooking_order(self, test_client):\n        \"\"\"Test starting cooking process\"\"\"\n        # Create order first\n        order_data = self._create_test_order_data()\n        create_response = await test_client.post(\"/orders\", json=order_data)\n        order_id = create_response.json()[\"id\"]\n\n        # Start cooking\n        cook_response = await test_client.post(\n            f\"/kitchen/orders/{order_id}/start\",\n            json={\"kitchen_staff_id\": \"staff_001\"}\n        )\n\n        assert cook_response.status_code == 200\n\n        # Verify order status changed\n        status_response = await test_client.get(f\"/orders/{order_id}\")\n        assert status_response.json()[\"status\"] == \"cooking\"\n\n    def _create_test_order_data(self):\n        return {\n            \"customer_name\": \"Test Customer\",\n            \"customer_phone\": \"+1-555-0123\",\n            \"customer_address\": \"123 Test St\",\n            \"pizzas\": [\n                {\n                    \"pizza_id\": \"margherita\",\n                    \"size\": \"medium\",\n                    \"toppings\": [],\n                    \"quantity\": 1\n                }\n            ],\n            \"payment_method\": \"credit_card\"\n        }\n</code></pre>"},{"location":"mario-pizzeria/testing-deployment/#repository-integration-tests","title":"Repository Integration Tests","text":"<pre><code>@pytest.mark.integration\nclass TestOrderRepository:\n    \"\"\"Integration tests for order data access\"\"\"\n\n    @pytest.fixture\n    async def repository(self, mongo_client):\n        \"\"\"Create repository with test database\"\"\"\n        return OrderRepository(mongo_client.test_db.orders)\n\n    @pytest.mark.asyncio\n    async def test_save_and_retrieve_order(self, repository):\n        \"\"\"Test complete CRUD operations\"\"\"\n        # Create test order\n        order = Order(\n            id=\"test_order_001\",\n            customer_name=\"Test Customer\",\n            customer_phone=\"+1-555-0123\",\n            pizzas=[self._create_test_pizza()],\n            status=\"pending\",\n            order_time=datetime.utcnow()\n        )\n\n        # Save order\n        await repository.save_async(order)\n\n        # Retrieve order\n        retrieved = await repository.get_by_id_async(\"test_order_001\")\n\n        assert retrieved is not None\n        assert retrieved.id == order.id\n        assert retrieved.customer_name == order.customer_name\n        assert retrieved.status == order.status\n        assert len(retrieved.pizzas) == len(order.pizzas)\n\n    @pytest.mark.asyncio\n    async def test_get_orders_by_status(self, repository):\n        \"\"\"Test filtering orders by status\"\"\"\n        # Create orders with different statuses\n        orders = [\n            self._create_test_order(\"order_001\", \"pending\"),\n            self._create_test_order(\"order_002\", \"cooking\"),\n            self._create_test_order(\"order_003\", \"ready\")\n        ]\n\n        for order in orders:\n            await repository.save_async(order)\n\n        # Get cooking orders\n        cooking_orders = await repository.get_by_status_async(\"cooking\")\n\n        assert len(cooking_orders) == 1\n        assert cooking_orders[0].status == \"cooking\"\n</code></pre>"},{"location":"mario-pizzeria/testing-deployment/#end-to-end-testing","title":"\ud83c\udf10 End-to-End Testing","text":"<p>End-to-end tests validate complete business workflows:</p> <pre><code>@pytest.mark.e2e\nclass TestPizzeriaWorkflow:\n    \"\"\"End-to-end workflow tests\"\"\"\n\n    @pytest.fixture\n    async def test_system(self):\n        \"\"\"Set up complete test system\"\"\"\n        app = create_app()\n        app.configure_test_environment()\n\n        # Start background services\n        await app.start_background_services()\n\n        async with AsyncClient(app=app, base_url=\"http://test\") as client:\n            yield client\n\n        await app.stop_background_services()\n\n    @pytest.mark.asyncio\n    async def test_complete_order_workflow(self, test_system):\n        \"\"\"Test complete order-to-delivery workflow\"\"\"\n        client = test_system\n\n        # Step 1: Customer browses menu\n        menu_response = await client.get(\"/menu/pizzas\")\n        assert menu_response.status_code == 200\n        pizzas = menu_response.json()\n        assert len(pizzas) &gt; 0\n\n        # Step 2: Customer places order\n        order_data = {\n            \"customer_name\": \"Integration Test Customer\",\n            \"customer_phone\": \"+1-555-9999\",\n            \"customer_address\": \"123 Test Ave\",\n            \"pizzas\": [\n                {\n                    \"pizza_id\": pizzas[0][\"id\"],\n                    \"size\": \"large\",\n                    \"toppings\": [\"pepperoni\", \"mushrooms\"],\n                    \"quantity\": 2\n                }\n            ],\n            \"payment_method\": \"credit_card\"\n        }\n\n        order_response = await client.post(\"/orders\", json=order_data)\n        assert order_response.status_code == 201\n        order = order_response.json()\n        order_id = order[\"id\"]\n\n        # Verify order is confirmed\n        assert order[\"status\"] == \"confirmed\"\n        assert order[\"customer_name\"] == \"Integration Test Customer\"\n\n        # Step 3: Kitchen views order queue\n        queue_response = await client.get(\"/kitchen/queue\")\n        assert queue_response.status_code == 200\n        queue = queue_response.json()\n\n        # Find our order in queue\n        order_in_queue = next((o for o in queue if o[\"id\"] == order_id), None)\n        assert order_in_queue is not None\n\n        # Step 4: Kitchen starts cooking\n        start_response = await client.post(\n            f\"/kitchen/orders/{order_id}/start\",\n            json={\"kitchen_staff_id\": \"test_staff\"}\n        )\n        assert start_response.status_code == 200\n\n        # Verify status changed to cooking\n        status_response = await client.get(f\"/orders/{order_id}\")\n        cooking_order = status_response.json()\n        assert cooking_order[\"status\"] == \"cooking\"\n\n        # Step 5: Kitchen completes order\n        complete_response = await client.post(\n            f\"/kitchen/orders/{order_id}/complete\"\n        )\n        assert complete_response.status_code == 200\n\n        # Step 6: Verify final status\n        final_response = await client.get(f\"/orders/{order_id}\")\n        final_order = final_response.json()\n        assert final_order[\"status\"] == \"ready\"\n\n        # Step 7: Verify kitchen capacity is freed\n        final_status = await client.get(\"/kitchen/status\")\n        kitchen_status = final_status.json()\n\n        # Kitchen should have capacity again\n        assert not kitchen_status[\"is_at_capacity\"]\n\n    @pytest.mark.asyncio\n    async def test_concurrent_order_processing(self, test_system):\n        \"\"\"Test system handles concurrent orders correctly\"\"\"\n        client = test_system\n\n        # Place multiple concurrent orders\n        order_tasks = []\n        for i in range(5):\n            order_data = self._create_concurrent_order_data(i)\n            task = client.post(\"/orders\", json=order_data)\n            order_tasks.append(task)\n\n        # Wait for all orders to complete\n        responses = await asyncio.gather(*order_tasks)\n\n        # Verify all orders were processed\n        successful_orders = 0\n        capacity_rejections = 0\n\n        for response in responses:\n            if response.status_code == 201:\n                successful_orders += 1\n            elif response.status_code == 400:\n                error_data = response.json()\n                if \"capacity\" in error_data.get(\"error\", \"\").lower():\n                    capacity_rejections += 1\n\n        # Should have processed some orders and rejected others due to capacity\n        assert successful_orders &gt; 0\n        assert successful_orders + capacity_rejections == 5\n</code></pre>"},{"location":"mario-pizzeria/testing-deployment/#deployment-operations","title":"\ud83d\ude80 Deployment &amp; Operations","text":""},{"location":"mario-pizzeria/testing-deployment/#docker-configuration","title":"Docker Configuration","text":"<pre><code># Dockerfile\nFROM python:3.11-slim\n\nWORKDIR /app\n\n# Install system dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    gcc \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Install Python dependencies\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Copy application code\nCOPY src/ ./src/\nCOPY tests/ ./tests/\n\n# Run tests during build\nRUN python -m pytest tests/ -v\n\n# Expose port\nEXPOSE 8000\n\n# Run application\nCMD [\"uvicorn\", \"src.mario_pizzeria.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n</code></pre>"},{"location":"mario-pizzeria/testing-deployment/#cicd-pipeline","title":"CI/CD Pipeline","text":"<pre><code># .github/workflows/ci-cd.yml\nname: Mario's Pizzeria CI/CD\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    services:\n      mongodb:\n        image: mongo:6\n        ports:\n          - 27017:27017\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: \"3.11\"\n\n      - name: Install dependencies\n        run: |\n          pip install -r requirements.txt\n          pip install -r requirements-test.txt\n\n      - name: Run unit tests\n        run: pytest tests/unit/ -v --cov=src/mario_pizzeria\n\n      - name: Run integration tests\n        run: pytest tests/integration/ -v -m integration\n\n      - name: Run E2E tests\n        run: pytest tests/e2e/ -v -m e2e\n\n      - name: Check test coverage\n        run: |\n          coverage report --fail-under=90\n          coverage xml\n\n      - name: Upload coverage to Codecov\n        uses: codecov/codecov-action@v3\n        with:\n          file: ./coverage.xml\n\n  deploy:\n    needs: test\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Build Docker image\n        run: docker build -t mario-pizzeria:${{ github.sha }} .\n\n      - name: Deploy to staging\n        run: |\n          # Deploy to staging environment\n          echo \"Deploying to staging...\"\n\n      - name: Run smoke tests\n        run: |\n          # Run basic smoke tests against staging\n          pytest tests/smoke/ -v\n</code></pre>"},{"location":"mario-pizzeria/testing-deployment/#production-monitoring","title":"Production Monitoring","text":"<pre><code># monitoring.py\nfrom prometheus_client import Counter, Histogram, generate_latest\nfrom fastapi import Request\nimport time\n\n# Metrics\nREQUEST_COUNT = Counter('pizzeria_requests_total', 'Total requests', ['method', 'endpoint'])\nREQUEST_DURATION = Histogram('pizzeria_request_duration_seconds', 'Request duration')\nORDER_COUNT = Counter('pizzeria_orders_total', 'Total orders', ['status'])\nKITCHEN_CAPACITY = Histogram('pizzeria_kitchen_capacity', 'Kitchen capacity usage')\n\nclass MetricsMiddleware:\n    def __init__(self, app):\n        self.app = app\n\n    async def __call__(self, scope, receive, send):\n        if scope[\"type\"] == \"http\":\n            request = Request(scope, receive)\n            start_time = time.time()\n\n            # Process request\n            response = await self.app(scope, receive, send)\n\n            # Record metrics\n            duration = time.time() - start_time\n            REQUEST_COUNT.labels(\n                method=request.method,\n                endpoint=request.url.path\n            ).inc()\n            REQUEST_DURATION.observe(duration)\n\n            return response\n\n        return await self.app(scope, receive, send)\n\n@app.get(\"/metrics\")\nasync def metrics():\n    \"\"\"Prometheus metrics endpoint\"\"\"\n    return Response(generate_latest(), media_type=\"text/plain\")\n</code></pre>"},{"location":"mario-pizzeria/testing-deployment/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":""},{"location":"mario-pizzeria/testing-deployment/#case-study-documents","title":"Case Study Documents","text":"<ul> <li>Business Analysis - Requirements and stakeholder analysis</li> <li>Technical Architecture - System design and infrastructure</li> <li>Domain Design - Business logic and data models</li> <li>Implementation Guide - Development patterns and APIs</li> </ul>"},{"location":"mario-pizzeria/testing-deployment/#framework-patterns-for-testing","title":"Framework Patterns for Testing","text":"<ul> <li>Dependency Injection - Constructor injection enables easy mocking</li> <li>Repository Pattern - InMemoryRepository for test data setup</li> <li>Unit of Work - Testing domain event collection and dispatching</li> <li>CQRS Pattern - Testing commands and queries separately</li> <li>Pipeline Behaviors - Testing validation and logging behaviors</li> </ul> <p>\ud83d\udca1 Testing Lesson: Mario's Pizzeria testing demonstrates why avoiding Service Locator anti-pattern makes testing so much easier with constructor injection!</p> <p>This comprehensive testing and deployment guide ensures Mario's Pizzeria maintains high quality and reliability from development through production.</p>"},{"location":"old/architecture/","title":"\ud83c\udfd7\ufe0f Architecture Guide","text":"<p>\u26a0\ufe0f Deprecated</p> <p>This page is deprecated and will be removed in a future version. The content has been migrated to more focused sections:</p> <ul> <li>Clean Architecture Pattern - Four-layer separation and dependency rules</li> <li>CQRS Pattern - Command Query Responsibility Segregation</li> <li>Event-Driven Pattern - Domain events and messaging</li> <li>Mario's Pizzeria - Complete bounded context example</li> <li>Features - Framework-specific implementation details</li> </ul> <p>Please use the new structure for the most up-to-date documentation.</p> <p>Neuroglia's clean architecture is demonstrated through Mario's Pizzeria, showing how layered architecture promotes separation of concerns, testability, and maintainability in a real-world application.</p>"},{"location":"old/architecture/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>Clean Architecture Layers: How Mario's Pizzeria separates concerns across API, Application, Domain, and Integration layers</li> <li>Dependency Flow: How pizza order workflow demonstrates the dependency rule in practice</li> <li>CQRS Implementation: How command and query separation works in kitchen operations</li> <li>Event-Driven Design: How domain events coordinate between pizza preparation and customer notifications</li> <li>Testing Strategy: How architecture enables comprehensive testing at every layer</li> </ul>"},{"location":"old/architecture/#marios-pizzeria-architecture","title":"\ud83c\udf55 Mario's Pizzeria Architecture","text":""},{"location":"old/architecture/#overview-from-order-to-pizza","title":"Overview: From Order to Pizza","text":"<p>Mario's Pizzeria demonstrates clean architecture through the complete pizza ordering and preparation workflow:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            \ud83c\udf10 API Layer (Controllers)           \u2502  \u2190 Customer &amp; Staff Interface\n\u2502   OrdersController \u2502 MenuController \u2502 Kitchen   \u2502\n\u2502   Authentication   \u2502 Error Handling \u2502 Swagger   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 orchestrates\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502       \ud83d\udcbc Application Layer (CQRS + Events)      \u2502  \u2190 Business Workflow\n\u2502  PlaceOrderCommand \u2502 GetMenuQuery \u2502 Handlers    \u2502\n\u2502  OrderPlacedEvent  \u2502 Kitchen Workflow Pipeline  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 uses\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         \ud83c\udfdb\ufe0f Domain Layer (Business Logic)        \u2502  \u2190 Pizza Business Rules\n\u2502    Order Entity    \u2502    Pizza Entity           \u2502\n\u2502  Kitchen Workflow  \u2502  Pricing Rules            \u2502\n\u2502   Domain Events    \u2502  Business Validation      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 implements\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502      \ud83d\udd0c Integration Layer (External Systems)    \u2502  \u2190 Data &amp; External APIs\n\u2502  Order Repository  \u2502  Payment Gateway          \u2502\n\u2502   File Storage     \u2502  MongoDB \u2502 Event Store    \u2502\n\u2502  SMS Notifications \u2502  Email Service            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"old/architecture/#the-dependency-rule-in-action","title":"The Dependency Rule in Action","text":"<p>Pizza order flow demonstrates how dependencies always point inward:</p> <ol> <li>API Layer \u2192 Application Layer: Controller calls <code>PlaceOrderCommand</code></li> <li>Application Layer \u2192 Domain Layer: Handler uses <code>Order</code> entity business logic</li> <li>Integration Layer \u2192 Domain Layer: Repository implements domain <code>IOrderRepository</code> interface</li> <li>Never: Domain layer doesn't know about API controllers or database implementation</li> </ol>"},{"location":"old/architecture/#layer-details-with-pizza-examples","title":"\ud83c\udfe2 Layer Details with Pizza Examples","text":""},{"location":"old/architecture/#api-layer-customer-staff-interface","title":"\ud83d\udce1 API Layer: Customer &amp; Staff Interface","text":"<p>Purpose: External interface for Mario's Pizzeria operations</p> <p>Responsibilities:</p> <ul> <li>HTTP endpoints for orders, menu, kitchen operations</li> <li>Customer and staff authentication (OAuth 2.0)</li> <li>Request validation and error handling</li> <li>OpenAPI documentation generation</li> </ul> <p>Key Components:</p> <pre><code># src/api/controllers/orders_controller.py\nclass OrdersController(ControllerBase):\n    \"\"\"Handle customer pizza orders\"\"\"\n\n    @post(\"/\", response_model=OrderDto, status_code=201)\n    async def place_order(self, order_request: PlaceOrderDto) -&gt; OrderDto:\n        \"\"\"Place new pizza order\"\"\"\n        command = PlaceOrderCommand(\n            customer_name=order_request.customer_name,\n            customer_phone=order_request.customer_phone,\n            pizzas=order_request.pizzas,\n            payment_method=order_request.payment_method\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)  # Framework handles success/error response\n\n# src/api/dtos/order_dto.py\nclass PlaceOrderDto(BaseModel):\n    \"\"\"Request DTO for placing pizza orders\"\"\"\n    customer_name: str = Field(..., min_length=2, max_length=100)\n    customer_phone: str = Field(..., regex=r\"^\\+?1?[2-9]\\d{9}$\")\n    customer_address: str = Field(..., min_length=10, max_length=200)\n    pizzas: List[PizzaOrderDto] = Field(..., min_items=1, max_items=20)\n    payment_method: str = Field(..., regex=\"^(cash|card|online)$\")\n</code></pre> <p>Architecture Benefits:</p> <ul> <li>Framework Independence: Pure business logic with no external dependencies</li> </ul>"},{"location":"old/architecture/#integration-layer-external-systems","title":"\ud83d\udd0c Integration Layer: External Systems","text":"<p>Purpose: Handles external system interactions and data persistence</p> <p>Responsibilities:</p> <ul> <li>Data persistence (file storage, MongoDB, event store)</li> <li>External API integration (payment, notifications)</li> <li>Infrastructure concerns (caching, logging)</li> <li>Implements domain interfaces</li> </ul> <p>Integration Components:</p> <pre><code># src/integration/repositories/file_order_repository.py\nclass FileOrderRepository(IOrderRepository):\n    \"\"\"File-based order repository for development\"\"\"\n\n    def __init__(self, orders_directory: str = \"data/orders\"):\n        self.orders_directory = Path(orders_directory)\n        self.orders_directory.mkdir(parents=True, exist_ok=True)\n\n    async def save_async(self, order: Order) -&gt; Order:\n        \"\"\"Save order to JSON file\"\"\"\n        order_file = self.orders_directory / f\"{order.id}.json\"\n\n        order_data = {\n            \"id\": order.id,\n            \"customer_name\": order.customer_name,\n            \"customer_phone\": order.customer_phone,\n            \"customer_address\": order.customer_address,\n            \"pizzas\": [self._pizza_to_dict(pizza) for pizza in order.pizzas],\n            \"status\": order.status.value,\n            \"order_time\": order.order_time.isoformat(),\n            \"total_amount\": float(order.total_amount)\n        }\n\n        async with aiofiles.open(order_file, 'w') as f:\n            await f.write(json.dumps(order_data, indent=2))\n\n        return order\n\n# src/integration/services/payment_service.py\nclass StripePaymentService(IPaymentService):\n    \"\"\"Payment processing using Stripe API\"\"\"\n\n    async def process_payment_async(self,\n                                    amount: Decimal,\n                                    payment_method: str) -&gt; PaymentResult:\n        \"\"\"Process payment through Stripe\"\"\"\n        try:\n            import stripe\n            stripe.api_key = os.getenv(\"STRIPE_SECRET_KEY\")\n\n            # Create payment intent\n            intent = stripe.PaymentIntent.create(\n                amount=int(amount * 100),  # Convert to cents\n                currency=\"usd\",\n                payment_method=payment_method,\n                confirm=True,\n                return_url=\"https://marios-pizzeria.com/payment-success\"\n            )\n\n            return PaymentResult(\n                is_success=True,\n                transaction_id=intent.id,\n                amount_processed=amount\n            )\n\n        except stripe.error.StripeError as e:\n            return PaymentResult(\n                is_success=False,\n                error_message=str(e)\n            )\n\n# src/integration/services/notification_service.py\nclass TwilioNotificationService(INotificationService):\n    \"\"\"SMS notifications using Twilio\"\"\"\n\n    async def send_order_confirmation_async(self, order: Order) -&gt; None:\n        \"\"\"Send order confirmation SMS\"\"\"\n        from twilio.rest import Client\n\n        client = Client(\n            os.getenv(\"TWILIO_ACCOUNT_SID\"),\n            os.getenv(\"TWILIO_AUTH_TOKEN\")\n        )\n\n        message = (f\"Hi {order.customer_name}! Your pizza order #{order.id} \"\n                  f\"has been confirmed. Total: ${order.total_amount}. \"\n                  f\"Estimated ready time: {order.estimated_ready_time.strftime('%I:%M %p')}\")\n\n        await client.messages.create(\n            body=message,\n            from_=os.getenv(\"TWILIO_PHONE_NUMBER\"),\n            to=order.customer_phone\n        )\n\n    async def send_order_ready_notification_async(self, order: Order) -&gt; None:\n        \"\"\"Send order ready SMS\"\"\"\n        message = (f\"\ud83c\udf55 Your order #{order.id} is ready for pickup at Mario's Pizzeria! \"\n                  f\"Please arrive within 15 minutes to keep your pizzas hot.\")\n\n        # Implementation details...\n</code></pre>"},{"location":"old/architecture/#cqrs-implementation-in-marios-pizzeria","title":"\ud83c\udfaf CQRS Implementation in Mario's Pizzeria","text":""},{"location":"old/architecture/#command-and-query-separation","title":"Command and Query Separation","text":"<p>Mario's Pizzeria demonstrates CQRS (Command Query Responsibility Segregation):</p> <pre><code># Commands: Change state (Write operations)\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Command to place new pizza order\"\"\"\n    pass\n\nclass UpdateOrderStatusCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Command to update order status in kitchen\"\"\"\n    pass\n\nclass CancelOrderCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Command to cancel existing order\"\"\"\n    pass\n\n# Queries: Read state (Read operations)\nclass GetOrderByIdQuery(Query[OrderDto]):\n    \"\"\"Query to get specific order details\"\"\"\n    pass\n\nclass GetKitchenQueueQuery(Query[List[KitchenOrderDto]]):\n    \"\"\"Query to get orders in kitchen preparation queue\"\"\"\n    pass\n\nclass GetMenuQuery(Query[List[PizzaDto]]):\n    \"\"\"Query to get available pizza menu\"\"\"\n    pass\n</code></pre>"},{"location":"old/architecture/#benefits-of-cqrs-in-pizzeria-context","title":"Benefits of CQRS in Pizzeria Context","text":"<p>Write Side (Commands):</p> <ul> <li>Order Placement: Validates business rules, processes payments</li> <li>Kitchen Operations: Updates order status, manages workflow</li> <li>Menu Management: Updates pizza availability, pricing</li> </ul> <p>Read Side (Queries):</p> <ul> <li>Customer App: Fast menu browsing, order tracking</li> <li>Kitchen Display: Real-time queue updates</li> <li>Analytics: Revenue reports, performance metrics</li> </ul> <p>Separate Optimization:</p> <ul> <li>Commands use MongoDB for ACID transactions</li> <li>Queries use optimized read models for fast retrieval</li> <li>Analytics use event store for historical data</li> </ul>"},{"location":"old/architecture/#event-driven-architecture","title":"\ud83d\udcca Event-Driven Architecture","text":""},{"location":"old/architecture/#domain-events-in-pizza-workflow","title":"Domain Events in Pizza Workflow","text":"<p>Events coordinate between different parts of Mario's Pizzeria:</p> <pre><code># Domain events flow through the system\nOrderPlacedEvent \u2192 KitchenNotificationHandler \u2192 Kitchen Display Update\n                \u2198 CustomerConfirmationHandler \u2192 SMS Confirmation\n                \u2198 InventoryHandler \u2192 Update Pizza Availability\n\nOrderReadyEvent \u2192 CustomerNotificationHandler \u2192 \"Order Ready\" SMS\n               \u2198 DeliveryScheduleHandler \u2192 Schedule Delivery\n\nOrderCompletedEvent \u2192 AnalyticsHandler \u2192 Update Revenue Metrics\n                   \u2198 CustomerHistoryHandler \u2192 Update Customer Profile\n</code></pre>"},{"location":"old/architecture/#event-handler-examples","title":"Event Handler Examples","text":"<pre><code>class KitchenNotificationHandler(EventHandler[OrderPlacedEvent]):\n    \"\"\"Update kitchen display when new order placed\"\"\"\n\n    async def handle_async(self, event: OrderPlacedEvent):\n        # Add order to kitchen queue\n        command = AddToKitchenQueueCommand(\n            order_id=event.order_id,\n            estimated_ready_time=event.estimated_ready_time\n        )\n        await self.mediator.execute_async(command)\n\nclass CustomerNotificationHandler(EventHandler[OrderReadyEvent]):\n    \"\"\"Notify customer when order is ready\"\"\"\n\n    async def handle_async(self, event: OrderReadyEvent):\n        # Send SMS notification\n        await self.notification_service.send_order_ready_notification_async(\n            order_id=event.order_id,\n            customer_phone=event.customer_phone\n        )\n\nclass RevenueAnalyticsHandler(EventHandler[OrderCompletedEvent]):\n    \"\"\"Update revenue analytics when order completed\"\"\"\n\n    async def handle_async(self, event: OrderCompletedEvent):\n        # Update daily revenue\n        command = UpdateDailyRevenueCommand(\n            date=event.completed_at.date(),\n            amount=event.total_amount,\n            order_count=1\n        )\n        await self.mediator.execute_async(command)\n</code></pre>"},{"location":"old/architecture/#testing-strategy-across-layers","title":"\ud83e\uddea Testing Strategy Across Layers","text":""},{"location":"old/architecture/#layer-specific-testing-approaches","title":"Layer-Specific Testing Approaches","text":"<p>Each layer in Mario's Pizzeria has specific testing strategies:</p> <p>API Layer (Controllers):</p> <ul> <li>Unit Tests: Mock mediator, test HTTP status codes and response formatting</li> <li>Integration Tests: Test full HTTP request/response cycle with real dependencies</li> <li>Contract Tests: Validate request/response schemas match OpenAPI spec</li> </ul> <pre><code>@pytest.mark.asyncio\nasync def test_place_order_success(orders_controller, mock_mediator):\n    \"\"\"Test successful order placement through controller\"\"\"\n    # Arrange\n    order_request = PlaceOrderDto(\n        customer_name=\"Test Customer\",\n        customer_phone=\"+1234567890\",\n        pizzas=[PizzaOrderDto(name=\"Margherita\", size=\"large\", quantity=1)]\n    )\n\n    expected_order = OrderDto(id=\"order_123\", status=\"received\")\n    mock_mediator.execute_async.return_value = OperationResult.success(expected_order)\n\n    # Act\n    result = await orders_controller.place_order(order_request)\n\n    # Assert\n    assert result.id == \"order_123\"\n    assert result.status == \"received\"\n</code></pre> <p>Application Layer (Handlers):</p> <ul> <li>Unit Tests: Mock all dependencies (repositories, external services)</li> <li>Behavior Tests: Verify business workflow logic and error handling</li> <li>Event Tests: Validate domain events are raised correctly</li> </ul> <pre><code>@pytest.mark.asyncio\nasync def test_place_order_handler_workflow(mock_order_repo, mock_payment_service):\n    \"\"\"Test complete order placement workflow\"\"\"\n    # Arrange\n    handler = PlaceOrderCommandHandler(mock_order_repo, mock_payment_service, ...)\n    command = PlaceOrderCommand(customer_name=\"Test\", pizzas=[...])\n\n    mock_payment_service.process_payment_async.return_value = PaymentResult(success=True)\n    mock_order_repo.save_async.return_value = Order(id=\"order_123\")\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n    mock_payment_service.process_payment_async.assert_called_once()\n    mock_order_repo.save_async.assert_called_once()\n</code></pre> <p>Domain Layer (Entities &amp; Services):</p> <ul> <li>Unit Tests: Pure business logic testing with no external dependencies</li> <li>Business Rule Tests: Validate invariants and business constraints</li> <li>Event Tests: Ensure domain events are raised for business-significant changes</li> </ul> <pre><code>def test_order_total_calculation():\n    \"\"\"Test pizza order total calculation business logic\"\"\"\n    # Arrange\n    pizzas = [\n        Pizza(\"Margherita\", \"large\", [\"extra_cheese\"]),\n        Pizza(\"Pepperoni\", \"medium\", [])\n    ]\n\n    # Act\n    order = Order.create_new(\"Customer\", \"+1234567890\", \"Address\", pizzas, \"card\")\n\n    # Assert\n    expected_subtotal = Decimal(\"15.99\") + Decimal(\"12.99\")  # Pizza prices\n    expected_tax = expected_subtotal * Decimal(\"0.0875\")     # 8.75% tax\n    expected_delivery = Decimal(\"2.99\")                      # Delivery fee\n    expected_total = expected_subtotal + expected_tax + expected_delivery\n\n    assert order.total_amount == expected_total.quantize(Decimal(\"0.01\"))\n\ndef test_order_status_transition_validation():\n    \"\"\"Test order status transition business rules\"\"\"\n    # Arrange\n    order = Order.create_new(\"Customer\", \"+1234567890\", \"Address\", [], \"card\")\n\n    # Act &amp; Assert - Valid transition\n    order.update_status(OrderStatus.PREPARING, \"chef_mario\")\n    assert order.status == OrderStatus.PREPARING\n\n    # Act &amp; Assert - Invalid transition\n    with pytest.raises(DomainException):\n        order.update_status(OrderStatus.DELIVERED, \"chef_mario\")  # Cannot skip to delivered\n\ndef test_domain_events_raised():\n    \"\"\"Test that domain events are raised correctly\"\"\"\n    # Arrange\n    pizzas = [Pizza(\"Margherita\", \"large\", [])]\n\n    # Act\n    order = Order.create_new(\"Customer\", \"+1234567890\", \"Address\", pizzas, \"card\")\n\n    # Assert\n    events = order.get_uncommitted_events()\n    assert len(events) == 1\n    assert isinstance(events[0], OrderPlacedEvent)\n    assert events[0].order_id == order.id\n</code></pre> <p>Integration Layer (Repositories &amp; Services):</p> <ul> <li>Unit Tests: Mock external dependencies (databases, APIs)</li> <li>Integration Tests: Test against real external systems in controlled environments</li> <li>Contract Tests: Validate external API integrations</li> </ul> <pre><code>@pytest.mark.integration\nasync def test_file_order_repository_roundtrip():\n    \"\"\"Test saving and retrieving orders from file system\"\"\"\n    # Arrange\n    repository = FileOrderRepository(\"test_data/orders\")\n    order = Order.create_new(\"Test Customer\", \"+1234567890\", \"Test Address\", [], \"cash\")\n\n    # Act\n    saved_order = await repository.save_async(order)\n    retrieved_order = await repository.get_by_id_async(saved_order.id)\n\n    # Assert\n    assert retrieved_order is not None\n    assert retrieved_order.customer_name == \"Test Customer\"\n    assert retrieved_order.id == saved_order.id\n\n@pytest.mark.integration\nasync def test_stripe_payment_service():\n    \"\"\"Test payment processing with Stripe (using test API keys)\"\"\"\n    # Arrange\n    payment_service = StripePaymentService()\n    amount = Decimal(\"29.99\")\n\n    # Act\n    result = await payment_service.process_payment_async(amount, \"pm_card_visa\")\n\n    # Assert\n    assert result.is_success\n    assert result.amount_processed == amount\n    assert result.transaction_id is not None\n</code></pre>"},{"location":"old/architecture/#end-to-end-testing","title":"End-to-End Testing","text":"<p>Full workflow testing across all layers:</p> <pre><code>@pytest.mark.e2e\nasync def test_complete_pizza_order_workflow():\n    \"\"\"Test complete order workflow from API to persistence\"\"\"\n    async with TestClient(create_pizzeria_app()) as client:\n        # 1. Get menu\n        menu_response = await client.get(\"/api/menu/pizzas\")\n        assert menu_response.status_code == 200\n\n        # 2. Place order\n        order_data = {\n            \"customer_name\": \"E2E Test Customer\",\n            \"customer_phone\": \"+1234567890\",\n            \"customer_address\": \"123 Test St\",\n            \"pizzas\": [{\"name\": \"Margherita\", \"size\": \"large\", \"quantity\": 1}],\n            \"payment_method\": \"card\"\n        }\n\n        order_response = await client.post(\"/api/orders/\", json=order_data)\n        assert order_response.status_code == 201\n        order = order_response.json()\n\n        # 3. Update order status (kitchen)\n        status_update = {\"status\": \"preparing\", \"notes\": \"Started preparation\"}\n        status_response = await client.put(\n            f\"/api/kitchen/orders/{order['id']}/status\",\n            json=status_update,\n            headers={\"Authorization\": \"Bearer {kitchen_token}\"}\n        )\n        assert status_response.status_code == 200\n\n        # 4. Verify order status\n        check_response = await client.get(f\"/api/orders/{order['id']}\")\n        updated_order = check_response.json()\n        assert updated_order[\"status\"] == \"preparing\"\n</code></pre>"},{"location":"old/architecture/#dependency-injection-configuration","title":"\ud83d\udee0\ufe0f Dependency Injection Configuration","text":""},{"location":"old/architecture/#service-registration-for-marios-pizzeria","title":"Service Registration for Mario's Pizzeria","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\n\ndef configure_pizzeria_services(builder: WebApplicationBuilder):\n    \"\"\"Configure all services for Mario's Pizzeria\"\"\"\n\n    # Domain services\n    builder.services.add_scoped(KitchenWorkflowService)\n    builder.services.add_scoped(PricingService)\n\n    # Application services\n    builder.services.add_mediator()\n    builder.services.add_auto_mapper()\n\n    # Infrastructure services (environment-specific)\n    environment = os.getenv(\"ENVIRONMENT\", \"development\")\n\n    if environment == \"development\":\n        # File-based repositories for development\n        builder.services.add_scoped(IOrderRepository, FileOrderRepository)\n        builder.services.add_scoped(IPizzaRepository, FilePizzaRepository)\n        builder.services.add_scoped(INotificationService, ConsoleNotificationService)\n        builder.services.add_scoped(IPaymentService, MockPaymentService)\n\n    else:  # production\n        # MongoDB repositories for production\n        builder.services.add_scoped(IOrderRepository, MongoOrderRepository)\n        builder.services.add_scoped(IPizzaRepository, MongoPizzaRepository)\n        builder.services.add_scoped(INotificationService, TwilioNotificationService)\n        builder.services.add_scoped(IPaymentService, StripePaymentService)\n\n    # Event handlers\n    builder.services.add_scoped(EventHandler[OrderPlacedEvent], KitchenNotificationHandler)\n    builder.services.add_scoped(EventHandler[OrderReadyEvent], CustomerNotificationHandler)\n    builder.services.add_scoped(EventHandler[OrderCompletedEvent], AnalyticsHandler)\n\n    # Controllers\n    builder.services.add_controllers([\n        \"api.controllers.orders_controller\",\n        \"api.controllers.menu_controller\",\n        \"api.controllers.kitchen_controller\"\n    ])\n</code></pre>"},{"location":"old/architecture/#benefits-of-this-architecture","title":"\ud83d\ude80 Benefits of This Architecture","text":""},{"location":"old/architecture/#for-marios-pizzeria-business","title":"For Mario's Pizzeria Business","text":"<ul> <li>Scalability: Can handle increasing order volume by scaling individual layers</li> <li>Maintainability: Business logic changes are isolated to domain layer</li> <li>Testability: Comprehensive testing at every layer ensures reliability</li> <li>Flexibility: Easy to change storage, payment providers, or notification methods</li> <li>Team Productivity: Clear boundaries enable parallel development</li> </ul>"},{"location":"old/architecture/#for-development-teams","title":"For Development Teams","text":"<ul> <li>Clear Responsibilities: Each layer has well-defined purpose and boundaries</li> <li>Technology Independence: Can swap infrastructure without changing business logic</li> <li>Parallel Development: Teams can work on different layers simultaneously</li> <li>Easy Onboarding: New developers understand system through consistent patterns</li> </ul>"},{"location":"old/architecture/#for-long-term-maintenance","title":"For Long-Term Maintenance","text":"<ul> <li>Evolution Support: Architecture supports changing business requirements</li> <li>Technology Updates: Infrastructure can be updated without business logic changes</li> <li>Performance Optimization: Each layer can be optimized independently</li> <li>Monitoring &amp; Debugging: Clear separation aids in troubleshooting issues</li> </ul>"},{"location":"old/architecture/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started Guide - Complete Mario's Pizzeria tutorial</li> <li>CQRS &amp; Mediation - Command and query patterns in depth</li> <li>Dependency Injection - Service registration and DI patterns</li> <li>MVC Controllers - API layer implementation details</li> <li>Data Access - Repository patterns and data persistence</li> <li>Source Code Naming Conventions - Consistent naming across all architectural layers</li> <li>12-Factor App Compliance - Cloud-native architecture principles with framework implementation</li> </ul> <p>This architecture guide demonstrates clean architecture principles using Mario's Pizzeria as a comprehensive example. The layered approach shown here scales from simple applications to complex enterprise systems while maintaining clear separation of concerns and testability.</p>"},{"location":"old/architecture/#application-layer-pizza-business-workflow","title":"\ud83d\udcbc Application Layer: Pizza Business Workflow","text":"<p>Purpose: Orchestrates pizza business operations and workflows</p> <p>Responsibilities:</p> <ul> <li>Command and query handling (CQRS)</li> <li>Business workflow coordination</li> <li>Domain event processing</li> <li>Cross-cutting concerns (logging, validation, caching)</li> </ul> <p>Key Components:</p> <pre><code># src/application/commands/place_order_command.py\n@dataclass\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Command to place a pizza order\"\"\"\n    customer_name: str\n    customer_phone: str\n    customer_address: str\n    pizzas: List[PizzaOrderDto]\n    payment_method: str\n\n# src/application/handlers/place_order_handler.py\nclass PlaceOrderCommandHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    \"\"\"Handles pizza order placement business workflow\"\"\"\n\n    def __init__(self,\n                 order_repository: IOrderRepository,\n                 pizza_repository: IPizzaRepository,\n                 payment_service: IPaymentService,\n                 notification_service: INotificationService,\n                 mapper: Mapper):\n        self.order_repository = order_repository\n        self.pizza_repository = pizza_repository\n        self.payment_service = payment_service\n        self.notification_service = notification_service\n        self.mapper = mapper\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        \"\"\"Execute pizza order placement workflow\"\"\"\n        try:\n            # 1. Validate pizzas are available\n            for pizza_request in command.pizzas:\n                pizza = await self.pizza_repository.get_by_name_async(pizza_request.name)\n                if not pizza or not pizza.is_available:\n                    return self.bad_request(f\"Pizza '{pizza_request.name}' is not available\")\n\n            # 2. Calculate order total using domain logic\n            order = Order.create_new(\n                customer_name=command.customer_name,\n                customer_phone=command.customer_phone,\n                customer_address=command.customer_address,\n                pizzas=command.pizzas,\n                payment_method=command.payment_method\n            )\n\n            # 3. Process payment (integration layer)\n            payment_result = await self.payment_service.process_payment_async(\n                order.total_amount, command.payment_method\n            )\n\n            if not payment_result.is_success:\n                return self.bad_request(\"Payment processing failed\")\n\n            order.mark_payment_processed(payment_result.transaction_id)\n\n            # 4. Save order (integration layer)\n            saved_order = await self.order_repository.save_async(order)\n\n            # 5. Domain event will trigger kitchen notification automatically\n            # (OrderPlacedEvent is raised by Order entity)\n\n            # 6. Send customer confirmation\n            await self.notification_service.send_order_confirmation_async(saved_order)\n\n            # 7. Return success result\n            order_dto = self.mapper.map(saved_order, OrderDto)\n            return self.created(order_dto)\n\n        except Exception as ex:\n            return self.internal_server_error(f\"Failed to place order: {str(ex)}\")\n</code></pre> <p>Architecture Benefits:</p> <ul> <li>Single Responsibility: Each handler has one clear purpose</li> <li>Testability: Easy to unit test handlers with mocked repositories</li> <li>Transaction Management: Clear transaction boundaries</li> <li>Event-Driven: Domain events enable loose coupling</li> </ul>"},{"location":"old/architecture/#domain-layer-pizza-business-logic","title":"\ud83c\udfdb\ufe0f Domain Layer: Pizza Business Logic","text":"<p>Purpose: Contains core pizza business rules and entities</p> <p>Responsibilities:</p> <ul> <li>Business entities with behavior</li> <li>Domain services for complex business logic</li> <li>Domain events for business-significant occurrences</li> <li>Business rule validation and invariants</li> </ul> <p>Key Components:</p> <p>Key Components:</p> <ul> <li>Controllers: Handle HTTP requests and delegate to application layer</li> <li>DTOs: Data Transfer Objects for API contracts</li> <li>Middleware: Cross-cutting concerns like authentication, logging</li> </ul> <p>Example Structure:</p> <pre><code>api/\n\u251c\u2500\u2500 controllers/\n\u2502   \u251c\u2500\u2500 users_controller.py\n\u2502   \u2514\u2500\u2500 orders_controller.py\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 user_dto.py\n\u2502   \u2514\u2500\u2500 order_dto.py\n\u2514\u2500\u2500 middleware/\n    \u251c\u2500\u2500 auth_middleware.py\n    \u2514\u2500\u2500 logging_middleware.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Keep controllers thin - delegate business logic to application layer</li> <li>Use DTOs to define API contracts</li> <li>Validate input at the API boundary</li> <li>Map between DTOs and domain models</li> </ul>"},{"location":"old/architecture/#application-layer-srcapplication","title":"\ud83d\udcbc Application Layer (<code>src/application/</code>)","text":"<p>Purpose: Orchestrates business workflows and coordinates domain operations</p> <p>Responsibilities:</p> <ul> <li>Command and query handling</li> <li>Business workflow orchestration</li> <li>Transaction management</li> <li>Event publishing</li> <li>Application services</li> </ul> <p>Key Components:</p> <ul> <li>Commands: Represent actions that change state</li> <li>Queries: Represent read operations</li> <li>Handlers: Process commands and queries</li> <li>Services: Application-specific business logic</li> </ul> <p>Example Structure:</p> <pre><code>application/\n\u251c\u2500\u2500 commands/\n\u2502   \u251c\u2500\u2500 create_user_command.py\n\u2502   \u2514\u2500\u2500 update_user_command.py\n\u251c\u2500\u2500 queries/\n\u2502   \u251c\u2500\u2500 get_user_query.py\n\u2502   \u2514\u2500\u2500 list_users_query.py\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 user_service.py\n\u2502   \u2514\u2500\u2500 notification_service.py\n\u2514\u2500\u2500 events/\n    \u251c\u2500\u2500 user_created_event.py\n    \u2514\u2500\u2500 user_updated_event.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Each command/query should have a single responsibility</li> <li>Use the mediator pattern to decouple handlers</li> <li>Keep application services focused on coordination</li> <li>Publish domain events for side effects</li> </ul>"},{"location":"old/architecture/#domain-layer-srcdomain","title":"\ud83c\udfdb\ufe0f Domain Layer (<code>src/domain/</code>)","text":"<p>Purpose: Contains the core business logic and rules</p> <p>Responsibilities:</p> <ul> <li>Business entities and aggregates</li> <li>Value objects</li> <li>Domain services</li> <li>Business rules and invariants</li> <li>Domain events</li> </ul> <p>Key Components:</p> <ul> <li>Entities: Objects with identity and lifecycle</li> <li>Value Objects: Immutable objects defined by their attributes</li> <li>Aggregates: Consistency boundaries</li> <li>Domain Services: Business logic that doesn't belong to entities</li> </ul> <p>Example Structure:</p> <pre><code>domain/\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 user.py\n\u2502   \u251c\u2500\u2500 order.py\n\u2502   \u2514\u2500\u2500 address.py\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 pricing_service.py\n\u2502   \u2514\u2500\u2500 validation_service.py\n\u2514\u2500\u2500 events/\n    \u251c\u2500\u2500 user_registered.py\n    \u2514\u2500\u2500 order_placed.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Keep domain models rich with behavior</li> <li>Enforce business invariants</li> <li>Use domain events for decoupling</li> <li>Avoid dependencies on infrastructure</li> </ul>"},{"location":"old/architecture/#integration-layer-srcintegration","title":"\ud83d\udd0c Integration Layer (<code>src/integration/</code>)","text":"<p>Purpose: Handles external integrations and infrastructure concerns</p> <p>Responsibilities:</p> <ul> <li>Database repositories</li> <li>External API clients</li> <li>Message queue integration</li> <li>File system operations</li> <li>Caching</li> </ul> <p>Key Components:</p> <ul> <li>Repositories: Data access implementations</li> <li>API Clients: External service integrations</li> <li>DTOs: External data contracts</li> <li>Infrastructure Services: Technical concerns</li> </ul> <p>Example Structure:</p> <pre><code>integration/\n\u251c\u2500\u2500 repositories/\n\u2502   \u251c\u2500\u2500 user_repository.py\n\u2502   \u2514\u2500\u2500 order_repository.py\n\u251c\u2500\u2500 clients/\n\u2502   \u251c\u2500\u2500 payment_client.py\n\u2502   \u2514\u2500\u2500 email_client.py\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 user_entity.py\n\u2502   \u2514\u2500\u2500 payment_dto.py\n\u2514\u2500\u2500 services/\n    \u251c\u2500\u2500 cache_service.py\n    \u2514\u2500\u2500 file_service.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Implement domain repository interfaces</li> <li>Handle external failures gracefully</li> <li>Use DTOs for external data contracts</li> <li>Isolate infrastructure concerns</li> </ul>"},{"location":"old/architecture/#data-flow","title":"\ud83d\udd04 Data Flow","text":""},{"location":"old/architecture/#command-flow-write-operations","title":"Command Flow (Write Operations)","text":"<ol> <li>Controller receives HTTP request with DTO</li> <li>Controller maps DTO to Command and sends to Mediator</li> <li>Mediator routes Command to appropriate Handler</li> <li>Handler loads domain entities via Repository</li> <li>Handler executes business logic on domain entities</li> <li>Handler saves changes via Repository</li> <li>Handler publishes domain events</li> <li>Handler returns result to Controller</li> <li>Controller maps result to DTO and returns HTTP response</li> </ol> <pre><code>HTTP Request \u2192 Controller \u2192 Command \u2192 Handler \u2192 Domain \u2192 Repository \u2192 Database\n                    \u2193           \u2193        \u2193\n               HTTP Response \u2190 DTO \u2190 Result \u2190 Events\n</code></pre>"},{"location":"old/architecture/#query-flow-read-operations","title":"Query Flow (Read Operations)","text":"<ol> <li>Controller receives HTTP request with parameters</li> <li>Controller creates Query and sends to Mediator</li> <li>Mediator routes Query to appropriate Handler</li> <li>Handler loads data via Repository or Read Model</li> <li>Handler returns data to Controller</li> <li>Controller maps data to DTO and returns HTTP response</li> </ol> <pre><code>HTTP Request \u2192 Controller \u2192 Query \u2192 Handler \u2192 Repository \u2192 Database\n                    \u2193         \u2193       \u2193\n               HTTP Response \u2190 DTO \u2190 Result\n</code></pre>"},{"location":"old/architecture/#patterns-implemented","title":"\ud83c\udfad Patterns Implemented","text":""},{"location":"old/architecture/#1-command-query-responsibility-segregation-cqrs","title":"1. Command Query Responsibility Segregation (CQRS)","text":"<p>Separates read and write operations to optimize performance and scalability:</p> <pre><code># Command (Write)\n@dataclass\nclass CreateUserCommand(Command[OperationResult[UserDto]]):\n    email: str\n    first_name: str\n    last_name: str\n\n# Query (Read)\n@dataclass\nclass GetUserQuery(Query[OperationResult[UserDto]]):\n    user_id: str\n</code></pre>"},{"location":"old/architecture/#2-mediator-pattern","title":"2. Mediator Pattern","text":"<p>Decouples components by routing requests through a central mediator:</p> <pre><code># In controller\nresult = await self.mediator.execute_async(command)\n</code></pre>"},{"location":"old/architecture/#3-repository-pattern","title":"3. Repository Pattern","text":"<p>Abstracts data access and provides a consistent interface:</p> <pre><code>class UserRepository(Repository[User, str]):\n    async def add_async(self, user: User) -&gt; User:\n        # Implementation details\n        pass\n</code></pre>"},{"location":"old/architecture/#4-event-sourcing-optional","title":"4. Event Sourcing (Optional)","text":"<p>Stores state changes as events rather than current state:</p> <pre><code>class User(AggregateRoot[str]):\n    def register(self, email: str, name: str):\n        self.apply(UserRegisteredEvent(email, name))\n</code></pre>"},{"location":"old/architecture/#5-dependency-injection","title":"5. Dependency Injection","text":"<p>Manages object creation and dependencies:</p> <pre><code># Automatic registration\nbuilder.services.add_scoped(UserService)\n\n# Resolution\nuser_service = provider.get_required_service(UserService)\n</code></pre>"},{"location":"old/architecture/#testing-architecture","title":"\ud83e\uddea Testing Architecture","text":"<p>The layered architecture makes testing straightforward:</p>"},{"location":"old/architecture/#unit-tests","title":"Unit Tests","text":"<p>Test individual components in isolation:</p> <pre><code>def test_user_registration():\n    # Arrange\n    command = CreateUserCommand(\"test@example.com\", \"John\", \"Doe\")\n    handler = CreateUserCommandHandler(mock_repository)\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n</code></pre>"},{"location":"old/architecture/#integration-tests","title":"Integration Tests","text":"<p>Test interactions between layers:</p> <pre><code>def test_create_user_endpoint():\n    # Test API \u2192 Application \u2192 Domain integration\n    response = test_client.post(\"/api/v1/users\", json=user_data)\n    assert response.status_code == 201\n</code></pre>"},{"location":"old/architecture/#architecture-tests","title":"Architecture Tests","text":"<p>Verify architectural constraints:</p> <pre><code>def test_domain_has_no_infrastructure_dependencies():\n    # Ensure domain layer doesn't depend on infrastructure\n    domain_modules = get_domain_modules()\n    for module in domain_modules:\n        assert not has_infrastructure_imports(module)\n</code></pre>"},{"location":"old/architecture/#benefits","title":"\ud83d\ude80 Benefits","text":""},{"location":"old/architecture/#maintainability","title":"Maintainability","text":"<ul> <li>Clear boundaries: Each layer has well-defined responsibilities</li> <li>Loose coupling: Changes in one layer don't affect others</li> <li>High cohesion: Related functionality is grouped together</li> </ul>"},{"location":"old/architecture/#testability","title":"Testability","text":"<ul> <li>Isolated testing: Each layer can be tested independently</li> <li>Mock dependencies: External dependencies can be easily mocked</li> <li>Fast tests: Business logic tests don't require infrastructure</li> </ul>"},{"location":"old/architecture/#scalability","title":"Scalability","text":"<ul> <li>CQRS: Read and write models can be optimized separately</li> <li>Event-driven: Asynchronous processing for better performance</li> <li>Microservice ready: Clear boundaries make extraction easier</li> </ul>"},{"location":"old/architecture/#flexibility","title":"Flexibility","text":"<ul> <li>Technology agnostic: Swap implementations without affecting business logic</li> <li>Framework independence: Business logic isn't tied to web framework</li> <li>Future-proof: Architecture adapts to changing requirements</li> </ul>"},{"location":"patterns/","title":"\ud83c\udfaf Architecture Patterns &amp; Core Concepts","text":"<p>Welcome to architecture patterns! This section explains the patterns and principles that Neuroglia is built upon. Each pattern is explained for beginners - you don't need prior knowledge.</p> <p>\ud83d\udcd6 Note: Pattern documentation includes beginner-friendly What &amp; Why sections showing problems and solutions, Common Mistakes with anti-patterns, and When NOT to Use guidance.</p>"},{"location":"patterns/#why-these-patterns","title":"\ud83c\udfaf Why These Patterns?","text":"<p>Neuroglia enforces specific architectural patterns because they solve real problems in software development:</p> <ul> <li>Maintainability: Code that's easy to change as requirements evolve</li> <li>Testability: Components that can be tested in isolation</li> <li>Scalability: Architecture that grows with your application</li> <li>Clarity: Clear separation of concerns and responsibilities</li> </ul>"},{"location":"patterns/#quick-start-learning-path","title":"\ufffd Quick Start Learning Path","text":"<p>New to these patterns? Follow this recommended path:</p> <ol> <li>Foundation: Clean Architecture - Organizing code in layers</li> <li>Dependencies: Dependency Injection - Managing components</li> <li>Domain Logic: Domain-Driven Design - Modeling business rules</li> <li>Application Layer: CQRS - Separating reads from writes</li> <li>Integration: Event-Driven Architecture - Reacting to events</li> <li>Data Access: Repository - Abstracting persistence</li> </ol> <p>Already familiar? Jump to any pattern for Neuroglia-specific implementation details.</p>"},{"location":"patterns/#what-each-guide-includes","title":"\ud83d\udca1 What Each Guide Includes","text":"<ul> <li>\u274c The Problem: What happens without this pattern</li> <li>\u2705 The Solution: How the pattern solves it</li> <li>\ud83d\udd27 In Neuroglia: Framework implementation details</li> <li>\ud83e\uddea Testing: How to test code using this pattern</li> <li>\u26a0\ufe0f Common Mistakes: Pitfalls to avoid</li> <li>\ud83d\udeab When NOT to Use: Scenarios where simpler approaches work better</li> </ul>"},{"location":"patterns/#architectural-approaches-a-comparative-introduction","title":"\ud83c\udfd7\ufe0f Architectural Approaches: A Comparative Introduction","text":"<p>Before diving into specific patterns, it's essential to understand the different architectural philosophies that drive modern system design. The Neuroglia framework draws from multiple architectural approaches, each with distinct strengths and use cases.</p>"},{"location":"patterns/#core-philosophy-comparison","title":"\ud83c\udfaf Core Philosophy Comparison","text":"<p>Domain-Driven Design (DDD) and Declarative Resource-Oriented Architecture represent two powerful but different approaches to managing complex system states:</p> <ul> <li>DDD: Models systems around business domains, focusing on behavior and state transitions</li> <li>Declarative Architecture: Defines desired end states and uses automated processes to achieve them</li> </ul>"},{"location":"patterns/#architectural-patterns-overview","title":"\ud83d\udd04 Architectural Patterns Overview","text":"Architecture Core Philosophy Primary Actor Unit of Work Source of Truth Flow of Logic Error Handling Typical Domain \ud83c\udfdb\ufe0f Domain-Driven Design Model around business domain with AggregateRoot as guardian enforcing business rules Imperative Command: User/system issues explicit commands (<code>AddToppingToPizza</code>) Aggregate: Boundary around business objects with atomic transactions Application Database: Current aggregate state in database Synchronous &amp; Explicit: <code>CommandHandler</code> \u2192 <code>Repository.Get()</code> \u2192 <code>Aggregate.Method()</code> \u2192 <code>Repository.Update()</code> Throws Exceptions: Business rule violations cause immediate failures Complex Business Logic: E-commerce, banking, booking systems \ud83c\udf10 Declarative Resource-Oriented Define desired state and let automated processes achieve it Declarative Reconciliation: Automated Controller continuously matches actual to desired state Resource: Self-contained state declaration (e.g., Kubernetes Pod manifest) Declarative Manifest: Configuration file (YAML) defines desired state Asynchronous &amp; Looping: <code>Watcher</code> detects change \u2192 <code>Controller</code> triggers \u2192 Reconciliation Loop \u2192 <code>Client.UpdateActualState()</code> Retries and Converges: Failed operations retry in next reconciliation cycle Infrastructure &amp; Systems Management: Kubernetes, Terraform, CloudFormation"},{"location":"patterns/#practical-analogies","title":"\ud83c\udfa8 Practical Analogies","text":"<ul> <li>DDD is like giving a chef specific recipe instructions: \"Add 20g of cheese to the pizza\" - explicit commands executed immediately</li> <li>Declarative Architecture is like giving the chef a photograph of the final pizza: \"Make it look like this\" - continuous checking and adjustment until the goal is achieved</li> </ul>"},{"location":"patterns/#event-driven-architecture-the-foundation","title":"\ud83d\udce1 Event-Driven Architecture: The Foundation","text":"<p>Event-Driven Architecture (EDA) serves as the postal service \ud83d\udcec of your system - a foundational pattern enabling reactive communication without tight coupling between components.</p>"},{"location":"patterns/#eda-in-domain-driven-design","title":"\ud83c\udfdb\ufe0f EDA in Domain-Driven Design","text":"<p>In DDD, EDA handles side effects and communication between different business domains (Bounded Contexts):</p> <ul> <li>Purpose: Reacting to significant business moments</li> <li>Mechanism: <code>AggregateRoot</code> publishes <code>DomainEvents</code> (e.g., <code>OrderPaid</code>, <code>PizzaBaked</code>)</li> <li>Benefit: Highly decoupled systems where services don't need direct knowledge of each other</li> </ul> <p>Example: <code>Orders</code> service publishes <code>OrderPaid</code> \u2192 <code>Kitchen</code> service receives event and starts pizza preparation</p>"},{"location":"patterns/#eda-in-declarative-architecture","title":"\ud83c\udf10 EDA in Declarative Architecture","text":"<p>In declarative systems, EDA powers the reconciliation loop:</p> <ul> <li>Purpose: Reacting to changes in configuration or state</li> <li>Mechanism: Watcher monitors resources \u2192 generates events \u2192 Controller consumes events and reconciles state</li> <li>Benefit: Automated state management with continuous convergence toward desired state</li> </ul> <p>Example: YAML file creates <code>Deployment</code> \u2192 API server generates \"resource created\" event \u2192 Deployment controller creates required pods</p>"},{"location":"patterns/#integration-summary","title":"\ud83d\udd04 Integration Summary","text":"Architecture How it uses Event-Driven Architecture (EDA) \ud83c\udfdb\ufe0f Domain-Driven Design Uses Domain Events to announce significant business actions, triggering workflows in decoupled business domains \ud83c\udf10 Declarative Architecture Uses State Change Events (from watchers) to trigger controller reconciliation loops, ensuring actual state matches desired state"},{"location":"patterns/#choosing-your-approach","title":"\ud83c\udfaf Choosing Your Approach","text":"<p>Both patterns leverage EDA for reactive, decoupled systems but differ in event nature and granularity:</p> <ul> <li>DDD: Focus on high-level business events with rich domain behavior</li> <li>Declarative: Focus on low-level resource state changes with automated convergence</li> </ul> <p>The Neuroglia framework provides implementations for both approaches, allowing you to choose the right pattern for each part of your system.</p>"},{"location":"patterns/#pattern-overview","title":"\ufffd\ud83c\udfdb\ufe0f Pattern Overview","text":"Pattern Purpose Key Concepts What You'll Learn Mario's Pizzeria Use Case When to Use \ud83c\udfd7\ufe0f Clean Architecture Foundation pattern that organizes code into layers with clear dependency rules \u2022 Domain-driven layer separation\u2022 Dependency inversion principle\u2022 Business logic isolation\u2022 Infrastructure abstraction \u2022 Four-layer architecture implementation\u2022 Dependency flow and injection patterns\u2022 Domain entity design with business logic\u2022 Integration layer abstraction Order processing across API, Application, Domain, and Integration layers All applications - structural foundation \ud83c\udfdb\ufe0f Domain Driven Design Core domain abstractions and patterns for rich business models with event-driven capabilities \u2022 Rich domain entities with business logic\u2022 Aggregate roots and consistency boundaries\u2022 Domain events and integration events\u2022 Event sourcing vs traditional approaches \u2022 Entity and aggregate root implementation\u2022 Domain event design and handling\u2022 Transaction flows with multiple events\u2022 Data flow across architectural layers Pizza orders with business rules, events, and cross-layer data flow Complex business domains, rich models \ud83c\udfdb\ufe0f Persistence Patterns Alternative persistence approaches with different complexity levels and capabilities \u2022 Simple Entity + State Persistence\u2022 Complex AggregateRoot + Event Sourcing\u2022 Hybrid approaches\u2022 Pattern decision frameworks \u2022 Complexity level comparison\u2022 Implementation patterns for each approach\u2022 Decision criteria and guidelines\u2022 Migration strategies between patterns Customer profiles (simple) vs Order processing (complex) patterns All applications - choose right complexity \ud83d\udd04 Unit of Work Pattern Coordination layer for domain event collection and dispatching across persistence patterns \u2022 Aggregate registration and tracking\u2022 Automatic event collection\u2022 Pipeline integration\u2022 Flexible entity support \u2022 UnitOfWork implementation and usage\u2022 Event coordination patterns\u2022 Pipeline behavior integration\u2022 Testing strategies for event workflows Order processing with automatic event dispatching after state persistence Event-driven systems, domain coordination \ufffd Pipeline Behaviors Cross-cutting concerns implemented as composable behaviors around command/query execution \u2022 Decorator pattern implementation\u2022 Behavior chaining and ordering\u2022 Cross-cutting concerns\u2022 Pre/post processing logic \u2022 Creating custom pipeline behaviors\u2022 Behavior registration and ordering\u2022 Validation, logging, caching patterns\u2022 Transaction and error handling Validation, logging, and transaction management around order processing Cross-cutting concerns, AOP patterns \ufffd\ud83d\udc89 Dependency Injection Manages object dependencies and lifecycle through inversion of control patterns \u2022 Service registration and resolution\u2022 Lifetime management patterns\u2022 Constructor injection\u2022 Interface-based abstractions \u2022 Service container configuration\u2022 Lifetime scope patterns\u2022 Testing with mock dependencies\u2022 Clean dependency management PizzeriaService dependencies managed through DI container Complex dependency graphs, testability \ud83d\udce1 CQRS &amp; Mediation Separates read/write operations with mediator pattern for decoupled request handling \u2022 Command/Query separation\u2022 Mediator request routing\u2022 Pipeline behaviors\u2022 Handler-based processing \u2022 Command and query handler implementation\u2022 Mediation pattern usage\u2022 Cross-cutting concerns via behaviors\u2022 Event integration with CQRS PlaceOrderCommand vs GetOrderQuery with mediator routing Complex business logic, high-scale systems \ud83d\udd04 Event-Driven Architecture Implements reactive systems using domain events and event handlers \u2022 Domain event patterns\u2022 Event handlers and workflows\u2022 Asynchronous processing\u2022 System decoupling \u2022 Domain event design and publishing\u2022 Event handler implementation\u2022 Kitchen workflow automation\u2022 CloudEvents integration OrderPlaced \u2192 Kitchen processing \u2192 OrderReady \u2192 Customer notification Loose coupling, reactive workflows \ud83c\udfaf Event Sourcing Stores state changes as immutable events for complete audit trails and temporal queries \u2022 Event-based persistence\u2022 Aggregate state reconstruction\u2022 Temporal queries\u2022 Event replay capabilities \u2022 Event-sourced aggregate design\u2022 Event store integration\u2022 Read model projections\u2022 Business intelligence from events Order lifecycle tracked through immutable events with full history Audit requirements, temporal analysis \ud83c\udf0a Reactive Programming Enables asynchronous event-driven architectures using Observable streams \u2022 Observable stream patterns\u2022 Asynchronous event processing\u2022 Stream transformations\u2022 Background service integration \u2022 RxPY integration patterns\u2022 Stream processing and subscription\u2022 Real-time data flows\u2022 Background service implementation Real-time order tracking and kitchen capacity monitoring Real-time systems, high-throughput events \ud83d\udcbe Repository Pattern Abstracts data access logic with multiple storage implementations \u2022 Data access abstraction\u2022 Storage implementation flexibility\u2022 Consistent query interfaces\u2022 Testing with mock repositories \u2022 Repository interface design\u2022 Multiple storage backend implementation\u2022 Async data access patterns\u2022 Repository testing strategies OrderRepository with File, MongoDB, and InMemory implementations Data persistence, testability \ud83c\udf10 Resource-Oriented Architecture Resource-oriented design principles for building RESTful APIs and resource-centric applications \u2022 Resource identification and modeling\u2022 RESTful API design principles\u2022 HTTP verb mapping and semantics\u2022 Resource lifecycle management \u2022 Resource-oriented design principles\u2022 RESTful API architecture patterns\u2022 HTTP protocol integration\u2022 Resource state management Orders, Menu, Kitchen as REST resources with full CRUD operations RESTful APIs, microservices \ud83d\udc40 Watcher &amp; Reconciliation Patterns Kubernetes-inspired patterns for watching resource changes and implementing reconciliation loops \u2022 Resource state observation\u2022 Reconciliation loop patterns\u2022 Event-driven state management\u2022 Declarative resource management \u2022 Resource watching implementation\u2022 Reconciliation loop design\u2022 Event-driven update patterns\u2022 State synchronization strategies Kitchen capacity monitoring and order queue reconciliation Reactive systems, state synchronization \u26a1 Watcher &amp; Reconciliation Execution Execution engine for watcher and reconciliation patterns with error handling and monitoring \u2022 Execution orchestration\u2022 Error handling and recovery\u2022 Performance monitoring\u2022 Reliable state persistence \u2022 Execution pipeline design\u2022 Error handling strategies\u2022 Monitoring and observability\u2022 Performance optimization Automated kitchen workflow execution with retry logic and monitoring Production systems, reliability requirements"},{"location":"patterns/#marios-pizzeria-unified-example","title":"\ud83c\udf55 Mario's Pizzeria: Unified Example","text":"<p>All patterns use Mario's Pizzeria as a consistent domain example, showing how patterns work together in a real-world system:</p> <pre><code>graph TB\n    subgraph \"\ud83c\udfd7\ufe0f Clean Architecture Layers\"\n        API[\ud83c\udf10 API Layer&lt;br/&gt;Controllers &amp; DTOs]\n        APP[\ud83d\udcbc Application Layer&lt;br/&gt;Commands &amp; Queries]\n        DOM[\ud83c\udfdb\ufe0f Domain Layer&lt;br/&gt;Entities &amp; Events]\n        INT[\ud83d\udd0c Integration Layer&lt;br/&gt;Repositories &amp; Services]\n    end\n\n    subgraph \"\ud83d\udce1 CQRS Implementation\"\n        CMD[Commands&lt;br/&gt;PlaceOrder, StartCooking]\n        QRY[Queries&lt;br/&gt;GetOrder, GetMenu]\n    end\n\n    subgraph \"\ud83d\udd04 Event-Driven Flow\"\n        EVT[Domain Events&lt;br/&gt;OrderPlaced, OrderReady]\n        HDL[Event Handlers&lt;br/&gt;Kitchen, Notifications]\n    end\n\n    subgraph \"\ud83d\udcbe Data Access\"\n        REPO[Repositories&lt;br/&gt;Order, Menu, Customer]\n        STOR[Storage&lt;br/&gt;File, MongoDB, Memory]\n    end\n\n    API --&gt; APP\n    APP --&gt; DOM\n    APP --&gt; INT\n\n    APP --&gt; CMD\n    APP --&gt; QRY\n\n    DOM --&gt; EVT\n    EVT --&gt; HDL\n\n    INT --&gt; REPO\n    REPO --&gt; STOR\n\n    style API fill:#e3f2fd\n    style APP fill:#f3e5f5\n    style DOM fill:#e8f5e8\n    style INT fill:#fff3e0</code></pre>"},{"location":"patterns/#pattern-integration","title":"\ud83d\ude80 Pattern Integration","text":""},{"location":"patterns/#how-patterns-work-together","title":"How Patterns Work Together","text":"Order Pattern Role in System Dependencies Integration Points 1 Clean Architecture Structural foundation None Provides layer structure for all other patterns 2 Dependency Injection Service management foundation Clean Architecture Manages service lifetimes across all layers 3 CQRS &amp; Mediation Application layer organization Clean Architecture, DI Commands/Queries with mediator routing 4 Event-Driven Reactive domain workflows Clean Architecture, CQRS, DI Domain events published by command handlers 5 Event Sourcing Event-based persistence Event-Driven, Repository, DI Events as source of truth with aggregate patterns 6 Reactive Programming Asynchronous stream processing Event-Driven, DI Observable streams for real-time event processing 7 Repository Infrastructure abstraction Clean Architecture, DI Implements Integration layer data access 8 Resource-Oriented API contract definition Clean Architecture, CQRS, DI REST endpoints expose commands/queries 9 Watcher &amp; Reconciliation Reactive resource management Event-Driven, Repository, DI Observes events, updates via repositories"},{"location":"patterns/#implementation-order","title":"Implementation Order","text":"<pre><code>flowchart LR\n    A[1. Clean Architecture&lt;br/&gt;\ud83c\udfd7\ufe0f Layer Structure] --&gt; B[2. Dependency Injection&lt;br/&gt;\ud83d\udc89 Service Management]\n    B --&gt; C[3. CQRS &amp; Mediation&lt;br/&gt;\ud83d\udce1 Commands &amp; Queries]\n    C --&gt; D[4. Event-Driven&lt;br/&gt;\ud83d\udd04 Domain Events]\n    D --&gt; E[5. Event Sourcing&lt;br/&gt;\ud83c\udfaf Event Persistence]\n    E --&gt; F[6. Reactive Programming&lt;br/&gt;\ud83c\udf0a Stream Processing]\n    F --&gt; G[7. Repository Pattern&lt;br/&gt;\ud83d\udcbe Data Access]\n    G --&gt; H[8. Resource-Oriented&lt;br/&gt;\ud83c\udf10 API Design]\n    H --&gt; I[9. Watcher Patterns&lt;br/&gt;\ud83d\udc40 Reactive Management]\n\n    style A fill:#e8f5e8\n    style B fill:#f8bbd9\n    style C fill:#e3f2fd\n    style D fill:#fff3e0\n    style E fill:#ffecb5\n    style F fill:#b3e5fc\n    style G fill:#f3e5f5\n    style H fill:#e1f5fe\n    style I fill:#fce4ec</code></pre>"},{"location":"patterns/#business-domain-examples","title":"\ud83c\udfaf Business Domain Examples","text":"Domain Area Pattern Application Implementation Details Benefits Demonstrated \ud83c\udf55 Order Processing Clean Architecture + CQRS + Event Sourcing + DI Complete workflow from placement to delivery with event history Layer separation, mediation routing, audit trails, service management \ud83d\udccb Menu Management Repository + Resource-Oriented + DI Product catalog with pricing and availability via REST API Data abstraction, RESTful design, dependency management \ud83d\udc68\u200d\ud83c\udf73 Kitchen Operations Event-Driven + Reactive Programming + Watcher Patterns Real-time queue management with stream processing Reactive processing, observable streams, state synchronization \ud83d\udcf1 Customer Communications Event-Driven + Reactive Programming Real-time notifications through reactive event streams Stream processing, asynchronous messaging, real-time updates \ud83d\udcb3 Payment Processing Clean Architecture + Repository + DI External service integration with proper abstraction Infrastructure abstraction, testability, service integration \ud83d\udcca Analytics &amp; Reporting Event Sourcing + Reactive Programming Business intelligence from event streams with real-time views Temporal queries, stream aggregation, historical analysis"},{"location":"patterns/#testing-strategies","title":"\ud83e\uddea Testing Strategies","text":"Testing Type Scope Pattern Focus Tools &amp; Techniques Example Scenarios \ud83d\udd2c Unit Testing Individual components All patterns with isolated mocks pytest, Mock objects, dependency injection Test OrderEntity business logic, Command handlers \ud83d\udd17 Integration Testing Cross-layer interactions Clean Architecture layer communication TestClient, database containers Test API \u2192 Application \u2192 Domain flow \ud83c\udf10 End-to-End Testing Complete workflows Full pattern integration Automated scenarios, real dependencies Complete pizza order workflow validation \u26a1 Performance Testing Scalability validation CQRS read optimization, Event throughput Load testing, metrics collection Query performance, event processing rates"},{"location":"patterns/#pattern-learning-paths","title":"\ud83d\udcda Pattern Learning Paths","text":"Level Focus Area Recommended Patterns Learning Objectives Practical Outcomes \ud83c\udf31 Beginner Foundation &amp; Structure 1. Clean Architecture2. Domain Driven Design3. Dependency Injection4. Repository Pattern \u2022 Layer separation principles\u2022 Rich domain model design\u2022 Service lifetime management\u2022 Data access abstraction Pizza ordering system with rich domain models and proper DI \ud83d\ude80 Intermediate Separation &amp; Optimization 1. CQRS &amp; Mediation2. Event-Driven Architecture3. Resource-Oriented Architecture \u2022 Read/write operation separation\u2022 Mediator pattern usage\u2022 Event-driven workflows\u2022 RESTful API design Scalable pizza API with command/query separation and events \u26a1 Advanced Reactive &amp; Distributed 1. Event Sourcing2. Reactive Programming3. Watcher &amp; Reconciliation \u2022 Event-based persistence\u2022 Stream processing patterns\u2022 Reactive system design\u2022 State reconciliation strategies Complete event-sourced pizzeria with real-time capabilities"},{"location":"patterns/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\ud83d\ude80 Framework Features - Implementation-specific features</li> <li>\ud83d\udcd6 Implementation Guides - Step-by-step tutorials</li> <li>\ud83c\udf55 Mario's Pizzeria - Complete system example</li> <li>\ud83d\udcbc Sample Applications - Production-ready examples</li> <li>\ud83d\udd10 OAuth, OIDC &amp; JWT - Authentication and authorization patterns</li> </ul> <p>These patterns form the architectural foundation for building maintainable, testable, and scalable applications. Each pattern page includes detailed code examples, Mermaid diagrams, and practical implementation guidance using the Mario's Pizzeria domain.</p>"},{"location":"patterns/clean-architecture/","title":"\ud83c\udfd7\ufe0f Clean Architecture Pattern","text":"<p>Estimated reading time: 20 minutes</p> <p>The Clean Architecture pattern enforces a layered approach where dependencies only flow inward, ensuring testability, maintainability, and independence from external concerns.</p>"},{"location":"patterns/clean-architecture/#what-why","title":"\ud83c\udfaf What &amp; Why","text":""},{"location":"patterns/clean-architecture/#the-problem-tightly-coupled-layers","title":"The Problem: Tightly Coupled Layers","text":"<p>Without clean architecture, code becomes tangled with business logic mixed with infrastructure concerns:</p> <pre><code># \u274c Problem: Business logic tightly coupled to framework and database\nfrom fastapi import FastAPI, HTTPException\nfrom pymongo import MongoClient\nimport stripe\n\napp = FastAPI()\nmongo_client = MongoClient(\"mongodb://localhost:27017\")\ndb = mongo_client.pizzeria\n\n@app.post(\"/orders\")\nasync def place_order(order_data: dict):\n    # \u274c HTTP framework logic mixed with business logic\n    try:\n        # \u274c Database details in endpoint handler\n        customer = db.customers.find_one({\"_id\": order_data[\"customer_id\"]})\n        if not customer:\n            raise HTTPException(status_code=404, detail=\"Customer not found\")\n\n        # \u274c Business rules scattered in controller\n        subtotal = sum(item[\"price\"] for item in order_data[\"items\"])\n        tax = subtotal * 0.08\n        total = subtotal + tax\n\n        # \u274c Direct payment API call in controller\n        stripe.api_key = \"sk_test_...\"\n        charge = stripe.Charge.create(\n            amount=int(total * 100),\n            currency=\"usd\",\n            source=order_data[\"payment_token\"]\n        )\n\n        # \u274c Direct MongoDB operations\n        order_doc = {\n            \"customer_id\": order_data[\"customer_id\"],\n            \"items\": order_data[\"items\"],\n            \"total\": total,\n            \"status\": \"pending\",\n            \"stripe_charge_id\": charge.id\n        }\n        result = db.orders.insert_one(order_doc)\n\n        # \u274c HTTP response mixed with business logic\n        return {\n            \"order_id\": str(result.inserted_id),\n            \"total\": total,\n            \"status\": \"pending\"\n        }\n\n    except stripe.error.CardError as e:\n        # \u274c Infrastructure exceptions in business layer\n        raise HTTPException(status_code=402, detail=str(e))\n    except Exception as e:\n        # \u274c Generic error handling\n        raise HTTPException(status_code=500, detail=str(e))\n\n# \u274c Testing requires real MongoDB and Stripe\n# \u274c Can't swap database without rewriting entire endpoint\n# \u274c Business logic can't be reused for CLI or mobile app\n# \u274c Framework upgrade requires changing business logic\n</code></pre> <p>Problems with this approach:</p> <ol> <li>No Testability: Can't test without real database and payment service</li> <li>Tight Coupling: Business logic depends on FastAPI, MongoDB, Stripe</li> <li>No Reusability: Can't use order placement logic in CLI or batch jobs</li> <li>Hard to Maintain: Changes to infrastructure affect business logic</li> <li>Framework Lock-in: Stuck with FastAPI, can't migrate to another framework</li> <li>No Business Focus: Domain rules lost in infrastructure code</li> </ol>"},{"location":"patterns/clean-architecture/#the-solution-clean-architecture-with-layer-separation","title":"The Solution: Clean Architecture with Layer Separation","text":"<p>Separate concerns into layers with clear dependency direction:</p> <pre><code># \u2705 Solution: Layer 1 - Domain (Core Business Logic)\n# domain/entities/order.py\nfrom neuroglia.data.abstractions import Entity\n\nclass Order(Entity):\n    \"\"\"Pure business logic - no framework dependencies\"\"\"\n\n    def __init__(self, customer_id: str, items: List[OrderItem]):\n        super().__init__()\n        self.customer_id = customer_id\n        self.items = items\n        self.status = OrderStatus.PENDING\n        self.total = self._calculate_total()\n\n        # \u2705 Domain events for business occurrences\n        self.raise_event(OrderPlacedEvent(\n            order_id=self.id,\n            customer_id=customer_id,\n            total=self.total\n        ))\n\n    def _calculate_total(self) -&gt; Decimal:\n        \"\"\"\u2705 Business rule encapsulated in entity\"\"\"\n        subtotal = sum(item.price * item.quantity for item in self.items)\n        tax = subtotal * Decimal('0.08')  # 8% tax\n        return subtotal + tax\n\n# \u2705 Layer 2 - Application (Use Cases)\n# application/handlers/place_order_handler.py\nfrom neuroglia.mediation import CommandHandler\n\nclass PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    \"\"\"Orchestrates use case - depends only on abstractions\"\"\"\n\n    def __init__(\n        self,\n        order_repository: IOrderRepository,  # \u2705 Interface, not implementation\n        payment_service: IPaymentService,    # \u2705 Interface, not Stripe directly\n        mapper: Mapper\n    ):\n        self._repository = order_repository\n        self._payment = payment_service\n        self._mapper = mapper\n\n    async def handle_async(self, command: PlaceOrderCommand):\n        # \u2705 Use domain entity (business logic)\n        order = Order(command.customer_id, command.items)\n\n        # \u2705 Use abstraction (can swap implementations)\n        payment_result = await self._payment.process_async(\n            amount=order.total,\n            payment_method=command.payment_method\n        )\n\n        if not payment_result.success:\n            return self.bad_request(\"Payment failed\")\n\n        # \u2705 Use repository abstraction\n        await self._repository.save_async(order)\n\n        # \u2705 Return DTO, not entity\n        return self.created(self._mapper.map(order, OrderDto))\n\n# \u2705 Layer 3 - API (External Interface)\n# api/controllers/orders_controller.py\nfrom neuroglia.mvc import ControllerBase\n\nclass OrdersController(ControllerBase):\n    \"\"\"Thin controller - no business logic\"\"\"\n\n    @post(\"/\", response_model=OrderDto, status_code=201)\n    async def place_order(self, request: PlaceOrderRequest):\n        # \u2705 Map HTTP request to command\n        command = self.mapper.map(request, PlaceOrderCommand)\n\n        # \u2705 Delegate to mediator (no direct handler dependency)\n        result = await self.mediator.execute_async(command)\n\n        # \u2705 Process result (handles error codes)\n        return self.process(result)\n\n# \u2705 Layer 4 - Integration (Infrastructure)\n# integration/services/stripe_payment_service.py\nclass StripePaymentService(IPaymentService):\n    \"\"\"Implementation detail - can be swapped\"\"\"\n\n    async def process_async(\n        self,\n        amount: Decimal,\n        payment_method: str\n    ) -&gt; PaymentResult:\n        try:\n            charge = stripe.Charge.create(\n                amount=int(amount * 100),\n                currency=\"usd\",\n                source=payment_method\n            )\n            return PaymentResult(success=True, transaction_id=charge.id)\n        except stripe.error.CardError as e:\n            return PaymentResult(success=False, error=str(e))\n\n# integration/repositories/mongo_order_repository.py\nclass MongoOrderRepository(IOrderRepository):\n    \"\"\"Implementation detail - can be swapped\"\"\"\n\n    async def save_async(self, order: Order) -&gt; None:\n        doc = self._entity_to_document(order)\n        await self._collection.insert_one(doc)\n</code></pre> <p>Benefits of clean architecture:</p> <ol> <li>Testability: Test business logic without infrastructure</li> <li>Flexibility: Swap MongoDB for PostgreSQL without changing business logic</li> <li>Reusability: Use same handlers for API, CLI, or background jobs</li> <li>Maintainability: Infrastructure changes don't affect domain</li> <li>Framework Independence: Business logic doesn't depend on FastAPI</li> <li>Business Focus: Domain logic is pure and clear</li> </ol>"},{"location":"patterns/clean-architecture/#understanding-clean-architecture","title":"\ud83c\udf93 Understanding Clean Architecture","text":"<p>Before diving into code, it's helpful to understand the architectural principles that guide Neuroglia:</p>"},{"location":"patterns/clean-architecture/#the-dependency-rule","title":"The Dependency Rule","text":"<pre><code>graph TD\n    A[\ud83c\udf10 API Layer&lt;br/&gt;Controllers, DTOs] --&gt; B[\ud83d\udcbc Application Layer&lt;br/&gt;Commands, Queries, Handlers]\n    B --&gt; C[\ud83c\udfdb\ufe0f Domain Layer&lt;br/&gt;Entities, Business Rules]\n    D[\ud83d\udd0c Integration Layer&lt;br/&gt;Repositories, External APIs] --&gt; C\n\n    style C fill:#e1f5fe\n    style B fill:#f3e5f5\n    style A fill:#e8f5e8\n    style D fill:#fff3e0</code></pre> <p>Key principle: Inner layers never depend on outer layers. This enables:</p> <ul> <li>Testability - Easy to mock external dependencies</li> <li>Flexibility - Swap implementations without affecting business logic</li> <li>Maintainability - Changes in infrastructure don't break business rules</li> <li>Domain Focus - Business logic stays pure and framework-agnostic</li> </ul>"},{"location":"patterns/clean-architecture/#cqrs-in-practice","title":"CQRS in Practice","text":"<pre><code>graph LR\n    A[Client Request] --&gt; B{Command or Query?}\n    B --&gt;|Write Operation| C[Command Handler]\n    B --&gt;|Read Operation| D[Query Handler]\n    C --&gt; E[Domain Logic]\n    E --&gt; F[Repository]\n    D --&gt; G[Read Model]\n\n    style C fill:#ffcdd2\n    style D fill:#c8e6c9\n    style E fill:#e1f5fe</code></pre> <p>Commands (Write): Create, Update, Delete operations that change system state Queries (Read): Retrieve operations that return data without side effects</p> <p>This separation enables:</p> <ul> <li>Performance Optimization - Different models for reads vs writes</li> <li>Scalability - Scale read and write operations independently</li> <li>Clarity - Clear intent whether operation changes state</li> <li>Event Sourcing - Natural fit for event-driven architectures</li> </ul>"},{"location":"patterns/clean-architecture/#overview","title":"\ud83c\udfaf Overview","text":"<p>Clean Architecture organizes code into four distinct layers, with the Mario's Pizzeria system serving as our primary example of how this pattern enables scalable, maintainable applications.</p> <pre><code>C4Container\n    title Clean Architecture - Mario's Pizzeria System\n\n    Container_Boundary(api, \"\ud83c\udf10 API Layer\") {\n        Container(orders_controller, \"Orders Controller\", \"FastAPI\", \"REST endpoints for pizza orders\")\n        Container(menu_controller, \"Menu Controller\", \"FastAPI\", \"Menu management and retrieval\")\n        Container(kitchen_controller, \"Kitchen Controller\", \"FastAPI\", \"Kitchen workflow management\")\n    }\n\n    Container_Boundary(app, \"\ud83d\udcbc Application Layer\") {\n        Container(mediator, \"Mediator\", \"CQRS\", \"Command/Query routing\")\n        Container(handlers, \"Command/Query Handlers\", \"Business Logic\", \"Order processing, menu queries\")\n        Container(pipeline, \"Pipeline Behaviors\", \"Cross-cutting\", \"Validation, logging, caching\")\n    }\n\n    Container_Boundary(domain, \"\ud83c\udfdb\ufe0f Domain Layer\") {\n        Container(entities, \"Pizza Entities\", \"Domain Models\", \"Order, Pizza, Customer entities\")\n        Container(events, \"Domain Events\", \"Business Events\", \"OrderPlaced, PizzaReady events\")\n        Container(rules, \"Business Rules\", \"Domain Logic\", \"Pricing, validation rules\")\n    }\n\n    Container_Boundary(integration, \"\ud83d\udd0c Integration Layer\") {\n        Container(repos, \"Repositories\", \"Data Access\", \"Order, Menu data persistence\")\n        Container(external, \"External Services\", \"Third-party\", \"Payment, SMS notifications\")\n        Container(storage, \"Data Storage\", \"Persistence\", \"MongoDB, File System\")\n    }\n\n    Rel(orders_controller, mediator, \"sends commands/queries\")\n    Rel(menu_controller, mediator, \"sends queries\")\n    Rel(kitchen_controller, mediator, \"sends commands\")\n\n    Rel(mediator, handlers, \"routes to\")\n    Rel(handlers, entities, \"uses\")\n    Rel(handlers, events, \"publishes\")\n\n    Rel(handlers, repos, \"persists via\")\n    Rel(repos, storage, \"stores in\")\n    Rel(handlers, external, \"integrates with\")</code></pre>"},{"location":"patterns/clean-architecture/#benefits","title":"\u2705 Benefits","text":""},{"location":"patterns/clean-architecture/#1-testability","title":"1. Testability","text":"<p>Each layer can be tested independently using mocks and stubs:</p> <pre><code># Testing Order Handler without database dependencies\nclass TestPlaceOrderHandler:\n    def setup_method(self):\n        self.mock_repository = Mock(spec=OrderRepository)\n        self.mock_payment = Mock(spec=PaymentService)\n        self.handler = PlaceOrderHandler(self.mock_repository, self.mock_payment)\n\n    async def test_place_order_success(self):\n        # Arrange\n        command = PlaceOrderCommand(customer_id=\"123\", pizzas=[\"margherita\"])\n\n        # Act\n        result = await self.handler.handle_async(command)\n\n        # Assert\n        assert result.is_success\n        self.mock_repository.save_async.assert_called_once()\n</code></pre>"},{"location":"patterns/clean-architecture/#2-independence","title":"2. Independence","text":"<p>Business logic in the domain layer is completely independent of frameworks, databases, and external services.</p>"},{"location":"patterns/clean-architecture/#3-maintainability","title":"3. Maintainability","text":"<p>Changes to external systems (databases, APIs) don't affect business logic.</p>"},{"location":"patterns/clean-architecture/#data-flow","title":"\ud83d\udd04 Data Flow","text":"<p>The pizza ordering workflow demonstrates clean architecture data flow:</p> <pre><code>sequenceDiagram\n    participant Customer\n    participant API as OrdersController\n    participant Med as Mediator\n    participant Handler as PlaceOrderHandler\n    participant Domain as Order Entity\n    participant Repo as OrderRepository\n    participant DB as MongoDB\n\n    Customer-&gt;&gt;+API: POST /orders (pizza order)\n    Note over API: \ud83c\udf10 API Layer - HTTP endpoint\n\n    API-&gt;&gt;+Med: Execute PlaceOrderCommand\n    Note over Med: \ud83d\udcbc Application Layer - CQRS routing\n\n    Med-&gt;&gt;+Handler: Handle command\n    Note over Handler: \ud83d\udcbc Application Layer - Business workflow\n\n    Handler-&gt;&gt;+Domain: Create Order entity\n    Note over Domain: \ud83c\udfdb\ufe0f Domain Layer - Business rules\n    Domain--&gt;&gt;-Handler: Order with domain events\n\n    Handler-&gt;&gt;+Repo: Save order\n    Note over Repo: \ud83d\udd0c Integration Layer - Data access\n    Repo-&gt;&gt;+DB: Insert document\n    Note over DB: \ud83d\udd0c Integration Layer - Persistence\n    DB--&gt;&gt;-Repo: Success\n    Repo--&gt;&gt;-Handler: Order saved\n\n    Handler--&gt;&gt;-Med: OrderDto result\n    Med--&gt;&gt;-API: Success response\n    API--&gt;&gt;-Customer: 201 Created + OrderDto</code></pre>"},{"location":"patterns/clean-architecture/#use-cases","title":"\ud83c\udfaf Use Cases","text":"<p>Clean Architecture is ideal for:</p> <ul> <li>Complex Business Logic: When domain rules are intricate (pricing, promotions, kitchen workflows)</li> <li>Multiple Interfaces: Supporting web APIs, mobile apps, and admin panels</li> <li>Long-term Maintenance: Systems that need to evolve over time</li> <li>Team Collaboration: Clear boundaries enable parallel development</li> </ul>"},{"location":"patterns/clean-architecture/#implementation-in-marios-pizzeria","title":"\ud83c\udf55 Implementation in Mario's Pizzeria","text":""},{"location":"patterns/clean-architecture/#domain-layer-core-business","title":"Domain Layer (Core Business)","text":"<pre><code># domain/entities/order.py\nclass Order(Entity):\n    def __init__(self, customer_id: str, items: List[OrderItem]):\n        super().__init__()\n        self.customer_id = customer_id\n        self.items = items\n        self.status = OrderStatus.PENDING\n        self.total = self._calculate_total()\n\n        # Domain event for business workflow\n        self.raise_event(OrderPlacedEvent(\n            order_id=self.id,\n            customer_id=customer_id,\n            total=self.total\n        ))\n\n    def _calculate_total(self) -&gt; Decimal:\n        \"\"\"Business rule: Calculate order total with tax\"\"\"\n        subtotal = sum(item.price for item in self.items)\n        tax = subtotal * Decimal('0.08')  # 8% tax\n        return subtotal + tax\n</code></pre>"},{"location":"patterns/clean-architecture/#application-layer-use-cases","title":"Application Layer (Use Cases)","text":"<pre><code># application/handlers/place_order_handler.py\nclass PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    def __init__(self,\n                 order_repository: OrderRepository,\n                 payment_service: PaymentService,\n                 mapper: Mapper):\n        self._repository = order_repository\n        self._payment = payment_service\n        self._mapper = mapper\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        # Create domain entity (business logic)\n        order = Order(command.customer_id, command.items)\n\n        # Process payment (external integration)\n        payment_result = await self._payment.process_async(order.total)\n        if not payment_result.success:\n            return self.bad_request(\"Payment failed\")\n\n        # Persist order (data access)\n        await self._repository.save_async(order)\n\n        # Return result\n        dto = self._mapper.map(order, OrderDto)\n        return self.created(dto)\n</code></pre>"},{"location":"patterns/clean-architecture/#api-layer-interface","title":"API Layer (Interface)","text":"<pre><code># api/controllers/orders_controller.py\nclass OrdersController(ControllerBase):\n    @post(\"/\", response_model=OrderDto, status_code=201)\n    async def place_order(self, request: PlaceOrderRequest) -&gt; OrderDto:\n        command = self.mapper.map(request, PlaceOrderCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"patterns/clean-architecture/#integration-layer-external-concerns","title":"Integration Layer (External Concerns)","text":"<pre><code># integration/repositories/mongo_order_repository.py\nclass MongoOrderRepository(Repository[Order, str]):\n    def __init__(self, collection: Collection):\n        self._collection = collection\n\n    async def save_async(self, order: Order) -&gt; None:\n        document = {\n            \"_id\": order.id,\n            \"customer_id\": order.customer_id,\n            \"items\": [{\"name\": item.name, \"price\": float(item.price)}\n                     for item in order.items],\n            \"total\": float(order.total),\n            \"status\": order.status.value\n        }\n        await self._collection.insert_one(document)\n</code></pre>"},{"location":"patterns/clean-architecture/#testing-clean-architecture","title":"\ud83e\uddea Testing Clean Architecture","text":""},{"location":"patterns/clean-architecture/#unit-testing-domain-layer","title":"Unit Testing Domain Layer","text":"<pre><code>import pytest\nfrom decimal import Decimal\n\nclass TestOrderEntity:\n    def test_order_calculates_total_with_tax(self):\n        # Arrange\n        items = [\n            OrderItem(pizza_name=\"Margherita\", price=Decimal(\"12.99\"), quantity=2),\n            OrderItem(pizza_name=\"Pepperoni\", price=Decimal(\"14.99\"), quantity=1)\n        ]\n\n        # Act\n        order = Order(customer_id=\"cust_123\", items=items)\n\n        # Assert\n        expected_subtotal = Decimal(\"40.97\")  # 12.99*2 + 14.99\n        expected_tax = expected_subtotal * Decimal(\"0.08\")\n        expected_total = expected_subtotal + expected_tax\n        assert order.total == expected_total\n\n    def test_order_raises_domain_event(self):\n        # Arrange\n        items = [OrderItem(pizza_name=\"Margherita\", price=Decimal(\"12.99\"), quantity=1)]\n\n        # Act\n        order = Order(customer_id=\"cust_123\", items=items)\n\n        # Assert\n        events = order.get_uncommitted_events()\n        assert len(events) == 1\n        assert isinstance(events[0], OrderPlacedEvent)\n        assert events[0].order_id == order.id\n</code></pre>"},{"location":"patterns/clean-architecture/#unit-testing-application-layer","title":"Unit Testing Application Layer","text":"<pre><code>@pytest.mark.asyncio\nasync def test_place_order_handler_success():\n    # Arrange\n    mock_repository = AsyncMock(spec=IOrderRepository)\n    mock_payment = AsyncMock(spec=IPaymentService)\n    mock_payment.process_async.return_value = PaymentResult(success=True)\n\n    handler = PlaceOrderHandler(mock_repository, mock_payment, Mock())\n\n    command = PlaceOrderCommand(\n        customer_id=\"cust_123\",\n        items=[OrderItemDto(pizza_name=\"Margherita\", price=\"12.99\", quantity=1)],\n        payment_method=\"card\"\n    )\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n    mock_payment.process_async.assert_called_once()\n    mock_repository.save_async.assert_called_once()\n\n@pytest.mark.asyncio\nasync def test_place_order_handler_payment_failure():\n    # Arrange\n    mock_repository = AsyncMock(spec=IOrderRepository)\n    mock_payment = AsyncMock(spec=IPaymentService)\n    mock_payment.process_async.return_value = PaymentResult(\n        success=False,\n        error=\"Card declined\"\n    )\n\n    handler = PlaceOrderHandler(mock_repository, mock_payment, Mock())\n    command = PlaceOrderCommand(customer_id=\"cust_123\", items=[], payment_method=\"card\")\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert not result.is_success\n    assert \"Payment failed\" in result.error_message\n    mock_repository.save_async.assert_not_called()\n</code></pre>"},{"location":"patterns/clean-architecture/#integration-testing","title":"Integration Testing","text":"<pre><code>@pytest.mark.integration\n@pytest.mark.asyncio\nasync def test_complete_order_workflow():\n    # Arrange - use test app with real mediator and in-memory repositories\n    app = create_test_app()\n    client = TestClient(app)\n\n    order_data = {\n        \"customer_id\": \"test_customer\",\n        \"items\": [\n            {\"pizza_name\": \"Margherita\", \"price\": \"12.99\", \"quantity\": 2}\n        ],\n        \"payment_method\": \"card\"\n    }\n\n    # Act\n    response = client.post(\"/api/orders\", json=order_data)\n\n    # Assert\n    assert response.status_code == 201\n    result = response.json()\n    assert \"order_id\" in result\n    assert result[\"total\"] == \"27.95\"  # (12.99 * 2) * 1.08\n</code></pre>"},{"location":"patterns/clean-architecture/#common-mistakes","title":"\u26a0\ufe0f Common Mistakes","text":""},{"location":"patterns/clean-architecture/#1-layer-violations-breaking-dependency-rule","title":"1. Layer Violations (Breaking Dependency Rule)","text":"<pre><code># \u274c Wrong - Domain layer depends on infrastructure\nfrom pymongo import Collection  # \u274c Infrastructure import in domain\n\nclass Order(Entity):\n    def __init__(self, customer_id: str, collection: Collection):\n        # \u274c Domain entity depends on MongoDB\n        self.collection = collection\n\n    async def save(self):\n        # \u274c Domain entity performing data access\n        await self.collection.insert_one(self.__dict__)\n\n# \u2705 Correct - Domain layer has no infrastructure dependencies\nclass Order(Entity):\n    def __init__(self, customer_id: str, items: List[OrderItem]):\n        # \u2705 Pure business logic only\n        self.customer_id = customer_id\n        self.items = items\n        self.total = self._calculate_total()\n\n    # \u2705 Repository handles persistence (integration layer)\n</code></pre>"},{"location":"patterns/clean-architecture/#2-business-logic-in-controllers","title":"2. Business Logic in Controllers","text":"<pre><code># \u274c Wrong - Business logic in API layer\nclass OrdersController(ControllerBase):\n    @post(\"/orders\")\n    async def place_order(self, request: dict):\n        # \u274c Tax calculation in controller\n        subtotal = sum(item[\"price\"] for item in request[\"items\"])\n        tax = subtotal * 0.08\n        total = subtotal + tax\n\n        # \u274c Validation in controller\n        if total &gt; 1000:\n            return {\"error\": \"Order too large\"}\n\n        order_doc = {\"total\": total, \"items\": request[\"items\"]}\n        await self._db.orders.insert_one(order_doc)\n        return order_doc\n\n# \u2705 Correct - Thin controller delegates to application layer\nclass OrdersController(ControllerBase):\n    @post(\"/orders\", response_model=OrderDto)\n    async def place_order(self, request: PlaceOrderRequest):\n        # \u2705 Map and delegate\n        command = self.mapper.map(request, PlaceOrderCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"patterns/clean-architecture/#3-direct-repository-dependencies-in-controllers","title":"3. Direct Repository Dependencies in Controllers","text":"<pre><code># \u274c Wrong - Controller directly uses repository\nclass OrdersController:\n    def __init__(self, order_repository: IOrderRepository):\n        # \u274c Controller depends on repository\n        self._repository = order_repository\n\n    @post(\"/orders\")\n    async def place_order(self, request: dict):\n        order = Order(**request)\n        # \u274c Controller calling repository directly\n        await self._repository.save_async(order)\n        return order\n\n# \u2705 Correct - Controller uses mediator\nclass OrdersController(ControllerBase):\n    # \u2705 Only depends on base class (provides mediator)\n\n    @post(\"/orders\", response_model=OrderDto)\n    async def place_order(self, request: PlaceOrderRequest):\n        # \u2705 Uses mediator for all operations\n        command = self.mapper.map(request, PlaceOrderCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"patterns/clean-architecture/#4-returning-domain-entities-from-api","title":"4. Returning Domain Entities from API","text":"<pre><code># \u274c Wrong - Exposing domain entities to API\nclass OrdersController(ControllerBase):\n    @get(\"/orders/{order_id}\")\n    async def get_order(self, order_id: str) -&gt; Order:  # \u274c Returns entity\n        query = GetOrderQuery(order_id=order_id)\n        order = await self.mediator.execute_async(query)\n        return order  # \u274c Exposing domain entity\n\n# \u2705 Correct - Return DTOs\nclass OrdersController(ControllerBase):\n    @get(\"/orders/{order_id}\", response_model=OrderDto)  # \u2705 Returns DTO\n    async def get_order(self, order_id: str) -&gt; OrderDto:\n        query = GetOrderQuery(order_id=order_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)  # \u2705 Returns mapped DTO\n</code></pre>"},{"location":"patterns/clean-architecture/#5-mixing-infrastructure-code-in-application-layer","title":"5. Mixing Infrastructure Code in Application Layer","text":"<pre><code># \u274c Wrong - Application layer with infrastructure details\nclass PlaceOrderHandler(CommandHandler):\n    async def handle_async(self, command: PlaceOrderCommand):\n        # \u274c Direct MongoDB access in handler\n        from pymongo import MongoClient\n        client = MongoClient(\"mongodb://localhost\")\n        db = client.pizzeria\n\n        order_doc = {\"customer_id\": command.customer_id}\n        await db.orders.insert_one(order_doc)\n\n# \u2705 Correct - Application layer uses abstractions\nclass PlaceOrderHandler(CommandHandler):\n    def __init__(self, repository: IOrderRepository):\n        # \u2705 Depends on interface\n        self._repository = repository\n\n    async def handle_async(self, command: PlaceOrderCommand):\n        order = Order(command.customer_id, command.items)\n        # \u2705 Uses repository abstraction\n        await self._repository.save_async(order)\n</code></pre>"},{"location":"patterns/clean-architecture/#6-anemic-domain-models","title":"6. Anemic Domain Models","text":"<pre><code># \u274c Wrong - Domain entity with no behavior\nclass Order:\n    def __init__(self):\n        self.customer_id = None\n        self.items = []\n        self.total = 0\n        # \u274c Just a data bag, no business logic\n\n# Business logic scattered in handlers\nclass PlaceOrderHandler:\n    async def handle_async(self, command: PlaceOrderCommand):\n        order = Order()\n        order.customer_id = command.customer_id\n        order.items = command.items\n        # \u274c Calculating total in handler\n        order.total = sum(item.price for item in order.items) * 1.08\n\n# \u2705 Correct - Rich domain model with behavior\nclass Order(Entity):\n    def __init__(self, customer_id: str, items: List[OrderItem]):\n        # \u2705 Business logic in entity\n        self.customer_id = customer_id\n        self.items = items\n        self.total = self._calculate_total()\n        self.raise_event(OrderPlacedEvent(...))\n\n    def _calculate_total(self) -&gt; Decimal:\n        # \u2705 Business rule encapsulated\n        subtotal = sum(item.price * item.quantity for item in self.items)\n        return subtotal * Decimal(\"1.08\")\n\n    def apply_discount(self, percentage: Decimal):\n        # \u2705 Business behavior on entity\n        if percentage &gt; Decimal(\"0.5\"):\n            raise ValueError(\"Discount cannot exceed 50%\")\n        self.total = self.total * (Decimal(\"1\") - percentage)\n</code></pre>"},{"location":"patterns/clean-architecture/#when-not-to-use","title":"\ud83d\udeab When NOT to Use","text":""},{"location":"patterns/clean-architecture/#1-simple-crud-applications","title":"1. Simple CRUD Applications","text":"<p>For basic applications with minimal business logic:</p> <pre><code># Clean architecture is overkill for simple CRUD\n@app.get(\"/pizzas\")\nasync def get_pizzas(db: Database):\n    return await db.pizzas.find().to_list(None)\n\n@app.post(\"/pizzas\")\nasync def create_pizza(pizza: PizzaDto, db: Database):\n    result = await db.pizzas.insert_one(pizza.dict())\n    return {\"id\": str(result.inserted_id)}\n</code></pre>"},{"location":"patterns/clean-architecture/#2-prototypes-and-proof-of-concepts","title":"2. Prototypes and Proof of Concepts","text":"<p>When rapidly testing ideas without long-term maintenance needs:</p> <pre><code># Quick prototype - simple FastAPI endpoints sufficient\n@app.post(\"/orders\")\nasync def place_order(order_data: dict, db: Database):\n    # Direct implementation without layers\n    result = await db.orders.insert_one(order_data)\n    return {\"order_id\": str(result.inserted_id)}\n</code></pre>"},{"location":"patterns/clean-architecture/#3-single-purpose-scripts","title":"3. Single-Purpose Scripts","text":"<p>For one-off data migration or batch processing scripts:</p> <pre><code># Simple script doesn't need architecture layers\nimport pymongo\n\nclient = pymongo.MongoClient(\"mongodb://localhost\")\ndb = client.pizzeria\n\n# Direct operations\nfor order in db.orders.find({\"status\": \"pending\"}):\n    db.orders.update_one({\"_id\": order[\"_id\"]}, {\"$set\": {\"status\": \"completed\"}})\n</code></pre>"},{"location":"patterns/clean-architecture/#4-very-small-teams-without-architecture-experience","title":"4. Very Small Teams Without Architecture Experience","text":"<p>When team lacks experience with layered architecture:</p> <pre><code># Simple service pattern may be better\nclass OrderService:\n    def __init__(self, db: Database):\n        self.db = db\n\n    async def create_order(self, order_data: dict):\n        return await self.db.orders.insert_one(order_data)\n</code></pre>"},{"location":"patterns/clean-architecture/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ol> <li>Dependency Rule: Dependencies flow inward - outer layers depend on inner layers</li> <li>Four Layers: API \u2192 Application \u2192 Domain \u2190 Integration</li> <li>Domain Independence: Business logic has no framework or infrastructure dependencies</li> <li>Testability: Test each layer independently with mocks</li> <li>Abstractions: Application layer depends on interfaces, not implementations</li> <li>DTOs at Boundaries: API layer uses DTOs, not domain entities</li> <li>Rich Domain Models: Entities contain business logic, not just data</li> <li>Single Responsibility: Each layer has clear, focused responsibilities</li> <li>Framework Independence: Business logic doesn't depend on FastAPI, Django, etc.</li> <li>Long-Term Maintainability: Architecture supports evolution and scaling</li> </ol>"},{"location":"patterns/clean-architecture/#related-patterns","title":"\ud83d\udd17 Related Patterns","text":"<ul> <li>CQRS Pattern - Separates commands and queries within the application layer</li> <li>Event-Driven Architecture - Uses domain events for decoupled communication</li> <li>Repository Pattern - Abstracts data access in the integration layer</li> <li>Domain-Driven Design - Rich domain models with business behavior</li> <li>Dependency Injection - Wires abstractions to implementations</li> </ul> <p>This pattern guide demonstrates Clean Architecture using Mario's Pizzeria as a practical example. The four-layer approach shown here scales from simple applications to complex enterprise systems. \ud83c\udfd7\ufe0f</p>"},{"location":"patterns/cqrs/","title":"\ud83c\udfaf CQRS &amp; Mediation Pattern","text":"<p>Estimated reading time: 25 minutes</p> <p>Command Query Responsibility Segregation (CQRS) with Mediation separates read and write operations into distinct models while using a mediator to decouple application logic and promote clean separation between commands, queries, and their handlers. This pattern combines the scalability benefits of CQRS with the architectural benefits of the mediator pattern.</p>"},{"location":"patterns/cqrs/#what-why","title":"\ud83c\udfaf What &amp; Why","text":""},{"location":"patterns/cqrs/#the-problem-mixed-readwrite-concerns","title":"The Problem: Mixed Read/Write Concerns","text":"<p>Without CQRS, controllers directly call services that handle both reads and writes, creating tight coupling and performance bottlenecks:</p> <pre><code># \u274c Problem: Single service handles both reads and writes\nclass OrderService:\n    def __init__(\n        self,\n        order_repository: OrderRepository,\n        payment_service: PaymentService,\n        inventory_service: InventoryService,\n        kitchen_service: KitchenService,\n        notification_service: NotificationService,\n        analytics_service: AnalyticsService\n    ):\n        # Service has too many responsibilities\n        self._order_repo = order_repository\n        self._payment = payment_service\n        self._inventory = inventory_service\n        self._kitchen = kitchen_service\n        self._notification = notification_service\n        self._analytics = analytics_service\n\n    async def place_order(self, order_data: dict) -&gt; Order:\n        # \u274c Complex write operation mixed with business logic\n        order = Order(**order_data)\n        await self._payment.process_payment(order)\n        await self._inventory.reserve_ingredients(order)\n        await self._order_repo.save(order)\n        await self._kitchen.add_to_queue(order)\n        await self._notification.send_confirmation(order)\n        return order\n\n    async def get_order_history(self, customer_id: str) -&gt; List[Order]:\n        # \u274c Simple read operation uses same service as complex writes\n        orders = await self._order_repo.find_by_customer(customer_id)\n        # \u274c Returns full entities even when only summary data needed\n        return orders\n\n    async def get_menu(self) -&gt; List[Pizza]:\n        # \u274c Can't cache or optimize reads separately from writes\n        return await self._pizza_repo.find_all()\n\n# Controller tightly coupled to service\nclass OrdersController:\n    def __init__(self, order_service: OrderService):\n        self._order_service = order_service\n\n    async def place_order(self, request: dict):\n        # \u274c Controller knows about service implementation details\n        return await self._order_service.place_order(request)\n\n    async def get_orders(self, customer_id: str):\n        # \u274c Same service for reads and writes - can't scale independently\n        return await self._order_service.get_order_history(customer_id)\n</code></pre> <p>Problems with this approach:</p> <ol> <li>Mixed Responsibilities: Service handles both reads and writes</li> <li>No Optimization: Can't optimize reads separately from writes</li> <li>Tight Coupling: Controller depends directly on service</li> <li>Poor Testability: Must mock entire service for simple tests</li> <li>No Cross-Cutting Concerns: Validation, caching, logging duplicated everywhere</li> <li>Scaling Issues: Read-heavy operations slow down writes</li> </ol>"},{"location":"patterns/cqrs/#the-solution-cqrs-with-mediation","title":"The Solution: CQRS with Mediation","text":"<p>Separate commands (writes) from queries (reads) and use a mediator to route requests:</p> <pre><code># \u2705 Solution: Separate command for writes\n@dataclass\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    customer_id: str\n    items: List[OrderItemDto]\n    delivery_address: str\n    payment_method: str\n\nclass PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    def __init__(\n        self,\n        repository: IOrderRepository,\n        mapper: Mapper\n    ):\n        # \u2705 Handler only depends on what it needs\n        self._repository = repository\n        self._mapper = mapper\n\n    async def handle_async(self, command: PlaceOrderCommand):\n        # \u2705 Focused on single responsibility: order placement\n        order = Order.create(\n            command.customer_id,\n            command.items,\n            command.delivery_address\n        )\n\n        await self._repository.save_async(order)\n\n        # \u2705 Domain events automatically published\n        return self.created(self._mapper.map(order, OrderDto))\n\n# \u2705 Solution: Separate query for reads\n@dataclass\nclass GetOrderHistoryQuery(Query[List[OrderSummaryDto]]):\n    customer_id: str\n    page: int = 1\n    page_size: int = 20\n\nclass GetOrderHistoryHandler(QueryHandler[GetOrderHistoryQuery, List[OrderSummaryDto]]):\n    def __init__(self, read_repository: IOrderReadRepository):\n        # \u2705 Uses optimized read repository\n        self._read_repo = read_repository\n\n    async def handle_async(self, query: GetOrderHistoryQuery):\n        # \u2705 Optimized for reading with denormalized data\n        orders = await self._read_repo.get_customer_history_async(\n            query.customer_id,\n            query.page,\n            query.page_size\n        )\n\n        # \u2705 Returns lightweight DTOs, not full entities\n        return [OrderSummaryDto(\n            order_id=o.id,\n            total=o.total,\n            status=o.status,\n            order_date=o.created_at\n        ) for o in orders]\n\n# \u2705 Controller uses mediator - no direct dependencies\nclass OrdersController(ControllerBase):\n    # \u2705 No service dependencies - only mediator\n\n    @post(\"/\", response_model=OrderDto, status_code=201)\n    async def place_order(self, request: PlaceOrderRequest):\n        # \u2705 Mediator routes to appropriate handler\n        command = self.mapper.map(request, PlaceOrderCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @get(\"/history\", response_model=List[OrderSummaryDto])\n    async def get_history(self, customer_id: str, page: int = 1):\n        # \u2705 Separate query handler with optimized read model\n        query = GetOrderHistoryQuery(customer_id=customer_id, page=page)\n        result = await self.mediator.execute_async(query)\n        return result\n</code></pre> <p>Benefits of CQRS with Mediation:</p> <ol> <li>Clear Separation: Commands write, queries read - single responsibility</li> <li>Independent Optimization: Optimize reads and writes separately</li> <li>Loose Coupling: Controllers don't know about handlers</li> <li>Easy Testing: Test handlers in isolation with minimal mocks</li> <li>Cross-Cutting Concerns: Pipeline behaviors handle validation, caching, logging</li> <li>Independent Scaling: Scale read and write sides independently</li> <li>Event-Driven: Commands naturally produce domain events</li> </ol>"},{"location":"patterns/cqrs/#overview","title":"\ud83c\udfaf Overview","text":"<p>CQRS divides your application's operations into two distinct paths: Commands for writes (state changes) and Queries for reads (data retrieval). Mario's Pizzeria demonstrates this pattern through its order management and menu systems.</p> <pre><code>flowchart TD\n    Client[Customer/Staff]\n\n    subgraph \"\ud83c\udfaf CQRS Separation\"\n        subgraph Commands[\"\ud83d\udcdd Write Side (Commands)\"]\n            PlaceOrder[PlaceOrderCommand]\n            UpdateMenu[UpdateMenuCommand]\n            ProcessPayment[ProcessPaymentCommand]\n        end\n\n        subgraph Queries[\"\ud83d\udcd6 Read Side (Queries)\"]\n            GetMenu[GetMenuQuery]\n            GetOrder[GetOrderByIdQuery]\n            GetOrderHistory[GetOrderHistoryQuery]\n        end\n    end\n\n    subgraph Mediator[\"\ud83c\udfad Mediator\"]\n        CommandHandlers[Command Handlers]\n        QueryHandlers[Query Handlers]\n    end\n\n    subgraph Storage[\"\ud83d\udcbe Data Storage\"]\n        WriteDB[(Write Database&lt;br/&gt;MongoDB)]\n        ReadDB[(Read Models&lt;br/&gt;Optimized Views)]\n        EventStore[(Event Store&lt;br/&gt;Order History)]\n    end\n\n    Client --&gt;|\"\ud83c\udf55 Place Order\"| PlaceOrder\n    Client --&gt;|\"\ud83d\udccb Get Menu\"| GetMenu\n    Client --&gt;|\"\ud83d\udcca Order Status\"| GetOrder\n\n    PlaceOrder --&gt; CommandHandlers\n    GetMenu --&gt; QueryHandlers\n    GetOrder --&gt; QueryHandlers\n\n    CommandHandlers --&gt;|\"\ud83d\udcbe Persist\"| WriteDB\n    CommandHandlers --&gt;|\"\ud83d\udce1 Events\"| EventStore\n    QueryHandlers --&gt;|\"\ud83d\udd0d Read\"| ReadDB\n\n    WriteDB -.-&gt;|\"\ud83d\udd04 Sync\"| ReadDB\n    EventStore -.-&gt;|\"\ud83d\udcc8 Project\"| ReadDB</code></pre>"},{"location":"patterns/cqrs/#mediation-pattern-integration","title":"\ud83c\udfad Mediation Pattern Integration","text":"<p>The mediation layer provides centralized request routing and cross-cutting concerns:</p> <ul> <li>Mediator: Central dispatcher that routes commands, queries, and events to appropriate handlers</li> <li>Pipeline Behaviors: Cross-cutting concerns like validation, logging, caching, and transactions</li> <li>Handler Discovery: Automatic registration and resolution of command/query handlers</li> <li>Event Publishing: Automatic dispatch of domain events to registered event handlers</li> </ul>"},{"location":"patterns/cqrs/#mediator-architecture","title":"Mediator Architecture","text":"<pre><code>flowchart TD\n    Controller[\ud83c\udfae Controller]\n    Mediator[\ud83c\udfad Mediator]\n\n    subgraph \"\ud83d\udccb Pipeline Behaviors\"\n        Validation[\u2705 Validation]\n        Logging[\ud83d\udcdd Logging]\n        Caching[\ud83d\udcbe Caching]\n        Transaction[\ud83d\udd04 Transaction]\n    end\n\n    subgraph \"\ud83c\udfaf Handlers\"\n        CommandHandler[\ud83d\udcdd Command Handler]\n        QueryHandler[\ud83d\udcd6 Query Handler]\n        EventHandler[\ud83d\udce1 Event Handler]\n    end\n\n    subgraph \"\ud83d\udcbe Infrastructure\"\n        Database[(\ud83d\uddc4\ufe0f Database)]\n        EventStore[(\ud83d\udcda Event Store)]\n        Cache[(\u26a1 Cache)]\n    end\n\n    Controller --&gt; Mediator\n    Mediator --&gt; Validation\n    Validation --&gt; Logging\n    Logging --&gt; Caching\n    Caching --&gt; Transaction\n\n    Transaction --&gt; CommandHandler\n    Transaction --&gt; QueryHandler\n    CommandHandler --&gt; EventHandler\n\n    CommandHandler --&gt; Database\n    QueryHandler --&gt; Database\n    EventHandler --&gt; EventStore\n    QueryHandler --&gt; Cache</code></pre>"},{"location":"patterns/cqrs/#benefits","title":"\u2705 Benefits","text":""},{"location":"patterns/cqrs/#1-optimized-performance","title":"1. Optimized Performance","text":"<p>Different models for reads and writes enable performance optimization:</p> <pre><code># Write Model - Normalized for consistency\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    customer_id: str\n    items: List[OrderItemDto]\n    delivery_address: AddressDto\n    payment_method: PaymentMethodDto\n\n# Read Model - Denormalized for speed\nclass OrderSummaryDto:\n    order_id: str\n    customer_name: str  # Denormalized\n    total_amount: Decimal\n    status: str\n    estimated_delivery: datetime\n    items_count: int  # Pre-calculated\n</code></pre>"},{"location":"patterns/cqrs/#2-independent-scaling","title":"2. Independent Scaling","text":"<p>Read and write sides can scale independently based on usage patterns:</p> <pre><code># Heavy read operations don't impact write performance\nclass GetPopularPizzasQuery(Query[List[PopularPizzaDto]]):\n    time_period: str = \"last_30_days\"\n    limit: int = 10\n\n# Complex writes don't slow down simple reads\nclass ProcessOrderWorkflowCommand(Command[OperationResult]):\n    order_id: str\n    # Complex business logic with multiple validations\n</code></pre>"},{"location":"patterns/cqrs/#3-clear-separation-of-concerns","title":"3. Clear Separation of Concerns","text":"<p>Commands handle business logic while queries focus on data presentation.</p>"},{"location":"patterns/cqrs/#data-flow","title":"\ud83d\udd04 Data Flow","text":"<p>The pizza ordering process demonstrates CQRS data flow:</p> <pre><code>sequenceDiagram\n    participant Customer\n    participant API as API Controller\n    participant Med as Mediator\n    participant CH as Command Handler\n    participant QH as Query Handler\n    participant WDB as Write DB\n    participant RDB as Read DB\n    participant ES as Event Store\n\n    Note over Customer,ES: \ud83d\udcdd Command Flow (Write)\n    Customer-&gt;&gt;+API: Place Pizza Order\n    API-&gt;&gt;+Med: PlaceOrderCommand\n    Med-&gt;&gt;+CH: Route to handler\n\n    CH-&gt;&gt;CH: Validate business rules\n    CH-&gt;&gt;+WDB: Save normalized order\n    WDB--&gt;&gt;-CH: Order persisted\n\n    CH-&gt;&gt;+ES: Store OrderPlacedEvent\n    ES--&gt;&gt;-CH: Event saved\n\n    CH--&gt;&gt;-Med: Success result\n    Med--&gt;&gt;-API: OrderDto\n    API--&gt;&gt;-Customer: 201 Created\n\n    Note over Customer,ES: \ud83d\udcd6 Query Flow (Read)\n    Customer-&gt;&gt;+API: Get Order Status\n    API-&gt;&gt;+Med: GetOrderByIdQuery\n    Med-&gt;&gt;+QH: Route to handler\n\n    QH-&gt;&gt;+RDB: Read denormalized view\n    RDB--&gt;&gt;-QH: Order summary\n\n    QH--&gt;&gt;-Med: OrderSummaryDto\n    Med--&gt;&gt;-API: Result\n    API--&gt;&gt;-Customer: 200 OK\n\n    Note over WDB,RDB: \ud83d\udd04 Background Sync\n    ES-&gt;&gt;RDB: Project events to read models\n    WDB-&gt;&gt;RDB: Sync latest changes</code></pre>"},{"location":"patterns/cqrs/#use-cases","title":"\ud83c\udfaf Use Cases","text":"<p>CQRS is particularly effective for:</p> <ul> <li>High-Traffic Applications: Different read/write performance requirements</li> <li>Complex Business Logic: Commands handle intricate workflows</li> <li>Reporting Systems: Optimized read models for analytics</li> <li>Event-Driven Systems: Natural fit with event sourcing</li> </ul>"},{"location":"patterns/cqrs/#implementation-in-marios-pizzeria","title":"\ud83c\udf55 Implementation in Mario's Pizzeria","text":""},{"location":"patterns/cqrs/#commands-write-operations","title":"Commands (Write Operations)","text":"<pre><code># Command: Place a pizza order\n@dataclass\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    customer_id: str\n    pizzas: List[PizzaSelectionDto]\n    delivery_address: str\n    payment_method: str\n    special_instructions: Optional[str] = None\n\nclass PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    def __init__(self,\n                 order_repository: OrderRepository,\n                 payment_service: PaymentService,\n                 inventory_service: InventoryService):\n        self._order_repo = order_repository\n        self._payment = payment_service\n        self._inventory = inventory_service\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        try:\n            # 1. Validate business rules\n            if not await self._inventory.check_availability(command.pizzas):\n                return self.bad_request(\"Some pizzas are not available\")\n\n            # 2. Create domain entity\n            order = Order.create(\n                customer_id=command.customer_id,\n                pizzas=command.pizzas,\n                delivery_address=command.delivery_address\n            )\n\n            # 3. Process payment\n            payment_result = await self._payment.charge_async(\n                order.total, command.payment_method\n            )\n            if not payment_result.success:\n                return self.bad_request(\"Payment failed\")\n\n            # 4. Persist order\n            await self._order_repo.save_async(order)\n\n            # 5. Return result\n            dto = self.mapper.map(order, OrderDto)\n            return self.created(dto)\n\n        except Exception as ex:\n            return self.internal_server_error(f\"Order placement failed: {str(ex)}\")\n</code></pre>"},{"location":"patterns/cqrs/#queries-read-operations","title":"Queries (Read Operations)","text":"<pre><code># Query: Get menu with pricing\n@dataclass\nclass GetMenuQuery(Query[List[MenuItemDto]]):\n    category: Optional[str] = None\n    include_unavailable: bool = False\n\nclass GetMenuHandler(QueryHandler[GetMenuQuery, List[MenuItemDto]]):\n    def __init__(self, menu_read_repository: MenuReadRepository):\n        self._menu_repo = menu_read_repository\n\n    async def handle_async(self, query: GetMenuQuery) -&gt; List[MenuItemDto]:\n        # Optimized read from denormalized menu view\n        menu_items = await self._menu_repo.get_menu_items_async(\n            category=query.category,\n            include_unavailable=query.include_unavailable\n        )\n\n        return [self.mapper.map(item, MenuItemDto) for item in menu_items]\n\n# Query: Get order history with analytics\n@dataclass\nclass GetOrderHistoryQuery(Query[OrderHistoryDto]):\n    customer_id: str\n    page: int = 1\n    page_size: int = 10\n\nclass GetOrderHistoryHandler(QueryHandler[GetOrderHistoryQuery, OrderHistoryDto]):\n    async def handle_async(self, query: GetOrderHistoryQuery) -&gt; OrderHistoryDto:\n        # Read from optimized history view with pre-calculated stats\n        history = await self._order_read_repo.get_customer_history_async(\n            customer_id=query.customer_id,\n            page=query.page,\n            page_size=query.page_size\n        )\n\n        return OrderHistoryDto(\n            orders=history.orders,\n            total_orders=history.total_count,\n            total_spent=history.lifetime_value,  # Pre-calculated\n            favorite_pizzas=history.top_pizzas,  # Pre-calculated\n            page=query.page,\n            page_size=query.page_size\n        )\n</code></pre>"},{"location":"patterns/cqrs/#controller-integration","title":"Controller Integration","text":"<pre><code># Controllers use mediator to route commands and queries\nclass OrdersController(ControllerBase):\n\n    @post(\"/\", response_model=OrderDto, status_code=201)\n    async def place_order(self, request: PlaceOrderRequest) -&gt; OrderDto:\n        # Route to command handler\n        command = self.mapper.map(request, PlaceOrderCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @get(\"/{order_id}\", response_model=OrderDto)\n    async def get_order(self, order_id: str) -&gt; OrderDto:\n        # Route to query handler\n        query = GetOrderByIdQuery(order_id=order_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/\", response_model=List[OrderSummaryDto])\n    async def get_orders(self,\n                        customer_id: Optional[str] = None,\n                        status: Optional[str] = None) -&gt; List[OrderSummaryDto]:\n        # Route to query handler with filters\n        query = GetOrdersQuery(customer_id=customer_id, status=status)\n        result = await self.mediator.execute_async(query)\n        return result\n</code></pre>"},{"location":"patterns/cqrs/#read-model-optimization","title":"Read Model Optimization","text":"<pre><code># Optimized read models for different use cases\nclass OrderSummaryDto:\n    \"\"\"Lightweight order summary for lists\"\"\"\n    order_id: str\n    customer_name: str  # Denormalized\n    total: Decimal\n    status: OrderStatus\n    order_date: datetime\n    estimated_delivery: datetime\n\nclass OrderDetailDto:\n    \"\"\"Complete order details for single order view\"\"\"\n    order_id: str\n    customer: CustomerDto  # Full customer details\n    items: List[OrderItemDetailDto]  # Expanded item details\n    payment: PaymentDetailDto\n    delivery: DeliveryDetailDto\n    timeline: List[OrderEventDto]  # Order history\n    total_breakdown: OrderTotalDto  # Tax, discounts, etc.\n</code></pre>"},{"location":"patterns/cqrs/#testing-cqrs","title":"\ud83e\uddea Testing CQRS","text":"<pre><code># Test commands and queries separately\nclass TestPlaceOrderCommand:\n    async def test_place_order_success(self):\n        # Arrange\n        handler = PlaceOrderHandler(mock_repo, mock_payment, mock_inventory)\n        command = PlaceOrderCommand(\n            customer_id=\"123\",\n            pizzas=[PizzaSelectionDto(name=\"Margherita\", size=\"Large\")]\n        )\n\n        # Act\n        result = await handler.handle_async(command)\n\n        # Assert\n        assert result.is_success\n        mock_repo.save_async.assert_called_once()\n\nclass TestGetMenuQuery:\n    async def test_get_menu_filters_by_category(self):\n        # Arrange\n        handler = GetMenuHandler(mock_read_repo)\n        query = GetMenuQuery(category=\"Pizza\")\n\n        # Act\n        result = await handler.handle_async(query)\n\n        # Assert\n        assert len(result) &gt; 0\n        assert all(item.category == \"Pizza\" for item in result)\n</code></pre>"},{"location":"patterns/cqrs/#related-patterns","title":"\ud83d\udd17 Related Patterns","text":"<ul> <li>Clean Architecture - CQRS fits naturally in the application layer</li> <li>Event-Driven Pattern - Commands often produce events</li> <li>Repository Pattern - Separate repositories for reads and writes</li> </ul>"},{"location":"patterns/cqrs/#handler-implementation-patterns","title":"\ud83c\udfaa Handler Implementation Patterns","text":""},{"location":"patterns/cqrs/#command-handlers-with-business-logic","title":"Command Handlers with Business Logic","text":"<pre><code>from neuroglia.mediation.mediator import CommandHandler\nfrom neuroglia.mapping.mapper import Mapper\nfrom neuroglia.data.abstractions import Repository\nfrom decimal import Decimal\n\nclass PlaceOrderCommandHandler(CommandHandler[PlaceOrderCommand, OperationResult]):\n    \"\"\"Handles pizza order placement with full business logic\"\"\"\n\n    def __init__(self,\n                 order_repository: Repository[Order, str],\n                 pizza_repository: Repository[Pizza, str],\n                 mapper: Mapper,\n                 payment_service: IPaymentService,\n                 notification_service: INotificationService):\n        self.order_repository = order_repository\n        self.pizza_repository = pizza_repository\n        self.mapper = mapper\n        self.payment_service = payment_service\n        self.notification_service = notification_service\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult:\n        try:\n            # 1. Validate pizza availability\n            pizza_ids = [item.pizza_id for item in command.pizza_items]\n            available_pizzas = await self.pizza_repository.get_by_ids_async(pizza_ids)\n\n            if len(available_pizzas) != len(pizza_ids):\n                return self.bad_request(\"One or more pizzas are not available\")\n\n            # 2. Calculate total with size and topping modifications\n            total_amount = Decimal(\"0\")\n            order_pizzas = []\n\n            for item in command.pizza_items:\n                base_pizza = next(p for p in available_pizzas if p.id == item.pizza_id)\n\n                customized_pizza = Pizza(\n                    name=base_pizza.name,\n                    size=item.size,\n                    base_price=self._calculate_size_price(base_pizza.base_price, item.size),\n                    toppings=item.toppings,\n                    special_instructions=item.special_instructions\n                )\n\n                order_pizzas.append(customized_pizza)\n                total_amount += customized_pizza.total_price\n\n            # 3. Create order domain entity\n            order = Order.create(\n                customer_name=command.customer_name,\n                customer_phone=command.customer_phone,\n                customer_address=command.customer_address,\n                pizzas=order_pizzas,\n                payment_method=command.payment_method\n            )\n\n            # 4. Persist order (domain events will be published automatically)\n            await self.order_repository.save_async(order)\n\n            # 5. Return success result\n            return self.created({\n                \"order_id\": order.id,\n                \"total_amount\": str(total_amount),\n                \"estimated_ready_time\": order.estimated_ready_time.isoformat()\n            })\n\n        except PaymentDeclinedException:\n            return self.bad_request(\"Payment was declined. Please try a different payment method.\")\n        except KitchenOverloadedException:\n            return self.service_unavailable(\"Kitchen is at capacity. Estimated wait time is 45 minutes.\")\n        except Exception as ex:\n            return self.internal_server_error(f\"Failed to place order: {str(ex)}\")\n\n    def _calculate_size_price(self, base_price: Decimal, size: str) -&gt; Decimal:\n        \"\"\"Calculate price based on pizza size\"\"\"\n        multipliers = {\"small\": Decimal(\"0.8\"), \"medium\": Decimal(\"1.0\"), \"large\": Decimal(\"1.3\")}\n        return base_price * multipliers.get(size, Decimal(\"1.0\"))\n</code></pre>"},{"location":"patterns/cqrs/#query-handlers-with-caching","title":"Query Handlers with Caching","text":"<pre><code>from neuroglia.mediation.mediator import QueryHandler\n\nclass GetMenuQueryHandler(QueryHandler[GetMenuQuery, OperationResult[List[dict]]]):\n    \"\"\"Handles menu retrieval queries with caching optimization\"\"\"\n\n    def __init__(self,\n                 pizza_repository: Repository[Pizza, str],\n                 cache_service: ICacheService):\n        self.pizza_repository = pizza_repository\n        self.cache_service = cache_service\n\n    async def handle_async(self, query: GetMenuQuery) -&gt; OperationResult[List[dict]]:\n        # Check cache first for performance\n        cache_key = f\"menu:{query.category}:{query.include_seasonal}\"\n        cached_menu = await self.cache_service.get_async(cache_key)\n\n        if cached_menu:\n            return self.ok(cached_menu)\n\n        # Fetch from repository\n        pizzas = await self.pizza_repository.get_all_async()\n\n        # Apply filters\n        if query.category:\n            pizzas = [p for p in pizzas if p.category == query.category]\n\n        if not query.include_seasonal:\n            pizzas = [p for p in pizzas if not p.is_seasonal]\n\n        # Build optimized menu response\n        menu_items = []\n        for pizza in pizzas:\n            menu_items.append({\n                \"id\": pizza.id,\n                \"name\": pizza.name,\n                \"description\": pizza.description,\n                \"base_price\": str(pizza.base_price),\n                \"category\": pizza.category,\n                \"preparation_time_minutes\": pizza.preparation_time_minutes,\n                \"available_sizes\": [\"small\", \"medium\", \"large\"],\n                \"available_toppings\": pizza.available_toppings,\n                \"is_seasonal\": pizza.is_seasonal\n            })\n\n        # Cache for 15 minutes\n        await self.cache_service.set_async(cache_key, menu_items, expire_minutes=15)\n\n        return self.ok(menu_items)\n\nclass GetKitchenQueueQueryHandler(QueryHandler[GetKitchenQueueQuery, OperationResult[List[dict]]]):\n    \"\"\"Handles kitchen queue queries for staff dashboard\"\"\"\n\n    def __init__(self, order_repository: Repository[Order, str]):\n        self.order_repository = order_repository\n\n    async def handle_async(self, query: GetKitchenQueueQuery) -&gt; OperationResult[List[dict]]:\n        # Get orders by status\n        orders = await self.order_repository.get_by_status_async(query.status)\n\n        # Sort by order time (FIFO)\n        orders.sort(key=lambda o: o.order_time)\n\n        # Build optimized queue response\n        queue_items = []\n        for order in orders:\n            queue_items.append({\n                \"order_id\": order.id,\n                \"customer_name\": order.customer_name,\n                \"order_time\": order.order_time.isoformat(),\n                \"estimated_ready_time\": order.estimated_ready_time.isoformat() if order.estimated_ready_time else None,\n                \"pizza_count\": len(order.pizzas),\n                \"total_prep_time\": sum(p.preparation_time_minutes for p in order.pizzas),\n                \"special_instructions\": [p.special_instructions for p in order.pizzas if p.special_instructions]\n            })\n\n        return self.ok(queue_items)\n</code></pre>"},{"location":"patterns/cqrs/#event-handlers-for-side-effects","title":"Event Handlers for Side Effects","text":"<pre><code>from neuroglia.mediation.mediator import EventHandler\n\nclass OrderPlacedEventHandler(EventHandler[OrderPlacedEvent]):\n    \"\"\"Handles order placed events - sends notifications and analytics\"\"\"\n\n    def __init__(self,\n                 notification_service: INotificationService,\n                 analytics_service: IAnalyticsService):\n        self.notification_service = notification_service\n        self.analytics_service = analytics_service\n\n    async def handle_async(self, event: OrderPlacedEvent):\n        # Send SMS confirmation to customer\n        await self.notification_service.send_sms(\n            phone=event.customer_phone,\n            message=f\"Order {event.order_id[:8]} confirmed! \"\n                   f\"Total: ${event.total_amount}. \"\n                   f\"Ready by: {event.estimated_ready_time.strftime('%H:%M')}\"\n        )\n\n        # Notify kitchen staff\n        await self.notification_service.notify_kitchen_staff(\n            f\"New order {event.order_id[:8]} from {event.customer_name}\"\n        )\n\n        # Track order analytics\n        await self.analytics_service.track_order_placed(\n            order_id=event.order_id,\n            amount=event.total_amount,\n            customer_type=\"returning\" if await self._is_returning_customer(event.customer_phone) else \"new\"\n        )\n\nclass PizzaReadyEventHandler(EventHandler[PizzaReadyEvent]):\n    \"\"\"Handles pizza ready events - manages completion tracking\"\"\"\n\n    def __init__(self,\n                 order_service: IOrderService,\n                 performance_service: IPerformanceService):\n        self.order_service = order_service\n        self.performance_service = performance_service\n\n    async def handle_async(self, event: PizzaReadyEvent):\n        # Check if entire order is complete\n        order_complete = await self.order_service.check_if_order_complete(event.order_id)\n\n        if order_complete:\n            # Mark order as ready and notify customer\n            await self.order_service.mark_order_ready(event.order_id)\n\n        # Track pizza cooking performance\n        await self.performance_service.track_pizza_completion(\n            order_id=event.order_id,\n            pizza_index=event.pizza_index,\n            actual_time=event.actual_cooking_time_minutes,\n            completed_at=event.completed_at\n        )\n</code></pre>"},{"location":"patterns/cqrs/#pipeline-behaviors","title":"\ud83d\udee1\ufe0f Pipeline Behaviors","text":""},{"location":"patterns/cqrs/#validation-behavior","title":"Validation Behavior","text":"<pre><code>from neuroglia.mediation.mediator import PipelineBehavior\n\nclass OrderValidationBehavior(PipelineBehavior):\n    \"\"\"Validates pizza orders before processing\"\"\"\n\n    async def handle_async(self, request, next_handler):\n        # Only validate order commands\n        if isinstance(request, PlaceOrderCommand):\n            # Business rule: minimum order amount\n            if not request.pizza_items:\n                return OperationResult.validation_error(\"Order must contain at least one pizza\")\n\n            # Business rule: validate customer info\n            if not request.customer_phone or len(request.customer_phone) &lt; 10:\n                return OperationResult.validation_error(\"Valid phone number required\")\n\n            # Business rule: validate business hours\n            if not await self._is_within_business_hours():\n                return OperationResult.validation_error(\"Sorry, we're closed! Kitchen hours are 11 AM - 10 PM\")\n\n        # Continue to next behavior/handler\n        return await next_handler()\n\n    async def _is_within_business_hours(self) -&gt; bool:\n        \"\"\"Check if current time is within business hours\"\"\"\n        from datetime import datetime\n        current_hour = datetime.now().hour\n        return 11 &lt;= current_hour &lt;= 22  # 11 AM to 10 PM\n</code></pre>"},{"location":"patterns/cqrs/#caching-behavior","title":"Caching Behavior","text":"<pre><code>class QueryCachingBehavior(PipelineBehavior):\n    \"\"\"Caches query results based on query type and parameters\"\"\"\n\n    def __init__(self, cache_service: ICacheService):\n        self.cache_service = cache_service\n\n    async def handle_async(self, request, next_handler):\n        # Only cache queries, not commands\n        if not isinstance(request, Query):\n            return await next_handler()\n\n        # Generate cache key\n        cache_key = self._generate_cache_key(request)\n\n        # Try to get from cache first\n        cached_result = await self.cache_service.get_async(cache_key)\n        if cached_result:\n            return cached_result\n\n        # Execute query\n        result = await next_handler()\n\n        # Cache successful results\n        if result.is_success:\n            # Different TTL based on query type\n            ttl_minutes = self._get_cache_ttl(type(request))\n            await self.cache_service.set_async(cache_key, result, expire_minutes=ttl_minutes)\n\n        return result\n\n    def _generate_cache_key(self, request: Query) -&gt; str:\n        \"\"\"Generate cache key from request\"\"\"\n        request_type = type(request).__name__\n        request_data = str(request.__dict__)\n        return f\"query:{request_type}:{hash(request_data)}\"\n\n    def _get_cache_ttl(self, query_type: Type) -&gt; int:\n        \"\"\"Get cache TTL based on query type\"\"\"\n        cache_strategies = {\n            GetMenuQuery: 30,           # Menu changes infrequently\n            GetOrderStatusQuery: 1,     # Order status changes frequently\n            GetKitchenQueueQuery: 2,    # Kitchen queue changes regularly\n        }\n        return cache_strategies.get(query_type, 5)  # Default 5 minutes\n</code></pre>"},{"location":"patterns/cqrs/#transaction-behavior","title":"Transaction Behavior","text":"<pre><code>class OrderTransactionBehavior(PipelineBehavior):\n    \"\"\"Wraps order commands in database transactions\"\"\"\n\n    def __init__(self, unit_of_work: IUnitOfWork):\n        self.unit_of_work = unit_of_work\n\n    async def handle_async(self, request, next_handler):\n        # Only apply transactions to commands that modify data\n        if not isinstance(request, (PlaceOrderCommand, StartCookingCommand, ProcessPaymentCommand)):\n            return await next_handler()\n\n        async with self.unit_of_work.begin_transaction():\n            try:\n                result = await next_handler()\n\n                if result.is_success:\n                    await self.unit_of_work.commit_async()\n                else:\n                    await self.unit_of_work.rollback_async()\n\n                return result\n            except Exception:\n                await self.unit_of_work.rollback_async()\n                raise\n</code></pre>"},{"location":"patterns/cqrs/#framework-integration","title":"\ud83d\ude80 Framework Integration","text":""},{"location":"patterns/cqrs/#service-registration","title":"Service Registration","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.mediation.mediator import Mediator\n\ndef configure_cqrs_services(builder: WebApplicationBuilder):\n    \"\"\"Configure CQRS with mediator services\"\"\"\n\n    # Configure mediator with handler modules\n    Mediator.configure(builder, [\n        \"src.application.commands\",  # Command handlers\n        \"src.application.queries\",   # Query handlers\n        \"src.application.events\"     # Event handlers\n    ])\n\n    # Register pipeline behaviors\n    builder.services.add_pipeline_behavior(OrderValidationBehavior)\n    builder.services.add_pipeline_behavior(QueryCachingBehavior)\n    builder.services.add_pipeline_behavior(OrderTransactionBehavior)\n\n    # Register infrastructure services\n    builder.services.add_scoped(Repository[Order, str])\n    builder.services.add_scoped(Repository[Pizza, str])\n    builder.services.add_singleton(ICacheService)\n    builder.services.add_scoped(INotificationService)\n\ndef create_pizzeria_app():\n    \"\"\"Create pizzeria application with CQRS\"\"\"\n    builder = WebApplicationBuilder()\n\n    # Configure CQRS services\n    configure_cqrs_services(builder)\n\n    # Build application\n    app = builder.build()\n\n    return app\n</code></pre>"},{"location":"patterns/cqrs/#controller-integration_1","title":"Controller Integration","text":"<pre><code>from neuroglia.mvc.controller_base import ControllerBase\nfrom classy_fastapi.decorators import get, post, put\n\nclass OrdersController(ControllerBase):\n    \"\"\"Pizza orders API controller using CQRS with mediation\"\"\"\n\n    @post(\"/\", response_model=dict, status_code=201)\n    async def place_order(self, order_request: dict) -&gt; dict:\n        # Create command from request\n        command = PlaceOrderCommand(\n            customer_name=order_request[\"customer_name\"],\n            customer_phone=order_request[\"customer_phone\"],\n            customer_address=order_request[\"customer_address\"],\n            pizza_items=[PizzaItem(**item) for item in order_request[\"pizza_items\"]],\n            payment_method=order_request.get(\"payment_method\", \"cash\")\n        )\n\n        # Execute through mediator (with pipeline behaviors)\n        result = await self.mediator.execute_async(command)\n\n        # Process result and return\n        return self.process(result)\n\n    @get(\"/{order_id}/status\", response_model=dict)\n    async def get_order_status(self, order_id: str) -&gt; dict:\n        # Create query\n        query = GetOrderStatusQuery(order_id=order_id)\n\n        # Execute through mediator (with caching behavior)\n        result = await self.mediator.execute_async(query)\n\n        # Process result and return\n        return self.process(result)\n\n    @put(\"/{order_id}/cook\", response_model=dict)\n    async def start_cooking(self, order_id: str, cooking_request: dict) -&gt; dict:\n        # Create command\n        command = StartCookingCommand(\n            order_id=order_id,\n            kitchen_staff_id=cooking_request[\"kitchen_staff_id\"],\n            estimated_cooking_time_minutes=cooking_request[\"estimated_cooking_time_minutes\"]\n        )\n\n        # Execute through mediator (with transaction behavior)\n        result = await self.mediator.execute_async(command)\n\n        # Process result and return\n        return self.process(result)\n</code></pre>"},{"location":"patterns/cqrs/#testing-patterns","title":"\ud83e\uddea Testing Patterns","text":""},{"location":"patterns/cqrs/#command-handler-testing","title":"Command Handler Testing","text":"<pre><code>import pytest\nfrom unittest.mock import Mock, AsyncMock\n\n@pytest.mark.asyncio\nasync def test_place_order_command_handler_success():\n    # Arrange\n    mock_order_repo = AsyncMock(spec=IOrderRepository)\n    mock_mapper = Mock(spec=Mapper)\n    mock_mapper.map.return_value = OrderDto(order_id=\"123\", total=Decimal(\"25.99\"))\n\n    handler = PlaceOrderCommandHandler(\n        order_repository=mock_order_repo,\n        pizza_repository=Mock(),\n        mapper=mock_mapper,\n        payment_service=Mock(),\n        notification_service=Mock()\n    )\n\n    # Mock pizza availability\n    margherita = Pizza(\"margherita\", \"Margherita\", \"medium\", Decimal(\"12.99\"), [], 15)\n    handler.pizza_repository.get_by_ids_async = AsyncMock(return_value=[margherita])\n\n    command = PlaceOrderCommand(\n        customer_name=\"John Doe\",\n        customer_phone=\"555-0123\",\n        customer_address=\"123 Pizza St\",\n        pizza_items=[PizzaItem(pizza_id=\"margherita\", size=\"large\", toppings=[\"extra_cheese\"])],\n        payment_method=\"cash\"\n    )\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n    assert \"order_id\" in result.data\n    assert \"total_amount\" in result.data\n    mock_order_repo.save_async.assert_called_once()\n\n@pytest.mark.asyncio\nasync def test_place_order_command_handler_validation_failure():\n    # Arrange\n    handler = PlaceOrderCommandHandler(\n        Mock(), Mock(), Mock(), Mock(), Mock()\n    )\n\n    command = PlaceOrderCommand(\n        customer_name=\"John Doe\",\n        customer_phone=\"555-0123\",\n        customer_address=\"123 Pizza St\",\n        pizza_items=[],  # Empty items should fail validation\n        payment_method=\"cash\"\n    )\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert not result.is_success\n    assert \"at least one pizza\" in result.error_message\n</code></pre>"},{"location":"patterns/cqrs/#query-handler-testing","title":"Query Handler Testing","text":"<pre><code>@pytest.mark.asyncio\nasync def test_get_menu_query_handler():\n    # Arrange\n    mock_read_repo = AsyncMock(spec=IMenuReadRepository)\n    mock_read_repo.get_menu_items_async.return_value = [\n        MenuItem(id=\"1\", name=\"Margherita\", category=\"Pizza\", price=Decimal(\"12.99\")),\n        MenuItem(id=\"2\", name=\"Pepperoni\", category=\"Pizza\", price=Decimal(\"14.99\"))\n    ]\n\n    handler = GetMenuHandler(mock_read_repo)\n    query = GetMenuQuery(category=\"Pizza\")\n\n    # Act\n    result = await handler.handle_async(query)\n\n    # Assert\n    assert len(result) == 2\n    assert all(item.category == \"Pizza\" for item in result)\n    mock_read_repo.get_menu_items_async.assert_called_once_with(\n        category=\"Pizza\",\n        include_unavailable=False\n    )\n</code></pre>"},{"location":"patterns/cqrs/#integration-testing","title":"Integration Testing","text":"<pre><code>@pytest.mark.integration\n@pytest.mark.asyncio\nasync def test_complete_order_workflow():\n    \"\"\"Test the complete order placement and cooking workflow through mediator\"\"\"\n\n    # Arrange - use test client with real mediator\n    test_client = TestClient(create_pizzeria_app())\n\n    # Create order\n    order_data = {\n        \"customer_name\": \"John Doe\",\n        \"customer_phone\": \"555-0123\",\n        \"customer_address\": \"123 Pizza St\",\n        \"pizza_items\": [\n            {\n                \"pizza_id\": \"margherita\",\n                \"size\": \"large\",\n                \"toppings\": [\"extra_cheese\"],\n                \"special_instructions\": \"Extra crispy\"\n            }\n        ],\n        \"payment_method\": \"cash\"\n    }\n\n    # Act &amp; Assert - Place order\n    response = test_client.post(\"/api/orders\", json=order_data)\n    assert response.status_code == 201\n\n    order_result = response.json()\n    order_id = order_result[\"order_id\"]\n    assert \"total_amount\" in order_result\n    assert \"estimated_ready_time\" in order_result\n\n    # Act &amp; Assert - Check order status (should use cache)\n    status_response = test_client.get(f\"/api/orders/{order_id}/status\")\n    assert status_response.status_code == 200\n\n    status_data = status_response.json()\n    assert status_data[\"status\"] == \"pending\"\n    assert status_data[\"customer_name\"] == \"John Doe\"\n</code></pre>"},{"location":"patterns/cqrs/#common-mistakes","title":"\u26a0\ufe0f Common Mistakes","text":""},{"location":"patterns/cqrs/#1-queries-that-modify-state","title":"1. Queries That Modify State","text":"<pre><code># \u274c Wrong - query should not modify data\n@dataclass\nclass GetOrderQuery(Query[OrderDto]):\n    order_id: str\n    mark_as_viewed: bool = True  # \u274c Side effect in query!\n\nclass GetOrderHandler(QueryHandler[GetOrderQuery, OrderDto]):\n    async def handle_async(self, query: GetOrderQuery):\n        order = await self._repository.get_by_id_async(query.order_id)\n\n        # \u274c Query modifying state!\n        if query.mark_as_viewed:\n            order.mark_as_viewed()\n            await self._repository.save_async(order)\n\n        return self._mapper.map(order, OrderDto)\n\n# \u2705 Correct - queries only read, commands modify\n@dataclass\nclass GetOrderQuery(Query[OrderDto]):\n    order_id: str  # \u2705 No side effects\n\n@dataclass\nclass MarkOrderAsViewedCommand(Command[OperationResult]):\n    order_id: str  # \u2705 Separate command for modification\n\nclass GetOrderHandler(QueryHandler[GetOrderQuery, OrderDto]):\n    async def handle_async(self, query: GetOrderQuery):\n        order = await self._read_repository.get_by_id_async(query.order_id)\n        return self._mapper.map(order, OrderDto)  # \u2705 Read-only\n</code></pre>"},{"location":"patterns/cqrs/#2-commands-that-return-domain-entities","title":"2. Commands That Return Domain Entities","text":"<pre><code># \u274c Wrong - command returns full entity\n@dataclass\nclass PlaceOrderCommand(Command[Order]):  # \u274c Returns entity\n    customer_id: str\n    items: List[OrderItemDto]\n\nclass PlaceOrderHandler(CommandHandler[PlaceOrderCommand, Order]):\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; Order:\n        order = Order.create(command.customer_id, command.items)\n        await self._repository.save_async(order)\n        return order  # \u274c Exposing domain entity to API layer\n\n# \u2705 Correct - command returns DTO or result object\n@dataclass\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):  # \u2705 Returns DTO\n    customer_id: str\n    items: List[OrderItemDto]\n\nclass PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    async def handle_async(self, command: PlaceOrderCommand):\n        order = Order.create(command.customer_id, command.items)\n        await self._repository.save_async(order)\n\n        # \u2705 Map to DTO before returning\n        dto = self._mapper.map(order, OrderDto)\n        return self.created(dto)\n</code></pre>"},{"location":"patterns/cqrs/#3-not-using-mediator-direct-handler-calls","title":"3. Not Using Mediator - Direct Handler Calls","text":"<pre><code># \u274c Wrong - controller directly instantiates and calls handler\nclass OrdersController:\n    def __init__(self, repository: IOrderRepository):\n        self._repository = repository\n\n    async def place_order(self, request: dict):\n        # \u274c Manually creating handler\n        handler = PlaceOrderHandler(self._repository, mapper, ...)\n        command = PlaceOrderCommand(**request)\n\n        # \u274c Direct call bypasses pipeline behaviors\n        result = await handler.handle_async(command)\n        return result\n\n# \u2705 Correct - use mediator for routing\nclass OrdersController(ControllerBase):\n    # \u2705 No handler dependencies\n\n    async def place_order(self, request: PlaceOrderRequest):\n        # \u2705 Map request to command\n        command = self.mapper.map(request, PlaceOrderCommand)\n\n        # \u2705 Mediator handles routing and pipeline behaviors\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"patterns/cqrs/#4-shared-models-between-commands-and-queries","title":"4. Shared Models Between Commands and Queries","text":"<pre><code># \u274c Wrong - using same DTO for both commands and queries\nclass OrderDto:\n    # Used for both reading and writing\n    order_id: str\n    customer_id: str\n    items: List[OrderItemDto]\n    total: Decimal\n    status: str\n    created_at: datetime\n    updated_at: datetime\n    # \u274c Write operations don't need all these fields\n    # \u274c Read operations might need different fields\n\n# \u2705 Correct - separate DTOs for commands and queries\n@dataclass\nclass CreateOrderDto:\n    \"\"\"DTO for order creation command\"\"\"\n    customer_id: str\n    items: List[OrderItemDto]\n    delivery_address: str\n    # \u2705 Only fields needed for creation\n\n@dataclass\nclass OrderSummaryDto:\n    \"\"\"DTO for order list query\"\"\"\n    order_id: str\n    customer_name: str  # Denormalized\n    total: Decimal\n    status: str\n    order_date: datetime\n    # \u2705 Optimized for display\n\n@dataclass\nclass OrderDetailDto:\n    \"\"\"DTO for single order query\"\"\"\n    order_id: str\n    customer: CustomerDto  # Full customer info\n    items: List[OrderItemDetailDto]  # Expanded items\n    payment: PaymentDetailDto\n    timeline: List[OrderEventDto]\n    # \u2705 Complete information for detail view\n</code></pre>"},{"location":"patterns/cqrs/#5-missing-validation-in-pipeline","title":"5. Missing Validation in Pipeline","text":"<pre><code># \u274c Wrong - validation scattered across handlers\nclass PlaceOrderHandler(CommandHandler):\n    async def handle_async(self, command: PlaceOrderCommand):\n        # \u274c Validation logic in handler\n        if not command.items:\n            return self.bad_request(\"No items\")\n        if not command.customer_id:\n            return self.bad_request(\"No customer\")\n\n        # Business logic...\n\n# \u2705 Correct - validation in pipeline behavior\nclass ValidationBehavior(PipelineBehavior):\n    async def handle_async(self, request, next_handler):\n        # \u2705 Centralized validation\n        if isinstance(request, PlaceOrderCommand):\n            if not request.items:\n                return OperationResult.validation_error(\"Order must contain items\")\n            if not request.customer_id:\n                return OperationResult.validation_error(\"Customer ID required\")\n\n        return await next_handler()\n\nclass PlaceOrderHandler(CommandHandler):\n    async def handle_async(self, command: PlaceOrderCommand):\n        # \u2705 Handler focuses on business logic only\n        order = Order.create(command.customer_id, command.items)\n        await self._repository.save_async(order)\n        return self.created(order_dto)\n</code></pre>"},{"location":"patterns/cqrs/#6-not-leveraging-caching-for-queries","title":"6. Not Leveraging Caching for Queries","text":"<pre><code># \u274c Wrong - expensive query executed every time\nclass GetPopularPizzasHandler(QueryHandler):\n    async def handle_async(self, query: GetPopularPizzasQuery):\n        # \u274c Expensive aggregation query runs every request\n        result = await self._repository.calculate_popular_pizzas_async(\n            days=30\n        )\n        return result\n\n# \u2705 Correct - caching behavior for expensive queries\nclass CachingBehavior(PipelineBehavior):\n    async def handle_async(self, request, next_handler):\n        if not isinstance(request, Query):\n            return await next_handler()\n\n        # \u2705 Check cache first\n        cache_key = self._generate_key(request)\n        cached = await self._cache.get_async(cache_key)\n        if cached:\n            return cached\n\n        # Execute query\n        result = await next_handler()\n\n        # \u2705 Cache result with appropriate TTL\n        ttl = self._get_ttl(type(request))\n        await self._cache.set_async(cache_key, result, ttl)\n\n        return result\n</code></pre>"},{"location":"patterns/cqrs/#when-not-to-use","title":"\ud83d\udeab When NOT to Use","text":""},{"location":"patterns/cqrs/#1-simple-crud-applications","title":"1. Simple CRUD Applications","text":"<p>For basic create, read, update, delete operations without complex business logic:</p> <pre><code># CQRS is overkill for simple CRUD\n@app.get(\"/pizzas\")\nasync def get_pizzas(db: Database):\n    # Simple read - no need for query handler\n    return await db.pizzas.find().to_list(None)\n\n@app.post(\"/pizzas\")\nasync def create_pizza(pizza: PizzaDto, db: Database):\n    # Simple write - no need for command handler\n    return await db.pizzas.insert_one(pizza.dict())\n</code></pre>"},{"location":"patterns/cqrs/#2-applications-with-identical-readwrite-models","title":"2. Applications with Identical Read/Write Models","text":"<p>When your read and write operations use the same data structure:</p> <pre><code># If you're just saving and retrieving the same structure,\n# CQRS separation doesn't provide value\nclass CustomerService:\n    async def save_customer(self, customer: Customer):\n        await self._db.save(customer)\n\n    async def get_customer(self, id: str) -&gt; Customer:\n        return await self._db.get(id)\n    # No need for CQRS - same model for both operations\n</code></pre>"},{"location":"patterns/cqrs/#3-small-teams-without-cqrs-experience","title":"3. Small Teams Without CQRS Experience","text":"<p>The pattern adds complexity that may not be worth it for small teams:</p> <pre><code># Simple service pattern may be better for small teams\nclass OrderService:\n    async def place_order(self, data: dict) -&gt; Order:\n        order = Order(**data)\n        await self._db.save(order)\n        return order\n\n    async def get_order(self, order_id: str) -&gt; Order:\n        return await self._db.get(order_id)\n    # Simpler pattern, easier to understand and maintain\n</code></pre>"},{"location":"patterns/cqrs/#4-real-time-systems-requiring-immediate-consistency","title":"4. Real-Time Systems Requiring Immediate Consistency","text":"<p>When reads must immediately reflect writes:</p> <pre><code># CQRS with eventual consistency won't work\nasync def transfer_funds(from_account: str, to_account: str, amount: Decimal):\n    # Need immediate consistency - both operations must succeed or fail together\n    await debit_account(from_account, amount)\n    await credit_account(to_account, amount)\n\n    # Next read MUST show updated balances immediately\n    # Eventual consistency is not acceptable\n</code></pre>"},{"location":"patterns/cqrs/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ol> <li>Separation of Concerns: Commands modify state, queries read state - never mix</li> <li>Mediator Pattern: Centralized routing eliminates direct dependencies</li> <li>Pipeline Behaviors: Cross-cutting concerns (validation, caching, logging) in one place</li> <li>Independent Optimization: Optimize reads and writes separately for performance</li> <li>Testability: Test handlers in isolation with minimal mocking</li> <li>Event-Driven: Commands naturally produce domain events for other handlers</li> <li>DTOs Not Entities: Commands and queries work with DTOs, not domain entities</li> <li>Caching for Queries: Leverage pipeline behaviors to cache expensive queries</li> <li>Validation First: Use pipeline behaviors for consistent validation</li> <li>Know When Not To Use: Simple CRUD doesn't need CQRS complexity</li> </ol>"},{"location":"patterns/cqrs/#pattern-benefits","title":"\ud83c\udfaf Pattern Benefits","text":""},{"location":"patterns/cqrs/#cqrs-with-mediation-advantages","title":"CQRS with Mediation Advantages","text":"<ul> <li>Decoupled Architecture: Mediator eliminates direct dependencies between controllers and business logic</li> <li>Cross-Cutting Concerns: Pipeline behaviors handle validation, caching, logging, and transactions consistently</li> <li>Testability: Each handler can be unit tested in isolation without complex setup</li> <li>Scalability: Commands and queries can scale independently with optimized read/write models</li> <li>Event-Driven Integration: Domain events enable loose coupling between bounded contexts</li> <li>Single Responsibility: Each handler has one clear responsibility and business purpose</li> </ul>"},{"location":"patterns/cqrs/#when-to-use","title":"When to Use","text":"<ul> <li>Applications with complex business logic requiring clear separation of concerns</li> <li>Systems needing different optimization strategies for reads and writes</li> <li>Microservices architectures requiring decoupled communication</li> <li>Applications with cross-cutting concerns like caching, validation, and transaction management</li> <li>Event-driven systems where domain events drive business processes</li> <li>Teams wanting to enforce consistent patterns and reduce coupling</li> </ul>"},{"location":"patterns/cqrs/#related-patterns_1","title":"\ud83d\udd17 Related Patterns","text":"<ul> <li>Event-Driven Architecture - Commands produce events consumed by event handlers</li> <li>Repository Pattern - Separate repositories for command and query sides</li> <li>Domain-Driven Design - Aggregates and domain events align with CQRS</li> <li>Clean Architecture - CQRS handlers belong in application layer</li> <li>Event Sourcing - Commands naturally produce events for event sourcing</li> </ul> <p>This pattern guide demonstrates CQRS with Mediation using Mario's Pizzeria's order management system, showing clear separation between commands and queries with centralized request routing. \ud83c\udfaf</p>"},{"location":"patterns/dependency-injection/","title":"\ud83d\udd27 Dependency Injection Pattern","text":"<p>Estimated reading time: 30 minutes</p> <p>Dependency Injection (DI) is a design pattern that implements Inversion of Control (IoC) by injecting dependencies rather than creating them internally. Neuroglia provides a comprehensive DI container that manages service registration, lifetime, and resolution, demonstrated through Mario's Pizzeria implementation.</p>"},{"location":"patterns/dependency-injection/#what-why","title":"\ud83d\udca1 What &amp; Why","text":""},{"location":"patterns/dependency-injection/#the-problem-tight-coupling-and-hard-to-test-code","title":"\u274c The Problem: Tight Coupling and Hard-to-Test Code","text":"<p>When classes create their own dependencies directly, they become tightly coupled and difficult to test:</p> <pre><code># \u274c PROBLEM: Tight coupling with hardcoded dependencies\nfrom pymongo import MongoClient\n\nclass OrderService:\n    def __init__(self):\n        # Creating dependencies directly = TIGHT COUPLING!\n        self.mongo_client = MongoClient(\"mongodb://localhost:27017\")\n        self.db = self.mongo_client.pizzeria\n        self.email_service = EmailService(\"smtp.gmail.com\", 587)\n        self.payment_gateway = StripePaymentGateway(\"sk_live_secret_key\")\n        self.logger = FileLogger(\"/var/log/orders.log\")\n\n    async def create_order(self, customer_id: str, items: List[dict]):\n        # Use hardcoded dependencies\n        order = Order(customer_id, items)\n        await self.db.orders.insert_one(order.__dict__)\n        await self.email_service.send_confirmation(order)\n        return order\n\n# Problems with this approach:\n# \u274c Cannot test without real MongoDB, SMTP, Stripe, file system\n# \u274c Cannot swap implementations (e.g., test email service)\n# \u274c Configuration hardcoded in constructor\n# \u274c Difficult to change database or payment provider\n# \u274c Violates Single Responsibility Principle\n# \u274c Cannot reuse service with different dependencies\n\n# Testing is a NIGHTMARE:\nclass TestOrderService:\n    def test_create_order(self):\n        # Need REAL MongoDB running!\n        # Need REAL SMTP server!\n        # Need REAL Stripe account!\n        # Need file system write permissions!\n        service = OrderService()\n        # This test hits REAL external systems - TERRIBLE!\n        result = await service.create_order(\"customer-123\", [])\n</code></pre> <p>Problems with Tight Coupling:</p> <ul> <li>\u274c Untestable: Cannot mock dependencies for unit testing</li> <li>\u274c Inflexible: Hard to swap implementations (e.g., MongoDB \u2192 PostgreSQL)</li> <li>\u274c Configuration Hell: Connection strings and keys hardcoded</li> <li>\u274c Violates SRP: Service creates AND uses dependencies</li> <li>\u274c Difficult to Maintain: Changes ripple through codebase</li> <li>\u274c No Reusability: Cannot reuse service in different contexts</li> </ul>"},{"location":"patterns/dependency-injection/#the-solution-dependency-injection-with-ioc-container","title":"\u2705 The Solution: Dependency Injection with IoC Container","text":"<p>Inject dependencies through constructors, allowing flexibility and testability:</p> <pre><code># \u2705 SOLUTION: Dependency Injection with interfaces and IoC container\nfrom abc import ABC, abstractmethod\nfrom neuroglia.dependency_injection import ServiceCollection, ServiceLifetime\n\n# Define interfaces (contracts)\nclass IOrderRepository(ABC):\n    @abstractmethod\n    async def save_async(self, order: Order):\n        pass\n\n    @abstractmethod\n    async def get_by_id_async(self, order_id: str) -&gt; Order:\n        pass\n\nclass IEmailService(ABC):\n    @abstractmethod\n    async def send_confirmation_async(self, order: Order):\n        pass\n\nclass IPaymentGateway(ABC):\n    @abstractmethod\n    async def process_payment_async(self, amount: Decimal) -&gt; str:\n        pass\n\n# Service receives dependencies through constructor\nclass OrderService:\n    def __init__(self,\n                 order_repository: IOrderRepository,\n                 email_service: IEmailService,\n                 payment_gateway: IPaymentGateway,\n                 logger: ILogger):\n        # Dependencies injected, not created!\n        self.order_repository = order_repository\n        self.email_service = email_service\n        self.payment_gateway = payment_gateway\n        self.logger = logger\n\n    async def create_order(self, customer_id: str, items: List[dict]):\n        try:\n            # Create order\n            order = Order(customer_id, items)\n\n            # Process payment\n            transaction_id = await self.payment_gateway.process_payment_async(order.total)\n            order.mark_as_paid(transaction_id)\n\n            # Save order\n            await self.order_repository.save_async(order)\n\n            # Send confirmation\n            await self.email_service.send_confirmation_async(order)\n\n            self.logger.info(f\"Order {order.id} created successfully\")\n            return order\n\n        except Exception as ex:\n            self.logger.error(f\"Failed to create order: {ex}\")\n            raise\n\n# Real implementations\nclass MongoOrderRepository(IOrderRepository):\n    def __init__(self, mongo_client: MongoClient):\n        self.collection = mongo_client.pizzeria.orders\n\n    async def save_async(self, order: Order):\n        await self.collection.insert_one(order.__dict__)\n\n    async def get_by_id_async(self, order_id: str) -&gt; Order:\n        doc = await self.collection.find_one({\"id\": order_id})\n        return Order.from_dict(doc)\n\nclass SmtpEmailService(IEmailService):\n    def __init__(self, smtp_config: SmtpConfig):\n        self.config = smtp_config\n\n    async def send_confirmation_async(self, order: Order):\n        # Send email via SMTP\n        pass\n\nclass StripePaymentGateway(IPaymentGateway):\n    def __init__(self, stripe_config: StripeConfig):\n        self.config = stripe_config\n\n    async def process_payment_async(self, amount: Decimal) -&gt; str:\n        # Process payment via Stripe\n        return \"txn_abc123\"\n\n# Configure DI container\nservices = ServiceCollection()\n\n# Register dependencies with appropriate lifetimes\nservices.add_singleton(MongoClient, lambda: MongoClient(\"mongodb://localhost:27017\"))\nservices.add_scoped(IOrderRepository, MongoOrderRepository)\nservices.add_singleton(IEmailService, SmtpEmailService)\nservices.add_singleton(IPaymentGateway, StripePaymentGateway)\nservices.add_singleton(ILogger, FileLogger)\nservices.add_scoped(OrderService)\n\n# Build provider\nprovider = services.build_provider()\n\n# Resolve service (all dependencies injected automatically!)\norder_service = provider.get_service(OrderService)\nawait order_service.create_order(\"customer-123\", items)\n\n# Testing is now EASY with mocks!\nclass TestOrderService:\n    def setup_method(self):\n        # Create mock dependencies\n        self.mock_repository = Mock(spec=IOrderRepository)\n        self.mock_email = Mock(spec=IEmailService)\n        self.mock_payment = Mock(spec=IPaymentGateway)\n        self.mock_logger = Mock(spec=ILogger)\n\n        # Inject mocks into service\n        self.service = OrderService(\n            self.mock_repository,\n            self.mock_email,\n            self.mock_payment,\n            self.mock_logger\n        )\n\n    async def test_create_order_success(self):\n        # Configure mock behavior\n        self.mock_payment.process_payment_async.return_value = \"txn_123\"\n\n        # Test with NO external dependencies!\n        order = await self.service.create_order(\"customer-123\", [\n            {\"name\": \"Margherita\", \"price\": 12.99}\n        ])\n\n        # Verify interactions\n        assert order is not None\n        self.mock_repository.save_async.assert_called_once()\n        self.mock_email.send_confirmation_async.assert_called_once()\n        self.mock_payment.process_payment_async.assert_called_once()\n\n# Swapping implementations is EASY!\n# Want to use PostgreSQL instead of MongoDB?\nservices.add_scoped(IOrderRepository, PostgresOrderRepository)\n\n# Want to use SendGrid instead of SMTP?\nservices.add_singleton(IEmailService, SendGridEmailService)\n\n# Want test implementations for development?\nif config.environment == \"development\":\n    services.add_singleton(IPaymentGateway, FakePaymentGateway)\n    services.add_singleton(IEmailService, ConsoleEmailService)\n</code></pre> <p>Benefits of Dependency Injection:</p> <ul> <li>\u2705 Testability: Easy to mock dependencies for unit tests</li> <li>\u2705 Flexibility: Swap implementations without changing code</li> <li>\u2705 Separation of Concerns: Service uses dependencies, doesn't create them</li> <li>\u2705 Configuration: Centralized service registration</li> <li>\u2705 Reusability: Same service works with different dependencies</li> <li>\u2705 Maintainability: Changes isolated to service registration</li> <li>\u2705 Follows SOLID: Dependency Inversion Principle</li> </ul>"},{"location":"patterns/dependency-injection/#pattern-overview","title":"\ud83c\udfaf Pattern Overview","text":"<p>Dependency Injection addresses common software design problems by:</p> <ul> <li>Decoupling Components: Services don't create their dependencies directly</li> <li>Enabling Testability: Dependencies can be easily mocked or stubbed</li> <li>Managing Lifetimes: Container controls when services are created and disposed</li> <li>Configuration Flexibility: Swap implementations without code changes</li> <li>Cross-cutting Concerns: Centralized service configuration and management</li> </ul>"},{"location":"patterns/dependency-injection/#core-concepts","title":"Core Concepts","text":"Concept Purpose Mario's Pizzeria Example ServiceCollection Registry for service definitions Pizzeria's service catalog of all available services ServiceProvider Container for resolving services Kitchen coordinator that provides the right service when needed ServiceLifetime Controls service creation and disposal Equipment usage patterns (shared vs per-order vs per-use) Interface Abstraction Contracts for service implementations <code>IOrderRepository</code> with File, MongoDB, or Memory implementations"},{"location":"patterns/dependency-injection/#service-lifetime-patterns","title":"\ud83c\udfd7\ufe0f Service Lifetime Patterns","text":"<p>Understanding service lifetimes is crucial for proper resource management and performance:</p>"},{"location":"patterns/dependency-injection/#singleton-shared-infrastructure","title":"Singleton - Shared Infrastructure","text":"<p>Pattern: One instance for the entire application lifetime</p> <pre><code>from neuroglia.dependency_injection import ServiceCollection\n\nservices = ServiceCollection()\n\n# Shared infrastructure services\nservices.add_singleton(DatabaseConnection)      # Connection pool shared across all requests\nservices.add_singleton(MenuCacheService)        # Menu data cached for all customers\nservices.add_singleton(KitchenDisplayService)   # Single kitchen display system\nservices.add_singleton(PaymentGateway)          # Shared payment processing service\nservices.add_singleton(NotificationService)     # Single SMS/email service instance\n</code></pre> <p>When to Use:</p> <ul> <li>Database connection pools</li> <li>Caching services</li> <li>External API clients</li> <li>Configuration services</li> <li>Logging services</li> </ul> <p>Benefits: Memory efficiency, shared state, connection pooling Risks: Thread safety required, potential memory leaks if not disposed</p>"},{"location":"patterns/dependency-injection/#scoped-request-lifecycle","title":"Scoped - Request Lifecycle","text":"<p>Pattern: One instance per scope (typically per HTTP request or business operation)</p> <pre><code># Per-request/per-operation services\nservices.add_scoped(OrderRepository)           # Order data access for this request\nservices.add_scoped(OrderProcessingService)    # Business logic for current order\nservices.add_scoped(CustomerContextService)    # Customer-specific request context\nservices.add_scoped(KitchenWorkflowService)    # Kitchen operations for this order\n</code></pre> <p>When to Use:</p> <ul> <li>Repository instances</li> <li>Business service instances</li> <li>User context services</li> <li>Request-specific caching</li> <li>Database transactions</li> </ul> <p>Benefits: Request isolation, automatic cleanup, consistent state within scope Risks: Higher memory usage than singleton</p>"},{"location":"patterns/dependency-injection/#transient-stateless-operations","title":"Transient - Stateless Operations","text":"<p>Pattern: New instance every time the service is requested</p> <pre><code># Stateless calculation and validation services\nservices.add_transient(PizzaPriceCalculator)    # Fresh calculation each time\nservices.add_transient(DeliveryTimeEstimator)   # Stateless time calculations\nservices.add_transient(LoyaltyPointsCalculator) # Independent point calculations\nservices.add_transient(OrderValidator)          # Fresh validation each time\n</code></pre> <p>When to Use:</p> <ul> <li>Stateless calculators</li> <li>Validators</li> <li>Formatters</li> <li>Short-lived operations</li> <li>Thread-unsafe services</li> </ul> <p>Benefits: No shared state issues, always fresh instance Risks: Highest memory and CPU overhead</p>"},{"location":"patterns/dependency-injection/#registration-patterns","title":"\ud83d\udd27 Registration Patterns","text":""},{"location":"patterns/dependency-injection/#interface-based-registration","title":"Interface-Based Registration","text":"<p>Pattern: Register services by their abstractions to enable flexibility and testing</p> <pre><code>from abc import ABC, abstractmethod\nfrom typing import List, Optional\n\n# Define contract\nclass IOrderRepository(ABC):\n    @abstractmethod\n    async def save_async(self, order: Order) -&gt; None:\n        pass\n\n    @abstractmethod\n    async def get_by_id_async(self, order_id: str) -&gt; Optional[Order]:\n        pass\n\n    @abstractmethod\n    async def get_by_status_async(self, status: str) -&gt; List[Order]:\n        pass\n\n# Multiple implementations\nclass FileOrderRepository(IOrderRepository):\n    def __init__(self, data_dir: str = \"data\"):\n        self.data_dir = Path(data_dir)\n        self.data_dir.mkdir(exist_ok=True)\n\n    async def save_async(self, order: Order) -&gt; None:\n        file_path = self.data_dir / f\"{order.id}.json\"\n        with open(file_path, 'w') as f:\n            json.dump(order.__dict__, f, default=str)\n\nclass MongoOrderRepository(IOrderRepository):\n    def __init__(self, mongo_client: MongoClient):\n        self.collection = mongo_client.pizzeria.orders\n\n    async def save_async(self, order: Order) -&gt; None:\n        await self.collection.replace_one(\n            {\"_id\": order.id},\n            order.__dict__,\n            upsert=True\n        )\n\n# Register by interface - easy to swap implementations\nservices.add_scoped(IOrderRepository, FileOrderRepository)  # Development\n# services.add_scoped(IOrderRepository, MongoOrderRepository)  # Production\n</code></pre>"},{"location":"patterns/dependency-injection/#factory-pattern-registration","title":"Factory Pattern Registration","text":"<p>Pattern: Use factory functions for complex service initialization</p> <pre><code>def create_payment_gateway() -&gt; IPaymentGateway:\n    \"\"\"Factory creates payment gateway based on configuration\"\"\"\n    config = get_payment_config()\n\n    if config.environment == \"development\":\n        return MockPaymentGateway()\n    elif config.provider == \"stripe\":\n        return StripePaymentGateway(config.stripe_api_key)\n    else:\n        return SquarePaymentGateway(config.square_token)\n\ndef create_notification_service() -&gt; INotificationService:\n    \"\"\"Factory creates notification service with proper credentials\"\"\"\n    settings = get_app_settings()\n\n    return TwilioNotificationService(\n        account_sid=settings.twilio_sid,\n        auth_token=settings.twilio_token,\n        from_number=settings.pizzeria_phone\n    )\n\n# Register with factories\nservices.add_singleton(IPaymentGateway, factory=create_payment_gateway)\nservices.add_singleton(INotificationService, factory=create_notification_service)\n</code></pre>"},{"location":"patterns/dependency-injection/#generic-repository-pattern","title":"Generic Repository Pattern","text":"<p>Pattern: Generic repository implementation for multiple entity types</p> <pre><code>from typing import TypeVar, Generic\nfrom neuroglia.data.abstractions import Repository\n\nT = TypeVar('T')\nTKey = TypeVar('TKey')\n\nclass FileRepository(Repository[T, TKey], Generic[T, TKey]):\n    \"\"\"Generic file-based repository for any entity type\"\"\"\n\n    def __init__(self, entity_type: type, data_dir: str = \"data\"):\n        self.entity_type = entity_type\n        self.data_dir = Path(data_dir) / entity_type.__name__.lower()\n        self.data_dir.mkdir(parents=True, exist_ok=True)\n\n    async def save_async(self, entity: T) -&gt; None:\n        file_path = self.data_dir / f\"{entity.id}.json\"\n        with open(file_path, 'w') as f:\n            json.dump(entity.__dict__, f, default=str)\n\n# Factory functions for type-safe registration\ndef create_pizza_repository() -&gt; Repository[Pizza, str]:\n    return FileRepository(Pizza, \"data\")\n\ndef create_order_repository() -&gt; Repository[Order, str]:\n    return FileRepository(Order, \"data\")\n\n# Register generic repositories\nservices.add_scoped(Repository[Pizza, str], factory=create_pizza_repository)\nservices.add_scoped(Repository[Order, str], factory=create_order_repository)\n</code></pre>"},{"location":"patterns/dependency-injection/#constructor-injection-pattern","title":"\ud83c\udfaf Constructor Injection Pattern","text":"<p>Pattern: Dependencies are provided through constructor parameters</p> <pre><code>class OrderService:\n    \"\"\"Service with injected dependencies\"\"\"\n\n    def __init__(self,\n                 order_repository: IOrderRepository,\n                 payment_service: IPaymentService,\n                 notification_service: INotificationService,\n                 mapper: IMapper):\n        self.order_repository = order_repository\n        self.payment_service = payment_service\n        self.notification_service = notification_service\n        self.mapper = mapper\n\n    async def place_order_async(self, order_dto: OrderDto) -&gt; OperationResult[OrderDto]:\n        # Dependencies injected automatically\n        order = self.mapper.map(order_dto, Order)\n\n        # Process payment using injected service\n        payment_result = await self.payment_service.process_payment_async(order.total)\n        if not payment_result.success:\n            return OperationResult.bad_request(\"Payment failed\")\n\n        # Save using injected repository\n        await self.order_repository.save_async(order)\n\n        # Send notification using injected service\n        await self.notification_service.send_confirmation_async(order)\n\n        return OperationResult.ok(self.mapper.map(order, OrderDto))\n\nclass OrderController(ControllerBase):\n    \"\"\"Controller with service injection\"\"\"\n\n    def __init__(self,\n                 service_provider: ServiceProvider,\n                 mapper: IMapper,\n                 mediator: IMediator):\n        super().__init__(service_provider, mapper, mediator)\n        # Dependencies resolved automatically by framework\n</code></pre>"},{"location":"patterns/dependency-injection/#testing-with-dependency-injection","title":"\ud83e\uddea Testing with Dependency Injection","text":"<p>Pattern: Easy mocking and testing through dependency injection</p> <pre><code>import pytest\nfrom unittest.mock import Mock, AsyncMock\n\nclass TestOrderService:\n    \"\"\"Test class demonstrating DI testing benefits\"\"\"\n\n    def setup_method(self):\n        # Create mocks for all dependencies\n        self.order_repository = Mock(spec=IOrderRepository)\n        self.payment_service = Mock(spec=IPaymentService)\n        self.notification_service = Mock(spec=INotificationService)\n        self.mapper = Mock(spec=IMapper)\n\n        # Inject mocks into service\n        self.order_service = OrderService(\n            self.order_repository,\n            self.payment_service,\n            self.notification_service,\n            self.mapper\n        )\n\n    @pytest.mark.asyncio\n    async def test_place_order_success(self):\n        # Arrange - setup mock behaviors\n        order_dto = OrderDto(customer_name=\"Test\", total=25.99)\n        order = Order(id=\"123\", customer_name=\"Test\", total=25.99)\n\n        self.mapper.map.return_value = order\n        self.payment_service.process_payment_async = AsyncMock(\n            return_value=PaymentResult(success=True)\n        )\n        self.order_repository.save_async = AsyncMock()\n        self.notification_service.send_confirmation_async = AsyncMock()\n\n        # Act\n        result = await self.order_service.place_order_async(order_dto)\n\n        # Assert\n        assert result.is_success\n        self.payment_service.process_payment_async.assert_called_once_with(25.99)\n        self.order_repository.save_async.assert_called_once_with(order)\n        self.notification_service.send_confirmation_async.assert_called_once_with(order)\n</code></pre>"},{"location":"patterns/dependency-injection/#advanced-patterns","title":"\ud83d\ude80 Advanced Patterns","text":""},{"location":"patterns/dependency-injection/#service-locator-anti-pattern","title":"Service Locator Anti-Pattern","text":"<p>\u274c Avoid: Service Locator pattern hides dependencies</p> <pre><code># BAD - Service Locator hides dependencies\nclass OrderService:\n    def process_order(self, order_dto: OrderDto):\n        # Hidden dependencies - hard to test and understand\n        repository = ServiceLocator.get(IOrderRepository)\n        payment = ServiceLocator.get(IPaymentService)\n        # ... rest of implementation\n</code></pre> <p>\u2705 Prefer: Constructor Injection makes dependencies explicit</p> <pre><code># GOOD - Dependencies are explicit and testable\nclass OrderService:\n    def __init__(self,\n                 repository: IOrderRepository,\n                 payment: IPaymentService):\n        self.repository = repository\n        self.payment = payment\n</code></pre>"},{"location":"patterns/dependency-injection/#configuration-based-registration","title":"Configuration-Based Registration","text":"<p>Pattern: Configure services based on environment or settings</p> <pre><code>def configure_services(services: ServiceCollection, environment: str):\n    \"\"\"Configure services based on environment\"\"\"\n\n    # Always register core abstractions\n    services.add_transient(IMapper, AutoMapper)\n    services.add_scoped(IOrderService, OrderService)\n\n    # Environment-specific implementations\n    if environment == \"development\":\n        services.add_scoped(IOrderRepository, FileOrderRepository)\n        services.add_singleton(IPaymentService, MockPaymentService)\n        services.add_singleton(INotificationService, ConsoleNotificationService)\n\n    elif environment == \"testing\":\n        services.add_scoped(IOrderRepository, InMemoryOrderRepository)\n        services.add_singleton(IPaymentService, MockPaymentService)\n        services.add_singleton(INotificationService, NoOpNotificationService)\n\n    elif environment == \"production\":\n        services.add_scoped(IOrderRepository, MongoOrderRepository)\n        services.add_singleton(IPaymentService, StripePaymentService)\n        services.add_singleton(INotificationService, TwilioNotificationService)\n</code></pre>"},{"location":"patterns/dependency-injection/#integration-with-other-patterns","title":"\ud83d\udd17 Integration with Other Patterns","text":""},{"location":"patterns/dependency-injection/#di-cqrs-pattern","title":"DI + CQRS Pattern","text":"<pre><code># Command handlers with injected dependencies\nclass PlaceOrderHandler(ICommandHandler[PlaceOrderCommand, OperationResult]):\n    def __init__(self,\n                 order_repository: IOrderRepository,\n                 payment_service: IPaymentService):\n        self.order_repository = order_repository\n        self.payment_service = payment_service\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult:\n        # Implementation uses injected dependencies\n        pass\n\n# Register handlers\nservices.add_scoped(ICommandHandler[PlaceOrderCommand, OperationResult], PlaceOrderHandler)\n</code></pre>"},{"location":"patterns/dependency-injection/#di-repository-pattern","title":"DI + Repository Pattern","text":"<pre><code># Repository with injected infrastructure dependencies\nclass OrderRepository(IOrderRepository):\n    def __init__(self,\n                 mongo_client: MongoClient,\n                 logger: ILogger,\n                 cache: ICache):\n        self.collection = mongo_client.pizzeria.orders\n        self.logger = logger\n        self.cache = cache\n</code></pre>"},{"location":"patterns/dependency-injection/#common-mistakes","title":"\u26a0\ufe0f Common Mistakes","text":""},{"location":"patterns/dependency-injection/#1-service-locator-anti-pattern","title":"1. Service Locator Anti-Pattern","text":"<pre><code># \u274c WRONG: Service Locator (anti-pattern)\nclass OrderService:\n    def __init__(self, service_locator: ServiceProvider):\n        # Service locator is DI's evil twin!\n        self.service_locator = service_locator\n\n    async def create_order(self, customer_id: str):\n        # Hides dependencies - what does this service need?\n        repository = self.service_locator.get_service(IOrderRepository)\n        email = self.service_locator.get_service(IEmailService)\n        payment = self.service_locator.get_service(IPaymentGateway)\n        # Dependencies are HIDDEN!\n\n# \u2705 CORRECT: Constructor injection (explicit dependencies)\nclass OrderService:\n    def __init__(self,\n                 order_repository: IOrderRepository,\n                 email_service: IEmailService,\n                 payment_gateway: IPaymentGateway):\n        # Dependencies are EXPLICIT and visible!\n        self.order_repository = order_repository\n        self.email_service = email_service\n        self.payment_gateway = payment_gateway\n</code></pre>"},{"location":"patterns/dependency-injection/#2-incorrect-service-lifetimes","title":"2. Incorrect Service Lifetimes","text":"<pre><code># \u274c WRONG: Database connection as transient (creates new connection every time!)\nservices.add_transient(MongoClient, lambda: MongoClient(\"mongodb://localhost\"))\n# This creates a NEW MongoDB connection for EVERY service that needs it!\n\n# \u274c WRONG: Request-specific service as singleton (shared across all requests!)\nservices.add_singleton(CurrentUserService)\n# This shares the SAME user across all requests!\n\n# \u2705 CORRECT: Appropriate lifetimes\nservices.add_singleton(MongoClient, lambda: MongoClient(\"mongodb://localhost\"))\nservices.add_scoped(CurrentUserService)  # One per request\nservices.add_transient(OrderValidator)   # Stateless, new instance each time\n</code></pre>"},{"location":"patterns/dependency-injection/#3-circular-dependencies","title":"3. Circular Dependencies","text":"<pre><code># \u274c WRONG: Circular dependency (A needs B, B needs A)\nclass OrderService:\n    def __init__(self, customer_service: CustomerService):\n        self.customer_service = customer_service\n\nclass CustomerService:\n    def __init__(self, order_service: OrderService):\n        self.order_service = order_service  # Circular!\n\n# \u2705 CORRECT: Extract shared logic or use events\nclass OrderService:\n    def __init__(self, customer_repository: ICustomerRepository):\n        self.customer_repository = customer_repository\n\nclass CustomerService:\n    def __init__(self, customer_repository: ICustomerRepository):\n        self.customer_repository = customer_repository\n\n# Both use repository, no circular dependency!\n</code></pre>"},{"location":"patterns/dependency-injection/#4-not-using-interfaces","title":"4. Not Using Interfaces","text":"<pre><code># \u274c WRONG: Depending on concrete implementations\nclass OrderService:\n    def __init__(self, mongo_repository: MongoOrderRepository):\n        # Coupled to MongoDB implementation!\n        self.repository = mongo_repository\n\n# \u2705 CORRECT: Depend on abstractions\nclass OrderService:\n    def __init__(self, order_repository: IOrderRepository):\n        # Can use ANY repository implementation!\n        self.repository = order_repository\n\n# Register concrete implementation\nservices.add_scoped(IOrderRepository, MongoOrderRepository)\n# Easy to swap: services.add_scoped(IOrderRepository, PostgresOrderRepository)\n</code></pre>"},{"location":"patterns/dependency-injection/#5-fat-constructors-too-many-dependencies","title":"5. Fat Constructors (Too Many Dependencies)","text":"<pre><code># \u274c WRONG: Service with too many dependencies (code smell!)\nclass OrderService:\n    def __init__(self,\n                 order_repository: IOrderRepository,\n                 customer_repository: ICustomerRepository,\n                 product_repository: IProductRepository,\n                 payment_gateway: IPaymentGateway,\n                 email_service: IEmailService,\n                 sms_service: ISmsService,\n                 inventory_service: IInventoryService,\n                 loyalty_service: ILoyaltyService,\n                 analytics_service: IAnalyticsService,\n                 audit_service: IAuditService):\n        # 10 dependencies = this class does TOO MUCH!\n        pass\n\n# \u2705 CORRECT: Split into focused services\nclass OrderService:\n    def __init__(self,\n                 order_repository: IOrderRepository,\n                 order_processor: IOrderProcessor):\n        # Delegate to specialized services\n        self.repository = order_repository\n        self.processor = order_processor\n\nclass OrderProcessor:\n    def __init__(self,\n                 payment_gateway: IPaymentGateway,\n                 notification_service: INotificationService):\n        # Focused responsibility\n        self.payment = payment_gateway\n        self.notifications = notification_service\n</code></pre>"},{"location":"patterns/dependency-injection/#6-not-disposing-resources","title":"6. Not Disposing Resources","text":"<pre><code># \u274c WRONG: Not disposing scoped services\nasync def handle_request():\n    provider = services.build_provider()\n    service = provider.get_service(OrderService)\n    await service.create_order(...)\n    # Provider never disposed - resource leak!\n\n# \u2705 CORRECT: Dispose scoped services properly\nasync def handle_request():\n    scope = services.create_scope()\n    try:\n        service = scope.service_provider.get_service(OrderService)\n        await service.create_order(...)\n    finally:\n        scope.dispose()  # Clean up resources!\n</code></pre>"},{"location":"patterns/dependency-injection/#when-not-to-use","title":"\ud83d\udeab When NOT to Use","text":""},{"location":"patterns/dependency-injection/#1-simple-scripts-and-utilities","title":"1. Simple Scripts and Utilities","text":"<pre><code># DI adds unnecessary complexity for simple scripts\nclass DataMigrationScript:\n    \"\"\"One-time data migration script\"\"\"\n    def run(self):\n        # Just create what you need directly\n        source_db = MongoClient(\"mongodb://localhost:27017\")\n        target_db = PostgresClient(\"postgresql://localhost:5432\")\n\n        # No need for DI container for a simple script\n        data = source_db.old_db.collection.find()\n        for item in data:\n            target_db.new_db.table.insert(item)\n</code></pre>"},{"location":"patterns/dependency-injection/#2-framework-entry-points-already-have-di","title":"2. Framework Entry Points (Already Have DI)","text":"<pre><code># FastAPI already has dependency injection built-in\nfrom fastapi import Depends\n\n@app.get(\"/orders/{order_id}\")\nasync def get_order(\n    order_id: str,\n    repository: IOrderRepository = Depends(get_order_repository)\n):\n    # FastAPI's Depends() is DI - don't add Neuroglia DI on top\n    return await repository.get_by_id_async(order_id)\n</code></pre>"},{"location":"patterns/dependency-injection/#3-value-objects-and-dtos","title":"3. Value Objects and DTOs","text":"<pre><code># Value objects shouldn't use DI - they should be simple data\n@dataclass\nclass Address:\n    \"\"\"Simple value object - no dependencies needed\"\"\"\n    street: str\n    city: str\n    zip_code: str\n\n    # No constructor injection - just data!\n</code></pre>"},{"location":"patterns/dependency-injection/#4-static-utility-classes","title":"4. Static Utility Classes","text":"<pre><code># Static utilities don't need DI\nclass StringUtils:\n    \"\"\"Stateless utility functions\"\"\"\n    @staticmethod\n    def to_kebab_case(text: str) -&gt; str:\n        return text.lower().replace(\"_\", \"-\")\n\n    # No dependencies, no state, no need for DI\n</code></pre>"},{"location":"patterns/dependency-injection/#5-very-small-applications-100-lines","title":"5. Very Small Applications (&lt; 100 lines)","text":"<pre><code># For tiny apps, DI is overkill\nclass TinyBot:\n    \"\"\"Simple Discord bot with 3 commands\"\"\"\n    def __init__(self):\n        # Just create what you need\n        self.client = discord.Client()\n        self.commands = [\"!help\", \"!ping\", \"!joke\"]\n\n    # No need for DI container for such a small app\n</code></pre>"},{"location":"patterns/dependency-injection/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ul> <li>Dependency Injection inverts control: Dependencies injected, not created internally</li> <li>Use constructor injection for explicit, testable dependencies</li> <li>Register services with appropriate lifetimes: Singleton, Scoped, or Transient</li> <li>Depend on abstractions (interfaces), not concrete implementations</li> <li>Service Locator is an anti-pattern - use constructor injection instead</li> <li>Avoid circular dependencies - extract shared logic or use events</li> <li>Fat constructors indicate too many responsibilities - split services</li> <li>DI enables testability by allowing easy mocking</li> <li>Framework provides ServiceCollection and ServiceProvider for DI management</li> <li>Dispose scoped services properly to prevent resource leaks</li> </ul>"},{"location":"patterns/dependency-injection/#related-patterns","title":"\ud83d\udcda Related Patterns","text":"<ul> <li>\ud83c\udfaf CQRS Pattern - Command and query handlers use DI for dependencies</li> <li>\ud83d\udcbe Repository Pattern - Repositories are registered and injected as services</li> <li>\ud83d\udd04 Event-Driven Pattern - Event handlers use DI for their dependencies</li> <li>\ud83c\udfd7\ufe0f Clean Architecture - DI enables layer separation and dependency inversion</li> </ul> <p>Dependency Injection is fundamental to building testable, maintainable applications. Mario's Pizzeria demonstrates how proper DI patterns enable flexible architecture and easy testing.</p>"},{"location":"patterns/domain-driven-design/","title":"\ud83c\udfdb\ufe0f Domain Driven Design Pattern","text":"<p>Estimated reading time: 45 minutes</p> <p>Domain Driven Design (DDD) forms the architectural foundation of the Neuroglia framework, providing core abstractions and patterns that enable rich, expressive domain models while maintaining clean separation of concerns.</p> <p>This pattern serves as the primary reference for understanding how domain logic flows through the API, Application, Domain, and Integration layers.</p>"},{"location":"patterns/domain-driven-design/#what-why","title":"\ud83c\udfaf What &amp; Why","text":""},{"location":"patterns/domain-driven-design/#the-problem-anemic-domain-models","title":"The Problem: Anemic Domain Models","text":"<p>Without DDD, business logic scatters across services and controllers, resulting in anemic domain models:</p> <pre><code># \u274c Problem: Anemic domain model - just a data bag\nclass Order:\n    def __init__(self):\n        self.id = None\n        self.customer_id = None\n        self.items = []\n        self.total = 0\n        self.status = \"pending\"\n        # \u274c No behavior, just properties\n\n# \u274c Business logic scattered in service\nclass OrderService:\n    async def place_order(self, order_data: dict):\n        # \u274c Business rules in service layer\n        order = Order()\n        order.customer_id = order_data[\"customer_id\"]\n        order.items = order_data[\"items\"]\n\n        # \u274c Total calculation logic here\n        subtotal = sum(item[\"price\"] * item[\"quantity\"] for item in order.items)\n        tax = subtotal * 0.08\n        order.total = subtotal + tax\n\n        # \u274c Validation logic here\n        if order.total &gt; 1000:\n            raise ValueError(\"Order exceeds maximum amount\")\n\n        # \u274c Business rule enforcement here\n        if len(order.items) == 0:\n            raise ValueError(\"Order must have items\")\n\n        await self._db.save(order)\n\n        # \u274c Events created manually, not from domain\n        await self._event_bus.publish({\"type\": \"OrderPlaced\", \"order_id\": order.id})\n\n# \u274c Different service duplicates same logic\nclass ReportingService:\n    async def calculate_revenue(self, orders: List[Order]):\n        # \u274c Duplicating total calculation logic\n        total_revenue = 0\n        for order in orders:\n            subtotal = sum(item[\"price\"] * item[\"quantity\"] for item in order.items)\n            tax = subtotal * 0.08\n            total_revenue += subtotal + tax\n        return total_revenue\n</code></pre> <p>Problems with this approach:</p> <ol> <li>Scattered Business Logic: Rules spread across services, controllers, utilities</li> <li>Duplication: Same calculations repeated in multiple places</li> <li>No Encapsulation: Anyone can modify order state without validation</li> <li>Hard to Test: Must test through services with infrastructure dependencies</li> <li>Lost Domain Knowledge: Business rules not expressed in domain language</li> <li>Difficult Maintenance: Changes require hunting through multiple files</li> </ol>"},{"location":"patterns/domain-driven-design/#the-solution-rich-domain-models-with-ddd","title":"The Solution: Rich Domain Models with DDD","text":"<p>Encapsulate business logic in domain entities with clear behavior:</p> <pre><code># \u2705 Solution: Rich domain model with behavior\nfrom neuroglia.data.abstractions import Entity\nfrom decimal import Decimal\n\nclass Order(Entity):\n    \"\"\"Rich domain entity with business logic and validation\"\"\"\n\n    def __init__(self, customer_id: str, items: List[OrderItem]):\n        super().__init__()\n\n        # \u2705 Business rule validation at construction\n        if not items:\n            raise ValueError(\"Order must contain at least one item\")\n\n        self.customer_id = customer_id\n        self.items = items\n        self.status = OrderStatus.PENDING\n        self.total = self._calculate_total()  # \u2705 Encapsulated calculation\n\n        # \u2705 Business rule enforcement\n        if self.total &gt; Decimal(\"1000.00\"):\n            raise ValueError(\"Order exceeds maximum allowed amount\")\n\n        # \u2705 Domain event automatically raised\n        self.raise_event(OrderPlacedEvent(\n            order_id=self.id,\n            customer_id=customer_id,\n            total=self.total,\n            items=[item.to_dto() for item in items]\n        ))\n\n    def _calculate_total(self) -&gt; Decimal:\n        \"\"\"\u2705 Business rule: Calculate total with tax\"\"\"\n        subtotal = sum(item.price * item.quantity for item in self.items)\n        tax = subtotal * Decimal(\"0.08\")  # 8% tax rate\n        return subtotal + tax\n\n    def add_item(self, item: OrderItem):\n        \"\"\"\u2705 Business operation with validation\"\"\"\n        if self.status != OrderStatus.PENDING:\n            raise InvalidOperationError(\"Cannot modify confirmed order\")\n\n        # \u2705 Check business constraint\n        new_total = self.total + (item.price * item.quantity * Decimal(\"1.08\"))\n        if new_total &gt; Decimal(\"1000.00\"):\n            raise ValueError(\"Adding item would exceed maximum order amount\")\n\n        self.items.append(item)\n        self.total = self._calculate_total()\n\n        # \u2705 Domain event for business occurrence\n        self.raise_event(OrderItemAddedEvent(\n            order_id=self.id,\n            item=item.to_dto()\n        ))\n\n    def confirm(self, payment_transaction_id: str):\n        \"\"\"\u2705 Business workflow encapsulated\"\"\"\n        if self.status != OrderStatus.PENDING:\n            raise InvalidOperationError(f\"Cannot confirm order in {self.status} status\")\n\n        self.status = OrderStatus.CONFIRMED\n        self.payment_transaction_id = payment_transaction_id\n        self.confirmed_at = datetime.utcnow()\n\n        # \u2705 Domain event for state change\n        self.raise_event(OrderConfirmedEvent(\n            order_id=self.id,\n            transaction_id=payment_transaction_id\n        ))\n\n# \u2705 Service layer is thin - just orchestration\nclass PlaceOrderHandler(CommandHandler):\n    async def handle_async(self, command: PlaceOrderCommand):\n        # \u2705 Domain entity handles all business logic\n        order = Order(command.customer_id, command.items)\n\n        # \u2705 Process payment (external concern)\n        payment = await self._payment_service.process_async(order.total)\n        if not payment.success:\n            return self.bad_request(\"Payment failed\")\n\n        order.confirm(payment.transaction_id)\n\n        # \u2705 Persist (infrastructure concern)\n        await self._repository.save_async(order)\n\n        # \u2705 Events automatically published by framework\n        return self.created(self._mapper.map(order, OrderDto))\n</code></pre> <p>Benefits of DDD approach:</p> <ol> <li>Encapsulated Business Logic: All rules in domain entities</li> <li>Single Source of Truth: Business calculations in one place</li> <li>Self-Validating: Entities enforce invariants automatically</li> <li>Easy Testing: Test pure domain logic without infrastructure</li> <li>Ubiquitous Language: Code matches business terminology</li> <li>Maintainability: Changes localized to domain entities</li> <li>Domain Events: First-class representation of business occurrences</li> </ol>"},{"location":"patterns/domain-driven-design/#pattern-overview","title":"\ud83c\udfaf Pattern Overview","text":"<p>Domain Driven Design is a software development methodology that emphasizes modeling complex business domains through rich domain models, ubiquitous language, and strategic design patterns. The Neuroglia framework implements DDD principles through a comprehensive set of base abstractions that support both traditional CRUD operations and advanced patterns like event sourcing.</p>"},{"location":"patterns/domain-driven-design/#core-ddd-principles","title":"\ud83c\udf1f Core DDD Principles","text":"<ul> <li>\ud83c\udfdb\ufe0f Rich Domain Models: Business logic lives in domain entities, not in services</li> <li>\ud83d\udde3\ufe0f Ubiquitous Language: Common vocabulary shared between business and technical teams</li> <li>\ud83c\udfaf Bounded Contexts: Clear boundaries around cohesive domain models</li> <li>\ud83d\udcda Aggregate Boundaries: Consistency boundaries that encapsulate business invariants</li> <li>\u26a1 Domain Events: First-class representation of business events and state changes</li> </ul>"},{"location":"patterns/domain-driven-design/#framework-integration","title":"\ud83d\udd04 Framework Integration","text":"<p>The framework provides core abstractions that seamlessly integrate with all architectural layers:</p> <pre><code>graph TB\n    subgraph \"\ud83c\udf10 API Layer\"\n        Controllers[\"Controllers&lt;br/&gt;HTTP Endpoints\"]\n        DTOs[\"DTOs&lt;br/&gt;Data Transfer Objects\"]\n    end\n\n    subgraph \"\ud83d\udcbc Application Layer\"\n        Commands[\"Commands&lt;br/&gt;Write Operations\"]\n        Queries[\"Queries&lt;br/&gt;Read Operations\"]\n        Handlers[\"Handlers&lt;br/&gt;Business Orchestration\"]\n    end\n\n    subgraph \"\ud83c\udfdb\ufe0f Domain Layer\"\n        Entities[\"Entities&lt;br/&gt;Business Objects\"]\n        Aggregates[\"Aggregate Roots&lt;br/&gt;Consistency Boundaries\"]\n        DomainEvents[\"Domain Events&lt;br/&gt;Business Events\"]\n        ValueObjects[\"Value Objects&lt;br/&gt;Immutable Data\"]\n    end\n\n    subgraph \"\ud83d\udd0c Integration Layer\"\n        Repositories[\"Repositories&lt;br/&gt;Data Access\"]\n        EventBus[\"Event Bus&lt;br/&gt;Integration Events\"]\n        ExternalAPIs[\"External APIs&lt;br/&gt;Third-party Services\"]\n    end\n\n    Controllers --&gt; Commands\n    Controllers --&gt; Queries\n    Commands --&gt; Handlers\n    Queries --&gt; Handlers\n    Handlers --&gt; Aggregates\n    Handlers --&gt; Repositories\n    Aggregates --&gt; DomainEvents\n    DomainEvents --&gt; EventBus\n    Repositories --&gt; ExternalAPIs\n\n    style Entities fill:#e8f5e8\n    style Aggregates fill:#e8f5e8\n    style DomainEvents fill:#fff3e0\n    style ValueObjects fill:#e8f5e8</code></pre>"},{"location":"patterns/domain-driven-design/#core-domain-abstractions","title":"\ud83c\udf55 Core Domain Abstractions","text":""},{"location":"patterns/domain-driven-design/#1-entity-base-class","title":"1. Entity Base Class","text":"<p>Entities represent objects with distinct identity that persist over time:</p> <pre><code>from neuroglia.data.abstractions import Entity\nfrom datetime import datetime\nfrom typing import List\nimport uuid\n\nclass Pizza(Entity[str]):\n    \"\"\"Pizza entity with business logic and identity\"\"\"\n\n    def __init__(self, name: str, price: float, ingredients: List[str], id: str = None):\n        super().__init__()\n        self.id = id or f\"pizza_{uuid.uuid4().hex[:8]}\"\n        self.name = name\n        self.price = price\n        self.ingredients = ingredients.copy()\n        self.is_available = True\n        self.created_at = datetime.now()\n\n        # Business rule validation\n        if price &lt;= 0:\n            raise ValueError(\"Pizza price must be positive\")\n        if not ingredients:\n            raise ValueError(\"Pizza must have at least one ingredient\")\n\n    def add_ingredient(self, ingredient: str) -&gt; None:\n        \"\"\"Add ingredient with business rule validation\"\"\"\n        if ingredient in self.ingredients:\n            raise ValueError(f\"Ingredient '{ingredient}' already exists\")\n\n        self.ingredients.append(ingredient)\n        self.price += 2.50  # Business rule: each ingredient adds $2.50\n        self.updated_at = datetime.now()\n\n    def remove_ingredient(self, ingredient: str) -&gt; None:\n        \"\"\"Remove ingredient with business validation\"\"\"\n        if ingredient not in self.ingredients:\n            raise ValueError(f\"Ingredient '{ingredient}' not found\")\n        if len(self.ingredients) &lt;= 1:\n            raise ValueError(\"Pizza must have at least one ingredient\")\n\n        self.ingredients.remove(ingredient)\n        self.price -= 2.50\n        self.updated_at = datetime.now()\n\n    def make_unavailable(self, reason: str) -&gt; None:\n        \"\"\"Business operation to make pizza unavailable\"\"\"\n        self.is_available = False\n        self.unavailable_reason = reason\n        self.updated_at = datetime.now()\n</code></pre>"},{"location":"patterns/domain-driven-design/#2-domain-events","title":"2. Domain Events","text":"<p>Domain Events represent important business occurrences that other parts of the system need to know about:</p> <pre><code>from neuroglia.data.abstractions import DomainEvent\nfrom dataclasses import dataclass\nfrom decimal import Decimal\nfrom datetime import datetime\nfrom typing import List, Dict, Any\n\n@dataclass\nclass PizzaOrderPlacedEvent(DomainEvent[str]):\n    \"\"\"Domain event representing a pizza order being placed\"\"\"\n    customer_id: str\n    items: List[Dict[str, Any]]\n    total_amount: Decimal\n    special_instructions: str\n\n    def __init__(self, aggregate_id: str, customer_id: str, items: List[Dict[str, Any]],\n                 total_amount: Decimal, special_instructions: str = \"\"):\n        super().__init__(aggregate_id)\n        self.customer_id = customer_id\n        self.items = items\n        self.total_amount = total_amount\n        self.special_instructions = special_instructions\n\n@dataclass\nclass OrderStatusChangedEvent(DomainEvent[str]):\n    \"\"\"Domain event representing order status changes\"\"\"\n    previous_status: str\n    new_status: str\n    changed_by: str\n    reason: str\n\n    def __init__(self, aggregate_id: str, previous_status: str, new_status: str,\n                 changed_by: str, reason: str = \"\"):\n        super().__init__(aggregate_id)\n        self.previous_status = previous_status\n        self.new_status = new_status\n        self.changed_by = changed_by\n        self.reason = reason\n\n@dataclass\nclass PaymentProcessedEvent(DomainEvent[str]):\n    \"\"\"Domain event representing successful payment processing\"\"\"\n    payment_method: str\n    amount: Decimal\n    transaction_id: str\n    processed_at: datetime\n\n    def __init__(self, aggregate_id: str, payment_method: str, amount: Decimal,\n                 transaction_id: str):\n        super().__init__(aggregate_id)\n        self.payment_method = payment_method\n        self.amount = amount\n        self.transaction_id = transaction_id\n        self.processed_at = datetime.now()\n</code></pre>"},{"location":"patterns/domain-driven-design/#framework-data-abstractions","title":"\ud83c\udfd7\ufe0f Framework Data Abstractions","text":""},{"location":"patterns/domain-driven-design/#core-base-classes","title":"Core Base Classes","text":"<p>The Neuroglia framework provides a comprehensive set of base abstractions that form the foundation of domain-driven design. These abstractions enforce patterns while providing flexibility for different architectural approaches.</p> <pre><code># /src/neuroglia/data/abstractions.py\nfrom abc import ABC\nfrom datetime import datetime\nfrom typing import Generic, List, Type, TypeVar\n\nTKey = TypeVar(\"TKey\")\n\"\"\"Represents the generic argument used to specify the type of key to use\"\"\"\n\nclass Identifiable(Generic[TKey], ABC):\n    \"\"\"Defines the fundamentals of an object that can be identified based on a unique identifier\"\"\"\n    id: TKey\n\nclass Entity(Generic[TKey], Identifiable[TKey], ABC):\n    \"\"\"Represents the abstract class inherited by all entities in the application\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.created_at = datetime.now()\n\n    created_at: datetime\n    last_modified: datetime\n\nclass VersionedState(ABC):\n    \"\"\"Represents the abstract class inherited by all versioned states\"\"\"\n\n    def __init__(self):\n        self.state_version = 0\n\n    state_version: int = 0\n\nclass AggregateState(Generic[TKey], Identifiable[TKey], VersionedState, ABC):\n    \"\"\"Represents the abstract class inherited by all aggregate root states\"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n    id: TKey\n    created_at: datetime\n    last_modified: datetime\n\nclass DomainEvent(Generic[TKey], ABC):\n    \"\"\"Represents the base class inherited by all domain events\"\"\"\n\n    def __init__(self, aggregate_id: TKey):\n        self.created_at = datetime.now()\n        self.aggregate_id = aggregate_id\n\n    created_at: datetime\n    aggregate_id: TKey\n    aggregate_version: int\n\nclass AggregateRoot(Generic[TState, TKey], Entity[TKey], ABC):\n    \"\"\"Represents the base class for all aggregate roots\"\"\"\n\n    _pending_events: List[DomainEvent]\n\n    def __init__(self):\n        self.state = object.__new__(self.__orig_bases__[0].__args__[0])\n        self.state.__init__()\n        self._pending_events = list[DomainEvent]()\n\n    def id(self):\n        return self.state.id\n\n    state: TState\n\n    def register_event(self, e: TEvent) -&gt; TEvent:\n        \"\"\"Registers the specified domain event\"\"\"\n        if not hasattr(self, \"_pending_events\"):\n            self._pending_events = list[DomainEvent]()\n        self._pending_events.append(e)\n        e.aggregate_version = self.state.state_version + len(self._pending_events)\n        return e\n\n    def clear_pending_events(self):\n        \"\"\"Clears all pending domain events\"\"\"\n        self._pending_events.clear()\n</code></pre>"},{"location":"patterns/domain-driven-design/#domain-event-application-mechanism","title":"\u26a1 Domain Event Application Mechanism","text":""},{"location":"patterns/domain-driven-design/#understanding-selfstateon-and-selfregister_event","title":"Understanding <code>self.state.on()</code> and <code>self.register_event()</code>","text":"<p>The framework implements a sophisticated event sourcing pattern where domain events serve dual purposes:</p> <ol> <li>State Application: Events modify aggregate state through the <code>state.on()</code> method</li> <li>Event Registration: Events are registered for persistence and external handling via <code>register_event()</code></li> </ol>"},{"location":"patterns/domain-driven-design/#event-flow-architecture","title":"Event Flow Architecture","text":"<pre><code>graph TB\n    subgraph \"\ud83c\udfaf Business Operation\"\n        A[Business Method Called]\n        B[Validate Business Rules]\n        C[Create Domain Event]\n    end\n\n    subgraph \"\u26a1 Event Processing Pipeline\"\n        D[state.on event]\n        E[register_event event]\n        F[Update State Version]\n        G[Add to Pending Events]\n    end\n\n    subgraph \"\ud83d\udcbe Persistence &amp; Distribution\"\n        H[Repository Save]\n        I[Event Store Append]\n        J[Event Bus Publish]\n        K[Integration Events]\n    end\n\n    A --&gt; B\n    B --&gt; C\n    C --&gt; D\n    C --&gt; E\n    D --&gt; F\n    E --&gt; G\n    F --&gt; H\n    G --&gt; I\n    I --&gt; J\n    J --&gt; K\n\n    style D fill:#e8f5e8\n    style E fill:#fff3e0\n    style I fill:#e3f2fd</code></pre>"},{"location":"patterns/domain-driven-design/#event-application-pattern-with-multiple-dispatch","title":"Event Application Pattern with Multiple Dispatch","text":"<pre><code>from multipledispatch import dispatch\nfrom neuroglia.data.abstractions import AggregateRoot, AggregateState\n\nclass BankAccountState(AggregateState[str]):\n    \"\"\"Aggregate state with event handlers using multiple dispatch\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.account_number: Optional[str] = None\n        self.owner_name: Optional[str] = None\n        self.balance: Decimal = Decimal(\"0.00\")\n        self.account_type: Optional[str] = None\n        self.is_active: bool = True\n\n    @dispatch(AccountCreatedEvent)\n    def on(self, event: AccountCreatedEvent):\n        \"\"\"Apply account created event to state\"\"\"\n        self.id = event.aggregate_id\n        self.created_at = event.created_at\n        self.account_number = event.account_number\n        self.owner_name = event.owner_name\n        self.balance = event.initial_balance\n        self.account_type = event.account_type\n        self.is_active = True\n\n    @dispatch(MoneyDepositedEvent)\n    def on(self, event: MoneyDepositedEvent):\n        \"\"\"Apply money deposited event to state\"\"\"\n        self.balance = event.new_balance\n        self.last_modified = event.created_at\n\n    @dispatch(MoneyWithdrawnEvent)\n    def on(self, event: MoneyWithdrawnEvent):\n        \"\"\"Apply money withdrawn event to state\"\"\"\n        self.balance = event.new_balance\n        self.last_modified = event.created_at\n\nclass BankAccountAggregate(AggregateRoot[BankAccountState, str]):\n    \"\"\"Aggregate root demonstrating event application pattern\"\"\"\n\n    def create_account(self, account_number: str, owner_name: str,\n                      initial_balance: Decimal, account_type: str):\n        \"\"\"Business operation that applies events to state\"\"\"\n\n        # 1. Business rule validation\n        if initial_balance &lt; 0:\n            raise ValueError(\"Initial balance cannot be negative\")\n        if account_type not in [\"checking\", \"savings\", \"business\"]:\n            raise ValueError(\"Invalid account type\")\n\n        # 2. Create domain event\n        event = AccountCreatedEvent(\n            aggregate_id=self.state.id,\n            account_number=account_number,\n            owner_name=owner_name,\n            initial_balance=initial_balance,\n            account_type=account_type,\n        )\n\n        # 3. Apply event to state AND register for persistence\n        self.state.on(event)  # Updates aggregate state immediately\n        self.register_event(event)  # Adds to pending events for persistence\n\n    def deposit_money(self, amount: Decimal, transaction_id: str):\n        \"\"\"Deposit operation with event-driven state changes\"\"\"\n\n        # Business validation\n        if amount &lt;= 0:\n            raise ValueError(\"Deposit amount must be positive\")\n        if not self.state.is_active:\n            raise ValueError(\"Cannot deposit to inactive account\")\n\n        # Calculate new balance\n        new_balance = self.state.balance + amount\n\n        # Create and apply event\n        event = MoneyDepositedEvent(\n            aggregate_id=self.state.id,\n            amount=amount,\n            new_balance=new_balance,\n            transaction_id=transaction_id,\n        )\n\n        self.state.on(event)  # State update via event\n        self.register_event(event)  # Event registration\n</code></pre>"},{"location":"patterns/domain-driven-design/#data-flow-breakdown","title":"Data Flow Breakdown","text":""},{"location":"patterns/domain-driven-design/#1-event-creation-application","title":"1. Event Creation &amp; Application","text":"<pre><code># Business method creates event\nevent = MoneyDepositedEvent(aggregate_id=self.id, amount=100.00, ...)\n\n# State application - Uses @dispatch to find the right handler\nself.state.on(event)  # Calls BankAccountState.on(MoneyDepositedEvent)\n\n# Event registration - Adds to pending events collection\nself.register_event(event)  # Adds to _pending_events list\n</code></pre>"},{"location":"patterns/domain-driven-design/#2-multiple-dispatch-resolution","title":"2. Multiple Dispatch Resolution","text":"<p>The <code>@dispatch</code> decorator from the <code>multipledispatch</code> library enables method overloading based on argument types:</p> <pre><code>@dispatch(AccountCreatedEvent)\ndef on(self, event: AccountCreatedEvent):\n    # Handles AccountCreatedEvent specifically\n    self.balance = event.initial_balance\n\n@dispatch(MoneyDepositedEvent)\ndef on(self, event: MoneyDepositedEvent):\n    # Handles MoneyDepositedEvent specifically\n    self.balance = event.new_balance\n\n# Python's multiple dispatch automatically routes:\n# state.on(AccountCreatedEvent) -&gt; First method\n# state.on(MoneyDepositedEvent) -&gt; Second method\n</code></pre>"},{"location":"patterns/domain-driven-design/#3-event-versioning-persistence","title":"3. Event Versioning &amp; Persistence","text":"<pre><code>def register_event(self, e: TEvent) -&gt; TEvent:\n    \"\"\"Framework method that handles event registration\"\"\"\n\n    # Add to pending events collection\n    self._pending_events.append(e)\n\n    # Set event version based on current state + pending events\n    e.aggregate_version = self.state.state_version + len(self._pending_events)\n\n    return e\n</code></pre>"},{"location":"patterns/domain-driven-design/#4-repository-integration","title":"4. Repository Integration","text":"<p>When the aggregate is saved through a repository:</p> <pre><code># In CommandHandler or Application Service\nasync def handle_async(self, command: DepositMoneyCommand):\n\n    # Load aggregate\n    account = await self.repository.get_by_id_async(command.account_id)\n\n    # Execute business operation (applies events)\n    account.deposit_money(command.amount, command.transaction_id)\n\n    # Save aggregate (persists events and updates state)\n    await self.repository.save_async(account)\n    #                                  \u2191\n    # Repository implementation will:\n    # 1. Append events to event store\n    # 2. Update read model/snapshot\n    # 3. Publish events to event bus\n    # 4. Clear pending events\n</code></pre>"},{"location":"patterns/domain-driven-design/#event-sourcing-vs-traditional-state-management","title":"Event Sourcing vs. Traditional State Management","text":""},{"location":"patterns/domain-driven-design/#traditional-approach","title":"Traditional Approach \u274c","text":"<pre><code>def deposit_money(self, amount: Decimal):\n    # Direct state mutation\n    self.balance += amount\n    self.last_modified = datetime.now()\n    # Lost: WHY the balance changed, WHEN exactly, by WHOM\n</code></pre>"},{"location":"patterns/domain-driven-design/#event-sourcing-approach","title":"Event Sourcing Approach \u2705","text":"<pre><code>def deposit_money(self, amount: Decimal, transaction_id: str):\n    # Create event with full context\n    event = MoneyDepositedEvent(\n        aggregate_id=self.id,\n        amount=amount,\n        new_balance=self.balance + amount,\n        transaction_id=transaction_id\n    )\n\n    # Apply event to state (predictable, testable)\n    self.state.on(event)\n\n    # Register for persistence (audit trail, replay capability)\n    self.register_event(event)\n</code></pre>"},{"location":"patterns/domain-driven-design/#benefits-of-the-frameworks-event-pattern","title":"Benefits of the Framework's Event Pattern","text":"<ol> <li>\ud83d\udd04 Replay Capability: States can be reconstructed from events</li> <li>\ud83d\udccb Complete Audit Trail: Every state change is captured with context</li> <li>\ud83e\uddea Testability: Events are pure data, easy to test</li> <li>\ud83c\udfaf Consistency: All state changes go through the same event pipeline</li> <li>\ud83d\udd0c Integration: Events naturally publish to external systems</li> <li>\ud83d\udcc8 Temporal Queries: Query state at any point in time</li> <li>\ud83d\udee1\ufe0f Immutability: Events are immutable, ensuring data integrity</li> </ol>"},{"location":"patterns/domain-driven-design/#persistence-pattern-choices-in-ddd","title":"\ufffd\ufe0f Persistence Pattern Choices in DDD","text":"<p>The Neuroglia framework supports multiple persistence patterns within the same DDD foundation, allowing you to choose the right approach based on domain complexity and requirements.</p>"},{"location":"patterns/domain-driven-design/#pattern-decision-matrix","title":"Pattern Decision Matrix","text":"Domain Characteristics Recommended Pattern Complexity Level Simple CRUD operations Entity + State Persistence \u2b50\u2b50\u2606\u2606\u2606 Complex business rules AggregateRoot + Event Sourcing \u2b50\u2b50\u2b50\u2b50\u2b50 Mixed requirements Hybrid Approach \u2b50\u2b50\u2b50\u2606\u2606"},{"location":"patterns/domain-driven-design/#entity-pattern-for-simple-domains","title":"Entity Pattern for Simple Domains","text":"<p>Perfect for traditional business applications with straightforward persistence needs:</p> <pre><code>class Customer(Entity):\n    \"\"\"Simple entity with state persistence and domain events.\"\"\"\n\n    def __init__(self, name: str, email: str):\n        super().__init__()\n        self._id = str(uuid.uuid4())\n        self.name = name\n        self.email = email\n\n        # Still raises domain events for integration\n        self._raise_domain_event(CustomerCreatedEvent(\n            customer_id=self.id,\n            name=self.name,\n            email=self.email\n        ))\n\n    def update_email(self, new_email: str) -&gt; None:\n        \"\"\"Business method with validation and events.\"\"\"\n        if not self._is_valid_email(new_email):\n            raise ValueError(\"Invalid email format\")\n\n        old_email = self.email\n        self.email = new_email\n\n        # Domain event for integration\n        self._raise_domain_event(CustomerEmailUpdatedEvent(\n            customer_id=self.id,\n            old_email=old_email,\n            new_email=new_email\n        ))\n\n    def _raise_domain_event(self, event: DomainEvent) -&gt; None:\n        if not hasattr(self, '_pending_events'):\n            self._pending_events = []\n        self._pending_events.append(event)\n\n    @property\n    def domain_events(self) -&gt; List[DomainEvent]:\n        \"\"\"Required for Unit of Work integration.\"\"\"\n        return getattr(self, '_pending_events', []).copy()\n\n# Usage in handler - same patterns as AggregateRoot\nclass UpdateCustomerEmailHandler(CommandHandler):\n    async def handle_async(self, command: UpdateCustomerEmailCommand):\n        customer = await self.customer_repository.get_by_id_async(command.customer_id)\n        customer.update_email(command.new_email)  # Business logic + events\n\n        await self.customer_repository.save_async(customer)  # State persistence\n        self.unit_of_work.register_aggregate(customer)       # Event dispatching\n\n        return self.ok(CustomerDto.from_entity(customer))\n</code></pre>"},{"location":"patterns/domain-driven-design/#aggregateroot-pattern-for-complex-domains","title":"AggregateRoot Pattern for Complex Domains","text":"<p>Use when you need rich business logic, comprehensive audit trails, and event sourcing:</p> <pre><code>class BankAccount(AggregateRoot[BankAccountState, str]):\n    \"\"\"Complex aggregate with event sourcing and rich business logic.\"\"\"\n\n    def deposit_money(self, amount: Decimal, transaction_id: str) -&gt; None:\n        \"\"\"Rich business logic with comprehensive validation.\"\"\"\n        # Business rules\n        if amount &lt;= 0:\n            raise ValueError(\"Deposit amount must be positive\")\n        if self.state.is_frozen:\n            raise DomainException(\"Cannot deposit to frozen account\")\n\n        # Apply event (changes state + records for replay)\n        event = MoneyDepositedEvent(\n            aggregate_id=self.id,\n            amount=amount,\n            new_balance=self.state.balance + amount,\n            transaction_id=transaction_id,\n            deposited_at=datetime.utcnow()\n        )\n\n        self.state.on(event)      # Apply to current state\n        self.register_event(event)  # Record for event sourcing\n\n# Usage - same handler patterns\nclass DepositMoneyHandler(CommandHandler):\n    async def handle_async(self, command: DepositMoneyCommand):\n        account = await self.account_repository.get_by_id_async(command.account_id)\n        account.deposit_money(command.amount, command.transaction_id)\n\n        await self.account_repository.save_async(account)  # Event store persistence\n        self.unit_of_work.register_aggregate(account)      # Event dispatching\n\n        return self.ok(AccountDto.from_aggregate(account))\n</code></pre>"},{"location":"patterns/domain-driven-design/#pattern-selection-guidelines","title":"Pattern Selection Guidelines","text":""},{"location":"patterns/domain-driven-design/#start-simple-evolve-as-needed","title":"Start Simple, Evolve as Needed","text":"<pre><code>flowchart TD\n    START[New Domain Feature] --&gt; ASSESS{Assess Complexity}\n\n    ASSESS --&gt;|Simple Business Rules| ENTITY[Entity + State Persistence]\n    ASSESS --&gt;|Complex Business Rules| AGG[AggregateRoot + Event Sourcing]\n\n    ENTITY --&gt; WORKS{Meets Requirements?}\n    WORKS --&gt;|Yes| DONE[\u2705 Stay with Entity]\n    WORKS --&gt;|No - Need Audit Trail| MIGRATE[Migrate to AggregateRoot]\n    WORKS --&gt;|No - Complex Rules| MIGRATE\n\n    AGG --&gt; DONE2[\u2705 Full Event Sourcing]\n    MIGRATE --&gt; DONE2\n\n    style ENTITY fill:#e8f5e8\n    style AGG fill:#fff3e0\n    style DONE fill:#c8e6c9\n    style DONE2 fill:#fff8e1</code></pre>"},{"location":"patterns/domain-driven-design/#decision-criteria","title":"Decision Criteria","text":"<p>Choose Entity + State Persistence When:</p> <ul> <li>\u2705 Building CRUD-heavy applications</li> <li>\u2705 Simple business rules and validation</li> <li>\u2705 Traditional database infrastructure</li> <li>\u2705 Team is new to DDD concepts</li> <li>\u2705 Performance is critical</li> <li>\u2705 Quick development cycles needed</li> </ul> <p>Choose AggregateRoot + Event Sourcing When:</p> <ul> <li>\u2705 Complex business invariants and rules</li> <li>\u2705 Comprehensive audit requirements</li> <li>\u2705 Temporal queries needed</li> <li>\u2705 Rich domain logic with state machines</li> <li>\u2705 Event-driven system integration</li> <li>\u2705 Long-term maintenance over initial complexity</li> </ul>"},{"location":"patterns/domain-driven-design/#framework-benefits-for-both-patterns","title":"Framework Benefits for Both Patterns","text":"<p>Both approaches use the same infrastructure:</p> <ul> <li>\ud83d\udd04 Unit of Work: Automatic event collection and dispatching</li> <li>\u26a1 Pipeline Behaviors: Cross-cutting concerns (validation, logging, transactions)</li> <li>\ud83c\udfaf CQRS Integration: Command/Query handling with Mediator pattern</li> <li>\ud83d\udce1 Event Integration: Domain events automatically published as integration events</li> <li>\ud83e\uddea Testing Support: Same testing patterns and infrastructure</li> </ul> <p>\ud83d\udcda Detailed Guides:</p> <ul> <li>\ud83c\udfdb\ufe0f Persistence Patterns Guide - Complete comparison and decision framework</li> <li>\ud83d\udd04 Unit of Work Pattern - Event coordination and aggregate management</li> <li>\ud83c\udfdb\ufe0f State-Based Persistence - Entity pattern implementation guide</li> </ul>"},{"location":"patterns/domain-driven-design/#complete-real-world-example-openbank","title":"\ufffd\ud83c\udfe6 Complete Real-World Example: OpenBank","text":""},{"location":"patterns/domain-driven-design/#full-domain-model-implementation","title":"Full Domain Model Implementation","text":"<p>Here's a complete example from the OpenBank sample showing the full data abstraction pattern:</p> <pre><code># Domain Events\n@dataclass\nclass BankAccountCreatedDomainEventV1(DomainEvent[str]):\n    \"\"\"Event raised when a bank account is created\"\"\"\n    owner_id: str\n    overdraft_limit: Decimal\n\n@dataclass\nclass BankAccountTransactionRecordedDomainEventV1(DomainEvent[str]):\n    \"\"\"Event raised when a transaction is recorded\"\"\"\n    transaction: BankTransactionV1\n\n# Aggregate State with Event Handlers\n@map_to(BankAccountDto)\nclass BankAccountStateV1(AggregateState[str]):\n    \"\"\"Bank account state with multiple dispatch event handlers\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.transactions: List[BankTransactionV1] = []\n        self.balance: Decimal = Decimal(\"0.00\")\n        self.overdraft_limit: Decimal = Decimal(\"0.00\")\n        self.owner_id: str = \"\"\n\n    @dispatch(BankAccountCreatedDomainEventV1)\n    def on(self, event: BankAccountCreatedDomainEventV1):\n        \"\"\"Apply account creation event\"\"\"\n        self.id = event.aggregate_id\n        self.created_at = event.created_at\n        self.owner_id = event.owner_id\n        self.overdraft_limit = event.overdraft_limit\n\n    @dispatch(BankAccountTransactionRecordedDomainEventV1)\n    def on(self, event: BankAccountTransactionRecordedDomainEventV1):\n        \"\"\"Apply transaction event and recompute balance\"\"\"\n        self.last_modified = event.created_at\n        self.transactions.append(event.transaction)\n        self._compute_balance()\n\n    def _compute_balance(self):\n        \"\"\"Recompute balance from all transactions (event sourcing)\"\"\"\n        balance = Decimal(\"0.00\")\n        for transaction in self.transactions:\n            if transaction.type in [BankTransactionTypeV1.DEPOSIT.value,\n                                  BankTransactionTypeV1.INTEREST.value]:\n                balance += Decimal(transaction.amount)\n            elif transaction.type == BankTransactionTypeV1.TRANSFER.value:\n                if transaction.to_account_id == self.id:\n                    balance += Decimal(transaction.amount)  # Incoming transfer\n                else:\n                    balance -= Decimal(transaction.amount)  # Outgoing transfer\n            else:  # Withdrawal\n                balance -= Decimal(transaction.amount)\n        self.balance = balance\n\n# Aggregate Root with Business Logic\nclass BankAccount(AggregateRoot[BankAccountStateV1, str]):\n    \"\"\"Bank account aggregate implementing banking business rules\"\"\"\n\n    def __init__(self, owner: Person, overdraft_limit: Decimal = Decimal(\"0.00\")):\n        super().__init__()\n\n        # Create account through event application\n        event = BankAccountCreatedDomainEventV1(\n            aggregate_id=str(uuid.uuid4()).replace('-', ''),\n            owner_id=owner.id(),\n            overdraft_limit=overdraft_limit\n        )\n\n        # Apply event to state AND register for persistence\n        self.state.on(event)\n        self.register_event(event)\n\n    def get_available_balance(self) -&gt; Decimal:\n        \"\"\"Calculate available balance including overdraft\"\"\"\n        return self.state.balance + self.state.overdraft_limit\n\n    def try_add_transaction(self, transaction: BankTransactionV1) -&gt; bool:\n        \"\"\"Attempt to add transaction with business rule validation\"\"\"\n\n        # Business rule: Check if transaction would cause overdraft\n        if (transaction.type not in [BankTransactionTypeV1.DEPOSIT,\n                                   BankTransactionTypeV1.INTEREST] and\n            not (transaction.type == BankTransactionTypeV1.TRANSFER and\n                 transaction.to_account_id == self.id()) and\n            transaction.amount &gt; self.get_available_balance()):\n            return False  # Transaction rejected\n\n        # Create and apply transaction event\n        event = BankAccountTransactionRecordedDomainEventV1(\n            aggregate_id=self.id(),\n            transaction=transaction\n        )\n\n        # Event application pattern\n        self.state.on(event)  # Updates state via multiple dispatch\n        self.register_event(event)  # Registers for persistence\n\n        return True  # Transaction accepted\n</code></pre>"},{"location":"patterns/domain-driven-design/#event-sourcing-aggregation-process","title":"Event Sourcing Aggregation Process","text":"<p>The framework includes an <code>Aggregator</code> class that reconstructs aggregate state from events:</p> <pre><code># /src/neuroglia/data/infrastructure/event_sourcing/abstractions.py\nclass Aggregator:\n    \"\"\"Reconstructs aggregates from event streams\"\"\"\n\n    def aggregate(self, events: List[EventRecord], aggregate_type: Type) -&gt; AggregateRoot:\n        \"\"\"Rebuild aggregate state from historical events\"\"\"\n\n        # 1. Create empty aggregate instance\n        aggregate: AggregateRoot = object.__new__(aggregate_type)\n        aggregate.state = aggregate.__orig_bases__[0].__args__[0]()\n\n        # 2. Replay all events in sequence\n        for event_record in events:\n            # Apply each event to state using multiple dispatch\n            aggregate.state.on(event_record.data)\n\n            # Update state version to match event version\n            aggregate.state.state_version = event_record.data.aggregate_version\n\n        return aggregate\n</code></pre>"},{"location":"patterns/domain-driven-design/#complete-data-flow-example","title":"Complete Data Flow Example","text":"<pre><code># Application Service using the pattern\nclass CreateBankAccountHandler(CommandHandler[CreateBankAccountCommand, OperationResult[BankAccountDto]]):\n\n    async def handle_async(self, command: CreateBankAccountCommand) -&gt; OperationResult[BankAccountDto]:\n\n        # 1. Load related aggregate (Person)\n        owner = await self.person_repository.get_by_id_async(command.owner_id)\n\n        # 2. Create new aggregate (triggers events)\n        account = BankAccount(owner, command.overdraft_limit)\n        #                     \u2191\n        # This constructor:\n        # - Creates BankAccountCreatedDomainEventV1\n        # - Calls self.state.on(event) \u2192 Updates state via @dispatch\n        # - Calls self.register_event(event) \u2192 Adds to _pending_events\n\n        # 3. Save aggregate (persists events and publishes)\n        saved_account = await self.repository.add_async(account)\n        #                                                   \u2191\n        # Repository implementation:\n        # - Appends events from _pending_events to event store\n        # - Publishes events to event bus for integration\n        # - Updates read models/projections\n        # - Clears _pending_events\n\n        # 4. Return DTO mapped from aggregate state\n        return self.created(self.mapper.map(saved_account.state, BankAccountDto))\n</code></pre>"},{"location":"patterns/domain-driven-design/#key-insights-from-the-openbank-example","title":"Key Insights from the OpenBank Example","text":"<ol> <li>\ud83c\udfaf Business Logic in Aggregates: All banking rules are enforced in the aggregate</li> <li>\ud83d\udcdd Events as Facts: Each event represents a business fact that occurred</li> <li>\ud83d\udd04 State from Events: Balance is computed from transaction events, not stored directly</li> <li>\ud83d\udee1\ufe0f Consistency Boundaries: Account aggregate ensures transaction consistency</li> <li>\ud83d\udd0c Automatic Integration: Events automatically trigger downstream processing</li> <li>\ud83d\udcca Audit Trail: Complete transaction history is preserved in events</li> <li>\ud83e\uddea Testable: Business logic can be tested by verifying events produced</li> </ol>"},{"location":"patterns/domain-driven-design/#3-aggregate-root","title":"3. Aggregate Root","text":"<p>Aggregate Roots define consistency boundaries and coordinate multiple entities:</p> <pre><code>from neuroglia.data.abstractions import AggregateRoot, AggregateState\nfrom multipledispatch import dispatch\nfrom enum import Enum\nfrom typing import Optional\n\nclass OrderStatus(Enum):\n    PENDING = \"PENDING\"\n    CONFIRMED = \"CONFIRMED\"\n    PREPARING = \"PREPARING\"\n    READY = \"READY\"\n    DELIVERED = \"DELIVERED\"\n    CANCELLED = \"CANCELLED\"\n\nclass PizzaOrderState(AggregateState[str]):\n    \"\"\"State for pizza order aggregate\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.customer_id = \"\"\n        self.items = []\n        self.total_amount = Decimal('0.00')\n        self.status = OrderStatus.PENDING\n        self.special_instructions = \"\"\n        self.estimated_delivery = None\n        self.payment_status = \"UNPAID\"\n\n    @dispatch(PizzaOrderPlacedEvent)\n    def on(self, event: PizzaOrderPlacedEvent):\n        \"\"\"Apply order placed event to state\"\"\"\n        self.id = event.aggregate_id\n        self.customer_id = event.customer_id\n        self.items = event.items.copy()\n        self.total_amount = event.total_amount\n        self.special_instructions = event.special_instructions\n        self.created_at = event.created_at\n\n    @dispatch(OrderStatusChangedEvent)\n    def on(self, event: OrderStatusChangedEvent):\n        \"\"\"Apply status change event to state\"\"\"\n        self.status = OrderStatus(event.new_status)\n        self.last_modified = event.created_at\n\n    @dispatch(PaymentProcessedEvent)\n    def on(self, event: PaymentProcessedEvent):\n        \"\"\"Apply payment processed event to state\"\"\"\n        self.payment_status = \"PAID\"\n        self.last_modified = event.created_at\n\nclass PizzaOrderAggregate(AggregateRoot[PizzaOrderState, str]):\n    \"\"\"Pizza order aggregate root implementing business rules\"\"\"\n\n    def __init__(self, order_id: str = None):\n        super().__init__()\n        if order_id:\n            self.state.id = order_id\n\n    def place_order(self, customer_id: str, items: List[Dict[str, Any]],\n                   special_instructions: str = \"\") -&gt; None:\n        \"\"\"Place a new pizza order with business validation\"\"\"\n\n        # Business rule validation\n        if not items:\n            raise ValueError(\"Order must contain at least one item\")\n\n        # Calculate total with business rules\n        total = Decimal('0.00')\n        for item in items:\n            if item['quantity'] &lt;= 0:\n                raise ValueError(\"Item quantity must be positive\")\n            total += Decimal(str(item['price'])) * item['quantity']\n\n        # Minimum order business rule\n        if total &lt; Decimal('10.00'):\n            raise ValueError(\"Minimum order amount is $10.00\")\n\n        # Create and apply domain event\n        event = PizzaOrderPlacedEvent(\n            aggregate_id=self.state.id,\n            customer_id=customer_id,\n            items=items,\n            total_amount=total,\n            special_instructions=special_instructions\n        )\n\n        self.state.on(event)\n        self.register_event(event)\n\n    def confirm_order(self, estimated_delivery: datetime, confirmed_by: str) -&gt; None:\n        \"\"\"Confirm order with business rules\"\"\"\n        if self.state.status != OrderStatus.PENDING:\n            raise ValueError(f\"Cannot confirm order in {self.state.status.value} status\")\n\n        self.state.estimated_delivery = estimated_delivery\n\n        # Create status change event\n        event = OrderStatusChangedEvent(\n            aggregate_id=self.state.id,\n            previous_status=self.state.status.value,\n            new_status=OrderStatus.CONFIRMED.value,\n            changed_by=confirmed_by,\n            reason=\"Order confirmed by kitchen\"\n        )\n\n        self.state.on(event)\n        self.register_event(event)\n\n    def process_payment(self, payment_method: str, transaction_id: str) -&gt; None:\n        \"\"\"Process payment with business validation\"\"\"\n        if self.state.payment_status == \"PAID\":\n            raise ValueError(\"Order is already paid\")\n\n        if self.state.status == OrderStatus.CANCELLED:\n            raise ValueError(\"Cannot process payment for cancelled order\")\n\n        event = PaymentProcessedEvent(\n            aggregate_id=self.state.id,\n            payment_method=payment_method,\n            amount=self.state.total_amount,\n            transaction_id=transaction_id\n        )\n\n        self.state.on(event)\n        self.register_event(event)\n\n    def cancel_order(self, reason: str, cancelled_by: str) -&gt; None:\n        \"\"\"Cancel order with business rules\"\"\"\n        if self.state.status in [OrderStatus.DELIVERED, OrderStatus.CANCELLED]:\n            raise ValueError(f\"Cannot cancel order in {self.state.status.value} status\")\n\n        event = OrderStatusChangedEvent(\n            aggregate_id=self.state.id,\n            previous_status=self.state.status.value,\n            new_status=OrderStatus.CANCELLED.value,\n            changed_by=cancelled_by,\n            reason=reason\n        )\n\n        self.state.on(event)\n        self.register_event(event)\n</code></pre>"},{"location":"patterns/domain-driven-design/#transaction-flow-with-multiple-domain-events","title":"\ud83d\udd04 Transaction Flow with Multiple Domain Events","text":"<p>When a single command requires multiple domain events, the framework ensures transactional consistency through the aggregate boundary:</p>"},{"location":"patterns/domain-driven-design/#complex-business-transaction-example","title":"Complex Business Transaction Example","text":"<pre><code>from typing import List\nfrom decimal import Decimal\n\nclass OrderWithPromotionAggregate(AggregateRoot[PizzaOrderState, str]):\n    \"\"\"Extended order aggregate with promotion handling\"\"\"\n\n    def place_order_with_promotion(self, customer_id: str, items: List[Dict[str, Any]],\n                                  promotion_code: str = None) -&gt; None:\n        \"\"\"Place order with potential promotion - multiple events in single transaction\"\"\"\n\n        # Step 1: Validate and place base order\n        self.place_order(customer_id, items)\n\n        # Step 2: Apply promotion if valid\n        if promotion_code:\n            discount_amount = self._validate_and_calculate_promotion(promotion_code)\n            if discount_amount &gt; 0:\n                # Create promotion applied event\n                promotion_event = PromotionAppliedEvent(\n                    aggregate_id=self.state.id,\n                    promotion_code=promotion_code,\n                    discount_amount=discount_amount,\n                    original_amount=self.state.total_amount\n                )\n\n                self.state.on(promotion_event)\n                self.register_event(promotion_event)\n\n        # Step 3: Check for loyalty points\n        loyalty_points = self._calculate_loyalty_points()\n        if loyalty_points &gt; 0:\n            loyalty_event = LoyaltyPointsEarnedEvent(\n                aggregate_id=self.state.id,\n                customer_id=customer_id,\n                points_earned=loyalty_points,\n                transaction_amount=self.state.total_amount\n            )\n\n            self.register_event(loyalty_event)\n\n    def _validate_and_calculate_promotion(self, promotion_code: str) -&gt; Decimal:\n        \"\"\"Business logic for promotion validation\"\"\"\n        promotions = {\n            \"FIRST10\": Decimal('10.00'),\n            \"STUDENT15\": self.state.total_amount * Decimal('0.15')\n        }\n        return promotions.get(promotion_code, Decimal('0.00'))\n\n    def _calculate_loyalty_points(self) -&gt; int:\n        \"\"\"Business logic for loyalty points calculation\"\"\"\n        # 1 point per dollar spent\n        return int(self.state.total_amount)\n\n@dataclass\nclass PromotionAppliedEvent(DomainEvent[str]):\n    \"\"\"Domain event for promotion application\"\"\"\n    promotion_code: str\n    discount_amount: Decimal\n    original_amount: Decimal\n\n@dataclass\nclass LoyaltyPointsEarnedEvent(DomainEvent[str]):\n    \"\"\"Domain event for loyalty points\"\"\"\n    customer_id: str\n    points_earned: int\n    transaction_amount: Decimal\n</code></pre>"},{"location":"patterns/domain-driven-design/#transaction-flow-visualization","title":"Transaction Flow Visualization","text":"<pre><code>sequenceDiagram\n    participant API as \ud83c\udf10 API Controller\n    participant CMD as \ud83d\udcbc Command Handler\n    participant AGG as \ud83c\udfdb\ufe0f Aggregate Root\n    participant REPO as \ud83d\udd0c Repository\n    participant BUS as \ud83d\udce1 Event Bus\n\n    API-&gt;&gt;CMD: PlaceOrderWithPromotionCommand\n\n    Note over CMD,AGG: Single Transaction Boundary\n    CMD-&gt;&gt;AGG: place_order_with_promotion()\n\n    AGG-&gt;&gt;AGG: validate_order_items()\n    AGG-&gt;&gt;AGG: register_event(OrderPlacedEvent)\n\n    AGG-&gt;&gt;AGG: validate_promotion()\n    AGG-&gt;&gt;AGG: register_event(PromotionAppliedEvent)\n\n    AGG-&gt;&gt;AGG: calculate_loyalty_points()\n    AGG-&gt;&gt;AGG: register_event(LoyaltyPointsEarnedEvent)\n\n    CMD-&gt;&gt;REPO: save_async(aggregate)\n\n    Note over REPO: Atomic Save Operation\n    REPO-&gt;&gt;REPO: persist_state()\n    REPO-&gt;&gt;BUS: publish_domain_events()\n\n    Note over BUS: Event Publishing (After Commit)\n    BUS-&gt;&gt;BUS: OrderPlacedEvent \u2192 Integration\n    BUS-&gt;&gt;BUS: PromotionAppliedEvent \u2192 Marketing\n    BUS-&gt;&gt;BUS: LoyaltyPointsEarnedEvent \u2192 Customer Service\n\n    REPO--&gt;&gt;CMD: Success\n    CMD--&gt;&gt;API: OperationResult&lt;OrderDto&gt;</code></pre>"},{"location":"patterns/domain-driven-design/#domain-events-vs-integration-events","title":"\ud83c\udf10 Domain Events vs Integration Events","text":"<p>The framework distinguishes between Domain Events (internal business events) and Integration Events (cross-boundary communication):</p>"},{"location":"patterns/domain-driven-design/#domain-event-integration-event-flow","title":"Domain Event \u2192 Integration Event Flow","text":"<pre><code>from neuroglia.eventing import DomainEventHandler\nfrom neuroglia.eventing.cloud_events import CloudEvent\nfrom typing import Dict, Any\n\nclass OrderDomainEventHandler(DomainEventHandler[PizzaOrderPlacedEvent]):\n    \"\"\"Handles domain events and publishes integration events\"\"\"\n\n    def __init__(self, event_bus: EventBus, mapper: Mapper):\n        self.event_bus = event_bus\n        self.mapper = mapper\n\n    async def handle_async(self, domain_event: PizzaOrderPlacedEvent) -&gt; None:\n        \"\"\"Convert domain event to integration event (CloudEvent)\"\"\"\n\n        # Transform domain event to integration event data\n        integration_data = {\n            \"orderId\": domain_event.aggregate_id,\n            \"customerId\": domain_event.customer_id,\n            \"totalAmount\": float(domain_event.total_amount),\n            \"items\": domain_event.items,\n            \"orderPlacedAt\": domain_event.created_at.isoformat()\n        }\n\n        # Create CloudEvent for external systems\n        cloud_event = CloudEvent(\n            source=\"mario-pizzeria/orders\",\n            type=\"com.mario-pizzeria.order.placed.v1\",\n            data=integration_data,\n            datacontenttype=\"application/json\"\n        )\n\n        # Publish to external systems\n        await self.event_bus.publish_async(cloud_event)\n\n        # Handle internal business workflows\n        await self._notify_kitchen(domain_event)\n        await self._update_inventory(domain_event)\n        await self._send_customer_confirmation(domain_event)\n\n    async def _notify_kitchen(self, event: PizzaOrderPlacedEvent) -&gt; None:\n        \"\"\"Internal business workflow - kitchen notification\"\"\"\n        kitchen_notification = KitchenOrderReceivedEvent(\n            order_id=event.aggregate_id,\n            items=event.items,\n            special_instructions=event.special_instructions\n        )\n        await self.event_bus.publish_async(kitchen_notification)\n\n    async def _update_inventory(self, event: PizzaOrderPlacedEvent) -&gt; None:\n        \"\"\"Internal business workflow - inventory management\"\"\"\n        for item in event.items:\n            inventory_event = IngredientReservedEvent(\n                pizza_type=item['name'],\n                quantity=item['quantity'],\n                order_id=event.aggregate_id\n            )\n            await self.event_bus.publish_async(inventory_event)\n</code></pre>"},{"location":"patterns/domain-driven-design/#event-types-comparison","title":"Event Types Comparison","text":"Aspect Domain Events Integration Events (CloudEvents) Scope Internal to bounded context Cross-boundary communication Format Domain-specific objects Standardized CloudEvent format Audience Internal domain handlers External systems &amp; services Coupling Tightly coupled to domain Loosely coupled via contracts Evolution Can change with domain Must maintain backward compatibility Examples <code>OrderPlacedEvent</code>, <code>PaymentProcessedEvent</code> <code>com.mario-pizzeria.order.placed.v1</code> <pre><code>flowchart TB\n    subgraph \"\ud83c\udfdb\ufe0f Domain Layer\"\n        DomainOp[\"Domain Operation&lt;br/&gt;(place_order)\"]\n        DomainEvent[\"Domain Event&lt;br/&gt;(OrderPlacedEvent)\"]\n    end\n\n    subgraph \"\ud83d\udcbc Application Layer\"\n        EventHandler[\"Domain Event Handler&lt;br/&gt;(OrderDomainEventHandler)\"]\n        Transform[\"Event Transformation&lt;br/&gt;(Domain \u2192 Integration)\"]\n    end\n\n    subgraph \"\ud83d\udd0c Integration Layer\"\n        CloudEvent[\"Integration Event&lt;br/&gt;(CloudEvent)\"]\n        EventBus[\"Event Bus&lt;br/&gt;(External Publishing)\"]\n    end\n\n    subgraph \"\ud83c\udf10 External Systems\"\n        Payment[\"Payment Service\"]\n        Inventory[\"Inventory System\"]\n        Analytics[\"Analytics Platform\"]\n        CRM[\"Customer CRM\"]\n    end\n\n    DomainOp --&gt; DomainEvent\n    DomainEvent --&gt; EventHandler\n    EventHandler --&gt; Transform\n    Transform --&gt; CloudEvent\n    CloudEvent --&gt; EventBus\n    EventBus --&gt; Payment\n    EventBus --&gt; Inventory\n    EventBus --&gt; Analytics\n    EventBus --&gt; CRM\n\n    style DomainEvent fill:#e8f5e8\n    style CloudEvent fill:#fff3e0\n    style Transform fill:#e3f2fd</code></pre>"},{"location":"patterns/domain-driven-design/#event-sourcing-vs-traditional-implementation","title":"\ud83c\udfaf Event Sourcing vs Traditional Implementation","text":"<p>The framework supports both traditional state-based and event sourcing implementations:</p>"},{"location":"patterns/domain-driven-design/#traditional-crud-implementation","title":"Traditional CRUD Implementation","text":"<pre><code>class TraditionalOrderService:\n    \"\"\"Traditional CRUD approach - current state only\"\"\"\n\n    def __init__(self, repository: Repository[PizzaOrder, str]):\n        self.repository = repository\n\n    async def place_order_async(self, command: PlaceOrderCommand) -&gt; PizzaOrder:\n        \"\"\"Traditional approach - direct state mutation\"\"\"\n\n        # Create order entity with current state\n        order = PizzaOrder(\n            customer_id=command.customer_id,\n            items=command.items,\n            total_amount=self._calculate_total(command.items),\n            status=OrderStatus.PENDING,\n            created_at=datetime.now()\n        )\n\n        # Validate business rules\n        self._validate_order(order)\n\n        # Save current state only\n        saved_order = await self.repository.add_async(order)\n\n        # Manually trigger side effects\n        await self._send_notifications(saved_order)\n        await self._update_inventory(saved_order)\n\n        return saved_order\n\n    async def update_status_async(self, order_id: str, new_status: OrderStatus) -&gt; PizzaOrder:\n        \"\"\"Traditional approach - direct state update\"\"\"\n        order = await self.repository.get_async(order_id)\n        if not order:\n            raise ValueError(\"Order not found\")\n\n        # Direct state mutation (loses history)\n        old_status = order.status\n        order.status = new_status\n        order.updated_at = datetime.now()\n\n        # Save updated state (old state is lost)\n        return await self.repository.update_async(order)\n</code></pre>"},{"location":"patterns/domain-driven-design/#event-sourcing-implementation","title":"Event Sourcing Implementation","text":"<pre><code>from neuroglia.data.infrastructure.event_sourcing import EventSourcingRepository\n\nclass EventSourcedOrderService:\n    \"\"\"Event sourcing approach - complete history preservation\"\"\"\n\n    def __init__(self, repository: EventSourcingRepository[PizzaOrderAggregate, str]):\n        self.repository = repository\n\n    async def place_order_async(self, command: PlaceOrderCommand) -&gt; PizzaOrderAggregate:\n        \"\"\"Event sourcing approach - event-based state building\"\"\"\n\n        # Create new aggregate\n        aggregate = PizzaOrderAggregate(f\"order_{uuid.uuid4().hex[:8]}\")\n\n        # Apply business operation (generates events)\n        aggregate.place_order(\n            customer_id=command.customer_id,\n            items=command.items,\n            special_instructions=command.special_instructions\n        )\n\n        # Repository saves events and publishes them\n        return await self.repository.add_async(aggregate)\n\n    async def update_status_async(self, order_id: str, new_status: OrderStatus,\n                                 changed_by: str, reason: str) -&gt; PizzaOrderAggregate:\n        \"\"\"Event sourcing approach - reconstruct from events\"\"\"\n\n        # Reconstruct aggregate from events\n        aggregate = await self.repository.get_async(order_id)\n        if not aggregate:\n            raise ValueError(\"Order not found\")\n\n        # Apply business operation (generates new events)\n        if new_status == OrderStatus.CONFIRMED:\n            aggregate.confirm_order(\n                estimated_delivery=datetime.now() + timedelta(minutes=30),\n                confirmed_by=changed_by\n            )\n        elif new_status == OrderStatus.CANCELLED:\n            aggregate.cancel_order(reason, changed_by)\n\n        # Save new events (all history preserved)\n        return await self.repository.update_async(aggregate)\n</code></pre>"},{"location":"patterns/domain-driven-design/#implementation-comparison","title":"Implementation Comparison","text":"Aspect Traditional CRUD Event Sourcing State Storage Current state only Complete event history History Lost on updates Full audit trail preserved Rollback Manual snapshots required Replay to any point in time Analytics Limited to current state Rich temporal analysis Debugging Current state only Complete operation history Performance Fast reads Fast writes, reads via projections Complexity Lower Higher initial complexity <pre><code>flowchart LR\n    subgraph \"\ud83d\udcca Traditional CRUD\"\n        CRUD_State[\"Current State&lt;br/&gt;\u274c History Lost\"]\n        CRUD_DB[(\"Database&lt;br/&gt;Single Record\")]\n    end\n\n    subgraph \"\ud83d\udcc8 Event Sourcing\"\n        Events[\"Event Stream&lt;br/&gt;\ud83d\udcdc Complete History\"]\n        EventStore[(\"Event Store&lt;br/&gt;Immutable Events\")]\n        Projections[\"Read Models&lt;br/&gt;\ud83d\udcca Optimized Views\"]\n    end\n\n    subgraph \"\ud83d\udd0d Capabilities Comparison\"\n        Audit[\"\u2705 Audit Trail\"]\n        Rollback[\"\u2705 Time Travel\"]\n        Analytics[\"\u2705 Business Intelligence\"]\n        Debugging[\"\u2705 Complete Debugging\"]\n    end\n\n    CRUD_State --&gt; CRUD_DB\n    Events --&gt; EventStore\n    EventStore --&gt; Projections\n\n    Events --&gt; Audit\n    Events --&gt; Rollback\n    Events --&gt; Analytics\n    Events --&gt; Debugging\n\n    style Events fill:#e8f5e8\n    style EventStore fill:#fff3e0\n    style Projections fill:#e3f2fd\n    style CRUD_State fill:#ffebee</code></pre>"},{"location":"patterns/domain-driven-design/#data-flow-across-layers","title":"\ud83c\udfd7\ufe0f Data Flow Across Layers","text":""},{"location":"patterns/domain-driven-design/#complete-request-response-flow","title":"Complete Request-Response Flow","text":"<pre><code>sequenceDiagram\n    participant Client as \ud83c\udf10 Client\n    participant Controller as \ud83c\udfae API Controller\n    participant Handler as \ud83d\udcbc Command Handler\n    participant Aggregate as \ud83c\udfdb\ufe0f Aggregate Root\n    participant Repository as \ud83d\udd0c Repository\n    participant EventBus as \ud83d\udce1 Event Bus\n    participant Integration as \ud83c\udf0d External Systems\n\n    Client-&gt;&gt;Controller: POST /orders (PlaceOrderDto)\n\n    Note over Controller: \ud83d\udd04 DTO \u2192 Command Mapping\n    Controller-&gt;&gt;Controller: Map DTO to PlaceOrderCommand\n\n    Controller-&gt;&gt;Handler: mediator.execute_async(command)\n\n    Note over Handler: \ud83d\udcbc Application Logic\n    Handler-&gt;&gt;Handler: Validate command\n    Handler-&gt;&gt;Aggregate: Create/Load aggregate\n\n    Note over Aggregate: \ud83c\udfdb\ufe0f Domain Logic\n    Aggregate-&gt;&gt;Aggregate: Apply business rules\n    Aggregate-&gt;&gt;Aggregate: Generate domain events\n\n    Handler-&gt;&gt;Repository: save_async(aggregate)\n\n    Note over Repository: \ud83d\udd0c Persistence\n    Repository-&gt;&gt;Repository: Save aggregate state\n    Repository-&gt;&gt;Repository: Extract pending events\n\n    loop For each Domain Event\n        Repository-&gt;&gt;EventBus: publish_domain_event()\n        EventBus-&gt;&gt;EventBus: Convert to integration event\n        EventBus-&gt;&gt;Integration: Publish CloudEvent\n    end\n\n    Repository--&gt;&gt;Handler: Persisted aggregate\n    Handler-&gt;&gt;Handler: Map aggregate to DTO\n    Handler--&gt;&gt;Controller: OperationResult&lt;OrderDto&gt;\n    Controller--&gt;&gt;Client: HTTP 201 Created (OrderDto)\n\n    Note over Integration: \ud83c\udf0d External Processing\n    Integration-&gt;&gt;Integration: Payment processing\n    Integration-&gt;&gt;Integration: Inventory updates\n    Integration-&gt;&gt;Integration: Customer notifications</code></pre>"},{"location":"patterns/domain-driven-design/#data-transformation-flow","title":"Data Transformation Flow","text":"<pre><code>from neuroglia.mvc import ControllerBase\nfrom neuroglia.mediation import Mediator, Command, OperationResult\nfrom neuroglia.mapping import Mapper\n\n# 1. API Layer - Controllers and DTOs\n@dataclass\nclass PlaceOrderDto:\n    \"\"\"Data Transfer Object for API requests\"\"\"\n    customer_id: str\n    items: List[Dict[str, Any]]\n    special_instructions: str = \"\"\n\n@dataclass\nclass OrderDto:\n    \"\"\"Data Transfer Object for API responses\"\"\"\n    id: str\n    customer_id: str\n    items: List[Dict[str, Any]]\n    total_amount: float\n    status: str\n    created_at: str\n\nclass OrdersController(ControllerBase):\n    \"\"\"API Controller handling HTTP requests\"\"\"\n\n    @post(\"/orders\", response_model=OrderDto, status_code=201)\n    async def place_order(self, dto: PlaceOrderDto) -&gt; OrderDto:\n        \"\"\"\ud83c\udf10 API Layer: Transform DTO to Command\"\"\"\n        command = self.mapper.map(dto, PlaceOrderCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n# 2. Application Layer - Commands and Handlers\n@dataclass\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Application command for placing orders\"\"\"\n    customer_id: str\n    items: List[Dict[str, Any]]\n    special_instructions: str = \"\"\n\nclass PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    \"\"\"\ud83d\udcbc Application Layer: Business orchestration\"\"\"\n\n    def __init__(self, repository: Repository[PizzaOrderAggregate, str],\n                 mapper: Mapper):\n        self.repository = repository\n        self.mapper = mapper\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        \"\"\"Handle command with domain coordination\"\"\"\n        try:\n            # Create domain aggregate\n            aggregate = PizzaOrderAggregate()\n\n            # Apply domain operation\n            aggregate.place_order(\n                customer_id=command.customer_id,\n                items=command.items,\n                special_instructions=command.special_instructions\n            )\n\n            # Persist with events\n            saved_aggregate = await self.repository.add_async(aggregate)\n\n            # Transform back to DTO\n            dto = self.mapper.map(saved_aggregate.state, OrderDto)\n            return self.created(dto)\n\n        except ValueError as e:\n            return self.bad_request(str(e))\n        except Exception as e:\n            return self.internal_server_error(f\"Failed to place order: {str(e)}\")\n\n# 3. Integration Layer - Event Handlers\nclass OrderIntegrationEventHandler(DomainEventHandler[PizzaOrderPlacedEvent]):\n    \"\"\"\ud83d\udd0c Integration Layer: External system coordination\"\"\"\n\n    async def handle_async(self, event: PizzaOrderPlacedEvent) -&gt; None:\n        \"\"\"Transform domain events to integration events\"\"\"\n\n        # Convert to CloudEvent for external systems\n        cloud_event = CloudEvent(\n            source=\"mario-pizzeria/orders\",\n            type=\"com.mario-pizzeria.order.placed.v1\",\n            data={\n                \"orderId\": event.aggregate_id,\n                \"customerId\": event.customer_id,\n                \"totalAmount\": float(event.total_amount),\n                \"timestamp\": event.created_at.isoformat()\n            }\n        )\n\n        await self.event_bus.publish_async(cloud_event)\n</code></pre>"},{"location":"patterns/domain-driven-design/#when-to-use-domain-driven-design","title":"\ud83c\udfaf When to Use Domain Driven Design","text":""},{"location":"patterns/domain-driven-design/#ideal-use-cases","title":"\u2705 Ideal Use Cases","text":"<ul> <li>Complex Business Logic: Rich domain rules and workflows</li> <li>Long-term Projects: Systems that will evolve over years</li> <li>Large Teams: Multiple developers working on same domain</li> <li>Event-driven Systems: Business events drive system behavior</li> <li>Audit Requirements: Need complete operation history</li> <li>Collaborative Development: Business experts and developers working together</li> </ul>"},{"location":"patterns/domain-driven-design/#consider-alternatives-when","title":"\u274c Consider Alternatives When","text":"<ul> <li>Simple CRUD: Basic data entry with minimal business rules</li> <li>Short-term Projects: Quick prototypes or temporary solutions</li> <li>Small Teams: 1-2 developers with simple requirements</li> <li>Performance Critical: Microsecond latency requirements</li> <li>Read-heavy Systems: Mostly queries with minimal writes</li> </ul>"},{"location":"patterns/domain-driven-design/#migration-path","title":"\ud83d\ude80 Migration Path","text":"<pre><code>flowchart TB\n    subgraph \"\ud83d\udcca Current State: Simple CRUD\"\n        CRUD[\"Entity Classes&lt;br/&gt;Basic Repositories\"]\n        Services[\"Service Classes&lt;br/&gt;Business Logic\"]\n    end\n\n    subgraph \"\ud83c\udfaf Target State: Rich Domain Model\"\n        Entities[\"Rich Entities&lt;br/&gt;Business Behavior\"]\n        Aggregates[\"Aggregate Roots&lt;br/&gt;Consistency Boundaries\"]\n        Events[\"Domain Events&lt;br/&gt;Business Events\"]\n    end\n\n    subgraph \"\ud83d\udd04 Migration Steps\"\n        Step1[\"1: Extract Business Logic&lt;br/&gt;Move logic from services to entities\"]\n        Step2[\"2: Identify Aggregates&lt;br/&gt;Define consistency boundaries\"]\n        Step3[\"3: Add Domain Events&lt;br/&gt;Capture business occurrences\"]\n        Step4[\"4: Implement Event Sourcing&lt;br/&gt;Optional advanced pattern\"]\n    end\n\n    CRUD --&gt; Step1\n    Services --&gt; Step1\n    Step1 --&gt; Step2\n    Step2 --&gt; Step3\n    Step3 --&gt; Step4\n    Step4 --&gt; Entities\n    Step4 --&gt; Aggregates\n    Step4 --&gt; Events\n\n    style Step1 fill:#e3f2fd\n    style Step2 fill:#e8f5e8\n    style Step3 fill:#fff3e0\n    style Step4 fill:#f3e5f5</code></pre>"},{"location":"patterns/domain-driven-design/#testing-domain-abstractions","title":"\ud83e\uddea Testing Domain Abstractions","text":""},{"location":"patterns/domain-driven-design/#testing-event-driven-aggregates","title":"Testing Event-Driven Aggregates","text":"<p>The event-driven pattern makes domain logic highly testable through event verification:</p> <pre><code>import pytest\nfrom decimal import Decimal\nfrom samples.openbank.domain.models.bank_account import BankAccount, Person\nfrom samples.openbank.domain.models.bank_transaction import BankTransactionV1, BankTransactionTypeV1\nfrom samples.openbank.domain.events.bank_account import BankAccountCreatedDomainEventV1\n\nclass TestBankAccountAggregate:\n    \"\"\"Test bank account domain logic through events\"\"\"\n\n    def test_account_creation_produces_correct_event(self):\n        \"\"\"Test that account creation produces the expected domain event\"\"\"\n\n        # Arrange\n        owner = Person(\"John\", \"Doe\", \"US\", PersonGender.MALE, date(1980, 1, 1), Address(...))\n        overdraft_limit = Decimal(\"500.00\")\n\n        # Act\n        account = BankAccount(owner, overdraft_limit)\n\n        # Assert - Verify event was registered\n        assert len(account._pending_events) == 1\n\n        # Assert - Verify event type and data\n        created_event = account._pending_events[0]\n        assert isinstance(created_event, BankAccountCreatedDomainEventV1)\n        assert created_event.owner_id == owner.id()\n        assert created_event.overdraft_limit == overdraft_limit\n\n        # Assert - Verify state was updated correctly\n        assert account.state.owner_id == owner.id()\n        assert account.state.overdraft_limit == overdraft_limit\n        assert account.state.balance == Decimal(\"0.00\")\n\n    def test_successful_transaction_updates_state_and_registers_event(self):\n        \"\"\"Test transaction processing with event verification\"\"\"\n\n        # Arrange\n        owner = Person(\"Jane\", \"Smith\", \"CA\", PersonGender.FEMALE, date(1990, 1, 1), Address(...))\n        account = BankAccount(owner, Decimal(\"100.00\"))\n\n        deposit_transaction = BankTransactionV1(\n            amount=Decimal(\"250.00\"),\n            type=BankTransactionTypeV1.DEPOSIT,\n            description=\"Initial deposit\"\n        )\n\n        # Clear creation event for clean test\n        account.clear_pending_events()\n\n        # Act\n        result = account.try_add_transaction(deposit_transaction)\n\n        # Assert - Transaction was accepted\n        assert result is True\n\n        # Assert - Event was registered\n        assert len(account._pending_events) == 1\n        transaction_event = account._pending_events[0]\n        assert transaction_event.transaction == deposit_transaction\n\n        # Assert - State was updated correctly\n        assert account.state.balance == Decimal(\"250.00\")\n        assert len(account.state.transactions) == 1\n        assert account.state.transactions[0] == deposit_transaction\n\n    def test_overdraft_rejection_produces_no_events(self):\n        \"\"\"Test business rule validation prevents invalid operations\"\"\"\n\n        # Arrange\n        owner = Person(\"Bob\", \"Wilson\", \"UK\", PersonGender.MALE, date(1975, 6, 15), Address(...))\n        account = BankAccount(owner, Decimal(\"50.00\"))  # Small overdraft limit\n\n        withdrawal_transaction = BankTransactionV1(\n            amount=Decimal(\"100.00\"),  # Exceeds balance + overdraft\n            type=BankTransactionTypeV1.WITHDRAWAL,\n            description=\"Large withdrawal\"\n        )\n\n        account.clear_pending_events()\n\n        # Act\n        result = account.try_add_transaction(withdrawal_transaction)\n\n        # Assert - Transaction was rejected\n        assert result is False\n\n        # Assert - No events were registered\n        assert len(account._pending_events) == 0\n\n        # Assert - State remains unchanged\n        assert account.state.balance == Decimal(\"0.00\")\n        assert len(account.state.transactions) == 0\n</code></pre>"},{"location":"patterns/domain-driven-design/#testing-event-handlers-with-multiple-dispatch","title":"Testing Event Handlers with Multiple Dispatch","text":"<pre><code>class TestBankAccountState:\n    \"\"\"Test state event handling in isolation\"\"\"\n\n    def test_account_created_event_handler(self):\n        \"\"\"Test @dispatch event handler for account creation\"\"\"\n\n        # Arrange\n        state = BankAccountStateV1()\n        event = BankAccountCreatedDomainEventV1(\n            aggregate_id=\"account-123\",\n            owner_id=\"person-456\",\n            overdraft_limit=Decimal(\"1000.00\")\n        )\n\n        # Act\n        state.on(event)  # Multiple dispatch routes to correct handler\n\n        # Assert\n        assert state.id == \"account-123\"\n        assert state.owner_id == \"person-456\"\n        assert state.overdraft_limit == Decimal(\"1000.00\")\n        assert state.created_at == event.created_at\n\n    def test_balance_computation_from_events(self):\n        \"\"\"Test that balance is correctly computed from event sequence\"\"\"\n\n        # Arrange\n        state = BankAccountStateV1()\n\n        # Series of transaction events\n        events = [\n            BankAccountTransactionRecordedDomainEventV1(\n                aggregate_id=\"account-123\",\n                transaction=BankTransactionV1(\n                    amount=Decimal(\"500.00\"),\n                    type=BankTransactionTypeV1.DEPOSIT,\n                    description=\"Initial deposit\"\n                )\n            ),\n            BankAccountTransactionRecordedDomainEventV1(\n                aggregate_id=\"account-123\",\n                transaction=BankTransactionV1(\n                    amount=Decimal(\"150.00\"),\n                    type=BankTransactionTypeV1.WITHDRAWAL,\n                    description=\"ATM withdrawal\"\n                )\n            ),\n            BankAccountTransactionRecordedDomainEventV1(\n                aggregate_id=\"account-123\",\n                transaction=BankTransactionV1(\n                    amount=Decimal(\"25.00\"),\n                    type=BankTransactionTypeV1.INTEREST,\n                    description=\"Monthly interest\"\n                )\n            )\n        ]\n\n        # Act - Apply events in sequence\n        for event in events:\n            state.on(event)\n\n        # Assert - Balance computed correctly\n        expected_balance = Decimal(\"500.00\") - Decimal(\"150.00\") + Decimal(\"25.00\")\n        assert state.balance == expected_balance\n        assert len(state.transactions) == 3\n</code></pre>"},{"location":"patterns/domain-driven-design/#integration-testing-with-event-store","title":"Integration Testing with Event Store","text":"<pre><code>class TestBankAccountIntegration:\n    \"\"\"Integration tests with event sourcing infrastructure\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_aggregate_reconstruction_from_events(self):\n        \"\"\"Test that aggregates can be rebuilt from event streams\"\"\"\n\n        # Arrange - Create and save aggregate with multiple operations\n        owner = Person(\"Alice\", \"Johnson\", \"US\", PersonGender.FEMALE, date(1985, 3, 20), Address(...))\n        account = BankAccount(owner, Decimal(\"200.00\"))\n\n        account.try_add_transaction(BankTransactionV1(\n            amount=Decimal(\"1000.00\"),\n            type=BankTransactionTypeV1.DEPOSIT,\n            description=\"Salary deposit\"\n        ))\n\n        account.try_add_transaction(BankTransactionV1(\n            amount=Decimal(\"300.00\"),\n            type=BankTransactionTypeV1.WITHDRAWAL,\n            description=\"Rent payment\"\n        ))\n\n        # Save to repository (persists events)\n        await self.repository.add_async(account)\n        account_id = account.id()\n\n        # Act - Load aggregate from event store\n        reconstructed_account = await self.repository.get_by_id_async(account_id)\n\n        # Assert - State matches original\n        assert reconstructed_account.state.balance == Decimal(\"700.00\")  # 1000 - 300\n        assert len(reconstructed_account.state.transactions) == 2\n        assert reconstructed_account.state.owner_id == owner.id()\n        assert reconstructed_account.state.overdraft_limit == Decimal(\"200.00\")\n</code></pre>"},{"location":"patterns/domain-driven-design/#testing-domain-event-publishing","title":"Testing Domain Event Publishing","text":"<pre><code>class TestDomainEventIntegration:\n    \"\"\"Test domain event publishing and handling\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_domain_events_trigger_integration_events(self):\n        \"\"\"Test that domain events are properly published as integration events\"\"\"\n\n        # Arrange\n        mock_event_bus = Mock(spec=EventBus)\n        handler = BankAccountDomainEventHandler(\n            mediator=self.mediator,\n            mapper=self.mapper,\n            write_models=self.write_repository,\n            read_models=self.read_repository,\n            cloud_event_bus=mock_event_bus,\n            cloud_event_publishing_options=CloudEventPublishingOptions()\n        )\n\n        domain_event = BankAccountCreatedDomainEventV1(\n            aggregate_id=\"account-789\",\n            owner_id=\"person-123\",\n            overdraft_limit=Decimal(\"500.00\")\n        )\n\n        # Act\n        await handler.handle_async(domain_event)\n\n        # Assert - Cloud event was published\n        mock_event_bus.publish_async.assert_called_once()\n        published_event = mock_event_bus.publish_async.call_args[0][0]\n\n        assert published_event.type == \"bank-account.created.v1\"\n        assert published_event.source == \"openbank.accounts\"\n        assert \"account-789\" in published_event.data\n</code></pre>"},{"location":"patterns/domain-driven-design/#key-testing-benefits","title":"Key Testing Benefits","text":"<ol> <li>\ud83c\udfaf Clear Expectations: Events make the expected behavior explicit</li> <li>\ud83d\udd0d Easy Verification: Test what events are produced, not internal state</li> <li>\ud83e\uddea Isolated Testing: Test domain logic without infrastructure dependencies</li> <li>\ud83d\udcdd Living Documentation: Tests serve as examples of domain behavior</li> <li>\ud83d\udee1\ufe0f Regression Protection: Changes that break domain rules fail tests immediately</li> <li>\ud83d\udd04 Event Replay Testing: Verify aggregates can be reconstructed from events</li> <li>\u26a1 Fast Execution: Pure domain tests run quickly without I/O</li> </ol>"},{"location":"patterns/domain-driven-design/#common-mistakes","title":"\u26a0\ufe0f Common Mistakes","text":""},{"location":"patterns/domain-driven-design/#1-anemic-domain-models-data-bags","title":"1. Anemic Domain Models (Data Bags)","text":"<pre><code># \u274c Wrong - entity with no behavior\nclass Order:\n    def __init__(self):\n        self.id = None\n        self.customer_id = None\n        self.items = []\n        self.total = 0\n        # \u274c Just properties, no business logic\n\n# \u2705 Correct - rich entity with behavior\nclass Order(Entity):\n    def __init__(self, customer_id: str, items: List[OrderItem]):\n        super().__init__()\n        self.customer_id = customer_id\n        self.items = items\n        self.total = self._calculate_total()  # \u2705 Business logic\n        self.raise_event(OrderPlacedEvent(...))  # \u2705 Domain events\n\n    def _calculate_total(self) -&gt; Decimal:\n        # \u2705 Business rule encapsulated\n        return sum(item.subtotal for item in self.items) * Decimal(\"1.08\")\n</code></pre>"},{"location":"patterns/domain-driven-design/#2-business-logic-in-application-layer","title":"2. Business Logic in Application Layer","text":"<pre><code># \u274c Wrong - business logic in handler\nclass PlaceOrderHandler(CommandHandler):\n    async def handle_async(self, command: PlaceOrderCommand):\n        # \u274c Calculation in handler\n        total = sum(item.price for item in command.items)\n        tax = total * 0.08\n\n        # \u274c Validation in handler\n        if total &gt; 1000:\n            return self.bad_request(\"Too expensive\")\n\n        order = Order()\n        order.total = total + tax\n        await self._repository.save_async(order)\n\n# \u2705 Correct - business logic in domain\nclass PlaceOrderHandler(CommandHandler):\n    async def handle_async(self, command: PlaceOrderCommand):\n        # \u2705 Entity handles all business logic\n        order = Order(command.customer_id, command.items)\n        await self._repository.save_async(order)\n        return self.created(order_dto)\n</code></pre>"},{"location":"patterns/domain-driven-design/#3-not-using-value-objects-for-concepts","title":"3. Not Using Value Objects for Concepts","text":"<pre><code># \u274c Wrong - primitive obsession\nclass Order(Entity):\n    def __init__(self, customer_id: str, delivery_address: str):\n        self.customer_id = customer_id\n        self.delivery_address = delivery_address  # \u274c String for address\n        self.delivery_city = None\n        self.delivery_zip = None\n        # \u274c Address logic scattered\n\n# \u2705 Correct - value object for address concept\n@dataclass(frozen=True)\nclass Address:\n    \"\"\"Value object representing delivery address\"\"\"\n    street: str\n    city: str\n    state: str\n    zip_code: str\n\n    def __post_init__(self):\n        if not self.zip_code or len(self.zip_code) != 5:\n            raise ValueError(\"Invalid ZIP code\")\n\nclass Order(Entity):\n    def __init__(self, customer_id: str, delivery_address: Address):\n        self.customer_id = customer_id\n        self.delivery_address = delivery_address  # \u2705 Rich value object\n</code></pre>"},{"location":"patterns/domain-driven-design/#4-aggregate-boundaries-too-large","title":"4. Aggregate Boundaries Too Large","text":"<pre><code># \u274c Wrong - massive aggregate with everything\nclass Restaurant(AggregateRoot):\n    def __init__(self):\n        self.orders = []  # \u274c All orders\n        self.menu_items = []  # \u274c All menu items\n        self.employees = []  # \u274c All employees\n        self.inventory = []  # \u274c All inventory\n        # \u274c Too much in one aggregate - performance issues\n\n# \u2705 Correct - focused aggregates with clear boundaries\nclass Order(AggregateRoot):\n    \"\"\"Aggregate for order lifecycle\"\"\"\n    def __init__(self, customer_id: str, items: List[OrderItem]):\n        # \u2705 Only order-related data\n        pass\n\nclass MenuItem(AggregateRoot):\n    \"\"\"Aggregate for menu management\"\"\"\n    def __init__(self, name: str, price: Decimal):\n        # \u2705 Only menu item data\n        pass\n\n# Aggregates reference each other by ID, not by object\nclass Order(AggregateRoot):\n    def __init__(self, customer_id: str, menu_item_ids: List[str]):\n        self.menu_item_ids = menu_item_ids  # \u2705 Reference by ID\n</code></pre>"},{"location":"patterns/domain-driven-design/#5-not-raising-domain-events","title":"5. Not Raising Domain Events","text":"<pre><code># \u274c Wrong - state changes without events\nclass Order(Entity):\n    def confirm(self):\n        self.status = OrderStatus.CONFIRMED\n        # \u274c No event raised - other systems don't know\n\n# \u2705 Correct - domain events for business occurrences\nclass Order(Entity):\n    def confirm(self, payment_transaction_id: str):\n        self.status = OrderStatus.CONFIRMED\n        self.payment_transaction_id = payment_transaction_id\n\n        # \u2705 Event raised for important business occurrence\n        self.raise_event(OrderConfirmedEvent(\n            order_id=self.id,\n            transaction_id=payment_transaction_id\n        ))\n</code></pre>"},{"location":"patterns/domain-driven-design/#6-domain-layer-depending-on-infrastructure","title":"6. Domain Layer Depending on Infrastructure","text":"<pre><code># \u274c Wrong - domain imports infrastructure\nfrom pymongo import Collection  # \u274c Infrastructure in domain\n\nclass Order(Entity):\n    def save_to_database(self, collection: Collection):\n        # \u274c Domain entity knows about MongoDB\n        collection.insert_one(self.__dict__)\n\n# \u2705 Correct - domain has no infrastructure dependencies\nclass Order(Entity):\n    def __init__(self, customer_id: str, items: List[OrderItem]):\n        # \u2705 Pure business logic\n        self.customer_id = customer_id\n        self.items = items\n\n# Infrastructure in integration layer\nclass MongoOrderRepository(IOrderRepository):\n    async def save_async(self, order: Order):\n        # \u2705 Repository handles persistence\n        doc = self._entity_to_document(order)\n        await self._collection.insert_one(doc)\n</code></pre>"},{"location":"patterns/domain-driven-design/#when-not-to-use","title":"\ud83d\udeab When NOT to Use","text":""},{"location":"patterns/domain-driven-design/#1-simple-crud-applications","title":"1. Simple CRUD Applications","text":"<p>For basic data management without complex business rules:</p> <pre><code># DDD is overkill for simple CRUD\n@app.get(\"/customers\")\nasync def get_customers(db: Database):\n    return await db.customers.find().to_list(None)\n\n@app.post(\"/customers\")\nasync def create_customer(customer: dict, db: Database):\n    result = await db.customers.insert_one(customer)\n    return {\"id\": str(result.inserted_id)}\n</code></pre>"},{"location":"patterns/domain-driven-design/#2-prototypes-and-throwaway-code","title":"2. Prototypes and Throwaway Code","text":"<p>When building quick prototypes or spikes:</p> <pre><code># Quick prototype doesn't need DDD structure\nasync def process_order(order_data: dict):\n    # Direct implementation without domain modeling\n    total = sum(item[\"price\"] for item in order_data[\"items\"])\n    await db.orders.insert_one({\"total\": total})\n</code></pre>"},{"location":"patterns/domain-driven-design/#3-data-centric-applications-reportinganalytics","title":"3. Data-Centric Applications (Reporting/Analytics)","text":"<p>When application is primarily about data transformation:</p> <pre><code># Analytics queries don't need domain models\nasync def generate_sales_report(start_date: date, end_date: date):\n    # Direct database aggregation\n    pipeline = [\n        {\"$match\": {\"date\": {\"$gte\": start_date, \"$lte\": end_date}}},\n        {\"$group\": {\"_id\": \"$category\", \"total\": {\"$sum\": \"$amount\"}}}\n    ]\n    return await db.sales.aggregate(pipeline).to_list(None)\n</code></pre>"},{"location":"patterns/domain-driven-design/#4-small-teams-without-ddd-experience","title":"4. Small Teams Without DDD Experience","text":"<p>When team lacks DDD knowledge and time to learn:</p> <pre><code># Simple service pattern may be more appropriate\nclass OrderService:\n    async def create_order(self, order_data: dict):\n        # Traditional service approach\n        order = Order(**order_data)\n        return await self._db.save(order)\n</code></pre>"},{"location":"patterns/domain-driven-design/#5-performance-critical-systems","title":"5. Performance-Critical Systems","text":"<p>When microsecond-level performance is critical:</p> <pre><code># Rich domain models add overhead\n# For high-frequency trading or real-time systems,\n# procedural code may be more appropriate\ndef process_tick(price: float, volume: int):\n    # Direct calculation without object overhead\n    return price * volume * commission_rate\n</code></pre>"},{"location":"patterns/domain-driven-design/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ol> <li>Rich Domain Models: Business logic belongs in domain entities, not services</li> <li>Ubiquitous Language: Use business terminology in code</li> <li>Aggregate Boundaries: Define clear consistency boundaries</li> <li>Domain Events: First-class representation of business occurrences</li> <li>Value Objects: Immutable objects for domain concepts</li> <li>Entity Identity: Entities have identity that persists over time</li> <li>No Infrastructure Dependencies: Domain layer is pure business logic</li> <li>Bounded Contexts: Clear boundaries around cohesive models</li> <li>Testing: Test domain logic in isolation without infrastructure</li> <li>Framework Support: Neuroglia provides abstractions for both Entity and AggregateRoot patterns</li> </ol>"},{"location":"patterns/domain-driven-design/#related-patterns","title":"\ud83d\udd17 Related Patterns","text":"<ul> <li>\ud83c\udfd7\ufe0f Clean Architecture - Foundational layering that supports DDD</li> <li>\ud83d\udce1 CQRS &amp; Mediation - Command/Query patterns for domain operations</li> <li>\ud83c\udfaf Event Sourcing - Advanced persistence using domain events</li> <li>\ud83d\udd04 Event-Driven Architecture - System integration through domain events</li> <li>\ud83d\udcbe Repository Pattern - Data access abstraction for aggregates</li> </ul> <p>Domain Driven Design provides the foundation for building maintainable, business-focused applications. The Neuroglia framework's abstractions support both simple domain models and advanced patterns like event sourcing, allowing teams to evolve their architecture as complexity grows.</p>"},{"location":"patterns/event-driven/","title":"\ud83d\udce1 Event-Driven Architecture Pattern","text":"<p>Estimated reading time: 20 minutes</p> <p>Event-Driven Architecture uses events to communicate between decoupled components, enabling loose coupling, scalability, and reactive system behavior.</p>"},{"location":"patterns/event-driven/#what-why","title":"\ud83c\udfaf What &amp; Why","text":""},{"location":"patterns/event-driven/#the-problem-tight-coupling-in-synchronous-systems","title":"The Problem: Tight Coupling in Synchronous Systems","text":"<p>Without event-driven architecture, components become tightly coupled through direct method calls:</p> <pre><code># \u274c Problem: Order handler tightly coupled to all downstream systems\nclass PlaceOrderHandler(CommandHandler):\n    def __init__(\n        self,\n        repository: IOrderRepository,\n        kitchen_service: KitchenService,\n        sms_service: SMSService,\n        email_service: EmailService,\n        inventory_service: InventoryService,\n        analytics_service: AnalyticsService\n    ):\n        # Handler knows about ALL downstream systems\n        self._repository = repository\n        self._kitchen = kitchen_service\n        self._sms = sms_service\n        self._email = email_service\n        self._inventory = inventory_service\n        self._analytics = analytics_service\n\n    async def handle_async(self, command: PlaceOrderCommand):\n        # Create order\n        order = Order.create(command.customer_id, command.items)\n        await self._repository.save_async(order)\n\n        # \u274c Direct calls to every system - tightly coupled\n        await self._kitchen.add_to_queue_async(order.id)\n        await self._sms.send_confirmation_async(order.customer_phone)\n        await self._email.send_confirmation_async(order.customer_email)\n        await self._inventory.reserve_ingredients_async(order.items)\n        await self._analytics.track_order_async(order)\n\n        # \u274c If SMS service is down, entire order placement fails\n        # \u274c Adding new notification channel requires changing this handler\n        # \u274c All operations execute sequentially, slowing response time\n\n        return self.created(order_dto)\n</code></pre> <p>Problems with this approach:</p> <ol> <li>High Coupling: Handler depends on 6+ services directly</li> <li>Brittleness: If any downstream service fails, the entire operation fails</li> <li>Poor Scalability: All operations execute sequentially in one request</li> <li>Hard to Extend: Adding new functionality requires modifying handler</li> <li>Testing Complexity: Must mock all dependencies for testing</li> </ol>"},{"location":"patterns/event-driven/#the-solution-event-driven-decoupling","title":"The Solution: Event-Driven Decoupling","text":"<p>With event-driven architecture, components communicate through events:</p> <pre><code># \u2705 Solution: Handler only knows about domain, publishes event\nclass PlaceOrderHandler(CommandHandler):\n    def __init__(\n        self,\n        repository: IOrderRepository,\n        mapper: Mapper\n    ):\n        # Handler only depends on repository\n        self._repository = repository\n        self._mapper = mapper\n\n    async def handle_async(self, command: PlaceOrderCommand):\n        # Create order\n        order = Order.create(command.customer_id, command.items)\n\n        # Domain entity raises event automatically\n        # order.raise_event(OrderPlacedEvent(...))\n\n        await self._repository.save_async(order)\n\n        # \u2705 Event automatically published by framework\n        # \u2705 Handler doesn't know who listens to the event\n        # \u2705 Multiple handlers process event independently and asynchronously\n        # \u2705 If SMS fails, order placement still succeeds\n\n        return self.created(self._mapper.map(order, OrderDto))\n\n# Independent event handlers respond to OrderPlacedEvent\nclass KitchenWorkflowHandler(EventHandler[OrderPlacedEvent]):\n    async def handle_async(self, event: OrderPlacedEvent):\n        await self._kitchen_service.add_to_queue_async(event.order_id)\n\nclass CustomerNotificationHandler(EventHandler[OrderPlacedEvent]):\n    async def handle_async(self, event: OrderPlacedEvent):\n        await self._sms_service.send_confirmation_async(event.customer_phone)\n\nclass InventoryHandler(EventHandler[OrderPlacedEvent]):\n    async def handle_async(self, event: OrderPlacedEvent):\n        await self._inventory_service.reserve_ingredients_async(event.items)\n\nclass AnalyticsHandler(EventHandler[OrderPlacedEvent]):\n    async def handle_async(self, event: OrderPlacedEvent):\n        await self._analytics_service.track_order_async(event)\n</code></pre> <p>Benefits of event-driven approach:</p> <ol> <li>Loose Coupling: Components don't know about each other</li> <li>Independent Scaling: Each handler scales independently</li> <li>Fault Isolation: Failed handlers don't affect core workflow</li> <li>Easy Extension: Add new handlers without changing existing code</li> <li>Parallel Processing: Handlers execute concurrently</li> <li>Simple Testing: Test handlers in isolation</li> </ol>"},{"location":"patterns/event-driven/#overview","title":"\ud83c\udfaf Overview","text":"<p>Event-Driven Architecture (EDA) promotes loose coupling through asynchronous event communication. Mario's Pizzeria demonstrates this pattern through domain events that coordinate kitchen operations, customer notifications, and order tracking.</p> <pre><code>flowchart TD\n    subgraph \"\ud83c\udf55 Mario's Pizzeria Event Flow\"\n        Customer[Customer]\n\n        subgraph Domain[\"\ud83c\udfdb\ufe0f Domain Events\"]\n            OrderPlaced[OrderPlacedEvent]\n            PaymentProcessed[PaymentProcessedEvent]\n            OrderCooking[OrderCookingStartedEvent]\n            OrderReady[OrderReadyEvent]\n            OrderDelivered[OrderDeliveredEvent]\n        end\n\n        subgraph Handlers[\"\ud83d\udce1 Event Handlers\"]\n            KitchenHandler[Kitchen Workflow Handler]\n            NotificationHandler[SMS Notification Handler]\n            InventoryHandler[Inventory Update Handler]\n            AnalyticsHandler[Analytics Handler]\n            EmailHandler[Email Confirmation Handler]\n        end\n\n        subgraph External[\"\ud83d\udd0c External Systems\"]\n            Kitchen[Kitchen Display]\n            SMS[SMS Service]\n            Email[Email Service]\n            Analytics[Analytics DB]\n            Inventory[Inventory System]\n        end\n    end\n\n    Customer --&gt;|\"Place Order\"| OrderPlaced\n\n    OrderPlaced --&gt; KitchenHandler\n    OrderPlaced --&gt; NotificationHandler\n    OrderPlaced --&gt; InventoryHandler\n    OrderPlaced --&gt; EmailHandler\n\n    KitchenHandler --&gt;|\"Start Cooking\"| OrderCooking\n    KitchenHandler --&gt; Kitchen\n\n    OrderCooking --&gt; AnalyticsHandler\n\n    Kitchen --&gt;|\"Pizza Ready\"| OrderReady\n    OrderReady --&gt; NotificationHandler\n    OrderReady --&gt; AnalyticsHandler\n\n    NotificationHandler --&gt; SMS\n    EmailHandler --&gt; Email\n    InventoryHandler --&gt; Inventory\n    AnalyticsHandler --&gt; Analytics\n\n    OrderReady --&gt;|\"Out for Delivery\"| OrderDelivered</code></pre>"},{"location":"patterns/event-driven/#benefits","title":"\u2705 Benefits","text":""},{"location":"patterns/event-driven/#1-loose-coupling","title":"1. Loose Coupling","text":"<p>Components communicate through events without direct dependencies:</p> <pre><code># Order placement doesn't know about kitchen or notifications\nclass PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        order = Order.create(command.customer_id, command.items)\n        await self._repository.save_async(order)\n\n        # Domain entity raises event - handler doesn't know who listens\n        # OrderPlacedEvent is automatically published by the framework\n\n        return self.created(self.mapper.map(order, OrderDto))\n\n# Multiple handlers can respond to events independently\nclass KitchenWorkflowHandler(EventHandler[OrderPlacedEvent]):\n    async def handle_async(self, event: OrderPlacedEvent):\n        await self._kitchen_service.add_to_queue_async(event.order_id)\n\nclass CustomerNotificationHandler(EventHandler[OrderPlacedEvent]):\n    async def handle_async(self, event: OrderPlacedEvent):\n        await self._sms_service.send_confirmation_async(\n            event.customer_phone, event.order_id\n        )\n</code></pre>"},{"location":"patterns/event-driven/#2-scalability","title":"2. Scalability","text":"<p>Event handlers can be scaled independently based on load:</p> <pre><code># High-volume analytics can be processed separately\nclass OrderAnalyticsHandler(EventHandler[OrderPlacedEvent]):\n    async def handle_async(self, event: OrderPlacedEvent):\n        # This can be processed in background/separate service\n        analytics_data = AnalyticsEvent(\n            event_type=\"order_placed\",\n            customer_id=event.customer_id,\n            order_value=event.total_amount,\n            timestamp=event.occurred_at\n        )\n        await self._analytics_service.track_async(analytics_data)\n</code></pre>"},{"location":"patterns/event-driven/#3-resilience","title":"3. Resilience","text":"<p>Failed event handlers don't affect the main workflow:</p> <pre><code># If SMS fails, order processing continues\nclass ResilientNotificationHandler(EventHandler[OrderReadyEvent]):\n    async def handle_async(self, event: OrderReadyEvent):\n        try:\n            await self._sms_service.notify_customer_async(\n                event.customer_phone,\n                f\"Your order #{event.order_id} is ready!\"\n            )\n        except Exception as ex:\n            # Log error but don't fail the entire workflow\n            self._logger.error(f\"SMS notification failed: {ex}\")\n            # Could queue for retry or use alternative notification\n</code></pre>"},{"location":"patterns/event-driven/#data-flow","title":"\ud83d\udd04 Data Flow","text":"<p>The pizza preparation workflow demonstrates event-driven data flow:</p> <pre><code>sequenceDiagram\n    participant Customer\n    participant OrderAPI\n    participant OrderHandler\n    participant EventBus\n    participant KitchenHandler\n    participant NotificationHandler\n    participant Kitchen\n    participant SMS\n\n    Customer-&gt;&gt;+OrderAPI: Place pizza order\n    OrderAPI-&gt;&gt;+OrderHandler: Handle PlaceOrderCommand\n\n    OrderHandler-&gt;&gt;OrderHandler: Create Order entity\n    Note over OrderHandler: Order.raise_event(OrderPlacedEvent)\n\n    OrderHandler-&gt;&gt;+EventBus: Publish OrderPlacedEvent\n    EventBus-&gt;&gt;KitchenHandler: Async delivery\n    EventBus-&gt;&gt;NotificationHandler: Async delivery\n    EventBus--&gt;&gt;-OrderHandler: Events published\n\n    OrderHandler--&gt;&gt;-OrderAPI: Order created successfully\n    OrderAPI--&gt;&gt;-Customer: 201 Created\n\n    Note over Customer,SMS: Parallel Event Processing\n\n    par Kitchen Workflow\n        KitchenHandler-&gt;&gt;+Kitchen: Add order to queue\n        Kitchen--&gt;&gt;-KitchenHandler: Order queued\n\n        Kitchen-&gt;&gt;Kitchen: Start cooking\n        Kitchen-&gt;&gt;+EventBus: Publish OrderCookingStartedEvent\n        EventBus--&gt;&gt;-Kitchen: Event published\n\n        Kitchen-&gt;&gt;Kitchen: Pizza ready\n        Kitchen-&gt;&gt;+EventBus: Publish OrderReadyEvent\n        EventBus-&gt;&gt;NotificationHandler: Deliver event\n        EventBus--&gt;&gt;-Kitchen: Event published\n\n    and Customer Notifications\n        NotificationHandler-&gt;&gt;+SMS: Send order confirmation\n        SMS--&gt;&gt;-NotificationHandler: SMS sent\n\n        Note over NotificationHandler: Wait for OrderReadyEvent\n\n        NotificationHandler-&gt;&gt;+SMS: Send \"order ready\" notification\n        SMS--&gt;&gt;-NotificationHandler: SMS sent\n        SMS-&gt;&gt;Customer: \"Your pizza is ready!\"\n    end</code></pre>"},{"location":"patterns/event-driven/#use-cases","title":"\ud83c\udfaf Use Cases","text":"<p>Event-Driven Architecture is ideal for:</p> <ul> <li>Microservices: Decoupled service communication</li> <li>Real-time Systems: Immediate response to state changes</li> <li>Complex Workflows: Multi-step processes with branching logic</li> <li>Integration: Connecting disparate systems</li> </ul>"},{"location":"patterns/event-driven/#implementation-in-marios-pizzeria","title":"\ud83c\udf55 Implementation in Mario's Pizzeria","text":""},{"location":"patterns/event-driven/#domain-events","title":"Domain Events","text":"<pre><code># Domain events represent important business occurrences\n@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    order_id: str\n    customer_id: str\n    customer_phone: str\n    items: List[OrderItemDto]\n    total_amount: Decimal\n    delivery_address: str\n    estimated_delivery_time: datetime\n\n@dataclass\nclass OrderReadyEvent(DomainEvent):\n    order_id: str\n    customer_id: str\n    customer_phone: str\n    preparation_time: timedelta\n    pickup_instructions: str\n\n@dataclass\nclass InventoryLowEvent(DomainEvent):\n    ingredient_id: str\n    ingredient_name: str\n    current_quantity: int\n    minimum_threshold: int\n    supplier_info: SupplierDto\n</code></pre>"},{"location":"patterns/event-driven/#event-handlers","title":"Event Handlers","text":"<pre><code># Kitchen workflow responds to order events\nclass KitchenWorkflowHandler(EventHandler[OrderPlacedEvent]):\n    def __init__(self,\n                 kitchen_service: KitchenService,\n                 inventory_service: InventoryService):\n        self._kitchen = kitchen_service\n        self._inventory = inventory_service\n\n    async def handle_async(self, event: OrderPlacedEvent):\n        # Check ingredient availability\n        availability = await self._inventory.check_ingredients_async(event.items)\n        if not availability.all_available:\n            # Raise event for procurement\n            await self._event_bus.publish_async(\n                InventoryLowEvent(\n                    ingredient_id=availability.missing_ingredients[0],\n                    current_quantity=availability.current_stock,\n                    minimum_threshold=availability.required_stock\n                )\n            )\n\n        # Add to kitchen queue\n        kitchen_order = KitchenOrder(\n            order_id=event.order_id,\n            items=event.items,\n            priority=self._calculate_priority(event),\n            estimated_prep_time=self._calculate_prep_time(event.items)\n        )\n\n        await self._kitchen.add_to_queue_async(kitchen_order)\n\n        # Raise cooking started event\n        await self._event_bus.publish_async(\n            OrderCookingStartedEvent(\n                order_id=event.order_id,\n                estimated_ready_time=datetime.utcnow() + kitchen_order.estimated_prep_time\n            )\n        )\n\n# Customer communication handler\nclass CustomerCommunicationHandler:\n    def __init__(self,\n                 sms_service: SMSService,\n                 email_service: EmailService):\n        self._sms = sms_service\n        self._email = email_service\n\n    @event_handler(OrderPlacedEvent)\n    async def send_order_confirmation(self, event: OrderPlacedEvent):\n        confirmation_message = f\"\"\"\n        \ud83c\udf55 Order Confirmed!\n\n        Order #{event.order_id}\n        Total: ${event.total_amount}\n        Estimated delivery: {event.estimated_delivery_time.strftime('%H:%M')}\n\n        We'll notify you when your pizza is ready!\n        \"\"\"\n\n        await self._sms.send_async(event.customer_phone, confirmation_message)\n        await self._email.send_order_confirmation_async(event)\n\n    @event_handler(OrderReadyEvent)\n    async def send_ready_notification(self, event: OrderReadyEvent):\n        ready_message = f\"\"\"\n        \ud83c\udf89 Your pizza is ready!\n\n        Order #{event.order_id}\n        Pickup instructions: {event.pickup_instructions}\n\n        Please collect within 10 minutes for best quality.\n        \"\"\"\n\n        await self._sms.send_async(event.customer_phone, ready_message)\n\n# Analytics and reporting handler\nclass AnalyticsHandler:\n    @event_handler(OrderPlacedEvent)\n    async def track_order_metrics(self, event: OrderPlacedEvent):\n        metrics = OrderMetrics(\n            order_id=event.order_id,\n            customer_id=event.customer_id,\n            order_value=event.total_amount,\n            item_count=len(event.items),\n            order_time=event.occurred_at,\n            customer_type=await self._get_customer_type(event.customer_id)\n        )\n\n        await self._analytics_db.save_metrics_async(metrics)\n\n    @event_handler(OrderReadyEvent)\n    async def track_preparation_metrics(self, event: OrderReadyEvent):\n        prep_metrics = PreparationMetrics(\n            order_id=event.order_id,\n            preparation_time=event.preparation_time,\n            efficiency_score=self._calculate_efficiency(event.preparation_time)\n        )\n\n        await self._analytics_db.save_prep_metrics_async(prep_metrics)\n</code></pre>"},{"location":"patterns/event-driven/#event-bus-configuration","title":"Event Bus Configuration","text":"<pre><code># Configure event routing and handlers\nclass EventBusConfiguration:\n    def configure_events(self, services: ServiceCollection):\n        # Register event handlers\n        services.add_scoped(KitchenWorkflowHandler)\n        services.add_scoped(CustomerCommunicationHandler)\n        services.add_scoped(AnalyticsHandler)\n        services.add_scoped(InventoryManagementHandler)\n\n        # Configure event routing\n        services.add_event_handler(OrderPlacedEvent, KitchenWorkflowHandler)\n        services.add_event_handler(OrderPlacedEvent, CustomerCommunicationHandler)\n        services.add_event_handler(OrderPlacedEvent, AnalyticsHandler)\n\n        services.add_event_handler(OrderReadyEvent, CustomerCommunicationHandler)\n        services.add_event_handler(OrderReadyEvent, AnalyticsHandler)\n\n        services.add_event_handler(InventoryLowEvent, InventoryManagementHandler)\n</code></pre>"},{"location":"patterns/event-driven/#cloudevents-integration","title":"CloudEvents Integration","text":"<pre><code># CloudEvents for external system integration\nclass CloudEventPublisher:\n    def __init__(self, event_bus: EventBus):\n        self._event_bus = event_bus\n\n    async def publish_order_event(self, order_event: OrderPlacedEvent):\n        # Convert domain event to CloudEvent for external systems\n        cloud_event = CloudEvent(\n            source=\"mario-pizzeria/orders\",\n            type=\"com.mariopizzeria.order.placed\",\n            subject=f\"order/{order_event.order_id}\",\n            data={\n                \"orderId\": order_event.order_id,\n                \"customerId\": order_event.customer_id,\n                \"totalAmount\": float(order_event.total_amount),\n                \"items\": [item.to_dict() for item in order_event.items],\n                \"estimatedDelivery\": order_event.estimated_delivery_time.isoformat()\n            },\n            datacontenttype=\"application/json\"\n        )\n\n        await self._event_bus.publish_cloud_event_async(cloud_event)\n</code></pre>"},{"location":"patterns/event-driven/#testing-event-driven-systems","title":"\ud83e\uddea Testing Event-Driven Systems","text":""},{"location":"patterns/event-driven/#unit-testing-event-handlers","title":"Unit Testing Event Handlers","text":"<pre><code>import pytest\nfrom unittest.mock import AsyncMock, Mock\n\n@pytest.mark.asyncio\nasync def test_kitchen_workflow_handler():\n    # Arrange\n    mock_kitchen = AsyncMock(spec=KitchenService)\n    mock_inventory = AsyncMock(spec=InventoryService)\n    mock_inventory.check_ingredients_async.return_value = IngredientAvailability(\n        all_available=True\n    )\n\n    handler = KitchenWorkflowHandler(mock_kitchen, mock_inventory)\n\n    event = OrderPlacedEvent(\n        order_id=\"order_123\",\n        customer_id=\"cust_456\",\n        items=[OrderItemDto(pizza_name=\"Margherita\", size=\"large\", quantity=2)],\n        total_amount=Decimal(\"31.98\")\n    )\n\n    # Act\n    await handler.handle_async(event)\n\n    # Assert\n    mock_inventory.check_ingredients_async.assert_called_once()\n    mock_kitchen.add_to_queue_async.assert_called_once()\n\n    kitchen_order = mock_kitchen.add_to_queue_async.call_args[0][0]\n    assert kitchen_order.order_id == \"order_123\"\n\n@pytest.mark.asyncio\nasync def test_notification_handler_resilience():\n    # Arrange\n    mock_sms = AsyncMock(spec=SMSService)\n    mock_sms.send_async.side_effect = Exception(\"SMS service unavailable\")\n    mock_logger = Mock()\n\n    handler = CustomerNotificationHandler(mock_sms, mock_logger)\n    event = OrderReadyEvent(order_id=\"123\", customer_phone=\"+1234567890\")\n\n    # Act - should not raise exception\n    await handler.handle_async(event)\n\n    # Assert - error logged but execution continued\n    mock_logger.error.assert_called_once()\n</code></pre>"},{"location":"patterns/event-driven/#integration-testing-with-event-bus","title":"Integration Testing with Event Bus","text":"<pre><code>@pytest.mark.integration\nclass TestEventIntegration:\n    @pytest.fixture\n    def event_bus(self):\n        \"\"\"Create in-memory event bus for testing\"\"\"\n        return InMemoryEventBus()\n\n    @pytest.mark.asyncio\n    async def test_order_placement_triggers_all_handlers(self, event_bus):\n        # Arrange\n        kitchen_handler = Mock(spec=KitchenWorkflowHandler)\n        kitchen_handler.handle_async = AsyncMock()\n\n        notification_handler = Mock(spec=CustomerNotificationHandler)\n        notification_handler.send_order_confirmation = AsyncMock()\n\n        analytics_handler = Mock(spec=AnalyticsHandler)\n        analytics_handler.track_order_metrics = AsyncMock()\n\n        # Subscribe handlers\n        event_bus.subscribe(OrderPlacedEvent, kitchen_handler)\n        event_bus.subscribe(OrderPlacedEvent, notification_handler)\n        event_bus.subscribe(OrderPlacedEvent, analytics_handler)\n\n        event = OrderPlacedEvent(\n            order_id=\"order_123\",\n            customer_id=\"cust_456\",\n            items=[],\n            total_amount=Decimal(\"20.00\")\n        )\n\n        # Act\n        await event_bus.publish_async(event)\n\n        # Assert - all handlers received event\n        kitchen_handler.handle_async.assert_called_once_with(event)\n        notification_handler.send_order_confirmation.assert_called_once_with(event)\n        analytics_handler.track_order_metrics.assert_called_once_with(event)\n\n    @pytest.mark.asyncio\n    async def test_handler_failure_does_not_affect_others(self, event_bus):\n        # Arrange\n        failing_handler = Mock(spec=EventHandler)\n        failing_handler.handle_async = AsyncMock(side_effect=Exception(\"Handler failed\"))\n\n        successful_handler = Mock(spec=EventHandler)\n        successful_handler.handle_async = AsyncMock()\n\n        event_bus.subscribe(OrderPlacedEvent, failing_handler)\n        event_bus.subscribe(OrderPlacedEvent, successful_handler)\n\n        event = OrderPlacedEvent(order_id=\"123\", customer_id=\"456\")\n\n        # Act\n        await event_bus.publish_async(event)\n\n        # Assert - successful handler still executed\n        failing_handler.handle_async.assert_called_once()\n        successful_handler.handle_async.assert_called_once()\n</code></pre>"},{"location":"patterns/event-driven/#common-mistakes","title":"\u26a0\ufe0f Common Mistakes","text":""},{"location":"patterns/event-driven/#1-event-coupling-tight-event-dependencies","title":"1. Event Coupling (Tight Event Dependencies)","text":"<pre><code># \u274c Wrong - events coupled to specific consumers\n@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    order_id: str\n    customer_id: str\n    # \u274c Event knows about SMS service details\n    sms_provider: str\n    sms_api_key: str\n    # \u274c Event knows about kitchen system details\n    kitchen_display_id: str\n    kitchen_printer_ip: str\n\n# \u2705 Correct - events contain only domain information\n@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    order_id: str\n    customer_id: str\n    customer_phone: str\n    items: List[OrderItemDto]\n    total_amount: Decimal\n    delivery_address: str\n    # \u2705 Generic domain data - handlers decide how to use it\n</code></pre>"},{"location":"patterns/event-driven/#2-large-events-with-too-much-data","title":"2. Large Events with Too Much Data","text":"<pre><code># \u274c Wrong - event contains entire order aggregate\n@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    order: Order  # \u274c Entire aggregate with all data\n    customer: Customer  # \u274c Complete customer aggregate\n    menu: Menu  # \u274c Entire menu for price lookup\n    inventory: InventorySnapshot  # \u274c Full inventory state\n\n# \u2705 Correct - event contains only essential data\n@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    order_id: str  # \u2705 ID for handlers to fetch details if needed\n    customer_id: str\n    items: List[OrderItemDto]  # \u2705 Only essential order information\n    total_amount: Decimal\n    # Handlers can query repository for more details if needed\n</code></pre>"},{"location":"patterns/event-driven/#3-missing-error-handling","title":"3. Missing Error Handling","text":"<pre><code># \u274c Wrong - event handler can crash entire system\nclass CustomerNotificationHandler(EventHandler[OrderReadyEvent]):\n    async def handle_async(self, event: OrderReadyEvent):\n        # \u274c No error handling - exception bubbles up\n        await self._sms_service.send_async(\n            event.customer_phone,\n            f\"Your order #{event.order_id} is ready!\"\n        )\n\n# \u2705 Correct - resilient event handler with error handling\nclass CustomerNotificationHandler(EventHandler[OrderReadyEvent]):\n    async def handle_async(self, event: OrderReadyEvent):\n        try:\n            await self._sms_service.send_async(\n                event.customer_phone,\n                f\"Your order #{event.order_id} is ready!\"\n            )\n        except SMSServiceException as ex:\n            # \u2705 Log error and continue\n            self._logger.error(\n                f\"SMS notification failed for order {event.order_id}: {ex}\"\n            )\n            # \u2705 Optional: queue for retry\n            await self._retry_queue.enqueue_async(\n                RetryMessage(event=event, attempt=1)\n            )\n        except Exception as ex:\n            # \u2705 Catch unexpected errors\n            self._logger.exception(\n                f\"Unexpected error in notification handler: {ex}\"\n            )\n</code></pre>"},{"location":"patterns/event-driven/#4-synchronous-processing-of-events","title":"4. Synchronous Processing of Events","text":"<pre><code># \u274c Wrong - processing events synchronously blocks the request\nclass PlaceOrderHandler(CommandHandler):\n    async def handle_async(self, command: PlaceOrderCommand):\n        order = Order.create(command.customer_id, command.items)\n        await self._repository.save_async(order)\n\n        # \u274c Waiting for all event handlers before responding\n        event = OrderPlacedEvent(order_id=order.id, ...)\n        await self._event_bus.publish_and_wait_async(event)  # \u274c Blocks\n\n        return self.created(order_dto)\n\n# \u2705 Correct - fire-and-forget event publishing\nclass PlaceOrderHandler(CommandHandler):\n    async def handle_async(self, command: PlaceOrderCommand):\n        order = Order.create(command.customer_id, command.items)\n        await self._repository.save_async(order)\n\n        # \u2705 Events published asynchronously, don't wait\n        # Domain events automatically published by framework\n\n        return self.created(order_dto)  # \u2705 Respond immediately\n</code></pre>"},{"location":"patterns/event-driven/#5-event-versioning-ignored","title":"5. Event Versioning Ignored","text":"<pre><code># \u274c Wrong - breaking changes to event structure\n@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    order_id: str\n    # \u274c Removed customer_phone, breaking existing handlers\n    # customer_phone: str  # REMOVED\n    customer_email: str  # \u274c Added new required field\n\n# \u2705 Correct - backward-compatible event evolution\n@dataclass\nclass OrderPlacedEventV2(DomainEvent):\n    order_id: str\n    customer_phone: Optional[str] = None  # \u2705 Keep old field as optional\n    customer_email: Optional[str] = None  # \u2705 New field is optional\n    customer_contact_info: ContactInfo = None  # \u2705 New structured approach\n\n    event_version: str = \"2.0\"  # \u2705 Version tracking\n\n# OR use event transformation\nclass EventAdapter:\n    def transform(self, old_event: OrderPlacedEvent) -&gt; OrderPlacedEventV2:\n        return OrderPlacedEventV2(\n            order_id=old_event.order_id,\n            customer_phone=old_event.customer_phone,\n            customer_email=None,\n            event_version=\"2.0\"\n        )\n</code></pre>"},{"location":"patterns/event-driven/#when-not-to-use","title":"\ud83d\udeab When NOT to Use","text":""},{"location":"patterns/event-driven/#1-simple-crud-operations","title":"1. Simple CRUD Operations","text":"<p>For straightforward create/read/update/delete operations with no side effects:</p> <pre><code># Event-driven is overkill for simple CRUD\n@app.get(\"/menu/pizzas\")\nasync def get_pizzas(db: Database):\n    # Simple read - no need for events\n    return await db.pizzas.find().to_list(None)\n\n@app.post(\"/customers\")\nasync def create_customer(customer: CreateCustomerDto, db: Database):\n    # Simple creation with no business logic - no need for events\n    return await db.customers.insert_one(customer.dict())\n</code></pre>"},{"location":"patterns/event-driven/#2-transactions-requiring-strong-consistency","title":"2. Transactions Requiring Strong Consistency","text":"<p>When operations must complete together or not at all:</p> <pre><code># Event-driven doesn't guarantee transactional consistency\n# Use Unit of Work pattern instead\n\nasync def transfer_loyalty_points(from_customer: str, to_customer: str, points: int):\n    # \u274c Events won't work - need atomic transaction\n    # If deduct succeeds but add fails, data becomes inconsistent\n\n    # \u2705 Use Unit of Work or database transaction\n    async with self._unit_of_work.begin_transaction():\n        await self._customer_repo.deduct_points_async(from_customer, points)\n        await self._customer_repo.add_points_async(to_customer, points)\n        await self._unit_of_work.commit_async()\n</code></pre>"},{"location":"patterns/event-driven/#3-synchronous-request-response-flows","title":"3. Synchronous Request-Response Flows","text":"<p>When caller needs immediate response from downstream operation:</p> <pre><code># \u274c Event-driven not suitable - caller needs immediate result\nasync def validate_customer_credit(customer_id: str) -&gt; bool:\n    # Caller needs immediate yes/no answer\n    # Can't wait for asynchronous event processing\n\n    # \u2705 Use direct service call instead\n    return await self._credit_service.check_credit_async(customer_id)\n</code></pre>"},{"location":"patterns/event-driven/#4-small-applications-with-simple-workflows","title":"4. Small Applications with Simple Workflows","text":"<p>For small apps without complex workflows or integration needs:</p> <pre><code># Simple pizza menu app with no integrations\n# Event-driven architecture adds unnecessary complexity\n\n# \u2705 Direct service calls are simpler\nclass SimplePizzaService:\n    async def create_order(self, order_data: dict):\n        order = Order(**order_data)\n        await self._db.orders.insert_one(order)\n        return order  # No events needed\n</code></pre>"},{"location":"patterns/event-driven/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ol> <li>Loose Coupling: Events enable components to communicate without knowing about each other</li> <li>Async Processing: Event handlers execute independently and asynchronously</li> <li>Fault Isolation: Failed handlers don't affect core business operations</li> <li>Scalability: Scale event handlers independently based on load</li> <li>Extensibility: Add new handlers without modifying existing code</li> <li>Domain Events: Capture important business occurrences in domain layer</li> <li>Error Handling: Handlers must be resilient with proper error handling</li> <li>Event Design: Keep events small with only essential domain information</li> <li>Testing: Test handlers in isolation with mocked dependencies</li> <li>Use Judiciously: Not suitable for transactional operations or simple CRUD</li> </ol>"},{"location":"patterns/event-driven/#related-patterns","title":"\ud83d\udd17 Related Patterns","text":"<ul> <li>CQRS Pattern - Commands often produce domain events for queries to consume</li> <li>Clean Architecture - Events enable layer decoupling without dependencies</li> <li>Repository Pattern - Events can trigger repository operations in handlers</li> <li>Domain-Driven Design - Domain entities raise events for business occurrences</li> </ul> <p>This pattern guide demonstrates Event-Driven Architecture using Mario's Pizzeria's kitchen workflow and customer communication systems. Events enable loose coupling and reactive behavior across the entire pizza ordering experience. \ud83d\udce1</p>"},{"location":"patterns/event-sourcing/","title":"\ud83c\udfaf Event Sourcing Pattern","text":"<p>Estimated reading time: 35 minutes</p> <p>Event Sourcing is a data storage pattern where state changes are stored as a sequence of immutable events rather than updating data in place. Instead of persisting current state directly, the pattern captures all changes as events that can be replayed to reconstruct state at any point in time, providing complete audit trails, temporal queries, and business intelligence capabilities.</p>"},{"location":"patterns/event-sourcing/#what-why","title":"\ud83d\udca1 What &amp; Why","text":""},{"location":"patterns/event-sourcing/#the-problem-lost-history-with-state-based-persistence","title":"\u274c The Problem: Lost History with State-Based Persistence","text":"<p>Traditional state-based persistence overwrites data, losing the history of how we arrived at the current state:</p> <pre><code># \u274c PROBLEM: Traditional state-based persistence loses history\nclass Order:\n    def __init__(self, order_id: str):\n        self.order_id = order_id\n        self.status = \"pending\"\n        self.total = Decimal(\"0.00\")\n        self.updated_at = datetime.now()\n\nclass OrderRepository:\n    async def save_async(self, order: Order):\n        # Overwrites existing record - history is LOST!\n        await self.db.orders.update_one(\n            {\"order_id\": order.order_id},\n            {\"$set\": {\n                \"status\": order.status,\n                \"total\": order.total,\n                \"updated_at\": order.updated_at\n            }},\n            upsert=True\n        )\n\n# Usage in handler\nasync def confirm_order(order_id: str):\n    order = await repository.get_by_id(order_id)\n    order.status = \"confirmed\"  # Previous status LOST forever!\n    order.total = Decimal(\"45.99\")\n    order.updated_at = datetime.now()\n    await repository.save_async(order)  # Overwrites, no history\n\n# Questions we CANNOT answer:\n# - When was the order placed?\n# - What was the original total before discounts?\n# - Who changed the status and when?\n# - What was the sequence of status changes?\n# - Why was the order modified?\n</code></pre> <p>Problems with State-Based Persistence:</p> <ul> <li>\u274c Lost History: No record of what happened, only current state</li> <li>\u274c No Audit Trail: Cannot prove compliance or answer \"who did what when?\"</li> <li>\u274c No Time Travel: Cannot reconstruct state at any point in the past</li> <li>\u274c No Business Intelligence: Cannot analyze trends or patterns over time</li> <li>\u274c Data Loss: Accidental updates or deletes destroy information permanently</li> <li>\u274c Debugging Nightmares: Cannot replay events to reproduce bugs</li> </ul>"},{"location":"patterns/event-sourcing/#the-solution-event-sourcing-with-immutable-event-log","title":"\u2705 The Solution: Event Sourcing with Immutable Event Log","text":"<p>Event sourcing stores every state change as an immutable event, preserving complete history:</p> <pre><code># \u2705 SOLUTION: Event sourcing preserves complete history\nfrom neuroglia.data.abstractions import AggregateRoot, DomainEvent\nfrom dataclasses import dataclass\nfrom typing import List\n\n# Domain Events - Immutable facts about what happened\n@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    order_id: str\n    customer_id: str\n    items: List[dict]\n    total: Decimal\n    placed_at: datetime\n\n@dataclass\nclass OrderConfirmedEvent(DomainEvent):\n    order_id: str\n    confirmed_by: str\n    confirmed_at: datetime\n\n@dataclass\nclass DiscountAppliedEvent(DomainEvent):\n    order_id: str\n    discount_code: str\n    original_total: Decimal\n    discount_amount: Decimal\n    new_total: Decimal\n    applied_at: datetime\n\n# Event-Sourced Aggregate\nclass Order(AggregateRoot):\n    def __init__(self, order_id: str):\n        super().__init__()\n        self.order_id = order_id\n        self.status = \"pending\"\n        self.total = Decimal(\"0.00\")\n        self.customer_id = None\n        self.items = []\n\n    @staticmethod\n    def place(customer_id: str, items: List[dict]) -&gt; \"Order\":\n        \"\"\"Factory method to create new order\"\"\"\n        order = Order(str(uuid.uuid4()))\n        total = sum(Decimal(str(item[\"price\"])) * item[\"quantity\"] for item in items)\n\n        # Raise event - this is stored forever!\n        order.raise_event(OrderPlacedEvent(\n            order_id=order.order_id,\n            customer_id=customer_id,\n            items=items,\n            total=total,\n            placed_at=datetime.now()\n        ))\n        return order\n\n    def confirm(self, confirmed_by: str):\n        \"\"\"Confirm the order\"\"\"\n        if self.status != \"pending\":\n            raise ValueError(f\"Cannot confirm order in status {self.status}\")\n\n        # Raise event - immutable record!\n        self.raise_event(OrderConfirmedEvent(\n            order_id=self.order_id,\n            confirmed_by=confirmed_by,\n            confirmed_at=datetime.now()\n        ))\n\n    def apply_discount(self, discount_code: str, discount_amount: Decimal):\n        \"\"\"Apply discount to order\"\"\"\n        original_total = self.total\n        new_total = original_total - discount_amount\n\n        # Raise event - preserves original price!\n        self.raise_event(DiscountAppliedEvent(\n            order_id=self.order_id,\n            discount_code=discount_code,\n            original_total=original_total,\n            discount_amount=discount_amount,\n            new_total=new_total,\n            applied_at=datetime.now()\n        ))\n\n    # Event handlers - apply events to update state\n    def on_order_placed(self, event: OrderPlacedEvent):\n        self.customer_id = event.customer_id\n        self.items = event.items\n        self.total = event.total\n\n    def on_order_confirmed(self, event: OrderConfirmedEvent):\n        self.status = \"confirmed\"\n\n    def on_discount_applied(self, event: DiscountAppliedEvent):\n        self.total = event.new_total\n\n# Event Store Repository\nclass EventSourcedOrderRepository:\n    def __init__(self, event_store: IEventStore):\n        self.event_store = event_store\n\n    async def save_async(self, order: Order):\n        \"\"\"Save events, not state!\"\"\"\n        events = order.get_uncommitted_events()\n        await self.event_store.append_async(order.order_id, events)\n        order.mark_events_as_committed()\n\n    async def get_by_id_async(self, order_id: str) -&gt; Order:\n        \"\"\"Reconstruct state from events!\"\"\"\n        events = await self.event_store.get_events_async(order_id)\n        order = Order(order_id)\n\n        # Replay events to rebuild current state\n        for event in events:\n            if isinstance(event, OrderPlacedEvent):\n                order.on_order_placed(event)\n            elif isinstance(event, OrderConfirmedEvent):\n                order.on_order_confirmed(event)\n            elif isinstance(event, DiscountAppliedEvent):\n                order.on_discount_applied(event)\n\n        return order\n\n# Usage - Complete history preserved!\nasync def process_order():\n    # Create and place order\n    order = Order.place(\"customer-123\", [\n        {\"name\": \"Margherita\", \"price\": \"12.99\", \"quantity\": 2}\n    ])\n    await repository.save_async(order)  # Events stored!\n\n    # Confirm order\n    order = await repository.get_by_id_async(order.order_id)\n    order.confirm(\"employee-456\")\n    await repository.save_async(order)  # More events stored!\n\n    # Apply discount\n    order = await repository.get_by_id_async(order.order_id)\n    order.apply_discount(\"WELCOME10\", Decimal(\"2.60\"))\n    await repository.save_async(order)  # Even more events!\n\n    # Now we can answer ALL these questions:\n    # \u2705 When was the order placed? (OrderPlacedEvent.placed_at)\n    # \u2705 What was the original total? (OrderPlacedEvent.total)\n    # \u2705 Who confirmed it? (OrderConfirmedEvent.confirmed_by)\n    # \u2705 What discount was applied? (DiscountAppliedEvent.discount_code)\n    # \u2705 What was the price before discount? (DiscountAppliedEvent.original_total)\n    # \u2705 Complete audit trail for compliance!\n</code></pre> <p>Benefits of Event Sourcing:</p> <ul> <li>\u2705 Complete History: Every change is recorded as an immutable event</li> <li>\u2705 Audit Trail: Know exactly who did what and when for compliance</li> <li>\u2705 Time Travel: Reconstruct state at any point in the past</li> <li>\u2705 Business Intelligence: Analyze trends, patterns, and behaviors over time</li> <li>\u2705 Debugging: Replay events to reproduce and fix bugs</li> <li>\u2705 Event-Driven Integration: Events naturally integrate with other systems</li> <li>\u2705 Projections: Build specialized read models from event streams</li> </ul>"},{"location":"patterns/event-sourcing/#pattern-intent","title":"\ud83c\udfaf Pattern Intent","text":"<p>Replace traditional state-based persistence with an append-only event log that serves as the authoritative source of truth. Enable system reconstruction, audit trails, temporal queries, and business analytics through immutable event sequences while maintaining data integrity and providing deep insights into system behavior over time.</p>"},{"location":"patterns/event-sourcing/#pattern-structure","title":"\ud83c\udfd7\ufe0f Pattern Structure","text":"<pre><code>flowchart TD\n    subgraph \"\ud83c\udfaf Event Sourcing Core\"\n        A[\"\ud83d\udcdd Domain Events&lt;br/&gt;Immutable Facts\"]\n        B[\"\ud83d\udcda Event Store&lt;br/&gt;Append-Only Log\"]\n        C[\"\ud83d\udd04 Event Stream&lt;br/&gt;Ordered Sequence\"]\n        D[\"\ud83c\udfd7\ufe0f Aggregate Root&lt;br/&gt;Business Logic\"]\n    end\n\n    subgraph \"\ud83d\udcca State Management\"\n        E[\"\u26a1 Current State&lt;br/&gt;Computed from Events\"]\n        F[\"\ud83d\udd70\ufe0f Historical State&lt;br/&gt;Point-in-Time Queries\"]\n        G[\"\ud83d\udcc8 Event Replay&lt;br/&gt;State Reconstruction\"]\n        H[\"\ud83d\udcf8 Snapshots&lt;br/&gt;Performance Optimization\"]\n    end\n\n    subgraph \"\ud83d\udccb Read Models\"\n        I[\"\ud83d\udcca Projections&lt;br/&gt;Optimized Views\"]\n        J[\"\ud83d\udd0d Query Models&lt;br/&gt;Specialized Indexes\"]\n        K[\"\ud83d\udcc8 Analytics Views&lt;br/&gt;Business Intelligence\"]\n        L[\"\ud83c\udfaf Denormalized Data&lt;br/&gt;Fast Queries\"]\n    end\n\n    A --&gt; B\n    B --&gt; C\n    C --&gt; D\n    D --&gt; E\n\n    C --&gt; F\n    B --&gt; G\n    E --&gt; H\n\n    C --&gt; I\n    I --&gt; J\n    I --&gt; K\n    I --&gt; L\n\n    style B fill:#e1f5fe,stroke:#0277bd,stroke-width:3px\n    style C fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\n    style E fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px\n\n    classDef projections fill:#fff3e0,stroke:#f57c00,stroke-width:2px\n    class I,J,K,L projections\n\n    classDef state fill:#fce4ec,stroke:#ad1457,stroke-width:2px\n    class E,F,G,H state</code></pre>"},{"location":"patterns/event-sourcing/#pattern-implementation","title":"\ud83c\udf55 Pattern Implementation","text":""},{"location":"patterns/event-sourcing/#core-event-sourcing-components","title":"Core Event Sourcing Components","text":"<pre><code>from neuroglia.data.abstractions import AggregateRoot, DomainEvent\nfrom neuroglia.eventing import event_handler\nfrom multipledispatch import dispatch\nfrom dataclasses import dataclass\nfrom decimal import Decimal\nfrom datetime import datetime\nfrom typing import List, Optional, Dict, Any\nimport uuid\n\n# Domain Events - Immutable Facts\n@dataclass\nclass PizzaOrderPlacedEvent(DomainEvent):\n    \"\"\"Event representing a pizza order being placed\"\"\"\n    order_id: str\n    customer_id: str\n    items: List[Dict[str, Any]]\n    total_amount: Decimal\n    placed_at: datetime\n\n@dataclass\nclass PizzaOrderConfirmedEvent(DomainEvent):\n    \"\"\"Event representing order confirmation\"\"\"\n    order_id: str\n    estimated_delivery_time: datetime\n    kitchen_notes: str\n    confirmed_at: datetime\n\n@dataclass\nclass PaymentProcessedEvent(DomainEvent):\n    \"\"\"Event representing successful payment\"\"\"\n    order_id: str\n    payment_method: str\n    amount: Decimal\n    transaction_id: str\n    processed_at: datetime\n\n@dataclass\nclass OrderStatusChangedEvent(DomainEvent):\n    \"\"\"Event representing order status changes\"\"\"\n    order_id: str\n    previous_status: str\n    new_status: str\n    changed_at: datetime\n    reason: Optional[str] = None\n\n# Aggregate Root with Event Sourcing\nclass PizzaOrder(AggregateRoot[str]):\n    \"\"\"Pizza order aggregate using event sourcing\"\"\"\n\n    def __init__(self, order_id: str = None):\n        super().__init__(order_id or str(uuid.uuid4()))\n\n        # Current state computed from events\n        self._customer_id = \"\"\n        self._items = []\n        self._total_amount = Decimal('0.00')\n        self._status = \"PENDING\"\n        self._placed_at = None\n        self._estimated_delivery = None\n        self._payment_status = \"UNPAID\"\n        self._kitchen_notes = \"\"\n\n    # Business Logic Methods - Produce Events\n    def place_order(self, customer_id: str, items: List[Dict[str, Any]], total_amount: Decimal):\n        \"\"\"Place a new pizza order - produces PizzaOrderPlacedEvent\"\"\"\n\n        # Business rule validation\n        if not items:\n            raise ValueError(\"Order must contain at least one item\")\n        if total_amount &lt;= 0:\n            raise ValueError(\"Order total must be positive\")\n\n        # Create and register domain event\n        event = PizzaOrderPlacedEvent(\n            order_id=self.id(),\n            customer_id=customer_id,\n            items=items,\n            total_amount=total_amount,\n            placed_at=datetime.utcnow()\n        )\n\n        # Apply event to update state and register for persistence\n        self.state.on(self.register_event(event))\n\n    def confirm_order(self, estimated_delivery_time: datetime, kitchen_notes: str = \"\"):\n        \"\"\"Confirm order - produces PizzaOrderConfirmedEvent\"\"\"\n\n        # Business rule validation\n        if self._status != \"PENDING\":\n            raise ValueError(f\"Cannot confirm order in status: {self._status}\")\n\n        event = PizzaOrderConfirmedEvent(\n            order_id=self.id(),\n            estimated_delivery_time=estimated_delivery_time,\n            kitchen_notes=kitchen_notes,\n            confirmed_at=datetime.utcnow()\n        )\n\n        self.state.on(self.register_event(event))\n\n    def process_payment(self, payment_method: str, transaction_id: str):\n        \"\"\"Process payment - produces PaymentProcessedEvent\"\"\"\n\n        if self._payment_status == \"PAID\":\n            raise ValueError(\"Order is already paid\")\n\n        event = PaymentProcessedEvent(\n            order_id=self.id(),\n            payment_method=payment_method,\n            amount=self._total_amount,\n            transaction_id=transaction_id,\n            processed_at=datetime.utcnow()\n        )\n\n        self.state.on(self.register_event(event))\n\n    def change_status(self, new_status: str, reason: str = None):\n        \"\"\"Change order status - produces OrderStatusChangedEvent\"\"\"\n\n        if self._status == new_status:\n            return  # No change needed\n\n        event = OrderStatusChangedEvent(\n            order_id=self.id(),\n            previous_status=self._status,\n            new_status=new_status,\n            changed_at=datetime.utcnow(),\n            reason=reason\n        )\n\n        self.state.on(self.register_event(event))\n\n    # State Reconstruction from Events using @dispatch\n    @dispatch(PizzaOrderPlacedEvent)\n    def state_manager(self, event: PizzaOrderPlacedEvent):\n        \"\"\"Apply order placed event to reconstruct state\"\"\"\n        self._customer_id = event.customer_id\n        self._items = event.items.copy()\n        self._total_amount = event.total_amount\n        self._status = \"PENDING\"\n        self._placed_at = event.placed_at\n\n    @dispatch(PizzaOrderConfirmedEvent)\n    def state_manager(self, event: PizzaOrderConfirmedEvent):\n        \"\"\"Apply order confirmed event to reconstruct state\"\"\"\n        self._status = \"CONFIRMED\"\n        self._estimated_delivery = event.estimated_delivery_time\n        self._kitchen_notes = event.kitchen_notes\n\n    @dispatch(PaymentProcessedEvent)\n    def state_manager(self, event: PaymentProcessedEvent):\n        \"\"\"Apply payment processed event to reconstruct state\"\"\"\n        self._payment_status = \"PAID\"\n        # Automatically move to cooking if order is confirmed and paid\n        if self._status == \"CONFIRMED\":\n            self._status = \"COOKING\"\n\n    @dispatch(OrderStatusChangedEvent)\n    def state_manager(self, event: OrderStatusChangedEvent):\n        \"\"\"Apply status change event to reconstruct state\"\"\"\n        self._status = event.new_status\n\n    # Property Accessors for Current State\n    @property\n    def customer_id(self) -&gt; str:\n        return self._customer_id\n\n    @property\n    def items(self) -&gt; List[Dict[str, Any]]:\n        return self._items.copy()\n\n    @property\n    def total_amount(self) -&gt; Decimal:\n        return self._total_amount\n\n    @property\n    def status(self) -&gt; str:\n        return self._status\n\n    @property\n    def payment_status(self) -&gt; str:\n        return self._payment_status\n\n    @property\n    def placed_at(self) -&gt; Optional[datetime]:\n        return self._placed_at\n\n    @property\n    def estimated_delivery(self) -&gt; Optional[datetime]:\n        return self._estimated_delivery\n</code></pre>"},{"location":"patterns/event-sourcing/#event-store-configuration","title":"Event Store Configuration","text":"<pre><code>from neuroglia.data.infrastructure.event_sourcing.event_store import ESEventStore\nfrom neuroglia.data.infrastructure.event_sourcing.abstractions import EventStoreOptions\nfrom neuroglia.hosting.web import WebApplicationBuilder\n\ndef configure_event_store(builder: WebApplicationBuilder):\n    \"\"\"Configure EventStoreDB for event sourcing\"\"\"\n\n    # Event store configuration\n    database_name = \"mario_pizzeria\"\n    consumer_group = \"pizzeria-api-v1\"\n\n    ESEventStore.configure(\n        builder,\n        EventStoreOptions(\n            database_name=database_name,\n            consumer_group=consumer_group,\n            connection_string=\"esdb://localhost:2113?tls=false\",\n            credentials={\"username\": \"admin\", \"password\": \"changeit\"}\n        )\n    )\n\n    # Configure event sourcing repository for write model\n    EventSourcingRepository.configure(builder, PizzaOrder, str)\n\n    return builder\n\n# Repository Pattern for Event-Sourced Aggregates\nclass EventSourcingRepository:\n    \"\"\"Repository for event-sourced aggregates\"\"\"\n\n    def __init__(self, event_store: EventStore, aggregator: Aggregator):\n        self.event_store = event_store\n        self.aggregator = aggregator\n\n    async def save_async(self, aggregate: PizzaOrder) -&gt; PizzaOrder:\n        \"\"\"Save aggregate events to event store\"\"\"\n\n        # Get uncommitted events from aggregate\n        events = aggregate.get_uncommitted_events()\n        if not events:\n            return aggregate\n\n        # Persist events to event store\n        stream_id = f\"PizzaOrder-{aggregate.id()}\"\n        await self.event_store.append_async(\n            stream_id=stream_id,\n            events=events,\n            expected_version=aggregate.version\n        )\n\n        # Mark events as committed\n        aggregate.mark_events_as_committed()\n\n        return aggregate\n\n    async def get_by_id_async(self, order_id: str) -&gt; Optional[PizzaOrder]:\n        \"\"\"Load aggregate by ID from event store\"\"\"\n\n        stream_id = f\"PizzaOrder-{order_id}\"\n\n        # Read events from event store\n        events = await self.event_store.read_async(\n            stream_id=stream_id,\n            direction=StreamReadDirection.FORWARDS\n        )\n\n        if not events:\n            return None\n\n        # Reconstruct aggregate from events\n        aggregate = PizzaOrder(order_id)\n        for event_record in events:\n            aggregate.state_manager(event_record.data)\n            aggregate.version = event_record.stream_revision\n\n        return aggregate\n</code></pre>"},{"location":"patterns/event-sourcing/#event-driven-projections-pattern","title":"Event-Driven Projections Pattern","text":"<pre><code>from neuroglia.eventing import event_handler\nfrom neuroglia.data.abstractions import Repository\n\n@dataclass\nclass PizzaOrderProjection:\n    \"\"\"Optimized read model for pizza order queries\"\"\"\n\n    id: str\n    customer_id: str\n    customer_name: str  # Denormalized for fast queries\n    customer_email: str  # Denormalized for fast queries\n    item_count: int\n    total_amount: Decimal\n    status: str\n    payment_status: str\n    placed_at: datetime\n    estimated_delivery: Optional[datetime]\n    last_updated: datetime\n\n    # Analytics fields computed from events\n    time_to_confirmation: Optional[int] = None  # seconds\n    time_to_payment: Optional[int] = None  # seconds\n\nclass PizzaOrderProjectionHandler:\n    \"\"\"Handles domain events to update read model projections\"\"\"\n\n    def __init__(self, read_repository: Repository[PizzaOrderProjection, str]):\n        self.read_repository = read_repository\n\n    @event_handler(PizzaOrderPlacedEvent)\n    async def handle_order_placed(self, event: PizzaOrderPlacedEvent):\n        \"\"\"Create read model projection when order is placed\"\"\"\n\n        # Fetch customer details for denormalization\n        customer = await self._get_customer_details(event.customer_id)\n\n        projection = PizzaOrderProjection(\n            id=event.order_id,\n            customer_id=event.customer_id,\n            customer_name=customer.name if customer else \"Unknown\",\n            customer_email=customer.email if customer else \"\",\n            item_count=len(event.items),\n            total_amount=event.total_amount,\n            status=\"PENDING\",\n            payment_status=\"UNPAID\",\n            placed_at=event.placed_at,\n            estimated_delivery=None,\n            last_updated=event.placed_at\n        )\n\n        await self.read_repository.add_async(projection)\n\n    @event_handler(PizzaOrderConfirmedEvent)\n    async def handle_order_confirmed(self, event: PizzaOrderConfirmedEvent):\n        \"\"\"Update projection when order is confirmed\"\"\"\n\n        projection = await self.read_repository.get_by_id_async(event.order_id)\n        if projection:\n            # Calculate time to confirmation\n            time_to_confirmation = int((event.confirmed_at - projection.placed_at).total_seconds())\n\n            projection.status = \"CONFIRMED\"\n            projection.estimated_delivery = event.estimated_delivery_time\n            projection.time_to_confirmation = time_to_confirmation\n            projection.last_updated = event.confirmed_at\n\n            await self.read_repository.update_async(projection)\n\n    @event_handler(PaymentProcessedEvent)\n    async def handle_payment_processed(self, event: PaymentProcessedEvent):\n        \"\"\"Update projection when payment is processed\"\"\"\n\n        projection = await self.read_repository.get_by_id_async(event.order_id)\n        if projection:\n            # Calculate time to payment\n            time_to_payment = int((event.processed_at - projection.placed_at).total_seconds())\n\n            projection.payment_status = \"PAID\"\n            projection.time_to_payment = time_to_payment\n            projection.last_updated = event.processed_at\n\n            await self.read_repository.update_async(projection)\n\n    @event_handler(OrderStatusChangedEvent)\n    async def handle_status_changed(self, event: OrderStatusChangedEvent):\n        \"\"\"Update projection when order status changes\"\"\"\n\n        projection = await self.read_repository.get_by_id_async(event.order_id)\n        if projection:\n            projection.status = event.new_status\n            projection.last_updated = event.changed_at\n\n            await self.read_repository.update_async(projection)\n\n    async def _get_customer_details(self, customer_id: str) -&gt; Optional[Any]:\n        \"\"\"Fetch customer details for denormalization\"\"\"\n        # Implementation would fetch from customer service/repository\n        return None\n</code></pre>"},{"location":"patterns/event-sourcing/#temporal-queries-pattern","title":"Temporal Queries Pattern","text":"<pre><code>class TemporalQueryService:\n    \"\"\"Service for temporal queries on event-sourced aggregates\"\"\"\n\n    def __init__(self, event_store: EventStore, aggregator: Aggregator):\n        self.event_store = event_store\n        self.aggregator = aggregator\n\n    async def get_order_status_at_time(self, order_id: str, as_of_time: datetime) -&gt; Optional[str]:\n        \"\"\"Get order status as it was at a specific point in time\"\"\"\n\n        stream_id = f\"PizzaOrder-{order_id}\"\n\n        # Read events up to the specified time\n        events = await self.event_store.read_async(\n            stream_id=stream_id,\n            direction=StreamReadDirection.FORWARDS,\n            from_position=0,\n            to_time=as_of_time\n        )\n\n        if not events:\n            return None\n\n        # Reconstruct state at that point in time\n        order = PizzaOrder(order_id)\n        for event_record in events:\n            order.state_manager(event_record.data)\n\n        return order.status\n\n    async def get_order_timeline(self, order_id: str) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get complete timeline of order changes\"\"\"\n\n        stream_id = f\"PizzaOrder-{order_id}\"\n\n        events = await self.event_store.read_async(\n            stream_id=stream_id,\n            direction=StreamReadDirection.FORWARDS\n        )\n\n        timeline = []\n        for event_record in events:\n            event_data = event_record.data\n\n            timeline_entry = {\n                'timestamp': event_record.created_at,\n                'event_type': type(event_data).__name__,\n                'description': self._get_event_description(event_data),\n                'details': self._extract_event_details(event_data)\n            }\n            timeline.append(timeline_entry)\n\n        return timeline\n\n    def _get_event_description(self, event: DomainEvent) -&gt; str:\n        \"\"\"Generate human-readable description for events\"\"\"\n        descriptions = {\n            'PizzaOrderPlacedEvent': 'Order placed by customer',\n            'PizzaOrderConfirmedEvent': 'Order confirmed by restaurant',\n            'PaymentProcessedEvent': 'Payment processed successfully',\n            'OrderStatusChangedEvent': f'Status changed to {event.new_status}'\n        }\n        return descriptions.get(type(event).__name__, 'Event occurred')\n\n    def _extract_event_details(self, event: DomainEvent) -&gt; Dict[str, Any]:\n        \"\"\"Extract relevant details from events for timeline\"\"\"\n        if isinstance(event, PizzaOrderPlacedEvent):\n            return {\n                'customer_id': event.customer_id,\n                'item_count': len(event.items),\n                'total_amount': float(event.total_amount)\n            }\n        elif isinstance(event, PaymentProcessedEvent):\n            return {\n                'payment_method': event.payment_method,\n                'transaction_id': event.transaction_id,\n                'amount': float(event.amount)\n            }\n        elif isinstance(event, OrderStatusChangedEvent):\n            return {\n                'previous_status': event.previous_status,\n                'new_status': event.new_status,\n                'reason': event.reason\n            }\n\n        return {}\n</code></pre>"},{"location":"patterns/event-sourcing/#business-intelligence-pattern","title":"Business Intelligence Pattern","text":"<pre><code>class PizzeriaAnalyticsService:\n    \"\"\"Service for analyzing business patterns from events\"\"\"\n\n    def __init__(self, event_store: EventStore):\n        self.event_store = event_store\n\n    async def get_order_analytics(self, from_date: datetime, to_date: datetime) -&gt; Dict[str, Any]:\n        \"\"\"Analyze order patterns over time\"\"\"\n\n        # Query all order events in date range\n        placed_events = await self.event_store.get_events_by_type_async(\n            PizzaOrderPlacedEvent,\n            from_date=from_date,\n            to_date=to_date\n        )\n\n        confirmed_events = await self.event_store.get_events_by_type_async(\n            PizzaOrderConfirmedEvent,\n            from_date=from_date,\n            to_date=to_date\n        )\n\n        if not placed_events:\n            return {\"message\": \"No orders found in date range\"}\n\n        # Calculate analytics\n        total_orders = len(placed_events)\n        total_revenue = sum(e.total_amount for e in placed_events)\n        confirmed_orders = len(confirmed_events)\n        confirmation_rate = (confirmed_orders / total_orders) * 100 if total_orders &gt; 0 else 0\n\n        # Analyze order sizes and items\n        all_items = []\n        for event in placed_events:\n            all_items.extend(event.items)\n\n        average_order_value = total_revenue / total_orders if total_orders &gt; 0 else 0\n\n        return {\n            \"period\": {\"from\": from_date.isoformat(), \"to\": to_date.isoformat()},\n            \"total_orders\": total_orders,\n            \"confirmed_orders\": confirmed_orders,\n            \"confirmation_rate\": round(confirmation_rate, 2),\n            \"total_revenue\": float(total_revenue),\n            \"average_order_value\": float(average_order_value),\n            \"total_items_sold\": len(all_items),\n            \"popular_items\": self._analyze_popular_items(all_items),\n            \"daily_breakdown\": self._calculate_daily_breakdown(placed_events)\n        }\n\n    def _analyze_popular_items(self, items: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:\n        \"\"\"Analyze most popular items\"\"\"\n        item_counts = {}\n\n        for item in items:\n            item_name = item.get('name', 'Unknown')\n            item_counts[item_name] = item_counts.get(item_name, 0) + item.get('quantity', 1)\n\n        # Sort by popularity\n        popular_items = sorted(item_counts.items(), key=lambda x: x[1], reverse=True)\n\n        return [\n            {\"item_name\": name, \"total_sold\": count}\n            for name, count in popular_items[:10]  # Top 10\n        ]\n\n    def _calculate_daily_breakdown(self, events: List[PizzaOrderPlacedEvent]) -&gt; List[Dict[str, Any]]:\n        \"\"\"Calculate daily order breakdown\"\"\"\n        daily_data = {}\n\n        for event in events:\n            day_key = event.placed_at.date().isoformat()\n            if day_key not in daily_data:\n                daily_data[day_key] = {\"count\": 0, \"revenue\": Decimal('0.00')}\n\n            daily_data[day_key][\"count\"] += 1\n            daily_data[day_key][\"revenue\"] += event.total_amount\n\n        return [\n            {\n                \"date\": date,\n                \"order_count\": data[\"count\"],\n                \"daily_revenue\": float(data[\"revenue\"])\n            }\n            for date, data in sorted(daily_data.items())\n        ]\n</code></pre>"},{"location":"patterns/event-sourcing/#testing-patterns","title":"\ud83e\uddea Testing Patterns","text":""},{"location":"patterns/event-sourcing/#aggregate-testing-pattern","title":"Aggregate Testing Pattern","text":"<pre><code>import pytest\nfrom decimal import Decimal\nfrom datetime import datetime, timedelta\n\nclass TestPizzaOrderAggregate:\n    \"\"\"Unit tests for PizzaOrder aggregate using event sourcing\"\"\"\n\n    def test_place_order_raises_correct_event(self):\n        \"\"\"Test that placing an order raises the correct event\"\"\"\n        order = PizzaOrder()\n        customer_id = \"customer-123\"\n        items = [{\"name\": \"Margherita\", \"quantity\": 2, \"price\": 12.50}]\n        total = Decimal(\"25.00\")\n\n        order.place_order(customer_id, items, total)\n\n        events = order.get_uncommitted_events()\n\n        assert len(events) == 1\n        assert isinstance(events[0], PizzaOrderPlacedEvent)\n        assert events[0].customer_id == customer_id\n        assert events[0].total_amount == total\n        assert order.status == \"PENDING\"\n\n    def test_confirm_order_updates_status_and_raises_event(self):\n        \"\"\"Test order confirmation produces correct event and state\"\"\"\n        order = self._create_placed_order()\n\n        estimated_delivery = datetime.utcnow() + timedelta(minutes=30)\n        kitchen_notes = \"Extra cheese\"\n\n        order.confirm_order(estimated_delivery, kitchen_notes)\n\n        # Check event was raised\n        events = order.get_uncommitted_events()\n        confirm_events = [e for e in events if isinstance(e, PizzaOrderConfirmedEvent)]\n\n        assert len(confirm_events) == 1\n        assert confirm_events[0].estimated_delivery_time == estimated_delivery\n        assert confirm_events[0].kitchen_notes == kitchen_notes\n\n        # Check state was updated\n        assert order.status == \"CONFIRMED\"\n        assert order.estimated_delivery == estimated_delivery\n\n    def test_payment_processing_updates_payment_status(self):\n        \"\"\"Test payment processing updates status correctly\"\"\"\n        order = self._create_confirmed_order()\n\n        payment_method = \"credit_card\"\n        transaction_id = \"txn-123456\"\n\n        order.process_payment(payment_method, transaction_id)\n\n        # Check event was raised\n        events = order.get_uncommitted_events()\n        payment_events = [e for e in events if isinstance(e, PaymentProcessedEvent)]\n\n        assert len(payment_events) == 1\n        assert payment_events[0].payment_method == payment_method\n        assert payment_events[0].transaction_id == transaction_id\n\n        # Check state updates\n        assert order.payment_status == \"PAID\"\n        assert order.status == \"COOKING\"  # Auto-transition to cooking\n\n    def test_state_reconstruction_from_events(self):\n        \"\"\"Test that aggregate state can be reconstructed from events\"\"\"\n        order = PizzaOrder(\"test-order-123\")\n\n        # Create events to simulate event store loading\n        placed_event = PizzaOrderPlacedEvent(\n            order_id=\"test-order-123\",\n            customer_id=\"customer-456\",\n            items=[{\"name\": \"Pepperoni\", \"quantity\": 1}],\n            total_amount=Decimal(\"15.00\"),\n            placed_at=datetime.utcnow()\n        )\n\n        confirmed_event = PizzaOrderConfirmedEvent(\n            order_id=\"test-order-123\",\n            estimated_delivery_time=datetime.utcnow() + timedelta(minutes=25),\n            kitchen_notes=\"No onions\",\n            confirmed_at=datetime.utcnow()\n        )\n\n        # Apply events to reconstruct state\n        order.state_manager(placed_event)\n        order.state_manager(confirmed_event)\n\n        # Verify state reconstruction\n        assert order.customer_id == \"customer-456\"\n        assert order.total_amount == Decimal(\"15.00\")\n        assert order.status == \"CONFIRMED\"\n        assert len(order.items) == 1\n\n    def test_business_rule_validation(self):\n        \"\"\"Test business rule validation prevents invalid operations\"\"\"\n        order = PizzaOrder()\n\n        # Test empty items validation\n        with pytest.raises(ValueError, match=\"Order must contain at least one item\"):\n            order.place_order(\"customer-123\", [], Decimal(\"0.00\"))\n\n        # Test negative total validation\n        with pytest.raises(ValueError, match=\"Order total must be positive\"):\n            order.place_order(\"customer-123\", [{\"name\": \"Pizza\"}], Decimal(\"-10.00\"))\n\n        # Test confirmation of non-pending order\n        order = self._create_placed_order()\n        order.change_status(\"DELIVERED\")  # Change to delivered status\n\n        with pytest.raises(ValueError, match=\"Cannot confirm order in status: DELIVERED\"):\n            order.confirm_order(datetime.utcnow(), \"test\")\n\n    def _create_placed_order(self) -&gt; PizzaOrder:\n        \"\"\"Helper to create a placed order\"\"\"\n        order = PizzaOrder()\n        order.place_order(\n            \"customer-123\",\n            [{\"name\": \"Margherita\", \"quantity\": 1, \"price\": 12.50}],\n            Decimal(\"12.50\")\n        )\n        order.mark_events_as_committed()  # Clear events for clean testing\n        return order\n\n    def _create_confirmed_order(self) -&gt; PizzaOrder:\n        \"\"\"Helper to create a confirmed order\"\"\"\n        order = self._create_placed_order()\n        order.confirm_order(datetime.utcnow() + timedelta(minutes=30), \"Test order\")\n        order.mark_events_as_committed()\n        return order\n\nclass TestEventSourcingIntegration:\n    \"\"\"Integration tests for event sourcing workflow\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_complete_aggregate_lifecycle(self, event_store_repository):\n        \"\"\"Test complete aggregate lifecycle with event store persistence\"\"\"\n\n        # Create and place order\n        order = PizzaOrder()\n        order.place_order(\n            \"customer-integration-test\",\n            [{\"name\": \"Integration Pizza\", \"quantity\": 1, \"price\": 20.00}],\n            Decimal(\"20.00\")\n        )\n\n        # Save to event store\n        saved_order = await event_store_repository.save_async(order)\n        assert saved_order.version &gt; 0\n\n        # Load from event store\n        loaded_order = await event_store_repository.get_by_id_async(saved_order.id())\n        assert loaded_order is not None\n        assert loaded_order.customer_id == \"customer-integration-test\"\n        assert loaded_order.total_amount == Decimal(\"20.00\")\n        assert loaded_order.status == \"PENDING\"\n\n        # Modify and save again\n        loaded_order.confirm_order(datetime.utcnow() + timedelta(minutes=35), \"Integration test\")\n        updated_order = await event_store_repository.save_async(loaded_order)\n\n        # Verify persistence of changes\n        final_order = await event_store_repository.get_by_id_async(updated_order.id())\n        assert final_order.status == \"CONFIRMED\"\n        assert final_order.estimated_delivery is not None\n</code></pre>"},{"location":"patterns/event-sourcing/#framework-integration","title":"\ud83d\ude80 Framework Integration","text":""},{"location":"patterns/event-sourcing/#service-registration-pattern","title":"Service Registration Pattern","text":"<pre><code>from neuroglia.hosting import WebApplicationBuilder\nfrom neuroglia.data.infrastructure.event_sourcing import EventSourcingRepository\n\ndef configure_event_sourcing_services(builder: WebApplicationBuilder):\n    \"\"\"Configure event sourcing services with dependency injection\"\"\"\n\n    # Configure event store\n    configure_event_store(builder)\n\n    # Register event-sourced aggregate repositories\n    builder.services.add_scoped(EventSourcingRepository[PizzaOrder, str])\n\n    # Register event handlers for projections\n    builder.services.add_scoped(PizzaOrderProjectionHandler)\n\n    # Register query services\n    builder.services.add_scoped(TemporalQueryService)\n    builder.services.add_scoped(PizzeriaAnalyticsService)\n\n    # Register read model repositories for projections\n    builder.services.add_scoped(Repository[PizzaOrderProjection, str])\n\n# Application startup with event sourcing\ndef create_event_sourced_application():\n    \"\"\"Create application with event sourcing support\"\"\"\n    builder = WebApplicationBuilder()\n\n    # Configure event sourcing\n    configure_event_sourcing_services(builder)\n\n    # Build application\n    app = builder.build()\n\n    return app\n</code></pre>"},{"location":"patterns/event-sourcing/#pattern-benefits","title":"\ud83c\udfaf Pattern Benefits","text":""},{"location":"patterns/event-sourcing/#advantages","title":"Advantages","text":"<ul> <li>Complete Audit Trail: Every state change is captured as an immutable event</li> <li>Temporal Queries: Query system state at any point in time</li> <li>Business Intelligence: Rich analytics from event stream analysis</li> <li>Event Replay: Reconstruct state and debug issues through event replay</li> <li>Scalability: Events can be replayed to create specialized read models</li> <li>Integration: Events provide natural integration points between bounded contexts</li> </ul>"},{"location":"patterns/event-sourcing/#when-to-use","title":"When to Use","text":"<ul> <li>Systems requiring complete audit trails and compliance</li> <li>Applications needing temporal queries and historical analysis</li> <li>Business domains with complex state transitions</li> <li>Systems requiring sophisticated business intelligence and reporting</li> <li>Applications with high read/write ratio where specialized read models provide value</li> <li>Domains where understanding \"how we got here\" is as important as current state</li> </ul>"},{"location":"patterns/event-sourcing/#when-not-to-use","title":"When Not to Use","text":"<ul> <li>Simple CRUD applications with minimal business logic</li> <li>Systems with very high write volumes where event storage becomes a bottleneck</li> <li>Applications where eventual consistency is not acceptable</li> <li>Teams lacking experience with event-driven architecture and eventual consistency</li> <li>Systems where the complexity of event sourcing outweighs the benefits</li> </ul>"},{"location":"patterns/event-sourcing/#common-mistakes","title":"\u26a0\ufe0f Common Mistakes","text":""},{"location":"patterns/event-sourcing/#1-storing-mutable-state-instead-of-events","title":"1. Storing Mutable State Instead of Events","text":"<pre><code># \u274c WRONG: Storing state snapshots, not events\nclass OrderRepository:\n    async def save_async(self, order: Order):\n        # This is NOT event sourcing - it's just state persistence!\n        await self.event_store.save_state(order.order_id, {\n            \"status\": order.status,\n            \"total\": order.total,\n            \"items\": order.items\n        })\n\n# \u2705 CORRECT: Store immutable events\nclass OrderRepository:\n    async def save_async(self, order: Order):\n        # Store the events that describe what happened\n        events = order.get_uncommitted_events()\n        await self.event_store.append_async(order.order_id, events)\n        order.mark_events_as_committed()\n</code></pre>"},{"location":"patterns/event-sourcing/#2-large-unfocused-events-fat-events","title":"2. Large, Unfocused Events (Fat Events)","text":"<pre><code># \u274c WRONG: One massive event with everything\n@dataclass\nclass OrderChangedEvent(DomainEvent):\n    order_id: str\n    customer_id: str\n    items: List[dict]\n    status: str\n    payment_method: str\n    delivery_address: dict\n    discount_code: str\n    total: Decimal\n    notes: str\n    # What actually changed??? Who knows!\n\n# \u2705 CORRECT: Focused, specific events\n@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    order_id: str\n    customer_id: str\n    items: List[dict]\n    total: Decimal\n\n@dataclass\nclass DeliveryAddressChangedEvent(DomainEvent):\n    order_id: str\n    old_address: dict\n    new_address: dict\n\n@dataclass\nclass DiscountAppliedEvent(DomainEvent):\n    order_id: str\n    discount_code: str\n    discount_amount: Decimal\n</code></pre>"},{"location":"patterns/event-sourcing/#3-not-versioning-events","title":"3. Not Versioning Events","text":"<pre><code># \u274c WRONG: Changing event structure without versioning\n@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    order_id: str\n    customer_id: str\n    items: List[dict]\n    # Later, someone adds a field - breaks old events!\n    customer_email: str  # New field breaks event replay!\n\n# \u2705 CORRECT: Version events properly\n@dataclass\nclass OrderPlacedEventV1(DomainEvent):\n    version: int = 1\n    order_id: str\n    customer_id: str\n    items: List[dict]\n\n@dataclass\nclass OrderPlacedEventV2(DomainEvent):\n    version: int = 2\n    order_id: str\n    customer_id: str\n    customer_email: str  # New field in V2\n    items: List[dict]\n\n# Event upcasting for old events\nclass EventUpcaster:\n    def upcast(self, event: DomainEvent) -&gt; DomainEvent:\n        if isinstance(event, OrderPlacedEventV1):\n            # Convert V1 to V2\n            return OrderPlacedEventV2(\n                order_id=event.order_id,\n                customer_id=event.customer_id,\n                customer_email=\"unknown@example.com\",  # Default for old events\n                items=event.items\n            )\n        return event\n</code></pre>"},{"location":"patterns/event-sourcing/#4-rebuilding-state-from-events-every-time-no-snapshots","title":"4. Rebuilding State from Events Every Time (No Snapshots)","text":"<pre><code># \u274c WRONG: Always replaying ALL events (slow for old aggregates)\nclass OrderRepository:\n    async def get_by_id_async(self, order_id: str) -&gt; Order:\n        # If order has 10,000 events, this is SLOW!\n        events = await self.event_store.get_events_async(order_id)\n        order = Order(order_id)\n        for event in events:  # Replaying 10,000 events every time!\n            order.apply(event)\n        return order\n\n# \u2705 CORRECT: Use snapshots for performance\nclass OrderRepository:\n    async def get_by_id_async(self, order_id: str) -&gt; Order:\n        # Try to load snapshot first\n        snapshot = await self.snapshot_store.get_snapshot_async(order_id)\n\n        if snapshot:\n            order = snapshot.aggregate\n            # Only replay events AFTER the snapshot\n            events = await self.event_store.get_events_async(\n                order_id,\n                from_version=snapshot.version\n            )\n        else:\n            order = Order(order_id)\n            # No snapshot, replay all events\n            events = await self.event_store.get_events_async(order_id)\n\n        for event in events:\n            order.apply(event)\n\n        return order\n\n    async def save_async(self, order: Order):\n        events = order.get_uncommitted_events()\n        await self.event_store.append_async(order.order_id, events)\n\n        # Create snapshot every 100 events\n        if order.version % 100 == 0:\n            await self.snapshot_store.save_snapshot_async(order)\n\n        order.mark_events_as_committed()\n</code></pre>"},{"location":"patterns/event-sourcing/#5-not-handling-event-store-failures","title":"5. Not Handling Event Store Failures","text":"<pre><code># \u274c WRONG: No error handling for event persistence\nasync def handle_async(self, command: PlaceOrderCommand):\n    order = Order.place(command.customer_id, command.items)\n    await self.repository.save_async(order)  # What if this fails?\n    return self.created(order)\n\n# \u2705 CORRECT: Handle event store failures gracefully\nasync def handle_async(self, command: PlaceOrderCommand):\n    try:\n        order = Order.place(command.customer_id, command.items)\n        await self.repository.save_async(order)\n        return self.created(order)\n\n    except EventStoreConnectionError as ex:\n        logger.error(f\"Event store unavailable: {ex}\")\n        return self.internal_server_error(\"Unable to process order. Please try again.\")\n\n    except EventStoreConcurrencyError as ex:\n        logger.warning(f\"Concurrency conflict for order {order.order_id}\")\n        return self.conflict(\"Order was modified by another process. Please retry.\")\n\n    except Exception as ex:\n        logger.exception(f\"Unexpected error saving order events: {ex}\")\n        return self.internal_server_error(\"An unexpected error occurred.\")\n</code></pre>"},{"location":"patterns/event-sourcing/#6-querying-event-store-directly-instead-of-projections","title":"6. Querying Event Store Directly Instead of Projections","text":"<pre><code># \u274c WRONG: Querying by replaying events (very slow!)\nasync def get_orders_by_customer(customer_id: str) -&gt; List[Order]:\n    # This is TERRIBLE for performance!\n    all_orders = []\n    order_ids = await self.event_store.get_all_aggregate_ids()\n\n    for order_id in order_ids:  # Could be thousands!\n        events = await self.event_store.get_events_async(order_id)\n        order = Order(order_id)\n        for event in events:\n            order.apply(event)\n\n        if order.customer_id == customer_id:\n            all_orders.append(order)\n\n    return all_orders\n\n# \u2705 CORRECT: Use projections for queries\nclass OrderReadModel:\n    \"\"\"Projection built from events for fast queries\"\"\"\n    order_id: str\n    customer_id: str\n    status: str\n    total: Decimal\n    placed_at: datetime\n\nclass OrderProjection:\n    \"\"\"Builds read models from events\"\"\"\n    def __init__(self, read_model_repository: OrderReadModelRepository):\n        self.repository = read_model_repository\n\n    async def handle(self, event: OrderPlacedEvent):\n        \"\"\"Update read model when order placed\"\"\"\n        read_model = OrderReadModel(\n            order_id=event.order_id,\n            customer_id=event.customer_id,\n            status=\"placed\",\n            total=event.total,\n            placed_at=event.placed_at\n        )\n        await self.repository.save_async(read_model)\n\n    async def handle(self, event: OrderConfirmedEvent):\n        \"\"\"Update read model when order confirmed\"\"\"\n        read_model = await self.repository.get_by_id_async(event.order_id)\n        read_model.status = \"confirmed\"\n        await self.repository.save_async(read_model)\n\n# Now queries are fast!\nasync def get_orders_by_customer(customer_id: str) -&gt; List[OrderReadModel]:\n    # Query optimized read model, not event store!\n    return await self.read_model_repository.find_by_customer_async(customer_id)\n</code></pre>"},{"location":"patterns/event-sourcing/#when-not-to-use_1","title":"\ud83d\udeab When NOT to Use","text":""},{"location":"patterns/event-sourcing/#1-simple-crud-applications","title":"1. Simple CRUD Applications","text":"<pre><code># Event sourcing adds unnecessary complexity for simple data management\nclass ContactListApplication:\n    \"\"\"Simple contact management doesn't need event sourcing\"\"\"\n    async def add_contact(self, name: str, email: str):\n        # Just save the contact - no need for events\n        contact = Contact(name=name, email=email)\n        await self.db.contacts.insert_one(contact.__dict__)\n\n    async def update_email(self, contact_id: str, new_email: str):\n        # Direct update is fine - no need to store history\n        await self.db.contacts.update_one(\n            {\"_id\": contact_id},\n            {\"$set\": {\"email\": new_email}}\n        )\n</code></pre>"},{"location":"patterns/event-sourcing/#2-high-volume-write-systems-without-proper-infrastructure","title":"2. High-Volume Write Systems (Without Proper Infrastructure)","text":"<pre><code># Event sourcing can become a bottleneck with very high write volumes\nclass RealTimeAnalytics:\n    \"\"\"Processing millions of events per second\"\"\"\n    async def record_metric(self, metric: Metric):\n        # For high-volume metrics, event sourcing may be overkill\n        # Consider time-series databases or streaming platforms instead\n        await self.timeseries_db.write_point(metric)\n</code></pre>"},{"location":"patterns/event-sourcing/#3-systems-requiring-immediate-consistency","title":"3. Systems Requiring Immediate Consistency","text":"<pre><code># Event sourcing typically involves eventual consistency\nclass BankingTransfer:\n    \"\"\"Financial transactions requiring immediate consistency\"\"\"\n    async def transfer_money(self, from_account: str, to_account: str, amount: Decimal):\n        # Banking transfers need immediate consistency\n        # Event sourcing's eventual consistency is problematic here\n        # Use traditional ACID transactions instead\n        async with self.db.begin_transaction() as tx:\n            await tx.debit(from_account, amount)\n            await tx.credit(to_account, amount)\n            await tx.commit()\n</code></pre>"},{"location":"patterns/event-sourcing/#4-small-teams-without-event-sourcing-experience","title":"4. Small Teams Without Event Sourcing Experience","text":"<pre><code># Event sourcing has a steep learning curve\nclass StartupMVP:\n    \"\"\"Early-stage product with small team\"\"\"\n    # Avoid event sourcing initially - focus on shipping features\n    # Add event sourcing later if audit trail becomes critical\n    async def create_user(self, user_data: dict):\n        # Simple state-based persistence is fine for MVPs\n        user = User(**user_data)\n        await self.db.users.insert_one(user.__dict__)\n</code></pre>"},{"location":"patterns/event-sourcing/#5-data-that-truly-doesnt-need-history","title":"5. Data That Truly Doesn't Need History","text":"<pre><code># Not all data benefits from historical tracking\nclass UserPreferences:\n    \"\"\"User UI preferences that don't need history\"\"\"\n    async def update_theme(self, user_id: str, theme: str):\n        # Who cares what theme the user had yesterday?\n        # Just store current preference\n        await self.db.preferences.update_one(\n            {\"user_id\": user_id},\n            {\"$set\": {\"theme\": theme}},\n            upsert=True\n        )\n</code></pre>"},{"location":"patterns/event-sourcing/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ul> <li>Event sourcing stores state changes as immutable events, preserving complete history</li> <li>Every state change is an event that can be replayed to reconstruct state</li> <li>Audit trails and compliance are automatic benefits of event sourcing</li> <li>Projections enable optimized read models built from event streams</li> <li>Snapshots improve performance by avoiding full event replay for old aggregates</li> <li>Event versioning is critical to handle schema evolution over time</li> <li>Use projections for queries, not direct event store queries</li> <li>Event sourcing adds complexity - only use when benefits outweigh costs</li> <li>Best for domains with complex workflows and audit requirements</li> <li>Framework provides EventStore and AggregateRoot for event sourcing support</li> </ul>"},{"location":"patterns/event-sourcing/#related-patterns","title":"\ud83d\udd17 Related Patterns","text":""},{"location":"patterns/event-sourcing/#complementary-patterns","title":"Complementary Patterns","text":"<ul> <li>CQRS - Command/Query separation works naturally with event sourcing</li> <li>Repository - Event sourcing repositories for aggregate persistence</li> <li>Domain-Driven Design - Aggregates and domain events are core DDD concepts</li> <li>Reactive Programming - Event streams integrate with reactive patterns</li> <li>Event-Driven Architecture - Events provide integration between services</li> <li>Dependency Injection - Service registration for event sourcing infrastructure</li> </ul>"},{"location":"patterns/event-sourcing/#integration-examples","title":"Integration Examples","text":"<p>Event Sourcing works particularly well with CQRS, where commands modify event-sourced aggregates and queries read from optimized projections built from the same event streams.</p> <p>Next Steps: Explore CQRS &amp; Mediation for command/query separation with event sourcing or Repository for aggregate persistence patterns.</p>"},{"location":"patterns/kitchen-order-placement-ddd-analysis/","title":"DDD Analysis: Where Should Kitchen Orders Be Added?","text":"<p>\ud83d\udea7 Work in Progress: This documentation is being updated to include beginner-friendly explanations with What &amp; Why sections, Common Mistakes, and When NOT to Use guidance. The content below is accurate but will be enhanced soon.</p>"},{"location":"patterns/kitchen-order-placement-ddd-analysis/#question","title":"Question","text":"<p>In the Mario Pizzeria sample app, where should an order be added to the Kitchen's pending orders list:</p> <ol> <li>In the Command Handler (PlaceOrderCommandHandler) - as part of the transaction?</li> <li>In the Domain Event Handler (OrderConfirmedEventHandler) - as a side effect?</li> </ol>"},{"location":"patterns/kitchen-order-placement-ddd-analysis/#current-state-analysis","title":"Current State Analysis","text":""},{"location":"patterns/kitchen-order-placement-ddd-analysis/#what-happens-now","title":"What Happens Now","text":"<p>PlaceOrderCommandHandler Flow:</p> <pre><code>async def handle_async(self, request: PlaceOrderCommand):\n    # 1. Create or get customer\n    customer = await self._create_or_get_customer(request)\n\n    # 2. Create order with items\n    order = Order(customer_id=customer.id())\n    order.add_order_item(...)\n\n    # 3. Confirm order (raises OrderConfirmedEvent)\n    order.confirm_order()\n\n    # 4. Save order\n    await self.order_repository.add_async(order)\n\n    # 5. Register for domain event dispatching\n    self.unit_of_work.register_aggregate(order)\n\n    # \u274c Kitchen is NOT updated here\n\n    return self.created(order_dto)\n</code></pre> <p>StartCookingCommandHandler Flow:</p> <pre><code>async def handle_async(self, request: StartCookingCommand):\n    # 1. Get order and kitchen\n    order = await self.order_repository.get_async(request.order_id)\n    kitchen = await self.kitchen_repository.get_kitchen_state_async()\n\n    # 2. Check capacity\n    if kitchen.is_at_capacity:\n        return self.bad_request(\"Kitchen is at capacity\")\n\n    # 3. Start cooking\n    order.start_cooking()  # Raises CookingStartedEvent\n    kitchen.start_order(order.id())  # \u2705 Kitchen updated in command handler\n\n    # 4. Save both aggregates\n    await self.order_repository.update_async(order)\n    await self.kitchen_repository.update_kitchen_state_async(kitchen)\n\n    # 5. Register for events\n    self.unit_of_work.register_aggregate(order)\n\n    return self.ok(order_dto)\n</code></pre> <p>Key Observation: The <code>StartCookingCommandHandler</code> updates the Kitchen in the command handler, not in an event handler.</p>"},{"location":"patterns/kitchen-order-placement-ddd-analysis/#ddd-principles-analysis","title":"DDD Principles Analysis","text":""},{"location":"patterns/kitchen-order-placement-ddd-analysis/#1-aggregate-boundaries","title":"1. Aggregate Boundaries","text":"<p>Order Aggregate:</p> <ul> <li>Root: <code>Order</code></li> <li>Owns: <code>OrderItems</code> (value objects)</li> <li>Responsible for: Order lifecycle, business rules about items, pricing</li> </ul> <p>Kitchen Aggregate:</p> <ul> <li>Root: <code>Kitchen</code></li> <li>Owns: <code>active_orders</code> list (order IDs)</li> <li>Responsible for: Capacity management, tracking orders in preparation</li> </ul> <p>Customer Aggregate:</p> <ul> <li>Root: <code>Customer</code></li> <li>Responsible for: Customer information, contact details</li> </ul> <p>These are SEPARATE aggregates - they should maintain their own consistency boundaries.</p>"},{"location":"patterns/kitchen-order-placement-ddd-analysis/#2-transaction-boundaries","title":"2. Transaction Boundaries","text":"<p>DDD Rule: A transaction should modify at most ONE aggregate root.</p> <p>Why?</p> <ul> <li>Ensures clear consistency boundaries</li> <li>Prevents distributed transaction complexity</li> <li>Makes concurrency control manageable</li> <li>Maintains aggregate autonomy</li> </ul> <p>Application to Pizza Domain:</p>"},{"location":"patterns/kitchen-order-placement-ddd-analysis/#scenario-a-update-kitchen-in-command-handler","title":"Scenario A: Update Kitchen in Command Handler","text":"<pre><code>async def handle_async(self, request: PlaceOrderCommand):\n    # Transaction modifies TWO aggregates:\n    order = Order(...)\n    order.confirm_order()\n    await self.order_repository.add_async(order)  # Aggregate 1\n\n    kitchen = await self.kitchen_repository.get_kitchen_state_async()\n    kitchen.add_pending_order(order.id())\n    await self.kitchen_repository.update_kitchen_state_async(kitchen)  # Aggregate 2\n\n    # \u274c VIOLATES: One transaction, two aggregates\n</code></pre> <p>Problems:</p> <ul> <li>\u274c Violates single aggregate per transaction rule</li> <li>\u274c Tight coupling between Order and Kitchen</li> <li>\u274c If Kitchen update fails, what happens to Order?</li> <li>\u274c Concurrency issues if multiple orders placed simultaneously</li> <li>\u274c Kitchen becomes a bottleneck for order placement</li> </ul>"},{"location":"patterns/kitchen-order-placement-ddd-analysis/#scenario-b-update-kitchen-in-event-handler-eventually-consistent","title":"Scenario B: Update Kitchen in Event Handler (Eventually Consistent)","text":"<pre><code># Command Handler - modifies ONE aggregate\nasync def handle_async(self, request: PlaceOrderCommand):\n    order = Order(...)\n    order.confirm_order()  # Raises OrderConfirmedEvent\n    await self.order_repository.add_async(order)\n    self.unit_of_work.register_aggregate(order)\n    # \u2705 Transaction complete, only modified Order\n    return self.created(order_dto)\n\n# Event Handler - separate transaction, different aggregate\nclass OrderConfirmedEventHandler:\n    async def handle_async(self, event: OrderConfirmedEvent):\n        kitchen = await self.kitchen_repository.get_kitchen_state_async()\n        kitchen.add_pending_order(event.aggregate_id)\n        await self.kitchen_repository.update_kitchen_state_async(kitchen)\n        # \u2705 Separate transaction, only modified Kitchen\n</code></pre> <p>Benefits:</p> <ul> <li>\u2705 Each transaction modifies ONE aggregate</li> <li>\u2705 Loose coupling via events</li> <li>\u2705 Order placement succeeds independently</li> <li>\u2705 Better scalability and concurrency</li> <li>\u2705 Clearer failure boundaries</li> </ul>"},{"location":"patterns/kitchen-order-placement-ddd-analysis/#3-domain-event-semantics","title":"3. Domain Event Semantics","text":"<p>What is OrderConfirmedEvent?</p> <ul> <li>Past tense - something that ALREADY happened</li> <li>Immutable fact - the order WAS confirmed</li> <li>Publishing contract - \"I'm telling you this happened, do what you need to do\"</li> </ul> <p>Event Handler Responsibilities:</p> <ul> <li>React to domain events from other aggregates</li> <li>Implement inter-aggregate workflows</li> <li>Maintain eventual consistency between aggregates</li> <li>Handle side effects and projections</li> </ul>"},{"location":"patterns/kitchen-order-placement-ddd-analysis/#4-consistency-models","title":"4. Consistency Models","text":"<p>Strong Consistency (Single Aggregate):</p> <pre><code>Order.confirm_order() \u2192 Order.state.status = CONFIRMED\n                      \u2192 Order.state.confirmed_time = now()\n\u2705 Immediate consistency within Order aggregate\n</code></pre> <p>Eventual Consistency (Cross-Aggregate):</p> <pre><code>Order confirms \u2192 OrderConfirmedEvent published\n              \u2193\n              \u2192 Event dispatched (after transaction commits)\n              \u2193\n              \u2192 OrderConfirmedEventHandler invoked\n              \u2193\n              \u2192 Kitchen updated with new pending order\n\n\u2705 Eventually consistent between Order and Kitchen\n</code></pre>"},{"location":"patterns/kitchen-order-placement-ddd-analysis/#5-business-rules-analysis","title":"5. Business Rules Analysis","text":"<p>Question: Is \"Kitchen must know about confirmed orders\" a business invariant or a side effect?</p> <p>Business Invariant (must be enforced in transaction):</p> <ul> <li>\"Order must have at least one pizza\"</li> <li>\"Order total must be &gt;= 0\"</li> <li>\"Kitchen cannot exceed max capacity when starting cooking\"</li> <li>These must be checked BEFORE committing</li> </ul> <p>Side Effect / Eventual Consistency (can happen after transaction):</p> <ul> <li>\"Kitchen should track pending orders for dashboard\"</li> <li>\"Customer should receive confirmation email\"</li> <li>\"Analytics should update order metrics\"</li> <li>These can happen asynchronously</li> </ul> <p>Analysis for Pizzeria:</p> <p>The Kitchen tracking pending orders is NOT a business invariant for order placement. Here's why:</p> <ol> <li>Order can be placed even if Kitchen is busy - the order goes into \"confirmed\" state, waiting for kitchen capacity</li> <li>Kitchen tracking is for operational visibility - showing what orders are waiting</li> <li>Failure to update Kitchen doesn't invalidate the Order - the order is still valid</li> <li>Kitchen state is a projection/read model - derived from order events</li> </ol> <p>Counterpoint: When starting cooking (StartCookingCommand), Kitchen capacity IS a business rule:</p> <pre><code>if kitchen.is_at_capacity:\n    return self.bad_request(\"Kitchen is at capacity\")\n</code></pre> <p>This must be checked in the transaction because it affects whether the order can transition to \"Cooking\" state.</p>"},{"location":"patterns/kitchen-order-placement-ddd-analysis/#recommendation-use-event-handler-eventually-consistent","title":"Recommendation: Use Event Handler (Eventually Consistent)","text":""},{"location":"patterns/kitchen-order-placement-ddd-analysis/#recommended-approach","title":"\u2705 Recommended Approach","text":"<p>Update the Kitchen via OrderConfirmedEventHandler:</p> <pre><code># domain/entities/kitchen.py\nclass Kitchen(Entity[str]):\n    def __init__(self, max_concurrent_orders: int = 3):\n        super().__init__()\n        self.id = \"kitchen\"\n        self.active_orders: list[str] = []  # Orders being cooked\n        self.pending_orders: list[str] = []  # Orders confirmed, waiting to cook\n        self.max_concurrent_orders = max_concurrent_orders\n        self.total_orders_processed = 0\n\n    def add_pending_order(self, order_id: str) -&gt; None:\n        \"\"\"Add a confirmed order to the pending queue\"\"\"\n        if order_id not in self.pending_orders:\n            self.pending_orders.append(order_id)\n\n    def start_order(self, order_id: str) -&gt; bool:\n        \"\"\"Move order from pending to active (if capacity allows)\"\"\"\n        if self.is_at_capacity:\n            return False\n\n        # Remove from pending if present\n        if order_id in self.pending_orders:\n            self.pending_orders.remove(order_id)\n\n        # Add to active\n        if order_id not in self.active_orders:\n            self.active_orders.append(order_id)\n\n        return True\n</code></pre> <pre><code># application/event_handlers.py\nclass OrderConfirmedEventHandler(DomainEventHandler[OrderConfirmedEvent]):\n    \"\"\"Handles order confirmation - adds to kitchen pending queue\"\"\"\n\n    def __init__(self, kitchen_repository: IKitchenRepository):\n        self.kitchen_repository = kitchen_repository\n\n    async def handle_async(self, event: OrderConfirmedEvent) -&gt; Any:\n        \"\"\"Process order confirmed event\"\"\"\n        logger.info(\n            f\"\ud83c\udf55 Order {event.aggregate_id} confirmed! \"\n            f\"Total: ${event.total_amount}, Pizzas: {event.pizza_count}\"\n        )\n\n        # Update kitchen with pending order\n        kitchen = await self.kitchen_repository.get_kitchen_state_async()\n        kitchen.add_pending_order(event.aggregate_id)\n        await self.kitchen_repository.update_kitchen_state_async(kitchen)\n\n        # Other side effects:\n        # - Send SMS notification to customer\n        # - Send email receipt\n        # - Update kitchen display system\n        # - Create kitchen ticket\n\n        return None\n</code></pre> <pre><code># application/commands/place_order_command.py\nclass PlaceOrderCommandHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    async def handle_async(self, request: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        try:\n            # Create customer and order (ONE aggregate modified)\n            customer = await self._create_or_get_customer(request)\n            order = Order(customer_id=customer.id())\n\n            # Add items\n            for pizza_item in request.pizzas:\n                order_item = OrderItem(...)\n                order.add_order_item(order_item)\n\n            # Confirm order (raises OrderConfirmedEvent)\n            order.confirm_order()\n\n            # Save order (commits transaction)\n            await self.order_repository.add_async(order)\n\n            # Register for domain event dispatching\n            self.unit_of_work.register_aggregate(order)\n            self.unit_of_work.register_aggregate(customer)\n\n            # \u2705 Kitchen will be updated by OrderConfirmedEventHandler\n            # \u2705 Happens AFTER this transaction commits\n            # \u2705 Eventually consistent\n\n            return self.created(order_dto)\n\n        except Exception as e:\n            return self.bad_request(f\"Failed to place order: {str(e)}\")\n</code></pre>"},{"location":"patterns/kitchen-order-placement-ddd-analysis/#why-this-is-better","title":"Why This is Better","text":""},{"location":"patterns/kitchen-order-placement-ddd-analysis/#1-respects-aggregate-boundaries","title":"1. Respects Aggregate Boundaries","text":"<ul> <li>PlaceOrderCommand modifies only Order aggregate \u2705</li> <li>OrderConfirmedEventHandler modifies only Kitchen aggregate \u2705</li> <li>Each transaction touches ONE aggregate root \u2705</li> </ul>"},{"location":"patterns/kitchen-order-placement-ddd-analysis/#2-follows-event-driven-architecture","title":"2. Follows Event-Driven Architecture","text":"<ul> <li>Domain events communicate between aggregates \u2705</li> <li>Loose coupling between Order and Kitchen \u2705</li> <li>Easy to add new event handlers (email, SMS, analytics) \u2705</li> </ul>"},{"location":"patterns/kitchen-order-placement-ddd-analysis/#3-better-scalability","title":"3. Better Scalability","text":"<pre><code>Without Event Handler (Synchronous):\nPlaceOrder \u2192 Update Order \u2192 Update Kitchen \u2192 Commit\n             |______________|______________|\n                 Single Transaction\n                 Kitchen is bottleneck\n\nWith Event Handler (Asynchronous):\nPlaceOrder \u2192 Update Order \u2192 Commit \u2705 (fast)\n                          \u2193\n                          Event Published\n                          \u2193\n                          \u2192 Update Kitchen \u2705 (separate transaction)\n                          \u2192 Send Email \u2705\n                          \u2192 Update Analytics \u2705\n</code></pre>"},{"location":"patterns/kitchen-order-placement-ddd-analysis/#4-clearer-failure-handling","title":"4. Clearer Failure Handling","text":"<ul> <li>Order placement succeeds even if Kitchen update temporarily fails</li> <li>Event handler can retry Kitchen update independently</li> <li>Kitchen update failure doesn't rollback the order (order is still valid)</li> <li>Eventual consistency is acceptable for this use case</li> </ul>"},{"location":"patterns/kitchen-order-placement-ddd-analysis/#5-business-semantics-match-reality","title":"5. Business Semantics Match Reality","text":"<p>Real pizza shop flow:</p> <ol> <li>Customer places order \u2192 Order confirmed \u2705</li> <li>Order ticket goes to kitchen \u2192 Kitchen gets notification \u2705</li> <li>Kitchen starts when ready \u2192 Order moves to cooking \u2705</li> </ol> <p>The kitchen getting the ticket is a consequence of order confirmation, not a prerequisite.</p>"},{"location":"patterns/kitchen-order-placement-ddd-analysis/#6-consistency-with-startcookingcommand","title":"6. Consistency with StartCookingCommand","text":"<p>Notice that <code>StartCookingCommand</code> DOES update Kitchen in the handler:</p> <pre><code>kitchen.start_order(order.id())  # Check capacity + update kitchen\norder.start_cooking()  # Update order status\n</code></pre> <p>Why is this different?</p> <ul> <li>Kitchen capacity is a business rule for starting cooking</li> <li>Must be checked atomically to prevent race conditions</li> <li>If capacity check fails, order cannot start cooking</li> <li>Strong consistency required between Kitchen and Order for this operation</li> </ul> <p>But for PlaceOrder:</p> <ul> <li>Kitchen tracking confirmed orders is just visibility/monitoring</li> <li>Order can be confirmed regardless of kitchen state</li> <li>Eventual consistency is acceptable</li> </ul>"},{"location":"patterns/kitchen-order-placement-ddd-analysis/#common-objections-addressed","title":"Common Objections Addressed","text":""},{"location":"patterns/kitchen-order-placement-ddd-analysis/#objection-1-but-kitchen-update-might-fail","title":"Objection 1: \"But kitchen update might fail!\"","text":"<p>Response:</p> <ul> <li>That's OK - the Order is still valid and confirmed</li> <li>Event handlers can retry on failure</li> <li>Use outbox pattern or reliable event bus for guaranteed delivery</li> <li>Kitchen can poll for confirmed orders as backup</li> <li>This is eventual consistency - the system will become consistent</li> </ul>"},{"location":"patterns/kitchen-order-placement-ddd-analysis/#objection-2-what-if-we-need-to-know-kitchen-state-before-confirming","title":"Objection 2: \"What if we need to know kitchen state before confirming?\"","text":"<p>Response:</p> <ul> <li>Then that's a different requirement: \"Order placement should check kitchen capacity\"</li> <li>In that case, add a query before the command:</li> </ul> <pre><code># In controller or application service\nkitchen = await query_handler.execute(GetKitchenStatusQuery())\nif kitchen.pending_orders_count &gt;= MAX_PENDING:\n    return self.bad_request(\"Too many pending orders\")\n\n# Proceed with PlaceOrderCommand\nresult = await mediator.execute(PlaceOrderCommand(...))\n</code></pre> <ul> <li>Still don't couple Order and Kitchen aggregates in the same transaction</li> <li>Pre-check is for user experience, not transactional consistency</li> </ul>"},{"location":"patterns/kitchen-order-placement-ddd-analysis/#objection-3-eventual-consistency-is-complex","title":"Objection 3: \"Eventual consistency is complex!\"","text":"<p>Response:</p> <ul> <li>It's actually simpler than distributed transactions</li> <li>The framework handles event dispatching automatically</li> <li>No distributed locks or 2-phase commits needed</li> <li>Better scalability and resilience</li> <li>This is how most successful systems work (Amazon, Netflix, Uber)</li> </ul>"},{"location":"patterns/kitchen-order-placement-ddd-analysis/#implementation-checklist","title":"Implementation Checklist","text":"<p>To implement this recommendation:</p> <ol> <li>\u2705 Add <code>pending_orders</code> to Kitchen entity</li> </ol> <pre><code>self.pending_orders: list[str] = []\n</code></pre> <ol> <li>\u2705 Add <code>add_pending_order()</code> method to Kitchen</li> </ol> <pre><code>def add_pending_order(self, order_id: str) -&gt; None\n</code></pre> <ol> <li>\u2705 Update <code>start_order()</code> to move from pending to active</li> </ol> <pre><code>def start_order(self, order_id: str) -&gt; bool:\n    if order_id in self.pending_orders:\n        self.pending_orders.remove(order_id)\n    self.active_orders.append(order_id)\n</code></pre> <ol> <li>\u2705 Update OrderConfirmedEventHandler</li> </ol> <pre><code>kitchen = await self.kitchen_repository.get_kitchen_state_async()\nkitchen.add_pending_order(event.aggregate_id)\nawait self.kitchen_repository.update_kitchen_state_async(kitchen)\n</code></pre> <ol> <li> <p>\u2705 Keep PlaceOrderCommandHandler as-is</p> </li> <li> <p>No kitchen updates in command handler</p> </li> <li> <p>Only modifies Order aggregate</p> </li> <li> <p>\u2705 Update KitchenStatusDto to show pending orders</p> </li> </ol> <pre><code>pending_orders: list[str]\n</code></pre>"},{"location":"patterns/kitchen-order-placement-ddd-analysis/#conclusion","title":"Conclusion","text":"<p>Recommendation: Add orders to Kitchen in the OrderConfirmedEventHandler \u2705</p> <p>This approach:</p> <ul> <li>\u2705 Follows DDD aggregate boundary rules (one aggregate per transaction)</li> <li>\u2705 Uses domain events correctly (inter-aggregate communication)</li> <li>\u2705 Provides eventual consistency (acceptable for this use case)</li> <li>\u2705 Maintains loose coupling (easy to extend)</li> <li>\u2705 Scales better (no transaction bottleneck)</li> <li>\u2705 Matches real-world semantics (order confirmed \u2192 kitchen notified)</li> <li>\u2705 Handles failures gracefully (order valid even if kitchen update fails)</li> </ul> <p>The current StartCookingCommand is correct because kitchen capacity is a business invariant that must be checked atomically when transitioning to cooking state.</p> <p>Your intuition about transactions was correct, but the key insight is: Not everything needs strong consistency. Kitchen tracking confirmed orders is a projection/read model that can be eventually consistent, while kitchen capacity for cooking is a business rule that requires strong consistency.</p> <p>This is a fundamental DDD pattern: Strong consistency within aggregates, eventual consistency between aggregates.</p>"},{"location":"patterns/kitchen-order-placement-ddd-analysis/#further-reading","title":"Further Reading","text":"<ul> <li>Domain-Driven Design by Eric Evans - Chapter on Aggregates</li> <li>Implementing Domain-Driven Design by Vaughn Vernon - Chapter on Aggregates and Event-Driven Architecture</li> <li>Patterns, Principles, and Practices of Domain-Driven Design by Scott Millett - Chapter on Eventual Consistency</li> </ul>"},{"location":"patterns/persistence-patterns/","title":"\ud83c\udfdb\ufe0f Persistence Patterns in Neuroglia","text":"<p>\ud83d\udea7 Work in Progress: This documentation is being updated to include beginner-friendly explanations with What &amp; Why sections, Common Mistakes, and When NOT to Use guidance. The content below is accurate but will be enhanced soon.</p> <p>This guide explains the persistence pattern alternatives available in the Neuroglia framework and their corresponding complexity levels, helping you choose the right approach for your domain requirements.</p>"},{"location":"patterns/persistence-patterns/#pattern-overview","title":"\ud83c\udfaf Pattern Overview","text":"<p>Neuroglia supports three distinct persistence patterns, each with different complexity levels and use cases:</p> Pattern Complexity Best For Infrastructure Simple Entity + State Persistence \u2b50\u2b50\u2606\u2606\u2606 CRUD apps, rapid development Any database Aggregate Root + Event Sourcing \u2b50\u2b50\u2b50\u2b50\u2b50 Complex domains, audit requirements Event store Hybrid Approach \u2b50\u2b50\u2b50\u2606\u2606 Mixed requirements, gradual migration Both <p>All patterns use the same infrastructure (Unit of Work, CQRS, Domain Events) but with different complexity levels and persistence strategies.</p>"},{"location":"patterns/persistence-patterns/#architecture-decision-matrix","title":"\ud83d\udcca Architecture Decision Matrix","text":""},{"location":"patterns/persistence-patterns/#when-to-choose-each-pattern","title":"When to Choose Each Pattern","text":"<pre><code>graph TD\n    START[New Feature/Domain] --&gt; COMPLEXITY{Domain Complexity?}\n\n    COMPLEXITY --&gt;|Simple CRUD| SIMPLE[Simple Entity + State]\n    COMPLEXITY --&gt;|Complex Business Logic| COMPLEX[Aggregate Root + Events]\n    COMPLEXITY --&gt;|Mixed Requirements| HYBRID[Hybrid Approach]\n\n    SIMPLE --&gt; SIMPLE_FEATURES[\u2705 Direct DB queries&lt;br/&gt;\u2705 Fast development&lt;br/&gt;\u2705 Easy testing&lt;br/&gt;\u26a0\ufe0f Limited audit trails]\n\n    COMPLEX --&gt; COMPLEX_FEATURES[\u2705 Rich domain logic&lt;br/&gt;\u2705 Full audit trails&lt;br/&gt;\u2705 Temporal queries&lt;br/&gt;\u26a0\ufe0f Higher complexity]\n\n    HYBRID --&gt; HYBRID_FEATURES[\u2705 Best of both worlds&lt;br/&gt;\u2705 Incremental adoption&lt;br/&gt;\u2705 Domain-specific choices&lt;br/&gt;\u26a0\ufe0f Mixed complexity]\n\n    SIMPLE_FEATURES --&gt; IMPL_SIMPLE[Entity + domain_events&lt;br/&gt;Repository pattern&lt;br/&gt;State-based persistence]\n    COMPLEX_FEATURES --&gt; IMPL_COMPLEX[AggregateRoot + EventStore&lt;br/&gt;Event sourcing&lt;br/&gt;Projections]\n    HYBRID_FEATURES --&gt; IMPL_HYBRID[Mix both patterns&lt;br/&gt;per bounded context]</code></pre>"},{"location":"patterns/persistence-patterns/#pattern-1-simple-entity-state-persistence","title":"\ud83d\udd27 Pattern 1: Simple Entity + State Persistence","text":"<p>Complexity Level: \u2b50\u2b50\u2606\u2606\u2606 (Simple)</p>"},{"location":"patterns/persistence-patterns/#overview","title":"Overview","text":"<p>The simplest approach for most applications. Uses regular entities with direct state persistence while still supporting domain events and clean architecture principles.</p>"},{"location":"patterns/persistence-patterns/#core-characteristics","title":"Core Characteristics","text":"<ul> <li>Entity Inheritance: Inherit from <code>Entity</code> base class</li> <li>State Persistence: Direct database state storage (SQL/NoSQL)</li> <li>Domain Events: Simple event raising for integration</li> <li>Traditional Queries: Direct database queries and joins</li> <li>Low Complexity: Minimal learning curve and setup</li> </ul>"},{"location":"patterns/persistence-patterns/#implementation-example","title":"Implementation Example","text":"<pre><code>from neuroglia.data.abstractions import Entity, DomainEvent\nfrom dataclasses import dataclass\nfrom decimal import Decimal\nimport uuid\n\n# 1. Simple Domain Event\n@dataclass(frozen=True)\nclass ProductCreatedEvent(DomainEvent):\n    product_id: str\n    name: str\n    price: Decimal\n    created_at: datetime\n\n# 2. Simple Entity with Business Logic\nclass Product(Entity):\n    def __init__(self, name: str, price: Decimal):\n        super().__init__()\n        self._id = str(uuid.uuid4())\n        self.name = name\n        self.price = price\n        self.is_active = True\n        self.created_at = datetime.utcnow()\n\n        # Raise domain event for integration\n        self._raise_domain_event(ProductCreatedEvent(\n            product_id=self.id,\n            name=self.name,\n            price=self.price,\n            created_at=self.created_at\n        ))\n\n    def update_price(self, new_price: Decimal) -&gt; None:\n        \"\"\"Business method with validation and events.\"\"\"\n        if new_price &lt;= 0:\n            raise ValueError(\"Price must be positive\")\n\n        if new_price != self.price:\n            old_price = self.price\n            self.price = new_price\n\n            # Raise integration event\n            self._raise_domain_event(ProductPriceUpdatedEvent(\n                product_id=self.id,\n                old_price=old_price,\n                new_price=new_price,\n                updated_at=datetime.utcnow()\n            ))\n\n    def deactivate(self) -&gt; None:\n        \"\"\"Business method to deactivate product.\"\"\"\n        if self.is_active:\n            self.is_active = False\n            self._raise_domain_event(ProductDeactivatedEvent(\n                product_id=self.id,\n                deactivated_at=datetime.utcnow()\n            ))\n\n    # Minimal domain event infrastructure\n    def _raise_domain_event(self, event: DomainEvent) -&gt; None:\n        if not hasattr(self, '_pending_events'):\n            self._pending_events = []\n        self._pending_events.append(event)\n\n    @property\n    def domain_events(self) -&gt; List[DomainEvent]:\n        \"\"\"Expose events for Unit of Work collection.\"\"\"\n        return getattr(self, '_pending_events', []).copy()\n\n    def clear_pending_events(self) -&gt; None:\n        \"\"\"Clear events after dispatching.\"\"\"\n        if hasattr(self, '_pending_events'):\n            self._pending_events.clear()\n\n# 3. Traditional Repository with State Persistence\nclass ProductRepository:\n    def __init__(self, db_context):\n        self.db_context = db_context\n\n    async def save_async(self, product: Product) -&gt; None:\n        \"\"\"Save entity state directly to database.\"\"\"\n        await self.db_context.products.replace_one(\n            {\"_id\": product.id},\n            {\n                \"_id\": product.id,\n                \"name\": product.name,\n                \"price\": float(product.price),\n                \"is_active\": product.is_active,\n                \"created_at\": product.created_at,\n                \"updated_at\": datetime.utcnow()\n            },\n            upsert=True\n        )\n\n    async def get_by_id_async(self, product_id: str) -&gt; Optional[Product]:\n        \"\"\"Load entity state from database.\"\"\"\n        doc = await self.db_context.products.find_one({\"_id\": product_id})\n        if not doc:\n            return None\n\n        # Reconstruct entity from state\n        product = Product.__new__(Product)\n        product._id = doc[\"_id\"]\n        product.name = doc[\"name\"]\n        product.price = Decimal(str(doc[\"price\"]))\n        product.is_active = doc[\"is_active\"]\n        product.created_at = doc[\"created_at\"]\n        return product\n\n# 4. Simple Command Handler\nclass UpdateProductPriceHandler(CommandHandler[UpdateProductPriceCommand, OperationResult]):\n    def __init__(self, product_repository: ProductRepository, unit_of_work: IUnitOfWork):\n        self.product_repository = product_repository\n        self.unit_of_work = unit_of_work\n\n    async def handle_async(self, command: UpdateProductPriceCommand) -&gt; OperationResult:\n        # Load entity\n        product = await self.product_repository.get_by_id_async(command.product_id)\n        if not product:\n            return self.not_found(\"Product not found\")\n\n        # Business logic with events\n        product.update_price(command.new_price)  # Raises ProductPriceUpdatedEvent\n\n        # State persistence\n        await self.product_repository.save_async(product)\n\n        # Register for automatic event dispatching\n        self.unit_of_work.register_aggregate(product)\n\n        return self.ok({\"product_id\": product.id, \"new_price\": product.price})\n</code></pre>"},{"location":"patterns/persistence-patterns/#database-schema-example-mongodb","title":"Database Schema Example (MongoDB)","text":"<pre><code>// Simple document structure - no events stored\n{\n  \"_id\": \"product-123\",\n  \"name\": \"Laptop\",\n  \"price\": 999.99,\n  \"is_active\": true,\n  \"created_at\": ISODate(\"2024-01-01T10:00:00Z\"),\n  \"updated_at\": ISODate(\"2024-01-15T14:30:00Z\")\n}\n\n// Queries are straightforward\ndb.products.find({is_active: true, price: {$lt: 1000}})\ndb.products.aggregate([\n  {$match: {is_active: true}},\n  {$group: {_id: null, avg_price: {$avg: \"$price\"}}}\n])\n</code></pre>"},{"location":"patterns/persistence-patterns/#benefits-trade-offs","title":"Benefits &amp; Trade-offs","text":""},{"location":"patterns/persistence-patterns/#benefits","title":"\u2705 Benefits","text":"<ul> <li>Simple to understand and implement</li> <li>Fast development and iteration</li> <li>Direct database queries and reporting</li> <li>Lower infrastructure requirements</li> <li>Easy testing and debugging</li> <li>Familiar to traditional developers</li> <li>Still supports domain events for integration</li> </ul>"},{"location":"patterns/persistence-patterns/#trade-offs","title":"\u26a0\ufe0f Trade-offs","text":"<ul> <li>Limited audit trail capabilities</li> <li>No built-in temporal queries</li> <li>Manual implementation of complex business rules</li> <li>Event history not automatically preserved</li> </ul>"},{"location":"patterns/persistence-patterns/#best-use-cases","title":"Best Use Cases","text":"<ul> <li>CRUD-heavy applications</li> <li>Rapid prototyping and MVPs</li> <li>Simple business domains</li> <li>Traditional database infrastructure</li> <li>Teams new to DDD/event sourcing</li> <li>Performance-critical applications</li> </ul>"},{"location":"patterns/persistence-patterns/#pattern-2-aggregate-root-event-sourcing","title":"\ud83c\udfd7\ufe0f Pattern 2: Aggregate Root + Event Sourcing","text":"<p>Complexity Level: \u2b50\u2b50\u2b50\u2b50\u2b50 (Complex)</p>"},{"location":"patterns/persistence-patterns/#overview_1","title":"Overview","text":"<p>The most sophisticated approach for complex domains. Uses aggregate roots with full event sourcing, providing rich business logic, complete audit trails, and temporal query capabilities.</p>"},{"location":"patterns/persistence-patterns/#core-characteristics_1","title":"Core Characteristics","text":"<ul> <li>Aggregate Root: Inherit from <code>AggregateRoot[TState, TKey]</code></li> <li>Event Sourcing: Events are the source of truth</li> <li>Rich Domain Logic: Complex business rules and invariants</li> <li>Event Store: Specialized storage for events</li> <li>Projections: Read models built from events</li> <li>Temporal Queries: Query state at any point in time</li> </ul>"},{"location":"patterns/persistence-patterns/#implementation-example_1","title":"Implementation Example","text":"<pre><code>from neuroglia.data.abstractions import AggregateRoot, DomainEvent\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom typing import List, Optional\nimport uuid\nfrom datetime import datetime\n\n# 1. Rich Domain Events\n@dataclass(frozen=True)\nclass OrderPlacedEvent(DomainEvent):\n    order_id: str\n    customer_id: str\n    items: List[dict]\n    total_amount: Decimal\n    placed_at: datetime\n\n@dataclass(frozen=True)\nclass OrderItemAddedEvent(DomainEvent):\n    order_id: str\n    product_id: str\n    quantity: int\n    unit_price: Decimal\n    added_at: datetime\n\n@dataclass(frozen=True)\nclass OrderCancelledEvent(DomainEvent):\n    order_id: str\n    reason: str\n    cancelled_at: datetime\n\n# 2. Aggregate State\nclass OrderStatus(Enum):\n    DRAFT = \"draft\"\n    PLACED = \"placed\"\n    SHIPPED = \"shipped\"\n    DELIVERED = \"delivered\"\n    CANCELLED = \"cancelled\"\n\n@dataclass\nclass OrderItem:\n    product_id: str\n    quantity: int\n    unit_price: Decimal\n\n    @property\n    def line_total(self) -&gt; Decimal:\n        return self.unit_price * self.quantity\n\nclass OrderState:\n    def __init__(self):\n        self.status = OrderStatus.DRAFT\n        self.customer_id: Optional[str] = None\n        self.items: List[OrderItem] = []\n        self.placed_at: Optional[datetime] = None\n        self.cancelled_at: Optional[datetime] = None\n        self.cancellation_reason: Optional[str] = None\n\n    @property\n    def total_amount(self) -&gt; Decimal:\n        return sum(item.line_total for item in self.items)\n\n    # Event handlers that modify state\n    def on(self, event: DomainEvent) -&gt; None:\n        if isinstance(event, OrderPlacedEvent):\n            self.status = OrderStatus.PLACED\n            self.customer_id = event.customer_id\n            self.items = [OrderItem(**item_data) for item_data in event.items]\n            self.placed_at = event.placed_at\n\n        elif isinstance(event, OrderItemAddedEvent):\n            self.items.append(OrderItem(\n                product_id=event.product_id,\n                quantity=event.quantity,\n                unit_price=event.unit_price\n            ))\n\n        elif isinstance(event, OrderCancelledEvent):\n            self.status = OrderStatus.CANCELLED\n            self.cancelled_at = event.cancelled_at\n            self.cancellation_reason = event.reason\n\n# 3. Aggregate Root with Rich Business Logic\nclass OrderAggregate(AggregateRoot[OrderState, str]):\n    def __init__(self, order_id: Optional[str] = None):\n        super().__init__(OrderState(), order_id or str(uuid.uuid4()))\n\n    def place_order(self, customer_id: str, items: List[dict]) -&gt; None:\n        \"\"\"Rich business logic with comprehensive validation.\"\"\"\n        # Business rule: Cannot place empty orders\n        if not items:\n            raise DomainException(\"Order must contain at least one item\")\n\n        # Business rule: Cannot modify placed orders\n        if self.state.status != OrderStatus.DRAFT:\n            raise DomainException(f\"Cannot place order in status: {self.state.status}\")\n\n        # Business rule: Validate customer\n        if not customer_id:\n            raise DomainException(\"Customer ID is required\")\n\n        # Business rule: Validate items\n        for item in items:\n            if item.get('quantity', 0) &lt;= 0:\n                raise DomainException(\"Item quantity must be positive\")\n            if item.get('unit_price', 0) &lt;= 0:\n                raise DomainException(\"Item price must be positive\")\n\n        # Apply event - this changes state AND records event\n        event = OrderPlacedEvent(\n            order_id=self.id,\n            customer_id=customer_id,\n            items=items,\n            total_amount=sum(Decimal(str(item['unit_price'])) * item['quantity'] for item in items),\n            placed_at=datetime.utcnow()\n        )\n\n        self.state.on(event)      # Apply to current state\n        self.register_event(event)  # Record for persistence and replay\n\n    def add_item(self, product_id: str, quantity: int, unit_price: Decimal) -&gt; None:\n        \"\"\"Add item with business rule enforcement.\"\"\"\n        # Business rule: Can only add items to draft orders\n        if self.state.status != OrderStatus.DRAFT:\n            raise DomainException(\"Cannot modify non-draft orders\")\n\n        # Business rule: Validate item\n        if quantity &lt;= 0:\n            raise DomainException(\"Quantity must be positive\")\n        if unit_price &lt;= 0:\n            raise DomainException(\"Price must be positive\")\n\n        # Business rule: Check for duplicates (example business logic)\n        existing_item = next((item for item in self.state.items if item.product_id == product_id), None)\n        if existing_item:\n            raise DomainException(f\"Product {product_id} already in order. Use update instead.\")\n\n        event = OrderItemAddedEvent(\n            order_id=self.id,\n            product_id=product_id,\n            quantity=quantity,\n            unit_price=unit_price,\n            added_at=datetime.utcnow()\n        )\n\n        self.state.on(event)\n        self.register_event(event)\n\n    def cancel_order(self, reason: str) -&gt; None:\n        \"\"\"Cancel order with business rules.\"\"\"\n        # Business rule: Can only cancel placed orders\n        if self.state.status not in [OrderStatus.DRAFT, OrderStatus.PLACED]:\n            raise DomainException(f\"Cannot cancel order in status: {self.state.status}\")\n\n        # Business rule: Require cancellation reason\n        if not reason or reason.strip() == \"\":\n            raise DomainException(\"Cancellation reason is required\")\n\n        event = OrderCancelledEvent(\n            order_id=self.id,\n            reason=reason.strip(),\n            cancelled_at=datetime.utcnow()\n        )\n\n        self.state.on(event)\n        self.register_event(event)\n\n    @property\n    def can_add_items(self) -&gt; bool:\n        \"\"\"Business query method.\"\"\"\n        return self.state.status == OrderStatus.DRAFT\n\n    @property\n    def is_modifiable(self) -&gt; bool:\n        \"\"\"Business query method.\"\"\"\n        return self.state.status in [OrderStatus.DRAFT]\n\n# 4. Event Store Repository\nclass EventSourcedOrderRepository:\n    def __init__(self, event_store):\n        self.event_store = event_store\n\n    async def save_async(self, order: OrderAggregate) -&gt; None:\n        \"\"\"Save uncommitted events to event store.\"\"\"\n        uncommitted_events = order.get_uncommitted_events()\n        if uncommitted_events:\n            await self.event_store.append_events_async(\n                stream_id=f\"order-{order.id}\",\n                events=uncommitted_events,\n                expected_version=order.version\n            )\n            order.mark_events_committed()\n\n    async def get_by_id_async(self, order_id: str) -&gt; Optional[OrderAggregate]:\n        \"\"\"Rebuild aggregate from event history.\"\"\"\n        events = await self.event_store.get_events_async(f\"order-{order_id}\")\n        if not events:\n            return None\n\n        # Rebuild aggregate by replaying all events\n        order = OrderAggregate(order_id)\n        for event in events:\n            order.state.on(event)\n\n        order.version = len(events) - 1\n        return order\n\n    async def get_by_id_at_time_async(self, order_id: str, at_time: datetime) -&gt; Optional[OrderAggregate]:\n        \"\"\"Temporal query - get aggregate state at specific time.\"\"\"\n        events = await self.event_store.get_events_before_async(f\"order-{order_id}\", at_time)\n        if not events:\n            return None\n\n        # Rebuild state up to specific point in time\n        order = OrderAggregate(order_id)\n        for event in events:\n            order.state.on(event)\n\n        return order\n\n# 5. Complex Command Handler\nclass PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    def __init__(self, order_repository: EventSourcedOrderRepository, unit_of_work: IUnitOfWork):\n        self.order_repository = order_repository\n        self.unit_of_work = unit_of_work\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        try:\n            # Create new aggregate\n            order = OrderAggregate()\n\n            # Rich business logic with validation\n            order.place_order(command.customer_id, command.items)\n\n            # Event sourcing persistence\n            await self.order_repository.save_async(order)\n\n            # Register for event dispatching\n            self.unit_of_work.register_aggregate(order)\n\n            # Return rich result\n            return self.created(OrderDto.from_aggregate(order))\n\n        except DomainException as ex:\n            return self.bad_request(str(ex))\n        except Exception as ex:\n            return self.internal_server_error(f\"Failed to place order: {str(ex)}\")\n</code></pre>"},{"location":"patterns/persistence-patterns/#event-store-schema-example","title":"Event Store Schema Example","text":"<pre><code>// Events are stored as immutable history\n{\n  \"_id\": \"evt-12345\",\n  \"stream_id\": \"order-abc123\",\n  \"event_type\": \"OrderPlacedEvent\",\n  \"event_version\": 1,\n  \"timestamp\": ISODate(\"2024-01-01T10:00:00Z\"),\n  \"data\": {\n    \"order_id\": \"abc123\",\n    \"customer_id\": \"cust456\",\n    \"items\": [\n      {\"product_id\": \"prod789\", \"quantity\": 2, \"unit_price\": 29.99}\n    ],\n    \"total_amount\": 59.98,\n    \"placed_at\": \"2024-01-01T10:00:00Z\"\n  }\n}\n\n// Temporal queries - state at any point in time\nevents = db.events.find({\n  stream_id: \"order-abc123\",\n  timestamp: {$lte: ISODate(\"2024-01-01T12:00:00Z\")}\n}).sort({event_version: 1})\n\n// Projections for read models\ndb.order_summary.aggregate([\n  {$match: {event_type: \"OrderPlacedEvent\"}},\n  {$group: {\n    _id: \"$data.customer_id\",\n    total_orders: {$sum: 1},\n    total_amount: {$sum: \"$data.total_amount\"}\n  }}\n])\n</code></pre>"},{"location":"patterns/persistence-patterns/#benefits-trade-offs_1","title":"Benefits &amp; Trade-offs","text":""},{"location":"patterns/persistence-patterns/#benefits_1","title":"\u2705 Benefits","text":"<ul> <li>Complete audit trail and compliance</li> <li>Rich business logic enforcement</li> <li>Temporal queries (state at any point in time)</li> <li>Event-driven integrations</li> <li>Scalable read models through projections</li> <li>Business rule consistency</li> <li>Historical analysis capabilities</li> </ul>"},{"location":"patterns/persistence-patterns/#trade-offs_1","title":"\u26a0\ufe0f Trade-offs","text":"<ul> <li>Significant complexity increase</li> <li>Event store infrastructure required</li> <li>Event versioning and migration challenges</li> <li>Projection building and maintenance</li> <li>Eventual consistency considerations</li> <li>Steeper learning curve</li> </ul>"},{"location":"patterns/persistence-patterns/#best-use-cases_1","title":"Best Use Cases","text":"<ul> <li>Complex business domains with rich logic</li> <li>Audit and compliance requirements</li> <li>Temporal analysis and reporting</li> <li>Event-driven system integrations</li> <li>High consistency requirements</li> <li>Long-term maintainability over initial complexity</li> </ul>"},{"location":"patterns/persistence-patterns/#pattern-3-hybrid-approach","title":"\ud83d\udd04 Pattern 3: Hybrid Approach","text":"<p>Complexity Level: \u2b50\u2b50\u2b50\u2606\u2606 (Moderate)</p>"},{"location":"patterns/persistence-patterns/#overview_2","title":"Overview","text":"<p>The pragmatic approach that combines both patterns within the same application, using the right tool for each domain area based on complexity and requirements.</p>"},{"location":"patterns/persistence-patterns/#implementation-strategy","title":"Implementation Strategy","text":"<pre><code># Order Management - Complex domain with event sourcing\nclass OrderAggregate(AggregateRoot[OrderState, str]):\n    def place_order(self, customer_id: str, items: List[OrderItem]):\n        # Complex business logic with event sourcing\n        self._validate_order_invariants(customer_id, items)\n        event = OrderPlacedEvent(self.id, customer_id, items, datetime.utcnow())\n        self.state.on(event)\n        self.register_event(event)\n\n# Product Catalog - Simple CRUD with state persistence\nclass Product(Entity):\n    def update_price(self, new_price: Decimal):\n        # Simple business logic with state persistence\n        self.price = new_price\n        self._raise_domain_event(ProductPriceUpdatedEvent(self.id, new_price))\n\n# Customer Profile - Mixed approach based on operation complexity\nclass Customer(Entity):\n    def update_profile(self, name: str, email: str):\n        # Simple state update\n        self.name = name\n        self.email = email\n        self._raise_domain_event(CustomerProfileUpdatedEvent(self.id, name, email))\n\n    def process_loyalty_upgrade(self, new_tier: str, earned_points: int):\n        # More complex business logic that could warrant event sourcing\n        if self._qualifies_for_tier(new_tier, earned_points):\n            self.loyalty_tier = new_tier\n            self.loyalty_points += earned_points\n            self._raise_domain_event(CustomerLoyaltyUpgradedEvent(\n                self.id, new_tier, earned_points, self._calculate_benefits()\n            ))\n\n# Single handler coordinating both patterns\nclass ProcessOrderHandler(CommandHandler):\n    async def handle_async(self, command: ProcessOrderCommand):\n        # Event-sourced aggregate for complex order logic\n        order = await self.order_repository.get_by_id_async(command.order_id)\n        order.confirm_payment(command.payment_details)\n        await self.order_repository.save_async(order)\n        self.unit_of_work.register_aggregate(order)\n\n        # Simple entity for inventory update\n        for item in order.state.items:\n            inventory = await self.inventory_repository.get_by_product_id(item.product_id)\n            inventory.reduce_stock(item.quantity)  # Simple state update\n            await self.inventory_repository.save_async(inventory)\n            self.unit_of_work.register_aggregate(inventory)\n\n        # Customer update using appropriate complexity level\n        customer = await self.customer_repository.get_by_id_async(order.state.customer_id)\n        customer.record_purchase(order.state.total_amount)  # Could be simple or complex\n        await self.customer_repository.save_async(customer)\n        self.unit_of_work.register_aggregate(customer)\n\n        return self.ok({\"order_id\": order.id})\n</code></pre>"},{"location":"patterns/persistence-patterns/#benefits-trade-offs_2","title":"Benefits &amp; Trade-offs","text":""},{"location":"patterns/persistence-patterns/#benefits_2","title":"\u2705 Benefits","text":"<ul> <li>Right tool for each domain area</li> <li>Incremental adoption of event sourcing</li> <li>Flexible based on changing requirements</li> <li>Team can learn gradually</li> <li>Optimize for specific use cases</li> </ul>"},{"location":"patterns/persistence-patterns/#trade-offs_2","title":"\u26a0\ufe0f Trade-offs","text":"<ul> <li>Mixed complexity across codebase</li> <li>Multiple infrastructure requirements</li> <li>Team needs to understand both patterns</li> <li>Consistency in approach decisions</li> </ul>"},{"location":"patterns/persistence-patterns/#decision-framework","title":"\ud83c\udfaf Decision Framework","text":""},{"location":"patterns/persistence-patterns/#step-1-assess-domain-complexity","title":"Step 1: Assess Domain Complexity","text":"<p>Ask these questions for each bounded context:</p> <pre><code>flowchart TD\n    START[New Bounded Context] --&gt; Q1{Complex Business Rules?}\n\n    Q1 --&gt;|Yes| Q2{Audit Requirements?}\n    Q1 --&gt;|No| SIMPLE[Simple Entity + State]\n\n    Q2 --&gt;|Yes| Q3{Temporal Queries Needed?}\n    Q2 --&gt;|No| Q4{Performance Critical?}\n\n    Q3 --&gt;|Yes| COMPLEX[Aggregate Root + Events]\n    Q3 --&gt;|No| Q5{Team Experience?}\n\n    Q4 --&gt;|Yes| SIMPLE\n    Q4 --&gt;|No| Q5\n\n    Q5 --&gt;|High| COMPLEX\n    Q5 --&gt;|Low| SIMPLE\n\n    SIMPLE --&gt; SIMPLE_IMPL[\u2705 Entity inheritance&lt;br/&gt;\u2705 State persistence&lt;br/&gt;\u2705 Simple events&lt;br/&gt;\u2705 Direct queries]\n\n    COMPLEX --&gt; COMPLEX_IMPL[\u2705 AggregateRoot&lt;br/&gt;\u2705 Event sourcing&lt;br/&gt;\u2705 Rich domain logic&lt;br/&gt;\u2705 Event store]</code></pre>"},{"location":"patterns/persistence-patterns/#step-2-evaluate-technical-constraints","title":"Step 2: Evaluate Technical Constraints","text":"Constraint Simple Entity Aggregate Root Hybrid Team Experience \u2705 Any level \u274c Advanced DDD \u26a0\ufe0f Mixed Infrastructure \u2705 Any database \u274c Event store required \u26a0\ufe0f Both needed Development Speed \u2705 Very fast \u274c Slower initial \u26a0\ufe0f Variable Query Performance \u2705 Direct DB \u274c Projection building \u26a0\ufe0f Mixed Audit Requirements \u274c Manual \u2705 Automatic \u26a0\ufe0f Partial"},{"location":"patterns/persistence-patterns/#step-3-implementation-planning","title":"Step 3: Implementation Planning","text":""},{"location":"patterns/persistence-patterns/#for-simple-entity-state-persistence","title":"For Simple Entity + State Persistence","text":"<ol> <li>Define Entities: Inherit from <code>Entity</code>, add business methods</li> <li>Design Events: Simple integration events for key business occurrences</li> <li>Create Repositories: Traditional state-based persistence</li> <li>Write Handlers: Straightforward command/query handlers</li> </ol>"},{"location":"patterns/persistence-patterns/#for-aggregate-root-event-sourcing","title":"For Aggregate Root + Event Sourcing","text":"<ol> <li>Design Aggregate Boundaries: Identify consistency boundaries</li> <li>Model Events: Rich domain events with full business context</li> <li>Define State: Separate state classes with event handlers</li> <li>Create Aggregates: Complex business logic with invariant enforcement</li> <li>Setup Event Store: Specialized event storage infrastructure</li> <li>Build Projections: Read models for queries</li> </ol>"},{"location":"patterns/persistence-patterns/#for-hybrid-approach","title":"For Hybrid Approach","text":"<ol> <li>Analyze Each Context: Apply decision framework per bounded context</li> <li>Start Simple: Begin with Entity pattern, migrate to AggregateRoot as needed</li> <li>Consistent Patterns: Use same pattern within bounded context</li> <li>Clear Documentation: Document which pattern is used where and why</li> </ol>"},{"location":"patterns/persistence-patterns/#integration-with-framework-features","title":"\ud83d\udd17 Integration with Framework Features","text":"<p>All persistence patterns integrate seamlessly with Neuroglia's core features:</p>"},{"location":"patterns/persistence-patterns/#cqrs-integration","title":"CQRS Integration","text":"<pre><code># Commands use appropriate persistence pattern\nclass CreateOrderHandler(CommandHandler):  # Can use Entity or AggregateRoot\n    pass\n\n# Queries work with both patterns\nclass GetOrderHandler(QueryHandler):       # Queries state or projections\n    pass\n</code></pre>"},{"location":"patterns/persistence-patterns/#unit-of-work-integration","title":"Unit of Work Integration","text":"<pre><code># Same UnitOfWork works with both patterns\nclass OrderHandler(CommandHandler):\n    async def handle_async(self, command):\n        # Works with Entity\n        product = Product(command.name, command.price)\n        self.unit_of_work.register_aggregate(product)\n\n        # Works with AggregateRoot\n        order = OrderAggregate()\n        order.place_order(command.customer_id, command.items)\n        self.unit_of_work.register_aggregate(order)\n\n        # Same event dispatching for both\n        return self.created(result)\n</code></pre>"},{"location":"patterns/persistence-patterns/#pipeline-behaviors-integration","title":"Pipeline Behaviors Integration","text":"<pre><code># Same pipeline works with both patterns\nservices.add_scoped(PipelineBehavior, ValidationBehavior)           # Validate inputs\nservices.add_scoped(PipelineBehavior, TransactionBehavior)          # Manage transactions\nservices.add_scoped(PipelineBehavior, DomainEventDispatchingMiddleware)  # Dispatch events\nservices.add_scoped(PipelineBehavior, LoggingBehavior)             # Log execution\n</code></pre>"},{"location":"patterns/persistence-patterns/#related-documentation","title":"\ud83d\udcda Related Documentation","text":"<ul> <li>\ud83d\udd04 Unit of Work Pattern - Coordination layer for both patterns</li> <li>\ud83c\udfaf Simple CQRS - Command/Query handling for both patterns</li> <li>\ud83d\udd27 Pipeline Behaviors - Cross-cutting concerns</li> <li>\ud83c\udfdb\ufe0f Domain Driven Design - Comprehensive DDD guidance</li> <li>\ud83d\udce6 Repository Pattern - Data access abstraction</li> <li>\ud83d\udce1 Event-Driven Architecture - Event handling patterns</li> </ul> <p>Choose the persistence pattern that fits your domain complexity and team capabilities. Start simple and evolve toward complexity only when the business value justifies the additional investment.</p>"},{"location":"patterns/pipeline-behaviors/","title":"\ud83d\udd27 Pipeline Behaviors","text":"<p>Estimated reading time: 20 minutes</p> <p>Pipeline behaviors provide a powerful way to implement cross-cutting concerns in the Neuroglia mediation pipeline. They enable you to add functionality like validation, logging, caching, transactions, and domain event dispatching around command and query execution.</p>"},{"location":"patterns/pipeline-behaviors/#what-why","title":"\ud83d\udca1 What &amp; Why","text":""},{"location":"patterns/pipeline-behaviors/#the-problem-cross-cutting-concerns-scattered-across-handlers","title":"\u274c The Problem: Cross-Cutting Concerns Scattered Across Handlers","text":"<p>When cross-cutting concerns are implemented in every handler, code becomes duplicated and inconsistent:</p> <pre><code># \u274c PROBLEM: Logging, validation, and error handling duplicated in every handler\nclass CreateOrderHandler(CommandHandler[CreateOrderCommand, OperationResult[OrderDto]]):\n    async def handle_async(self, command: CreateOrderCommand):\n        # Logging duplicated in EVERY handler\n        self.logger.info(f\"Creating order for customer {command.customer_id}\")\n        start_time = time.time()\n\n        try:\n            # Validation duplicated in EVERY handler\n            if not command.customer_id:\n                return self.validation_error(\"Customer ID required\")\n            if not command.items:\n                return self.validation_error(\"At least one item required\")\n\n            # Business logic (the ONLY thing that should be here!)\n            order = Order.create(command.customer_id, command.items)\n            await self.repository.save_async(order)\n\n            # Logging duplicated in EVERY handler\n            duration = time.time() - start_time\n            self.logger.info(f\"Order created in {duration:.2f}s\")\n\n            return self.created(order)\n\n        except Exception as ex:\n            # Error handling duplicated in EVERY handler\n            self.logger.error(f\"Failed to create order: {ex}\")\n            return self.internal_server_error(\"Failed to create order\")\n\nclass ConfirmOrderHandler(CommandHandler[ConfirmOrderCommand, OperationResult[OrderDto]]):\n    async def handle_async(self, command: ConfirmOrderCommand):\n        # SAME logging code copy-pasted!\n        self.logger.info(f\"Confirming order {command.order_id}\")\n        start_time = time.time()\n\n        try:\n            # SAME validation code copy-pasted!\n            if not command.order_id:\n                return self.validation_error(\"Order ID required\")\n\n            # Business logic\n            order = await self.repository.get_by_id_async(command.order_id)\n            order.confirm()\n            await self.repository.save_async(order)\n\n            # SAME logging code copy-pasted!\n            duration = time.time() - start_time\n            self.logger.info(f\"Order confirmed in {duration:.2f}s\")\n\n            return self.ok(order)\n\n        except Exception as ex:\n            # SAME error handling copy-pasted!\n            self.logger.error(f\"Failed to confirm order: {ex}\")\n            return self.internal_server_error(\"Failed to confirm order\")\n\n# Problems:\n# \u274c Logging code duplicated in 50+ handlers\n# \u274c Validation logic scattered everywhere\n# \u274c Error handling inconsistent across handlers\n# \u274c Hard to change logging format or validation rules\n# \u274c Handlers doing TOO MUCH (violates Single Responsibility)\n# \u274c Difficult to add new cross-cutting concerns\n</code></pre> <p>Problems with Scattered Cross-Cutting Concerns:</p> <ul> <li>\u274c Code Duplication: Same logging/validation/error handling code in every handler</li> <li>\u274c Inconsistency: Each handler implements concerns slightly differently</li> <li>\u274c Violates SRP: Handlers mix business logic with infrastructure concerns</li> <li>\u274c Hard to Change: Updating logging format requires changing 50+ handlers</li> <li>\u274c Difficult to Test: Must test logging/validation in every handler</li> <li>\u274c Hard to Add Concerns: Adding caching requires modifying all handlers</li> </ul>"},{"location":"patterns/pipeline-behaviors/#the-solution-pipeline-behaviors-for-centralized-cross-cutting-concerns","title":"\u2705 The Solution: Pipeline Behaviors for Centralized Cross-Cutting Concerns","text":"<p>Pipeline behaviors wrap handlers to provide cross-cutting functionality in one place:</p> <pre><code># \u2705 SOLUTION: Pipeline behaviors centralize cross-cutting concerns\nfrom neuroglia.mediation.pipeline_behavior import PipelineBehavior\n\n# Logging Behavior - ONE place for all logging!\nclass LoggingBehavior(PipelineBehavior[Any, Any]):\n    def __init__(self, logger: ILogger):\n        self.logger = logger\n\n    async def handle_async(self, request, next_handler):\n        request_name = type(request).__name__\n        self.logger.info(f\"Executing {request_name}\")\n        start_time = time.time()\n\n        try:\n            result = await next_handler()  # Execute handler\n\n            duration = time.time() - start_time\n            self.logger.info(f\"Completed {request_name} in {duration:.2f}s\")\n            return result\n\n        except Exception as ex:\n            self.logger.error(f\"Failed {request_name}: {ex}\")\n            raise\n\n# Validation Behavior - ONE place for all validation!\nclass ValidationBehavior(PipelineBehavior[Command, OperationResult]):\n    async def handle_async(self, request, next_handler):\n        # Validate request (using validator for this command type)\n        validator = self._get_validator(type(request))\n        if validator:\n            validation_result = await validator.validate_async(request)\n            if not validation_result.is_valid:\n                return OperationResult.validation_error(validation_result.errors)\n\n        # Continue if valid\n        return await next_handler()\n\n# Error Handling Behavior - ONE place for all error handling!\nclass ErrorHandlingBehavior(PipelineBehavior[Any, OperationResult]):\n    async def handle_async(self, request, next_handler):\n        try:\n            return await next_handler()\n        except ValidationException as ex:\n            return OperationResult.validation_error(ex.message)\n        except NotFoundException as ex:\n            return OperationResult.not_found(ex.message)\n        except Exception as ex:\n            self.logger.exception(f\"Unhandled error: {ex}\")\n            return OperationResult.internal_error(\"An unexpected error occurred\")\n\n# Now handlers are CLEAN and focused!\nclass CreateOrderHandler(CommandHandler[CreateOrderCommand, OperationResult[OrderDto]]):\n    async def handle_async(self, command: CreateOrderCommand):\n        # ONLY business logic - no logging, validation, or error handling!\n        order = Order.create(command.customer_id, command.items)\n        await self.repository.save_async(order)\n        return self.created(order)\n\nclass ConfirmOrderHandler(CommandHandler[ConfirmOrderCommand, OperationResult[OrderDto]]):\n    async def handle_async(self, command: ConfirmOrderCommand):\n        # ONLY business logic!\n        order = await self.repository.get_by_id_async(command.order_id)\n        order.confirm()\n        await self.repository.save_async(order)\n        return self.ok(order)\n\n# Register pipeline behaviors once\nservices = ServiceCollection()\nservices.add_scoped(PipelineBehavior, LoggingBehavior)\nservices.add_scoped(PipelineBehavior, ValidationBehavior)\nservices.add_scoped(PipelineBehavior, ErrorHandlingBehavior)\n\n# Pipeline wraps EVERY handler automatically:\n# Request \u2192 LoggingBehavior \u2192 ValidationBehavior \u2192 ErrorHandlingBehavior \u2192 Handler\n</code></pre> <p>Benefits of Pipeline Behaviors:</p> <ul> <li>\u2705 No Duplication: Cross-cutting concerns in one place</li> <li>\u2705 Consistency: All handlers get same logging/validation/error handling</li> <li>\u2705 Single Responsibility: Handlers focus only on business logic</li> <li>\u2705 Easy to Change: Update logging format in one behavior</li> <li>\u2705 Easy to Test: Test behaviors once, not in every handler</li> <li>\u2705 Composable: Chain multiple behaviors together</li> <li>\u2705 Easy to Add Concerns: Add caching by adding one behavior</li> </ul>"},{"location":"patterns/pipeline-behaviors/#overview","title":"\ud83c\udfaf Overview","text":"<p>Pipeline behaviors implement the decorator pattern, wrapping around command and query handlers to provide additional functionality without modifying the core business logic.</p>"},{"location":"patterns/pipeline-behaviors/#key-benefits","title":"Key Benefits","text":"<ul> <li>\ud83d\udd04 Cross-Cutting Concerns: Implement validation, logging, caching consistently</li> <li>\ud83d\udce6 Composable: Chain multiple behaviors together</li> <li>\ud83c\udfaf Single Responsibility: Keep handlers focused on business logic</li> <li>\ud83d\udd27 Reusable: Apply same behavior across multiple handlers</li> <li>\u26a1 Performance: Add caching, monitoring, optimization layers</li> </ul>"},{"location":"patterns/pipeline-behaviors/#basic-implementation","title":"\ud83c\udfd7\ufe0f Basic Implementation","text":""},{"location":"patterns/pipeline-behaviors/#creating-a-pipeline-behavior","title":"Creating a Pipeline Behavior","text":"<pre><code>from neuroglia.mediation.pipeline_behavior import PipelineBehavior\nfrom neuroglia.core import OperationResult\n\nclass LoggingBehavior(PipelineBehavior[Any, Any]):\n    async def handle_async(self, request, next_handler):\n        request_name = type(request).__name__\n\n        # Pre-processing\n        logger.info(f\"Executing {request_name}\")\n        start_time = time.time()\n\n        try:\n            # Continue pipeline\n            result = await next_handler()\n\n            # Post-processing\n            duration = time.time() - start_time\n            logger.info(f\"Completed {request_name} in {duration:.2f}s\")\n\n            return result\n\n        except Exception as ex:\n            logger.error(f\"Failed {request_name}: {ex}\")\n            raise\n</code></pre>"},{"location":"patterns/pipeline-behaviors/#registration","title":"Registration","text":"<pre><code>from neuroglia.dependency_injection import ServiceCollection\nfrom neuroglia.mediation.pipeline_behavior import PipelineBehavior\n\nservices = ServiceCollection()\nservices.add_mediator()\nservices.add_scoped(PipelineBehavior, LoggingBehavior)\n</code></pre>"},{"location":"patterns/pipeline-behaviors/#common-patterns","title":"\ud83d\ude80 Common Patterns","text":""},{"location":"patterns/pipeline-behaviors/#validation-behavior","title":"Validation Behavior","text":"<pre><code>class ValidationBehavior(PipelineBehavior[Command, OperationResult]):\n    async def handle_async(self, request, next_handler):\n        # Validate request\n        validation_result = await self._validate_request(request)\n        if not validation_result.is_valid:\n            return OperationResult.validation_error(validation_result.errors)\n\n        # Continue if valid\n        return await next_handler()\n\n    async def _validate_request(self, request):\n        # Implement validation logic\n        return ValidationResult(is_valid=True)\n</code></pre>"},{"location":"patterns/pipeline-behaviors/#caching-behavior","title":"Caching Behavior","text":"<pre><code>class CachingBehavior(PipelineBehavior[Query, Any]):\n    def __init__(self, cache_service: CacheService):\n        self.cache = cache_service\n\n    async def handle_async(self, request, next_handler):\n        # Generate cache key\n        cache_key = self._generate_cache_key(request)\n\n        # Check cache first\n        cached_result = await self.cache.get_async(cache_key)\n        if cached_result:\n            return cached_result\n\n        # Execute query\n        result = await next_handler()\n\n        # Cache result\n        await self.cache.set_async(cache_key, result, ttl=300)\n\n        return result\n</code></pre>"},{"location":"patterns/pipeline-behaviors/#performance-monitoring","title":"Performance Monitoring","text":"<pre><code>class PerformanceBehavior(PipelineBehavior[Any, Any]):\n    async def handle_async(self, request, next_handler):\n        request_name = type(request).__name__\n\n        with self.metrics.timer(f\"request.{request_name}.duration\"):\n            try:\n                result = await next_handler()\n                self.metrics.increment(f\"request.{request_name}.success\")\n                return result\n\n            except Exception:\n                self.metrics.increment(f\"request.{request_name}.error\")\n                raise\n</code></pre>"},{"location":"patterns/pipeline-behaviors/#behavior-chaining","title":"\ud83d\udd17 Behavior Chaining","text":"<p>Behaviors execute in registration order, forming a pipeline:</p> <pre><code># Registration order determines execution order\nservices.add_scoped(PipelineBehavior, ValidationBehavior)      # 1st\nservices.add_scoped(PipelineBehavior, CachingBehavior)         # 2nd\nservices.add_scoped(PipelineBehavior, PerformanceBehavior)     # 3rd\nservices.add_scoped(PipelineBehavior, LoggingBehavior)         # 4th\n\n# Execution flow:\n# ValidationBehavior -&gt; CachingBehavior -&gt; PerformanceBehavior -&gt; LoggingBehavior -&gt; Handler\n</code></pre>"},{"location":"patterns/pipeline-behaviors/#conditional-behavior","title":"Conditional Behavior","text":"<pre><code>class ConditionalBehavior(PipelineBehavior[Command, OperationResult]):\n    async def handle_async(self, request, next_handler):\n        # Only apply to specific command types\n        if isinstance(request, CriticalCommand):\n            # Add extra processing for critical commands\n            await self._notify_administrators(request)\n\n        return await next_handler()\n</code></pre>"},{"location":"patterns/pipeline-behaviors/#testing-pipeline-behaviors","title":"\ud83e\uddea Testing Pipeline Behaviors","text":""},{"location":"patterns/pipeline-behaviors/#unit-testing","title":"Unit Testing","text":"<pre><code>@pytest.mark.asyncio\nasync def test_logging_behavior_logs_execution():\n    behavior = LoggingBehavior()\n    request = TestCommand(\"test\")\n\n    async def mock_next_handler():\n        return OperationResult(\"OK\", 200)\n\n    result = await behavior.handle_async(request, mock_next_handler)\n\n    assert result.status_code == 200\n    # Verify logging occurred\n</code></pre>"},{"location":"patterns/pipeline-behaviors/#integration-testing","title":"Integration Testing","text":"<pre><code>@pytest.mark.asyncio\nasync def test_full_pipeline_execution():\n    # Setup complete pipeline\n    services = ServiceCollection()\n    services.add_mediator()\n    services.add_scoped(PipelineBehavior, ValidationBehavior)\n    services.add_scoped(PipelineBehavior, LoggingBehavior)\n\n    provider = services.build_provider()\n    mediator = provider.get_service(Mediator)\n\n    # Execute through full pipeline\n    command = CreateUserCommand(\"test@example.com\")\n    result = await mediator.execute_async(command)\n\n    assert result.is_success\n</code></pre>"},{"location":"patterns/pipeline-behaviors/#advanced-scenarios","title":"\ud83d\udd27 Advanced Scenarios","text":""},{"location":"patterns/pipeline-behaviors/#type-specific-behaviors","title":"Type-Specific Behaviors","text":"<pre><code>class CommandValidationBehavior(PipelineBehavior[Command, OperationResult]):\n    \"\"\"Only applies to commands, not queries\"\"\"\n\n    async def handle_async(self, request: Command, next_handler):\n        # Command-specific validation\n        if not hasattr(request, 'user_id'):\n            return self.bad_request(\"user_id is required for all commands\")\n\n        return await next_handler()\n\nclass QueryCachingBehavior(PipelineBehavior[Query, Any]):\n    \"\"\"Only applies to queries, not commands\"\"\"\n\n    async def handle_async(self, request: Query, next_handler):\n        # Query-specific caching logic\n        return await self._cache_query_result(request, next_handler)\n</code></pre>"},{"location":"patterns/pipeline-behaviors/#error-handling-behavior","title":"Error Handling Behavior","text":"<pre><code>class ErrorHandlingBehavior(PipelineBehavior[Any, OperationResult]):\n    async def handle_async(self, request, next_handler):\n        try:\n            return await next_handler()\n\n        except ValidationException as ex:\n            return OperationResult.validation_error(ex.message)\n\n        except BusinessRuleException as ex:\n            return OperationResult.business_error(ex.message)\n\n        except Exception as ex:\n            logger.exception(f\"Unhandled error in {type(request).__name__}\")\n            return OperationResult.internal_error(\"An unexpected error occurred\")\n</code></pre>"},{"location":"patterns/pipeline-behaviors/#common-mistakes","title":"\u26a0\ufe0f Common Mistakes","text":""},{"location":"patterns/pipeline-behaviors/#1-modifying-request-in-pipeline-side-effects","title":"1. Modifying Request in Pipeline (Side Effects)","text":"<pre><code># \u274c WRONG: Modifying request object (side effects!)\nclass NormalizationBehavior(PipelineBehavior):\n    async def handle_async(self, request, next_handler):\n        # Don't modify the request!\n        request.email = request.email.lower().strip()\n        return await next_handler()\n\n# \u2705 CORRECT: Handler normalizes data, or use separate validation step\nclass CreateUserHandler:\n    async def handle_async(self, command: CreateUserCommand):\n        # Normalize in handler\n        email = command.email.lower().strip()\n        user = User(email=email)\n        return self.created(user)\n</code></pre>"},{"location":"patterns/pipeline-behaviors/#2-forgetting-to-call-next_handler","title":"2. Forgetting to Call next_handler()","text":"<pre><code># \u274c WRONG: Not calling next_handler (pipeline stops!)\nclass BrokenBehavior(PipelineBehavior):\n    async def handle_async(self, request, next_handler):\n        self.logger.info(\"Executing...\")\n        # FORGOT to call next_handler()!\n        return None  # Handler never executes!\n\n# \u2705 CORRECT: Always call next_handler()\nclass WorkingBehavior(PipelineBehavior):\n    async def handle_async(self, request, next_handler):\n        self.logger.info(\"Executing...\")\n        return await next_handler()  # Handler executes!\n</code></pre>"},{"location":"patterns/pipeline-behaviors/#3-order-dependent-behaviors-without-explicit-ordering","title":"3. Order-Dependent Behaviors Without Explicit Ordering","text":"<pre><code># \u274c WRONG: Assuming behavior order (undefined!)\nservices.add_scoped(PipelineBehavior, AuthenticationBehavior)\nservices.add_scoped(PipelineBehavior, AuthorizationBehavior)\n# Order is NOT guaranteed! Authorization might run before authentication!\n\n# \u2705 CORRECT: Use explicit ordering or numbered behaviors\nclass AuthenticationBehavior(PipelineBehavior):\n    order = 1  # Run first\n\nclass AuthorizationBehavior(PipelineBehavior):\n    order = 2  # Run after authentication\n\n# Or chain explicitly in one behavior\nclass SecurityBehavior(PipelineBehavior):\n    async def handle_async(self, request, next_handler):\n        # Authenticate first\n        user = await self.authenticate(request)\n        if not user:\n            return self.unauthorized()\n\n        # Then authorize\n        if not await self.authorize(user, request):\n            return self.forbidden()\n\n        return await next_handler()\n</code></pre>"},{"location":"patterns/pipeline-behaviors/#4-expensive-operations-in-every-request","title":"4. Expensive Operations in Every Request","text":"<pre><code># \u274c WRONG: Database queries in every pipeline invocation\nclass AuditBehavior(PipelineBehavior):\n    async def handle_async(self, request, next_handler):\n        # Database query for EVERY request!\n        audit_settings = await self.db.settings.find_one({\"type\": \"audit\"})\n\n        if audit_settings[\"enabled\"]:\n            await self.log_audit(request)\n\n        return await next_handler()\n\n# \u2705 CORRECT: Cache expensive lookups\nclass AuditBehavior(PipelineBehavior):\n    def __init__(self, cache_service: ICacheService):\n        self.cache = cache_service\n        self._audit_enabled = None\n\n    async def handle_async(self, request, next_handler):\n        # Cache the setting\n        if self._audit_enabled is None:\n            settings = await self.db.settings.find_one({\"type\": \"audit\"})\n            self._audit_enabled = settings[\"enabled\"]\n\n        if self._audit_enabled:\n            await self.log_audit(request)\n\n        return await next_handler()\n</code></pre>"},{"location":"patterns/pipeline-behaviors/#5-catching-all-exceptions-without-re-raising","title":"5. Catching All Exceptions Without Re-Raising","text":"<pre><code># \u274c WRONG: Swallowing exceptions (hides errors!)\nclass SilentErrorBehavior(PipelineBehavior):\n    async def handle_async(self, request, next_handler):\n        try:\n            return await next_handler()\n        except Exception as ex:\n            self.logger.error(f\"Error: {ex}\")\n            return None  # Swallowed! Caller doesn't know about error!\n\n# \u2705 CORRECT: Handle specific exceptions or re-raise\nclass ErrorHandlingBehavior(PipelineBehavior):\n    async def handle_async(self, request, next_handler):\n        try:\n            return await next_handler()\n        except ValidationException as ex:\n            # Handle specific exception\n            return OperationResult.validation_error(ex.message)\n        except Exception as ex:\n            # Log and re-raise unknown exceptions\n            self.logger.exception(f\"Unhandled error: {ex}\")\n            raise  # Re-raise so caller knows!\n</code></pre>"},{"location":"patterns/pipeline-behaviors/#6-not-using-scoped-lifetime","title":"6. Not Using Scoped Lifetime","text":"<pre><code># \u274c WRONG: Singleton lifetime (shared state across requests!)\nservices.add_singleton(PipelineBehavior, RequestContextBehavior)\n# Same behavior instance for ALL requests - shared state!\n\n# \u2705 CORRECT: Scoped lifetime (one per request)\nservices.add_scoped(PipelineBehavior, RequestContextBehavior)\n# Each request gets fresh behavior instance\n</code></pre>"},{"location":"patterns/pipeline-behaviors/#when-not-to-use","title":"\ud83d\udeab When NOT to Use","text":""},{"location":"patterns/pipeline-behaviors/#1-business-logic-belongs-in-handlers","title":"1. Business Logic (Belongs in Handlers)","text":"<pre><code># \u274c WRONG: Business logic in pipeline behavior\nclass InventoryCheckBehavior(PipelineBehavior):\n    async def handle_async(self, request, next_handler):\n        if isinstance(request, CreateOrderCommand):\n            # This is business logic, not cross-cutting!\n            for item in request.items:\n                if not await self.inventory.has_stock(item.product_id):\n                    return OperationResult.validation_error(\"Out of stock\")\n\n        return await next_handler()\n\n# \u2705 CORRECT: Business logic in handler\nclass CreateOrderHandler:\n    async def handle_async(self, command: CreateOrderCommand):\n        # Check inventory as part of business logic\n        for item in command.items:\n            if not await self.inventory.has_stock(item.product_id):\n                return self.validation_error(\"Out of stock\")\n\n        order = Order.create(command.items)\n        return self.created(order)\n</code></pre>"},{"location":"patterns/pipeline-behaviors/#2-request-specific-logic","title":"2. Request-Specific Logic","text":"<pre><code># Pipeline behaviors should be generic across ALL requests\n# Don't create behaviors for specific commands/queries\n\n# \u274c WRONG: Behavior for ONE specific command\nclass CreateOrderSpecificBehavior(PipelineBehavior):\n    async def handle_async(self, request, next_handler):\n        if isinstance(request, CreateOrderCommand):\n            # Logic specific to CreateOrderCommand\n            pass\n        return await next_handler()\n\n# \u2705 CORRECT: Put command-specific logic in handler\n</code></pre>"},{"location":"patterns/pipeline-behaviors/#3-simple-applications-without-cross-cutting-concerns","title":"3. Simple Applications Without Cross-Cutting Concerns","text":"<pre><code># For very simple apps, pipeline behaviors add unnecessary complexity\nclass SimpleTodoApp:\n    \"\"\"Simple todo app with 3 commands\"\"\"\n    # Just implement handlers directly, no need for pipeline\n    async def create_todo(self, title: str):\n        todo = Todo(title=title)\n        await self.db.todos.insert_one(todo)\n        return todo\n</code></pre>"},{"location":"patterns/pipeline-behaviors/#4-one-off-requirements","title":"4. One-Off Requirements","text":"<pre><code># Don't create a behavior for something used only once\n# Put it in the handler instead\n\n# \u274c WRONG: Behavior used by only ONE handler\nclass SendWelcomeEmailBehavior(PipelineBehavior):\n    async def handle_async(self, request, next_handler):\n        result = await next_handler()\n        if isinstance(request, CreateUserCommand):\n            await self.email.send_welcome(request.email)\n        return result\n\n# \u2705 CORRECT: Put in handler\nclass CreateUserHandler:\n    async def handle_async(self, command: CreateUserCommand):\n        user = User(command.email)\n        await self.repository.save_async(user)\n        await self.email.send_welcome(user.email)  # Specific to this handler\n        return self.created(user)\n</code></pre>"},{"location":"patterns/pipeline-behaviors/#5-performance-critical-tight-loops","title":"5. Performance-Critical Tight Loops","text":"<pre><code># Pipeline behaviors add overhead - avoid for very high-throughput scenarios\nclass HighFrequencyMetricHandler:\n    \"\"\"Processes thousands of metrics per second\"\"\"\n    async def handle_async(self, command: RecordMetricCommand):\n        # Direct implementation without pipeline overhead\n        await self.metrics.record(command.metric_name, command.value)\n</code></pre>"},{"location":"patterns/pipeline-behaviors/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ul> <li>Pipeline behaviors implement cross-cutting concerns centrally</li> <li>Wrap handlers using decorator pattern for composable functionality</li> <li>Keep handlers focused on business logic by extracting infrastructure concerns</li> <li>Common behaviors: Logging, validation, error handling, caching, transactions</li> <li>Always call next_handler() to continue the pipeline</li> <li>Use scoped lifetime for request-specific state</li> <li>Order matters for dependent behaviors (auth before authorization)</li> <li>Don't put business logic in behaviors - keep them generic</li> <li>Avoid modifying requests - behaviors should be side-effect free</li> <li>Framework provides PipelineBehavior base class for easy implementation</li> </ul>"},{"location":"patterns/pipeline-behaviors/#related-documentation","title":"\ud83d\udcda Related Documentation","text":"<ul> <li>State-Based Persistence - Domain event dispatching</li> <li>CQRS Mediation - Core command/query patterns</li> <li>Dependency Injection - Service registration</li> </ul> <p>Pipeline behaviors provide a clean, composable way to add cross-cutting functionality to your CQRS application while keeping your handlers focused on business logic.</p>"},{"location":"patterns/rationales/","title":"\ud83c\udfaf How to Choose the Right Data Modeling Patterns","text":"<p>\ud83d\udea7 Work in Progress: This documentation is being updated to include beginner-friendly explanations with What &amp; Why sections, Common Mistakes, and When NOT to Use guidance. The content below is accurate but will be enhanced soon.</p> <p>This document provides a comprehensive guide for choosing and progressing through different data modeling patterns in the Neuroglia framework, from simple entities to complex event-sourced aggregates with declarative resource management. It shows the natural evolution path and when to adopt each pattern based on system complexity and requirements.</p>"},{"location":"patterns/rationales/#the-evolution-path","title":"\ud83c\udfaf The Evolution Path","text":"<p>Data modeling in complex systems naturally evolves through distinct stages, each adding capabilities to handle increasing complexity. The Neuroglia framework supports this progression seamlessly:</p> <p>\ud83d\udd04 Evolution Stages:</p> <ol> <li>Simple Entities \u2192 Basic CRUD operations with direct repository access</li> <li>DDD Aggregates + UnitOfWork \u2192 Rich domain models with transactional consistency and side effects</li> <li>Event Sourcing \u2192 Complete audit trail with write/read model separation</li> <li>Declarative Resources \u2192 Autonomous infrastructure management and reconciliation</li> </ol> <p>\ud83c\udfaf Key Insight: Each stage builds upon the previous one, and you can adopt them incrementally as your system's complexity grows. Most systems benefit from combining multiple patterns for different aspects of the domain.</p>"},{"location":"patterns/rationales/#pattern-progression-from-simple-to-complex","title":"\ud83c\udfd7\ufe0f Pattern Progression: From Simple to Complex","text":""},{"location":"patterns/rationales/#stage-1-simple-entities-with-direct-repository-access","title":"\ud83d\udcdd Stage 1: Simple Entities with Direct Repository Access","text":"<p>When to use: Simple CRUD applications, minimal business logic, straightforward data operations.</p> <p>Implementation Pattern:</p> <pre><code># Simple entity - just data structure\nclass Order(Entity):\n    def __init__(self, customer_id: str, items: List[OrderItem]):\n        super().__init__()\n        self.customer_id = customer_id\n        self.items = items\n        self.status = OrderStatus.PENDING\n        self.total = sum(item.price * item.quantity for item in items)\n\n# Generic repository for basic persistence\nclass OrderRepository(Repository[Order, str]):\n    async def save(self, order: Order) -&gt; None:\n        await self.collection.replace_one({\"_id\": order.id}, order.to_dict(), upsert=True)\n\n# Direct command handler - no transactions, no events\nclass CreateOrderHandler(CommandHandler[CreateOrderCommand, OperationResult[OrderDto]]):\n    def __init__(self, order_repository: OrderRepository, mapper: Mapper):\n        self.order_repository = order_repository\n        self.mapper = mapper\n\n    async def handle_async(self, command: CreateOrderCommand) -&gt; OperationResult[OrderDto]:\n        # Simple: create entity and save directly\n        order = Order(command.customer_id, command.items)\n        await self.order_repository.save(order)\n\n        order_dto = self.mapper.map(order, OrderDto)\n        return self.created(order_dto)\n</code></pre> <p>Characteristics:</p> <ul> <li>\u2705 Simplicity: Minimal complexity, easy to understand</li> <li>\u2705 Performance: Direct database operations, no overhead</li> <li>\u274c No Transactions: Each operation is isolated</li> <li>\u274c No Events: No side effects or integration capabilities</li> <li>\u274c Limited Business Logic: Basic validation only</li> </ul>"},{"location":"patterns/rationales/#stage-2-ddd-aggregates-with-unitofwork-pattern","title":"\ud83c\udfdb\ufe0f Stage 2: DDD Aggregates with UnitOfWork Pattern","text":"<p>When to use: Complex business rules, need for transactional consistency, side effects coordination.</p> <p>Implementation Pattern:</p> <pre><code># Rich aggregate root with business logic and domain events\nclass Order(AggregateRoot):\n    def __init__(self, customer_id: str, items: List[OrderItem]):\n        super().__init__()\n        self.customer_id = customer_id\n        self.items = items\n        self.status = OrderStatus.PENDING\n        self.total = self._calculate_total()\n\n        # Domain event for side effects\n        self.raise_event(OrderCreatedEvent(\n            order_id=self.id,\n            customer_id=self.customer_id,\n            total_amount=self.total\n        ))\n\n    def confirm_payment(self, payment_method: PaymentMethod) -&gt; None:\n        if self.status != OrderStatus.PENDING:\n            raise BusinessRuleViolationError(\"Can only confirm pending orders\")\n\n        self.status = OrderStatus.CONFIRMED\n        self.payment_method = payment_method\n\n        # Business event triggers kitchen workflow\n        self.raise_event(OrderPaymentConfirmedEvent(\n            order_id=self.id,\n            total_amount=self.total\n        ))\n\n# Command handler with UnitOfWork for transactional consistency\nclass ConfirmPaymentHandler(CommandHandler[ConfirmPaymentCommand, OperationResult]):\n    def __init__(self, order_repository: OrderRepository, unit_of_work: IUnitOfWork):\n        self.order_repository = order_repository\n        self.unit_of_work = unit_of_work\n\n    async def handle_async(self, command: ConfirmPaymentCommand) -&gt; OperationResult:\n        # Load aggregate\n        order = await self.order_repository.get_by_id_async(command.order_id)\n\n        # Execute business logic (generates domain events)\n        order.confirm_payment(command.payment_method)\n\n        # Save state changes\n        await self.order_repository.save_async(order)\n\n        # Register aggregate for event collection and dispatch\n        self.unit_of_work.register_aggregate(order)\n\n        # Events automatically dispatched after successful persistence\n        return self.success()\n</code></pre> <p>Characteristics:</p> <ul> <li>\u2705 Rich Business Logic: Complex domain rules and validation</li> <li>\u2705 Transactional Consistency: UnitOfWork coordinates persistence and events</li> <li>\u2705 Domain Events: Side effects triggered after successful persistence</li> <li>\u2705 State-Based Storage: Current aggregate state saved to database</li> <li>\u274c No Audit Trail: Historical changes not preserved</li> <li>\u274c Tight Coupling: Write and read models are the same</li> </ul>"},{"location":"patterns/rationales/#stage-3-event-sourcing-with-read-model-separation","title":"\ud83d\udcda Stage 3: Event Sourcing with Read Model Separation","text":"<p>When to use: Audit requirements, temporal queries, complex read models, regulatory compliance.</p> <p>Implementation Pattern:</p> <pre><code># Event-sourced aggregate - state derived from events\nclass Order(EventSourcedAggregateRoot):\n    def __init__(self, order_id: str = None):\n        super().__init__(order_id)\n        self.customer_id = None\n        self.items = []\n        self.status = OrderStatus.PENDING\n        self.total = Decimal('0.00')\n\n    def create_order(self, customer_id: str, items: List[OrderItem]) -&gt; None:\n        # Generate event instead of directly modifying state\n        event = OrderCreatedEvent(\n            order_id=self.id,\n            customer_id=customer_id,\n            items=items,\n            total_amount=sum(item.price * item.quantity for item in items)\n        )\n        self.apply_event(event)\n\n    def confirm_payment(self, payment_method: PaymentMethod) -&gt; None:\n        if self.status != OrderStatus.PENDING:\n            raise BusinessRuleViolationError(\"Can only confirm pending orders\")\n\n        event = OrderPaymentConfirmedEvent(\n            order_id=self.id,\n            payment_method=payment_method,\n            confirmed_at=datetime.utcnow()\n        )\n        self.apply_event(event)\n\n    # Event application methods (state transitions)\n    def _apply_order_created_event(self, event: OrderCreatedEvent) -&gt; None:\n        self.customer_id = event.customer_id\n        self.items = event.items\n        self.total = event.total_amount\n\n    def _apply_order_payment_confirmed_event(self, event: OrderPaymentConfirmedEvent) -&gt; None:\n        self.status = OrderStatus.CONFIRMED\n        self.payment_method = event.payment_method\n\n# Event store for write model (stores events, not state)\nclass EventSourcedOrderRepository(EventStore[Order]):\n    async def save_async(self, aggregate: Order) -&gt; None:\n        # Store all uncommitted events\n        events = aggregate.get_uncommitted_events()\n        await self.append_events_async(aggregate.id, events, aggregate.version)\n        aggregate.mark_events_as_committed()\n\n    async def get_by_id_async(self, order_id: str) -&gt; Order:\n        # Rebuild aggregate from stored events\n        events = await self.get_events_async(order_id)\n        order = Order(order_id)\n        order.load_from_history(events)\n        return order\n\n# Separate read model for queries\n@dataclass\nclass OrderReadModel:\n    order_id: str\n    customer_id: str\n    status: str\n    total_amount: Decimal\n    created_at: datetime\n    confirmed_at: Optional[datetime] = None\n\n# Read model projector (rebuilds read models when events occur)\nclass OrderReadModelProjector(DomainEventHandler[OrderCreatedEvent, OrderPaymentConfirmedEvent]):\n    def __init__(self, read_model_repository: Repository[OrderReadModel, str]):\n        self.read_model_repository = read_model_repository\n\n    async def handle_async(self, event: OrderCreatedEvent) -&gt; None:\n        read_model = OrderReadModel(\n            order_id=event.order_id,\n            customer_id=event.customer_id,\n            status=OrderStatus.PENDING.value,\n            total_amount=event.total_amount,\n            created_at=event.occurred_at\n        )\n        await self.read_model_repository.save_async(read_model)\n\n    async def handle_async(self, event: OrderPaymentConfirmedEvent) -&gt; None:\n        read_model = await self.read_model_repository.get_by_id_async(event.order_id)\n        read_model.status = OrderStatus.CONFIRMED.value\n        read_model.confirmed_at = event.occurred_at\n        await self.read_model_repository.save_async(read_model)\n</code></pre> <p>Characteristics:</p> <ul> <li>\u2705 Complete Audit Trail: Every change preserved as immutable events</li> <li>\u2705 Temporal Queries: Can reconstruct state at any point in time</li> <li>\u2705 Optimized Read Models: Separate, specialized views for queries</li> <li>\u2705 Event Replay: Can rebuild read models from scratch</li> <li>\u274c Increased Complexity: Event application, projections, eventual consistency</li> <li>\u274c Storage Overhead: Events accumulate over time</li> </ul>"},{"location":"patterns/rationales/#stage-4-declarative-resources-with-autonomous-reconciliation","title":"\ud83c\udf10 Stage 4: Declarative Resources with Autonomous Reconciliation","text":"<p>When to use: Infrastructure management, autonomous operations, complex system coordination.</p> <p>Implementation Pattern:</p> <pre><code># Declarative resource - desired vs actual state\n@dataclass\nclass KitchenCapacityResource(Resource):\n    spec: KitchenCapacitySpec\n    status: KitchenCapacityStatus\n\n    @classmethod\n    def increase_capacity_for_order(cls, order_value: Decimal) -&gt; 'KitchenCapacityResource':\n        # Calculate required capacity based on business rules\n        required_ovens = math.ceil(order_value / Decimal('100.00'))\n\n        return cls(\n            spec=KitchenCapacitySpec(\n                required_ovens=required_ovens,\n                target_throughput=order_value * Decimal('0.1')\n            ),\n            status=KitchenCapacityStatus(\n                current_ovens=0,\n                current_throughput=Decimal('0.00'),\n                reconciliation_state=\"pending\"\n            )\n        )\n\n# Resource controller - autonomous reconciliation engine\nclass KitchenCapacityController(ResourceControllerBase[KitchenCapacityResource]):\n    def __init__(self, infrastructure_client: InfrastructureClient, event_bus: EventBus):\n        super().__init__()\n        self.infrastructure_client = infrastructure_client\n        self.event_bus = event_bus\n\n    async def _do_reconcile(self, resource: KitchenCapacityResource) -&gt; ReconciliationResult:\n        desired_ovens = resource.spec.required_ovens\n        current_ovens = resource.status.current_ovens\n\n        if desired_ovens &gt; current_ovens:\n            # Provision additional capacity\n            await self.infrastructure_client.provision_oven()\n            resource.status.current_ovens += 1\n            resource.status.reconciliation_state = \"provisioning\"\n\n            # Publish integration event\n            await self.event_bus.publish(KitchenCapacityIncreasedEvent(\n                resource_id=resource.id,\n                new_capacity=resource.status.current_ovens\n            ))\n\n        elif desired_ovens &lt; current_ovens:\n            # Scale down capacity\n            await self.infrastructure_client.decommission_oven()\n            resource.status.current_ovens -= 1\n            resource.status.reconciliation_state = \"scaling_down\"\n\n        else:\n            resource.status.reconciliation_state = \"stable\"\n\n        return ReconciliationResult.success()\n\n# Integration event handler - bridges business domain to infrastructure\nclass OrderPaymentConfirmedIntegrationHandler(IntegrationEventHandler[OrderPaymentConfirmedEvent]):\n    def __init__(self, resource_repository: Repository[KitchenCapacityResource, str]):\n        self.resource_repository = resource_repository\n\n    async def handle_async(self, event: OrderPaymentConfirmedEvent) -&gt; None:\n        # Business event triggers infrastructure adaptation\n        capacity_resource = KitchenCapacityResource.increase_capacity_for_order(event.total_amount)\n        await self.resource_repository.save_async(capacity_resource)\n\n        # Resource controller will automatically reconcile the infrastructure\n</code></pre> <p>Characteristics:</p> <ul> <li>\u2705 Autonomous Operations: Self-healing, self-scaling infrastructure</li> <li>\u2705 Declarative Management: Specify desired state, system achieves it</li> <li>\u2705 Integration Events: Bridge between business domain and infrastructure</li> <li>\u2705 Eventual Consistency: Continuous reconciliation toward desired state</li> <li>\u274c Operational Complexity: Requires robust monitoring and error handling</li> <li>\u274c Debugging Complexity: Async reconciliation can be harder to trace## \ufffd Combining Patterns: Real-World Integration</li> </ul>"},{"location":"patterns/rationales/#multi-stage-system-example","title":"\ud83d\udca1 Multi-Stage System Example","text":"<p>Most complex systems benefit from using different patterns for different aspects. Here's how they work together:</p> <pre><code># Stage 1: Simple entities for basic data (User profiles, settings)\nclass UserProfile(Entity):\n    def update_email(self, new_email: str) -&gt; None:\n        self.email = new_email\n        self.updated_at = datetime.utcnow()\n\n# Stage 2: DDD aggregates for core business logic (Orders, payments)\nclass Order(AggregateRoot):\n    def confirm_payment(self, payment_info: PaymentInfo) -&gt; None:\n        if not self._validate_payment(payment_info):\n            raise InvalidPaymentError(\"Payment validation failed\")\n\n        self.status = OrderStatus.CONFIRMED\n        self.raise_event(OrderPaymentConfirmedEvent(\n            order_id=self.id,\n            amount=self.total_amount\n        ))\n\n# Stage 3: Event sourcing for audit-critical domains (Financial transactions)\nclass PaymentTransaction(EventSourcedAggregateRoot):\n    def process_payment(self, amount: Decimal, method: PaymentMethod) -&gt; None:\n        event = PaymentProcessedEvent(\n            transaction_id=self.id,\n            amount=amount,\n            method=method,\n            processed_at=datetime.utcnow()\n        )\n        self.apply_event(event)\n\n# Stage 4: Declarative resources for infrastructure (Kitchen capacity, delivery routes)\nclass DeliveryRouteResource(Resource):\n    spec: DeliveryRouteSpec      # Desired route optimization\n    status: DeliveryRouteStatus  # Current route state\n\n# Integration through events and shared UnitOfWork\nclass OrderConfirmationHandler(DomainEventHandler[OrderPaymentConfirmedEvent]):\n    async def handle_async(self, event: OrderPaymentConfirmedEvent) -&gt; None:\n        # Trigger financial transaction (event sourced)\n        transaction = PaymentTransaction.create_for_order(event.order_id, event.amount)\n        transaction.process_payment(event.amount, PaymentMethod.CREDIT_CARD)\n\n        # Update delivery capacity (declarative resource)\n        delivery_resource = await self.get_delivery_resource()\n        delivery_resource.spec.add_delivery_requirement(event.order_id)\n\n        # Both handled by UnitOfWork for transactional consistency\n        self.unit_of_work.register_aggregate(transaction)\n        self.unit_of_work.register_aggregate(delivery_resource)\n</code></pre>"},{"location":"patterns/rationales/#decision-framework-when-to-use-each-pattern","title":"\ud83c\udfaf Decision Framework: When to Use Each Pattern","text":""},{"location":"patterns/rationales/#pattern-selection-matrix","title":"\ud83d\udcca Pattern Selection Matrix","text":"Criteria Simple Entities DDD + UnitOfWork Event Sourcing Declarative Resources Business Complexity Low High High N/A (Infrastructure) Audit Requirements None Basic Complete Operational only Team Experience Any Intermediate Advanced Advanced Performance Needs High Good Complex Excellent Consistency Requirements Eventual Strong Strong Eventual Infrastructure Complexity Manual Manual Manual Autonomous"},{"location":"patterns/rationales/#decision-tree","title":"\ud83d\udea6 Decision Tree","text":"<pre><code>flowchart TD\n    A[New System/Feature] --&gt; B{Complex Business Rules?}\n    B --&gt;|No| C[Simple Entities]\n    B --&gt;|Yes| D{Audit Requirements?}\n\n    D --&gt;|Heavy| E[Event Sourcing]\n    D --&gt;|Normal| F[DDD + UnitOfWork]\n\n    C --&gt; G{Infrastructure Management?}\n    F --&gt; G\n    E --&gt; G\n\n    G --&gt;|Manual| H[Traditional Ops]\n    G --&gt;|Autonomous| I[Add Declarative Resources]\n\n    style C fill:#90EE90\n    style F fill:#FFD700\n    style E fill:#FF6B6B\n    style I fill:#87CEEB</code></pre>"},{"location":"patterns/rationales/#progression-guidelines","title":"\ud83c\udfaf Progression Guidelines","text":"<p>\ud83d\ude80 Start Simple, Evolve Gradually</p> <ol> <li>Begin with Simple Entities for basic CRUD operations</li> <li>Add DDD + UnitOfWork when business complexity grows</li> <li>Consider Event Sourcing when audit trails become critical</li> <li>Introduce Declarative Resources for infrastructure automation</li> </ol> <p>\u26a1 Migration Strategies</p> <pre><code># Phase 1: Simple Entity\nclass Order(Entity):\n    status: OrderStatus\n    items: List[OrderItem]\n\n# Phase 2: Add Domain Events (DDD)\nclass Order(AggregateRoot):\n    def confirm_order(self):\n        self.status = OrderStatus.CONFIRMED\n        self.raise_event(OrderConfirmedEvent(...))\n\n# Phase 3: Add Event Sourcing (if needed)\nclass Order(EventSourcedAggregateRoot):\n    def confirm_order(self):\n        event = OrderConfirmedEvent(...)\n        self.apply_event(event)\n\n# Phase 4: Add Infrastructure Resources\nclass OrderProcessingResource(Resource):\n    spec: ProcessingCapacitySpec\n    status: ProcessingCapacityStatus\n</code></pre>"},{"location":"patterns/rationales/#testing-strategy-by-pattern","title":"\ud83e\uddea Testing Strategy by Pattern","text":""},{"location":"patterns/rationales/#simple-entities-testing","title":"\ud83e\uddea Simple Entities Testing","text":"<pre><code>class TestUserProfile:\n    def test_update_email(self):\n        # Arrange\n        profile = UserProfile(user_id=\"123\", email=\"old@example.com\")\n\n        # Act\n        profile.update_email(\"new@example.com\")\n\n        # Assert\n        assert profile.email == \"new@example.com\"\n        assert profile.updated_at is not None\n</code></pre>"},{"location":"patterns/rationales/#ddd-unitofwork-testing","title":"\ud83e\uddea DDD + UnitOfWork Testing","text":"<pre><code>class TestOrderAggregate:\n    async def test_confirm_payment_with_events(self):\n        # Arrange\n        order = Order(customer_id=\"123\", items=[pizza_item])\n        payment_handler = ConfirmPaymentHandler(order_repo, unit_of_work)\n\n        # Act\n        result = await payment_handler.handle_async(ConfirmPaymentCommand(\n            order_id=order.id,\n            payment_method=PaymentMethod.CREDIT_CARD\n        ))\n\n        # Assert - Business logic\n        assert result.is_success\n        assert order.status == OrderStatus.CONFIRMED\n\n        # Assert - Domain events\n        events = order.get_uncommitted_events()\n        assert len(events) == 1\n        assert isinstance(events[0], OrderPaymentConfirmedEvent)\n\n        # Assert - Side effects triggered\n        mock_event_bus.publish.assert_called_with(events[0])\n</code></pre>"},{"location":"patterns/rationales/#event-sourcing-testing","title":"\ud83e\uddea Event Sourcing Testing","text":"<pre><code>class TestEventSourcedOrder:\n    async def test_event_application_and_replay(self):\n        # Arrange - Create events\n        events = [\n            OrderCreatedEvent(order_id=\"123\", customer_id=\"456\", items=[...]),\n            OrderPaymentConfirmedEvent(order_id=\"123\", payment_method=\"CREDIT\")\n        ]\n\n        # Act - Replay events\n        order = Order(\"123\")\n        order.load_from_history(events)\n\n        # Assert - State derived from events\n        assert order.customer_id == \"456\"\n        assert order.status == OrderStatus.CONFIRMED\n\n        # Test new event application\n        order.ship_order()\n        new_events = order.get_uncommitted_events()\n        assert len(new_events) == 1\n        assert isinstance(new_events[0], OrderShippedEvent)\n</code></pre>"},{"location":"patterns/rationales/#declarative-resources-testing","title":"\ud83e\uddea Declarative Resources Testing","text":"<pre><code>class TestKitchenCapacityController:\n    async def test_reconciliation_scales_up(self):\n        # Arrange - Resource needs more capacity\n        resource = KitchenCapacityResource(\n            spec=KitchenCapacitySpec(required_ovens=5),\n            status=KitchenCapacityStatus(current_ovens=2)\n        )\n\n        controller = KitchenCapacityController(mock_infra_client, event_bus)\n\n        # Act - Trigger reconciliation\n        result = await controller._do_reconcile(resource)\n\n        # Assert - Infrastructure provisioned\n        assert result.is_success\n        mock_infra_client.provision_oven.assert_called()\n\n        # Assert - Status updated\n        assert resource.status.current_ovens == 3\n        assert resource.status.reconciliation_state == \"provisioning\"\n\n        # Assert - Integration event published\n        event_bus.publish.assert_called_with(\n            KitchenCapacityIncreasedEvent(resource_id=resource.id, new_capacity=3)\n        )\n</code></pre>"},{"location":"patterns/rationales/#common-anti-patterns-and-solutions","title":"\ud83c\udfaf Common Anti-Patterns and Solutions","text":""},{"location":"patterns/rationales/#anti-pattern-1-wrong-pattern-for-complexity-level","title":"\u274c Anti-Pattern 1: Wrong Pattern for Complexity Level","text":"<pre><code># \u274c Using DDD for simple CRUD\nclass UserSettings(AggregateRoot):  # Overkill!\n    def update_theme(self, theme: str):\n        if theme not in VALID_THEMES:\n            raise InvalidThemeError()\n        self.theme = theme\n        self.raise_event(UserThemeChangedEvent(...))  # Unnecessary complexity\n\n# \u2705 Simple entity is sufficient\nclass UserSettings(Entity):\n    def update_theme(self, theme: str):\n        if theme not in VALID_THEMES:\n            raise ValueError(f\"Invalid theme: {theme}\")\n        self.theme = theme\n</code></pre>"},{"location":"patterns/rationales/#anti-pattern-2-missing-transactional-boundaries","title":"\u274c Anti-Pattern 2: Missing Transactional Boundaries","text":"<pre><code># \u274c No UnitOfWork - events fired before persistence\nclass BadOrderHandler:\n    async def handle(self, command: CreateOrderCommand):\n        order = Order(command.customer_id, command.items)\n\n        # Events fired immediately - could fail before save!\n        await self.event_bus.publish_all(order.get_uncommitted_events())\n        await self.order_repo.save(order)  # Could fail!\n\n# \u2705 UnitOfWork ensures events only fire after successful persistence\nclass GoodOrderHandler:\n    async def handle(self, command: CreateOrderCommand):\n        order = Order(command.customer_id, command.items)\n        await self.order_repo.save(order)\n\n        # UnitOfWork handles event dispatch after commit\n        self.unit_of_work.register_aggregate(order)\n</code></pre>"},{"location":"patterns/rationales/#anti-pattern-3-event-sourcing-without-read-models","title":"\u274c Anti-Pattern 3: Event Sourcing Without Read Models","text":"<pre><code># \u274c Querying event store directly for read operations\nclass BadOrderQueryHandler:\n    async def get_orders_by_customer(self, customer_id: str):\n        # Terrible performance - rebuilding aggregates for queries!\n        orders = []\n        for order_id in await self.get_order_ids_by_customer(customer_id):\n            events = await self.event_store.get_events(order_id)\n            order = Order(order_id)\n            order.load_from_history(events)\n            orders.append(order)\n        return orders\n\n# \u2705 Dedicated read models for efficient queries\nclass GoodOrderQueryHandler:\n    async def get_orders_by_customer(self, customer_id: str):\n        # Fast query against optimized read model\n        return await self.order_read_model_repo.find_by_customer(customer_id)\n</code></pre>"},{"location":"patterns/rationales/#best-practices-summary","title":"\ud83c\udfc6 Best Practices Summary","text":""},{"location":"patterns/rationales/#pattern-selection-checklist","title":"\ud83d\udccb Pattern Selection Checklist","text":"<p>Before choosing a pattern, ask:</p> <ol> <li> <p>Business Complexity: How complex are the business rules?</p> </li> <li> <p>Simple \u2192 Simple Entities</p> </li> <li> <p>Complex \u2192 DDD Aggregates</p> </li> <li> <p>Audit Requirements: Do you need complete history?</p> </li> <li> <p>No \u2192 State-based persistence</p> </li> <li> <p>Yes \u2192 Event Sourcing</p> </li> <li> <p>Infrastructure Complexity: How much operational automation is needed?</p> </li> <li> <p>Manual \u2192 Traditional repositories</p> </li> <li> <p>Autonomous \u2192 Declarative Resources</p> </li> <li> <p>Team Experience: What's the team's skill level?</p> </li> <li> <p>Junior \u2192 Start simple, evolve gradually</p> </li> <li> <p>Senior \u2192 Can adopt complex patterns immediately</p> </li> <li> <p>Performance Requirements: What are the latency/throughput needs?</p> </li> <li>High performance \u2192 Avoid event sourcing complexity</li> <li>Audit critical \u2192 Accept event sourcing overhead</li> </ol>"},{"location":"patterns/rationales/#testing-implications","title":"\ud83e\uddea Testing Implications","text":""},{"location":"patterns/rationales/#testing-both-patterns-together","title":"Testing Both Patterns Together","text":"<pre><code>class TestOrderWithInfrastructure:\n    async def test_order_placement_triggers_infrastructure_scaling(self):\n        # Arrange: Setup both domain and infrastructure\n        order_service = self.get_service(OrderService)\n        kitchen_controller = self.get_service(KitchenCapacityController)\n\n        # Act: Domain operation\n        result = await order_service.place_order(large_order_command)\n\n        # Assert: Both business and infrastructure effects\n        assert result.is_success\n\n        # Business assertion (DDD)\n        order = await self.order_repo.get_by_id(result.data.order_id)\n        assert order.status == OrderStatus.CONFIRMED\n\n        # Infrastructure assertion (Declarative)\n        kitchen_resource = await self.resource_repo.get_kitchen_capacity()\n        assert kitchen_resource.spec.required_capacity &gt; initial_capacity\n\n        # Event coordination assertion\n        events = self.event_collector.get_events()\n        assert any(isinstance(e, OrderPlacedEvent) for e in events)\n        assert any(isinstance(e, KitchenCapacityUpdatedEvent) for e in events)\n</code></pre>"},{"location":"patterns/rationales/#decision-framework","title":"\ud83c\udfaf Decision Framework","text":""},{"location":"patterns/rationales/#choose-your-pattern-combination","title":"Choose Your Pattern Combination","text":"<pre><code>flowchart TD\n    A[System Analysis] --&gt; B{Complex Business Logic?}\n    B --&gt;|Yes| C[Use DDD]\n    B --&gt;|No| D[Use Simple Entities]\n\n    C --&gt; E{Infrastructure Complexity?}\n    D --&gt; E\n\n    E --&gt;|High| F[Add Declarative Resources]\n    E --&gt;|Low| G[Manual Infrastructure]\n\n    F --&gt; H{Audit Requirements?}\n    G --&gt; H\n\n    H --&gt;|Heavy| I[Use Event Sourcing]\n    H --&gt;|Normal| J[Use State-Based Persistence]\n\n    I --&gt; K[Enterprise Pattern Stack]\n    J --&gt; L[Balanced Pattern Stack]\n\n    style K fill:#ff9999\n    style L fill:#99ff99</code></pre>"},{"location":"patterns/rationales/#pattern-selection-criteria","title":"Pattern Selection Criteria","text":"Criteria Weight DDD Declarative Event Sourcing State-Based Business Complexity High \u2705 Essential \u2796 Optional \u26a0\ufe0f Consider \u2705 Good Infrastructure Complexity High \u2796 Optional \u2705 Essential \u2796 Optional \u2705 Good Audit Requirements High \u2705 Good \u2796 Optional \u2705 Essential \u26a0\ufe0f Limited Team Experience Medium \u26a0\ufe0f Learning curve \u26a0\ufe0f Learning curve \u274c Complex \u2705 Familiar Performance Requirements Medium \u2705 Good \u2705 Excellent \u26a0\ufe0f Complex \u2705 Excellent Operational Complexity Medium \u2796 Manual \u2705 Autonomous \u26a0\ufe0f Complex \u2705 Simple"},{"location":"patterns/rationales/#migration-strategies","title":"\ud83d\ude80 Migration Strategies","text":""},{"location":"patterns/rationales/#from-simple-to-complex","title":"From Simple to Complex","text":"<pre><code># Phase 1: Start with simple entities\nclass Order(Entity):\n    def add_pizza(self, pizza):\n        self.pizzas.append(pizza)\n        # Direct database save\n\n# Phase 2: Add domain events (still state-based)\nclass Order(AggregateRoot):\n    def add_pizza(self, pizza):\n        self.pizzas.append(pizza)\n        self.raise_event(PizzaAddedEvent(...))  # Added events\n\n# Phase 3: Add declarative infrastructure\nclass KitchenCapacityResource:\n    spec: KitchenCapacitySpec\n    status: KitchenCapacityStatus\n    # Autonomous scaling based on order events\n\n# Phase 4: Consider event sourcing (if needed)\nclass Order(EventSourcedAggregateRoot):\n    def add_pizza(self, pizza):\n        self.apply_event(PizzaAddedEvent(...))  # Event-sourced\n</code></pre>"},{"location":"patterns/rationales/#framework-support-matrix","title":"\ud83d\udcda Framework Support Matrix","text":"Pattern Neuroglia Support Implementation Effort Learning Curve DDD + State-Based \u2705 Full support \u2b50\u2b50\u2b50 Medium \u2b50\u2b50\u2b50 Medium Declarative Resources \u2705 Full support \u2b50\u2b50\u2b50\u2b50 High \u2b50\u2b50\u2b50\u2b50 High Event Sourcing \u2705 Full support \u2b50\u2b50\u2b50\u2b50\u2b50 Very High \u2b50\u2b50\u2b50\u2b50\u2b50 Very High Combined Approach \u2705 Full support \u2b50\u2b50\u2b50\u2b50 High \u2b50\u2b50\u2b50\u2b50 High"},{"location":"patterns/rationales/#conclusion-the-progressive-data-modeling-approach","title":"\ud83c\udfaf Conclusion: The Progressive Data Modeling Approach","text":"<p>The key insight from this analysis is that data modeling patterns form a natural progression rather than competing alternatives. Each pattern builds upon the previous one, adding capabilities to handle increasing system complexity:</p>"},{"location":"patterns/rationales/#the-evolution-principle","title":"\ud83d\udd04 The Evolution Principle","text":"<ol> <li>Start Simple: Begin with simple entities for basic functionality</li> <li>Add Sophistication: Introduce DDD when business rules become complex</li> <li>Enable Auditability: Add event sourcing when history tracking is critical</li> <li>Automate Operations: Include declarative resources for infrastructure management</li> </ol>"},{"location":"patterns/rationales/#pattern-synergy","title":"\ud83c\udfaf Pattern Synergy","text":"<p>The most powerful systems combine multiple patterns strategically:</p> <ul> <li>Simple Entities for basic data (user preferences, configuration)</li> <li>DDD Aggregates for core business logic (orders, payments, workflows)</li> <li>Event Sourcing for audit-critical domains (financial transactions, compliance)</li> <li>Declarative Resources for infrastructure (scaling, provisioning, monitoring)</li> </ul>"},{"location":"patterns/rationales/#practical-recommendations","title":"\ud83d\ude80 Practical Recommendations","text":"<p>For New Projects:</p> <ol> <li>Start with Stage 1 (Simple Entities) to validate core functionality</li> <li>Evolve to Stage 2 (DDD + UnitOfWork) as business complexity grows</li> <li>Consider Stage 3 (Event Sourcing) only when audit requirements are clear</li> <li>Add Stage 4 (Declarative Resources) when operational complexity demands automation</li> </ol> <p>For Existing Projects:</p> <ul> <li>Assess current pain points to determine which pattern addresses them</li> <li>Migrate incrementally - don't try to adopt all patterns simultaneously</li> <li>Focus on the biggest problem first (business complexity vs operational complexity)</li> </ul>"},{"location":"patterns/rationales/#key-success-factors","title":"\ud83d\udca1 Key Success Factors","text":"<ol> <li>Match Pattern to Problem: Don't use complex patterns for simple problems</li> <li>Embrace Progressive Enhancement: Each stage adds capabilities without breaking existing functionality</li> <li>Leverage Neuroglia's Integration: The framework handles the coordination between patterns seamlessly</li> <li>Test Thoroughly: Each pattern has specific testing requirements and techniques</li> </ol> <p>The Neuroglia framework's strength lies in supporting this evolutionary approach, allowing teams to adopt sophisticated patterns gradually while maintaining system stability and developer productivity.</p>"},{"location":"patterns/rationales/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\ud83c\udfd7\ufe0f Clean Architecture - Structural foundation for all patterns</li> <li>\ud83c\udfdb\ufe0f Domain Driven Design - Rich domain modeling with aggregates</li> <li>\ud83d\udcda Event Sourcing - Complete audit trails and temporal queries</li> <li>\ufffd Resource Oriented Architecture - Declarative infrastructure management</li> <li>\ud83d\udd04 Unit of Work Pattern - Transactional consistency across patterns</li> <li>\ud83d\udce1 Event-Driven Architecture - Integration foundation for all approaches</li> </ul>"},{"location":"patterns/reactive-programming/","title":"\ud83d\udd04 Reactive Programming Pattern","text":"<p>Estimated reading time: 30 minutes</p> <p>The Reactive Programming pattern enables asynchronous, event-driven architectures using Observable streams for handling event flows, background processing, and real-time data transformations. This pattern excels in scenarios requiring responsiveness to continuous data streams and loose coupling between event producers and consumers.</p>"},{"location":"patterns/reactive-programming/#what-why","title":"\ud83d\udca1 What &amp; Why","text":""},{"location":"patterns/reactive-programming/#the-problem-blocking-operations-and-complex-event-coordination","title":"\u274c The Problem: Blocking Operations and Complex Event Coordination","text":"<p>Traditional imperative programming blocks on operations and makes event coordination complex:</p> <pre><code># \u274c PROBLEM: Blocking operations and complex event handling\nclass KitchenDashboardService:\n    async def monitor_orders(self):\n        # Polling approach - inefficient and blocks!\n        while True:\n            # Block waiting for new orders\n            orders = await self.db.orders.find({\"status\": \"pending\"}).to_list()\n\n            for order in orders:\n                # Process each order sequentially - slow!\n                await self.process_order(order)\n                await self.update_capacity()\n                await self.notify_kitchen_staff(order)\n\n            # Wait before checking again - delay!\n            await asyncio.sleep(5)  # 5 second delay before next check\n\n    async def process_multiple_events(self):\n        # Complex coordination of multiple event sources\n        order_events = []\n        payment_events = []\n        inventory_events = []\n\n        # Subscribe to multiple sources (complex!)\n        asyncio.create_task(self.poll_orders(order_events))\n        asyncio.create_task(self.poll_payments(payment_events))\n        asyncio.create_task(self.poll_inventory(inventory_events))\n\n        # Manually coordinate events (error-prone!)\n        while True:\n            if order_events and payment_events:\n                order = order_events.pop(0)\n                payment = payment_events.pop(0)\n\n                # What if events are out of sync?\n                # What if one stream is faster than another?\n                # How do we handle backpressure?\n                await self.match_order_with_payment(order, payment)\n\n            await asyncio.sleep(0.1)\n\n# Problems:\n# \u274c Blocking operations (polling, waiting)\n# \u274c Inefficient (constant polling even with no events)\n# \u274c Complex coordination of multiple event streams\n# \u274c No backpressure handling\n# \u274c Difficult to compose operations (filter, map, aggregate)\n# \u274c Hard to handle errors in streams\n# \u274c No built-in retry or timeout mechanisms\n</code></pre> <p>Problems with Imperative Event Handling:</p> <ul> <li>\u274c Blocking: Operations wait synchronously, wasting resources</li> <li>\u274c Polling Overhead: Constantly checking for events even when none exist</li> <li>\u274c Complex Coordination: Manually managing multiple event streams</li> <li>\u274c No Backpressure: Can't handle fast producers overwhelming slow consumers</li> <li>\u274c Poor Composability: Difficult to chain transformations</li> <li>\u274c Error Handling: Must manually handle errors in each step</li> <li>\u274c Resource Intensive: Many threads/tasks needed for concurrent streams</li> </ul>"},{"location":"patterns/reactive-programming/#the-solution-reactive-streams-with-observable-pattern","title":"\u2705 The Solution: Reactive Streams with Observable Pattern","text":"<p>Reactive programming uses Observable streams for declarative, non-blocking event processing:</p> <pre><code># \u2705 SOLUTION: Reactive streams with Observable pattern\nfrom rx.subject.subject import Subject\nfrom rx import operators as ops\nfrom neuroglia.reactive import AsyncRx\n\n# Create observable stream for order events\norder_stream = Subject()\n\n# Declaratively define event processing pipeline\nsubscription = order_stream.pipe(\n    # Filter: Only process orders above $20\n    ops.filter(lambda order: order.total &gt; 20),\n\n    # Map: Transform to kitchen view\n    ops.map(lambda order: {\n        \"order_id\": order.id,\n        \"items\": order.items,\n        \"priority\": \"high\" if order.total &gt; 100 else \"normal\"\n    }),\n\n    # Buffer: Group orders in 10-second windows\n    ops.buffer_with_time(10.0),\n\n    # Filter: Only process non-empty buffers\n    ops.filter(lambda buffer: len(buffer) &gt; 0),\n\n    # Map: Create batch for kitchen\n    ops.map(lambda orders: {\n        \"batch_id\": str(uuid.uuid4()),\n        \"orders\": orders,\n        \"order_count\": len(orders)\n    })\n).subscribe(\n    on_next=lambda batch: asyncio.create_task(self.process_batch(batch)),\n    on_error=lambda error: logger.error(f\"Stream error: {error}\"),\n    on_completed=lambda: logger.info(\"Stream completed\")\n)\n\n# Events are pushed (non-blocking, reactive!)\nasync def on_order_placed(event: OrderPlacedEvent):\n    order = Order.from_event(event)\n    order_stream.on_next(order)  # Push event into stream\n\n# Complex event coordination made EASY!\nclass ReactiveKitchenService:\n    def __init__(self):\n        self.order_stream = Subject()\n        self.payment_stream = Subject()\n        self.inventory_stream = Subject()\n\n    def setup_reactive_pipeline(self):\n        # Combine multiple streams declaratively\n        combined_stream = AsyncRx.combine_latest(\n            self.order_stream,\n            self.payment_stream,\n            self.inventory_stream\n        ).pipe(\n            # Only when ALL three have events\n            ops.filter(lambda tuple: all(tuple)),\n\n            # Transform combined data\n            ops.map(lambda tuple: {\n                \"order\": tuple[0],\n                \"payment\": tuple[1],\n                \"inventory\": tuple[2]\n            }),\n\n            # Validate we can fulfill\n            ops.filter(lambda data: self.can_fulfill(data)),\n\n            # Add retry logic\n            ops.retry(3),\n\n            # Add timeout\n            ops.timeout(30.0)\n        ).subscribe(\n            on_next=lambda data: asyncio.create_task(self.fulfill_order(data)),\n            on_error=lambda error: self.handle_stream_error(error)\n        )\n\n    async def can_fulfill(self, data: dict) -&gt; bool:\n        \"\"\"Check if order can be fulfilled\"\"\"\n        order = data[\"order\"]\n        inventory = data[\"inventory\"]\n\n        for item in order.items:\n            if inventory.get(item[\"product_id\"], 0) &lt; item[\"quantity\"]:\n                return False\n        return True\n\n# Real-time analytics with reactive streams\nclass OrderAnalyticsService:\n    def __init__(self):\n        self.order_stream = Subject()\n\n    def setup_analytics(self):\n        # Real-time metrics using sliding windows\n        self.order_stream.pipe(\n            # Sliding 5-minute window\n            ops.window_with_time(300.0),\n\n            # Aggregate orders in each window\n            ops.flat_map(lambda window: window.pipe(\n                ops.to_list(),\n                ops.map(lambda orders: {\n                    \"window_end\": datetime.now(),\n                    \"total_orders\": len(orders),\n                    \"total_revenue\": sum(o.total for o in orders),\n                    \"avg_order_value\": sum(o.total for o in orders) / len(orders) if orders else 0\n                })\n            ))\n        ).subscribe(\n            on_next=lambda metrics: self.publish_metrics(metrics)\n        )\n\n# Benefits:\n# \u2705 Non-blocking - events processed as they arrive\n# \u2705 Declarative - pipeline defined once, reused forever\n# \u2705 Composable - easy to chain operations (filter, map, buffer)\n# \u2705 Backpressure - built-in handling of fast producers\n# \u2705 Error handling - built into stream operators\n# \u2705 Retry/timeout - declarative failure handling\n# \u2705 Resource efficient - single stream handles many events\n</code></pre> <p>Benefits of Reactive Programming:</p> <ul> <li>\u2705 Non-Blocking: Events processed asynchronously without waiting</li> <li>\u2705 Push-Based: Events pushed when available, no polling overhead</li> <li>\u2705 Composable: Declaratively chain transformations (filter, map, reduce)</li> <li>\u2705 Backpressure: Handle fast producers and slow consumers gracefully</li> <li>\u2705 Error Resilience: Built-in retry, timeout, and error handling</li> <li>\u2705 Resource Efficient: Single stream processes thousands of events</li> <li>\u2705 Real-Time: Immediate event processing for responsive systems</li> </ul>"},{"location":"patterns/reactive-programming/#pattern-intent","title":"\ud83c\udfaf Pattern Intent","text":"<p>Transform applications from imperative, blocking operations to declarative, non-blocking event streams that react to data changes and events as they occur. Reactive programming enables building responsive, resilient, and scalable systems that handle high-throughput event processing with minimal latency.</p>"},{"location":"patterns/reactive-programming/#pattern-structure","title":"\ud83c\udfd7\ufe0f Pattern Structure","text":"<pre><code>flowchart TD\n    subgraph \"\ud83d\udd04 Reactive Core\"\n        A[\"\ud83d\udce1 Event Sources&lt;br/&gt;Domain Events, External APIs\"]\n        B[\"\ud83c\udf0a Observable Streams&lt;br/&gt;RxPY Integration\"]\n        C[\"\ud83d\udd04 AsyncRx Bridge&lt;br/&gt;Async/Await Integration\"]\n        D[\"\ud83d\udccb Stream Processing&lt;br/&gt;Filter, Map, Reduce\"]\n    end\n\n    subgraph \"\ud83c\udfaf Event Processing Pipeline\"\n        E[\"\ud83d\udd0d Event Filtering&lt;br/&gt;Business Logic\"]\n        F[\"\ud83d\udd04 Event Transformation&lt;br/&gt;Data Mapping\"]\n        G[\"\ud83c\udfad Event Aggregation&lt;br/&gt;State Updates\"]\n        H[\"\ud83d\udce4 Event Distribution&lt;br/&gt;Multiple Handlers\"]\n    end\n\n    subgraph \"\ud83c\udfed Background Services\"\n        I[\"\ud83d\udcca Event Store Reconciliation&lt;br/&gt;Read Model Updates\"]\n        J[\"\ud83d\udd14 Notification Services&lt;br/&gt;Real-time Alerts\"]\n        K[\"\ud83d\udcc8 Analytics Processing&lt;br/&gt;Business Intelligence\"]\n        L[\"\ud83e\uddf9 Maintenance Tasks&lt;br/&gt;Scheduled Operations\"]\n    end\n\n    A --&gt; B\n    B --&gt; C\n    C --&gt; D\n    D --&gt; E\n    E --&gt; F\n    F --&gt; G\n    G --&gt; H\n\n    H --&gt; I\n    H --&gt; J\n    H --&gt; K\n    H --&gt; L\n\n    style B fill:#e1f5fe,stroke:#0277bd,stroke-width:3px\n    style C fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\n    style D fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px\n\n    classDef pipeline fill:#fff3e0,stroke:#f57c00,stroke-width:2px\n    class E,F,G,H pipeline\n\n    classDef services fill:#fce4ec,stroke:#ad1457,stroke-width:2px\n    class I,J,K,L services</code></pre>"},{"location":"patterns/reactive-programming/#pattern-implementation","title":"\ud83c\udf55 Pattern Implementation","text":""},{"location":"patterns/reactive-programming/#core-reactive-components","title":"Core Reactive Components","text":"<pre><code>import asyncio\nfrom typing import List, Callable, Optional, Dict, Any\nfrom rx.subject.subject import Subject\nfrom rx.core.typing import Disposable\nfrom rx import operators as ops\nfrom neuroglia.reactive import AsyncRx\nfrom neuroglia.eventing import DomainEvent\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom enum import Enum\n\n# Domain Events for Reactive Processing\nclass OrderStatus(str, Enum):\n    PLACED = \"placed\"\n    CONFIRMED = \"confirmed\"\n    COOKING = \"cooking\"\n    READY = \"ready\"\n    DELIVERED = \"delivered\"\n\n@dataclass\nclass OrderStatusChangedEvent(DomainEvent):\n    order_id: str\n    previous_status: OrderStatus\n    new_status: OrderStatus\n    timestamp: datetime\n    estimated_completion: datetime\n\n@dataclass\nclass KitchenCapacityEvent(DomainEvent):\n    available_ovens: int\n    current_orders: int\n    estimated_wait_minutes: int\n\n# Reactive Event Processor Pattern\nclass ReactiveEventProcessor:\n    \"\"\"Central reactive processor for event streams\"\"\"\n\n    def __init__(self):\n        # Observable streams for different event types\n        self.order_status_stream = Subject()\n        self.kitchen_capacity_stream = Subject()\n        self.customer_notification_stream = Subject()\n\n        # Subscription management for cleanup\n        self.subscriptions: List[Disposable] = []\n\n        # Setup reactive processing pipelines\n        self._setup_reactive_pipelines()\n\n    def _setup_reactive_pipelines(self):\n        \"\"\"Configure reactive processing pipelines with stream transformations\"\"\"\n\n        # Order status processing pipeline\n        order_subscription = AsyncRx.subscribe(\n            self.order_status_stream.pipe(\n                # Filter only significant status changes\n                ops.filter(lambda event: self._is_significant_status_change(event)),\n                # Enrich with additional context\n                ops.map(lambda event: self._enrich_order_event(event)),\n                # Buffer for batch processing efficiency\n                ops.buffer_with_time(timespan=1.0)\n            ),\n            lambda events: asyncio.create_task(self._process_order_event_batch(events))\n        )\n        self.subscriptions.append(order_subscription)\n\n        # Kitchen capacity monitoring pipeline\n        kitchen_subscription = AsyncRx.subscribe(\n            self.kitchen_capacity_stream.pipe(\n                # Throttle rapid capacity updates\n                ops.throttle_first(0.5),\n                # Transform to capacity metrics\n                ops.map(lambda event: self._calculate_capacity_metrics(event))\n            ),\n            lambda metrics: asyncio.create_task(self._update_capacity_dashboard(metrics))\n        )\n        self.subscriptions.append(kitchen_subscription)\n\n        # Customer notification pipeline\n        notification_subscription = AsyncRx.subscribe(\n            self.customer_notification_stream.pipe(\n                # Group by customer for consolidated notifications\n                ops.group_by(lambda event: event.customer_id),\n                # Debounce to prevent notification spam\n                ops.debounce(1.5)\n            ),\n            lambda event: asyncio.create_task(self._send_customer_notification(event))\n        )\n        self.subscriptions.append(notification_subscription)\n\n    # Event Publishers\n    def publish_order_status_change(self, event: OrderStatusChangedEvent):\n        \"\"\"Publish order status change to reactive stream\"\"\"\n        self.order_status_stream.on_next(event)\n\n        # Trigger customer notification for customer-facing statuses\n        if event.new_status in [OrderStatus.READY, OrderStatus.DELIVERED]:\n            self.customer_notification_stream.on_next(event)\n\n    def publish_kitchen_capacity_update(self, event: KitchenCapacityEvent):\n        \"\"\"Publish kitchen capacity update to reactive stream\"\"\"\n        self.kitchen_capacity_stream.on_next(event)\n\n    # Stream Processing Methods\n    def _is_significant_status_change(self, event: OrderStatusChangedEvent) -&gt; bool:\n        \"\"\"Filter logic for significant status changes\"\"\"\n        significant_transitions = {\n            (OrderStatus.PLACED, OrderStatus.CONFIRMED),\n            (OrderStatus.CONFIRMED, OrderStatus.COOKING),\n            (OrderStatus.COOKING, OrderStatus.READY),\n            (OrderStatus.READY, OrderStatus.DELIVERED)\n        }\n        return (event.previous_status, event.new_status) in significant_transitions\n\n    def _enrich_order_event(self, event: OrderStatusChangedEvent) -&gt; Dict[str, Any]:\n        \"\"\"Enrich events with additional processing context\"\"\"\n        return {\n            'original_event': event,\n            'processing_timestamp': datetime.now(),\n            'priority_score': self._calculate_priority_score(event),\n            'estimated_impact': self._estimate_kitchen_impact(event)\n        }\n\n    async def _process_order_event_batch(self, enriched_events: List[Dict[str, Any]]):\n        \"\"\"Process batched events for efficiency\"\"\"\n        if not enriched_events:\n            return\n\n        print(f\"\ud83d\udd04 Processing batch of {len(enriched_events)} order events\")\n\n        # Extract original events for processing\n        events = [e['original_event'] for e in enriched_events]\n\n        # Batch update order tracking\n        order_ids = [e.order_id for e in events]\n        await self._batch_update_order_dashboard(order_ids)\n\n        # Update kitchen workflow for cooking transitions\n        cooking_events = [e for e in events if e.new_status == OrderStatus.COOKING]\n        if cooking_events:\n            await self._update_kitchen_workflow(cooking_events)\n\n    # Cleanup Management\n    def dispose(self):\n        \"\"\"Properly dispose of all reactive subscriptions\"\"\"\n        for subscription in self.subscriptions:\n            subscription.dispose()\n        self.subscriptions.clear()\n</code></pre>"},{"location":"patterns/reactive-programming/#stream-transformation-patterns","title":"Stream Transformation Patterns","text":"<pre><code>class StreamTransformationPatterns:\n    \"\"\"Common reactive stream transformation patterns\"\"\"\n\n    @staticmethod\n    def create_filtering_pipeline(source_stream: Subject, predicate: Callable) -&gt; Subject:\n        \"\"\"Create filtered stream with predicate\"\"\"\n        filtered_stream = Subject()\n\n        subscription = AsyncRx.subscribe(\n            source_stream.pipe(ops.filter(predicate)),\n            lambda item: filtered_stream.on_next(item)\n        )\n\n        return filtered_stream, subscription\n\n    @staticmethod\n    def create_transformation_pipeline(source_stream: Subject, transformer: Callable) -&gt; Subject:\n        \"\"\"Create transformed stream with mapping function\"\"\"\n        transformed_stream = Subject()\n\n        subscription = AsyncRx.subscribe(\n            source_stream.pipe(ops.map(transformer)),\n            lambda item: transformed_stream.on_next(item)\n        )\n\n        return transformed_stream, subscription\n\n    @staticmethod\n    def create_aggregation_pipeline(source_stream: Subject, window_seconds: float) -&gt; Subject:\n        \"\"\"Create aggregated stream with time-based windows\"\"\"\n        aggregated_stream = Subject()\n\n        subscription = AsyncRx.subscribe(\n            source_stream.pipe(\n                ops.buffer_with_time(timespan=window_seconds),\n                ops.filter(lambda items: len(items) &gt; 0),\n                ops.map(lambda items: StreamTransformationPatterns._aggregate_items(items))\n            ),\n            lambda aggregated: aggregated_stream.on_next(aggregated)\n        )\n\n        return aggregated_stream, subscription\n\n    @staticmethod\n    def _aggregate_items(items: List[Any]) -&gt; Dict[str, Any]:\n        \"\"\"Aggregate items in a time window\"\"\"\n        return {\n            'count': len(items),\n            'items': items,\n            'timestamp': datetime.now(),\n            'window_start': items[0].timestamp if items else None,\n            'window_end': items[-1].timestamp if items else None\n        }\n</code></pre>"},{"location":"patterns/reactive-programming/#background-service-pattern","title":"Background Service Pattern","text":"<pre><code>from neuroglia.hosting.abstractions import HostedService\nfrom apscheduler.schedulers.asyncio import AsyncIOScheduler\n\nclass ReactiveBackgroundService(HostedService):\n    \"\"\"Background service using reactive patterns for task processing\"\"\"\n\n    def __init__(self, scheduler: AsyncIOScheduler):\n        self.scheduler = scheduler\n        self.task_request_stream = Subject()\n        self.task_completion_stream = Subject()\n        self.subscription: Optional[Disposable] = None\n\n    async def start_async(self):\n        \"\"\"Start reactive background processing\"\"\"\n        print(\"\u26a1 Starting reactive background service\")\n\n        self.scheduler.start()\n\n        # Setup reactive task processing pipeline\n        self.subscription = AsyncRx.subscribe(\n            self.task_request_stream.pipe(\n                # Filter valid tasks\n                ops.filter(lambda task: self._is_valid_task(task)),\n                # Transform to executable tasks\n                ops.map(lambda task: self._prepare_task_execution(task))\n            ),\n            lambda prepared_task: asyncio.create_task(self._execute_task(prepared_task))\n        )\n\n    async def stop_async(self):\n        \"\"\"Stop reactive background processing\"\"\"\n        if self.subscription:\n            self.subscription.dispose()\n        self.scheduler.shutdown(wait=False)\n        print(\"\u23f9\ufe0f Stopped reactive background service\")\n\n    def schedule_task(self, task_descriptor: 'TaskDescriptor'):\n        \"\"\"Schedule task through reactive stream\"\"\"\n        self.task_request_stream.on_next(task_descriptor)\n\n    def _is_valid_task(self, task: 'TaskDescriptor') -&gt; bool:\n        \"\"\"Validate task before processing\"\"\"\n        return (\n            hasattr(task, 'id') and task.id and\n            hasattr(task, 'scheduled_time') and task.scheduled_time and\n            hasattr(task, 'task_type') and task.task_type\n        )\n\n    def _prepare_task_execution(self, task: 'TaskDescriptor') -&gt; Dict[str, Any]:\n        \"\"\"Prepare task for execution with reactive context\"\"\"\n        return {\n            'task': task,\n            'preparation_time': datetime.now(),\n            'execution_context': self._create_execution_context(task)\n        }\n\n    async def _execute_task(self, prepared_task: Dict[str, Any]):\n        \"\"\"Execute task and publish completion events\"\"\"\n        task = prepared_task['task']\n\n        try:\n            # Execute the task\n            result = await self._run_task(task)\n\n            # Publish success event\n            completion_event = TaskCompletionEvent(\n                task_id=task.id,\n                status='completed',\n                result=result,\n                completed_at=datetime.now()\n            )\n            self.task_completion_stream.on_next(completion_event)\n\n        except Exception as ex:\n            # Publish failure event\n            failure_event = TaskCompletionEvent(\n                task_id=task.id,\n                status='failed',\n                error=str(ex),\n                completed_at=datetime.now()\n            )\n            self.task_completion_stream.on_next(failure_event)\n</code></pre>"},{"location":"patterns/reactive-programming/#stream-processing-patterns","title":"\ud83c\udf0a Stream Processing Patterns","text":""},{"location":"patterns/reactive-programming/#event-aggregation-pattern","title":"Event Aggregation Pattern","text":"<pre><code>class EventAggregationPattern:\n    \"\"\"Pattern for aggregating events in reactive streams\"\"\"\n\n    def __init__(self):\n        self.source_events = Subject()\n        self.aggregated_events = Subject()\n        self._setup_aggregation_pipeline()\n\n    def _setup_aggregation_pipeline(self):\n        \"\"\"Setup event aggregation with multiple aggregation strategies\"\"\"\n\n        # Time-based aggregation (5-second windows)\n        time_aggregated = self.source_events.pipe(\n            ops.buffer_with_time(timespan=5.0),\n            ops.filter(lambda events: len(events) &gt; 0),\n            ops.map(lambda events: self._create_time_aggregate(events))\n        )\n\n        # Count-based aggregation (every 10 events)\n        count_aggregated = self.source_events.pipe(\n            ops.buffer_with_count(10),\n            ops.map(lambda events: self._create_count_aggregate(events))\n        )\n\n        # Combine aggregation strategies\n        combined_aggregated = time_aggregated.merge(count_aggregated)\n\n        # Subscribe to combined stream\n        AsyncRx.subscribe(\n            combined_aggregated,\n            lambda aggregate: self.aggregated_events.on_next(aggregate)\n        )\n\n    def _create_time_aggregate(self, events: List[DomainEvent]) -&gt; Dict[str, Any]:\n        \"\"\"Create time-based event aggregate\"\"\"\n        return {\n            'type': 'time_aggregate',\n            'event_count': len(events),\n            'events': events,\n            'time_window': 5.0,\n            'aggregate_timestamp': datetime.now()\n        }\n\n    def _create_count_aggregate(self, events: List[DomainEvent]) -&gt; Dict[str, Any]:\n        \"\"\"Create count-based event aggregate\"\"\"\n        return {\n            'type': 'count_aggregate',\n            'event_count': len(events),\n            'events': events,\n            'count_threshold': 10,\n            'aggregate_timestamp': datetime.now()\n        }\n</code></pre>"},{"location":"patterns/reactive-programming/#testing-patterns","title":"\ud83e\uddea Testing Patterns","text":""},{"location":"patterns/reactive-programming/#reactive-component-testing","title":"Reactive Component Testing","text":"<pre><code>import pytest\nfrom unittest.mock import Mock, AsyncMock\n\nclass TestReactiveEventProcessor:\n\n    def setup_method(self):\n        self.processor = ReactiveEventProcessor()\n        self.test_events = []\n\n        # Mock external dependencies\n        self.processor._batch_update_order_dashboard = AsyncMock()\n        self.processor._update_kitchen_workflow = AsyncMock()\n        self.processor._send_customer_notification = AsyncMock()\n\n    @pytest.mark.asyncio\n    async def test_order_status_event_triggers_processing(self):\n        \"\"\"Test order status events trigger reactive processing\"\"\"\n        # Arrange\n        event = OrderStatusChangedEvent(\n            order_id=\"TEST-001\",\n            previous_status=OrderStatus.PLACED,\n            new_status=OrderStatus.CONFIRMED,\n            timestamp=datetime.now(),\n            estimated_completion=datetime.now()\n        )\n\n        # Act\n        self.processor.publish_order_status_change(event)\n        await asyncio.sleep(0.1)  # Allow reactive processing\n\n        # Assert - Verify reactive pipeline was triggered\n        assert len(self.processor.subscriptions) &gt; 0\n\n    @pytest.mark.asyncio\n    async def test_kitchen_capacity_stream_throttling(self):\n        \"\"\"Test kitchen capacity updates are properly throttled\"\"\"\n        # Arrange\n        events = [\n            KitchenCapacityEvent(available_ovens=i, current_orders=5, estimated_wait_minutes=10)\n            for i in range(5)\n        ]\n\n        # Act - Rapid fire events\n        for event in events:\n            self.processor.publish_kitchen_capacity_update(event)\n            await asyncio.sleep(0.1)\n\n        # Assert - Should be throttled (fewer calls than events)\n        await asyncio.sleep(1.0)  # Wait for throttling window\n\n        # Verify throttling behavior through dashboard update calls\n        call_count = self.processor._update_capacity_dashboard.call_count\n        assert call_count &lt; len(events)  # Should be throttled\n\n    @pytest.mark.asyncio\n    async def test_subscription_cleanup(self):\n        \"\"\"Test proper cleanup of reactive subscriptions\"\"\"\n        # Arrange\n        initial_subscription_count = len(self.processor.subscriptions)\n\n        # Act\n        self.processor.dispose()\n\n        # Assert\n        assert len(self.processor.subscriptions) == 0\n\n    def teardown_method(self):\n        \"\"\"Cleanup test resources\"\"\"\n        self.processor.dispose()\n\nclass TestStreamTransformationPatterns:\n\n    def setup_method(self):\n        self.source_stream = Subject()\n        self.received_items = []\n\n    @pytest.mark.asyncio\n    async def test_filtering_pipeline(self):\n        \"\"\"Test stream filtering patterns\"\"\"\n        # Arrange\n        def is_even(x): return x % 2 == 0\n\n        filtered_stream, subscription = StreamTransformationPatterns.create_filtering_pipeline(\n            self.source_stream, is_even\n        )\n\n        # Subscribe to results\n        AsyncRx.subscribe(filtered_stream, lambda item: self.received_items.append(item))\n\n        # Act\n        for i in range(10):\n            self.source_stream.on_next(i)\n\n        await asyncio.sleep(0.1)\n\n        # Assert\n        assert self.received_items == [0, 2, 4, 6, 8]\n\n        # Cleanup\n        subscription.dispose()\n\n    @pytest.mark.asyncio\n    async def test_transformation_pipeline(self):\n        \"\"\"Test stream transformation patterns\"\"\"\n        # Arrange\n        def double(x): return x * 2\n\n        transformed_stream, subscription = StreamTransformationPatterns.create_transformation_pipeline(\n            self.source_stream, double\n        )\n\n        # Subscribe to results\n        AsyncRx.subscribe(transformed_stream, lambda item: self.received_items.append(item))\n\n        # Act\n        self.source_stream.on_next(5)\n        self.source_stream.on_next(10)\n\n        await asyncio.sleep(0.1)\n\n        # Assert\n        assert self.received_items == [10, 20]\n\n        # Cleanup\n        subscription.dispose()\n\n    def teardown_method(self):\n        \"\"\"Cleanup test streams\"\"\"\n        if hasattr(self, 'source_stream'):\n            self.source_stream.dispose()\n</code></pre>"},{"location":"patterns/reactive-programming/#framework-integration","title":"\ud83d\ude80 Framework Integration","text":""},{"location":"patterns/reactive-programming/#service-registration-pattern","title":"Service Registration Pattern","text":"<pre><code>from neuroglia.hosting import WebApplicationBuilder\nfrom neuroglia.dependency_injection import ServiceLifetime\n\ndef configure_reactive_services(builder: WebApplicationBuilder):\n    \"\"\"Configure reactive programming services with dependency injection\"\"\"\n\n    # Register core reactive services\n    builder.services.add_singleton(ReactiveEventProcessor)\n    builder.services.add_singleton(EventAggregationPattern)\n    builder.services.add_scoped(StreamTransformationPatterns)\n\n    # Register background services\n    builder.services.add_hosted_service(ReactiveBackgroundService)\n\n    # Configure reactive infrastructure\n    builder.services.add_singleton(AsyncIOScheduler)\n\n    # Register domain-specific reactive services\n    builder.services.add_singleton(ReactiveOrderProcessor)\n    builder.services.add_singleton(ReactiveAnalyticsDashboard)\n\n# Application startup with reactive configuration\ndef create_reactive_application():\n    \"\"\"Create application with reactive programming support\"\"\"\n    builder = WebApplicationBuilder()\n\n    # Configure reactive services\n    configure_reactive_services(builder)\n\n    # Build application\n    app = builder.build()\n\n    return app\n</code></pre>"},{"location":"patterns/reactive-programming/#pattern-benefits","title":"\ud83c\udfaf Pattern Benefits","text":""},{"location":"patterns/reactive-programming/#advantages","title":"Advantages","text":"<ul> <li>Responsiveness: React to events immediately with minimal latency</li> <li>Scalability: Handle high-throughput event streams efficiently through stream composition</li> <li>Decoupling: Loose coupling between event producers and consumers</li> <li>Composability: Declaratively chain and transform event streams</li> <li>Error Resilience: Built-in retry and error handling mechanisms</li> <li>Resource Efficiency: Non-blocking operations with efficient resource utilization</li> </ul>"},{"location":"patterns/reactive-programming/#when-to-use","title":"When to Use","text":"<ul> <li>Real-time data processing and analytics</li> <li>Event-driven architectures with high event volumes</li> <li>Background services requiring continuous processing</li> <li>UI applications needing responsive user interactions</li> <li>Integration scenarios with multiple event sources</li> <li>Systems requiring complex event correlation and aggregation</li> </ul>"},{"location":"patterns/reactive-programming/#when-not-to-use","title":"When Not to Use","text":"<ul> <li>Simple, synchronous data processing workflows</li> <li>Applications with infrequent, isolated operations</li> <li>Systems where event ordering must be strictly guaranteed</li> <li>Resource-constrained environments unable to support reactive infrastructure</li> <li>Teams lacking experience with asynchronous programming patterns</li> </ul>"},{"location":"patterns/reactive-programming/#common-mistakes","title":"\u26a0\ufe0f Common Mistakes","text":""},{"location":"patterns/reactive-programming/#1-not-disposing-subscriptions-memory-leaks","title":"1. Not Disposing Subscriptions (Memory Leaks)","text":"<pre><code># \u274c WRONG: Creating subscriptions without disposing them\nclass OrderMonitorService:\n    def start_monitoring(self):\n        # Creating subscription but never disposing it!\n        self.order_stream.subscribe(\n            on_next=lambda order: self.process_order(order)\n        )\n        # If this method is called multiple times, subscriptions accumulate!\n\n# \u2705 CORRECT: Properly dispose subscriptions\nclass OrderMonitorService:\n    def __init__(self):\n        self.subscription = None\n\n    def start_monitoring(self):\n        # Dispose old subscription if exists\n        if self.subscription:\n            self.subscription.dispose()\n\n        # Create new subscription\n        self.subscription = self.order_stream.subscribe(\n            on_next=lambda order: self.process_order(order)\n        )\n\n    def stop_monitoring(self):\n        # Always dispose when done\n        if self.subscription:\n            self.subscription.dispose()\n            self.subscription = None\n</code></pre>"},{"location":"patterns/reactive-programming/#2-blocking-operations-inside-reactive-streams","title":"2. Blocking Operations Inside Reactive Streams","text":"<pre><code># \u274c WRONG: Blocking operations in stream (defeats the purpose!)\norder_stream.pipe(\n    ops.map(lambda order: self.calculate_total(order)),\n    ops.map(lambda order: time.sleep(2)),  # BLOCKING SLEEP!\n    ops.map(lambda order: requests.get(f\"/api/validate/{order.id}\"))  # BLOCKING HTTP!\n).subscribe(on_next=self.process_order)\n\n# \u2705 CORRECT: Use async operations\norder_stream.pipe(\n    ops.map(lambda order: self.calculate_total(order)),\n    ops.flat_map(lambda order: AsyncRx.from_async(\n        self.validate_order_async(order)  # Async operation!\n    ))\n).subscribe(on_next=self.process_order)\n</code></pre>"},{"location":"patterns/reactive-programming/#3-not-handling-errors-in-streams","title":"3. Not Handling Errors in Streams","text":"<pre><code># \u274c WRONG: No error handling (stream terminates on first error!)\norder_stream.pipe(\n    ops.map(lambda order: self.process_order(order))\n    # If process_order throws, stream terminates forever!\n).subscribe(on_next=lambda result: print(result))\n\n# \u2705 CORRECT: Handle errors gracefully\norder_stream.pipe(\n    ops.map(lambda order: self.process_order(order)),\n    ops.catch(lambda error: Subject.return_value(None)),  # Continue on error\n    ops.retry(3)  # Retry failed operations\n).subscribe(\n    on_next=lambda result: print(result),\n    on_error=lambda error: logger.error(f\"Stream error: {error}\")\n)\n</code></pre>"},{"location":"patterns/reactive-programming/#4-creating-new-streams-in-map-operations","title":"4. Creating New Streams in Map Operations","text":"<pre><code># \u274c WRONG: Creating nested streams (complex and inefficient!)\norder_stream.pipe(\n    ops.map(lambda order: Subject().pipe(  # New stream for each order!\n        ops.map(lambda x: x * 2),\n        ops.filter(lambda x: x &gt; 10)\n    ))\n).subscribe(on_next=self.process)\n\n# \u2705 CORRECT: Use flat_map for nested async operations\norder_stream.pipe(\n    ops.flat_map(lambda order: self.get_order_details_async(order)),\n    ops.filter(lambda details: details.total &gt; 10)\n).subscribe(on_next=self.process)\n</code></pre>"},{"location":"patterns/reactive-programming/#5-not-managing-backpressure","title":"5. Not Managing Backpressure","text":"<pre><code># \u274c WRONG: Fast producer overwhelming slow consumer\nfast_producer_stream.subscribe(\n    on_next=lambda data: self.slow_processing(data)  # Can't keep up!\n)\n\n# \u2705 CORRECT: Use buffering or throttling\nfast_producer_stream.pipe(\n    ops.buffer_with_time(1.0),  # Buffer 1 second of events\n    ops.flat_map(lambda buffer: self.batch_process(buffer))\n).subscribe(on_next=self.handle_result)\n\n# Or throttle\nfast_producer_stream.pipe(\n    ops.throttle_first(0.1)  # Only take one event per 100ms\n).subscribe(on_next=self.slow_processing)\n</code></pre>"},{"location":"patterns/reactive-programming/#6-mixing-sync-and-async-code-incorrectly","title":"6. Mixing Sync and Async Code Incorrectly","text":"<pre><code># \u274c WRONG: Mixing sync/async without proper bridging\nasync def process_async(order):\n    result = await self.repository.save_async(order)\n    return result\n\n# This won't work correctly - async function in sync map!\norder_stream.pipe(\n    ops.map(lambda order: process_async(order))  # Returns coroutine, not result!\n).subscribe(on_next=print)\n\n# \u2705 CORRECT: Use AsyncRx for async operations\norder_stream.pipe(\n    ops.flat_map(lambda order: AsyncRx.from_async(process_async(order)))\n).subscribe(on_next=print)\n</code></pre>"},{"location":"patterns/reactive-programming/#when-not-to-use_1","title":"\ud83d\udeab When NOT to Use","text":""},{"location":"patterns/reactive-programming/#1-simple-sequential-processing","title":"1. Simple Sequential Processing","text":"<pre><code># Reactive is overkill for simple sequential operations\nclass SimpleReportGenerator:\n    async def generate_report(self):\n        # Just process sequentially\n        data = await self.db.fetch_data()\n        processed = self.transform(data)\n        await self.save_report(processed)\n        # No need for reactive streams here\n</code></pre>"},{"location":"patterns/reactive-programming/#2-infrequent-one-off-operations","title":"2. Infrequent, One-Off Operations","text":"<pre><code># Don't use reactive for one-time operations\nclass DatabaseMigration:\n    async def migrate(self):\n        # One-time migration script\n        records = await self.old_db.fetch_all()\n        for record in records:\n            await self.new_db.insert(record)\n        # Direct approach is simpler\n</code></pre>"},{"location":"patterns/reactive-programming/#3-strict-ordering-requirements","title":"3. Strict Ordering Requirements","text":"<pre><code># Reactive streams can process events out of order\nclass FinancialTransactionProcessor:\n    \"\"\"Bank transactions MUST be processed in strict order\"\"\"\n    async def process_transactions(self):\n        # Use sequential processing for strict ordering\n        transactions = await self.queue.dequeue_all()\n        for tx in transactions:  # Sequential, in order\n            await self.apply_transaction(tx)\n        # Reactive parallelism would break ordering guarantees\n</code></pre>"},{"location":"patterns/reactive-programming/#4-resource-constrained-environments","title":"4. Resource-Constrained Environments","text":"<pre><code># Reactive infrastructure has overhead\nclass EmbeddedIoTDevice:\n    \"\"\"Running on microcontroller with 512KB RAM\"\"\"\n    def process_sensor_data(self):\n        # Direct processing without reactive overhead\n        data = self.sensor.read()\n        if data &gt; threshold:\n            self.trigger_alert()\n</code></pre>"},{"location":"patterns/reactive-programming/#5-teams-unfamiliar-with-reactive-patterns","title":"5. Teams Unfamiliar with Reactive Patterns","text":"<pre><code># Reactive has a steep learning curve\nclass NewTeamProject:\n    \"\"\"Team new to async programming\"\"\"\n    # Start with simpler async/await patterns\n    async def process_order(self, order_id: str):\n        order = await self.repository.get_async(order_id)\n        await self.process_payment(order)\n        await self.send_confirmation(order)\n        # Add reactive patterns later when team is ready\n</code></pre>"},{"location":"patterns/reactive-programming/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ul> <li>Reactive programming enables non-blocking event processing with Observable streams</li> <li>Push-based model eliminates polling overhead and reduces latency</li> <li>Composable operators (filter, map, buffer, throttle) enable declarative pipelines</li> <li>Built-in backpressure handling manages fast producers and slow consumers</li> <li>Error resilience with retry, timeout, and catch operators</li> <li>Always dispose subscriptions to prevent memory leaks</li> <li>Use AsyncRx bridge for async/await integration</li> <li>Best for high-volume event streams and real-time processing</li> <li>Avoid for simple sequential operations where reactive adds complexity</li> <li>Framework provides rx integration through neuroglia.reactive module</li> </ul>"},{"location":"patterns/reactive-programming/#related-patterns","title":"\ud83d\udd17 Related Patterns","text":""},{"location":"patterns/reactive-programming/#complementary-patterns","title":"Complementary Patterns","text":"<ul> <li>Event Sourcing - Reactive event store reconciliation and stream processing</li> <li>CQRS - Reactive command/query processing pipelines</li> <li>Observer - Foundation pattern for reactive event subscription</li> <li>Event-Driven Architecture - Reactive event processing and distribution</li> <li>Repository - Reactive data access with stream-based queries</li> <li>Dependency Injection - Service registration for reactive components</li> </ul>"},{"location":"patterns/reactive-programming/#integration-examples","title":"Integration Examples","text":"<p>The Reactive Programming pattern integrates naturally with other architectural patterns, particularly in event-driven systems where multiple patterns work together to create responsive, scalable applications.</p> <p>Next Steps: Explore Event Sourcing for reactive event store integration or CQRS &amp; Mediation for reactive command/query processing patterns.</p>"},{"location":"patterns/repository/","title":"\ud83d\uddc4\ufe0f Repository Pattern","text":"<p>Estimated reading time: 15 minutes</p>"},{"location":"patterns/repository/#what-why","title":"\ud83c\udfaf What &amp; Why","text":"<p>The Repository Pattern abstracts data access logic behind a uniform interface, decoupling your business logic from specific storage mechanisms. It acts as an in-memory collection of domain objects, allowing you to swap storage implementations without changing business code.</p>"},{"location":"patterns/repository/#the-problem-without-repository-pattern","title":"The Problem Without Repository Pattern","text":"<pre><code># \u274c Without Repository - business logic tightly coupled to MongoDB\nclass PlaceOrderHandler(CommandHandler):\n    def __init__(self, mongo_client: MongoClient):\n        self.db = mongo_client.orders_db\n        self.collection = self.db.orders\n\n    async def handle_async(self, command: PlaceOrderCommand):\n        # Business logic mixed with MongoDB-specific code\n        order_doc = {\n            \"_id\": str(uuid.uuid4()),\n            \"customer_id\": command.customer_id,\n            \"items\": [{\"pizza\": item.pizza, \"qty\": item.quantity} for item in command.items],\n            \"total\": sum(item.price * item.quantity for item in command.items),\n            \"created_at\": datetime.utcnow()\n        }\n\n        # Direct MongoDB operations in business logic\n        await self.collection.insert_one(order_doc)\n\n        # Can't test without real MongoDB\n        # Can't switch to PostgreSQL without rewriting all handlers\n        # Can't use different storage for different entities\n</code></pre> <p>Problems:</p> <ul> <li>Business logic knows about MongoDB documents and queries</li> <li>Testing requires real database (slow, brittle)</li> <li>Switching databases requires rewriting all handlers</li> <li>Complex queries scattered across codebase</li> <li>No abstraction for domain objects</li> </ul>"},{"location":"patterns/repository/#the-solution-with-repository-pattern","title":"The Solution With Repository Pattern","text":"<pre><code># \u2705 With Repository - clean abstraction\nclass PlaceOrderHandler(CommandHandler):\n    def __init__(\n        self,\n        order_repository: IOrderRepository,  # Interface, not implementation\n        mapper: Mapper\n    ):\n        self.order_repository = order_repository\n        self.mapper = mapper\n\n    async def handle_async(self, command: PlaceOrderCommand):\n        # Pure business logic with domain objects\n        order = Order.create(\n            customer_id=command.customer_id,\n            items=command.items\n        )\n\n        # Simple, storage-agnostic persistence\n        await self.order_repository.save_async(order)\n\n        return self.created(self.mapper.map(order, OrderDto))\n\n# \u2705 Easy to test with in-memory implementation\n# \u2705 Swap to PostgreSQL by changing DI registration\n# \u2705 Domain objects, not database documents\n# \u2705 Complex queries encapsulated in repository\n</code></pre> <p>Benefits:</p> <ul> <li>Business logic uses domain objects, not database structures</li> <li>Easy testing with in-memory or mock repositories</li> <li>Swap storage implementations via dependency injection</li> <li>Centralized query logic in repository methods</li> <li>Storage-agnostic handler code</li> </ul>"},{"location":"patterns/repository/#core-components","title":"\ud83c\udfd7\ufe0f Core Components","text":"<p>The Repository pattern consists of three key layers:</p>"},{"location":"patterns/repository/#core-components_1","title":"\ud83c\udfd7\ufe0f Core Components","text":"<p>The Repository pattern consists of three key layers:</p>"},{"location":"patterns/repository/#1-repository-interface-domain-layer","title":"1. Repository Interface (Domain Layer)","text":"<p>Defines storage operations as domain concepts:</p> <pre><code>from abc import ABC, abstractmethod\nfrom typing import Generic, TypeVar, Optional, List\nfrom datetime import datetime\n\nTEntity = TypeVar('TEntity')\nTKey = TypeVar('TKey')\n\n# Base repository interface\nclass IRepository(ABC, Generic[TEntity, TKey]):\n    \"\"\"Abstract repository for all entities\"\"\"\n\n    @abstractmethod\n    async def get_by_id_async(self, id: TKey) -&gt; Optional[TEntity]:\n        \"\"\"Get entity by ID\"\"\"\n        pass\n\n    @abstractmethod\n    async def save_async(self, entity: TEntity) -&gt; None:\n        \"\"\"Save or update entity\"\"\"\n        pass\n\n    @abstractmethod\n    async def delete_async(self, id: TKey) -&gt; bool:\n        \"\"\"Delete entity by ID\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_all_async(self) -&gt; List[TEntity]:\n        \"\"\"Get all entities\"\"\"\n        pass\n\n# Order-specific repository interface with domain queries\nclass IOrderRepository(IRepository[Order, str]):\n    \"\"\"Order repository with business-specific queries\"\"\"\n\n    @abstractmethod\n    async def find_by_customer_async(self, customer_id: str) -&gt; List[Order]:\n        \"\"\"Find all orders for a customer\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_by_status_async(self, status: OrderStatus) -&gt; List[Order]:\n        \"\"\"Find orders by status\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_pending_deliveries_async(self) -&gt; List[Order]:\n        \"\"\"Find orders pending delivery\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_daily_revenue_async(self, date: datetime.date) -&gt; Decimal:\n        \"\"\"Calculate total revenue for a specific date\"\"\"\n        pass\n</code></pre> <p>Key Points:</p> <ul> <li>Lives in domain layer (defines what, not how)</li> <li>Methods use domain language (\"find_by_customer\", not \"query_collection\")</li> <li>Returns domain entities, not database records</li> <li>No implementation details (no SQL, MongoDB, etc.)</li> </ul>"},{"location":"patterns/repository/#2-repository-implementation-integration-layer","title":"2. Repository Implementation (Integration Layer)","text":"<p>Implements the interface for specific storage:</p> <pre><code>from motor.motor_asyncio import AsyncIOMotorCollection\n\nclass MongoOrderRepository(IOrderRepository):\n    \"\"\"MongoDB implementation of order repository\"\"\"\n\n    def __init__(self, collection: AsyncIOMotorCollection):\n        self._collection = collection\n\n    async def get_by_id_async(self, order_id: str) -&gt; Optional[Order]:\n        doc = await self._collection.find_one({\"_id\": order_id})\n        return self._to_entity(doc) if doc else None\n\n    async def save_async(self, order: Order) -&gt; None:\n        doc = self._to_document(order)\n        await self._collection.replace_one(\n            {\"_id\": order.id},\n            doc,\n            upsert=True\n        )\n\n    async def find_by_customer_async(self, customer_id: str) -&gt; List[Order]:\n        cursor = self._collection.find({\"customer_id\": customer_id})\n        docs = await cursor.to_list(None)\n        return [self._to_entity(doc) for doc in docs]\n\n    async def get_daily_revenue_async(self, date: datetime.date) -&gt; Decimal:\n        start = datetime.combine(date, datetime.min.time())\n        end = datetime.combine(date, datetime.max.time())\n\n        pipeline = [\n            {\n                \"$match\": {\n                    \"created_at\": {\"$gte\": start, \"$lt\": end},\n                    \"status\": {\"$ne\": \"cancelled\"}\n                }\n            },\n            {\n                \"$group\": {\n                    \"_id\": None,\n                    \"total\": {\"$sum\": \"$total\"}\n                }\n            }\n        ]\n\n        result = await self._collection.aggregate(pipeline).to_list(1)\n        return Decimal(str(result[0][\"total\"])) if result else Decimal(\"0\")\n\n    def _to_document(self, order: Order) -&gt; dict:\n        \"\"\"Convert domain entity to MongoDB document\"\"\"\n        return {\n            \"_id\": order.id,\n            \"customer_id\": order.customer_id,\n            \"items\": [self._item_to_dict(item) for item in order.items],\n            \"total\": float(order.total),\n            \"status\": order.status.value,\n            \"created_at\": order.created_at,\n            \"updated_at\": order.updated_at\n        }\n\n    def _to_entity(self, doc: dict) -&gt; Order:\n        \"\"\"Convert MongoDB document to domain entity\"\"\"\n        order = Order(\n            id=doc[\"_id\"],\n            customer_id=doc[\"customer_id\"],\n            items=[self._dict_to_item(item) for item in doc[\"items\"]]\n        )\n        order.status = OrderStatus(doc[\"status\"])\n        order.created_at = doc[\"created_at\"]\n        order.updated_at = doc[\"updated_at\"]\n        return order\n</code></pre> <p>Key Points:</p> <ul> <li>Lives in integration layer (implements how)</li> <li>Handles database-specific operations (queries, documents, connections)</li> <li>Converts between domain entities and storage format</li> <li>Encapsulates complex queries (aggregations, joins)</li> </ul>"},{"location":"patterns/repository/#3-dependency-injection-configuration","title":"3. Dependency Injection Configuration","text":"<p>Wires interface to implementation:</p>"},{"location":"patterns/repository/#3-dependency-injection-configuration_1","title":"3. Dependency Injection Configuration","text":"<p>Wires interface to implementation:</p> <pre><code>from neuroglia.hosting.web import WebApplicationBuilder\n\ndef configure_repositories(builder: WebApplicationBuilder):\n    \"\"\"Configure repository implementations\"\"\"\n    services = builder.services\n\n    # Register MongoDB implementation\n    services.add_singleton(\n        lambda sp: MongoClient(sp.get_service(AppSettings).mongodb_url)\n    )\n\n    # Register repositories with scoped lifetime\n    services.add_scoped(\n        IOrderRepository,\n        lambda sp: MongoOrderRepository(\n            sp.get_service(MongoClient).orders_db.orders\n        )\n    )\n\n    services.add_scoped(\n        ICustomerRepository,\n        lambda sp: MongoCustomerRepository(\n            sp.get_service(MongoClient).orders_db.customers\n        )\n    )\n\n# In tests, swap to in-memory implementation\ndef configure_test_repositories(builder: WebApplicationBuilder):\n    services = builder.services\n    services.add_singleton(IOrderRepository, InMemoryOrderRepository)\n    services.add_singleton(ICustomerRepository, InMemoryCustomerRepository)\n</code></pre>"},{"location":"patterns/repository/#real-world-example-marios-pizzeria","title":"\ud83d\udca1 Real-World Example: Mario's Pizzeria","text":"<p>Complete repository implementation for order management:</p>"},{"location":"patterns/repository/#order-repository-interface","title":"Order Repository Interface","text":"<pre><code># domain/repositories/order_repository.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Optional\nfrom datetime import date, datetime\nfrom decimal import Decimal\n\nclass IOrderRepository(ABC):\n    \"\"\"Repository for order aggregate management\"\"\"\n\n    # Basic CRUD\n    @abstractmethod\n    async def get_by_id_async(self, order_id: str) -&gt; Optional[Order]:\n        pass\n\n    @abstractmethod\n    async def save_async(self, order: Order) -&gt; None:\n        pass\n\n    @abstractmethod\n    async def delete_async(self, order_id: str) -&gt; bool:\n        pass\n\n    # Business queries\n    @abstractmethod\n    async def find_by_customer_async(\n        self,\n        customer_id: str,\n        skip: int = 0,\n        limit: int = 20\n    ) -&gt; List[Order]:\n        \"\"\"Get paginated orders for a customer\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_active_orders_async(self) -&gt; List[Order]:\n        \"\"\"Get all orders that are pending, preparing, or ready\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_by_status_async(self, status: OrderStatus) -&gt; List[Order]:\n        \"\"\"Get all orders with specific status\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_by_date_range_async(\n        self,\n        start_date: datetime,\n        end_date: datetime\n    ) -&gt; List[Order]:\n        \"\"\"Get orders within date range\"\"\"\n        pass\n\n    # Analytics queries\n    @abstractmethod\n    async def get_daily_sales_async(self, date: date) -&gt; DailySalesReport:\n        \"\"\"Get sales statistics for a specific date\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_popular_pizzas_async(self, days: int = 30) -&gt; List[PopularPizzaStat]:\n        \"\"\"Get most ordered pizzas in last N days\"\"\"\n        pass\n\n    @abstractmethod\n    async def count_by_customer_async(self, customer_id: str) -&gt; int:\n        \"\"\"Count total orders for a customer\"\"\"\n        pass\n</code></pre>"},{"location":"patterns/repository/#mongodb-implementation","title":"MongoDB Implementation","text":"<pre><code># integration/repositories/mongo_order_repository.py\nfrom motor.motor_asyncio import AsyncIOMotorCollection\nfrom datetime import datetime, date\nfrom decimal import Decimal\n\nclass MongoOrderRepository(IOrderRepository):\n    \"\"\"MongoDB implementation of order repository\"\"\"\n\n    def __init__(self, collection: AsyncIOMotorCollection):\n        self._collection = collection\n        self._ensure_indexes()\n\n    def _ensure_indexes(self):\n        \"\"\"Create database indexes for performance\"\"\"\n        # Run these on startup\n        # await self._collection.create_index(\"customer_id\")\n        # await self._collection.create_index(\"status\")\n        # await self._collection.create_index(\"created_at\")\n        pass\n\n    async def get_by_id_async(self, order_id: str) -&gt; Optional[Order]:\n        doc = await self._collection.find_one({\"_id\": order_id})\n        return self._document_to_entity(doc) if doc else None\n\n    async def save_async(self, order: Order) -&gt; None:\n        doc = self._entity_to_document(order)\n        await self._collection.replace_one(\n            {\"_id\": order.id},\n            doc,\n            upsert=True\n        )\n\n    async def delete_async(self, order_id: str) -&gt; bool:\n        result = await self._collection.delete_one({\"_id\": order_id})\n        return result.deleted_count &gt; 0\n\n    async def find_by_customer_async(\n        self,\n        customer_id: str,\n        skip: int = 0,\n        limit: int = 20\n    ) -&gt; List[Order]:\n        cursor = self._collection.find(\n            {\"customer_id\": customer_id}\n        ).sort(\"created_at\", -1).skip(skip).limit(limit)\n\n        docs = await cursor.to_list(None)\n        return [self._document_to_entity(doc) for doc in docs]\n\n    async def find_active_orders_async(self) -&gt; List[Order]:\n        cursor = self._collection.find({\n            \"status\": {\"$in\": [\"pending\", \"preparing\", \"ready\"]}\n        }).sort(\"created_at\", 1)\n\n        docs = await cursor.to_list(None)\n        return [self._document_to_entity(doc) for doc in docs]\n\n    async def get_daily_sales_async(self, target_date: date) -&gt; DailySalesReport:\n        start = datetime.combine(target_date, datetime.min.time())\n        end = datetime.combine(target_date, datetime.max.time())\n\n        pipeline = [\n            {\n                \"$match\": {\n                    \"created_at\": {\"$gte\": start, \"$lt\": end},\n                    \"status\": {\"$ne\": \"cancelled\"}\n                }\n            },\n            {\n                \"$group\": {\n                    \"_id\": None,\n                    \"total_orders\": {\"$sum\": 1},\n                    \"total_revenue\": {\"$sum\": \"$total\"},\n                    \"avg_order_value\": {\"$avg\": \"$total\"}\n                }\n            }\n        ]\n\n        result = await self._collection.aggregate(pipeline).to_list(1)\n\n        if result:\n            data = result[0]\n            return DailySalesReport(\n                date=target_date,\n                total_orders=data[\"total_orders\"],\n                total_revenue=Decimal(str(data[\"total_revenue\"])),\n                average_order_value=Decimal(str(data[\"avg_order_value\"]))\n            )\n\n        return DailySalesReport(\n            date=target_date,\n            total_orders=0,\n            total_revenue=Decimal(\"0\"),\n            average_order_value=Decimal(\"0\")\n        )\n\n    async def get_popular_pizzas_async(self, days: int = 30) -&gt; List[PopularPizzaStat]:\n        start_date = datetime.now() - timedelta(days=days)\n\n        pipeline = [\n            {\n                \"$match\": {\n                    \"created_at\": {\"$gte\": start_date},\n                    \"status\": {\"$ne\": \"cancelled\"}\n                }\n            },\n            {\"$unwind\": \"$items\"},\n            {\n                \"$group\": {\n                    \"_id\": \"$items.pizza_name\",\n                    \"order_count\": {\"$sum\": \"$items.quantity\"},\n                    \"total_revenue\": {\n                        \"$sum\": {\n                            \"$multiply\": [\"$items.price\", \"$items.quantity\"]\n                        }\n                    }\n                }\n            },\n            {\"$sort\": {\"order_count\": -1}},\n            {\"$limit\": 10}\n        ]\n\n        results = await self._collection.aggregate(pipeline).to_list(None)\n\n        return [\n            PopularPizzaStat(\n                pizza_name=doc[\"_id\"],\n                order_count=doc[\"order_count\"],\n                total_revenue=Decimal(str(doc[\"total_revenue\"]))\n            )\n            for doc in results\n        ]\n\n    def _entity_to_document(self, order: Order) -&gt; dict:\n        \"\"\"Convert domain entity to MongoDB document\"\"\"\n        return {\n            \"_id\": order.id,\n            \"customer_id\": order.customer_id,\n            \"items\": [\n                {\n                    \"pizza_name\": item.pizza_name,\n                    \"size\": item.size.value,\n                    \"quantity\": item.quantity,\n                    \"price\": float(item.price),\n                    \"toppings\": item.toppings\n                }\n                for item in order.items\n            ],\n            \"subtotal\": float(order.subtotal),\n            \"tax\": float(order.tax),\n            \"delivery_fee\": float(order.delivery_fee),\n            \"total\": float(order.total),\n            \"status\": order.status.value,\n            \"delivery_address\": order.delivery_address,\n            \"special_instructions\": order.special_instructions,\n            \"created_at\": order.created_at,\n            \"updated_at\": order.updated_at\n        }\n\n    def _document_to_entity(self, doc: dict) -&gt; Order:\n        \"\"\"Convert MongoDB document to domain entity\"\"\"\n        items = [\n            OrderItem(\n                pizza_name=item[\"pizza_name\"],\n                size=PizzaSize(item[\"size\"]),\n                quantity=item[\"quantity\"],\n                price=Decimal(str(item[\"price\"])),\n                toppings=item.get(\"toppings\", [])\n            )\n            for item in doc[\"items\"]\n        ]\n\n        order = Order(\n            id=doc[\"_id\"],\n            customer_id=doc[\"customer_id\"],\n            items=items,\n            delivery_address=doc[\"delivery_address\"],\n            special_instructions=doc.get(\"special_instructions\")\n        )\n\n        order.status = OrderStatus(doc[\"status\"])\n        order.created_at = doc[\"created_at\"]\n        order.updated_at = doc[\"updated_at\"]\n\n        return order\n</code></pre>"},{"location":"patterns/repository/#in-memory-implementation-testing","title":"In-Memory Implementation (Testing)","text":"<pre><code># integration/repositories/in_memory_order_repository.py\nimport copy\nfrom typing import Dict, List, Optional\n\nclass InMemoryOrderRepository(IOrderRepository):\n    \"\"\"In-memory implementation for testing\"\"\"\n\n    def __init__(self):\n        self._orders: Dict[str, Order] = {}\n\n    async def get_by_id_async(self, order_id: str) -&gt; Optional[Order]:\n        order = self._orders.get(order_id)\n        return copy.deepcopy(order) if order else None\n\n    async def save_async(self, order: Order) -&gt; None:\n        self._orders[order.id] = copy.deepcopy(order)\n\n    async def delete_async(self, order_id: str) -&gt; bool:\n        if order_id in self._orders:\n            del self._orders[order_id]\n            return True\n        return False\n\n    async def find_by_customer_async(\n        self,\n        customer_id: str,\n        skip: int = 0,\n        limit: int = 20\n    ) -&gt; List[Order]:\n        orders = [\n            copy.deepcopy(order)\n            for order in self._orders.values()\n            if order.customer_id == customer_id\n        ]\n        orders.sort(key=lambda o: o.created_at, reverse=True)\n        return orders[skip:skip + limit]\n\n    async def find_active_orders_async(self) -&gt; List[Order]:\n        active_statuses = {OrderStatus.PENDING, OrderStatus.PREPARING, OrderStatus.READY}\n        return [\n            copy.deepcopy(order)\n            for order in self._orders.values()\n            if order.status in active_statuses\n        ]\n\n    async def get_daily_sales_async(self, target_date: date) -&gt; DailySalesReport:\n        total_orders = 0\n        total_revenue = Decimal(\"0\")\n\n        for order in self._orders.values():\n            if (order.created_at.date() == target_date and\n                order.status != OrderStatus.CANCELLED):\n                total_orders += 1\n                total_revenue += order.total\n\n        avg = total_revenue / total_orders if total_orders &gt; 0 else Decimal(\"0\")\n\n        return DailySalesReport(\n            date=target_date,\n            total_orders=total_orders,\n            total_revenue=total_revenue,\n            average_order_value=avg\n        )\n\n    def clear(self):\n        \"\"\"Helper method for test cleanup\"\"\"\n        self._orders.clear()\n</code></pre>"},{"location":"patterns/repository/#application-setup","title":"Application Setup","text":"<pre><code># main.py\nfrom neuroglia.hosting.web import WebApplicationBuilder\n\ndef create_app():\n    builder = WebApplicationBuilder()\n\n    # Configure repositories based on environment\n    if builder.environment == \"production\":\n        configure_mongo_repositories(builder)\n    else:\n        configure_in_memory_repositories(builder)\n\n    # Register application services\n    builder.services.add_scoped(OrderService)\n    builder.services.add_mediator()\n    builder.services.add_mapper()\n\n    # Build app\n    return builder.build()\n\ndef configure_mongo_repositories(builder: WebApplicationBuilder):\n    \"\"\"Production: MongoDB repositories\"\"\"\n    services = builder.services\n\n    # Register MongoDB client\n    services.add_singleton(\n        lambda sp: MongoClient(sp.get_service(AppSettings).mongodb_url)\n    )\n\n    # Register repositories\n    services.add_scoped(\n        IOrderRepository,\n        lambda sp: MongoOrderRepository(\n            sp.get_service(MongoClient).pizzeria_db.orders\n        )\n    )\n\ndef configure_in_memory_repositories(builder: WebApplicationBuilder):\n    \"\"\"Development/Testing: In-memory repositories\"\"\"\n    services = builder.services\n    services.add_singleton(IOrderRepository, InMemoryOrderRepository)\n</code></pre>"},{"location":"patterns/repository/#advanced-patterns","title":"\ud83d\udd27 Advanced Patterns","text":""},{"location":"patterns/repository/#1-repository-with-caching","title":"1. Repository with Caching","text":"<p>Add caching layer for frequently accessed data:</p> <pre><code>class CachedOrderRepository(IOrderRepository):\n    \"\"\"Repository with Redis caching\"\"\"\n\n    def __init__(\n        self,\n        base_repository: IOrderRepository,\n        cache: Redis,\n        cache_ttl: int = 300\n    ):\n        self._repository = base_repository\n        self._cache = cache\n        self._ttl = cache_ttl\n\n    async def get_by_id_async(self, order_id: str) -&gt; Optional[Order]:\n        # Try cache first\n        cache_key = f\"order:{order_id}\"\n        cached = await self._cache.get(cache_key)\n\n        if cached:\n            return json.loads(cached, cls=OrderDecoder)\n\n        # Cache miss - get from database\n        order = await self._repository.get_by_id_async(order_id)\n\n        if order:\n            # Store in cache\n            await self._cache.setex(\n                cache_key,\n                self._ttl,\n                json.dumps(order, cls=OrderEncoder)\n            )\n\n        return order\n\n    async def save_async(self, order: Order) -&gt; None:\n        # Save to database\n        await self._repository.save_async(order)\n\n        # Invalidate cache\n        cache_key = f\"order:{order.id}\"\n        await self._cache.delete(cache_key)\n</code></pre>"},{"location":"patterns/repository/#2-specification-pattern-for-complex-queries","title":"2. Specification Pattern for Complex Queries","text":"<p>Encapsulate query logic in reusable specifications:</p> <pre><code>from abc import ABC, abstractmethod\n\nclass Specification(ABC, Generic[T]):\n    \"\"\"Base specification for filtering\"\"\"\n\n    @abstractmethod\n    def is_satisfied_by(self, entity: T) -&gt; bool:\n        pass\n\n    @abstractmethod\n    def to_mongo_query(self) -&gt; dict:\n        pass\n\nclass ActiveOrdersSpecification(Specification[Order]):\n    \"\"\"Specification for active orders\"\"\"\n\n    def is_satisfied_by(self, order: Order) -&gt; bool:\n        return order.status in [\n            OrderStatus.PENDING,\n            OrderStatus.PREPARING,\n            OrderStatus.READY\n        ]\n\n    def to_mongo_query(self) -&gt; dict:\n        return {\n            \"status\": {\n                \"$in\": [\"pending\", \"preparing\", \"ready\"]\n            }\n        }\n\nclass CustomerOrdersSpecification(Specification[Order]):\n    \"\"\"Specification for customer's orders\"\"\"\n\n    def __init__(self, customer_id: str):\n        self.customer_id = customer_id\n\n    def is_satisfied_by(self, order: Order) -&gt; bool:\n        return order.customer_id == self.customer_id\n\n    def to_mongo_query(self) -&gt; dict:\n        return {\"customer_id\": self.customer_id}\n\n# Usage in repository\nclass MongoOrderRepository(IOrderRepository):\n    async def find_by_specification_async(\n        self,\n        spec: Specification[Order]\n    ) -&gt; List[Order]:\n        query = spec.to_mongo_query()\n        cursor = self._collection.find(query)\n        docs = await cursor.to_list(None)\n        return [self._document_to_entity(doc) for doc in docs]\n\n# Combine specifications\nspec = AndSpecification(\n    ActiveOrdersSpecification(),\n    CustomerOrdersSpecification(\"customer_123\")\n)\norders = await repository.find_by_specification_async(spec)\n</code></pre>"},{"location":"patterns/repository/#3-unit-of-work-pattern-integration","title":"3. Unit of Work Pattern Integration","text":"<p>Coordinate multiple repositories in a transaction:</p> <pre><code>class UnitOfWork:\n    \"\"\"Coordinates repository operations and transactions\"\"\"\n\n    def __init__(self, session: AsyncIOMotorClientSession):\n        self._session = session\n        self._order_repository = MongoOrderRepository(session.collection)\n        self._customer_repository = MongoCustomerRepository(session.collection)\n\n    @property\n    def orders(self) -&gt; IOrderRepository:\n        return self._order_repository\n\n    @property\n    def customers(self) -&gt; ICustomerRepository:\n        return self._customer_repository\n\n    async def commit_async(self):\n        \"\"\"Commit all changes\"\"\"\n        await self._session.commit_transaction()\n\n    async def rollback_async(self):\n        \"\"\"Rollback all changes\"\"\"\n        await self._session.abort_transaction()\n\n# Usage in handler\nclass PlaceOrderHandler(CommandHandler):\n    async def handle_async(self, command: PlaceOrderCommand):\n        async with self.unit_of_work.begin_transaction():\n            # Update customer\n            customer = await self.unit_of_work.customers.get_by_id_async(\n                command.customer_id\n            )\n            customer.increment_order_count()\n            await self.unit_of_work.customers.save_async(customer)\n\n            # Create order\n            order = Order.create(command.customer_id, command.items)\n            await self.unit_of_work.orders.save_async(order)\n\n            # Commit both changes together\n            await self.unit_of_work.commit_async()\n</code></pre>"},{"location":"patterns/repository/#testing-with-repositories","title":"\ud83e\uddea Testing with Repositories","text":""},{"location":"patterns/repository/#unit-testing-handlers","title":"Unit Testing Handlers","text":"<pre><code>import pytest\nfrom unittest.mock import AsyncMock, Mock\n\n@pytest.mark.asyncio\nasync def test_place_order_handler():\n    # Arrange\n    mock_repository = AsyncMock(spec=IOrderRepository)\n    mock_mapper = Mock(spec=Mapper)\n\n    handler = PlaceOrderHandler(\n        Mock(),  # service_provider\n        mock_repository,\n        mock_mapper\n    )\n\n    command = PlaceOrderCommand(\n        customer_id=\"cust_123\",\n        items=[OrderItemDto(pizza_name=\"Margherita\", size=\"large\", quantity=2)]\n    )\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n    mock_repository.save_async.assert_called_once()\n    saved_order = mock_repository.save_async.call_args[0][0]\n    assert saved_order.customer_id == \"cust_123\"\n    assert len(saved_order.items) == 1\n\n@pytest.mark.asyncio\nasync def test_get_customer_orders_query():\n    # Arrange\n    mock_repository = AsyncMock(spec=IOrderRepository)\n    mock_repository.find_by_customer_async.return_value = [\n        Order(customer_id=\"cust_123\", items=[]),\n        Order(customer_id=\"cust_123\", items=[])\n    ]\n\n    handler = GetCustomerOrdersHandler(Mock(), mock_repository, Mock())\n    query = GetCustomerOrdersQuery(customer_id=\"cust_123\")\n\n    # Act\n    result = await handler.handle_async(query)\n\n    # Assert\n    assert result.is_success\n    assert len(result.data) == 2\n    mock_repository.find_by_customer_async.assert_called_once_with(\"cust_123\", 0, 20)\n</code></pre>"},{"location":"patterns/repository/#integration-testing-with-real-repository","title":"Integration Testing with Real Repository","text":"<pre><code>@pytest.mark.integration\nclass TestMongoOrderRepository:\n    @pytest.fixture\n    async def repository(self, mongo_client):\n        \"\"\"Create repository with test database\"\"\"\n        collection = mongo_client.test_db.orders\n        await collection.delete_many({})  # Clean slate\n        return MongoOrderRepository(collection)\n\n    @pytest.mark.asyncio\n    async def test_save_and_retrieve_order(self, repository):\n        # Arrange\n        order = Order(\n            customer_id=\"test_customer\",\n            items=[\n                OrderItem(\"Margherita\", PizzaSize.LARGE, 2, Decimal(\"15.99\"))\n            ],\n            delivery_address=\"123 Test St\"\n        )\n\n        # Act\n        await repository.save_async(order)\n        retrieved = await repository.get_by_id_async(order.id)\n\n        # Assert\n        assert retrieved is not None\n        assert retrieved.id == order.id\n        assert retrieved.customer_id == \"test_customer\"\n        assert len(retrieved.items) == 1\n        assert retrieved.items[0].pizza_name == \"Margherita\"\n\n    @pytest.mark.asyncio\n    async def test_daily_sales_calculation(self, repository):\n        # Arrange\n        today = date.today()\n        orders = [\n            Order(customer_id=\"cust1\", items=[\n                OrderItem(\"Margherita\", PizzaSize.LARGE, 1, Decimal(\"15.99\"))\n            ]),\n            Order(customer_id=\"cust2\", items=[\n                OrderItem(\"Pepperoni\", PizzaSize.MEDIUM, 2, Decimal(\"12.99\"))\n            ])\n        ]\n\n        for order in orders:\n            await repository.save_async(order)\n\n        # Act\n        report = await repository.get_daily_sales_async(today)\n\n        # Assert\n        assert report.total_orders == 2\n        assert report.total_revenue &gt; Decimal(\"0\")\n</code></pre>"},{"location":"patterns/repository/#common-mistakes","title":"\u26a0\ufe0f Common Mistakes","text":""},{"location":"patterns/repository/#1-leaking-storage-details-into-domain","title":"1. Leaking Storage Details into Domain","text":"<pre><code># \u274c Wrong - MongoDB query in handler\nclass GetOrdersHandler(QueryHandler):\n    async def handle_async(self, query: GetOrdersQuery):\n        # Domain layer shouldn't know about MongoDB\n        orders = await self.repository._collection.find({\n            \"customer_id\": query.customer_id,\n            \"status\": {\"$ne\": \"cancelled\"}\n        }).to_list(None)\n\n# \u2705 Correct - domain-level method\nclass GetOrdersHandler(QueryHandler):\n    async def handle_async(self, query: GetOrdersQuery):\n        orders = await self.repository.find_active_by_customer_async(\n            query.customer_id\n        )\n</code></pre>"},{"location":"patterns/repository/#2-returning-database-objects","title":"2. Returning Database Objects","text":"<pre><code># \u274c Wrong - returning MongoDB document\nclass OrderRepository:\n    async def get_by_id_async(self, order_id: str) -&gt; dict:\n        return await self._collection.find_one({\"_id\": order_id})\n\n# \u2705 Correct - returning domain entity\nclass OrderRepository:\n    async def get_by_id_async(self, order_id: str) -&gt; Optional[Order]:\n        doc = await self._collection.find_one({\"_id\": order_id})\n        return self._document_to_entity(doc) if doc else None\n</code></pre>"},{"location":"patterns/repository/#3-not-using-dependency-injection","title":"3. Not Using Dependency Injection","text":"<pre><code># \u274c Wrong - creating repository directly\nclass PlaceOrderHandler:\n    def __init__(self):\n        self.repository = MongoOrderRepository(\n            MongoClient(\"mongodb://localhost\").db.orders\n        )  # \u274c Hard-coded, can't test, can't swap\n\n# \u2705 Correct - injecting interface\nclass PlaceOrderHandler:\n    def __init__(self, order_repository: IOrderRepository):\n        self.repository = order_repository  # \u2705 Testable, swappable\n</code></pre>"},{"location":"patterns/repository/#when-not-to-use","title":"\ud83d\udeab When NOT to Use","text":""},{"location":"patterns/repository/#1-simple-crud-with-no-business-logic","title":"1. Simple CRUD with No Business Logic","text":"<p>If you're just passing data through without any business logic:</p> <pre><code># Repository might be overkill - consider using ORM directly\n@app.get(\"/orders/{id}\")\nasync def get_order(id: str, db: Database):\n    return await db.orders.find_one({\"_id\": id})\n</code></pre>"},{"location":"patterns/repository/#2-high-performance-read-heavy-systems","title":"2. High-Performance Read-Heavy Systems","text":"<p>For read-heavy systems with complex queries, consider CQRS with separate read models:</p> <pre><code># Instead of repository, use optimized read model\nclass OrderReadModel:\n    \"\"\"Denormalized, optimized for queries\"\"\"\n    async def get_order_details_async(self, order_id: str):\n        # Single query with all data pre-joined\n        pass\n</code></pre>"},{"location":"patterns/repository/#3-event-sourcing-systems","title":"3. Event Sourcing Systems","text":"<p>Event-sourced aggregates typically use event stores, not traditional repositories:</p> <pre><code># Use event store instead of repository\nclass OrderEventStore:\n    async def load_events_async(self, order_id: str) -&gt; List[DomainEvent]:\n        pass\n\n    async def append_events_async(self, order_id: str, events: List[DomainEvent]):\n        pass\n</code></pre>"},{"location":"patterns/repository/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ol> <li>Interface in Domain: Repository interfaces belong in domain layer</li> <li>Implementation in Integration: Concrete repositories belong in integration layer</li> <li>Domain Objects: Always return domain entities, never database objects</li> <li>Testability: Use in-memory implementations for fast unit tests</li> <li>Swappable: Change storage by changing DI registration</li> <li>Query Encapsulation: Complex queries belong in repository, not handlers</li> <li>Dependency Injection: Always inject interface, not implementation</li> </ol>"},{"location":"patterns/repository/#related-patterns","title":"\ud83d\udd17 Related Patterns","text":"<ul> <li>Clean Architecture - Repositories implement integration layer</li> <li>CQRS Pattern - Separate repositories for commands and queries</li> <li>Unit of Work Pattern - Coordinate multiple repositories</li> <li>Dependency Injection - Wire repositories to handlers</li> <li>Event-Driven Architecture - Repositories can publish domain events</li> </ul> <p>This pattern guide demonstrates the Repository pattern using Mario's Pizzeria's data access layer, showing storage abstraction and testing strategies. \ud83d\uddc4\ufe0f````</p>"},{"location":"patterns/repository/#benefits","title":"\u2705 Benefits","text":""},{"location":"patterns/repository/#1-storage-independence","title":"1. Storage Independence","text":"<p>Business logic doesn't depend on specific storage implementations:</p> <pre><code># Domain service works with any repository implementation\nclass OrderService:\n    def __init__(self, order_repository: OrderRepository):\n        self._repository = order_repository  # Interface, not implementation\n\n    async def process_order(self, order: Order) -&gt; bool:\n        # Business logic is storage-agnostic\n        if order.total &gt; Decimal('100'):\n            order.apply_discount(Decimal('0.1'))  # 10% discount for large orders\n\n        await self._repository.save_async(order)\n        return True\n\n# Can swap implementations without changing business logic\n# services.add_scoped(OrderRepository, MongoOrderRepository)  # Production\n# services.add_scoped(OrderRepository, InMemoryOrderRepository)  # Testing\n</code></pre>"},{"location":"patterns/repository/#2-testability","title":"2. Testability","text":"<p>Easy to mock repositories for unit testing:</p> <pre><code>class TestOrderService:\n    def setup_method(self):\n        self.mock_repository = Mock(spec=OrderRepository)\n        self.service = OrderService(self.mock_repository)\n\n    async def test_large_order_gets_discount(self):\n        # Arrange\n        order = Order(customer_id=\"123\", total=Decimal('150'))\n\n        # Act\n        result = await self.service.process_order(order)\n\n        # Assert\n        assert order.total == Decimal('135')  # 10% discount applied\n        self.mock_repository.save_async.assert_called_once_with(order)\n</code></pre>"},{"location":"patterns/repository/#3-centralized-querying","title":"3. Centralized Querying","text":"<p>Complex queries are encapsulated in the repository:</p> <pre><code>class OrderRepository(Repository[Order, str]):\n    async def find_orders_by_customer_async(self, customer_id: str) -&gt; List[Order]:\n        \"\"\"Find all orders for a specific customer\"\"\"\n        pass\n\n    async def find_orders_by_date_range_async(\n        self,\n        start_date: datetime,\n        end_date: datetime\n    ) -&gt; List[Order]:\n        \"\"\"Find orders within a date range\"\"\"\n        pass\n\n    async def find_popular_pizzas_async(self, days: int = 30) -&gt; List[PopularPizzaStats]:\n        \"\"\"Get pizza popularity statistics\"\"\"\n        pass\n</code></pre>"},{"location":"patterns/repository/#data-flow","title":"\ud83d\udd04 Data Flow","text":"<p>Order management demonstrates repository data flow:</p> <pre><code>sequenceDiagram\n    participant Client\n    participant Handler as Order Handler\n    participant Repo as Order Repository\n    participant MongoDB as MongoDB\n    participant FileSystem as File System\n\n    Note over Client,FileSystem: Save Order Flow\n    Client-&gt;&gt;+Handler: PlaceOrderCommand\n    Handler-&gt;&gt;Handler: Create Order entity\n    Handler-&gt;&gt;+Repo: save_async(order)\n\n    alt MongoDB Implementation\n        Repo-&gt;&gt;+MongoDB: Insert document\n        MongoDB--&gt;&gt;-Repo: Success\n    else File Implementation\n        Repo-&gt;&gt;+FileSystem: Write JSON file\n        FileSystem--&gt;&gt;-Repo: Success\n    end\n\n    Repo--&gt;&gt;-Handler: Order saved\n    Handler--&gt;&gt;-Client: OrderDto result\n\n    Note over Client,FileSystem: Query Orders Flow\n    Client-&gt;&gt;+Handler: GetOrderHistoryQuery\n    Handler-&gt;&gt;+Repo: find_orders_by_customer_async(customer_id)\n\n    alt MongoDB Implementation\n        Repo-&gt;&gt;+MongoDB: Find query with aggregation\n        MongoDB--&gt;&gt;-Repo: Order documents\n    else File Implementation\n        Repo-&gt;&gt;+FileSystem: Read and filter JSON files\n        FileSystem--&gt;&gt;-Repo: Order data\n    end\n\n    Repo--&gt;&gt;-Handler: List[Order]\n    Handler-&gt;&gt;Handler: Map to DTOs\n    Handler--&gt;&gt;-Client: List[OrderDto]</code></pre>"},{"location":"patterns/repository/#use-cases","title":"\ud83c\udfaf Use Cases","text":"<p>Repository pattern is ideal for:</p> <ul> <li>Multiple Storage Options: Support different databases/storage systems</li> <li>Complex Queries: Encapsulate sophisticated data access logic</li> <li>Testing: Easy mocking and unit testing</li> <li>Legacy Integration: Abstract away legacy system complexity</li> </ul>"},{"location":"patterns/repository/#implementation-in-marios-pizzeria","title":"\ud83c\udf55 Implementation in Mario's Pizzeria","text":""},{"location":"patterns/repository/#repository-interface","title":"Repository Interface","text":"<pre><code># Abstract base repository for all entities\nclass Repository(ABC, Generic[TEntity, TKey]):\n    @abstractmethod\n    async def get_by_id_async(self, id: TKey) -&gt; Optional[TEntity]:\n        \"\"\"Get entity by ID\"\"\"\n        pass\n\n    @abstractmethod\n    async def save_async(self, entity: TEntity) -&gt; None:\n        \"\"\"Save or update entity\"\"\"\n        pass\n\n    @abstractmethod\n    async def delete_async(self, id: TKey) -&gt; bool:\n        \"\"\"Delete entity by ID\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_all_async(self) -&gt; List[TEntity]:\n        \"\"\"Get all entities\"\"\"\n        pass\n\n# Order-specific repository interface\nclass OrderRepository(Repository[Order, str]):\n    @abstractmethod\n    async def find_by_customer_async(self, customer_id: str) -&gt; List[Order]:\n        \"\"\"Find orders for a specific customer\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_by_status_async(self, status: OrderStatus) -&gt; List[Order]:\n        \"\"\"Find orders by status\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_by_date_range_async(\n        self,\n        start_date: datetime,\n        end_date: datetime\n    ) -&gt; List[Order]:\n        \"\"\"Find orders within date range\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_daily_sales_async(self, date: datetime.date) -&gt; DailySalesReport:\n        \"\"\"Get sales report for specific date\"\"\"\n        pass\n</code></pre>"},{"location":"patterns/repository/#mongodb-implementation_1","title":"MongoDB Implementation","text":"<pre><code>class MongoOrderRepository(OrderRepository):\n    def __init__(self, collection: Collection):\n        self._collection = collection\n\n    async def get_by_id_async(self, order_id: str) -&gt; Optional[Order]:\n        document = await self._collection.find_one({\"_id\": order_id})\n        return self._document_to_entity(document) if document else None\n\n    async def save_async(self, order: Order) -&gt; None:\n        document = self._entity_to_document(order)\n        await self._collection.replace_one(\n            {\"_id\": order.id},\n            document,\n            upsert=True\n        )\n\n    async def find_by_customer_async(self, customer_id: str) -&gt; List[Order]:\n        cursor = self._collection.find({\"customer_id\": customer_id})\n        documents = await cursor.to_list(None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def find_by_status_async(self, status: OrderStatus) -&gt; List[Order]:\n        cursor = self._collection.find({\"status\": status.value})\n        documents = await cursor.to_list(None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def get_daily_sales_async(self, date: datetime.date) -&gt; DailySalesReport:\n        start_datetime = datetime.combine(date, datetime.min.time())\n        end_datetime = datetime.combine(date, datetime.max.time())\n\n        pipeline = [\n            {\n                \"$match\": {\n                    \"created_at\": {\n                        \"$gte\": start_datetime,\n                        \"$lt\": end_datetime\n                    },\n                    \"status\": {\"$ne\": \"cancelled\"}\n                }\n            },\n            {\n                \"$group\": {\n                    \"_id\": None,\n                    \"total_orders\": {\"$sum\": 1},\n                    \"total_revenue\": {\"$sum\": \"$total\"},\n                    \"avg_order_value\": {\"$avg\": \"$total\"}\n                }\n            }\n        ]\n\n        result = await self._collection.aggregate(pipeline).to_list(1)\n        if result:\n            data = result[0]\n            return DailySalesReport(\n                date=date,\n                total_orders=data[\"total_orders\"],\n                total_revenue=Decimal(str(data[\"total_revenue\"])),\n                average_order_value=Decimal(str(data[\"avg_order_value\"]))\n            )\n\n        return DailySalesReport(date=date, total_orders=0, total_revenue=Decimal('0'))\n\n    def _entity_to_document(self, order: Order) -&gt; dict:\n        return {\n            \"_id\": order.id,\n            \"customer_id\": order.customer_id,\n            \"items\": [\n                {\n                    \"name\": item.pizza_name,\n                    \"size\": item.size,\n                    \"quantity\": item.quantity,\n                    \"price\": float(item.price)\n                }\n                for item in order.items\n            ],\n            \"total\": float(order.total),\n            \"status\": order.status.value,\n            \"delivery_address\": order.delivery_address,\n            \"special_instructions\": order.special_instructions,\n            \"created_at\": order.created_at,\n            \"updated_at\": order.updated_at\n        }\n\n    def _document_to_entity(self, document: dict) -&gt; Order:\n        items = [\n            OrderItem(\n                pizza_name=item[\"name\"],\n                size=PizzaSize(item[\"size\"]),\n                quantity=item[\"quantity\"],\n                price=Decimal(str(item[\"price\"]))\n            )\n            for item in document[\"items\"]\n        ]\n\n        order = Order(\n            id=document[\"_id\"],\n            customer_id=document[\"customer_id\"],\n            items=items,\n            delivery_address=document[\"delivery_address\"],\n            special_instructions=document.get(\"special_instructions\")\n        )\n\n        order.status = OrderStatus(document[\"status\"])\n        order.created_at = document[\"created_at\"]\n        order.updated_at = document[\"updated_at\"]\n\n        return order\n</code></pre>"},{"location":"patterns/repository/#file-based-implementation","title":"File-Based Implementation","text":"<pre><code>class FileOrderRepository(OrderRepository):\n    def __init__(self, data_directory: str):\n        self._data_dir = Path(data_directory)\n        self._data_dir.mkdir(exist_ok=True)\n\n    async def get_by_id_async(self, order_id: str) -&gt; Optional[Order]:\n        file_path = self._data_dir / f\"{order_id}.json\"\n        if not file_path.exists():\n            return None\n\n        async with aiofiles.open(file_path, 'r') as f:\n            data = json.loads(await f.read())\n            return self._dict_to_entity(data)\n\n    async def save_async(self, order: Order) -&gt; None:\n        file_path = self._data_dir / f\"{order.id}.json\"\n        data = self._entity_to_dict(order)\n\n        async with aiofiles.open(file_path, 'w') as f:\n            await f.write(json.dumps(data, indent=2, cls=DecimalEncoder))\n\n    async def find_by_customer_async(self, customer_id: str) -&gt; List[Order]:\n        orders = []\n        async for file_path in self._iterate_order_files():\n            async with aiofiles.open(file_path, 'r') as f:\n                data = json.loads(await f.read())\n                if data[\"customer_id\"] == customer_id:\n                    orders.append(self._dict_to_entity(data))\n        return orders\n\n    async def get_daily_sales_async(self, date: datetime.date) -&gt; DailySalesReport:\n        total_orders = 0\n        total_revenue = Decimal('0')\n\n        async for file_path in self._iterate_order_files():\n            async with aiofiles.open(file_path, 'r') as f:\n                data = json.loads(await f.read())\n                order_date = datetime.fromisoformat(data[\"created_at\"]).date()\n\n                if order_date == date and data[\"status\"] != \"cancelled\":\n                    total_orders += 1\n                    total_revenue += Decimal(str(data[\"total\"]))\n\n        avg_order_value = total_revenue / total_orders if total_orders &gt; 0 else Decimal('0')\n\n        return DailySalesReport(\n            date=date,\n            total_orders=total_orders,\n            total_revenue=total_revenue,\n            average_order_value=avg_order_value\n        )\n\n    async def _iterate_order_files(self):\n        for file_path in self._data_dir.glob(\"*.json\"):\n            yield file_path\n</code></pre>"},{"location":"patterns/repository/#in-memory-implementation-testing_1","title":"In-Memory Implementation (Testing)","text":"<pre><code>class InMemoryOrderRepository(OrderRepository):\n    def __init__(self):\n        self._orders: Dict[str, Order] = {}\n\n    async def get_by_id_async(self, order_id: str) -&gt; Optional[Order]:\n        return self._orders.get(order_id)\n\n    async def save_async(self, order: Order) -&gt; None:\n        # Create deep copy to avoid reference issues in tests\n        self._orders[order.id] = copy.deepcopy(order)\n\n    async def delete_async(self, order_id: str) -&gt; bool:\n        if order_id in self._orders:\n            del self._orders[order_id]\n            return True\n        return False\n\n    async def find_all_async(self) -&gt; List[Order]:\n        return list(self._orders.values())\n\n    async def find_by_customer_async(self, customer_id: str) -&gt; List[Order]:\n        return [order for order in self._orders.values()\n                if order.customer_id == customer_id]\n\n    async def find_by_status_async(self, status: OrderStatus) -&gt; List[Order]:\n        return [order for order in self._orders.values()\n                if order.status == status]\n\n    def clear(self):\n        \"\"\"Helper method for testing\"\"\"\n        self._orders.clear()\n</code></pre>"},{"location":"patterns/repository/#repository-registration","title":"Repository Registration","text":"<pre><code>class RepositoryConfiguration:\n    def configure_repositories(self, services: ServiceCollection, config: AppConfig):\n        if config.storage_type == \"mongodb\":\n            # MongoDB implementation\n            services.add_singleton(lambda sp: MongoClient(config.mongodb_connection))\n            services.add_scoped(lambda sp: MongoOrderRepository(\n                sp.get_service(MongoClient).orders_db.orders\n            ))\n\n        elif config.storage_type == \"file\":\n            # File-based implementation\n            services.add_scoped(lambda sp: FileOrderRepository(config.data_directory))\n\n        elif config.storage_type == \"memory\":\n            # In-memory implementation (testing)\n            services.add_singleton(InMemoryOrderRepository)\n\n        # Register interface to implementation\n        services.add_scoped(OrderRepository,\n                          lambda sp: sp.get_service(config.repository_implementation))\n</code></pre>"},{"location":"patterns/repository/#testing-with-repositories_1","title":"\ud83e\uddea Testing with Repositories","text":"<pre><code># Unit testing with mocked repositories\nclass TestOrderService:\n    def setup_method(self):\n        self.mock_repository = Mock(spec=OrderRepository)\n        self.service = OrderService(self.mock_repository)\n\n    async def test_get_customer_orders(self):\n        # Arrange\n        expected_orders = [\n            Order(customer_id=\"123\", items=[]),\n            Order(customer_id=\"123\", items=[])\n        ]\n        self.mock_repository.find_by_customer_async.return_value = expected_orders\n\n        # Act\n        result = await self.service.get_customer_orders(\"123\")\n\n        # Assert\n        assert len(result) == 2\n        self.mock_repository.find_by_customer_async.assert_called_once_with(\"123\")\n\n# Integration testing with real repositories\nclass TestOrderRepositoryIntegration:\n    def setup_method(self):\n        self.repository = InMemoryOrderRepository()\n\n    async def test_save_and_retrieve_order(self):\n        # Arrange\n        order = Order(\n            customer_id=\"123\",\n            items=[OrderItem(\"Margherita\", PizzaSize.LARGE, 1, Decimal('15.99'))]\n        )\n\n        # Act\n        await self.repository.save_async(order)\n        retrieved = await self.repository.get_by_id_async(order.id)\n\n        # Assert\n        assert retrieved is not None\n        assert retrieved.customer_id == \"123\"\n        assert len(retrieved.items) == 1\n</code></pre>"},{"location":"patterns/repository/#related-patterns_1","title":"\ud83d\udd17 Related Patterns","text":"<ul> <li>Clean Architecture - Repositories belong in the integration layer</li> <li>CQRS Pattern - Separate repositories for commands and queries</li> <li>Event-Driven Pattern - Repositories can publish domain events</li> </ul> <p>This pattern guide demonstrates the Repository pattern using Mario's Pizzeria's data access layer. The abstraction enables storage flexibility and comprehensive testing strategies. \ud83d\uddc4\ufe0f</p>"},{"location":"patterns/resource-oriented-architecture/","title":"\ud83c\udfaf Resource Oriented Architecture (ROA)","text":"<p>\ud83d\udea7 Work in Progress: This documentation is being updated to include beginner-friendly explanations with What &amp; Why sections, Common Mistakes, and When NOT to Use guidance. The content below is accurate but will be enhanced soon.</p> <p>Resource Oriented Architecture is a powerful pattern for building systems that manage resources through their lifecycle, similar to how Kubernetes manages cluster resources. Neuroglia provides comprehensive support for ROA patterns including watchers, controllers, and reconciliation loops.</p>"},{"location":"patterns/resource-oriented-architecture/#overview","title":"\ud83c\udfaf Overview","text":"<p>ROA provides:</p> <ul> <li>\ud83d\udcca Resource Management: Declarative resource definitions with desired vs actual state</li> <li>\ud83d\udc40 Watchers: Continuous monitoring of resource changes through polling or event streams</li> <li>\ud83c\udfae Controllers: Business logic that responds to resource changes and implements state transitions</li> <li>\ud83d\udd04 Reconciliation: Periodic loops that ensure system consistency and handle drift detection</li> <li>\ud83d\udee1\ufe0f Safety Mechanisms: Timeout handling, error recovery, and corrective actions</li> </ul>"},{"location":"patterns/resource-oriented-architecture/#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<pre><code>graph TB\n    subgraph \"\ud83d\udcca Resource Layer\"\n        A[Resource Definition]\n        B[Resource Storage]\n        C[Resource Events]\n    end\n\n    subgraph \"\ud83d\udc40 Observation Layer\"\n        D[Watcher] --&gt; E[Event Stream]\n        F[Poller] --&gt; G[Change Detection]\n    end\n\n    subgraph \"\ud83c\udfae Control Layer\"\n        H[Controller] --&gt; I[Business Logic]\n        I --&gt; J[State Transitions]\n        I --&gt; K[Action Execution]\n    end\n\n    subgraph \"\ud83d\udd04 Reconciliation Layer\"\n        L[Reconciliation Loop] --&gt; M[Drift Detection]\n        M --&gt; N[Corrective Actions]\n        N --&gt; O[State Restoration]\n    end\n\n    subgraph \"\ud83d\udee1\ufe0f Safety Layer\"\n        P[Error Handling] --&gt; Q[Retry Logic]\n        Q --&gt; R[Circuit Breaker]\n        R --&gt; S[Timeout Management]\n    end\n\n    A --&gt; B\n    B --&gt; C\n    C --&gt; D\n    C --&gt; F\n    E --&gt; H\n    G --&gt; H\n    H --&gt; L\n    L --&gt; P\n\n    style A fill:#e3f2fd\n    style H fill:#f3e5f5\n    style L fill:#e8f5e8\n    style P fill:#fff3e0</code></pre>"},{"location":"patterns/resource-oriented-architecture/#core-components","title":"\ud83c\udfd7\ufe0f Core Components","text":""},{"location":"patterns/resource-oriented-architecture/#resource-definition","title":"Resource Definition","text":"<p>Resources are declarative objects that define desired state:</p> <pre><code>@dataclass\nclass LabInstanceResource:\n    api_version: str = \"lab.neuroglia.com/v1\"\n    kind: str = \"LabInstance\"\n    metadata: Dict[str, Any] = None\n    spec: Dict[str, Any] = None      # Desired state\n    status: Dict[str, Any] = None    # Current state\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#watcher-pattern","title":"Watcher Pattern","text":"<p>Watchers continuously monitor resources for changes:</p> <pre><code>class LabInstanceWatcher:\n    async def start_watching(self):\n        while self.is_running:\n            # Poll for changes since last known version\n            changes = self.storage.list_resources(since_version=self.last_resource_version)\n\n            for resource in changes:\n                await self._handle_resource_change(resource)\n\n            await asyncio.sleep(self.poll_interval)\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#controller-pattern","title":"Controller Pattern","text":"<p>Controllers respond to resource changes with business logic:</p> <pre><code>class LabInstanceController:\n    async def handle_resource_event(self, resource: LabInstanceResource):\n        current_state = resource.status.get('state')\n\n        if current_state == ResourceState.PENDING.value:\n            await self._start_provisioning(resource)\n        elif current_state == ResourceState.PROVISIONING.value:\n            await self._check_provisioning_status(resource)\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#reconciliation-loop","title":"Reconciliation Loop","text":"<p>Reconcilers ensure eventual consistency:</p> <pre><code>class LabInstanceScheduler:\n    async def start_reconciliation(self):\n        while self.is_running:\n            await self._reconcile_all_resources()\n            await asyncio.sleep(self.reconcile_interval)\n\n    async def _reconcile_resource(self, resource):\n        # Check for stuck states, timeouts, and drift\n        # Take corrective actions as needed\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#key-patterns","title":"\ud83d\ude80 Key Patterns","text":""},{"location":"patterns/resource-oriented-architecture/#1-declarative-state-management","title":"1. Declarative State Management","text":"<p>Resources define what should exist, not how to create it:</p> <pre><code># Desired state (spec)\nspec = {\n    'template': 'python-basics',\n    'duration': '60m',\n    'studentEmail': 'student@example.com'\n}\n\n# Current state (status)\nstatus = {\n    'state': 'ready',\n    'endpoint': 'https://lab-instance.example.com',\n    'readyAt': '2025-09-09T21:34:19Z'\n}\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#2-event-driven-processing","title":"2. Event-Driven Processing","text":"<p>Watchers detect changes and notify controllers immediately:</p> <pre><code>Resource Change \u2192 Watcher Detection \u2192 Controller Response \u2192 State Update\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#3-asynchronous-reconciliation","title":"3. Asynchronous Reconciliation","text":"<p>Controllers handle immediate responses while reconcilers provide safety:</p> <pre><code># Controller: Immediate response to events\nasync def handle_resource_event(self, resource):\n    if resource.state == PENDING:\n        await self.start_provisioning(resource)\n\n# Reconciler: Periodic safety checks\nasync def reconcile_resource(self, resource):\n    if self.is_stuck_provisioning(resource):\n        await self.mark_as_failed(resource)\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#4-state-machine-implementation","title":"4. State Machine Implementation","text":"<p>Resources progress through well-defined states:</p> <pre><code>PENDING \u2192 PROVISIONING \u2192 READY \u2192 (cleanup) \u2192 DELETING \u2192 DELETED\n    \u2193                      \u2193\n  FAILED              \u2190 FAILED\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#execution-model","title":"\u26a1 Execution Model","text":""},{"location":"patterns/resource-oriented-architecture/#timing-and-coordination","title":"Timing and Coordination","text":"<ul> <li>Watchers: Poll every 2-5 seconds for near-real-time responsiveness</li> <li>Controllers: Respond immediately to detected changes</li> <li>Reconcilers: Run every 10-30 seconds for consistency checks</li> </ul>"},{"location":"patterns/resource-oriented-architecture/#concurrent-processing","title":"Concurrent Processing","text":"<p>All components run concurrently:</p> <pre><code>async def main():\n    # Start all components concurrently\n    watcher_task = asyncio.create_task(watcher.start_watching())\n    scheduler_task = asyncio.create_task(scheduler.start_reconciliation())\n\n    # Controllers are event-driven (no separate task needed)\n    watcher.add_event_handler(controller.handle_resource_event)\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#safety-and-reliability","title":"\ud83d\udee1\ufe0f Safety and Reliability","text":""},{"location":"patterns/resource-oriented-architecture/#timeout-handling","title":"Timeout Handling","text":"<p>Reconcilers detect and handle stuck states:</p> <pre><code>if resource.state == PROVISIONING and age &gt; timeout_threshold:\n    await self.mark_as_failed(resource, \"Provisioning timeout\")\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#error-recovery","title":"Error Recovery","text":"<p>Controllers and reconcilers implement retry logic:</p> <pre><code>try:\n    await self.provision_lab_instance(resource)\nexcept Exception as e:\n    resource.status['retries'] = resource.status.get('retries', 0) + 1\n    if resource.status['retries'] &lt; max_retries:\n        await self.schedule_retry(resource)\n    else:\n        await self.mark_as_failed(resource, str(e))\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#drift-detection","title":"Drift Detection","text":"<p>Reconcilers verify that actual state matches desired state:</p> <pre><code>async def check_drift(self, resource):\n    actual_state = await self.get_actual_infrastructure_state(resource)\n    desired_state = resource.spec\n\n    if actual_state != desired_state:\n        await self.correct_drift(resource, actual_state, desired_state)\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#observability","title":"\ud83d\udcca Observability","text":""},{"location":"patterns/resource-oriented-architecture/#metrics-and-logging","title":"Metrics and Logging","text":"<p>ROA components provide rich observability:</p> <pre><code>logger.info(f\"\ud83d\udd0d Watcher detected change: {resource_id} -&gt; {state}\")\nlogger.info(f\"\ud83c\udfae Controller processing: {resource_id} (state: {state})\")\nlogger.info(f\"\ud83d\udd04 Reconciling {len(resources)} resources\")\nlogger.warning(f\"\u26a0\ufe0f Reconciler: Resource stuck: {resource_id}\")\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#resource-versioning","title":"Resource Versioning","text":"<p>Track changes with resource versions:</p> <pre><code>resource.metadata['resourceVersion'] = str(self.next_version())\nresource.metadata['lastModified'] = datetime.now(timezone.utc).isoformat()\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#configuration","title":"\ud83d\udd27 Configuration","text":""},{"location":"patterns/resource-oriented-architecture/#tuning-parameters","title":"Tuning Parameters","text":"<p>Adjust timing for your use case:</p> <pre><code># Development: Fast feedback\nwatcher = LabInstanceWatcher(storage, poll_interval=1.0)\nscheduler = LabInstanceScheduler(storage, reconcile_interval=5.0)\n\n# Production: Balanced performance\nwatcher = LabInstanceWatcher(storage, poll_interval=5.0)\nscheduler = LabInstanceScheduler(storage, reconcile_interval=30.0)\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#scaling-considerations","title":"Scaling Considerations","text":"<ul> <li>Multiple Watchers: Use resource sharding for scale</li> <li>Controller Parallelism: Process multiple resources concurrently</li> <li>Reconciler Batching: Group operations for efficiency</li> </ul>"},{"location":"patterns/resource-oriented-architecture/#use-cases","title":"\ud83c\udfaf Use Cases","text":"<p>ROA is ideal for:</p> <ul> <li>Infrastructure Management: Cloud resources, containers, services</li> <li>Workflow Orchestration: Multi-step processes with dependencies</li> <li>Resource Lifecycle: Provisioning, monitoring, cleanup</li> <li>System Integration: Managing external system state</li> <li>DevOps Automation: CI/CD pipelines, deployment management</li> </ul>"},{"location":"patterns/resource-oriented-architecture/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\ud83c\udfd7\ufe0f Watcher &amp; Reconciliation Patterns - Detailed pattern explanations</li> <li>\u26a1 Execution Flow - How components coordinate</li> <li>\ud83e\uddea Lab Resource Manager Sample - Complete ROA implementation</li> <li>\ud83c\udfaf CQRS &amp; Mediation - Command/Query patterns used in ROA</li> <li>\ud83d\uddc4\ufe0f Data Access - Repository patterns for resource storage</li> </ul>"},{"location":"patterns/unit-of-work/","title":"\ud83d\udd04 Unit of Work Pattern","text":"<p>Estimated reading time: 25 minutes</p> <p>The Unit of Work pattern maintains a list of objects affected by a business transaction and coordinates writing out changes while resolving concurrency problems. In the Neuroglia framework, it provides automatic domain event collection and dispatching, enabling both event-sourced and state-based persistence patterns.</p>"},{"location":"patterns/unit-of-work/#what-why","title":"\ud83d\udca1 What &amp; Why","text":""},{"location":"patterns/unit-of-work/#the-problem-manual-event-management-and-inconsistent-transactions","title":"\u274c The Problem: Manual Event Management and Inconsistent Transactions","text":"<p>Without Unit of Work, managing domain events and transactional consistency is manual and error-prone:</p> <pre><code># \u274c PROBLEM: Manual event management and inconsistent transactions\nclass CreateOrderHandler(CommandHandler[CreateOrderCommand, OperationResult[OrderDto]]):\n    def __init__(self,\n                 order_repository: OrderRepository,\n                 event_bus: EventBus):\n        self.order_repository = order_repository\n        self.event_bus = event_bus\n\n    async def handle_async(self, command: CreateOrderCommand):\n        # Create order (raises domain events)\n        order = Order.create(command.customer_id, command.items)\n\n        # Save order\n        await self.order_repository.save_async(order)\n\n        # PROBLEM: Must manually extract and publish events!\n        events = order.get_uncommitted_events()\n        for event in events:\n            await self.event_bus.publish_async(event)\n        order.mark_events_as_committed()\n\n        # PROBLEMS:\n        # \u274c What if save succeeds but event publishing fails?\n        # \u274c Events published even if transaction rolls back!\n        # \u274c Must remember to publish events in EVERY handler!\n        # \u274c Easy to forget to mark events as committed!\n        # \u274c No coordination between multiple aggregates!\n\n        return self.created(order)\n\n# Another handler with the SAME manual code!\nclass ConfirmOrderHandler(CommandHandler[ConfirmOrderCommand, OperationResult[OrderDto]]):\n    async def handle_async(self, command: ConfirmOrderCommand):\n        order = await self.order_repository.get_by_id_async(command.order_id)\n        order.confirm()\n        await self.order_repository.save_async(order)\n\n        # Copy-pasted event management code - DUPLICATION!\n        events = order.get_uncommitted_events()\n        for event in events:\n            await self.event_bus.publish_async(event)\n        order.mark_events_as_committed()\n\n        return self.ok(order)\n\n# Multi-aggregate scenario is even WORSE!\nclass TransferInventoryHandler(CommandHandler[TransferInventoryCommand, OperationResult]):\n    async def handle_async(self, command: TransferInventoryCommand):\n        source = await self.warehouse_repository.get_by_id_async(command.source_id)\n        target = await self.warehouse_repository.get_by_id_async(command.target_id)\n\n        # Modify both aggregates\n        source.remove_inventory(command.product_id, command.quantity)\n        target.add_inventory(command.product_id, command.quantity)\n\n        # Save both\n        await self.warehouse_repository.save_async(source)\n        await self.warehouse_repository.save_async(target)\n\n        # PROBLEM: Must manually collect events from BOTH aggregates!\n        all_events = []\n        all_events.extend(source.get_uncommitted_events())\n        all_events.extend(target.get_uncommitted_events())\n\n        for event in all_events:\n            await self.event_bus.publish_async(event)\n\n        source.mark_events_as_committed()\n        target.mark_events_as_committed()\n\n        # This is TEDIOUS and ERROR-PRONE!\n        return self.ok()\n</code></pre> <p>Problems with Manual Event Management:</p> <ul> <li>\u274c Event Publishing Scattered: Every handler must remember to publish events</li> <li>\u274c Duplication: Same event management code copy-pasted everywhere</li> <li>\u274c Inconsistency Risk: Events published even if transaction fails</li> <li>\u274c Multi-Aggregate Complexity: Collecting events from multiple aggregates is tedious</li> <li>\u274c Easy to Forget: Developers forget to publish events or mark as committed</li> <li>\u274c No Coordination: No central mechanism to track modified aggregates</li> </ul>"},{"location":"patterns/unit-of-work/#the-solution-unit-of-work-for-automatic-event-coordination","title":"\u2705 The Solution: Unit of Work for Automatic Event Coordination","text":"<p>Unit of Work automatically tracks aggregates and coordinates event dispatching:</p> <pre><code># \u2705 SOLUTION: Unit of Work handles event coordination automatically\nfrom neuroglia.data.abstractions import IUnitOfWork\n\nclass CreateOrderHandler(CommandHandler[CreateOrderCommand, OperationResult[OrderDto]]):\n    def __init__(self,\n                 order_repository: OrderRepository,\n                 unit_of_work: IUnitOfWork):\n        self.order_repository = order_repository\n        self.unit_of_work = unit_of_work\n\n    async def handle_async(self, command: CreateOrderCommand):\n        # 1. Create order (raises domain events)\n        order = Order.create(command.customer_id, command.items)\n\n        # 2. Save order\n        await self.order_repository.save_async(order)\n\n        # 3. Register aggregate with Unit of Work\n        self.unit_of_work.register_aggregate(order)\n\n        # That's IT! Pipeline behavior handles the rest:\n        # - Extracts events from registered aggregates\n        # - Publishes events ONLY if transaction succeeds\n        # - Marks events as committed automatically\n        # - Clears unit of work for next request\n\n        return self.created(order)\n\n# Multi-aggregate scenario is SIMPLE!\nclass TransferInventoryHandler(CommandHandler[TransferInventoryCommand, OperationResult]):\n    async def handle_async(self, command: TransferInventoryCommand):\n        source = await self.warehouse_repository.get_by_id_async(command.source_id)\n        target = await self.warehouse_repository.get_by_id_async(command.target_id)\n\n        # Modify both aggregates\n        source.remove_inventory(command.product_id, command.quantity)\n        target.add_inventory(command.product_id, command.quantity)\n\n        # Save both\n        await self.warehouse_repository.save_async(source)\n        await self.warehouse_repository.save_async(target)\n\n        # Register both aggregates\n        self.unit_of_work.register_aggregate(source)\n        self.unit_of_work.register_aggregate(target)\n\n        # Unit of Work collects events from BOTH automatically!\n        return self.ok()\n\n# Pipeline Behavior handles event dispatching automatically\nclass DomainEventDispatcherBehavior(PipelineBehavior):\n    def __init__(self,\n                 unit_of_work: IUnitOfWork,\n                 event_bus: EventBus):\n        self.unit_of_work = unit_of_work\n        self.event_bus = event_bus\n\n    async def handle_async(self, request, next_handler):\n        # Execute handler\n        result = await next_handler()\n\n        # Only publish events if handler succeeded\n        if result.is_success:\n            # Get ALL events from ALL registered aggregates\n            events = self.unit_of_work.get_domain_events()\n\n            # Publish events\n            for event in events:\n                await self.event_bus.publish_async(event)\n\n            # Clear unit of work for next request\n            self.unit_of_work.clear()\n\n        return result\n\n# Register in DI container\nservices = ServiceCollection()\nservices.add_scoped(IUnitOfWork, UnitOfWork)\nservices.add_scoped(PipelineBehavior, DomainEventDispatcherBehavior)\n</code></pre> <p>Benefits of Unit of Work:</p> <ul> <li>\u2705 Automatic Event Collection: No manual event extraction needed</li> <li>\u2705 Centralized Coordination: Single place to track modified aggregates</li> <li>\u2705 Consistent Event Publishing: Events only published if transaction succeeds</li> <li>\u2705 Multi-Aggregate Support: Easily handle multiple aggregates in one transaction</li> <li>\u2705 Reduced Duplication: Event management code in one place (pipeline)</li> <li>\u2705 Hard to Forget: Framework handles event lifecycle automatically</li> <li>\u2705 Testability: Unit of Work can be mocked for testing</li> </ul>"},{"location":"patterns/unit-of-work/#pattern-overview","title":"\ud83c\udfaf Pattern Overview","text":"<p>The Unit of Work pattern serves as a coordination mechanism between your domain aggregates and the infrastructure, ensuring that:</p> <ul> <li>Transactional Consistency: All changes within a business operation succeed or fail together</li> <li>Event Coordination: Domain events are collected and dispatched automatically after successful operations</li> <li>Aggregate Tracking: Modified entities are tracked during the request lifecycle</li> <li>Clean Separation: Domain logic remains pure while infrastructure handles persistence concerns</li> </ul>"},{"location":"patterns/unit-of-work/#architecture-integration","title":"\ud83c\udfd7\ufe0f Architecture Integration","text":"<pre><code>graph TB\n    subgraph \"\ud83d\udcbc Application Layer\"\n        CH[Command Handler]\n        QH[Query Handler]\n    end\n\n    subgraph \"\ud83d\udd04 Unit of Work\"\n        UOW[IUnitOfWork]\n        AGG_LIST[Registered Aggregates]\n        EVENT_COLL[Domain Event Collection]\n    end\n\n    subgraph \"\ud83c\udfdb\ufe0f Domain Layer\"\n        ENT1[Entity/Aggregate 1]\n        ENT2[Entity/Aggregate 2]\n        DE[Domain Events]\n    end\n\n    subgraph \"\ud83d\udd27 Infrastructure\"\n        REPO[Repositories]\n        DB[(Database)]\n        MW[Pipeline Middleware]\n    end\n\n    CH --&gt; UOW\n    CH --&gt; ENT1\n    CH --&gt; ENT2\n    ENT1 --&gt; DE\n    ENT2 --&gt; DE\n    UOW --&gt; AGG_LIST\n    UOW --&gt; EVENT_COLL\n    CH --&gt; REPO\n    REPO --&gt; DB\n    MW --&gt; UOW\n    MW --&gt; DE</code></pre>"},{"location":"patterns/unit-of-work/#core-interface","title":"\ud83d\udd27 Core Interface","text":"<p>The <code>IUnitOfWork</code> interface provides a simple contract for aggregate and event management:</p> <pre><code>from abc import ABC, abstractmethod\nfrom typing import List\nfrom neuroglia.data.abstractions import AggregateRoot, DomainEvent\n\nclass IUnitOfWork(ABC):\n    \"\"\"Unit of Work pattern for coordinating aggregate changes and domain events.\"\"\"\n\n    @abstractmethod\n    def register_aggregate(self, aggregate: AggregateRoot) -&gt; None:\n        \"\"\"Registers an aggregate for event collection and tracking.\"\"\"\n\n    @abstractmethod\n    def get_domain_events(self) -&gt; List[DomainEvent]:\n        \"\"\"Gets all domain events from registered aggregates.\"\"\"\n\n    @abstractmethod\n    def clear(self) -&gt; None:\n        \"\"\"Clears all registered aggregates and collected events.\"\"\"\n\n    @abstractmethod\n    def has_changes(self) -&gt; bool:\n        \"\"\"Determines if any aggregates have pending changes.\"\"\"\n</code></pre>"},{"location":"patterns/unit-of-work/#implementation-patterns","title":"\ud83d\udce6 Implementation Patterns","text":""},{"location":"patterns/unit-of-work/#1-basic-usage-in-command-handlers","title":"1. Basic Usage in Command Handlers","text":"<pre><code>class CreateOrderHandler(CommandHandler[CreateOrderCommand, OperationResult[OrderDto]]):\n    def __init__(self,\n                 order_repository: OrderRepository,\n                 unit_of_work: IUnitOfWork):\n        self.order_repository = order_repository\n        self.unit_of_work = unit_of_work\n\n    async def handle_async(self, command: CreateOrderCommand) -&gt; OperationResult[OrderDto]:\n        # 1. Create domain entity (raises domain events)\n        order = Order.create(command.customer_id, command.items)\n\n        # 2. Persist state\n        await self.order_repository.save_async(order)\n\n        # 3. Register for automatic event dispatching\n        self.unit_of_work.register_aggregate(order)\n\n        # 4. Return result - events dispatched automatically by middleware\n        return self.created(OrderDto.from_entity(order))\n</code></pre>"},{"location":"patterns/unit-of-work/#2-multiple-aggregates-in-single-transaction","title":"2. Multiple Aggregates in Single Transaction","text":"<pre><code>class ProcessPaymentHandler(CommandHandler):\n    async def handle_async(self, command: ProcessPaymentCommand) -&gt; OperationResult:\n        # Multiple aggregates modified in single business transaction\n\n        # Update order\n        order = await self.order_repository.get_by_id_async(command.order_id)\n        order.mark_paid(command.payment_id)  # Raises OrderPaidEvent\n        await self.order_repository.save_async(order)\n        self.unit_of_work.register_aggregate(order)\n\n        # Update customer account\n        customer = await self.customer_repository.get_by_id_async(order.customer_id)\n        customer.record_purchase(order.total_amount)  # Raises PurchaseRecordedEvent\n        await self.customer_repository.save_async(customer)\n        self.unit_of_work.register_aggregate(customer)\n\n        # Update inventory\n        for item in order.items:\n            inventory = await self.inventory_repository.get_by_product_id(item.product_id)\n            inventory.reduce_stock(item.quantity)  # Raises StockReducedEvent\n            await self.inventory_repository.save_async(inventory)\n            self.unit_of_work.register_aggregate(inventory)\n\n        # All events from all aggregates dispatched together\n        return self.ok({\"order_id\": order.id, \"payment_processed\": True})\n</code></pre>"},{"location":"patterns/unit-of-work/#persistence-pattern-flexibility","title":"\ud83c\udfad Persistence Pattern Flexibility","text":"<p>The Unit of Work pattern supports multiple persistence approaches with the same infrastructure:</p>"},{"location":"patterns/unit-of-work/#pattern-1-simple-entity-with-state-persistence","title":"Pattern 1: Simple Entity with State Persistence","text":"<p>\u2192 Complexity Level: \u2b50\u2b50\u2606\u2606\u2606</p> <p>Best for: CRUD operations, simple domains, traditional persistence</p> <pre><code>class Product(Entity):  # \u2190 Just Entity, no AggregateRoot needed!\n    \"\"\"Simple entity with domain events for state-based persistence.\"\"\"\n\n    def __init__(self, name: str, price: float):\n        super().__init__()\n        self._id = str(uuid.uuid4())\n        self.name = name\n        self.price = price\n\n        # Raise domain event\n        self._raise_domain_event(ProductCreatedEvent(self.id, name, price))\n\n    def update_price(self, new_price: float):\n        \"\"\"Business logic with domain event.\"\"\"\n        if new_price != self.price:\n            old_price = self.price\n            self.price = new_price\n            self._raise_domain_event(PriceChangedEvent(self.id, old_price, new_price))\n\n    # Minimal event infrastructure\n    def _raise_domain_event(self, event: DomainEvent):\n        if not hasattr(self, '_pending_events'):\n            self._pending_events = []\n        self._pending_events.append(event)\n\n    @property\n    def domain_events(self) -&gt; List[DomainEvent]:\n        return getattr(self, '_pending_events', []).copy()\n\n    def clear_pending_events(self):\n        if hasattr(self, '_pending_events'):\n            self._pending_events.clear()\n\n# Usage - Same UnitOfWork, simpler entity\nclass UpdateProductPriceHandler(CommandHandler):\n    async def handle_async(self, command: UpdateProductPriceCommand):\n        product = await self.product_repository.get_by_id_async(command.product_id)\n        product.update_price(command.new_price)  # Raises PriceChangedEvent\n\n        await self.product_repository.save_async(product)  # Save state to DB\n        self.unit_of_work.register_aggregate(product)      # Auto-dispatch events\n\n        return self.ok(ProductDto.from_entity(product))\n</code></pre> <p>Characteristics:</p> <ul> <li>\u2705 Direct state persistence to database</li> <li>\u2705 Simple entity inheritance (<code>Entity</code>)</li> <li>\u2705 Automatic domain event dispatching</li> <li>\u2705 No event store required</li> <li>\u2705 Traditional database schemas</li> <li>\u2705 Easy to understand and implement</li> </ul>"},{"location":"patterns/unit-of-work/#pattern-2-aggregate-root-with-event-sourcing","title":"Pattern 2: Aggregate Root with Event Sourcing","text":"<p>\u2192 Complexity Level: \u2b50\u2b50\u2b50\u2b50\u2b50</p> <p>Best for: Complex domains, audit requirements, temporal queries</p> <pre><code>class OrderAggregate(AggregateRoot[OrderState, UUID]):\n    \"\"\"Complex aggregate with full event sourcing.\"\"\"\n\n    def place_order(self, customer_id: str, items: List[OrderItem]):\n        \"\"\"Rich business logic with event sourcing.\"\"\"\n        # Business rules validation\n        if not items:\n            raise DomainException(\"Order must have at least one item\")\n\n        total = sum(item.price * item.quantity for item in items)\n        if total &lt;= 0:\n            raise DomainException(\"Order total must be positive\")\n\n        # Apply event to change state\n        event = OrderPlacedEvent(\n            order_id=self.id,\n            customer_id=customer_id,\n            items=items,\n            total_amount=total,\n            placed_at=datetime.utcnow()\n        )\n\n        # Event sourcing: event changes state + is stored for replay\n        self.state.on(event)  # Apply to current state\n        self.register_event(event)  # Register for persistence\n\n    def add_item(self, product_id: str, quantity: int, price: Decimal):\n        \"\"\"Add item with business rule validation.\"\"\"\n        if self.state.status != OrderStatus.DRAFT:\n            raise DomainException(\"Cannot modify confirmed order\")\n\n        event = ItemAddedEvent(self.id, product_id, quantity, price)\n        self.state.on(event)\n        self.register_event(event)\n\n# Usage - Same UnitOfWork, event-sourced aggregate\nclass PlaceOrderHandler(CommandHandler):\n    async def handle_async(self, command: PlaceOrderCommand):\n        order = OrderAggregate()\n        order.place_order(command.customer_id, command.items)  # Raises OrderPlacedEvent\n\n        await self.order_repository.save_async(order)  # Save events to event store\n        self.unit_of_work.register_aggregate(order)    # Auto-dispatch events\n\n        return self.created(OrderDto.from_aggregate(order))\n</code></pre> <p>Characteristics:</p> <ul> <li>\u2705 Complete event sourcing with event store</li> <li>\u2705 Full aggregate pattern with <code>AggregateRoot[TState, TKey]</code></li> <li>\u2705 Rich business logic and invariant enforcement</li> <li>\u2705 Temporal queries and audit trails</li> <li>\u2705 Event replay and projection capabilities</li> <li>\u2705 Complex consistency boundaries</li> </ul>"},{"location":"patterns/unit-of-work/#pattern-3-hybrid-approach","title":"Pattern 3: Hybrid Approach","text":"<p>\u2192 Complexity Level: \u2b50\u2b50\u2b50\u2606\u2606</p> <p>Best for: Mixed requirements, gradual migration, pragmatic solutions</p> <pre><code># Mix both patterns in the same application\nclass OrderProcessingHandler(CommandHandler):\n    async def handle_async(self, command: ProcessOrderCommand):\n        # Event-sourced aggregate for complex business logic\n        order = await self.order_repository.get_by_id_async(command.order_id)\n        order.process_payment(command.payment_info)  # Complex event-sourced logic\n        await self.order_repository.save_async(order)\n        self.unit_of_work.register_aggregate(order)\n\n        # Simple entity for straightforward updates\n        inventory = await self.inventory_repository.get_by_product_id(command.product_id)\n        inventory.reduce_stock(command.quantity)  # Simple state-based persistence\n        await self.inventory_repository.save_async(inventory)\n        self.unit_of_work.register_aggregate(inventory)\n\n        # Both patterns work together seamlessly\n        return self.ok()\n</code></pre>"},{"location":"patterns/unit-of-work/#infrastructure-integration","title":"\ud83d\udd27 Infrastructure Integration","text":""},{"location":"patterns/unit-of-work/#pipeline-integration","title":"Pipeline Integration","text":"<p>The Unit of Work integrates seamlessly with the mediation pipeline through <code>DomainEventDispatchingMiddleware</code>:</p> <pre><code># Automatic setup\nservices = ServiceCollection()\nservices.add_mediator()\nservices.add_state_based_persistence()  # Includes UnitOfWork + Event Dispatching\n\n# Pipeline execution flow:\n# 1. Command received\n# 2. [Optional] Transaction begins\n# 3. Command handler executes\n# 4. Handler registers aggregates with UnitOfWork\n# 5. Command completes successfully\n# 6. DomainEventDispatchingMiddleware collects events\n# 7. Events dispatched through mediator\n# 8. [Optional] Transaction commits\n# 9. UnitOfWork cleared for next request\n</code></pre>"},{"location":"patterns/unit-of-work/#event-collection-mechanism","title":"Event Collection Mechanism","text":"<p>The UnitOfWork uses duck typing to collect events from any object, supporting both patterns:</p> <pre><code>def get_domain_events(self) -&gt; List[DomainEvent]:\n    \"\"\"Flexible event collection supporting multiple patterns.\"\"\"\n    events = []\n\n    for aggregate in self._aggregates:\n        # Event-sourced aggregates (AggregateRoot)\n        if hasattr(aggregate, 'get_uncommitted_events'):\n            events.extend(aggregate.get_uncommitted_events())\n\n        # State-based entities (Entity + domain_events)\n        elif hasattr(aggregate, 'domain_events'):\n            events.extend(aggregate.domain_events)\n\n        # Fallback to internal events\n        elif hasattr(aggregate, '_pending_events'):\n            events.extend(aggregate._pending_events)\n\n    return events\n</code></pre>"},{"location":"patterns/unit-of-work/#complexity-comparison","title":"\ud83d\udccb Complexity Comparison","text":"Aspect Entity + State Persistence AggregateRoot + Event Sourcing Learning Curve \u2b50\u2b50\u2606\u2606\u2606 Simple \u2b50\u2b50\u2b50\u2b50\u2b50 Complex Setup Complexity \u2b50\u2b50\u2606\u2606\u2606 Minimal \u2b50\u2b50\u2b50\u2b50\u2606 Significant Database Requirements Any SQL/NoSQL database Event store + projections Query Capabilities Direct database queries Event replay + projections Business Logic Method-based Event-driven state machines Audit &amp; History Manual implementation Built-in temporal queries Performance Direct database access Event replay overhead Scalability Traditional scaling Event-driven scaling"},{"location":"patterns/unit-of-work/#when-to-use-each-pattern","title":"\ud83c\udfaf When to Use Each Pattern","text":""},{"location":"patterns/unit-of-work/#choose-entity-state-persistence-when","title":"Choose Entity + State Persistence When","text":"<ul> <li>\u2705 Building CRUD-heavy applications</li> <li>\u2705 Team is new to DDD/event sourcing</li> <li>\u2705 Simple business rules and workflows</li> <li>\u2705 Traditional database infrastructure</li> <li>\u2705 Performance is critical</li> <li>\u2705 Quick prototyping and development</li> </ul>"},{"location":"patterns/unit-of-work/#choose-aggregateroot-event-sourcing-when","title":"Choose AggregateRoot + Event Sourcing When","text":"<ul> <li>\u2705 Complex business domains with rich logic</li> <li>\u2705 Audit trails and compliance requirements</li> <li>\u2705 Temporal queries and historical analysis</li> <li>\u2705 Event-driven integrations</li> <li>\u2705 High consistency requirements</li> <li>\u2705 Long-term maintainability over complexity</li> </ul>"},{"location":"patterns/unit-of-work/#choose-hybrid-approach-when","title":"Choose Hybrid Approach When","text":"<ul> <li>\u2705 Mixed complexity across domain areas</li> <li>\u2705 Migrating from traditional to event-sourced systems</li> <li>\u2705 Different persistence requirements per bounded context</li> <li>\u2705 Pragmatic balance between complexity and capability</li> </ul>"},{"location":"patterns/unit-of-work/#integration-with-other-patterns","title":"\ud83d\udd17 Integration with Other Patterns","text":""},{"location":"patterns/unit-of-work/#cqrs-integration","title":"CQRS Integration","text":"<p>The Unit of Work pattern works seamlessly with CQRS:</p> <pre><code># Commands use UnitOfWork for writes\nclass CreateProductHandler(CommandHandler):\n    async def handle_async(self, command):\n        product = Product(command.name, command.price)\n        await self.repository.save_async(product)\n        self.unit_of_work.register_aggregate(product)  # Events dispatched\n        return self.created(product)\n\n# Queries bypass UnitOfWork for reads\nclass GetProductHandler(QueryHandler):\n    async def handle_async(self, query):\n        return await self.repository.get_by_id_async(query.product_id)\n        # No UnitOfWork needed for read operations\n</code></pre>"},{"location":"patterns/unit-of-work/#pipeline-behaviors-integration","title":"Pipeline Behaviors Integration","text":"<p>Unit of Work integrates with Pipeline Behaviors:</p> <pre><code># Transaction behavior + Domain event dispatching\nservices.add_scoped(PipelineBehavior, TransactionBehavior)        # 1st: Manages DB transactions\nservices.add_scoped(PipelineBehavior, DomainEventDispatchingMiddleware)  # 2nd: Dispatches events after success\nservices.add_scoped(PipelineBehavior, LoggingBehavior)            # 3rd: Logs execution\n\n# Execution order ensures events only dispatch after successful transaction commit\n</code></pre>"},{"location":"patterns/unit-of-work/#repository-pattern-integration","title":"Repository Pattern Integration","text":"<p>Unit of Work coordinates with Repository Pattern:</p> <pre><code># Repository handles persistence, UnitOfWork handles events\nclass OrderHandler(CommandHandler):\n    async def handle_async(self, command):\n        order = Order.create(command.data)     # Domain logic\n        await self.repository.save_async(order)  # Repository persistence\n        self.unit_of_work.register_aggregate(order)  # UnitOfWork event coordination\n        return self.created(order)\n</code></pre>"},{"location":"patterns/unit-of-work/#testing-strategies","title":"\ud83e\uddea Testing Strategies","text":""},{"location":"patterns/unit-of-work/#unit-testing-domain-events","title":"Unit Testing Domain Events","text":"<pre><code>def test_product_creation_raises_event():\n    \"\"\"Test domain events are raised correctly.\"\"\"\n    product = Product(\"Laptop\", 999.99)\n\n    events = product.domain_events\n    assert len(events) == 1\n    assert isinstance(events[0], ProductCreatedEvent)\n    assert events[0].name == \"Laptop\"\n    assert events[0].price == 999.99\n\ndef test_price_update_raises_event():\n    \"\"\"Test business operations raise appropriate events.\"\"\"\n    product = Product(\"Laptop\", 999.99)\n    product.clear_pending_events()  # Clear creation event\n\n    product.update_price(899.99)\n\n    events = product.domain_events\n    assert len(events) == 1\n    assert isinstance(events[0], PriceChangedEvent)\n    assert events[0].old_price == 999.99\n    assert events[0].new_price == 899.99\n</code></pre>"},{"location":"patterns/unit-of-work/#integration-testing-with-unitofwork","title":"Integration Testing with UnitOfWork","text":"<pre><code>@pytest.mark.asyncio\nasync def test_command_handler_registers_aggregates():\n    \"\"\"Test complete command handler workflow with UnitOfWork.\"\"\"\n    # Setup\n    unit_of_work = UnitOfWork()\n    repository = InMemoryProductRepository()\n    handler = CreateProductHandler(repository, unit_of_work)\n\n    # Execute\n    command = CreateProductCommand(\"Laptop\", 999.99)\n    result = await handler.handle_async(command)\n\n    # Verify\n    assert result.is_success\n    assert unit_of_work.has_changes()\n\n    events = unit_of_work.get_domain_events()\n    assert len(events) == 1\n    assert isinstance(events[0], ProductCreatedEvent)\n\n@pytest.mark.asyncio\nasync def test_middleware_dispatches_events():\n    \"\"\"Test automatic event dispatching through middleware.\"\"\"\n    # Setup\n    mock_mediator = Mock()\n    middleware = DomainEventDispatchingMiddleware(unit_of_work, mock_mediator)\n\n    # Setup aggregate with events\n    product = Product(\"Test Product\", 10.0)\n    unit_of_work.register_aggregate(product)\n\n    # Execute\n    async def successful_handler():\n        return OperationResult(\"OK\", 200)\n\n    command = CreateProductCommand(\"Test Product\", 10.0)\n    result = await middleware.handle_async(command, successful_handler)\n\n    # Verify\n    assert result.is_success\n    mock_mediator.publish_async.assert_called_once()\n    assert not unit_of_work.has_changes()  # Cleared after dispatching\n</code></pre>"},{"location":"patterns/unit-of-work/#best-practices","title":"\ud83d\udea8 Best Practices","text":""},{"location":"patterns/unit-of-work/#entity-design-patterns","title":"Entity Design Patterns","text":"<pre><code># \u2705 Good: Business-focused methods with events\nclass Order(Entity):\n    def place_order(self, items: List[OrderItem]):\n        self._validate_order_items(items)\n        self.status = OrderStatus.PLACED\n        self._raise_event(OrderPlacedEvent(self.id, items))\n\n    def add_item(self, item: OrderItem):\n        if self.status != OrderStatus.DRAFT:\n            raise DomainException(\"Cannot modify placed order\")\n\n        self.items.append(item)\n        self._raise_event(ItemAddedEvent(self.id, item))\n\n# \u274c Avoid: Property setters that bypass business rules\nclass Order(Entity):\n    @property\n    def status(self, value):\n        self._status = value  # No validation, no events!\n</code></pre>"},{"location":"patterns/unit-of-work/#event-design-patterns","title":"Event Design Patterns","text":"<pre><code># \u2705 Good: Rich, immutable events with business context\n@dataclass(frozen=True)\nclass OrderPlacedEvent(DomainEvent):\n    order_id: str\n    customer_id: str\n    items: List[OrderItem]\n    total_amount: Decimal\n    placed_at: datetime\n\n# \u274c Avoid: Anemic events without context\n@dataclass\nclass OrderEvent(DomainEvent):\n    order_id: str  # Too generic, lacks business meaning\n</code></pre>"},{"location":"patterns/unit-of-work/#unitofwork-usage-patterns","title":"UnitOfWork Usage Patterns","text":"<pre><code># \u2705 Good: Register aggregates after business operations\nasync def handle_async(self, command):\n    order = Order.create(command.items)        # Business logic first\n    await self.repository.save_async(order)    # Persistence second\n    self.unit_of_work.register_aggregate(order)  # Event coordination last\n    return self.created(order)\n\n# \u274c Avoid: Registering before business operations complete\nasync def handle_async(self, command):\n    order = Order()\n    self.unit_of_work.register_aggregate(order)  # Too early!\n    order.add_items(command.items)              # Business logic after registration\n    return self.created(order)\n</code></pre>"},{"location":"patterns/unit-of-work/#common-mistakes","title":"\u26a0\ufe0f Common Mistakes","text":""},{"location":"patterns/unit-of-work/#1-forgetting-to-register-aggregates","title":"1. Forgetting to Register Aggregates","text":"<pre><code># \u274c WRONG: Forget to register aggregate (events never dispatched!)\nasync def handle_async(self, command: CreateOrderCommand):\n    order = Order.create(command.customer_id, command.items)\n    await self.repository.save_async(order)\n    # Forgot to register! Events will NOT be published!\n    return self.created(order)\n\n# \u2705 CORRECT: Always register aggregates that raise events\nasync def handle_async(self, command: CreateOrderCommand):\n    order = Order.create(command.customer_id, command.items)\n    await self.repository.save_async(order)\n    self.unit_of_work.register_aggregate(order)  # Events will be published!\n    return self.created(order)\n</code></pre>"},{"location":"patterns/unit-of-work/#2-registering-aggregates-before-operations-complete","title":"2. Registering Aggregates Before Operations Complete","text":"<pre><code># \u274c WRONG: Register too early (captures partial state)\nasync def handle_async(self, command: CreateOrderCommand):\n    order = Order(command.customer_id)\n    self.unit_of_work.register_aggregate(order)  # TOO EARLY!\n\n    # These events won't be captured by unit of work!\n    order.add_items(command.items)\n    order.apply_discount(command.discount_code)\n\n    await self.repository.save_async(order)\n    return self.created(order)\n\n# \u2705 CORRECT: Register after all business operations\nasync def handle_async(self, command: CreateOrderCommand):\n    order = Order(command.customer_id)\n    order.add_items(command.items)\n    order.apply_discount(command.discount_code)\n\n    await self.repository.save_async(order)\n    self.unit_of_work.register_aggregate(order)  # Captures ALL events!\n    return self.created(order)\n</code></pre>"},{"location":"patterns/unit-of-work/#3-not-clearing-unit-of-work-between-requests","title":"3. Not Clearing Unit of Work Between Requests","text":"<pre><code># \u274c WRONG: Reusing same Unit of Work without clearing\nclass MyPipelineBehavior(PipelineBehavior):\n    async def handle_async(self, request, next_handler):\n        result = await next_handler()\n\n        if result.is_success:\n            events = self.unit_of_work.get_domain_events()\n            for event in events:\n                await self.event_bus.publish_async(event)\n            # FORGOT to clear! Events accumulate across requests!\n\n        return result\n\n# \u2705 CORRECT: Always clear after processing\nclass MyPipelineBehavior(PipelineBehavior):\n    async def handle_async(self, request, next_handler):\n        try:\n            result = await next_handler()\n\n            if result.is_success:\n                events = self.unit_of_work.get_domain_events()\n                for event in events:\n                    await self.event_bus.publish_async(event)\n\n            return result\n        finally:\n            self.unit_of_work.clear()  # Always clear!\n</code></pre>"},{"location":"patterns/unit-of-work/#4-using-singleton-lifetime-for-unit-of-work","title":"4. Using Singleton Lifetime for Unit of Work","text":"<pre><code># \u274c WRONG: Singleton lifetime (shared across all requests!)\nservices.add_singleton(IUnitOfWork, UnitOfWork)\n# All requests share the same Unit of Work - DISASTER!\n\n# \u2705 CORRECT: Scoped lifetime (one per request)\nservices.add_scoped(IUnitOfWork, UnitOfWork)\n# Each request gets its own Unit of Work instance\n</code></pre>"},{"location":"patterns/unit-of-work/#5-publishing-events-before-transaction-commits","title":"5. Publishing Events Before Transaction Commits","text":"<pre><code># \u274c WRONG: Publishing events before save completes\nasync def handle_async(self, command: CreateOrderCommand):\n    order = Order.create(command.customer_id, command.items)\n\n    # Publishing BEFORE save!\n    events = order.get_uncommitted_events()\n    for event in events:\n        await self.event_bus.publish_async(event)\n\n    # What if save fails? Events already published!\n    await self.repository.save_async(order)\n    return self.created(order)\n\n# \u2705 CORRECT: Let pipeline behavior publish AFTER save\nasync def handle_async(self, command: CreateOrderCommand):\n    order = Order.create(command.customer_id, command.items)\n    await self.repository.save_async(order)\n    self.unit_of_work.register_aggregate(order)\n    # Pipeline publishes events ONLY if handler succeeds\n    return self.created(order)\n</code></pre>"},{"location":"patterns/unit-of-work/#6-not-handling-event-publishing-failures","title":"6. Not Handling Event Publishing Failures","text":"<pre><code># \u274c WRONG: No error handling for event publishing\nclass EventDispatcherBehavior(PipelineBehavior):\n    async def handle_async(self, request, next_handler):\n        result = await next_handler()\n\n        events = self.unit_of_work.get_domain_events()\n        for event in events:\n            await self.event_bus.publish_async(event)  # What if this fails?\n\n        return result\n\n# \u2705 CORRECT: Handle publishing failures gracefully\nclass EventDispatcherBehavior(PipelineBehavior):\n    async def handle_async(self, request, next_handler):\n        result = await next_handler()\n\n        if not result.is_success:\n            return result\n\n        events = self.unit_of_work.get_domain_events()\n\n        try:\n            for event in events:\n                await self.event_bus.publish_async(event)\n        except Exception as ex:\n            self.logger.error(f\"Failed to publish events: {ex}\")\n            # Consider: retry, dead letter queue, or compensating transaction\n            # For now, log and continue (events are stored with aggregate)\n        finally:\n            self.unit_of_work.clear()\n\n        return result\n</code></pre>"},{"location":"patterns/unit-of-work/#when-not-to-use","title":"\ud83d\udeab When NOT to Use","text":""},{"location":"patterns/unit-of-work/#1-simple-crud-operations-without-domain-events","title":"1. Simple CRUD Operations Without Domain Events","text":"<pre><code># Unit of Work is overkill for simple data updates\nclass UpdateCustomerEmailHandler:\n    async def handle_async(self, command: UpdateEmailCommand):\n        # Simple update, no domain events needed\n        await self.db.customers.update_one(\n            {\"id\": command.customer_id},\n            {\"$set\": {\"email\": command.new_email}}\n        )\n        # No need for Unit of Work here\n</code></pre>"},{"location":"patterns/unit-of-work/#2-read-only-queries","title":"2. Read-Only Queries","text":"<pre><code># Unit of Work is for WRITE operations, not queries\nclass GetOrderByIdHandler:\n    async def handle_async(self, query: GetOrderByIdQuery):\n        # Just reading data, no events to coordinate\n        return await self.repository.get_by_id_async(query.order_id)\n        # No Unit of Work needed\n</code></pre>"},{"location":"patterns/unit-of-work/#3-stateless-services-without-aggregates","title":"3. Stateless Services Without Aggregates","text":"<pre><code># Services that don't work with domain aggregates\nclass PriceCalculationService:\n    def calculate_total(self, items: List[OrderItem]) -&gt; Decimal:\n        # Pure calculation, no state changes, no events\n        return sum(item.price * item.quantity for item in items)\n        # No Unit of Work needed\n</code></pre>"},{"location":"patterns/unit-of-work/#4-external-api-integration","title":"4. External API Integration","text":"<pre><code># Unit of Work is for domain aggregates, not external APIs\nclass SendEmailHandler:\n    async def handle_async(self, command: SendEmailCommand):\n        # Calling external API, not modifying aggregates\n        await self.email_api.send_async(\n            to=command.recipient,\n            subject=command.subject,\n            body=command.body\n        )\n        # No aggregates, no Unit of Work needed\n</code></pre>"},{"location":"patterns/unit-of-work/#5-background-jobs-without-domain-logic","title":"5. Background Jobs Without Domain Logic","text":"<pre><code># Simple background tasks without domain events\nclass CleanupOldLogsJob:\n    async def execute_async(self):\n        # Deleting old data, not raising domain events\n        cutoff = datetime.now() - timedelta(days=90)\n        await self.db.logs.delete_many({\"created_at\": {\"$lt\": cutoff}})\n        # No domain events, no Unit of Work needed\n</code></pre>"},{"location":"patterns/unit-of-work/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ul> <li>Unit of Work coordinates aggregate changes and event dispatching</li> <li>Automatically collects domain events from registered aggregates</li> <li>Ensures transactional consistency by publishing events only after save succeeds</li> <li>Reduces boilerplate by eliminating manual event management in every handler</li> <li>Supports multi-aggregate transactions with centralized coordination</li> <li>Always register aggregates after business operations complete</li> <li>Use scoped lifetime (one Unit of Work per request)</li> <li>Clear Unit of Work after each request to prevent event accumulation</li> <li>Pipeline behaviors typically handle event dispatching automatically</li> <li>Framework provides IUnitOfWork interface and implementation</li> </ul>"},{"location":"patterns/unit-of-work/#related-documentation","title":"\ud83d\udcda Related Documentation","text":"<ul> <li>\ud83c\udfaf Simple CQRS - Command and Query handling patterns</li> <li>\ud83d\udd27 Pipeline Behaviors - Cross-cutting concern patterns</li> <li>\ud83c\udfdb\ufe0f State-Based Persistence - Detailed state persistence guide</li> <li>\ud83c\udfdb\ufe0f Domain Driven Design - Comprehensive DDD patterns</li> <li>\ud83d\udce6 Repository Pattern - Data access abstraction patterns</li> <li>\ud83d\udce1 Event-Driven Architecture - Event handling and integration patterns</li> </ul> <p>The Unit of Work pattern provides the coordination layer that makes domain-driven design practical and maintainable, supporting both simple and complex persistence scenarios within the same architectural framework.</p>"},{"location":"patterns/watcher-reconciliation-execution/","title":"How Watcher and Reconciliation Loop Execute","text":"<p>\ud83d\udea7 Work in Progress: This documentation is being updated to include beginner-friendly explanations with What &amp; Why sections, Common Mistakes, and When NOT to Use guidance. The content below is accurate but will be enhanced soon.</p> <p>This document provides a detailed explanation of how the Resource Watcher and Reconciliation Loop patterns execute in our Resource Oriented Architecture (ROA) implementation.</p>"},{"location":"patterns/watcher-reconciliation-execution/#execution-flow-overview","title":"\ud83d\udd04 Execution Flow Overview","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Resource       \u2502    \u2502  Resource       \u2502    \u2502  Background     \u2502\n\u2502  Watcher        \u2502    \u2502  Controller     \u2502    \u2502  Scheduler      \u2502\n\u2502                 \u2502    \u2502                 \u2502    \u2502                 \u2502\n\u2502 \u2022 Polls storage \u2502\u2500\u2500\u2500\u25b6\u2502 \u2022 Reconciles    \u2502\u25c4\u2500\u2500\u25b6\u2502 \u2022 Monitors all  \u2502\n\u2502 \u2022 Detects \u0394     \u2502    \u2502   resources     \u2502    \u2502   resources     \u2502\n\u2502 \u2022 Emits events  \u2502    \u2502 \u2022 Updates state \u2502    \u2502 \u2022 Enforces      \u2502\n\u2502 \u2022 Triggers      \u2502    \u2502 \u2022 Publishes     \u2502    \u2502   lifecycle     \u2502\n\u2502   reconciliation\u2502    \u2502   events        \u2502    \u2502                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                       \u2502                       \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                 \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502    Event Bus &amp;          \u2502\n                    \u2502  Cloud Events           \u2502\n                    \u2502                         \u2502\n                    \u2502 \u2022 Resource created      \u2502\n                    \u2502 \u2022 Resource updated      \u2502\n                    \u2502 \u2022 Status changed        \u2502\n                    \u2502 \u2022 Reconciliation done   \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#1-resource-watcher-execution","title":"1\ufe0f\u20e3 Resource Watcher Execution","text":""},{"location":"patterns/watcher-reconciliation-execution/#polling-loop-implementation","title":"Polling Loop Implementation","text":"<pre><code>class ResourceWatcherBase:\n    async def _watch_loop(self, namespace=None, label_selector=None):\n        \"\"\"\n        Main watch loop - executes continuously:\n\n        1. List current resources from storage\n        2. Compare with cached resources\n        3. Detect changes (CREATED, UPDATED, DELETED, STATUS_UPDATED)\n        4. Process each change\n        5. Update cache\n        6. Sleep until next poll\n        \"\"\"\n        while self._watching:\n            try:\n                # STEP 1: Get current state from storage\n                current_resources = await self._list_resources(namespace, label_selector)\n                current_resource_map = {r.id: r for r in current_resources}\n\n                # STEP 2: Detect changes by comparing with cache\n                changes = self._detect_changes(current_resource_map)\n\n                # STEP 3: Process each detected change\n                for change in changes:\n                    await self._process_change(change)\n\n                # STEP 4: Update cache with current state\n                self._resource_cache = current_resource_map\n\n                # STEP 5: Wait before next poll\n                await asyncio.sleep(self.watch_interval)\n\n            except Exception as e:\n                log.error(f\"Error in watch loop: {e}\")\n                await asyncio.sleep(self.watch_interval)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#change-detection-algorithm","title":"Change Detection Algorithm","text":"<pre><code>def _detect_changes(self, current_resources):\n    \"\"\"\n    Change detection compares current vs cached state:\n\n    \u2022 CREATED: resource_id in current but not in cache\n    \u2022 DELETED: resource_id in cache but not in current\n    \u2022 UPDATED: generation increased (spec changed)\n    \u2022 STATUS_UPDATED: status fields changed\n    \"\"\"\n    changes = []\n    current_ids = set(current_resources.keys())\n    cached_ids = set(self._resource_cache.keys())\n\n    # New resources (CREATED)\n    for resource_id in current_ids - cached_ids:\n        changes.append(ResourceChangeEvent(\n            change_type=ResourceChangeType.CREATED,\n            resource=current_resources[resource_id]\n        ))\n\n    # Deleted resources (DELETED)\n    for resource_id in cached_ids - current_ids:\n        changes.append(ResourceChangeEvent(\n            change_type=ResourceChangeType.DELETED,\n            resource=self._resource_cache[resource_id]\n        ))\n\n    # Modified resources (UPDATED/STATUS_UPDATED)\n    for resource_id in current_ids &amp; cached_ids:\n        current = current_resources[resource_id]\n        cached = self._resource_cache[resource_id]\n\n        # Spec changed (generation incremented)\n        if current.metadata.generation &gt; cached.metadata.generation:\n            changes.append(ResourceChangeEvent(\n                change_type=ResourceChangeType.UPDATED,\n                resource=current,\n                old_resource=cached\n            ))\n        # Status changed\n        elif self._has_status_changed(current, cached):\n            changes.append(ResourceChangeEvent(\n                change_type=ResourceChangeType.STATUS_UPDATED,\n                resource=current,\n                old_resource=cached\n            ))\n\n    return changes\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#event-processing-and-controller-triggering","title":"Event Processing and Controller Triggering","text":"<pre><code>async def _process_change(self, change):\n    \"\"\"\n    When changes are detected:\n\n    1. Call registered change handlers (like controllers)\n    2. Publish CloudEvents to event bus\n    3. Handle errors gracefully\n    \"\"\"\n    # STEP 1: Call all registered handlers\n    for handler in self._change_handlers:\n        try:\n            if asyncio.iscoroutinefunction(handler):\n                await handler(change)  # Triggers controller reconciliation\n            else:\n                handler(change)\n        except Exception as e:\n            log.error(f\"Change handler failed: {e}\")\n\n    # STEP 2: Publish event to broader system\n    await self._publish_change_event(change)\n\n# Example: Lab Instance Watcher\nclass LabInstanceWatcher(ResourceWatcherBase):\n    def __init__(self, repository, controller, event_publisher):\n        super().__init__(event_publisher)\n        # Register controller as change handler\n        self.add_change_handler(self._handle_resource_change)\n\n    async def _handle_resource_change(self, change):\n        \"\"\"Called automatically when changes detected\"\"\"\n        if change.change_type in [ResourceChangeType.CREATED, ResourceChangeType.UPDATED]:\n            # Trigger reconciliation for new/updated resources\n            await self.controller.reconcile(change.resource)\n        elif change.change_type == ResourceChangeType.DELETED:\n            # Trigger cleanup for deleted resources\n            await self.controller.finalize(change.resource)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#2-reconciliation-loop-execution","title":"2\ufe0f\u20e3 Reconciliation Loop Execution","text":""},{"location":"patterns/watcher-reconciliation-execution/#controller-reconciliation-pattern","title":"Controller Reconciliation Pattern","text":"<pre><code>class ResourceControllerBase:\n    async def reconcile(self, resource):\n        \"\"\"\n        Main reconciliation entry point:\n\n        1. Check if reconciliation is needed\n        2. Execute reconciliation logic with timeout\n        3. Handle results (success, failure, requeue)\n        4. Update resource status\n        5. Emit reconciliation events\n        \"\"\"\n        start_time = datetime.now()\n\n        try:\n            # STEP 1: Check if reconciliation needed\n            if not resource.needs_reconciliation():\n                log.debug(f\"Resource {resource.metadata.name} does not need reconciliation\")\n                return\n\n            # STEP 2: Execute reconciliation with timeout\n            result = await asyncio.wait_for(\n                self._do_reconcile(resource),\n                timeout=self._reconciliation_timeout.total_seconds()\n            )\n\n            # STEP 3: Handle reconciliation result\n            await self._handle_reconciliation_result(resource, result, start_time)\n\n        except asyncio.TimeoutError:\n            await self._handle_reconciliation_error(resource, TimeoutError(), start_time)\n        except Exception as e:\n            await self._handle_reconciliation_error(resource, e, start_time)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#lab-instance-controller-implementation","title":"Lab Instance Controller Implementation","text":"<pre><code>class LabInstanceController(ResourceControllerBase):\n    async def _do_reconcile(self, resource: LabInstanceRequest):\n        \"\"\"\n        Lab-specific reconciliation logic:\n\n        \u2022 PENDING \u2192 PROVISIONING: Check if should start\n        \u2022 PROVISIONING \u2192 RUNNING: Start container\n        \u2022 RUNNING \u2192 COMPLETED: Monitor completion\n        \u2022 Handle errors and timeouts\n        \"\"\"\n        current_phase = resource.status.phase\n\n        if current_phase == LabInstancePhase.PENDING:\n            if resource.should_start_now():\n                # Time to start - provision container\n                success = await self._provision_lab_instance(resource)\n                return ReconciliationResult.success() if success else ReconciliationResult.requeue()\n            else:\n                # Not time yet - requeue when it should start\n                remaining_time = resource.get_time_until_start()\n                return ReconciliationResult.requeue_after(remaining_time)\n\n        elif current_phase == LabInstancePhase.PROVISIONING:\n            # Check if container is ready\n            if await self._is_container_ready(resource):\n                resource.transition_to_running()\n                await self._repository.save_async(resource)\n                return ReconciliationResult.success()\n            else:\n                # Still provisioning - check again soon\n                return ReconciliationResult.requeue_after(timedelta(seconds=30))\n\n        elif current_phase == LabInstancePhase.RUNNING:\n            # Monitor for completion or timeout\n            if resource.is_expired():\n                await self._timeout_lab_instance(resource)\n                return ReconciliationResult.success()\n            else:\n                # Check again when it should expire\n                remaining_time = resource.get_remaining_duration()\n                return ReconciliationResult.requeue_after(remaining_time)\n\n        # No action needed for terminal phases\n        return ReconciliationResult.success()\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#3-background-scheduler-as-reconciliation-loop","title":"3\ufe0f\u20e3 Background Scheduler as Reconciliation Loop","text":""},{"location":"patterns/watcher-reconciliation-execution/#scheduler-service-implementation","title":"Scheduler Service Implementation","text":"<pre><code>class LabInstanceSchedulerService(HostedService):\n    \"\"\"\n    Background service that acts as a reconciliation loop:\n\n    \u2022 Runs independently of watchers\n    \u2022 Periodically scans all resources\n    \u2022 Applies policies and enforces state\n    \u2022 Handles bulk operations\n    \"\"\"\n\n    async def _run_scheduler_loop(self):\n        \"\"\"Main scheduler loop - runs continuously\"\"\"\n        cleanup_counter = 0\n\n        while self._running:\n            try:\n                # PHASE 1: Process scheduled instances (PENDING \u2192 PROVISIONING)\n                await self._process_scheduled_instances()\n\n                # PHASE 2: Monitor running instances (RUNNING state health)\n                await self._process_running_instances()\n\n                # PHASE 3: Periodic cleanup (expired/failed instances)\n                cleanup_counter += self._scheduler_interval\n                if cleanup_counter &gt;= self._cleanup_interval:\n                    await self._cleanup_expired_instances()\n                    cleanup_counter = 0\n\n                # Wait before next iteration\n                await asyncio.sleep(self._scheduler_interval)\n\n            except Exception as e:\n                log.error(f\"Error in scheduler loop: {e}\")\n                await asyncio.sleep(self._scheduler_interval)\n\n    async def _process_scheduled_instances(self):\n        \"\"\"Reconcile PENDING instances that should start\"\"\"\n        try:\n            # Find all pending instances that are scheduled\n            pending_instances = await self._repository.find_scheduled_pending_async()\n\n            for instance in pending_instances:\n                if instance.should_start_now():\n                    # Move toward desired state: PENDING \u2192 PROVISIONING \u2192 RUNNING\n                    await self._start_lab_instance(instance)\n\n        except Exception as e:\n            log.error(f\"Error processing scheduled instances: {e}\")\n\n    async def _process_running_instances(self):\n        \"\"\"Reconcile RUNNING instances for health/completion\"\"\"\n        try:\n            running_instances = await self._repository.find_running_instances_async()\n\n            for instance in running_instances:\n                # Check actual container state vs desired state\n                container_status = await self._container_service.get_container_status_async(\n                    instance.status.container_id\n                )\n\n                # Reconcile based on actual vs desired state\n                if container_status == \"stopped\":\n                    # Container stopped - instance should complete\n                    await self._complete_lab_instance(instance)\n                elif container_status == \"error\":\n                    # Container errored - instance should fail\n                    await self._fail_lab_instance(instance, \"Container error\")\n                elif instance.is_expired():\n                    # Policy violation - enforce timeout\n                    await self._timeout_lab_instance(instance)\n\n        except Exception as e:\n            log.error(f\"Error processing running instances: {e}\")\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#4-integration-patterns-and-event-flow","title":"4\ufe0f\u20e3 Integration Patterns and Event Flow","text":""},{"location":"patterns/watcher-reconciliation-execution/#complete-event-flow-example","title":"Complete Event Flow Example","text":"<pre><code>1. User creates LabInstanceRequest\n   \u2514\u2500 Resource saved to storage\n\n2. Watcher detects CREATED event (next poll cycle)\n   \u251c\u2500 Publishes labinstancerequest.created CloudEvent\n   \u2514\u2500 Triggers controller.reconcile(resource)\n\n3. Controller reconciliation\n   \u251c\u2500 Checks: resource.should_start_now() \u2192 false (scheduled for later)\n   \u2514\u2500 Returns: ReconciliationResult.requeue_after(delay)\n\n4. Scheduler loop (independent polling)\n   \u251c\u2500 Finds pending instances that should start\n   \u251c\u2500 Calls _start_lab_instance(resource)\n   \u2502  \u251c\u2500 Transitions: PENDING \u2192 PROVISIONING\n   \u2502  \u251c\u2500 Creates container\n   \u2502  \u2514\u2500 Transitions: PROVISIONING \u2192 RUNNING\n   \u2514\u2500 Updates resource status in storage\n\n5. Watcher detects STATUS_UPDATED event\n   \u251c\u2500 Publishes labinstancerequest.status_updated CloudEvent\n   \u2514\u2500 Triggers controller.reconcile(resource) again\n\n6. Controller reconciliation (RUNNING phase)\n   \u251c\u2500 Calculates when instance should expire\n   \u2514\u2500 Returns: ReconciliationResult.requeue_after(remaining_time)\n\n7. Time passes... scheduler monitors container health\n\n8. Container completes/fails/times out\n   \u251c\u2500 Scheduler detects state change\n   \u251c\u2500 Updates resource: RUNNING \u2192 COMPLETED/FAILED/TIMEOUT\n   \u2514\u2500 Cleans up container resources\n\n9. Watcher detects final STATUS_UPDATED event\n   \u251c\u2500 Publishes final CloudEvent\n   \u2514\u2500 Controller reconciliation confirms no action needed\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#timing-and-coordination","title":"Timing and Coordination","text":"Component Frequency Purpose Watcher 5-10 seconds Detect changes, trigger reactive reconciliation Scheduler 30-60 seconds Proactive reconciliation, policy enforcement Controller Event-driven Handle specific resource changes"},{"location":"patterns/watcher-reconciliation-execution/#error-handling-and-resilience","title":"Error Handling and Resilience","text":"<pre><code># Watcher error handling\nasync def _watch_loop(self):\n    while self._watching:\n        try:\n            # Process changes\n            pass\n        except Exception as e:\n            log.error(f\"Watch loop error: {e}\")\n            await asyncio.sleep(self.watch_interval)  # Continue watching\n\n# Controller error handling\nasync def reconcile(self, resource):\n    try:\n        result = await asyncio.wait_for(self._do_reconcile(resource), timeout=300)\n    except asyncio.TimeoutError:\n        # Handle timeout - mark for retry\n        result = ReconciliationResult.requeue()\n    except Exception as e:\n        # Handle error - exponential backoff\n        result = ReconciliationResult.failed(e)\n\n# Scheduler error handling\nasync def _run_scheduler_loop(self):\n    while self._running:\n        try:\n            # Process all phases\n            pass\n        except Exception as e:\n            log.error(f\"Scheduler error: {e}\")\n            await asyncio.sleep(self._scheduler_interval)  # Continue scheduling\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#observability-and-monitoring","title":"\ud83d\udcca Observability and Monitoring","text":""},{"location":"patterns/watcher-reconciliation-execution/#key-metrics-to-monitor","title":"Key Metrics to Monitor","text":"<pre><code># Watcher metrics\n{\n    \"watch_loop_iterations\": 1234,\n    \"changes_detected\": 56,\n    \"events_published\": 78,\n    \"cache_hit_ratio\": 0.95,\n    \"average_poll_duration\": \"150ms\"\n}\n\n# Controller metrics\n{\n    \"reconciliations_total\": 234,\n    \"reconciliations_successful\": 220,\n    \"reconciliations_failed\": 4,\n    \"reconciliations_requeued\": 10,\n    \"average_reconciliation_time\": \"2.3s\"\n}\n\n# Scheduler metrics\n{\n    \"scheduler_loop_iterations\": 567,\n    \"resources_processed\": 890,\n    \"state_transitions\": 123,\n    \"cleanup_operations\": 45,\n    \"average_loop_duration\": \"5.2s\"\n}\n</code></pre> <p>This architecture provides a robust, scalable foundation for declarative resource management that automatically maintains desired state while being resilient to failures and providing comprehensive observability.</p>"},{"location":"patterns/watcher-reconciliation-patterns/","title":"Resource Watcher and Reconciliation Loop Patterns","text":"<p>\ud83d\udea7 Work in Progress: This documentation is being updated to include beginner-friendly explanations with What &amp; Why sections, Common Mistakes, and When NOT to Use guidance. The content below is accurate but will be enhanced soon.</p> <p>This document explains how the Resource Watcher and Reconciliation Loop patterns work in our Resource Oriented Architecture (ROA) implementation, providing the foundation for Kubernetes-style declarative resource management.</p>"},{"location":"patterns/watcher-reconciliation-patterns/#overview","title":"\ud83c\udfaf Overview","text":"<p>The ROA implementation uses two complementary patterns:</p> <ol> <li>Resource Watcher: Detects changes to resources and emits events</li> <li>Reconciliation Loop: Continuously ensures actual state matches desired state</li> </ol> <p>These patterns work together to provide:</p> <ul> <li>Declarative Management: Specify desired state, controllers make it happen</li> <li>Event-Driven Processing: React to changes as they occur</li> <li>Self-Healing: Automatically correct drift from desired state</li> <li>Extensibility: Pluggable controllers for different resource types</li> </ul>"},{"location":"patterns/watcher-reconciliation-patterns/#resource-watcher-pattern","title":"\ud83d\udd0d Resource Watcher Pattern","text":""},{"location":"patterns/watcher-reconciliation-patterns/#how-the-watcher-works","title":"How the Watcher Works","text":"<pre><code>class ResourceWatcherBase(Generic[TResourceSpec, TResourceStatus]):\n    \"\"\"\n    The watcher follows a polling pattern:\n    1. Periodically lists resources from storage\n    2. Compares current state with cached state\n    3. Detects changes (CREATED, UPDATED, DELETED, STATUS_UPDATED)\n    4. Emits events for detected changes\n    5. Updates cache with current state\n    \"\"\"\n\n    async def _watch_loop(self, namespace=None, label_selector=None):\n        while self._watching:\n            # 1. Get current resources\n            current_resources = await self._list_resources(namespace, label_selector)\n            current_resource_map = {r.id: r for r in current_resources}\n\n            # 2. Detect changes\n            changes = self._detect_changes(current_resource_map)\n\n            # 3. Process each change\n            for change in changes:\n                await self._process_change(change)\n\n            # 4. Update cache\n            self._resource_cache = current_resource_map\n\n            # 5. Wait before next poll\n            await asyncio.sleep(self.watch_interval)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#change-detection-logic","title":"Change Detection Logic","text":"<p>The watcher detects four types of changes:</p> <pre><code>def _detect_changes(self, current_resources):\n    changes = []\n    current_ids = set(current_resources.keys())\n    cached_ids = set(self._resource_cache.keys())\n\n    # 1. CREATED: New resources that weren't in cache\n    for resource_id in current_ids - cached_ids:\n        changes.append(ResourceChangeEvent(\n            change_type=ResourceChangeType.CREATED,\n            resource=current_resources[resource_id]\n        ))\n\n    # 2. DELETED: Cached resources no longer present\n    for resource_id in cached_ids - current_ids:\n        changes.append(ResourceChangeEvent(\n            change_type=ResourceChangeType.DELETED,\n            resource=self._resource_cache[resource_id]\n        ))\n\n    # 3. UPDATED: Spec changed (generation increment)\n    # 4. STATUS_UPDATED: Status changed (observed generation, etc.)\n    for resource_id in current_ids &amp; cached_ids:\n        current = current_resources[resource_id]\n        cached = self._resource_cache[resource_id]\n\n        if current.metadata.generation &gt; cached.metadata.generation:\n            # Spec was updated\n            changes.append(ResourceChangeEvent(\n                change_type=ResourceChangeType.UPDATED,\n                resource=current,\n                old_resource=cached\n            ))\n        elif self._has_status_changed(current, cached):\n            # Status was updated\n            changes.append(ResourceChangeEvent(\n                change_type=ResourceChangeType.STATUS_UPDATED,\n                resource=current,\n                old_resource=cached\n            ))\n\n    return changes\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#event-processing-and-publishing","title":"Event Processing and Publishing","text":"<p>When changes are detected, the watcher:</p> <pre><code>async def _process_change(self, change):\n    # 1. Call registered change handlers\n    for handler in self._change_handlers:\n        if asyncio.iscoroutinefunction(handler):\n            await handler(change)\n        else:\n            handler(change)\n\n    # 2. Publish CloudEvent\n    await self._publish_change_event(change)\n\nasync def _publish_change_event(self, change):\n    event_type = f\"{resource.kind.lower()}.{change.change_type.value.lower()}\"\n\n    event = CloudEvent(\n        source=f\"watcher/{resource.kind.lower()}\",\n        type=event_type,  # e.g., \"labinstancerequest.created\"\n        subject=f\"{resource.metadata.namespace}/{resource.metadata.name}\",\n        data={\n            \"resourceUid\": resource.id,\n            \"apiVersion\": resource.api_version,\n            \"kind\": resource.kind,\n            \"changeType\": change.change_type.value,\n            \"generation\": resource.metadata.generation,\n            \"observedGeneration\": resource.status.observed_generation\n        }\n    )\n\n    await self.event_publisher.publish_async(event)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#reconciliation-loop-pattern","title":"\ud83d\udd04 Reconciliation Loop Pattern","text":""},{"location":"patterns/watcher-reconciliation-patterns/#how-reconciliation-works","title":"How Reconciliation Works","text":"<pre><code>class ResourceControllerBase(Generic[TResourceSpec, TResourceStatus]):\n    \"\"\"\n    Controllers implement the reconciliation pattern:\n    1. Receive resource change events\n    2. Compare current state with desired state\n    3. Take actions to move toward desired state\n    4. Update resource status\n    5. Emit reconciliation events\n    \"\"\"\n\n    async def reconcile(self, resource):\n        # 1. Check if reconciliation is needed\n        if not resource.needs_reconciliation():\n            return\n\n        # 2. Execute reconciliation with timeout\n        result = await asyncio.wait_for(\n            self._do_reconcile(resource),\n            timeout=self._reconciliation_timeout.total_seconds()\n        )\n\n        # 3. Handle result (success, failure, requeue)\n        await self._handle_reconciliation_result(resource, result)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#reconciliation-states","title":"Reconciliation States","text":"<p>Controllers can return different reconciliation results:</p> <pre><code>class ReconciliationStatus(Enum):\n    SUCCESS = \"Success\"          # Reconciliation completed successfully\n    FAILED = \"Failed\"            # Reconciliation failed, needs attention\n    REQUEUE = \"Requeue\"          # Retry immediately\n    REQUEUE_AFTER = \"RequeueAfter\"  # Retry after specified delay\n\n# Example usage in controller\nasync def _do_reconcile(self, resource):\n    if resource.status.phase == LabInstancePhase.PENDING:\n        if resource.should_start_now():\n            success = await self._start_lab_instance(resource)\n            return ReconciliationResult.success() if success else ReconciliationResult.requeue()\n        else:\n            # Not time to start yet, check again in 30 seconds\n            return ReconciliationResult.requeue_after(timedelta(seconds=30))\n\n    elif resource.status.phase == LabInstancePhase.RUNNING:\n        if resource.is_expired():\n            await self._stop_lab_instance(resource)\n            return ReconciliationResult.success()\n        else:\n            # Check again when it should expire\n            remaining = resource.get_remaining_duration()\n            return ReconciliationResult.requeue_after(remaining)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#integration-patterns","title":"\ud83d\udd27 Integration Patterns","text":""},{"location":"patterns/watcher-reconciliation-patterns/#pattern-1-watcher-controller-integration","title":"Pattern 1: Watcher \u2192 Controller Integration","text":"<pre><code># Watcher detects changes and triggers controller\nclass LabInstanceWatcher(ResourceWatcherBase[LabInstanceRequestSpec, LabInstanceRequestStatus]):\n    def __init__(self, repository, controller, event_publisher):\n        super().__init__(event_publisher)\n        self.repository = repository\n        self.controller = controller\n\n        # Register controller as change handler\n        self.add_change_handler(self._handle_resource_change)\n\n    async def _list_resources(self, namespace=None, label_selector=None):\n        return await self.repository.list_async(namespace=namespace)\n\n    async def _handle_resource_change(self, change):\n        \"\"\"Called when resource changes are detected.\"\"\"\n        resource = change.resource\n\n        if change.change_type in [ResourceChangeType.CREATED, ResourceChangeType.UPDATED]:\n            # Trigger reconciliation for created or updated resources\n            await self.controller.reconcile(resource)\n        elif change.change_type == ResourceChangeType.DELETED:\n            # Trigger finalization for deleted resources\n            await self.controller.finalize(resource)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#pattern-2-background-scheduler-as-reconciliation-loop","title":"Pattern 2: Background Scheduler as Reconciliation Loop","text":"<pre><code>class LabInstanceSchedulerService(HostedService):\n    \"\"\"\n    Background service that acts as a reconciliation loop:\n    1. Periodically scans all resources\n    2. Identifies resources that need reconciliation\n    3. Applies appropriate actions\n    4. Updates resource status\n    \"\"\"\n\n    async def _run_scheduler_loop(self):\n        while self._running:\n            # Reconciliation phases\n            await self._process_scheduled_instances()  # PENDING \u2192 PROVISIONING\n            await self._process_running_instances()    # RUNNING monitoring\n            await self._cleanup_expired_instances()    # TIMEOUT/CLEANUP\n\n            await asyncio.sleep(self._scheduler_interval)\n\n    async def _process_scheduled_instances(self):\n        \"\"\"Reconcile PENDING resources that should be started.\"\"\"\n        pending_instances = await self.repository.find_by_phase_async(LabInstancePhase.PENDING)\n\n        for instance in pending_instances:\n            if instance.should_start_now():\n                # Move toward desired state: PENDING \u2192 PROVISIONING \u2192 RUNNING\n                await self._start_lab_instance(instance)\n\n    async def _process_running_instances(self):\n        \"\"\"Reconcile RUNNING resources for completion/errors.\"\"\"\n        running_instances = await self.repository.find_by_phase_async(LabInstancePhase.RUNNING)\n\n        for instance in running_instances:\n            # Check actual container state vs desired state\n            container_status = await self.container_service.get_container_status_async(\n                instance.status.container_id\n            )\n\n            if container_status == \"stopped\":\n                # Actual state differs from desired, reconcile\n                await self._complete_lab_instance(instance)\n            elif instance.is_expired():\n                # Policy violation, enforce timeout\n                await self._timeout_lab_instance(instance)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#pattern-3-event-driven-reconciliation","title":"Pattern 3: Event-Driven Reconciliation","text":"<pre><code>class LabInstanceEventHandler:\n    \"\"\"Handle resource events and trigger reconciliation.\"\"\"\n\n    async def handle_lab_instance_created(self, event):\n        \"\"\"When a lab instance is created, ensure it's properly scheduled.\"\"\"\n        resource_id = event.data[\"resourceUid\"]\n        resource = await self.repository.get_by_id_async(resource_id)\n\n        if resource and resource.status.phase == LabInstancePhase.PENDING:\n            # Ensure resource is in scheduling queue\n            await self.controller.reconcile(resource)\n\n    async def handle_lab_instance_updated(self, event):\n        \"\"\"When a lab instance is updated, re-reconcile.\"\"\"\n        resource_id = event.data[\"resourceUid\"]\n        resource = await self.repository.get_by_id_async(resource_id)\n\n        if resource:\n            await self.controller.reconcile(resource)\n\n    async def handle_container_event(self, event):\n        \"\"\"When container state changes, update resource status.\"\"\"\n        container_id = event.data[\"containerId\"]\n\n        # Find resource with this container\n        instances = await self.repository.find_by_container_id_async(container_id)\n\n        for instance in instances:\n            # Reconcile to reflect new container state\n            await self.controller.reconcile(instance)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#complete-integration-example","title":"\ud83d\ude80 Complete Integration Example","text":"<p>Here's how all patterns work together:</p> <pre><code># 1. Setup watcher and controller\nwatcher = LabInstanceWatcher(repository, controller, event_publisher)\nscheduler = LabInstanceSchedulerService(repository, container_service, event_bus)\n\n# 2. Start background processes\nawait watcher.watch(namespace=\"default\")\nawait scheduler.start_async()\n\n# 3. Create a resource (triggers CREATED event)\nlab_instance = LabInstanceRequest(...)\nawait repository.save_async(lab_instance)\n\n# 4. Watcher detects CREATED event\n# 5. Watcher calls controller.reconcile(lab_instance)\n# 6. Controller checks if action needed (should_start_now?)\n# 7. If not time yet, controller returns REQUEUE_AFTER\n# 8. Scheduler loop independently checks all PENDING resources\n# 9. When time arrives, scheduler starts the lab instance\n# 10. Status update triggers STATUS_UPDATED event\n# 11. Watcher publishes CloudEvent\n# 12. Other services can react to the event\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#observability-and-monitoring","title":"\ud83d\udcca Observability and Monitoring","text":"<p>Both patterns provide rich observability:</p>"},{"location":"patterns/watcher-reconciliation-patterns/#watcher-metrics","title":"Watcher Metrics","text":"<pre><code>watcher_metrics = {\n    \"is_watching\": watcher.is_watching(),\n    \"cached_resources\": watcher.get_cached_resource_count(),\n    \"watch_interval\": watcher.watch_interval,\n    \"events_published\": watcher.events_published_count,\n    \"change_handlers\": len(watcher._change_handlers)\n}\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#controller-metrics","title":"Controller Metrics","text":"<pre><code>controller_metrics = {\n    \"reconciliations_total\": controller.reconciliation_count,\n    \"reconciliations_successful\": controller.success_count,\n    \"reconciliations_failed\": controller.failure_count,\n    \"average_reconciliation_duration\": controller.avg_duration,\n    \"pending_reconciliations\": controller.queue_size\n}\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#scheduler-metrics","title":"Scheduler Metrics","text":"<pre><code>scheduler_metrics = {\n    \"running\": scheduler._running,\n    \"scheduler_interval\": scheduler._scheduler_interval,\n    \"instances_by_phase\": {\n        phase.value: await repository.count_by_phase_async(phase)\n        for phase in LabInstancePhase\n    },\n    \"processed_this_cycle\": scheduler.processed_count\n}\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#configuration-and-tuning","title":"\u2699\ufe0f Configuration and Tuning","text":""},{"location":"patterns/watcher-reconciliation-patterns/#watcher-configuration","title":"Watcher Configuration","text":"<pre><code>watcher = LabInstanceWatcher(\n    repository=repository,\n    controller=controller,\n    event_publisher=event_publisher,\n    watch_interval=5.0  # Poll every 5 seconds\n)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#controller-configuration","title":"Controller Configuration","text":"<pre><code>controller = LabInstanceController(\n    service_provider=service_provider,\n    event_publisher=event_publisher\n)\ncontroller._reconciliation_timeout = timedelta(minutes=10)\ncontroller._max_retry_attempts = 5\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#scheduler-configuration","title":"Scheduler Configuration","text":"<pre><code>scheduler = LabInstanceSchedulerService(\n    repository=repository,\n    container_service=container_service,\n    event_bus=event_bus\n)\nscheduler._scheduler_interval = 30      # 30 second reconciliation loop\nscheduler._cleanup_interval = 300       # 5 minute cleanup cycle\n</code></pre> <p>This architecture provides a robust, observable, and extensible foundation for managing resources in a declarative, Kubernetes-style manner while integrating seamlessly with traditional CQRS patterns.</p>"},{"location":"references/12-factor-app/","title":"\ud83c\udfed The Twelve-Factor App with Neuroglia","text":"<p>The Twelve-Factor App is a methodology for building software-as-a-service applications that are portable, scalable, and maintainable. The Neuroglia framework was designed from the ground up to support and enforce these principles, making it easy to build cloud-native applications that follow best practices.</p>"},{"location":"references/12-factor-app/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>How each of the 12 factors applies to modern cloud-native applications</li> <li>How Neuroglia framework features directly support 12-factor compliance</li> <li>Practical implementation patterns using Mario's Pizzeria as an example</li> <li>Best practices for deploying and managing 12-factor applications</li> </ul>"},{"location":"references/12-factor-app/#i-codebase","title":"I. Codebase \ud83d\udcc1","text":"<p>Principle: One codebase tracked in revision control, many deploys</p>"},{"location":"references/12-factor-app/#requirements","title":"Requirements","text":"<ul> <li>Single codebase in version control (Git)</li> <li>Multiple deployments from same codebase (dev, staging, production)</li> <li>No shared code between apps - use libraries instead</li> </ul>"},{"location":"references/12-factor-app/#how-neuroglia-supports-this","title":"How Neuroglia Supports This","text":"<p>The framework enforces clean separation of concerns through its modular architecture:</p> <pre><code># Single codebase structure\nsrc/\n\u251c\u2500\u2500 marios_pizzeria/           # Single application codebase\n\u2502   \u251c\u2500\u2500 api/                   # API layer\n\u2502   \u251c\u2500\u2500 application/           # Business logic\n\u2502   \u251c\u2500\u2500 domain/                # Core domain\n\u2502   \u2514\u2500\u2500 integration/           # External integrations\n\u251c\u2500\u2500 shared_libs/               # Reusable libraries\n\u2502   \u2514\u2500\u2500 neuroglia/            # Framework as separate library\n\u2514\u2500\u2500 deployment/                # Environment-specific configs\n    \u251c\u2500\u2500 dev/\n    \u251c\u2500\u2500 staging/\n    \u2514\u2500\u2500 production/\n</code></pre> <p>Example: Mario's Pizzeria has one codebase but deploys to multiple environments:</p> <pre><code># main.py - Same code, different configs\nfrom neuroglia.hosting.web import WebApplicationBuilder\n\ndef create_app():\n    builder = WebApplicationBuilder()\n\n    # Configuration varies by environment\n    # but same codebase everywhere\n    services = builder.services\n    services.add_controllers([\"api.controllers\"])\n    services.add_mediator()\n\n    return builder.build()\n</code></pre>"},{"location":"references/12-factor-app/#ii-dependencies","title":"II. Dependencies \ud83d\udce6","text":"<p>Principle: Explicitly declare and isolate dependencies</p>"},{"location":"references/12-factor-app/#requirements_1","title":"Requirements","text":"<ul> <li>Explicit dependency declaration</li> <li>Dependency isolation (no system-wide packages)</li> <li>No implicit dependencies on system tools</li> </ul>"},{"location":"references/12-factor-app/#how-neuroglia-supports-this_1","title":"How Neuroglia Supports This","text":"<p>The framework uses Poetry and virtual environments for complete dependency isolation:</p> <pre><code># pyproject.toml - Explicit dependency declaration\n[tool.poetry.dependencies]\npython = \"^3.11\"\nfastapi = \"^0.104.0\"\nuvicorn = \"^0.24.0\"\npydantic = \"^2.4.0\"\nmotor = \"^3.3.0\"\n\n[tool.poetry.group.dev.dependencies]\npytest = \"^7.4.0\"\npytest-asyncio = \"^0.21.0\"\n</code></pre> <p>Dependency Injection Container ensures services are properly declared:</p> <pre><code>from neuroglia.dependency_injection import ServiceLifetime\n\ndef configure_services(services):\n    # Explicit service dependencies\n    services.add_singleton(OrderService)\n    services.add_scoped(PizzaRepository, MongoDbPizzaRepository)\n    services.add_transient(EmailService, SmtpEmailService)\n\n    # Framework handles dependency resolution\n    services.add_mediator()\n</code></pre> <p>No System Dependencies - Everything runs in isolated containers:</p> <pre><code># Dockerfile - Isolated environment\nFROM python:3.11-slim\nWORKDIR /app\nCOPY pyproject.toml poetry.lock ./\nRUN pip install poetry &amp;&amp; poetry install --no-dev\nCOPY src/ ./src/\nCMD [\"poetry\", \"run\", \"python\", \"main.py\"]\n</code></pre>"},{"location":"references/12-factor-app/#iii-config","title":"III. Config \u2699\ufe0f","text":"<p>Principle: Store config in the environment</p>"},{"location":"references/12-factor-app/#requirements_2","title":"Requirements","text":"<ul> <li>Configuration in environment variables</li> <li>Strict separation of config from code</li> <li>No passwords or API keys in code</li> </ul>"},{"location":"references/12-factor-app/#how-neuroglia-supports-this_2","title":"How Neuroglia Supports This","text":"<p>Environment-Based Configuration:</p> <pre><code>import os\nfrom pydantic import BaseSettings\n\nclass AppSettings(BaseSettings):\n    # Database configuration\n    mongodb_connection_string: str\n    database_name: str = \"marios_pizzeria\"\n\n    # External service configuration\n    payment_api_key: str\n    email_smtp_host: str\n    email_smtp_port: int = 587\n\n    # Application configuration\n    jwt_secret_key: str\n    log_level: str = \"INFO\"\n\n    class Config:\n        env_file = \".env\"\n        env_file_encoding = \"utf-8\"\n\n# Usage in application\nsettings = AppSettings()\n\nservices.add_singleton(AppSettings, lambda _: settings)\n</code></pre> <p>Environment-Specific Deployment:</p> <pre><code># Development environment\nexport MONGODB_CONNECTION_STRING=\"mongodb://localhost:27017\"\nexport PAYMENT_API_KEY=\"test_key_123\"\nexport JWT_SECRET_KEY=\"dev-secret\"\n\n# Production environment\nexport MONGODB_CONNECTION_STRING=\"mongodb://prod-cluster:27017/marios\"\nexport PAYMENT_API_KEY=\"pk_live_abc123\"\nexport JWT_SECRET_KEY=\"$(openssl rand -base64 32)\"\n</code></pre> <p>Configuration Injection:</p> <pre><code>class OrderController(ControllerBase):\n    def __init__(self, service_provider: ServiceProviderBase,\n                 mapper: Mapper, mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n        # Settings injected automatically\n        self._settings = service_provider.get_service(AppSettings)\n\n    @post(\"/orders\")\n    async def create_order(self, order_dto: CreateOrderDto):\n        # Use configuration without hardcoding\n        if self._settings.payment_api_key:\n            # Process payment\n            pass\n</code></pre>"},{"location":"references/12-factor-app/#iv-backing-services","title":"IV. Backing Services \ud83d\udd0c","text":"<p>Principle: Treat backing services as attached resources</p>"},{"location":"references/12-factor-app/#requirements_3","title":"Requirements","text":"<ul> <li>Database, message queues, caches as attached resources</li> <li>No distinction between local and third-party services</li> <li>Services attachable via configuration</li> </ul>"},{"location":"references/12-factor-app/#how-neuroglia-supports-this_3","title":"How Neuroglia Supports This","text":"<p>Repository Pattern abstracts backing services:</p> <pre><code># Abstract repository - same interface for all backing services\nfrom abc import ABC, abstractmethod\n\nclass PizzaRepository(ABC):\n    @abstractmethod\n    async def save_async(self, pizza: Pizza) -&gt; None:\n        pass\n\n    @abstractmethod\n    async def get_by_id_async(self, pizza_id: str) -&gt; Optional[Pizza]:\n        pass\n\n# MongoDB implementation\nclass MongoDbPizzaRepository(PizzaRepository):\n    def __init__(self, connection_string: str):\n        self._client = AsyncIOMotorClient(connection_string)\n\n    async def save_async(self, pizza: Pizza) -&gt; None:\n        await self._collection.insert_one(pizza.to_dict())\n\n# In-memory implementation (for testing)\nclass InMemoryPizzaRepository(PizzaRepository):\n    def __init__(self):\n        self._store = {}\n\n    async def save_async(self, pizza: Pizza) -&gt; None:\n        self._store[pizza.id] = pizza\n</code></pre> <p>Service Registration based on environment:</p> <pre><code>def configure_backing_services(services, settings: AppSettings):\n    # Database service - swappable via config\n    if settings.environment == \"production\":\n        services.add_scoped(PizzaRepository,\n            lambda sp: MongoDbPizzaRepository(settings.mongodb_connection_string))\n    else:\n        services.add_scoped(PizzaRepository, InMemoryPizzaRepository)\n\n    # Cache service - Redis in prod, memory in dev\n    if settings.redis_url:\n        services.add_singleton(CacheService,\n            lambda sp: RedisCacheService(settings.redis_url))\n    else:\n        services.add_singleton(CacheService, InMemoryCacheService)\n\n    # Message queue - RabbitMQ in prod, in-memory in dev\n    if settings.rabbitmq_url:\n        services.add_scoped(EventBus,\n            lambda sp: RabbitMqEventBus(settings.rabbitmq_url))\n    else:\n        services.add_scoped(EventBus, InMemoryEventBus)\n</code></pre> <p>Service Abstraction through dependency injection:</p> <pre><code>class ProcessOrderHandler(CommandHandler[ProcessOrderCommand, OperationResult]):\n    def __init__(self, pizza_repository: PizzaRepository,\n                 cache_service: CacheService,\n                 event_bus: EventBus):\n        # Handler doesn't know which implementations it's using\n        self._pizza_repository = pizza_repository\n        self._cache_service = cache_service\n        self._event_bus = event_bus\n\n    async def handle_async(self, command: ProcessOrderCommand):\n        # Same code works with any backing service implementation\n        pizza = await self._pizza_repository.get_by_id_async(command.pizza_id)\n        await self._cache_service.set_async(f\"order:{command.order_id}\", pizza)\n        await self._event_bus.publish_async(OrderProcessedEvent(command.order_id))\n</code></pre>"},{"location":"references/12-factor-app/#v-build-release-run","title":"V. Build, Release, Run \ud83d\ude80","text":"<p>Principle: Strictly separate build and run stages</p>"},{"location":"references/12-factor-app/#requirements_4","title":"Requirements","text":"<ul> <li>Build stage: convert code into executable bundle</li> <li>Release stage: combine build with configuration</li> <li>Run stage: execute the release in runtime environment</li> </ul>"},{"location":"references/12-factor-app/#how-neuroglia-supports-this_4","title":"How Neuroglia Supports This","text":"<p>Build Stage - Create deployable artifacts:</p> <pre><code>#!/bin/bash\n# build.sh - Build stage\nset -e\n\necho \"\ud83d\udd28 Building Neuroglia application...\"\n\n# Install dependencies\npoetry install --no-dev\n\n# Run tests\npoetry run pytest\n\n# Build wheel package\npoetry build\n\necho \"\u2705 Build complete: dist/marios_pizzeria-1.0.0-py3-none-any.whl\"\n</code></pre> <p>Release Stage - Combine build with configuration:</p> <pre><code># release.py - Release stage\nimport os\nimport shutil\nfrom pathlib import Path\n\ndef create_release(build_artifact: str, environment: str, version: str):\n    release_dir = Path(f\"releases/{version}-{environment}\")\n    release_dir.mkdir(parents=True, exist_ok=True)\n\n    # Copy build artifact\n    shutil.copy(build_artifact, release_dir / \"app.whl\")\n\n    # Copy environment-specific configuration\n    env_config = Path(f\"deployment/{environment}\")\n    shutil.copytree(env_config, release_dir / \"config\")\n\n    # Create release manifest\n    manifest = {\n        \"version\": version,\n        \"environment\": environment,\n        \"build_artifact\": \"app.whl\",\n        \"configuration\": \"config/\",\n        \"created_at\": datetime.utcnow().isoformat()\n    }\n\n    with open(release_dir / \"manifest.json\", \"w\") as f:\n        json.dump(manifest, f, indent=2)\n\n    return release_dir\n</code></pre> <p>Run Stage - Execute specific release:</p> <pre><code># run.py - Run stage\ndef run_release(release_path: Path):\n    # Load release manifest\n    with open(release_path / \"manifest.json\") as f:\n        manifest = json.load(f)\n\n    # Set environment from release configuration\n    config_dir = release_path / manifest[\"configuration\"]\n    load_environment_from_config(config_dir)\n\n    # Install and run the exact build artifact\n    app_wheel = release_path / manifest[\"build_artifact\"]\n    subprocess.run([\"pip\", \"install\", str(app_wheel)])\n\n    # Start the application\n    from marios_pizzeria.main import create_app\n    app = create_app()\n    app.run()\n</code></pre> <p>Docker Integration for immutable releases:</p> <pre><code># Multi-stage build\nFROM python:3.11-slim as builder\nWORKDIR /build\nCOPY pyproject.toml poetry.lock ./\nRUN pip install poetry &amp;&amp; poetry install --no-dev\nCOPY src/ ./src/\nRUN poetry build\n\nFROM python:3.11-slim as runtime\nWORKDIR /app\n# Copy only the build artifact\nCOPY --from=builder /build/dist/*.whl ./\nRUN pip install *.whl\n# Configuration comes from environment\nCMD [\"python\", \"-m\", \"marios_pizzeria\"]\n</code></pre>"},{"location":"references/12-factor-app/#vi-processes","title":"VI. Processes \ud83d\udd04","text":"<p>Principle: Execute the app as one or more stateless processes</p>"},{"location":"references/12-factor-app/#requirements_5","title":"Requirements","text":"<ul> <li>Processes are stateless and share-nothing</li> <li>Persistent data stored in backing services</li> <li>No sticky sessions or in-process caching</li> </ul>"},{"location":"references/12-factor-app/#how-neuroglia-supports-this_5","title":"How Neuroglia Supports This","text":"<p>Stateless Design through dependency injection:</p> <pre><code>class PizzaController(ControllerBase):\n    def __init__(self, service_provider: ServiceProviderBase,\n                 mapper: Mapper, mediator: Mediator):\n        # Controller has no instance state\n        super().__init__(service_provider, mapper, mediator)\n\n    @get(\"/pizzas/{pizza_id}\")\n    async def get_pizza(self, pizza_id: str) -&gt; PizzaDto:\n        # All state comes from request and backing services\n        query = GetPizzaByIdQuery(pizza_id=pizza_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre> <p>Repository Pattern for persistent data:</p> <pre><code>class GetPizzaByIdHandler(QueryHandler[GetPizzaByIdQuery, PizzaDto]):\n    def __init__(self, pizza_repository: PizzaRepository, mapper: Mapper):\n        self._pizza_repository = pizza_repository  # Stateless service\n        self._mapper = mapper\n\n    async def handle_async(self, query: GetPizzaByIdQuery) -&gt; PizzaDto:\n        # No process state - all data from backing service\n        pizza = await self._pizza_repository.get_by_id_async(query.pizza_id)\n        if pizza is None:\n            raise NotFoundException(f\"Pizza {query.pizza_id} not found\")\n\n        return self._mapper.map(pizza, PizzaDto)\n</code></pre> <p>Process Scaling configuration:</p> <pre><code># docker-compose.yml - Horizontal scaling\nversion: \"3.8\"\nservices:\n  web:\n    image: marios-pizzeria:latest\n    ports:\n      - \"8000-8003:8000\" # Multiple process instances\n    environment:\n      - MONGODB_CONNECTION_STRING=${MONGODB_URL}\n      - REDIS_URL=${REDIS_URL}\n    deploy:\n      replicas: 4 # 4 stateless processes\n\n  nginx:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n    depends_on:\n      - web\n    # Load balancer - no session affinity needed\n</code></pre> <p>Session State externalization:</p> <pre><code>class SessionService:\n    def __init__(self, cache_service: CacheService):\n        self._cache = cache_service  # External session store\n\n    async def get_user_session(self, session_id: str) -&gt; Optional[UserSession]:\n        # Session stored in external cache, not process memory\n        return await self._cache.get_async(f\"session:{session_id}\")\n\n    async def save_user_session(self, session: UserSession) -&gt; None:\n        await self._cache.set_async(\n            f\"session:{session.id}\",\n            session,\n            ttl=timedelta(hours=24)\n        )\n</code></pre>"},{"location":"references/12-factor-app/#vii-port-binding","title":"VII. Port Binding \ud83c\udf10","text":"<p>Principle: Export services via port binding</p>"},{"location":"references/12-factor-app/#requirements_6","title":"Requirements","text":"<ul> <li>App is self-contained and exports HTTP via port binding</li> <li>No reliance on runtime injection by webserver</li> <li>One app can become backing service for another</li> </ul>"},{"location":"references/12-factor-app/#how-neuroglia-supports-this_6","title":"How Neuroglia Supports This","text":"<p>Self-Contained HTTP Server:</p> <pre><code># main.py - Self-contained application\nfrom neuroglia.hosting.web import WebApplicationBuilder\nimport uvicorn\n\ndef create_app():\n    builder = WebApplicationBuilder()\n\n    # Configure services\n    services = builder.services\n    services.add_controllers([\"api.controllers\"])\n    services.add_mediator()\n\n    # Build FastAPI application\n    app = builder.build()\n    app.use_controllers()\n\n    return app\n\nif __name__ == \"__main__\":\n    app = create_app()\n\n    # Self-contained HTTP server via port binding\n    port = int(os.environ.get(\"PORT\", 8000))\n    uvicorn.run(app, host=\"0.0.0.0\", port=port)\n</code></pre> <p>Port Configuration via environment:</p> <pre><code>class ServerSettings(BaseSettings):\n    port: int = 8000\n    host: str = \"0.0.0.0\"\n    workers: int = 1\n\n    class Config:\n        env_prefix = \"SERVER_\"\n\ndef run_server():\n    settings = ServerSettings()\n    app = create_app()\n\n    uvicorn.run(\n        app,\n        host=settings.host,\n        port=settings.port,\n        workers=settings.workers\n    )\n</code></pre> <p>Service-to-Service Communication:</p> <pre><code># Pizza service exports HTTP interface\nclass PizzaServiceClient:\n    def __init__(self, base_url: str):\n        self._base_url = base_url  # Port-bound service URL\n        self._client = httpx.AsyncClient()\n\n    async def get_pizza_async(self, pizza_id: str) -&gt; PizzaDto:\n        # Call another 12-factor app via its port binding\n        response = await self._client.get(f\"{self._base_url}/pizzas/{pizza_id}\")\n        return PizzaDto.model_validate(response.json())\n\n# Order service uses Pizza service as backing service\nclass OrderService:\n    def __init__(self, pizza_service: PizzaServiceClient):\n        self._pizza_service = pizza_service\n\n    async def create_order_async(self, order: CreateOrderRequest) -&gt; Order:\n        # Verify pizza exists via HTTP call\n        pizza = await self._pizza_service.get_pizza_async(order.pizza_id)\n        # Create order...\n</code></pre> <p>Docker Port Mapping:</p> <pre><code># Dockerfile - Port binding configuration\nFROM python:3.11-slim\nWORKDIR /app\nCOPY . .\nRUN pip install -r requirements.txt\n\n# Expose port for binding\nEXPOSE 8000\n\n# Run self-contained server\nCMD [\"python\", \"main.py\"]\n</code></pre>"},{"location":"references/12-factor-app/#viii-concurrency","title":"VIII. Concurrency \ud83d\udd00","text":"<p>Principle: Scale out via the process model</p>"},{"location":"references/12-factor-app/#requirements_7","title":"Requirements","text":"<ul> <li>Scale horizontally by adding more processes</li> <li>Different process types for different work</li> <li>Processes handle their own internal multiplexing</li> </ul>"},{"location":"references/12-factor-app/#how-neuroglia-supports-this_7","title":"How Neuroglia Supports This","text":"<p>Process Types definition:</p> <pre><code># Different process types for different workloads\n# web.py - HTTP request handler processes\ndef create_web_app():\n    builder = WebApplicationBuilder()\n    services = builder.services\n    services.add_controllers([\"api.controllers\"])\n    return builder.build()\n\n# worker.py - Background task processes\ndef create_worker_app():\n    builder = WebApplicationBuilder()\n    services = builder.services\n    services.add_event_handlers([\"application.handlers\"])\n    services.add_background_tasks()\n    return builder.build()\n\n# scheduler.py - Periodic task processes\ndef create_scheduler_app():\n    builder = WebApplicationBuilder()\n    services = builder.services\n    services.add_scheduled_tasks()\n    return builder.build()\n</code></pre> <p>Process Scaling configuration:</p> <pre><code># Procfile - Process type definitions\nweb: python web.py\nworker: python worker.py\nscheduler: python scheduler.py\n</code></pre> <p>Horizontal Scaling with different process counts:</p> <pre><code># docker-compose.yml\nversion: \"3.8\"\nservices:\n  web:\n    image: marios-pizzeria:latest\n    command: python web.py\n    ports:\n      - \"8000-8003:8000\"\n    deploy:\n      replicas: 4 # 4 web processes\n\n  worker:\n    image: marios-pizzeria:latest\n    command: python worker.py\n    deploy:\n      replicas: 2 # 2 worker processes\n\n  scheduler:\n    image: marios-pizzeria:latest\n    command: python scheduler.py\n    deploy:\n      replicas: 1 # 1 scheduler process\n</code></pre> <p>Internal Multiplexing with async/await:</p> <pre><code>class OrderController(ControllerBase):\n    @post(\"/orders\")\n    async def create_order(self, order_dto: CreateOrderDto):\n        # Single process handles multiple concurrent requests\n        # via async/await internal multiplexing\n        command = self.mapper.map(order_dto, CreateOrderCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\nclass BackgroundTaskService(HostedService):\n    async def start_async(self, cancellation_token):\n        # Single worker process handles multiple tasks concurrently\n        tasks = [\n            self.process_emails(),\n            self.process_notifications(),\n            self.process_analytics()\n        ]\n        await asyncio.gather(*tasks)\n\n    async def process_emails(self):\n        while True:\n            # Internal multiplexing within single process\n            async for email in self.email_queue:\n                await self.send_email(email)\n</code></pre> <p>Process Management with supervision:</p> <pre><code># supervisor.conf - Process supervision\n[program:marios-web]\ncommand=python web.py\nnumprocs=4\nautostart=true\nautorestart=true\n\n[program:marios-worker]\ncommand=python worker.py\nnumprocs=2\nautostart=true\nautorestart=true\n</code></pre>"},{"location":"references/12-factor-app/#ix-disposability","title":"IX. Disposability \u267b\ufe0f","text":"<p>Principle: Maximize robustness with fast startup and graceful shutdown</p>"},{"location":"references/12-factor-app/#requirements_8","title":"Requirements","text":"<ul> <li>Fast startup for elastic scaling</li> <li>Graceful shutdown on SIGTERM</li> <li>Robust against sudden termination</li> </ul>"},{"location":"references/12-factor-app/#how-neuroglia-supports-this_8","title":"How Neuroglia Supports This","text":"<p>Fast Startup through optimized initialization:</p> <pre><code>class WebApplicationBuilder:\n    def build(self) -&gt; FastAPI:\n        app = FastAPI(\n            title=\"Mario's Pizzeria API\",\n            # Fast startup - minimal initialization\n            docs_url=\"/docs\" if self._is_development else None,\n            redoc_url=\"/redoc\" if self._is_development else None\n        )\n\n        # Lazy service initialization\n        app.state.service_provider = LazyServiceProvider(self._services)\n\n        # Fast health check endpoint\n        @app.get(\"/health\")\n        async def health_check():\n            return {\"status\": \"healthy\", \"timestamp\": datetime.utcnow()}\n\n        return app\n\ndef create_app():\n    # Optimized for fast startup\n    builder = WebApplicationBuilder()\n\n    # Register services (no initialization yet)\n    builder.services.add_controllers([\"api.controllers\"])\n    builder.services.add_mediator()\n\n    # Build returns immediately\n    return builder.build()\n</code></pre> <p>Graceful Shutdown handling:</p> <pre><code>import signal\nimport asyncio\nfrom contextlib import asynccontextmanager\n\nclass GracefulShutdownHandler:\n    def __init__(self, app: FastAPI):\n        self._app = app\n        self._shutdown_event = asyncio.Event()\n        self._background_tasks = set()\n\n    def setup_signal_handlers(self):\n        # Handle SIGTERM gracefully\n        signal.signal(signal.SIGTERM, self._signal_handler)\n        signal.signal(signal.SIGINT, self._signal_handler)\n\n    def _signal_handler(self, signum, frame):\n        print(f\"Received signal {signum}, initiating graceful shutdown...\")\n        asyncio.create_task(self._graceful_shutdown())\n\n    async def _graceful_shutdown(self):\n        # Stop accepting new requests\n        self._app.state.accepting_requests = False\n\n        # Wait for current requests to complete (max 30 seconds)\n        try:\n            await asyncio.wait_for(\n                self._wait_for_requests_to_complete(),\n                timeout=30.0\n            )\n        except asyncio.TimeoutError:\n            print(\"Timeout waiting for requests to complete\")\n\n        # Cancel background tasks\n        for task in self._background_tasks:\n            task.cancel()\n\n        # Close connections\n        if hasattr(self._app.state, 'database'):\n            await self._app.state.database.close()\n\n        self._shutdown_event.set()\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Startup\n    shutdown_handler = GracefulShutdownHandler(app)\n    shutdown_handler.setup_signal_handlers()\n\n    yield\n\n    # Shutdown\n    await shutdown_handler._shutdown_event.wait()\n\ndef create_app():\n    return FastAPI(lifespan=lifespan)\n</code></pre> <p>Background Task Resilience:</p> <pre><code>class BackgroundTaskService(HostedService):\n    async def start_async(self, cancellation_token):\n        while not cancellation_token.is_cancelled:\n            try:\n                # Process work with checkpoints\n                async for work_item in self.get_work_items():\n                    if cancellation_token.is_cancelled:\n                        # Return work to queue on shutdown\n                        await self.return_to_queue(work_item)\n                        break\n\n                    await self.process_work_item(work_item)\n\n            except Exception as ex:\n                # Log error but continue running\n                self._logger.error(f\"Background task error: {ex}\")\n                await asyncio.sleep(5)  # Brief pause before retry\n\nclass OrderProcessingService:\n    async def process_order(self, order_id: str):\n        # Idempotent processing - safe to retry\n        order = await self._repository.get_by_id_async(order_id)\n        if order.status == OrderStatus.COMPLETED:\n            return  # Already processed\n\n        # Process with database transaction\n        async with self._repository.begin_transaction():\n            order.status = OrderStatus.PROCESSING\n            await self._repository.save_async(order)\n\n            # Do work...\n\n            order.status = OrderStatus.COMPLETED\n            await self._repository.save_async(order)\n</code></pre> <p>Container Health Checks:</p> <pre><code># Dockerfile with health check\nFROM python:3.11-slim\nWORKDIR /app\nCOPY . .\nRUN pip install -r requirements.txt\n\n# Health check for fast failure detection\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n    CMD curl -f http://localhost:8000/health || exit 1\n\nCMD [\"python\", \"main.py\"]\n</code></pre>"},{"location":"references/12-factor-app/#x-devprod-parity","title":"X. Dev/Prod Parity \ud83d\udd04","text":"<p>Principle: Keep development, staging, and production as similar as possible</p>"},{"location":"references/12-factor-app/#requirements_9","title":"Requirements","text":"<ul> <li>Minimize time gap between development and production</li> <li>Same people involved in development and deployment</li> <li>Use same backing services in all environments</li> </ul>"},{"location":"references/12-factor-app/#how-neuroglia-supports-this_9","title":"How Neuroglia Supports This","text":"<p>Same Backing Services across environments:</p> <pre><code># Use same service types everywhere\nclass DatabaseSettings(BaseSettings):\n    connection_string: str\n    database_name: str\n\n    @property\n    def is_mongodb(self) -&gt; bool:\n        return self.connection_string.startswith(\"mongodb://\")\n\ndef configure_database(services, settings: DatabaseSettings):\n    if settings.is_mongodb:\n        # MongoDB in all environments (dev uses local, prod uses cluster)\n        services.add_scoped(\n            PizzaRepository,\n            lambda sp: MongoDbPizzaRepository(settings.connection_string)\n        )\n    else:\n        # Don't use SQLite in dev and PostgreSQL in prod\n        # Use PostgreSQL everywhere via Docker\n        services.add_scoped(\n            PizzaRepository,\n            lambda sp: PostgreSQLPizzaRepository(settings.connection_string)\n        )\n</code></pre> <p>Docker Development Environment:</p> <pre><code># docker-compose.dev.yml - Same services as production\nversion: \"3.8\"\nservices:\n  app:\n    build: .\n    ports:\n      - \"8000:8000\"\n    environment:\n      - ENVIRONMENT=development\n      - MONGODB_CONNECTION_STRING=mongodb://mongo:27017/marios_dev\n      - REDIS_URL=redis://redis:6379\n    depends_on:\n      - mongo\n      - redis\n\n  mongo:\n    image: mongo:7.0 # Same version as production\n    ports:\n      - \"27017:27017\"\n\n  redis:\n    image: redis:7.2 # Same version as production\n    ports:\n      - \"6379:6379\"\n</code></pre> <p>Environment Parity Validation:</p> <pre><code>class EnvironmentValidator:\n    def __init__(self, settings: AppSettings):\n        self._settings = settings\n\n    def validate_parity(self):\n        \"\"\"Ensure dev/staging/prod use compatible services\"\"\"\n        warnings = []\n\n        # Check database compatibility\n        if self._settings.environment == \"development\":\n            if \"sqlite\" in self._settings.mongodb_connection_string.lower():\n                warnings.append(\n                    \"Development uses SQLite but production uses MongoDB. \"\n                    \"Use MongoDB in development for better parity.\"\n                )\n\n        # Check cache compatibility\n        if not self._settings.redis_url and self._settings.environment != \"test\":\n            warnings.append(\n                \"No Redis configuration found. \"\n                \"Use Redis in all environments for dev/prod parity.\"\n            )\n\n        return warnings\n\n# Application startup validation\ndef create_app():\n    settings = AppSettings()\n    validator = EnvironmentValidator(settings)\n\n    parity_warnings = validator.validate_parity()\n    if parity_warnings:\n        for warning in parity_warnings:\n            logger.warning(f\"Dev/Prod Parity: {warning}\")\n\n    builder = WebApplicationBuilder()\n    # ... configure app\n    return builder.build()\n</code></pre> <p>Continuous Deployment Pipeline:</p> <pre><code># .github/workflows/deploy.yml\nname: Deploy\non:\n  push:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    services:\n      mongo:\n        image: mongo:7.0\n      redis:\n        image: redis:7.2\n    steps:\n      - uses: actions/checkout@v3\n      - name: Run tests against production-like services\n        run: |\n          export MONGODB_CONNECTION_STRING=mongodb://mongo:27017/test\n          export REDIS_URL=redis://redis:6379\n          poetry run pytest\n\n  deploy-staging:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n      - name: Deploy to staging\n        run: |\n          # Same deployment process as production\n          docker build -t marios-pizzeria:${{ github.sha }} .\n          docker push registry/marios-pizzeria:${{ github.sha }}\n          kubectl set image deployment/app app=registry/marios-pizzeria:${{ github.sha }}\n\n  deploy-production:\n    needs: deploy-staging\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'\n    steps:\n      - name: Deploy to production\n        run: |\n          # Identical process to staging\n          kubectl set image deployment/app app=registry/marios-pizzeria:${{ github.sha }}\n</code></pre>"},{"location":"references/12-factor-app/#xi-logs","title":"XI. Logs \ud83d\udcca","text":"<p>Principle: Treat logs as event streams</p>"},{"location":"references/12-factor-app/#requirements_10","title":"Requirements","text":"<ul> <li>Write unbuffered logs to stdout</li> <li>No log file management by the application</li> <li>Log aggregation handled by execution environment</li> </ul>"},{"location":"references/12-factor-app/#how-neuroglia-supports-this_10","title":"How Neuroglia Supports This","text":"<p>Structured Logging to stdout:</p> <pre><code>import structlog\nimport sys\n\n# Configure structured logging\nstructlog.configure(\n    processors=[\n        structlog.stdlib.filter_by_level,\n        structlog.stdlib.add_logger_name,\n        structlog.stdlib.add_log_level,\n        structlog.stdlib.PositionalArgumentsFormatter(),\n        structlog.processors.TimeStamper(fmt=\"iso\"),\n        structlog.processors.StackInfoRenderer(),\n        structlog.processors.format_exc_info,\n        structlog.processors.UnicodeDecoder(),\n        structlog.processors.JSONRenderer()  # JSON for structured logs\n    ],\n    context_class=dict,\n    logger_factory=structlog.stdlib.LoggerFactory(),\n    wrapper_class=structlog.stdlib.BoundLogger,\n    cache_logger_on_first_use=True,\n)\n\n# Application logger - writes to stdout only\nlogger = structlog.get_logger()\n\nclass OrderController(ControllerBase):\n    @post(\"/orders\")\n    async def create_order(self, order_dto: CreateOrderDto):\n        # Structured logging with context\n        logger.info(\n            \"Order creation started\",\n            customer_id=order_dto.customer_id,\n            pizza_count=len(order_dto.pizzas),\n            total_amount=order_dto.total_amount,\n            correlation_id=self.get_correlation_id()\n        )\n\n        try:\n            command = self.mapper.map(order_dto, CreateOrderCommand)\n            result = await self.mediator.execute_async(command)\n\n            logger.info(\n                \"Order created successfully\",\n                order_id=result.value.id,\n                correlation_id=self.get_correlation_id()\n            )\n\n            return self.process(result)\n\n        except Exception as ex:\n            logger.error(\n                \"Order creation failed\",\n                error=str(ex),\n                error_type=type(ex).__name__,\n                correlation_id=self.get_correlation_id()\n            )\n            raise\n</code></pre> <p>Request/Response Logging Middleware:</p> <pre><code>import time\nfrom fastapi import Request, Response\n\nclass LoggingMiddleware:\n    def __init__(self, app):\n        self.app = app\n\n    async def __call__(self, scope, receive, send):\n        if scope[\"type\"] != \"http\":\n            await self.app(scope, receive, send)\n            return\n\n        request = Request(scope, receive)\n        start_time = time.time()\n\n        # Log request\n        logger.info(\n            \"HTTP request started\",\n            method=request.method,\n            path=request.url.path,\n            query_params=str(request.query_params),\n            user_agent=request.headers.get(\"user-agent\"),\n            client_ip=request.client.host if request.client else None\n        )\n\n        async def send_wrapper(message):\n            if message[\"type\"] == \"http.response.start\":\n                # Log response\n                duration = time.time() - start_time\n                logger.info(\n                    \"HTTP request completed\",\n                    method=request.method,\n                    path=request.url.path,\n                    status_code=message[\"status\"],\n                    duration_ms=round(duration * 1000, 2)\n                )\n            await send(message)\n\n        await self.app(scope, receive, send_wrapper)\n\n# Add middleware to application\ndef create_app():\n    builder = WebApplicationBuilder()\n    app = builder.build()\n\n    # Add logging middleware\n    app.add_middleware(LoggingMiddleware)\n\n    return app\n</code></pre> <p>No Log File Management:</p> <pre><code># main.py - No log files, only stdout\nimport logging\nimport sys\n\ndef configure_logging():\n    # Only configure stdout handler\n    root_logger = logging.getLogger()\n\n    # Remove any existing handlers\n    root_logger.handlers.clear()\n\n    # Add only stdout handler\n    stdout_handler = logging.StreamHandler(sys.stdout)\n    stdout_handler.setFormatter(\n        logging.Formatter(\n            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n        )\n    )\n\n    root_logger.addHandler(stdout_handler)\n    root_logger.setLevel(logging.INFO)\n\nif __name__ == \"__main__\":\n    configure_logging()  # No file handlers\n    app = create_app()\n\n    # Application logs go to stdout, captured by container runtime\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000, log_config=None)\n</code></pre> <p>Log Aggregation via deployment environment:</p> <pre><code># kubernetes deployment with log aggregation\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: marios-pizzeria\nspec:\n  template:\n    spec:\n      containers:\n        - name: app\n          image: marios-pizzeria:latest\n          # Logs go to stdout, captured by Kubernetes\n          env:\n            - name: LOG_LEVEL\n              value: \"INFO\"\n          # No volume mounts for log files\n---\n# Fluentd configuration for log aggregation\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: fluentd-config\ndata:\n  fluent.conf: |\n    &lt;source&gt;\n      @type tail\n      path /var/log/containers/marios-pizzeria-*.log\n      pos_file /var/log/fluentd-containers.log.pos\n      tag kubernetes.*\n      format json\n    &lt;/source&gt;\n\n    &lt;match kubernetes.**&gt;\n      @type elasticsearch\n      host elasticsearch.logging.svc.cluster.local\n      port 9200\n      index_name marios-pizzeria\n    &lt;/match&gt;\n</code></pre>"},{"location":"references/12-factor-app/#xii-admin-processes","title":"XII. Admin Processes \ud83d\udd27","text":"<p>Principle: Run admin/management tasks as one-off processes</p>"},{"location":"references/12-factor-app/#requirements_11","title":"Requirements","text":"<ul> <li>Admin tasks run in identical environment as regular processes</li> <li>Use same codebase and configuration</li> <li>Run against specific releases</li> </ul>"},{"location":"references/12-factor-app/#how-neuroglia-supports-this_11","title":"How Neuroglia Supports This","text":"<p>Admin Command Framework:</p> <pre><code># cli/admin.py - Admin process framework\nimport asyncio\nimport sys\nfrom abc import ABC, abstractmethod\nfrom neuroglia.hosting.web import WebApplicationBuilder\n\nclass AdminCommand(ABC):\n    @abstractmethod\n    async def execute_async(self, service_provider) -&gt; int:\n        \"\"\"Execute admin command, return exit code\"\"\"\n        pass\n\nclass MigrateDatabaseCommand(AdminCommand):\n    async def execute_async(self, service_provider) -&gt; int:\n        logger.info(\"Starting database migration...\")\n\n        try:\n            # Use same services as web processes\n            repository = service_provider.get_service(PizzaRepository)\n            await repository.migrate_schema_async()\n\n            logger.info(\"Database migration completed successfully\")\n            return 0\n\n        except Exception as ex:\n            logger.error(f\"Database migration failed: {ex}\")\n            return 1\n\nclass SeedDataCommand(AdminCommand):\n    async def execute_async(self, service_provider) -&gt; int:\n        logger.info(\"Seeding initial data...\")\n\n        try:\n            # Use same repositories as application\n            pizza_repo = service_provider.get_service(PizzaRepository)\n\n            # Create default pizzas\n            default_pizzas = [\n                Pizza(\"margherita\", \"Margherita\", 12.99),\n                Pizza(\"pepperoni\", \"Pepperoni\", 14.99),\n                Pizza(\"hawaiian\", \"Hawaiian\", 15.99)\n            ]\n\n            for pizza in default_pizzas:\n                await pizza_repo.save_async(pizza)\n\n            logger.info(f\"Seeded {len(default_pizzas)} default pizzas\")\n            return 0\n\n        except Exception as ex:\n            logger.error(f\"Data seeding failed: {ex}\")\n            return 1\n\n# Admin process runner\nasync def run_admin_command(command_name: str) -&gt; int:\n    # Create same application context as web processes\n    builder = WebApplicationBuilder()\n\n    # Same service configuration as main application\n    builder.services.add_scoped(PizzaRepository, MongoDbPizzaRepository)\n    builder.services.add_mediator()\n\n    service_provider = builder.services.build_provider()\n\n    # Map commands\n    commands = {\n        \"migrate\": MigrateDatabaseCommand(),\n        \"seed\": SeedDataCommand(),\n    }\n\n    if command_name not in commands:\n        logger.error(f\"Unknown command: {command_name}\")\n        return 1\n\n    # Execute command with same environment\n    return await commands[command_name].execute_async(service_provider)\n\nif __name__ == \"__main__\":\n    if len(sys.argv) != 2:\n        print(\"Usage: python admin.py &lt;command&gt;\")\n        sys.exit(1)\n\n    command = sys.argv[1]\n    exit_code = asyncio.run(run_admin_command(command))\n    sys.exit(exit_code)\n</code></pre> <p>Container-Based Admin Tasks:</p> <pre><code># Same image for web and admin processes\nFROM python:3.11-slim\nWORKDIR /app\nCOPY . .\nRUN pip install -r requirements.txt\n\n# Default command is web process\nCMD [\"python\", \"main.py\"]\n\n# Admin processes use same image with different command\n# docker run marios-pizzeria:latest python admin.py migrate\n# docker run marios-pizzeria:latest python admin.py seed\n</code></pre> <p>Kubernetes Jobs for admin processes:</p> <pre><code># Database migration job\napiVersion: batch/v1\nkind: Job\nmetadata:\n  name: marios-pizzeria-migrate\nspec:\n  template:\n    spec:\n      containers:\n        - name: migrate\n          image: marios-pizzeria:v1.2.3 # Same image as web deployment\n          command: [\"python\", \"admin.py\", \"migrate\"]\n          env:\n            # Same environment as web processes\n            - name: MONGODB_CONNECTION_STRING\n              valueFrom:\n                secretKeyRef:\n                  name: database-secret\n                  key: connection-string\n            - name: ENVIRONMENT\n              value: \"production\"\n      restartPolicy: OnFailure\n---\n# Data seeding job\napiVersion: batch/v1\nkind: Job\nmetadata:\n  name: marios-pizzeria-seed\nspec:\n  template:\n    spec:\n      containers:\n        - name: seed\n          image: marios-pizzeria:v1.2.3 # Exact same release\n          command: [\"python\", \"admin.py\", \"seed\"]\n          env:\n            # Identical configuration\n            - name: MONGODB_CONNECTION_STRING\n              valueFrom:\n                secretKeyRef:\n                  name: database-secret\n                  key: connection-string\n      restartPolicy: OnFailure\n</code></pre> <p>Production Admin Process Examples:</p> <pre><code># Run admin processes in production using same deployment\n# Database migration before release\nkubectl create job --from=deployment/marios-pizzeria migrate-v1-2-3 \\\n  --dry-run=client -o yaml | \\\n  sed 's/app/migrate/' | \\\n  sed 's/main.py/admin.py migrate/' | \\\n  kubectl apply -f -\n\n# One-off data fix\nkubectl run data-fix --image=marios-pizzeria:v1.2.3 \\\n  --env=\"MONGODB_CONNECTION_STRING=$PROD_DB\" \\\n  --restart=Never \\\n  --rm -it -- python admin.py fix-corrupted-orders\n\n# Interactive shell for debugging\nkubectl run debug-shell --image=marios-pizzeria:v1.2.3 \\\n  --env=\"MONGODB_CONNECTION_STRING=$PROD_DB\" \\\n  --restart=Never \\\n  --rm -it -- python -c \"\nfrom main import create_app\napp = create_app()\n# Interactive Python shell with full application context\nimport IPython; IPython.embed()\n\"\n</code></pre>"},{"location":"references/12-factor-app/#summary","title":"\ud83c\udfaf Summary","text":"<p>The Neuroglia framework was designed from the ground up to support the Twelve-Factor App methodology. Here's how each principle is addressed:</p> Factor Neuroglia Support I. Codebase Modular architecture with clean separation, single codebase for multiple deployments II. Dependencies Poetry dependency management, dependency injection container, Docker isolation III. Config Pydantic settings with environment variables, no hardcoded configuration IV. Backing Services Repository pattern, service abstractions, configurable implementations V. Build/Release/Run Docker builds, immutable releases, environment-specific deployments VI. Processes Stateless controllers, repository persistence, horizontal scaling support VII. Port Binding Self-contained FastAPI server, uvicorn HTTP binding, service-to-service HTTP VIII. Concurrency Process types, async/await concurrency, container orchestration IX. Disposability Fast startup, graceful shutdown handlers, idempotent operations X. Dev/Prod Parity Docker dev environments, same backing services, continuous deployment XI. Logs Structured logging to stdout, no file management, aggregation-ready XII. Admin Processes CLI command framework, same environment as web processes, container jobs"},{"location":"references/12-factor-app/#building-12-factor-apps-with-neuroglia","title":"\ud83d\ude80 Building 12-Factor Apps with Neuroglia","text":"<p>When building applications with Neuroglia, following these patterns ensures your application is:</p> <ul> <li>Portable: Runs consistently across different environments</li> <li>Scalable: Horizontal scaling through stateless processes</li> <li>Maintainable: Clean separation of concerns and dependency management</li> <li>Observable: Comprehensive logging and health monitoring</li> <li>Resilient: Graceful handling of failures and shutdowns</li> <li>Cloud-Native: Ready for container orchestration and continuous deployment</li> </ul> <p>The framework's opinionated architecture guides you toward 12-factor compliance naturally, making it easier to build modern, cloud-native applications that follow industry best practices.</p>"},{"location":"references/12-factor-app/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Framework setup and basic usage</li> <li>Dependency Injection - Service container and lifetime management</li> <li>CQRS &amp; Mediation - Command and query patterns</li> <li>MVC Controllers - HTTP API development</li> <li>Data Access - Repository pattern and backing services</li> <li>OpenBank Sample - Complete 12-factor application example</li> </ul>"},{"location":"references/oauth-oidc-jwt/","title":"\ud83d\udd10 OAuth 2.0, OpenID Connect &amp; JWT Reference","text":"<p>This comprehensive guide covers OAuth 2.0, OpenID Connect (OIDC), and JSON Web Tokens (JWT) implementation using the Neuroglia framework, with practical examples from Mario's Pizzeria.</p> <p>Based on official IETF specifications and OpenID Foundation standards, this reference provides production-ready patterns for implementing enterprise-grade authentication and authorization.</p>"},{"location":"references/oauth-oidc-jwt/#what-is-oauth-20","title":"\ud83c\udfaf What is OAuth 2.0?","text":"<p>OAuth 2.0 (RFC 6749) is an authorization framework that enables applications to obtain limited access to user accounts. It works by delegating user authentication to an authorization server and allowing third-party applications to obtain limited access tokens instead of passwords.</p>"},{"location":"references/oauth-oidc-jwt/#key-oauth-20-concepts","title":"Key OAuth 2.0 Concepts","text":"<ul> <li>Resource Owner: The user who owns the data (pizzeria customer/staff)</li> <li>Client: The application requesting access (Mario's Pizzeria web app)</li> <li>Authorization Server: Issues access tokens (Keycloak, Auth0, etc.)</li> <li>Resource Server: Hosts protected resources (Mario's Pizzeria API)</li> <li>Access Token: Credential used to access protected resources</li> <li>Scope: Permissions granted to the client (orders:read, kitchen:manage)</li> </ul>"},{"location":"references/oauth-oidc-jwt/#what-is-openid-connect-oidc","title":"\ud83c\udd94 What is OpenID Connect (OIDC)?","text":"<p>OpenID Connect (OpenID Connect Core 1.0) is an identity layer built on top of OAuth 2.0. While OAuth 2.0 handles authorization (what you can do), OIDC adds authentication (who you are).</p>"},{"location":"references/oauth-oidc-jwt/#oidc-adds-to-oauth-20","title":"OIDC Adds to OAuth 2.0","text":"<ul> <li>ID Token: Contains user identity information (JWT format)</li> <li>UserInfo Endpoint: Provides additional user profile data</li> <li>Standardized Claims: Email, name, roles, etc.</li> <li>Discovery: Automatic configuration discovery</li> </ul>"},{"location":"references/oauth-oidc-jwt/#what-are-json-web-tokens-jwt","title":"\ud83c\udff7\ufe0f What are JSON Web Tokens (JWT)?","text":"<p>JWT (RFC 7519) is a compact, URL-safe means of representing claims between two parties. In our pizzeria context, JWTs contain user identity and permissions.</p>"},{"location":"references/oauth-oidc-jwt/#jwt-structure","title":"JWT Structure","text":"<pre><code>Header.Payload.Signature\n</code></pre> <p>Example JWT for Mario's Pizzeria:</p> <pre><code>// Header\n{\n  \"alg\": \"RS256\",\n  \"typ\": \"JWT\",\n  \"kid\": \"pizzeria-key-1\"\n}\n\n// Payload\n{\n  \"sub\": \"customer_12345\",\n  \"name\": \"Mario Rossi\",\n  \"email\": \"mario@example.com\",\n  \"roles\": [\"customer\"],\n  \"scope\": \"orders:read orders:write menu:read\",\n  \"iss\": \"https://auth.mariospizzeria.com\",\n  \"aud\": \"pizzeria-api\",\n  \"exp\": 1695734400,\n  \"iat\": 1695648000\n}\n\n// Signature (generated by authorization server)\n</code></pre>"},{"location":"references/oauth-oidc-jwt/#oauth-20-authorization-flow","title":"\ud83d\udd04 OAuth 2.0 Authorization Flow","text":"<p>Here's how a customer logs into Mario's Pizzeria:</p> <pre><code>sequenceDiagram\n    participant User as \ud83d\udc64 Customer\n    participant Client as \ud83c\udf55 Pizzeria Web App\n    participant AuthServer as \ud83d\udd10 Keycloak (Auth Server)\n    participant API as \ud83c\udf10 Pizzeria API\n\n    Note over User,API: OAuth 2.0 Authorization Code Flow\n\n    User-&gt;&gt;+Client: 1. Click \"Login\"\n    Client-&gt;&gt;+AuthServer: 2. Redirect to authorization endpoint&lt;br/&gt;?client_id=pizzeria&amp;scope=orders:read+orders:write\n    AuthServer-&gt;&gt;+User: 3. Show login form\n    User-&gt;&gt;AuthServer: 4. Enter credentials\n    AuthServer-&gt;&gt;-User: 5. Redirect with authorization code&lt;br/&gt;?code=ABC123\n\n    User-&gt;&gt;+Client: 6. Return to app with code\n    Client-&gt;&gt;+AuthServer: 7. Exchange code for tokens&lt;br/&gt;POST /token\n    AuthServer-&gt;&gt;-Client: 8. Return access_token + id_token\n\n    Note over Client,API: Making Authenticated API Calls\n\n    Client-&gt;&gt;+API: 9. GET /orders&lt;br/&gt;Authorization: Bearer &lt;access_token&gt;\n    API-&gt;&gt;API: 10. Validate JWT signature &amp; claims\n    API-&gt;&gt;-Client: 11. Return order data\n\n    Client-&gt;&gt;-User: 12. Display user's orders</code></pre>"},{"location":"references/oauth-oidc-jwt/#jwt-validation-process","title":"\ud83d\udd0d JWT Validation Process","text":"<p>When Mario's Pizzeria API receives a request, it validates the JWT:</p> <pre><code>flowchart TD\n    A[\ud83c\udf10 API Receives Request] --&gt; B{JWT Present?}\n    B --&gt;|No| C[\u274c Return 401 Unauthorized]\n    B --&gt;|Yes| D[\ud83d\udcdd Parse JWT Header/Payload]\n\n    D --&gt; E{Valid Signature?}\n    E --&gt;|No| F[\u274c Return 401 Invalid Token]\n    E --&gt;|Yes| G{Token Expired?}\n\n    G --&gt;|Yes| H[\u274c Return 401 Token Expired]\n    G --&gt;|No| I{Valid Issuer?}\n\n    I --&gt;|No| J[\u274c Return 401 Invalid Issuer]\n    I --&gt;|Yes| K{Valid Audience?}\n\n    K --&gt;|No| L[\u274c Return 401 Invalid Audience]\n    K --&gt;|Yes| M{Required Scope?}\n\n    M --&gt;|No| N[\u274c Return 403 Insufficient Scope]\n    M --&gt;|Yes| O[\u2705 Allow Request]\n\n    O --&gt; P[\ud83c\udf55 Process Business Logic]\n\n    style A fill:#E3F2FD\n    style O fill:#E8F5E8\n    style P fill:#E8F5E8\n    style C,F,H,J,L,N fill:#FFEBEE</code></pre>"},{"location":"references/oauth-oidc-jwt/#keycloak-integration-with-neuroglia-framework","title":"\ud83c\udfd7\ufe0f Keycloak Integration with Neuroglia Framework","text":"<p>Here's how to integrate Keycloak (or any OIDC provider) with Mario's Pizzeria:</p>"},{"location":"references/oauth-oidc-jwt/#1-jwt-authentication-middleware","title":"1. JWT Authentication Middleware","text":"<pre><code>from neuroglia.dependency_injection import ServiceCollection\nfrom neuroglia.mvc import ControllerBase\nfrom fastapi import HTTPException, Depends\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nimport jwt\nfrom typing import Dict, List\n\nclass JWTAuthService:\n    def __init__(self,\n                 issuer: str = \"https://keycloak.mariospizzeria.com/auth/realms/pizzeria\",\n                 audience: str = \"pizzeria-api\",\n                 jwks_url: str = \"https://keycloak.mariospizzeria.com/auth/realms/pizzeria/protocol/openid_connect/certs\"):\n        self.issuer = issuer\n        self.audience = audience\n        self.jwks_url = jwks_url\n        self._public_keys = {}\n\n    async def validate_token(self, token: str) -&gt; Dict:\n        \"\"\"Validate JWT token and return claims\"\"\"\n        try:\n            # Decode without verification first to get kid\n            unverified_header = jwt.get_unverified_header(token)\n            kid = unverified_header.get('kid')\n\n            # Get public key for signature verification\n            public_key = await self._get_public_key(kid)\n\n            # Verify and decode token\n            payload = jwt.decode(\n                token,\n                public_key,\n                algorithms=['RS256'],\n                issuer=self.issuer,\n                audience=self.audience,\n                options={\"verify_exp\": True}\n            )\n\n            return payload\n\n        except jwt.ExpiredSignatureError:\n            raise HTTPException(status_code=401, detail=\"Token has expired\")\n        except jwt.InvalidTokenError as e:\n            raise HTTPException(status_code=401, detail=f\"Invalid token: {str(e)}\")\n\n    def check_scope(self, required_scope: str, token_scopes: str) -&gt; bool:\n        \"\"\"Check if required scope is present in token scopes\"\"\"\n        scopes = token_scopes.split(' ') if token_scopes else []\n        return required_scope in scopes\n\n    async def _get_public_key(self, kid: str):\n        \"\"\"Fetch and cache public keys from JWKS endpoint\"\"\"\n        # Implementation would fetch from Keycloak JWKS endpoint\n        # and cache the public keys for signature verification\n        pass\n</code></pre>"},{"location":"references/oauth-oidc-jwt/#2-scope-based-authorization-decorators","title":"2. Scope-Based Authorization Decorators","text":"<pre><code>from functools import wraps\nfrom fastapi import HTTPException\n\ndef require_scope(required_scope: str):\n    \"\"\"Decorator to require specific OAuth scope\"\"\"\n    def decorator(func):\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            # Get current user token from dependency injection\n            auth_service = kwargs.get('auth_service')  # Injected\n            token_data = kwargs.get('current_user')    # From JWT validation\n\n            if not auth_service.check_scope(required_scope, token_data.get('scope', '')):\n                raise HTTPException(\n                    status_code=403,\n                    detail=f\"Insufficient permissions. Required scope: {required_scope}\"\n                )\n\n            return await func(*args, **kwargs)\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"references/oauth-oidc-jwt/#3-protected-controllers-with-oauth-scopes","title":"3. Protected Controllers with OAuth Scopes","text":"<pre><code>from neuroglia.mvc import ControllerBase\nfrom classy_fastapi.decorators import get, post, put, delete\nfrom fastapi import Depends\n\nclass OrdersController(ControllerBase):\n    def __init__(self,\n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator,\n                 auth_service: JWTAuthService):\n        super().__init__(service_provider, mapper, mediator)\n        self.auth_service = auth_service\n\n    @get(\"/\", response_model=List[OrderDto])\n    @require_scope(\"orders:read\")\n    async def get_orders(self,\n                        current_user: dict = Depends(get_current_user)) -&gt; List[OrderDto]:\n        \"\"\"Get orders - requires orders:read scope\"\"\"\n        # Customers see only their orders, staff see all\n        if \"customer\" in current_user.get(\"roles\", []):\n            query = GetOrdersByCustomerQuery(customer_id=current_user[\"sub\"])\n        else:\n            query = GetAllOrdersQuery()\n\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @post(\"/\", response_model=OrderDto, status_code=201)\n    @require_scope(\"orders:write\")\n    async def create_order(self,\n                          create_order_dto: CreateOrderDto,\n                          current_user: dict = Depends(get_current_user)) -&gt; OrderDto:\n        \"\"\"Create new order - requires orders:write scope\"\"\"\n        command = self.mapper.map(create_order_dto, PlaceOrderCommand)\n        command.customer_id = current_user[\"sub\"]  # From JWT\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\nclass KitchenController(ControllerBase):\n\n    @get(\"/status\", response_model=KitchenStatusDto)\n    @require_scope(\"kitchen:read\")\n    async def get_kitchen_status(self,\n                                current_user: dict = Depends(get_current_user)) -&gt; KitchenStatusDto:\n        \"\"\"Get kitchen status - requires kitchen:read scope\"\"\"\n        query = GetKitchenStatusQuery()\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @post(\"/orders/{order_id}/start\")\n    @require_scope(\"kitchen:manage\")\n    async def start_cooking_order(self,\n                                 order_id: str,\n                                 current_user: dict = Depends(get_current_user)) -&gt; OrderDto:\n        \"\"\"Start cooking order - requires kitchen:manage scope\"\"\"\n        command = StartCookingCommand(\n            order_id=order_id,\n            kitchen_staff_id=current_user[\"sub\"]\n        )\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"references/oauth-oidc-jwt/#4-user-context-and-dependency-injection","title":"4. User Context and Dependency Injection","text":"<pre><code>from fastapi import Depends\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\n\nasync def get_current_user(\n    credentials: HTTPAuthorizationCredentials = Depends(security),\n    auth_service: JWTAuthService = Depends()\n) -&gt; dict:\n    \"\"\"Extract and validate user from JWT token\"\"\"\n    token = credentials.credentials\n    user_data = await auth_service.validate_token(token)\n    return user_data\n\ndef configure_auth_services(services: ServiceCollection):\n    \"\"\"Configure authentication services\"\"\"\n    services.add_singleton(JWTAuthService)\n    services.add_scoped(lambda sp: get_current_user)\n</code></pre>"},{"location":"references/oauth-oidc-jwt/#role-based-access-control","title":"\ud83c\udfad Role-Based Access Control","text":"<p>Mario's Pizzeria defines different user roles with specific scopes:</p> <pre><code>ROLE_SCOPES = {\n    \"customer\": [\n        \"orders:read\",      # View own orders\n        \"orders:write\",     # Place new orders\n        \"menu:read\"         # Browse menu\n    ],\n    \"kitchen_staff\": [\n        \"orders:read\",      # View all orders\n        \"kitchen:read\",     # View kitchen status\n        \"kitchen:manage\",   # Manage cooking queue\n        \"menu:read\"         # View menu\n    ],\n    \"manager\": [\n        \"orders:read\",      # View all orders\n        \"orders:write\",     # Create orders for customers\n        \"kitchen:read\",     # Monitor kitchen\n        \"kitchen:manage\",   # Manage kitchen operations\n        \"menu:read\",        # View menu\n        \"menu:write\",       # Update menu items\n        \"reports:read\"      # View analytics\n    ],\n    \"admin\": [\n        \"admin\"             # Full access to everything\n    ]\n}\n</code></pre>"},{"location":"references/oauth-oidc-jwt/#keycloak-configuration","title":"\ud83d\udd27 Keycloak Configuration","text":"<p>Keycloak is an open-source identity and access management solution that implements OAuth 2.0 and OpenID Connect standards.</p>"},{"location":"references/oauth-oidc-jwt/#realm-configuration","title":"Realm Configuration","text":"<pre><code>{\n  \"realm\": \"pizzeria\",\n  \"enabled\": true,\n  \"displayName\": \"Mario's Pizzeria\",\n  \"accessTokenLifespan\": 3600,\n  \"ssoSessionMaxLifespan\": 86400,\n  \"clients\": [\n    {\n      \"clientId\": \"pizzeria-web\",\n      \"enabled\": true,\n      \"protocol\": \"openid-connect\",\n      \"redirectUris\": [\"https://mariospizzeria.com/auth/callback\"],\n      \"webOrigins\": [\"https://mariospizzeria.com\"],\n      \"defaultClientScopes\": [\"profile\", \"email\", \"roles\"]\n    },\n    {\n      \"clientId\": \"pizzeria-api\",\n      \"enabled\": true,\n      \"bearerOnly\": true,\n      \"protocol\": \"openid-connect\"\n    }\n  ],\n  \"clientScopes\": [\n    {\n      \"name\": \"orders:read\",\n      \"description\": \"Read order information\"\n    },\n    {\n      \"name\": \"orders:write\",\n      \"description\": \"Create and modify orders\"\n    },\n    {\n      \"name\": \"kitchen:read\",\n      \"description\": \"View kitchen status\"\n    },\n    {\n      \"name\": \"kitchen:manage\",\n      \"description\": \"Manage kitchen operations\"\n    }\n  ]\n}\n</code></pre>"},{"location":"references/oauth-oidc-jwt/#frontend-integration-example","title":"\ud83d\udcf1 Frontend Integration Example","text":"<pre><code>// React/JavaScript frontend example\nclass PizzeriaAuthService {\n  constructor() {\n    this.keycloakConfig = {\n      url: \"https://keycloak.mariospizzeria.com/auth\",\n      realm: \"pizzeria\",\n      clientId: \"pizzeria-web\",\n    };\n  }\n\n  async login() {\n    // Redirect to Keycloak login\n    const authUrl =\n      `${this.keycloakConfig.url}/realms/${this.keycloakConfig.realm}/protocol/openid_connect/auth` +\n      `?client_id=${this.keycloakConfig.clientId}` +\n      `&amp;response_type=code` +\n      `&amp;scope=openid profile email orders:read orders:write menu:read` +\n      `&amp;redirect_uri=${encodeURIComponent(window.location.origin + \"/auth/callback\")}`;\n\n    window.location.href = authUrl;\n  }\n\n  async makeAuthenticatedRequest(url, options = {}) {\n    const token = localStorage.getItem(\"access_token\");\n\n    return fetch(url, {\n      ...options,\n      headers: {\n        Authorization: `Bearer ${token}`,\n        \"Content-Type\": \"application/json\",\n        ...options.headers,\n      },\n    });\n  }\n\n  // Example: Place order with authentication\n  async placeOrder(orderData) {\n    const response = await this.makeAuthenticatedRequest(\"/api/orders\", {\n      method: \"POST\",\n      body: JSON.stringify(orderData),\n    });\n\n    if (response.status === 401) {\n      // Token expired, redirect to login\n      this.login();\n      return;\n    }\n\n    if (response.status === 403) {\n      throw new Error(\"Insufficient permissions to place order\");\n    }\n\n    return response.json();\n  }\n}\n</code></pre>"},{"location":"references/oauth-oidc-jwt/#testing-authentication","title":"\ud83e\uddea Testing Authentication","text":"<pre><code>import pytest\nfrom unittest.mock import Mock, patch\n\nclass TestAuthenticatedEndpoints:\n    def setup_method(self):\n        self.auth_service = Mock(spec=JWTAuthService)\n        self.test_user = {\n            \"sub\": \"customer_123\",\n            \"name\": \"Mario Rossi\",\n            \"email\": \"mario@example.com\",\n            \"roles\": [\"customer\"],\n            \"scope\": \"orders:read orders:write menu:read\"\n        }\n\n    async def test_get_orders_with_valid_token(self, test_client):\n        \"\"\"Test getting orders with valid customer token\"\"\"\n        self.auth_service.validate_token.return_value = self.test_user\n        self.auth_service.check_scope.return_value = True\n\n        headers = {\"Authorization\": \"Bearer valid_token\"}\n        response = await test_client.get(\"/orders\", headers=headers)\n\n        assert response.status_code == 200\n        # Should only return customer's own orders\n\n    async def test_get_orders_insufficient_scope(self, test_client):\n        \"\"\"Test getting orders without required scope\"\"\"\n        user_without_scope = {**self.test_user, \"scope\": \"menu:read\"}\n        self.auth_service.validate_token.return_value = user_without_scope\n        self.auth_service.check_scope.return_value = False\n\n        headers = {\"Authorization\": \"Bearer limited_token\"}\n        response = await test_client.get(\"/orders\", headers=headers)\n\n        assert response.status_code == 403\n        assert \"Insufficient permissions\" in response.json()[\"detail\"]\n\n    async def test_kitchen_access_staff_only(self, test_client):\n        \"\"\"Test kitchen endpoints require staff role\"\"\"\n        staff_user = {\n            \"sub\": \"staff_456\",\n            \"roles\": [\"kitchen_staff\"],\n            \"scope\": \"kitchen:read kitchen:manage\"\n        }\n        self.auth_service.validate_token.return_value = staff_user\n        self.auth_service.check_scope.return_value = True\n\n        headers = {\"Authorization\": \"Bearer staff_token\"}\n        response = await test_client.get(\"/kitchen/status\", headers=headers)\n\n        assert response.status_code == 200\n\n    async def test_expired_token(self, test_client):\n        \"\"\"Test expired token handling\"\"\"\n        from jwt import ExpiredSignatureError\n        self.auth_service.validate_token.side_effect = ExpiredSignatureError()\n\n        headers = {\"Authorization\": \"Bearer expired_token\"}\n        response = await test_client.get(\"/orders\", headers=headers)\n\n        assert response.status_code == 401\n        assert \"expired\" in response.json()[\"detail\"].lower()\n</code></pre>"},{"location":"references/oauth-oidc-jwt/#security-best-practices","title":"\ud83d\udccb Security Best Practices","text":"<p>Following OAuth 2.0 Security Best Current Practice and JWT Best Current Practices:</p>"},{"location":"references/oauth-oidc-jwt/#1-token-security","title":"1. Token Security","text":"<ul> <li>Short-lived access tokens (15-60 minutes)</li> <li>Secure refresh token rotation</li> <li>HTTPS only in production</li> <li>Secure storage (HttpOnly cookies for web)</li> </ul>"},{"location":"references/oauth-oidc-jwt/#2-scope-management","title":"2. Scope Management","text":"<ul> <li>Principle of least privilege - minimal required scopes</li> <li>Granular permissions - specific scopes for each operation</li> <li>Role-based defaults - sensible scope sets per role</li> </ul>"},{"location":"references/oauth-oidc-jwt/#3-api-security","title":"3. API Security","text":"<ul> <li>Rate limiting on authentication endpoints</li> <li>Input validation on all endpoints</li> <li>Audit logging for sensitive operations</li> <li>CORS configuration for web clients</li> </ul>"},{"location":"references/oauth-oidc-jwt/#production-deployment","title":"\ud83d\ude80 Production Deployment","text":"<pre><code># docker-compose.yml for production\nversion: \"3.8\"\nservices:\n  keycloak:\n    image: quay.io/keycloak/keycloak:latest\n    environment:\n      KEYCLOAK_ADMIN: admin\n      KEYCLOAK_ADMIN_PASSWORD: ${KEYCLOAK_ADMIN_PASSWORD}\n      KC_DB: postgres\n      KC_DB_URL: jdbc:postgresql://postgres:5432/keycloak\n      KC_DB_USERNAME: keycloak\n      KC_DB_PASSWORD: ${DB_PASSWORD}\n    command: start --optimized\n    depends_on:\n      - postgres\n    ports:\n      - \"8080:8080\"\n\n  pizzeria-api:\n    build: .\n    environment:\n      JWT_ISSUER: \"https://keycloak.mariospizzeria.com/auth/realms/pizzeria\"\n      JWT_AUDIENCE: \"pizzeria-api\"\n      JWKS_URL: \"https://keycloak.mariospizzeria.com/auth/realms/pizzeria/protocol/openid_connect/certs\"\n    depends_on:\n      - keycloak\n    ports:\n      - \"8000:8000\"\n</code></pre>"},{"location":"references/oauth-oidc-jwt/#authoritative-references-specifications","title":"\ufffd Authoritative References &amp; Specifications","text":""},{"location":"references/oauth-oidc-jwt/#oauth-20-official-specifications","title":"OAuth 2.0 Official Specifications","text":"<ul> <li>RFC 6749: The OAuth 2.0 Authorization Framework - Core OAuth 2.0 specification</li> <li>RFC 6750: OAuth 2.0 Bearer Token Usage - Bearer tokens specification</li> <li>RFC 7636: Proof Key for Code Exchange (PKCE) - Enhanced security for public clients</li> <li>RFC 8628: OAuth 2.0 Device Authorization Grant - Device flow specification</li> <li>OAuth 2.1 Draft - Latest OAuth evolution with security enhancements</li> </ul>"},{"location":"references/oauth-oidc-jwt/#openid-connect-official-specifications","title":"OpenID Connect Official Specifications","text":"<ul> <li>OpenID Connect Core 1.0 - Core OIDC specification</li> <li>OpenID Connect Discovery 1.0 - Automatic configuration discovery</li> <li>OpenID Connect Session Management 1.0 - Session management specification</li> <li>OpenID Connect Front-Channel Logout 1.0 - Front-channel logout</li> <li>OpenID Connect Back-Channel Logout 1.0 - Back-channel logout</li> </ul>"},{"location":"references/oauth-oidc-jwt/#json-web-token-jwt-specifications","title":"JSON Web Token (JWT) Specifications","text":"<ul> <li>RFC 7519: JSON Web Token (JWT) - Core JWT specification</li> <li>RFC 7515: JSON Web Signature (JWS) - JWT signature algorithms</li> <li>RFC 7516: JSON Web Encryption (JWE) - JWT encryption specification</li> <li>RFC 7517: JSON Web Key (JWK) - Cryptographic key representation</li> <li>RFC 7518: JSON Web Algorithms (JWA) - Cryptographic algorithms for JWS/JWE</li> </ul>"},{"location":"references/oauth-oidc-jwt/#security-best-practices-guidelines","title":"Security Best Practices &amp; Guidelines","text":"<ul> <li>OAuth 2.0 Security Best Current Practice - IETF security recommendations</li> <li>OAuth 2.0 Threat Model and Security Considerations - Security threat analysis</li> <li>JWT Best Current Practices - JWT security best practices</li> <li>OWASP Authentication Cheat Sheet - Authentication security guidance</li> </ul>"},{"location":"references/oauth-oidc-jwt/#identity-provider-documentation","title":"Identity Provider Documentation","text":"<ul> <li>Keycloak Documentation - Open-source identity provider</li> <li>Auth0 Documentation - Commercial identity-as-a-service platform</li> <li>Microsoft Entra ID (Azure AD) - Microsoft identity platform</li> <li>Google Identity Platform - Google identity services</li> <li>AWS Cognito - Amazon identity services</li> </ul>"},{"location":"references/oauth-oidc-jwt/#python-libraries-tools","title":"Python Libraries &amp; Tools","text":"<ul> <li>PyJWT - JWT implementation for Python</li> <li>python-jose - JavaScript Object Signing and Encryption for Python</li> <li>Authlib - Comprehensive OAuth/OIDC library for Python</li> <li>FastAPI Security - FastAPI security utilities</li> <li>requests-oauthlib - OAuth support for Python Requests</li> </ul>"},{"location":"references/oauth-oidc-jwt/#testing-development-tools","title":"Testing &amp; Development Tools","text":"<ul> <li>JWT.io - JWT debugger and decoder</li> <li>OAuth.tools - OAuth flow testing tools</li> <li>OpenID Connect Playground - OIDC flow testing</li> <li>OIDC Debugger - OpenID Connect debugging tool</li> </ul>"},{"location":"references/oauth-oidc-jwt/#educational-resources","title":"Educational Resources","text":"<ul> <li>OAuth 2 Simplified - Comprehensive OAuth 2.0 guide by Aaron Parecki</li> <li>OpenID Connect Explained - OIDC learning resources</li> <li>JWT Introduction - JWT fundamentals and use cases</li> <li>The Nuts and Bolts of OAuth 2.0 - Video course on OAuth 2.0</li> </ul>"},{"location":"references/oauth-oidc-jwt/#related-documentation","title":"\ufffd\ud83d\udd17 Related Documentation","text":"<ul> <li>Mario's Pizzeria Sample - Complete pizzeria implementation using these patterns</li> <li>Dependency Injection - How to configure authentication services</li> <li>MVC Controllers - Building protected API endpoints</li> <li>Getting Started - Setting up your first authenticated Neuroglia application</li> </ul> <p>This comprehensive authentication guide demonstrates how to implement enterprise-grade security using OAuth 2.0, OpenID Connect, and JWT tokens with the Neuroglia framework. The examples show real-world patterns for protecting APIs, managing user permissions, and integrating with identity providers like Keycloak.</p>"},{"location":"references/persistence-documentation-guide/","title":"\ud83d\udcda Documentation Cross-References","text":"<p>This document provides cross-references between all the persistence-related documentation in the Neuroglia framework.</p>"},{"location":"references/persistence-documentation-guide/#persistence-documentation-hierarchy","title":"\ud83c\udfdb\ufe0f Persistence Documentation Hierarchy","text":""},{"location":"references/persistence-documentation-guide/#primary-guides","title":"Primary Guides","text":"<ol> <li> <p>\ud83c\udfdb\ufe0f Persistence Patterns - Start Here</p> </li> <li> <p>Purpose: Complete overview and decision framework for choosing persistence approaches</p> </li> <li>Contains: Pattern comparison, complexity levels, decision matrix, implementation examples</li> <li> <p>When to Read: When starting a new feature or project and need to choose persistence approach</p> </li> <li> <p>\ud83d\udd04 Unit of Work Pattern - Core Infrastructure</p> </li> <li>Purpose: Deep dive into the coordination layer that works with all persistence patterns</li> <li>Contains: UnitOfWork implementation, event collection, pipeline integration</li> <li>When to Read: When implementing command handlers or need to understand event coordination</li> </ol>"},{"location":"references/persistence-documentation-guide/#feature-specific-guides","title":"Feature-Specific Guides","text":"<ol> <li> <p>\ud83c\udfdb\ufe0f State-Based Persistence - Simple Approach</p> </li> <li> <p>Purpose: Detailed implementation guide for Entity + State persistence pattern</p> </li> <li>Contains: Entity design, repositories, command handlers, event integration</li> <li> <p>When to Read: When implementing the simple persistence pattern</p> </li> <li> <p>\ud83c\udfaf Simple CQRS - Command/Query Handling</p> </li> <li> <p>Purpose: CQRS implementation that works with both persistence patterns</p> </li> <li>Contains: Command/Query handlers, mediator usage, pipeline behaviors</li> <li> <p>When to Read: When implementing application layer handlers</p> </li> <li> <p>\ud83d\udd27 Pipeline Behaviors - Cross-Cutting Concerns</p> </li> <li>Purpose: Middleware patterns for validation, transactions, event dispatching</li> <li>Contains: Pipeline behavior implementation, ordering, integration patterns</li> <li>When to Read: When implementing cross-cutting concerns like validation or logging</li> </ol>"},{"location":"references/persistence-documentation-guide/#pattern-documentation","title":"Pattern Documentation","text":"<ol> <li>\ud83c\udfdb\ufe0f Domain Driven Design - Foundation Patterns</li> <li>Purpose: Core DDD patterns and abstractions used by all approaches</li> <li>Contains: Entity vs AggregateRoot patterns, domain events, DDD principles</li> <li>When to Read: When learning DDD concepts or designing domain models</li> </ol>"},{"location":"references/persistence-documentation-guide/#reading-path-by-use-case","title":"\ud83d\uddfa\ufe0f Reading Path by Use Case","text":""},{"location":"references/persistence-documentation-guide/#new-to-neuroglia-framework","title":"New to Neuroglia Framework","text":"<ol> <li>Start with Persistence Patterns for overview</li> <li>Read Domain Driven Design for foundation concepts</li> <li>Choose specific pattern guide based on your needs:</li> <li>Simple: Persistence Patterns - Simple Entity</li> <li>Complex: Domain Driven Design Event Sourcing sections</li> <li>Learn coordination with Unit of Work</li> <li>Implement handlers with Simple CQRS</li> </ol>"},{"location":"references/persistence-documentation-guide/#implementing-simple-crud-application","title":"Implementing Simple CRUD Application","text":"<ol> <li>Persistence Patterns \u2192 Choose Entity + State Persistence</li> <li>Persistence Patterns - Simple Entity \u2192 Implementation guide</li> <li>Unit of Work \u2192 Event coordination</li> <li>Simple CQRS \u2192 Command/Query handlers</li> </ol>"},{"location":"references/persistence-documentation-guide/#building-complex-domain-with-event-sourcing","title":"Building Complex Domain with Event Sourcing","text":"<ol> <li>Persistence Patterns \u2192 Choose AggregateRoot + Event Sourcing</li> <li>Domain Driven Design \u2192 Full DDD patterns</li> <li>Unit of Work \u2192 Event coordination</li> <li>Simple CQRS \u2192 Command/Query handlers</li> <li>Pipeline Behaviors \u2192 Cross-cutting concerns</li> </ol>"},{"location":"references/persistence-documentation-guide/#migrating-between-patterns","title":"Migrating Between Patterns","text":"<ol> <li>Persistence Patterns \u2192 Hybrid approach section</li> <li>Unit of Work \u2192 Same infrastructure for both patterns</li> <li>Specific implementation guides based on source and target patterns</li> </ol>"},{"location":"references/persistence-documentation-guide/#understanding-event-coordination","title":"Understanding Event Coordination","text":"<ol> <li>Unit of Work \u2192 Core coordination patterns</li> <li>Pipeline Behaviors \u2192 Event dispatching middleware</li> <li>Domain Driven Design \u2192 Domain event patterns</li> </ol>"},{"location":"references/persistence-documentation-guide/#implementing-cross-cutting-concerns","title":"Implementing Cross-Cutting Concerns","text":"<ol> <li>Pipeline Behaviors \u2192 Core patterns</li> <li>Unit of Work \u2192 Integration with event coordination</li> <li>Simple CQRS \u2192 Handler integration</li> </ol>"},{"location":"references/persistence-documentation-guide/#key-relationships","title":"\ud83d\udd17 Key Relationships","text":""},{"location":"references/persistence-documentation-guide/#all-patterns-use-same-infrastructure","title":"All Patterns Use Same Infrastructure","text":"<ul> <li>Unit of Work coordinates events for both Entity and AggregateRoot patterns</li> <li>Pipeline Behaviors provide cross-cutting concerns for both approaches</li> <li>CQRS/Mediator handles commands/queries regardless of persistence pattern</li> <li>Domain Events work the same way in both simple and complex patterns</li> </ul>"},{"location":"references/persistence-documentation-guide/#complexity-progression","title":"Complexity Progression","text":"<pre><code>Entity + State Persistence (\u2b50\u2b50\u2606\u2606\u2606)\n    \u2193 (add business complexity)\nAggregateRoot + Event Sourcing (\u2b50\u2b50\u2b50\u2b50\u2b50)\n    \u2193 (mix both approaches)\nHybrid Approach (\u2b50\u2b50\u2b50\u2606\u2606)\n</code></pre>"},{"location":"references/persistence-documentation-guide/#framework-integration-points","title":"Framework Integration Points","text":"<ul> <li>Unit of Work \u2190 All persistence patterns use this for event coordination</li> <li>Pipeline Behaviors \u2190 All handlers use this for cross-cutting concerns</li> <li>Mediator \u2190 All commands/queries route through this</li> <li>Domain Events \u2190 All patterns raise events, same dispatching mechanism</li> </ul>"},{"location":"references/persistence-documentation-guide/#quick-reference","title":"\ud83d\udcd6 Quick Reference","text":"I Need To... Read This First Then Read Choose persistence approach Persistence Patterns Pattern-specific guide Implement simple CRUD Persistence Patterns - Simple Entity Unit of Work Build complex domain Domain Driven Design Unit of Work Coordinate events Unit of Work Pipeline Behaviors Implement handlers Simple CQRS Pipeline Behaviors Add validation/logging Pipeline Behaviors Unit of Work Understand DDD concepts Domain Driven Design Persistence Patterns <p>This documentation structure ensures you can find the right information for your specific use case while understanding how all the pieces work together in the Neuroglia framework.</p>"},{"location":"references/python_modular_code/","title":"\ud83c\udfd7\ufe0f Python Modular Code Reference","text":"<p>Understanding modular code organization is essential for working with the Neuroglia framework, which emphasizes clean architecture and separation of concerns.</p>"},{"location":"references/python_modular_code/#what-is-modular-code","title":"\ud83c\udfaf What is Modular Code?","text":"<p>Modular code organizes functionality into separate, reusable components (modules) that have clear responsibilities and well-defined interfaces. This makes code easier to understand, test, maintain, and extend.</p>"},{"location":"references/python_modular_code/#the-pizza-kitchen-analogy","title":"The Pizza Kitchen Analogy","text":"<p>Think of a pizzeria kitchen:</p> <pre><code># \u274c Everything in one big file (messy kitchen):\n# pizza_chaos.py - 2000+ lines doing everything\n\ndef make_dough():\n    pass\n\ndef prepare_sauce():\n    pass\n\ndef add_toppings():\n    pass\n\ndef bake_pizza():\n    pass\n\ndef take_order():\n    pass\n\ndef process_payment():\n    pass\n\ndef manage_inventory():\n    pass\n\n# ... 1900+ more lines\n\n# \u2705 Organized into modules (specialized stations):\n\n# dough_station.py\ndef make_dough(flour_type: str, water_amount: float) -&gt; Dough:\n    \"\"\"Specialized dough preparation.\"\"\"\n    pass\n\n# sauce_station.py\ndef prepare_marinara() -&gt; Sauce:\n    \"\"\"Specialized sauce preparation.\"\"\"\n    pass\n\n# assembly_station.py\ndef assemble_pizza(dough: Dough, sauce: Sauce, toppings: List[str]) -&gt; Pizza:\n    \"\"\"Specialized pizza assembly.\"\"\"\n    pass\n\n# order_management.py\ndef take_order(customer: Customer, items: List[str]) -&gt; Order:\n    \"\"\"Specialized order handling.\"\"\"\n    pass\n</code></pre>"},{"location":"references/python_modular_code/#python-module-basics","title":"\ud83d\udd27 Python Module Basics","text":""},{"location":"references/python_modular_code/#what-is-a-module","title":"What is a Module?","text":"<p>A module is simply a Python file containing code. When you create a <code>.py</code> file, you've created a module.</p> <pre><code># math_utils.py - This is a module\ndef add(a: float, b: float) -&gt; float:\n    \"\"\"Add two numbers.\"\"\"\n    return a + b\n\ndef multiply(a: float, b: float) -&gt; float:\n    \"\"\"Multiply two numbers.\"\"\"\n    return a * b\n\nPI = 3.14159\n\n# Using the module in another file:\n# main.py\nimport math_utils\n\nresult = math_utils.add(5, 3)\ncircle_area = math_utils.PI * radius ** 2\n</code></pre>"},{"location":"references/python_modular_code/#packages-modules-organized-in-directories","title":"Packages - Modules Organized in Directories","text":"<p>A package is a directory containing multiple modules:</p> <pre><code>mario_pizzeria/\n\u251c\u2500\u2500 __init__.py          # Makes this a package\n\u251c\u2500\u2500 pizza.py             # Pizza-related code\n\u251c\u2500\u2500 customer.py          # Customer-related code\n\u2514\u2500\u2500 order.py             # Order-related code\n</code></pre> <pre><code># __init__.py - Package initialization\n\"\"\"Mario's Pizzeria - A delicious pizza ordering system.\"\"\"\n\n__version__ = \"1.0.0\"\n__author__ = \"Mario\"\n\n# pizza.py\nfrom dataclasses import dataclass\nfrom typing import List\n\n@dataclass\nclass Pizza:\n    name: str\n    price: float\n    ingredients: List[str]\n\ndef create_margherita() -&gt; Pizza:\n    return Pizza(\n        name=\"Margherita\",\n        price=12.99,\n        ingredients=[\"tomato\", \"mozzarella\", \"basil\"]\n    )\n\n# Using the package:\nfrom mario_pizzeria.pizza import Pizza, create_margherita\nfrom mario_pizzeria import __version__\n\nmargherita = create_margherita()\nprint(f\"Using Mario's Pizzeria v{__version__}\")\n</code></pre>"},{"location":"references/python_modular_code/#neuroglia-framework-architecture","title":"\ud83c\udfdb\ufe0f Neuroglia Framework Architecture","text":"<p>The Neuroglia framework follows a layered architecture with clear module organization:</p>"},{"location":"references/python_modular_code/#directory-structure","title":"Directory Structure","text":"<pre><code>src/\n\u251c\u2500\u2500 neuroglia/                    # Framework core\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 dependency_injection/     # DI container modules\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 service_collection.py\n\u2502   \u2502   \u251c\u2500\u2500 service_provider.py\n\u2502   \u2502   \u2514\u2500\u2500 extensions.py\n\u2502   \u251c\u2500\u2500 mediation/               # CQRS pattern modules\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 mediator.py\n\u2502   \u2502   \u251c\u2500\u2500 commands.py\n\u2502   \u2502   \u251c\u2500\u2500 queries.py\n\u2502   \u2502   \u2514\u2500\u2500 handlers.py\n\u2502   \u251c\u2500\u2500 mvc/                     # MVC pattern modules\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 controller_base.py\n\u2502   \u2502   \u2514\u2500\u2500 routing.py\n\u2502   \u2514\u2500\u2500 data/                    # Data access modules\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 repository.py\n\u2502       \u2514\u2500\u2500 mongo_repository.py\n\u2514\u2500\u2500 mario_pizzeria/              # Application code\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 api/                     # API layer\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 controllers/\n    \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u2502   \u2514\u2500\u2500 pizza_controller.py\n    \u2502   \u2514\u2500\u2500 dtos/\n    \u2502       \u251c\u2500\u2500 __init__.py\n    \u2502       \u2514\u2500\u2500 pizza_dto.py\n    \u251c\u2500\u2500 application/             # Application layer\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 commands/\n    \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u2502   \u2514\u2500\u2500 create_pizza_command.py\n    \u2502   \u251c\u2500\u2500 queries/\n    \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u2502   \u2514\u2500\u2500 get_pizza_query.py\n    \u2502   \u2514\u2500\u2500 handlers/\n    \u2502       \u251c\u2500\u2500 __init__.py\n    \u2502       \u251c\u2500\u2500 create_pizza_handler.py\n    \u2502       \u2514\u2500\u2500 get_pizza_handler.py\n    \u251c\u2500\u2500 domain/                  # Domain layer\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 entities/\n    \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u2502   \u2514\u2500\u2500 pizza.py\n    \u2502   \u2514\u2500\u2500 repositories/\n    \u2502       \u251c\u2500\u2500 __init__.py\n    \u2502       \u2514\u2500\u2500 pizza_repository.py\n    \u2514\u2500\u2500 integration/             # Integration layer\n        \u251c\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 repositories/\n            \u251c\u2500\u2500 __init__.py\n            \u2514\u2500\u2500 mongo_pizza_repository.py\n</code></pre>"},{"location":"references/python_modular_code/#module-organization-principles","title":"Module Organization Principles","text":""},{"location":"references/python_modular_code/#1-single-responsibility-principle","title":"1. Single Responsibility Principle","text":"<p>Each module should have one clear purpose:</p> <pre><code># \u2705 Good - pizza.py focuses only on Pizza entity\nfrom dataclasses import dataclass\nfrom typing import List\nfrom datetime import datetime\n\n@dataclass\nclass Pizza:\n    \"\"\"Represents a pizza entity.\"\"\"\n    id: str\n    name: str\n    price: float\n    ingredients: List[str]\n    created_at: datetime\n    is_available: bool = True\n\n    def add_ingredient(self, ingredient: str) -&gt; None:\n        \"\"\"Add an ingredient to the pizza.\"\"\"\n        if ingredient not in self.ingredients:\n            self.ingredients.append(ingredient)\n\n    def calculate_cost(self) -&gt; float:\n        \"\"\"Calculate base cost based on ingredients.\"\"\"\n        base_cost = 8.0\n        return base_cost + (len(self.ingredients) * 0.50)\n\n# \u274c Bad - pizza_everything.py tries to do too much\nclass Pizza:\n    # Pizza logic...\n    pass\n\nclass Customer:  # Should be in customer.py\n    pass\n\nclass Order:     # Should be in order.py\n    pass\n\ndef send_email():    # Should be in notification.py\n    pass\n\ndef connect_to_database():  # Should be in database.py\n    pass\n</code></pre>"},{"location":"references/python_modular_code/#2-high-cohesion-low-coupling","title":"2. High Cohesion, Low Coupling","text":"<p>Related functionality stays together, unrelated functionality is separated:</p> <pre><code># High cohesion - pizza_operations.py\nfrom typing import List, Optional\nfrom .pizza import Pizza\n\nclass PizzaService:\n    \"\"\"Service for pizza-related operations.\"\"\"\n\n    def __init__(self, repository: 'PizzaRepository'):\n        self._repository = repository\n\n    async def create_pizza(self, name: str, price: float, ingredients: List[str]) -&gt; Pizza:\n        \"\"\"Create a new pizza.\"\"\"\n        pizza = Pizza(\n            id=self._generate_id(),\n            name=name,\n            price=price,\n            ingredients=ingredients,\n            created_at=datetime.now()\n        )\n        await self._repository.save_async(pizza)\n        return pizza\n\n    async def get_available_pizzas(self) -&gt; List[Pizza]:\n        \"\"\"Get all available pizzas.\"\"\"\n        all_pizzas = await self._repository.get_all_async()\n        return [pizza for pizza in all_pizzas if pizza.is_available]\n\n    def _generate_id(self) -&gt; str:\n        \"\"\"Generate unique pizza ID.\"\"\"\n        return str(uuid.uuid4())\n\n# Low coupling - separate concerns into different modules\n# customer_service.py\nclass CustomerService:\n    \"\"\"Service for customer-related operations.\"\"\"\n    pass\n\n# order_service.py\nclass OrderService:\n    \"\"\"Service for order-related operations.\"\"\"\n    pass\n</code></pre>"},{"location":"references/python_modular_code/#import-strategies","title":"\ud83d\udce6 Import Strategies","text":""},{"location":"references/python_modular_code/#absolute-vs-relative-imports","title":"Absolute vs Relative Imports","text":"<pre><code># Project structure:\nmario_pizzeria/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 domain/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 entities/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 pizza.py\n\u2502   \u2502   \u2514\u2500\u2500 customer.py\n\u2502   \u2514\u2500\u2500 services/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 pizza_service.py\n\u2514\u2500\u2500 infrastructure/\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 repositories/\n        \u251c\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 pizza_repository.py\n\n# \u2705 Absolute imports (preferred for clarity):\n# In pizza_service.py\nfrom mario_pizzeria.domain.entities.pizza import Pizza\nfrom mario_pizzeria.domain.entities.customer import Customer\nfrom mario_pizzeria.infrastructure.repositories.pizza_repository import PizzaRepository\n\n# \u2705 Relative imports (good for internal package references):\n# In pizza_service.py\nfrom ..entities.pizza import Pizza\nfrom ..entities.customer import Customer\nfrom ...infrastructure.repositories.pizza_repository import PizzaRepository\n\n# \u274c Avoid mixing styles in the same file\n</code></pre>"},{"location":"references/python_modular_code/#import-organization","title":"Import Organization","text":"<p>Organize imports in a standard order:</p> <pre><code># Standard library imports\nimport os\nimport sys\nfrom datetime import datetime\nfrom typing import List, Optional, Dict\n\n# Third-party imports\nimport fastapi\nfrom pydantic import BaseModel\nimport pymongo\n\n# Local application imports\nfrom neuroglia.dependency_injection import ServiceProvider\nfrom neuroglia.mediation import Mediator, Command, Query\n\n# Local relative imports\nfrom .pizza import Pizza\nfrom .customer import Customer\nfrom ..repositories.pizza_repository import PizzaRepository\n</code></pre>"},{"location":"references/python_modular_code/#controlling-what-gets-imported","title":"Controlling What Gets Imported","text":"<p>Use <code>__init__.py</code> files to control the public API:</p> <pre><code># domain/entities/__init__.py\n\"\"\"Domain entities for Mario's Pizzeria.\"\"\"\n\nfrom .pizza import Pizza\nfrom .customer import Customer\nfrom .order import Order\n\n# Make only specific classes available when importing the package\n__all__ = ['Pizza', 'Customer', 'Order']\n\n# Usage - clean imports for users:\nfrom mario_pizzeria.domain.entities import Pizza, Customer\n# Instead of:\n# from mario_pizzeria.domain.entities.pizza import Pizza\n# from mario_pizzeria.domain.entities.customer import Customer\n</code></pre>"},{"location":"references/python_modular_code/#lazy-loading-for-performance","title":"Lazy Loading for Performance","text":"<p>Load expensive modules only when needed:</p> <pre><code># heavy_analytics.py - expensive to import\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef generate_sales_report() -&gt; pd.DataFrame:\n    # Expensive analytics operations\n    pass\n\n# pizza_service.py - lazy loading\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    # Import only for type checking, not at runtime\n    from .heavy_analytics import generate_sales_report\n\nclass PizzaService:\n    def get_basic_stats(self) -&gt; dict:\n        \"\"\"Fast operation - no heavy imports needed.\"\"\"\n        return {\"total_pizzas\": 42}\n\n    def get_detailed_analytics(self) -&gt; 'pd.DataFrame':\n        \"\"\"Load analytics module only when needed.\"\"\"\n        from .heavy_analytics import generate_sales_report\n        return generate_sales_report()\n</code></pre>"},{"location":"references/python_modular_code/#advanced-modular-patterns","title":"\ud83c\udfa8 Advanced Modular Patterns","text":""},{"location":"references/python_modular_code/#factory-pattern-with-modules","title":"Factory Pattern with Modules","text":"<p>Organize related creation logic:</p> <pre><code># factories/__init__.py\nfrom .pizza_factory import PizzaFactory\nfrom .customer_factory import CustomerFactory\n\n__all__ = ['PizzaFactory', 'CustomerFactory']\n\n# factories/pizza_factory.py\nfrom typing import List\nfrom ..domain.entities.pizza import Pizza\n\nclass PizzaFactory:\n    \"\"\"Factory for creating different types of pizzas.\"\"\"\n\n    @staticmethod\n    def create_margherita() -&gt; Pizza:\n        return Pizza(\n            id=PizzaFactory._generate_id(),\n            name=\"Margherita\",\n            price=12.99,\n            ingredients=[\"tomato sauce\", \"mozzarella\", \"basil\"],\n            created_at=datetime.now()\n        )\n\n    @staticmethod\n    def create_pepperoni() -&gt; Pizza:\n        return Pizza(\n            id=PizzaFactory._generate_id(),\n            name=\"Pepperoni\",\n            price=14.99,\n            ingredients=[\"tomato sauce\", \"mozzarella\", \"pepperoni\"],\n            created_at=datetime.now()\n        )\n\n    @staticmethod\n    def create_custom(name: str, ingredients: List[str]) -&gt; Pizza:\n        base_price = 10.0\n        price = base_price + (len(ingredients) * 1.50)\n\n        return Pizza(\n            id=PizzaFactory._generate_id(),\n            name=name,\n            price=price,\n            ingredients=ingredients,\n            created_at=datetime.now()\n        )\n\n    @staticmethod\n    def _generate_id() -&gt; str:\n        return str(uuid.uuid4())\n\n# Usage:\nfrom mario_pizzeria.factories import PizzaFactory\n\nmargherita = PizzaFactory.create_margherita()\ncustom_pizza = PizzaFactory.create_custom(\"Veggie Supreme\",\n                                         [\"tomato\", \"mozzarella\", \"mushrooms\", \"peppers\"])\n</code></pre>"},{"location":"references/python_modular_code/#plugin-architecture-with-modules","title":"Plugin Architecture with Modules","text":"<p>Create extensible systems using module discovery:</p> <pre><code># plugins/__init__.py\n\"\"\"Plugin system for Mario's Pizzeria.\"\"\"\n\nimport importlib\nimport pkgutil\nfrom typing import List, Type\nfrom abc import ABC, abstractmethod\n\nclass PizzaPlugin(ABC):\n    \"\"\"Base class for pizza plugins.\"\"\"\n\n    @abstractmethod\n    def get_name(self) -&gt; str:\n        pass\n\n    @abstractmethod\n    def create_pizza(self) -&gt; Pizza:\n        pass\n\ndef discover_plugins() -&gt; List[Type[PizzaPlugin]]:\n    \"\"\"Discover all available pizza plugins.\"\"\"\n    plugins = []\n\n    # Discover plugins in the plugins package\n    for finder, name, ispkg in pkgutil.iter_modules(__path__):\n        module = importlib.import_module(f'{__name__}.{name}')\n\n        # Find all plugin classes in the module\n        for attr_name in dir(module):\n            attr = getattr(module, attr_name)\n            if (isinstance(attr, type) and\n                issubclass(attr, PizzaPlugin) and\n                attr is not PizzaPlugin):\n                plugins.append(attr)\n\n    return plugins\n\n# plugins/italian_classics.py\nfrom . import PizzaPlugin\nfrom ..domain.entities.pizza import Pizza\n\nclass MargheritaPlugin(PizzaPlugin):\n    def get_name(self) -&gt; str:\n        return \"Margherita\"\n\n    def create_pizza(self) -&gt; Pizza:\n        return Pizza(\n            id=str(uuid.uuid4()),\n            name=\"Margherita\",\n            price=12.99,\n            ingredients=[\"tomato\", \"mozzarella\", \"basil\"]\n        )\n\nclass QuattroStagioniPlugin(PizzaPlugin):\n    def get_name(self) -&gt; str:\n        return \"Quattro Stagioni\"\n\n    def create_pizza(self) -&gt; Pizza:\n        return Pizza(\n            id=str(uuid.uuid4()),\n            name=\"Quattro Stagioni\",\n            price=16.99,\n            ingredients=[\"tomato\", \"mozzarella\", \"ham\", \"mushrooms\", \"artichokes\", \"olives\"]\n        )\n\n# plugins/american_style.py\nfrom . import PizzaPlugin\nfrom ..domain.entities.pizza import Pizza\n\nclass PepperoniPlugin(PizzaPlugin):\n    def get_name(self) -&gt; str:\n        return \"Pepperoni\"\n\n    def create_pizza(self) -&gt; Pizza:\n        return Pizza(\n            id=str(uuid.uuid4()),\n            name=\"Pepperoni\",\n            price=14.99,\n            ingredients=[\"tomato\", \"mozzarella\", \"pepperoni\"]\n        )\n\n# Usage:\nfrom mario_pizzeria.plugins import discover_plugins\n\n# Automatically discover all pizza plugins\navailable_plugins = discover_plugins()\nfor plugin_class in available_plugins:\n    plugin = plugin_class()\n    print(f\"Available: {plugin.get_name()}\")\n    pizza = plugin.create_pizza()\n</code></pre>"},{"location":"references/python_modular_code/#configuration-modules","title":"Configuration Modules","text":"<p>Organize configuration in modules:</p> <pre><code># config/__init__.py\nfrom .database import DatabaseConfig\nfrom .api import ApiConfig\nfrom .logging import LoggingConfig\n\n# config/database.py\nfrom dataclasses import dataclass\nfrom typing import Optional\n\n@dataclass\nclass DatabaseConfig:\n    \"\"\"Database configuration settings.\"\"\"\n    host: str = \"localhost\"\n    port: int = 27017\n    database: str = \"mario_pizzeria\"\n    username: Optional[str] = None\n    password: Optional[str] = None\n    connection_timeout: int = 30\n\n    @property\n    def connection_string(self) -&gt; str:\n        \"\"\"Generate MongoDB connection string.\"\"\"\n        if self.username and self.password:\n            return f\"mongodb://{self.username}:{self.password}@{self.host}:{self.port}/{self.database}\"\n        return f\"mongodb://{self.host}:{self.port}/{self.database}\"\n\n# config/api.py\n@dataclass\nclass ApiConfig:\n    \"\"\"API configuration settings.\"\"\"\n    host: str = \"0.0.0.0\"\n    port: int = 8000\n    debug: bool = False\n    cors_origins: List[str] = None\n    api_prefix: str = \"/api/v1\"\n\n    def __post_init__(self):\n        if self.cors_origins is None:\n            self.cors_origins = [\"http://localhost:3000\"]\n\n# config/logging.py\nimport logging\nfrom typing import Dict\n\n@dataclass\nclass LoggingConfig:\n    \"\"\"Logging configuration settings.\"\"\"\n    level: str = \"INFO\"\n    format: str = \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n    handlers: List[str] = None\n\n    def __post_init__(self):\n        if self.handlers is None:\n            self.handlers = [\"console\", \"file\"]\n\n    def get_level(self) -&gt; int:\n        \"\"\"Convert string level to logging constant.\"\"\"\n        return getattr(logging, self.level.upper(), logging.INFO)\n\n# Usage:\nfrom mario_pizzeria.config import DatabaseConfig, ApiConfig, LoggingConfig\n\ndb_config = DatabaseConfig(host=\"production-mongo\", database=\"pizzeria_prod\")\napi_config = ApiConfig(port=8080, debug=False)\nlog_config = LoggingConfig(level=\"WARNING\")\n\nprint(f\"Database: {db_config.connection_string}\")\nprint(f\"API will run on: {api_config.host}:{api_config.port}\")\nprint(f\"Log level: {log_config.get_level()}\")\n</code></pre>"},{"location":"references/python_modular_code/#testing-modular-code","title":"\ud83e\uddea Testing Modular Code","text":"<p>Organize tests to mirror your module structure:</p> <pre><code>tests/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 conftest.py              # Shared test fixtures\n\u251c\u2500\u2500 unit/                    # Unit tests\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 domain/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 test_pizza.py\n\u2502   \u2502   \u2514\u2500\u2500 test_customer.py\n\u2502   \u251c\u2500\u2500 application/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 test_pizza_service.py\n\u2502   \u2514\u2500\u2500 infrastructure/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 test_pizza_repository.py\n\u251c\u2500\u2500 integration/             # Integration tests\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 test_api_endpoints.py\n\u2502   \u2514\u2500\u2500 test_database_integration.py\n\u2514\u2500\u2500 fixtures/               # Test data\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 pizza_fixtures.py\n    \u2514\u2500\u2500 customer_fixtures.py\n</code></pre> <pre><code># tests/conftest.py - Shared fixtures\nimport pytest\nfrom mario_pizzeria.domain.entities.pizza import Pizza\nfrom mario_pizzeria.infrastructure.repositories.in_memory_pizza_repository import InMemoryPizzaRepository\n\n@pytest.fixture\ndef sample_pizza() -&gt; Pizza:\n    \"\"\"Create a sample pizza for testing.\"\"\"\n    return Pizza(\n        id=\"test-pizza-1\",\n        name=\"Test Margherita\",\n        price=12.99,\n        ingredients=[\"tomato\", \"mozzarella\", \"basil\"]\n    )\n\n@pytest.fixture\ndef pizza_repository() -&gt; InMemoryPizzaRepository:\n    \"\"\"Create an in-memory pizza repository for testing.\"\"\"\n    return InMemoryPizzaRepository()\n\n# tests/unit/domain/test_pizza.py\nimport pytest\nfrom mario_pizzeria.domain.entities.pizza import Pizza\n\nclass TestPizza:\n    def test_pizza_creation(self, sample_pizza):\n        \"\"\"Test pizza entity creation.\"\"\"\n        assert sample_pizza.name == \"Test Margherita\"\n        assert sample_pizza.price == 12.99\n        assert \"tomato\" in sample_pizza.ingredients\n\n    def test_add_ingredient(self, sample_pizza):\n        \"\"\"Test adding ingredient to pizza.\"\"\"\n        sample_pizza.add_ingredient(\"oregano\")\n        assert \"oregano\" in sample_pizza.ingredients\n\n    def test_calculate_cost(self, sample_pizza):\n        \"\"\"Test pizza cost calculation.\"\"\"\n        cost = sample_pizza.calculate_cost()\n        expected_cost = 8.0 + (3 * 0.50)  # base + (3 ingredients * 0.50)\n        assert cost == expected_cost\n\n# tests/fixtures/pizza_fixtures.py\nfrom typing import List\nfrom mario_pizzeria.domain.entities.pizza import Pizza\n\nclass PizzaFixtures:\n    \"\"\"Factory for creating test pizza data.\"\"\"\n\n    @staticmethod\n    def create_margherita() -&gt; Pizza:\n        return Pizza(\n            id=\"margherita-1\",\n            name=\"Margherita\",\n            price=12.99,\n            ingredients=[\"tomato\", \"mozzarella\", \"basil\"]\n        )\n\n    @staticmethod\n    def create_pizza_list() -&gt; List[Pizza]:\n        return [\n            PizzaFixtures.create_margherita(),\n            Pizza(\"pepperoni-1\", \"Pepperoni\", 14.99, [\"tomato\", \"mozzarella\", \"pepperoni\"]),\n            Pizza(\"hawaiian-1\", \"Hawaiian\", 13.49, [\"tomato\", \"mozzarella\", \"ham\", \"pineapple\"])\n        ]\n</code></pre>"},{"location":"references/python_modular_code/#best-practices-for-modular-code","title":"\ud83d\ude80 Best Practices for Modular Code","text":""},{"location":"references/python_modular_code/#1-use-meaningful-module-names","title":"1. Use Meaningful Module Names","text":"<pre><code># \u2705 Good - clear, descriptive names:\npizza_service.py\ncustomer_repository.py\norder_validation.py\npayment_processing.py\n\n# \u274c Bad - vague or abbreviated names:\nutil.py\nhelper.py\nstuff.py\nps.py (pizza service?)\n</code></pre>"},{"location":"references/python_modular_code/#2-keep-modules-focused-and-small","title":"2. Keep Modules Focused and Small","text":"<pre><code># \u2705 Good - focused pizza entity module (50-100 lines):\n# domain/entities/pizza.py\nfrom dataclasses import dataclass\nfrom typing import List\nfrom datetime import datetime\n\n@dataclass\nclass Pizza:\n    id: str\n    name: str\n    price: float\n    ingredients: List[str]\n    created_at: datetime\n    is_available: bool = True\n\n    def add_ingredient(self, ingredient: str) -&gt; None:\n        if ingredient not in self.ingredients:\n            self.ingredients.append(ingredient)\n\n    def remove_ingredient(self, ingredient: str) -&gt; None:\n        if ingredient in self.ingredients:\n            self.ingredients.remove(ingredient)\n\n    def calculate_cost(self) -&gt; float:\n        base_cost = 8.0\n        return base_cost + (len(self.ingredients) * 0.50)\n\n# \u274c Bad - trying to do everything in one module (1000+ lines)\n</code></pre>"},{"location":"references/python_modular_code/#3-use-dependency-injection-for-module-coupling","title":"3. Use Dependency Injection for Module Coupling","text":"<pre><code># \u2705 Good - dependency injection reduces coupling:\nclass PizzaService:\n    def __init__(self,\n                 repository: PizzaRepository,\n                 validator: PizzaValidator,\n                 notifier: NotificationService):\n        self._repository = repository\n        self._validator = validator\n        self._notifier = notifier\n\n    async def create_pizza(self, pizza_data: dict) -&gt; Pizza:\n        # Use injected dependencies\n        if not self._validator.is_valid(pizza_data):\n            raise ValidationError(\"Invalid pizza data\")\n\n        pizza = Pizza(**pizza_data)\n        await self._repository.save_async(pizza)\n        await self._notifier.notify_pizza_created(pizza)\n        return pizza\n\n# \u274c Bad - tight coupling with direct imports:\nclass PizzaService:\n    def __init__(self):\n        self._repository = MongoPizzaRepository()  # Tightly coupled\n        self._validator = PizzaValidator()         # Hard to test\n        self._notifier = EmailNotifier()          # Can't swap implementations\n</code></pre>"},{"location":"references/python_modular_code/#4-design-clear-module-interfaces","title":"4. Design Clear Module Interfaces","text":"<pre><code># \u2705 Good - clear, well-defined interface:\n# repositories/pizza_repository.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Optional\nfrom ..domain.entities.pizza import Pizza\n\nclass PizzaRepository(ABC):\n    \"\"\"Interface for pizza data access operations.\"\"\"\n\n    @abstractmethod\n    async def get_by_id_async(self, pizza_id: str) -&gt; Optional[Pizza]:\n        \"\"\"Get pizza by ID, returns None if not found.\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_by_name_async(self, name: str) -&gt; List[Pizza]:\n        \"\"\"Get all pizzas matching the given name.\"\"\"\n        pass\n\n    @abstractmethod\n    async def save_async(self, pizza: Pizza) -&gt; None:\n        \"\"\"Save pizza to storage.\"\"\"\n        pass\n\n    @abstractmethod\n    async def delete_async(self, pizza_id: str) -&gt; bool:\n        \"\"\"Delete pizza, returns True if deleted.\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_available_pizzas_async(self) -&gt; List[Pizza]:\n        \"\"\"Get all available pizzas.\"\"\"\n        pass\n\n# Concrete implementation:\nclass MongoPizzaRepository(PizzaRepository):\n    \"\"\"MongoDB implementation of pizza repository.\"\"\"\n\n    def __init__(self, collection):\n        self._collection = collection\n\n    async def get_by_id_async(self, pizza_id: str) -&gt; Optional[Pizza]:\n        # MongoDB-specific implementation\n        pass\n\n    # ... implement other methods\n</code></pre>"},{"location":"references/python_modular_code/#5-use-module-level-constants-and-configuration","title":"5. Use Module-Level Constants and Configuration","text":"<pre><code># constants/pizza_constants.py\n\"\"\"Constants for pizza-related operations.\"\"\"\n\n# Pizza sizes\nSMALL_SIZE = \"small\"\nMEDIUM_SIZE = \"medium\"\nLARGE_SIZE = \"large\"\n\nPIZZA_SIZES = [SMALL_SIZE, MEDIUM_SIZE, LARGE_SIZE]\n\n# Price multipliers by size\nSIZE_MULTIPLIERS = {\n    SMALL_SIZE: 0.8,\n    MEDIUM_SIZE: 1.0,\n    LARGE_SIZE: 1.3\n}\n\n# Ingredient categories\nCHEESE_INGREDIENTS = [\"mozzarella\", \"parmesan\", \"ricotta\", \"goat cheese\"]\nMEAT_INGREDIENTS = [\"pepperoni\", \"sausage\", \"ham\", \"bacon\", \"chicken\"]\nVEGETABLE_INGREDIENTS = [\"mushrooms\", \"peppers\", \"onions\", \"tomatoes\", \"spinach\"]\n\n# Business rules\nMAX_INGREDIENTS_PER_PIZZA = 8\nMIN_PIZZA_PRICE = 8.99\nMAX_PIZZA_PRICE = 29.99\n\n# Usage in other modules:\nfrom mario_pizzeria.constants.pizza_constants import (\n    PIZZA_SIZES,\n    SIZE_MULTIPLIERS,\n    MAX_INGREDIENTS_PER_PIZZA\n)\n\nclass PizzaValidator:\n    def validate_ingredients(self, ingredients: List[str]) -&gt; bool:\n        return len(ingredients) &lt;= MAX_INGREDIENTS_PER_PIZZA\n\n    def validate_size(self, size: str) -&gt; bool:\n        return size in PIZZA_SIZES\n</code></pre>"},{"location":"references/python_modular_code/#6-document-module-purposes-and-apis","title":"6. Document Module Purposes and APIs","text":"<pre><code># services/pizza_service.py\n\"\"\"\nPizza Service Module\n\nThis module provides business logic for pizza operations including creation,\nvalidation, pricing, and management. It serves as the main interface between\nthe API layer and the domain/data layers.\n\nClasses:\n    PizzaService: Main service class for pizza operations\n    PizzaValidator: Validation logic for pizza data\n    PricingCalculator: Pricing logic for pizzas\n\nDependencies:\n    - domain.entities.pizza: Pizza entity\n    - repositories.pizza_repository: Data access interface\n    - services.notification_service: Notification capabilities\n\nExample:\n    &gt;&gt;&gt; from mario_pizzeria.services import PizzaService\n    &gt;&gt;&gt; service = PizzaService(repository, validator, notifier)\n    &gt;&gt;&gt; pizza = await service.create_pizza({\n    ...     \"name\": \"Margherita\",\n    ...     \"ingredients\": [\"tomato\", \"mozzarella\", \"basil\"]\n    ... })\n\"\"\"\n\nfrom typing import List, Optional, Dict, Any\nfrom ..domain.entities.pizza import Pizza\nfrom ..repositories.pizza_repository import PizzaRepository\n\nclass PizzaService:\n    \"\"\"\n    Service class for pizza business operations.\n\n    This service handles pizza creation, validation, pricing calculations,\n    and coordinates with repositories and notification services.\n\n    Attributes:\n        _repository: Pizza data access repository\n        _validator: Pizza validation service\n        _notifier: Notification service for pizza events\n    \"\"\"\n\n    def __init__(self,\n                 repository: PizzaRepository,\n                 validator: 'PizzaValidator',\n                 notifier: 'NotificationService'):\n        \"\"\"\n        Initialize the pizza service.\n\n        Args:\n            repository: Repository for pizza data access\n            validator: Service for validating pizza data\n            notifier: Service for sending notifications\n        \"\"\"\n        self._repository = repository\n        self._validator = validator\n        self._notifier = notifier\n\n    async def create_pizza(self, pizza_data: Dict[str, Any]) -&gt; Pizza:\n        \"\"\"\n        Create a new pizza with validation and notification.\n\n        Args:\n            pizza_data: Dictionary containing pizza information with keys:\n                - name (str): Pizza name\n                - price (float): Pizza price\n                - ingredients (List[str]): List of ingredients\n\n        Returns:\n            Pizza: The created pizza entity\n\n        Raises:\n            ValidationError: If pizza data is invalid\n            RepositoryError: If save operation fails\n\n        Example:\n            &gt;&gt;&gt; pizza_data = {\n            ...     \"name\": \"Margherita\",\n            ...     \"price\": 12.99,\n            ...     \"ingredients\": [\"tomato\", \"mozzarella\", \"basil\"]\n            ... }\n            &gt;&gt;&gt; pizza = await service.create_pizza(pizza_data)\n        \"\"\"\n        # Implementation here...\n        pass\n</code></pre>"},{"location":"references/python_modular_code/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Python Object-Oriented Programming - Classes and inheritance in modular design</li> <li>Python Typing Guide - Type safety, generics, and modular programming patterns</li> <li>Dependency Injection - Managing dependencies between modules</li> <li>CQRS &amp; Mediation - Organizing commands and queries in modules</li> </ul>"},{"location":"references/python_modular_code/#further-reading","title":"\ud83d\udcda Further Reading","text":"<ul> <li>PEP 8 - Style Guide for Python Code</li> <li>Python Module Documentation</li> <li>Clean Architecture by Robert Martin</li> <li>Python Package Discovery</li> </ul>"},{"location":"references/python_object_oriented/","title":"\ud83c\udfdb\ufe0f Python Object-Oriented Programming Reference","text":"<p>Object-Oriented Programming (OOP) is fundamental to the Neuroglia framework's design. Understanding these concepts is essential for building maintainable, extensible applications.</p>"},{"location":"references/python_object_oriented/#what-is-object-oriented-programming","title":"\ud83c\udfaf What is Object-Oriented Programming?","text":"<p>OOP is a programming paradigm that organizes code around objects (data and methods that work on that data) rather than functions and logic. Think of it as creating blueprints (classes) for real-world entities.</p>"},{"location":"references/python_object_oriented/#the-pizza-restaurant-analogy","title":"The Pizza Restaurant Analogy","text":"<pre><code># Real world: A pizza restaurant has different roles and responsibilities\n\n# \u274c Procedural approach - everything is functions:\ndef make_pizza(name, ingredients, size):\n    pass\n\ndef take_order(customer_name, items):\n    pass\n\ndef calculate_bill(items, discounts):\n    pass\n\ndef manage_inventory(ingredient, quantity):\n    pass\n\n# \u2705 Object-oriented approach - organize by entities:\nclass Pizza:\n    \"\"\"A pizza entity with its own data and behaviors.\"\"\"\n    def __init__(self, name, ingredients, size):\n        self.name = name\n        self.ingredients = ingredients\n        self.size = size\n\n    def calculate_price(self):\n        # Pizza knows how to calculate its own price\n        pass\n\n    def add_ingredient(self, ingredient):\n        # Pizza knows how to modify itself\n        pass\n\nclass Chef:\n    \"\"\"A chef entity that knows how to make pizzas.\"\"\"\n    def make_pizza(self, pizza_order):\n        # Chef knows how to make pizzas\n        pass\n\nclass Waiter:\n    \"\"\"A waiter entity that handles customer interactions.\"\"\"\n    def take_order(self, customer, menu):\n        # Waiter knows how to interact with customers\n        pass\n\nclass CashRegister:\n    \"\"\"A cash register that handles billing.\"\"\"\n    def calculate_bill(self, order):\n        # Cash register knows how to calculate bills\n        pass\n</code></pre>"},{"location":"references/python_object_oriented/#core-oop-concepts","title":"\ud83d\udd27 Core OOP Concepts","text":""},{"location":"references/python_object_oriented/#1-classes-and-objects","title":"1. Classes and Objects","text":"<p>A class is a blueprint, an object is an instance of that blueprint:</p> <pre><code>from typing import List\nfrom datetime import datetime\nfrom dataclasses import dataclass\n\n# Class definition - the blueprint\n@dataclass\nclass Pizza:\n    \"\"\"Blueprint for creating pizza objects.\"\"\"\n    name: str\n    price: float\n    ingredients: List[str]\n    size: str = \"medium\"\n    created_at: datetime = None\n\n    def __post_init__(self):\n        \"\"\"Called after object creation.\"\"\"\n        if self.created_at is None:\n            self.created_at = datetime.now()\n\n    # Methods - what pizzas can do\n    def add_ingredient(self, ingredient: str) -&gt; None:\n        \"\"\"Add an ingredient to this pizza.\"\"\"\n        if ingredient not in self.ingredients:\n            self.ingredients.append(ingredient)\n\n    def remove_ingredient(self, ingredient: str) -&gt; None:\n        \"\"\"Remove an ingredient from this pizza.\"\"\"\n        if ingredient in self.ingredients:\n            self.ingredients.remove(ingredient)\n\n    def calculate_cost(self) -&gt; float:\n        \"\"\"Calculate the cost to make this pizza.\"\"\"\n        base_cost = {\"small\": 6.0, \"medium\": 8.0, \"large\": 10.0}\n        ingredient_cost = len(self.ingredients) * 0.75\n        return base_cost[self.size] + ingredient_cost\n\n    def __str__(self) -&gt; str:\n        \"\"\"String representation of the pizza.\"\"\"\n        return f\"{self.size.title()} {self.name} - ${self.price:.2f}\"\n\n# Creating objects - instances of the class\nmargherita = Pizza(\n    name=\"Margherita\",\n    price=12.99,\n    ingredients=[\"tomato sauce\", \"mozzarella\", \"basil\"]\n)\n\npepperoni = Pizza(\n    name=\"Pepperoni\",\n    price=14.99,\n    ingredients=[\"tomato sauce\", \"mozzarella\", \"pepperoni\"],\n    size=\"large\"\n)\n\n# Objects have their own data and can perform actions\nmargherita.add_ingredient(\"extra cheese\")\nprint(f\"Margherita cost to make: ${margherita.calculate_cost():.2f}\")\nprint(f\"Pepperoni: {pepperoni}\")\n\n# Each object is independent\nprint(f\"Margherita ingredients: {margherita.ingredients}\")\nprint(f\"Pepperoni ingredients: {pepperoni.ingredients}\")\n</code></pre>"},{"location":"references/python_object_oriented/#2-encapsulation-data-hiding","title":"2. Encapsulation - Data Hiding","text":"<p>Encapsulation bundles data and methods together and controls access to them:</p> <pre><code>from typing import Optional\n\nclass Customer:\n    \"\"\"Customer entity with controlled access to data.\"\"\"\n\n    def __init__(self, name: str, email: str):\n        self._name = name           # Protected attribute (internal use)\n        self._email = email         # Protected attribute\n        self.__loyalty_points = 0   # Private attribute (name mangling)\n        self._orders = []           # Protected attribute\n\n    # Public interface - how external code interacts with Customer\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Get customer name (read-only).\"\"\"\n        return self._name\n\n    @property\n    def email(self) -&gt; str:\n        \"\"\"Get customer email.\"\"\"\n        return self._email\n\n    @email.setter\n    def email(self, new_email: str) -&gt; None:\n        \"\"\"Set customer email with validation.\"\"\"\n        if \"@\" not in new_email or \".\" not in new_email:\n            raise ValueError(\"Invalid email format\")\n        self._email = new_email\n\n    @property\n    def loyalty_points(self) -&gt; int:\n        \"\"\"Get loyalty points (read-only from outside).\"\"\"\n        return self.__loyalty_points\n\n    def add_loyalty_points(self, points: int) -&gt; None:\n        \"\"\"Add loyalty points (controlled method).\"\"\"\n        if points &gt; 0:\n            self.__loyalty_points += points\n\n    def redeem_points(self, points: int) -&gt; bool:\n        \"\"\"Redeem loyalty points.\"\"\"\n        if points &gt; 0 and points &lt;= self.__loyalty_points:\n            self.__loyalty_points -= points\n            return True\n        return False\n\n    def place_order(self, order: 'Order') -&gt; None:\n        \"\"\"Place an order and earn points.\"\"\"\n        self._orders.append(order)\n        # Earn 1 point per dollar spent\n        points_earned = int(order.total_amount())\n        self.add_loyalty_points(points_earned)\n\n    def get_order_history(self) -&gt; List['Order']:\n        \"\"\"Get copy of order history (don't expose internal list).\"\"\"\n        return self._orders.copy()\n\n# Usage demonstrates encapsulation:\ncustomer = Customer(\"Mario\", \"mario@email.com\")\n\n# \u2705 Public interface works correctly:\nprint(f\"Customer: {customer.name}\")\nprint(f\"Points: {customer.loyalty_points}\")\n\ncustomer.add_loyalty_points(100)\nprint(f\"Points after addition: {customer.loyalty_points}\")\n\n# \u2705 Validation works:\ntry:\n    customer.email = \"invalid-email\"\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n\n# \u274c Direct access to private data is discouraged:\n# customer.__loyalty_points = 1000  # This won't work as expected\n# customer._orders.clear()          # Breaks encapsulation, but possible\n</code></pre>"},{"location":"references/python_object_oriented/#3-inheritance-extending-behavior","title":"3. Inheritance - Extending Behavior","text":"<p>Inheritance allows classes to inherit properties and methods from parent classes:</p> <pre><code>from abc import ABC, abstractmethod\nfrom typing import List, Dict\nfrom enum import Enum\n\nclass MenuItemType(Enum):\n    PIZZA = \"pizza\"\n    DRINK = \"drink\"\n    DESSERT = \"dessert\"\n    APPETIZER = \"appetizer\"\n\n# Base class - common behavior for all menu items\nclass MenuItem(ABC):\n    \"\"\"Abstract base class for all menu items.\"\"\"\n\n    def __init__(self, name: str, price: float, description: str):\n        self.name = name\n        self.price = price\n        self.description = description\n        self.is_available = True\n\n    @abstractmethod\n    def get_type(self) -&gt; MenuItemType:\n        \"\"\"Each menu item must specify its type.\"\"\"\n        pass\n\n    @abstractmethod\n    def calculate_preparation_time(self) -&gt; int:\n        \"\"\"Each menu item must specify preparation time in minutes.\"\"\"\n        pass\n\n    def apply_discount(self, percentage: float) -&gt; float:\n        \"\"\"Common discount calculation.\"\"\"\n        if 0 &lt;= percentage &lt;= 100:\n            return self.price * (1 - percentage / 100)\n        return self.price\n\n    def __str__(self) -&gt; str:\n        status = \"Available\" if self.is_available else \"Unavailable\"\n        return f\"{self.name} - ${self.price:.2f} ({status})\"\n\n# Derived classes - specialized menu items\nclass Pizza(MenuItem):\n    \"\"\"Pizza menu item with pizza-specific behavior.\"\"\"\n\n    def __init__(self, name: str, price: float, description: str,\n                 ingredients: List[str], size: str = \"medium\"):\n        super().__init__(name, price, description)  # Call parent constructor\n        self.ingredients = ingredients\n        self.size = size\n        self.crust_type = \"regular\"\n\n    def get_type(self) -&gt; MenuItemType:\n        \"\"\"Pizzas are PIZZA type.\"\"\"\n        return MenuItemType.PIZZA\n\n    def calculate_preparation_time(self) -&gt; int:\n        \"\"\"Pizza prep time depends on size and toppings.\"\"\"\n        base_time = {\"small\": 12, \"medium\": 15, \"large\": 18}\n        topping_time = len(self.ingredients) * 2\n        return base_time.get(self.size, 15) + topping_time\n\n    # Pizza-specific methods\n    def add_ingredient(self, ingredient: str) -&gt; None:\n        \"\"\"Add ingredient to pizza.\"\"\"\n        if ingredient not in self.ingredients:\n            self.ingredients.append(ingredient)\n            self.price += 1.50  # Extra topping cost\n\n    def set_crust_type(self, crust: str) -&gt; None:\n        \"\"\"Change crust type.\"\"\"\n        crust_options = [\"thin\", \"regular\", \"thick\", \"gluten-free\"]\n        if crust in crust_options:\n            self.crust_type = crust\n            if crust == \"gluten-free\":\n                self.price += 2.00\n\nclass Drink(MenuItem):\n    \"\"\"Drink menu item.\"\"\"\n\n    def __init__(self, name: str, price: float, description: str,\n                 size: str = \"medium\", is_alcoholic: bool = False):\n        super().__init__(name, price, description)\n        self.size = size\n        self.is_alcoholic = is_alcoholic\n        self.temperature = \"cold\"\n\n    def get_type(self) -&gt; MenuItemType:\n        return MenuItemType.DRINK\n\n    def calculate_preparation_time(self) -&gt; int:\n        \"\"\"Drinks are quick to prepare.\"\"\"\n        return 2 if not self.is_alcoholic else 5\n\n    def set_temperature(self, temp: str) -&gt; None:\n        \"\"\"Set drink temperature.\"\"\"\n        if temp in [\"hot\", \"cold\", \"room temperature\"]:\n            self.temperature = temp\n\nclass Dessert(MenuItem):\n    \"\"\"Dessert menu item.\"\"\"\n\n    def __init__(self, name: str, price: float, description: str,\n                 serving_size: str = \"individual\"):\n        super().__init__(name, price, description)\n        self.serving_size = serving_size\n        self.is_homemade = True\n\n    def get_type(self) -&gt; MenuItemType:\n        return MenuItemType.DESSERT\n\n    def calculate_preparation_time(self) -&gt; int:\n        \"\"\"Dessert prep time varies by type.\"\"\"\n        if \"cake\" in self.name.lower():\n            return 10\n        elif \"ice cream\" in self.name.lower():\n            return 3\n        return 5\n\n# Polymorphism - treating different types the same way\ndef create_sample_menu() -&gt; List[MenuItem]:\n    \"\"\"Create a sample menu with different item types.\"\"\"\n    return [\n        Pizza(\"Margherita\", 12.99, \"Classic tomato and mozzarella\",\n              [\"tomato sauce\", \"mozzarella\", \"basil\"]),\n        Pizza(\"Pepperoni\", 14.99, \"Pepperoni with mozzarella\",\n              [\"tomato sauce\", \"mozzarella\", \"pepperoni\"], size=\"large\"),\n        Drink(\"Coca Cola\", 2.99, \"Classic soft drink\", size=\"large\"),\n        Drink(\"House Wine\", 8.99, \"Italian red wine\", is_alcoholic=True),\n        Dessert(\"Tiramisu\", 6.99, \"Classic Italian dessert\"),\n        Dessert(\"Gelato\", 4.99, \"Italian ice cream\")\n    ]\n\n# Usage - polymorphism in action\nmenu = create_sample_menu()\n\nprint(\"=== Mario's Menu ===\")\ntotal_prep_time = 0\n\nfor item in menu:  # Each item behaves according to its specific type\n    print(f\"{item}\")\n    print(f\"  Type: {item.get_type().value}\")\n    print(f\"  Prep time: {item.calculate_preparation_time()} minutes\")\n    print(f\"  With 10% discount: ${item.apply_discount(10):.2f}\")\n    print()\n\n    total_prep_time += item.calculate_preparation_time()\n\nprint(f\"Total preparation time for all items: {total_prep_time} minutes\")\n</code></pre>"},{"location":"references/python_object_oriented/#4-composition-has-a-relationships","title":"4. Composition - \"Has-A\" Relationships","text":"<p>Composition builds objects by combining other objects:</p> <pre><code>from typing import List, Optional, Dict\nfrom datetime import datetime, timedelta\nfrom enum import Enum\n\nclass OrderStatus(Enum):\n    PENDING = \"pending\"\n    PREPARING = \"preparing\"\n    READY = \"ready\"\n    DELIVERED = \"delivered\"\n    CANCELLED = \"cancelled\"\n\nclass OrderItem:\n    \"\"\"Represents one item in an order.\"\"\"\n\n    def __init__(self, menu_item: MenuItem, quantity: int = 1,\n                 special_instructions: str = \"\"):\n        self.menu_item = menu_item\n        self.quantity = quantity\n        self.special_instructions = special_instructions\n        self.unit_price = menu_item.price\n        self.created_at = datetime.now()\n\n    def get_total_price(self) -&gt; float:\n        \"\"\"Calculate total price for this item.\"\"\"\n        return self.unit_price * self.quantity\n\n    def get_preparation_time(self) -&gt; int:\n        \"\"\"Calculate total preparation time.\"\"\"\n        return self.menu_item.calculate_preparation_time() * self.quantity\n\n    def __str__(self) -&gt; str:\n        special = f\" ({self.special_instructions})\" if self.special_instructions else \"\"\n        return f\"{self.quantity}x {self.menu_item.name}{special} - ${self.get_total_price():.2f}\"\n\nclass Order:\n    \"\"\"Order composed of multiple order items, customer, and status.\"\"\"\n\n    def __init__(self, customer: Customer, order_id: str = None):\n        self.customer = customer              # Composition: Order HAS-A Customer\n        self.order_id = order_id or self._generate_id()\n        self.items: List[OrderItem] = []      # Composition: Order HAS-MANY OrderItems\n        self.status = OrderStatus.PENDING\n        self.created_at = datetime.now()\n        self.estimated_ready_time: Optional[datetime] = None\n        self.discount_percentage = 0.0\n        self.tax_rate = 0.08  # 8% tax\n\n    def add_item(self, menu_item: MenuItem, quantity: int = 1,\n                 special_instructions: str = \"\") -&gt; None:\n        \"\"\"Add an item to the order.\"\"\"\n        order_item = OrderItem(menu_item, quantity, special_instructions)\n        self.items.append(order_item)\n        self._update_estimated_time()\n\n    def remove_item(self, item_index: int) -&gt; bool:\n        \"\"\"Remove an item from the order.\"\"\"\n        if 0 &lt;= item_index &lt; len(self.items):\n            del self.items[item_index]\n            self._update_estimated_time()\n            return True\n        return False\n\n    def apply_discount(self, percentage: float) -&gt; None:\n        \"\"\"Apply discount to the entire order.\"\"\"\n        if 0 &lt;= percentage &lt;= 50:  # Max 50% discount\n            self.discount_percentage = percentage\n\n    def calculate_subtotal(self) -&gt; float:\n        \"\"\"Calculate order subtotal.\"\"\"\n        return sum(item.get_total_price() for item in self.items)\n\n    def calculate_discount_amount(self) -&gt; float:\n        \"\"\"Calculate discount amount.\"\"\"\n        return self.calculate_subtotal() * (self.discount_percentage / 100)\n\n    def calculate_tax_amount(self) -&gt; float:\n        \"\"\"Calculate tax amount.\"\"\"\n        subtotal_after_discount = self.calculate_subtotal() - self.calculate_discount_amount()\n        return subtotal_after_discount * self.tax_rate\n\n    def calculate_total(self) -&gt; float:\n        \"\"\"Calculate final total.\"\"\"\n        subtotal = self.calculate_subtotal()\n        discount = self.calculate_discount_amount()\n        tax = self.calculate_tax_amount()\n        return subtotal - discount + tax\n\n    def update_status(self, new_status: OrderStatus) -&gt; None:\n        \"\"\"Update order status.\"\"\"\n        self.status = new_status\n        if new_status == OrderStatus.PREPARING:\n            self._update_estimated_time()\n\n    def _generate_id(self) -&gt; str:\n        \"\"\"Generate unique order ID.\"\"\"\n        import uuid\n        return f\"ORD-{str(uuid.uuid4())[:8].upper()}\"\n\n    def _update_estimated_time(self) -&gt; None:\n        \"\"\"Calculate estimated ready time based on items.\"\"\"\n        if not self.items:\n            self.estimated_ready_time = None\n            return\n\n        total_prep_time = sum(item.get_preparation_time() for item in self.items)\n        # Add buffer time for coordination\n        total_prep_time += 5\n        self.estimated_ready_time = datetime.now() + timedelta(minutes=total_prep_time)\n\n    def get_receipt(self) -&gt; str:\n        \"\"\"Generate order receipt.\"\"\"\n        lines = [\n            f\"=== Mario's Pizzeria Receipt ===\",\n            f\"Order ID: {self.order_id}\",\n            f\"Customer: {self.customer.name}\",\n            f\"Date: {self.created_at.strftime('%Y-%m-%d %H:%M')}\",\n            f\"Status: {self.status.value.title()}\",\n            \"\",\n            \"Items:\"\n        ]\n\n        for i, item in enumerate(self.items, 1):\n            lines.append(f\"  {i}. {item}\")\n\n        lines.extend([\n            \"\",\n            f\"Subtotal: ${self.calculate_subtotal():.2f}\",\n            f\"Discount ({self.discount_percentage}%): -${self.calculate_discount_amount():.2f}\",\n            f\"Tax: ${self.calculate_tax_amount():.2f}\",\n            f\"TOTAL: ${self.calculate_total():.2f}\"\n        ])\n\n        if self.estimated_ready_time:\n            lines.append(f\"Estimated ready: {self.estimated_ready_time.strftime('%H:%M')}\")\n\n        return \"\\n\".join(lines)\n\n# Kitchen class that manages orders\nclass Kitchen:\n    \"\"\"Kitchen that processes orders - composed of orders and equipment.\"\"\"\n\n    def __init__(self, max_concurrent_orders: int = 10):\n        self.active_orders: List[Order] = []    # Composition: Kitchen HAS-MANY Orders\n        self.completed_orders: List[Order] = []\n        self.max_concurrent_orders = max_concurrent_orders\n        self.equipment = {                      # Composition: Kitchen HAS equipment\n            \"ovens\": 3,\n            \"prep_stations\": 5,\n            \"fryers\": 2\n        }\n\n    def accept_order(self, order: Order) -&gt; bool:\n        \"\"\"Accept an order if kitchen has capacity.\"\"\"\n        if len(self.active_orders) &lt; self.max_concurrent_orders:\n            order.update_status(OrderStatus.PREPARING)\n            self.active_orders.append(order)\n            return True\n        return False\n\n    def complete_order(self, order_id: str) -&gt; Optional[Order]:\n        \"\"\"Mark an order as complete.\"\"\"\n        for i, order in enumerate(self.active_orders):\n            if order.order_id == order_id:\n                order.update_status(OrderStatus.READY)\n                completed_order = self.active_orders.pop(i)\n                self.completed_orders.append(completed_order)\n                return completed_order\n        return None\n\n    def get_queue_status(self) -&gt; Dict[str, any]:\n        \"\"\"Get kitchen queue status.\"\"\"\n        return {\n            \"active_orders\": len(self.active_orders),\n            \"max_capacity\": self.max_concurrent_orders,\n            \"queue_full\": len(self.active_orders) &gt;= self.max_concurrent_orders,\n            \"estimated_wait_minutes\": len(self.active_orders) * 3  # Rough estimate\n        }\n\n# Usage example showing composition:\ndef demonstrate_composition():\n    \"\"\"Show how objects work together through composition.\"\"\"\n\n    # Create components\n    customer = Customer(\"Luigi\", \"luigi@email.com\")\n    kitchen = Kitchen(max_concurrent_orders=5)\n\n    # Create menu items\n    margherita = Pizza(\"Margherita\", 12.99, \"Classic pizza\",\n                      [\"tomato\", \"mozzarella\", \"basil\"])\n    coke = Drink(\"Coke\", 2.99, \"Soft drink\")\n    tiramisu = Dessert(\"Tiramisu\", 6.99, \"Italian dessert\")\n\n    # Create order (composition in action)\n    order = Order(customer)  # Order contains Customer\n    order.add_item(margherita, quantity=2, special_instructions=\"Extra cheese\")\n    order.add_item(coke, quantity=2)\n    order.add_item(tiramisu, quantity=1)\n\n    # Apply discount for loyalty customer\n    if customer.loyalty_points &gt; 50:\n        order.apply_discount(10)\n\n    print(order.get_receipt())\n    print()\n\n    # Kitchen processes the order\n    if kitchen.accept_order(order):\n        print(f\"\u2705 Order {order.order_id} accepted by kitchen\")\n        print(f\"Kitchen status: {kitchen.get_queue_status()}\")\n\n        # Simulate completing the order\n        completed_order = kitchen.complete_order(order.order_id)\n        if completed_order:\n            print(f\"\u2705 Order {completed_order.order_id} is ready!\")\n            customer.place_order(completed_order)  # Customer gets loyalty points\n            print(f\"Customer {customer.name} now has {customer.loyalty_points} loyalty points\")\n    else:\n        print(f\"\u274c Kitchen is full, cannot accept order {order.order_id}\")\n\n# Run the demonstration\ndemonstrate_composition()\n</code></pre>"},{"location":"references/python_object_oriented/#oop-in-neuroglia-framework","title":"\ud83c\udfd7\ufe0f OOP in Neuroglia Framework","text":""},{"location":"references/python_object_oriented/#entity-base-classes","title":"Entity Base Classes","text":"<p>The framework uses OOP extensively for domain entities:</p> <pre><code>from abc import ABC, abstractmethod\nfrom typing import List, Any, Dict\nfrom datetime import datetime\nimport uuid\n\nclass Entity(ABC):\n    \"\"\"Base class for all domain entities.\"\"\"\n\n    def __init__(self, id: str = None):\n        self.id = id or str(uuid.uuid4())\n        self.created_at = datetime.now()\n        self.updated_at = datetime.now()\n        self._domain_events: List['DomainEvent'] = []\n\n    def raise_event(self, event: 'DomainEvent') -&gt; None:\n        \"\"\"Raise a domain event.\"\"\"\n        self._domain_events.append(event)\n\n    def get_uncommitted_events(self) -&gt; List['DomainEvent']:\n        \"\"\"Get events that haven't been processed yet.\"\"\"\n        return self._domain_events.copy()\n\n    def mark_events_as_committed(self) -&gt; None:\n        \"\"\"Mark all events as processed.\"\"\"\n        self._domain_events.clear()\n\n    def update_timestamp(self) -&gt; None:\n        \"\"\"Update the entity's last modified timestamp.\"\"\"\n        self.updated_at = datetime.now()\n\n    def __eq__(self, other) -&gt; bool:\n        \"\"\"Two entities are equal if they have the same ID and type.\"\"\"\n        return isinstance(other, self.__class__) and self.id == other.id\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Hash based on entity ID.\"\"\"\n        return hash(self.id)\n\n# Domain entities inherit from Entity\nclass Pizza(Entity):\n    \"\"\"Pizza domain entity with business logic.\"\"\"\n\n    def __init__(self, name: str, price: float, ingredients: List[str], id: str = None):\n        super().__init__(id)\n        self.name = name\n        self.price = price\n        self.ingredients = ingredients.copy()\n        self.is_available = True\n\n        # Raise domain event\n        self.raise_event(PizzaCreatedEvent(self.id, self.name))\n\n    def add_ingredient(self, ingredient: str) -&gt; None:\n        \"\"\"Add ingredient with business rules.\"\"\"\n        if len(self.ingredients) &gt;= 10:\n            raise ValueError(\"Pizza cannot have more than 10 ingredients\")\n\n        if ingredient not in self.ingredients:\n            self.ingredients.append(ingredient)\n            self.price += 1.50  # Business rule: each extra ingredient costs $1.50\n            self.update_timestamp()\n            self.raise_event(PizzaIngredientAddedEvent(self.id, ingredient))\n\n    def change_price(self, new_price: float) -&gt; None:\n        \"\"\"Change price with validation.\"\"\"\n        if new_price &lt; 5.0:\n            raise ValueError(\"Pizza price cannot be less than $5.00\")\n\n        old_price = self.price\n        self.price = new_price\n        self.update_timestamp()\n        self.raise_event(PizzaPriceChangedEvent(self.id, old_price, new_price))\n\n    def discontinue(self) -&gt; None:\n        \"\"\"Discontinue the pizza.\"\"\"\n        self.is_available = False\n        self.update_timestamp()\n        self.raise_event(PizzaDiscontinuedEvent(self.id, self.name))\n\nclass Customer(Entity):\n    \"\"\"Customer domain entity.\"\"\"\n\n    def __init__(self, name: str, email: str, id: str = None):\n        super().__init__(id)\n        self.name = name\n        self.email = email\n        self.loyalty_points = 0\n        self.total_orders = 0\n\n        self.raise_event(CustomerRegisteredEvent(self.id, self.name, self.email))\n\n    def place_order(self, order_total: float) -&gt; None:\n        \"\"\"Process an order and update customer state.\"\"\"\n        self.total_orders += 1\n        points_earned = int(order_total)  # 1 point per dollar\n        self.loyalty_points += points_earned\n        self.update_timestamp()\n\n        self.raise_event(OrderPlacedEvent(self.id, order_total, points_earned))\n\n        # Check for loyalty tier changes\n        if self.total_orders == 5:\n            self.raise_event(CustomerPromotedEvent(self.id, \"Bronze\"))\n        elif self.total_orders == 15:\n            self.raise_event(CustomerPromotedEvent(self.id, \"Silver\"))\n        elif self.total_orders == 30:\n            self.raise_event(CustomerPromotedEvent(self.id, \"Gold\"))\n</code></pre>"},{"location":"references/python_object_oriented/#repository-pattern-with-inheritance","title":"Repository Pattern with Inheritance","text":"<pre><code>from abc import ABC, abstractmethod\nfrom typing import Generic, TypeVar, Optional, List\n\nTEntity = TypeVar('TEntity', bound=Entity)\nTId = TypeVar('TId')\n\nclass Repository(Generic[TEntity, TId], ABC):\n    \"\"\"Abstract repository pattern.\"\"\"\n\n    @abstractmethod\n    async def get_by_id_async(self, id: TId) -&gt; Optional[TEntity]:\n        \"\"\"Get entity by ID.\"\"\"\n        pass\n\n    @abstractmethod\n    async def save_async(self, entity: TEntity) -&gt; None:\n        \"\"\"Save entity.\"\"\"\n        pass\n\n    @abstractmethod\n    async def delete_async(self, id: TId) -&gt; bool:\n        \"\"\"Delete entity.\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_all_async(self) -&gt; List[TEntity]:\n        \"\"\"Get all entities.\"\"\"\n        pass\n\n# Concrete repository implementations\nclass InMemoryRepository(Repository[TEntity, str]):\n    \"\"\"In-memory repository implementation.\"\"\"\n\n    def __init__(self):\n        self._entities: Dict[str, TEntity] = {}\n\n    async def get_by_id_async(self, id: str) -&gt; Optional[TEntity]:\n        return self._entities.get(id)\n\n    async def save_async(self, entity: TEntity) -&gt; None:\n        self._entities[entity.id] = entity\n        # Publish domain events\n        await self._publish_events(entity)\n\n    async def delete_async(self, id: str) -&gt; bool:\n        if id in self._entities:\n            del self._entities[id]\n            return True\n        return False\n\n    async def get_all_async(self) -&gt; List[TEntity]:\n        return list(self._entities.values())\n\n    async def _publish_events(self, entity: TEntity) -&gt; None:\n        \"\"\"Publish domain events from entity.\"\"\"\n        events = entity.get_uncommitted_events()\n        for event in events:\n            # Publish to event bus\n            await self._event_bus.publish_async(event)\n        entity.mark_events_as_committed()\n\nclass PizzaRepository(InMemoryRepository[Pizza]):\n    \"\"\"Specialized pizza repository.\"\"\"\n\n    async def get_available_pizzas_async(self) -&gt; List[Pizza]:\n        \"\"\"Get only available pizzas.\"\"\"\n        all_pizzas = await self.get_all_async()\n        return [pizza for pizza in all_pizzas if pizza.is_available]\n\n    async def get_pizzas_by_ingredient_async(self, ingredient: str) -&gt; List[Pizza]:\n        \"\"\"Find pizzas containing a specific ingredient.\"\"\"\n        all_pizzas = await self.get_all_async()\n        return [pizza for pizza in all_pizzas\n                if ingredient in pizza.ingredients and pizza.is_available]\n\n    async def get_pizzas_in_price_range_async(self, min_price: float, max_price: float) -&gt; List[Pizza]:\n        \"\"\"Find pizzas within a price range.\"\"\"\n        all_pizzas = await self.get_all_async()\n        return [pizza for pizza in all_pizzas\n                if min_price &lt;= pizza.price &lt;= max_price and pizza.is_available]\n</code></pre>"},{"location":"references/python_object_oriented/#command-and-query-handlers-with-inheritance","title":"Command and Query Handlers with Inheritance","text":"<pre><code>from abc import ABC, abstractmethod\nfrom typing import Generic, TypeVar\n\nTCommand = TypeVar('TCommand')\nTQuery = TypeVar('TQuery')\nTResult = TypeVar('TResult')\n\nclass CommandHandler(Generic[TCommand, TResult], ABC):\n    \"\"\"Base class for command handlers.\"\"\"\n\n    @abstractmethod\n    async def handle_async(self, command: TCommand) -&gt; TResult:\n        \"\"\"Handle the command.\"\"\"\n        pass\n\nclass QueryHandler(Generic[TQuery, TResult], ABC):\n    \"\"\"Base class for query handlers.\"\"\"\n\n    @abstractmethod\n    async def handle_async(self, query: TQuery) -&gt; TResult:\n        \"\"\"Handle the query.\"\"\"\n        pass\n\n# Specific handlers inherit from base classes\nclass CreatePizzaHandler(CommandHandler[CreatePizzaCommand, Pizza]):\n    \"\"\"Handler for creating pizzas.\"\"\"\n\n    def __init__(self, repository: PizzaRepository, validator: 'PizzaValidator'):\n        self._repository = repository\n        self._validator = validator\n\n    async def handle_async(self, command: CreatePizzaCommand) -&gt; Pizza:\n        \"\"\"Create and save a new pizza.\"\"\"\n        # Validation\n        validation_result = await self._validator.validate_async(command)\n        if not validation_result.is_valid:\n            raise ValidationError(validation_result.errors)\n\n        # Create pizza entity\n        pizza = Pizza(\n            name=command.name,\n            price=command.price,\n            ingredients=command.ingredients\n        )\n\n        # Save to repository\n        await self._repository.save_async(pizza)\n\n        return pizza\n\nclass GetAvailablePizzasHandler(QueryHandler[GetAvailablePizzasQuery, List[Pizza]]):\n    \"\"\"Handler for getting available pizzas.\"\"\"\n\n    def __init__(self, repository: PizzaRepository):\n        self._repository = repository\n\n    async def handle_async(self, query: GetAvailablePizzasQuery) -&gt; List[Pizza]:\n        \"\"\"Get all available pizzas.\"\"\"\n        return await self._repository.get_available_pizzas_async()\n\nclass GetPizzasByIngredientHandler(QueryHandler[GetPizzasByIngredientQuery, List[Pizza]]):\n    \"\"\"Handler for finding pizzas by ingredient.\"\"\"\n\n    def __init__(self, repository: PizzaRepository):\n        self._repository = repository\n\n    async def handle_async(self, query: GetPizzasByIngredientQuery) -&gt; List[Pizza]:\n        \"\"\"Find pizzas containing the specified ingredient.\"\"\"\n        return await self._repository.get_pizzas_by_ingredient_async(query.ingredient)\n</code></pre>"},{"location":"references/python_object_oriented/#advanced-oop-patterns","title":"\ud83c\udfa8 Advanced OOP Patterns","text":""},{"location":"references/python_object_oriented/#abstract-factory-pattern","title":"Abstract Factory Pattern","text":"<pre><code>from abc import ABC, abstractmethod\nfrom enum import Enum\n\nclass PizzaStyle(Enum):\n    ITALIAN = \"italian\"\n    AMERICAN = \"american\"\n    CHICAGO = \"chicago\"\n\nclass PizzaFactory(ABC):\n    \"\"\"Abstract factory for creating different styles of pizzas.\"\"\"\n\n    @abstractmethod\n    def create_margherita(self) -&gt; Pizza:\n        pass\n\n    @abstractmethod\n    def create_pepperoni(self) -&gt; Pizza:\n        pass\n\n    @abstractmethod\n    def create_supreme(self) -&gt; Pizza:\n        pass\n\nclass ItalianPizzaFactory(PizzaFactory):\n    \"\"\"Factory for authentic Italian-style pizzas.\"\"\"\n\n    def create_margherita(self) -&gt; Pizza:\n        return Pizza(\n            name=\"Margherita Italiana\",\n            price=15.99,\n            ingredients=[\"San Marzano tomatoes\", \"Buffalo mozzarella\", \"Fresh basil\", \"Extra virgin olive oil\"]\n        )\n\n    def create_pepperoni(self) -&gt; Pizza:\n        return Pizza(\n            name=\"Diavola\",\n            price=17.99,\n            ingredients=[\"San Marzano tomatoes\", \"Mozzarella di bufala\", \"Spicy salami\", \"Chili flakes\"]\n        )\n\n    def create_supreme(self) -&gt; Pizza:\n        return Pizza(\n            name=\"Quattro Stagioni\",\n            price=19.99,\n            ingredients=[\"Tomato sauce\", \"Mozzarella\", \"Prosciutto\", \"Mushrooms\", \"Artichokes\", \"Olives\"]\n        )\n\nclass AmericanPizzaFactory(PizzaFactory):\n    \"\"\"Factory for American-style pizzas.\"\"\"\n\n    def create_margherita(self) -&gt; Pizza:\n        return Pizza(\n            name=\"Classic Margherita\",\n            price=12.99,\n            ingredients=[\"Tomato sauce\", \"Mozzarella cheese\", \"Dried basil\"]\n        )\n\n    def create_pepperoni(self) -&gt; Pizza:\n        return Pizza(\n            name=\"Pepperoni Classic\",\n            price=14.99,\n            ingredients=[\"Tomato sauce\", \"Mozzarella cheese\", \"Pepperoni\"]\n        )\n\n    def create_supreme(self) -&gt; Pizza:\n        return Pizza(\n            name=\"Supreme Deluxe\",\n            price=18.99,\n            ingredients=[\"Tomato sauce\", \"Mozzarella\", \"Pepperoni\", \"Sausage\", \"Bell peppers\", \"Onions\", \"Mushrooms\"]\n        )\n\n# Factory selector\nclass PizzaFactoryProvider:\n    \"\"\"Provides the appropriate pizza factory based on style.\"\"\"\n\n    @staticmethod\n    def get_factory(style: PizzaStyle) -&gt; PizzaFactory:\n        \"\"\"Get the appropriate factory for the pizza style.\"\"\"\n        factories = {\n            PizzaStyle.ITALIAN: ItalianPizzaFactory(),\n            PizzaStyle.AMERICAN: AmericanPizzaFactory(),\n            # PizzaStyle.CHICAGO: ChicagoPizzaFactory(),  # Could add more\n        }\n\n        if style not in factories:\n            raise ValueError(f\"Unsupported pizza style: {style}\")\n\n        return factories[style]\n\n# Usage\ndef demonstrate_factory_pattern():\n    \"\"\"Show how factory pattern works.\"\"\"\n\n    # Customer chooses style\n    chosen_style = PizzaStyle.ITALIAN\n    factory = PizzaFactoryProvider.get_factory(chosen_style)\n\n    # Create pizzas using the appropriate factory\n    margherita = factory.create_margherita()\n    pepperoni = factory.create_pepperoni()\n    supreme = factory.create_supreme()\n\n    print(f\"=== {chosen_style.value.title()} Style Pizzas ===\")\n    print(f\"Margherita: {margherita.name} - ${margherita.price}\")\n    print(f\"Pepperoni: {pepperoni.name} - ${pepperoni.price}\")\n    print(f\"Supreme: {supreme.name} - ${supreme.price}\")\n</code></pre>"},{"location":"references/python_object_oriented/#strategy-pattern","title":"Strategy Pattern","text":"<pre><code>from abc import ABC, abstractmethod\n\nclass PricingStrategy(ABC):\n    \"\"\"Abstract strategy for pizza pricing.\"\"\"\n\n    @abstractmethod\n    def calculate_price(self, base_price: float, pizza: Pizza) -&gt; float:\n        pass\n\nclass RegularPricingStrategy(PricingStrategy):\n    \"\"\"Standard pricing - no modifications.\"\"\"\n\n    def calculate_price(self, base_price: float, pizza: Pizza) -&gt; float:\n        return base_price\n\nclass HappyHourPricingStrategy(PricingStrategy):\n    \"\"\"Happy hour pricing - 20% discount.\"\"\"\n\n    def calculate_price(self, base_price: float, pizza: Pizza) -&gt; float:\n        return base_price * 0.8\n\nclass LoyaltyPricingStrategy(PricingStrategy):\n    \"\"\"Loyalty customer pricing - discount based on ingredients.\"\"\"\n\n    def __init__(self, loyalty_level: str):\n        self.loyalty_level = loyalty_level\n        self.discounts = {\n            \"bronze\": 0.05,  # 5% discount\n            \"silver\": 0.10,  # 10% discount\n            \"gold\": 0.15     # 15% discount\n        }\n\n    def calculate_price(self, base_price: float, pizza: Pizza) -&gt; float:\n        discount = self.discounts.get(self.loyalty_level.lower(), 0)\n        return base_price * (1 - discount)\n\nclass GroupOrderPricingStrategy(PricingStrategy):\n    \"\"\"Group order pricing - bulk discount.\"\"\"\n\n    def __init__(self, order_quantity: int):\n        self.order_quantity = order_quantity\n\n    def calculate_price(self, base_price: float, pizza: Pizza) -&gt; float:\n        if self.order_quantity &gt;= 5:\n            return base_price * 0.85  # 15% discount for 5+ pizzas\n        elif self.order_quantity &gt;= 3:\n            return base_price * 0.90  # 10% discount for 3+ pizzas\n        return base_price\n\nclass PizzaPricer:\n    \"\"\"Context class that uses pricing strategies.\"\"\"\n\n    def __init__(self, strategy: PricingStrategy):\n        self._strategy = strategy\n\n    def set_strategy(self, strategy: PricingStrategy) -&gt; None:\n        \"\"\"Change pricing strategy at runtime.\"\"\"\n        self._strategy = strategy\n\n    def calculate_pizza_price(self, pizza: Pizza) -&gt; float:\n        \"\"\"Calculate pizza price using current strategy.\"\"\"\n        return self._strategy.calculate_price(pizza.price, pizza)\n\n    def calculate_order_total(self, pizzas: List[Pizza]) -&gt; float:\n        \"\"\"Calculate total for multiple pizzas.\"\"\"\n        return sum(self.calculate_pizza_price(pizza) for pizza in pizzas)\n\n# Usage example\ndef demonstrate_strategy_pattern():\n    \"\"\"Show how strategy pattern works.\"\"\"\n\n    # Create some pizzas\n    margherita = Pizza(\"Margherita\", 12.99, [\"tomato\", \"mozzarella\", \"basil\"])\n    pepperoni = Pizza(\"Pepperoni\", 14.99, [\"tomato\", \"mozzarella\", \"pepperoni\"])\n    pizzas = [margherita, pepperoni]\n\n    # Different pricing strategies\n    regular_pricer = PizzaPricer(RegularPricingStrategy())\n    happy_hour_pricer = PizzaPricer(HappyHourPricingStrategy())\n    loyalty_pricer = PizzaPricer(LoyaltyPricingStrategy(\"gold\"))\n    group_pricer = PizzaPricer(GroupOrderPricingStrategy(order_quantity=5))\n\n    print(\"=== Pizza Pricing Comparison ===\")\n    print(f\"Regular pricing: ${regular_pricer.calculate_order_total(pizzas):.2f}\")\n    print(f\"Happy hour pricing: ${happy_hour_pricer.calculate_order_total(pizzas):.2f}\")\n    print(f\"Gold loyalty pricing: ${loyalty_pricer.calculate_order_total(pizzas):.2f}\")\n    print(f\"Group order pricing: ${group_pricer.calculate_order_total(pizzas):.2f}\")\n\n    # Strategy can be changed at runtime\n    pricer = PizzaPricer(RegularPricingStrategy())\n    print(f\"\\nUsing initial strategy: ${pricer.calculate_order_total(pizzas):.2f}\")\n\n    pricer.set_strategy(HappyHourPricingStrategy())\n    print(f\"After switching to happy hour: ${pricer.calculate_order_total(pizzas):.2f}\")\n</code></pre>"},{"location":"references/python_object_oriented/#testing-oop-code","title":"\ud83e\uddea Testing OOP Code","text":"<p>Testing object-oriented code requires understanding inheritance and composition:</p> <pre><code>import pytest\nfrom unittest.mock import Mock, patch\nfrom typing import List\n\nclass TestPizza:\n    \"\"\"Test the Pizza entity class.\"\"\"\n\n    def setup_method(self):\n        \"\"\"Setup for each test method.\"\"\"\n        self.pizza = Pizza(\"Test Pizza\", 10.0, [\"cheese\", \"tomato\"])\n\n    def test_pizza_creation(self):\n        \"\"\"Test pizza object creation.\"\"\"\n        assert self.pizza.name == \"Test Pizza\"\n        assert self.pizza.price == 10.0\n        assert self.pizza.ingredients == [\"cheese\", \"tomato\"]\n        assert self.pizza.is_available == True\n        assert self.pizza.id is not None\n\n    def test_add_ingredient(self):\n        \"\"\"Test adding ingredient to pizza.\"\"\"\n        self.pizza.add_ingredient(\"pepperoni\")\n\n        assert \"pepperoni\" in self.pizza.ingredients\n        assert self.pizza.price == 11.50  # Original price + $1.50\n        assert len(self.pizza.get_uncommitted_events()) == 2  # Created + Ingredient added\n\n    def test_add_ingredient_duplicate(self):\n        \"\"\"Test adding duplicate ingredient doesn't change price.\"\"\"\n        original_price = self.pizza.price\n        self.pizza.add_ingredient(\"cheese\")  # Already exists\n\n        assert self.pizza.price == original_price\n        assert self.pizza.ingredients.count(\"cheese\") == 1\n\n    def test_add_too_many_ingredients(self):\n        \"\"\"Test business rule: max 10 ingredients.\"\"\"\n        # Add 8 more ingredients (already has 2)\n        for i in range(8):\n            self.pizza.add_ingredient(f\"ingredient_{i}\")\n\n        # Adding 9th should fail\n        with pytest.raises(ValueError, match=\"cannot have more than 10 ingredients\"):\n            self.pizza.add_ingredient(\"too_many\")\n\n    def test_change_price(self):\n        \"\"\"Test price change with validation.\"\"\"\n        self.pizza.change_price(15.99)\n\n        assert self.pizza.price == 15.99\n        events = self.pizza.get_uncommitted_events()\n        price_change_events = [e for e in events if isinstance(e, PizzaPriceChangedEvent)]\n        assert len(price_change_events) == 1\n\n    def test_change_price_too_low(self):\n        \"\"\"Test price validation.\"\"\"\n        with pytest.raises(ValueError, match=\"cannot be less than\"):\n            self.pizza.change_price(3.0)\n\n    def test_discontinue(self):\n        \"\"\"Test discontinuing pizza.\"\"\"\n        self.pizza.discontinue()\n\n        assert self.pizza.is_available == False\n        events = self.pizza.get_uncommitted_events()\n        discontinue_events = [e for e in events if isinstance(e, PizzaDiscontinuedEvent)]\n        assert len(discontinue_events) == 1\n\nclass TestOrder:\n    \"\"\"Test the Order composition class.\"\"\"\n\n    def setup_method(self):\n        \"\"\"Setup for each test method.\"\"\"\n        self.customer = Customer(\"Test Customer\", \"test@example.com\")\n        self.order = Order(self.customer)\n        self.pizza = Pizza(\"Test Pizza\", 12.99, [\"cheese\", \"tomato\"])\n        self.drink = Drink(\"Coke\", 2.99, \"Soft drink\")\n\n    def test_order_creation(self):\n        \"\"\"Test order object creation.\"\"\"\n        assert self.order.customer == self.customer\n        assert self.order.order_id is not None\n        assert len(self.order.items) == 0\n        assert self.order.status == OrderStatus.PENDING\n\n    def test_add_item(self):\n        \"\"\"Test adding items to order.\"\"\"\n        self.order.add_item(self.pizza, quantity=2)\n        self.order.add_item(self.drink, quantity=1)\n\n        assert len(self.order.items) == 2\n        assert self.order.items[0].quantity == 2\n        assert self.order.items[1].quantity == 1\n        assert self.order.estimated_ready_time is not None\n\n    def test_calculate_totals(self):\n        \"\"\"Test order total calculations.\"\"\"\n        self.order.add_item(self.pizza, quantity=2)  # 2 * 12.99 = 25.98\n        self.order.add_item(self.drink, quantity=1)  # 1 * 2.99 = 2.99\n\n        subtotal = self.order.calculate_subtotal()\n        assert subtotal == 28.97\n\n        self.order.apply_discount(10)  # 10% discount\n        discount = self.order.calculate_discount_amount()\n        assert discount == 2.897  # 10% of 28.97\n\n        tax = self.order.calculate_tax_amount()\n        expected_tax = (28.97 - 2.897) * 0.08  # 8% tax on discounted amount\n        assert abs(tax - expected_tax) &lt; 0.01\n\n    def test_remove_item(self):\n        \"\"\"Test removing items from order.\"\"\"\n        self.order.add_item(self.pizza)\n        self.order.add_item(self.drink)\n\n        removed = self.order.remove_item(0)  # Remove first item\n\n        assert removed == True\n        assert len(self.order.items) == 1\n        assert self.order.items[0].menu_item == self.drink\n\nclass TestPizzaRepository:\n    \"\"\"Test the repository with inheritance and composition.\"\"\"\n\n    def setup_method(self):\n        \"\"\"Setup for each test method.\"\"\"\n        self.repository = PizzaRepository()\n        self.pizza1 = Pizza(\"Margherita\", 12.99, [\"tomato\", \"mozzarella\"])\n        self.pizza2 = Pizza(\"Pepperoni\", 14.99, [\"tomato\", \"mozzarella\", \"pepperoni\"])\n        self.pizza2.is_available = False  # Discontinued\n\n    @pytest.mark.asyncio\n    async def test_save_and_retrieve(self):\n        \"\"\"Test saving and retrieving pizzas.\"\"\"\n        await self.repository.save_async(self.pizza1)\n\n        retrieved = await self.repository.get_by_id_async(self.pizza1.id)\n\n        assert retrieved is not None\n        assert retrieved.id == self.pizza1.id\n        assert retrieved.name == self.pizza1.name\n\n    @pytest.mark.asyncio\n    async def test_get_available_pizzas(self):\n        \"\"\"Test getting only available pizzas.\"\"\"\n        await self.repository.save_async(self.pizza1)  # Available\n        await self.repository.save_async(self.pizza2)  # Not available\n\n        available_pizzas = await self.repository.get_available_pizzas_async()\n\n        assert len(available_pizzas) == 1\n        assert available_pizzas[0].id == self.pizza1.id\n\n    @pytest.mark.asyncio\n    async def test_get_pizzas_by_ingredient(self):\n        \"\"\"Test finding pizzas by ingredient.\"\"\"\n        await self.repository.save_async(self.pizza1)\n        await self.repository.save_async(self.pizza2)\n\n        pizzas_with_pepperoni = await self.repository.get_pizzas_by_ingredient_async(\"pepperoni\")\n\n        # Should not include pizza2 because it's not available\n        assert len(pizzas_with_pepperoni) == 0\n\n        pizzas_with_mozzarella = await self.repository.get_pizzas_by_ingredient_async(\"mozzarella\")\n        assert len(pizzas_with_mozzarella) == 1  # Only available pizza1\n\nclass TestCommandHandlers:\n    \"\"\"Test command handlers with mocking.\"\"\"\n\n    def setup_method(self):\n        \"\"\"Setup for each test method.\"\"\"\n        self.mock_repository = Mock(spec=PizzaRepository)\n        self.mock_validator = Mock()\n        self.handler = CreatePizzaHandler(self.mock_repository, self.mock_validator)\n\n    @pytest.mark.asyncio\n    async def test_successful_pizza_creation(self):\n        \"\"\"Test successful pizza creation.\"\"\"\n        # Setup mocks\n        self.mock_validator.validate_async.return_value = Mock(is_valid=True)\n        self.mock_repository.save_async = Mock()\n\n        command = CreatePizzaCommand(\n            name=\"Test Pizza\",\n            price=12.99,\n            ingredients=[\"cheese\", \"tomato\"]\n        )\n\n        # Execute handler\n        result = await self.handler.handle_async(command)\n\n        # Verify results\n        assert isinstance(result, Pizza)\n        assert result.name == \"Test Pizza\"\n        assert result.price == 12.99\n\n        # Verify mocks were called\n        self.mock_validator.validate_async.assert_called_once_with(command)\n        self.mock_repository.save_async.assert_called_once()\n\n    @pytest.mark.asyncio\n    async def test_validation_failure(self):\n        \"\"\"Test handling validation errors.\"\"\"\n        # Setup mock to return validation failure\n        validation_result = Mock(is_valid=False, errors=[\"Invalid pizza name\"])\n        self.mock_validator.validate_async.return_value = validation_result\n\n        command = CreatePizzaCommand(name=\"\", price=12.99, ingredients=[])\n\n        # Should raise validation error\n        with pytest.raises(ValidationError):\n            await self.handler.handle_async(command)\n\n        # Repository should not be called\n        self.mock_repository.save_async.assert_not_called()\n</code></pre>"},{"location":"references/python_object_oriented/#best-practices-for-oop","title":"\ud83d\ude80 Best Practices for OOP","text":""},{"location":"references/python_object_oriented/#1-follow-solid-principles","title":"1. Follow SOLID Principles","text":"<pre><code># Single Responsibility Principle - each class has one job\nclass PizzaPriceCalculator:\n    \"\"\"Only responsible for price calculations.\"\"\"\n    def calculate_price(self, pizza: Pizza) -&gt; float:\n        pass\n\nclass PizzaValidator:\n    \"\"\"Only responsible for pizza validation.\"\"\"\n    def validate(self, pizza: Pizza) -&gt; ValidationResult:\n        pass\n\n# Open/Closed Principle - open for extension, closed for modification\nclass NotificationService(ABC):\n    @abstractmethod\n    async def send_notification(self, message: str, recipient: str) -&gt; None:\n        pass\n\nclass EmailNotificationService(NotificationService):\n    async def send_notification(self, message: str, recipient: str) -&gt; None:\n        # Email implementation\n        pass\n\nclass SmsNotificationService(NotificationService):\n    async def send_notification(self, message: str, recipient: str) -&gt; None:\n        # SMS implementation\n        pass\n\n# Liskov Substitution Principle - derived classes must be substitutable\ndef send_welcome_message(notification_service: NotificationService, customer: Customer):\n    # Works with any NotificationService implementation\n    await notification_service.send_notification(\n        f\"Welcome {customer.name}!\",\n        customer.email\n    )\n\n# Interface Segregation Principle - many specific interfaces\nclass Readable(Protocol):\n    def read(self) -&gt; str: ...\n\nclass Writable(Protocol):\n    def write(self, data: str) -&gt; None: ...\n\nclass ReadWritable(Readable, Writable, Protocol):\n    pass\n\n# Dependency Inversion Principle - depend on abstractions\nclass OrderService:\n    def __init__(self,\n                 repository: Repository[Order, str],  # Abstract dependency\n                 notifier: NotificationService):      # Abstract dependency\n        self._repository = repository\n        self._notifier = notifier\n</code></pre>"},{"location":"references/python_object_oriented/#2-use-composition-over-inheritance","title":"2. Use Composition over Inheritance","text":"<pre><code># \u2705 Good - composition\nclass Order:\n    def __init__(self, customer: Customer):\n        self.customer = customer          # HAS-A relationship\n        self.payment_method = None        # HAS-A relationship\n        self.items = []                   # HAS-A relationship\n\n# \u274c Avoid deep inheritance hierarchies\nclass Animal:\n    pass\n\nclass Mammal(Animal):\n    pass\n\nclass Carnivore(Mammal):\n    pass\n\nclass Feline(Carnivore):\n    pass\n\nclass Cat(Feline):  # Too deep!\n    pass\n</code></pre>"},{"location":"references/python_object_oriented/#3-keep-classes-focused-and-small","title":"3. Keep Classes Focused and Small","text":"<pre><code># \u2705 Good - focused class\nclass Pizza:\n    \"\"\"Represents a pizza with its properties and behaviors.\"\"\"\n    def __init__(self, name: str, price: float, ingredients: List[str]):\n        self.name = name\n        self.price = price\n        self.ingredients = ingredients\n\n    def add_ingredient(self, ingredient: str) -&gt; None:\n        \"\"\"Add ingredient to pizza.\"\"\"\n        pass\n\n    def calculate_cost(self) -&gt; float:\n        \"\"\"Calculate cost to make pizza.\"\"\"\n        pass\n\n# \u274c Bad - doing too much\nclass PizzaEverything:\n    \"\"\"Class that tries to do everything - violates SRP.\"\"\"\n    def create_pizza(self): pass\n    def save_to_database(self): pass\n    def send_email(self): pass\n    def process_payment(self): pass\n    def manage_inventory(self): pass\n    def generate_reports(self): pass\n</code></pre>"},{"location":"references/python_object_oriented/#4-use-properties-for-controlled-access","title":"4. Use Properties for Controlled Access","text":"<pre><code>class Customer:\n    def __init__(self, name: str, email: str):\n        self._name = name\n        self._email = email\n        self._loyalty_points = 0\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Get customer name.\"\"\"\n        return self._name\n\n    @property\n    def email(self) -&gt; str:\n        \"\"\"Get customer email.\"\"\"\n        return self._email\n\n    @email.setter\n    def email(self, value: str) -&gt; None:\n        \"\"\"Set email with validation.\"\"\"\n        if \"@\" not in value:\n            raise ValueError(\"Invalid email format\")\n        self._email = value\n\n    @property\n    def loyalty_points(self) -&gt; int:\n        \"\"\"Get loyalty points (read-only).\"\"\"\n        return self._loyalty_points\n\n    def add_loyalty_points(self, points: int) -&gt; None:\n        \"\"\"Add loyalty points through controlled method.\"\"\"\n        if points &gt; 0:\n            self._loyalty_points += points\n</code></pre>"},{"location":"references/python_object_oriented/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Python Typing Guide - Type safety, generics, and inheritance patterns</li> <li>Python Modular Code - Organizing classes across modules</li> <li>Dependency Injection - OOP with dependency management</li> <li>CQRS &amp; Mediation - Object-oriented command/query patterns</li> </ul>"},{"location":"references/python_object_oriented/#further-reading","title":"\ud83d\udcda Further Reading","text":"<ul> <li>Python Classes Documentation</li> <li>SOLID Principles in Python</li> <li>Design Patterns in Python</li> <li>Clean Code by Robert Martin</li> </ul>"},{"location":"references/python_typing_guide/","title":"\ud83c\udff7\ufe0f Python Typing Guide - Type Hints &amp; Generics","text":"<p>A comprehensive guide to Python type hints and generic types essential for understanding and working with the Neuroglia framework. They provide clarity, enable better IDE support, and help catch errors before runtime.</p>"},{"location":"references/python_typing_guide/#table-of-contents","title":"\ud83d\udcda Table of Contents","text":"<ol> <li>Type Hints Fundamentals</li> <li>Basic Type Annotations</li> <li>Advanced Type Hints</li> <li>Generic Types Fundamentals</li> <li>Core Generic Concepts</li> <li>Framework Integration</li> <li>Advanced Generic Patterns</li> <li>Testing with Types</li> <li>Type Checking Tools</li> <li>Best Practices</li> </ol>"},{"location":"references/python_typing_guide/#type-hints-fundamentals","title":"\ud83c\udfaf Type Hints Fundamentals","text":"<p>Type hints are optional annotations that specify what types of values functions, variables, and class attributes should have. They make your code more readable and help tools understand your intentions.</p>"},{"location":"references/python_typing_guide/#before-and-after-type-hints","title":"Before and After Type Hints","text":"<pre><code># Without type hints - unclear what types are expected:\ndef process_order(customer, items, discount):\n    total = 0\n    for item in items:\n        total += item[\"price\"] * item[\"quantity\"]\n\n    if discount:\n        total *= (1 - discount)\n\n    return {\n        \"customer\": customer,\n        \"total\": total,\n        \"items\": len(items)\n    }\n\n# With type hints - crystal clear what's expected:\nfrom typing import List, Dict, Optional\n\ndef process_order(\n    customer: str,\n    items: List[Dict[str, float]],\n    discount: Optional[float] = None\n) -&gt; Dict[str, any]:\n    total = 0.0\n    for item in items:\n        total += item[\"price\"] * item[\"quantity\"]\n\n    if discount:\n        total *= (1 - discount)\n\n    return {\n        \"customer\": customer,\n        \"total\": total,\n        \"items\": len(items)\n    }\n</code></pre>"},{"location":"references/python_typing_guide/#basic-type-annotations","title":"\ud83d\udd27 Basic Type Annotations","text":""},{"location":"references/python_typing_guide/#primitive-types","title":"Primitive Types","text":"<pre><code># Basic types:\nname: str = \"Mario\"\nage: int = 25\nprice: float = 12.99\nis_available: bool = True\n\n# Function parameters and return types:\ndef calculate_tax(amount: float, rate: float) -&gt; float:\n    return amount * rate\n\ndef greet_customer(name: str) -&gt; str:\n    return f\"Welcome to Mario's Pizzeria, {name}!\"\n\ndef is_pizza_large(diameter: int) -&gt; bool:\n    return diameter &gt;= 12\n</code></pre>"},{"location":"references/python_typing_guide/#collection-types","title":"Collection Types","text":"<pre><code>from typing import List, Dict, Set, Tuple\n\n# Lists - ordered collections of the same type:\npizza_names: List[str] = [\"Margherita\", \"Pepperoni\", \"Hawaiian\"]\nprices: List[float] = [12.99, 14.99, 13.49]\n\n# Dictionaries - key-value pairs:\npizza_menu: Dict[str, float] = {\n    \"Margherita\": 12.99,\n    \"Pepperoni\": 14.99,\n    \"Hawaiian\": 13.49\n}\n\n# Sets - unique collections:\navailable_toppings: Set[str] = {\"cheese\", \"pepperoni\", \"mushrooms\", \"olives\"}\n\n# Tuples - fixed-size collections:\nlocation: Tuple[float, float] = (40.7128, -74.0060)  # lat, lng\npizza_info: Tuple[str, float, List[str]] = (\n    \"Margherita\",\n    12.99,\n    [\"tomato\", \"mozzarella\", \"basil\"]\n)\n\n# Functions working with collections:\ndef get_most_expensive_pizza(menu: Dict[str, float]) -&gt; Tuple[str, float]:\n    name = max(menu, key=menu.get)\n    price = menu[name]\n    return name, price\n\ndef add_topping(toppings: Set[str], new_topping: str) -&gt; Set[str]:\n    toppings.add(new_topping)\n    return toppings\n</code></pre>"},{"location":"references/python_typing_guide/#advanced-type-hints","title":"\ud83c\udfa8 Advanced Type Hints","text":""},{"location":"references/python_typing_guide/#optional-types","title":"Optional Types","text":"<p>When a value might be <code>None</code>, use <code>Optional</code>:</p> <pre><code>from typing import Optional\n\n# Optional parameters:\ndef find_pizza_by_name(name: str, menu: Dict[str, float]) -&gt; Optional[float]:\n    \"\"\"Returns the price if pizza exists, None otherwise.\"\"\"\n    return menu.get(name)\n\n# Optional attributes:\nclass Customer:\n    def __init__(self, name: str, email: Optional[str] = None):\n        self.name: str = name\n        self.email: Optional[str] = email\n        self.phone: Optional[str] = None\n\n# Functions that might return None:\ndef get_customer_discount(customer_id: str) -&gt; Optional[float]:\n    # Database lookup logic here\n    if customer_exists(customer_id):\n        return 0.10  # 10% discount\n    return None\n\n# Using optional values safely:\ndiscount = get_customer_discount(\"12345\")\nif discount is not None:\n    discounted_price = original_price * (1 - discount)\nelse:\n    discounted_price = original_price\n</code></pre>"},{"location":"references/python_typing_guide/#union-types","title":"Union Types","text":"<p>When a value can be one of several types:</p> <pre><code>from typing import Union\n\n# A value that can be string or number:\nPizzaId = Union[str, int]\n\ndef get_pizza_details(pizza_id: PizzaId) -&gt; Dict[str, any]:\n    # Convert to string for consistent handling:\n    id_str = str(pizza_id)\n    # ... lookup logic\n    return pizza_details\n\n# Multiple possible return types:\ndef process_payment(amount: float) -&gt; Union[str, Dict[str, any]]:\n    if amount &lt;= 0:\n        return \"Invalid amount\"  # Error message\n\n    # Process payment...\n    return {\n        \"transaction_id\": \"TXN123\",\n        \"amount\": amount,\n        \"status\": \"completed\"\n    }\n\n# Modern Python 3.10+ syntax (preferred):\ndef process_payment_modern(amount: float) -&gt; str | Dict[str, any]:\n    # Same logic as above\n    pass\n</code></pre>"},{"location":"references/python_typing_guide/#callable-types","title":"Callable Types","text":"<p>For functions as parameters or return values:</p> <pre><code>from typing import Callable\n\n# Function that takes a function as parameter:\ndef apply_discount(\n    price: float,\n    discount_function: Callable[[float], float]\n) -&gt; float:\n    return discount_function(price)\n\n# Different discount strategies:\ndef student_discount(price: float) -&gt; float:\n    return price * 0.9  # 10% off\n\ndef loyalty_discount(price: float) -&gt; float:\n    return price * 0.85  # 15% off\n\n# Usage:\noriginal_price = 12.99\nstudent_price = apply_discount(original_price, student_discount)\nloyalty_price = apply_discount(original_price, loyalty_discount)\n\n# More complex callable signatures:\nProcessorFunction = Callable[[str, List[str]], Dict[str, any]]\n\ndef process_pizza_order(\n    pizza_name: str,\n    toppings: List[str],\n    processor: ProcessorFunction\n) -&gt; Dict[str, any]:\n    return processor(pizza_name, toppings)\n</code></pre>"},{"location":"references/python_typing_guide/#generic-types-fundamentals","title":"\ud83e\uddec Generic Types Fundamentals","text":"<p>Understanding generics is crucial for working with the Neuroglia framework, as they provide type safety and flexibility throughout the architecture.</p>"},{"location":"references/python_typing_guide/#what-are-generic-types","title":"What Are Generic Types?","text":"<p>Generic types allow you to write code that works with different types while maintaining type safety. Think of them as \"type parameters\" that get filled in later.</p>"},{"location":"references/python_typing_guide/#simple-analogy","title":"Simple Analogy","text":"<p>Imagine a generic container that can hold any type of item:</p> <pre><code># Instead of creating separate containers for each type:\nclass StringContainer:\n    def __init__(self, value: str):\n        self.value = value\n\nclass IntContainer:\n    def __init__(self, value: int):\n        self.value = value\n\n# We create ONE generic container:\nfrom typing import Generic, TypeVar\n\nT = TypeVar('T')\n\nclass Container(Generic[T]):\n    def __init__(self, value: T):\n        self.value = value\n\n    def get_value(self) -&gt; T:\n        return self.value\n\n# Now we can use it with any type:\nstring_container = Container[str](\"Hello\")\nint_container = Container[int](42)\n</code></pre>"},{"location":"references/python_typing_guide/#core-generic-concepts","title":"\ud83d\udd27 Core Generic Concepts","text":""},{"location":"references/python_typing_guide/#typevar-type-variables","title":"TypeVar - Type Variables","text":"<p><code>TypeVar</code> creates a placeholder for a type that will be specified later:</p> <pre><code>from typing import TypeVar, List\n\n# Define a type variable\nT = TypeVar('T')\n\ndef get_first_item(items: List[T]) -&gt; T:\n    \"\"\"Returns the first item from a list, preserving its type.\"\"\"\n    return items[0]\n\n# Usage examples:\nnumbers = [1, 2, 3]\nfirst_number = get_first_item(numbers)  # Type: int\n\nnames = [\"Alice\", \"Bob\", \"Charlie\"]\nfirst_name = get_first_item(names)      # Type: str\n</code></pre>"},{"location":"references/python_typing_guide/#generic-classes","title":"Generic Classes","text":"<p>Classes can be made generic to work with different types:</p> <pre><code>from typing import Generic, TypeVar, Optional, List\n\nT = TypeVar('T')\n\nclass Repository(Generic[T]):\n    \"\"\"A generic repository that can store any type of entity.\"\"\"\n\n    def __init__(self):\n        self._items: List[T] = []\n\n    def add(self, item: T) -&gt; None:\n        self._items.append(item)\n\n    def get_by_index(self, index: int) -&gt; Optional[T]:\n        if 0 &lt;= index &lt; len(self._items):\n            return self._items[index]\n        return None\n\n    def get_all(self) -&gt; List[T]:\n        return self._items.copy()\n\n# Usage with specific types:\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    id: str\n    name: str\n\n@dataclass\nclass Product:\n    id: str\n    name: str\n    price: float\n\n# Create type-specific repositories:\nuser_repo = Repository[User]()\nproduct_repo = Repository[Product]()\n\n# Type safety is maintained:\nuser_repo.add(User(\"1\", \"Alice\"))        # \u2705 Correct\nproduct_repo.add(Product(\"1\", \"Pizza\", 12.99))  # \u2705 Correct\n\n# user_repo.add(Product(\"1\", \"Pizza\", 12.99))  # \u274c Type error!\n</code></pre>"},{"location":"references/python_typing_guide/#framework-integration","title":"\ud83c\udfd7\ufe0f Framework Integration","text":""},{"location":"references/python_typing_guide/#type-hints-in-neuroglia-framework","title":"Type Hints in Neuroglia Framework","text":""},{"location":"references/python_typing_guide/#entity-and-repository-patterns","title":"Entity and Repository Patterns","text":"<pre><code>from typing import Generic, TypeVar, Optional, List, Protocol\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\n\n# Domain entities with type hints:\n@dataclass\nclass Pizza:\n    id: str\n    name: str\n    price: float\n    ingredients: List[str]\n    is_available: bool = True\n\n@dataclass\nclass Customer:\n    id: str\n    name: str\n    email: str\n    phone: Optional[str] = None\n    loyalty_points: int = 0\n\n# Repository with clear type signatures:\nTEntity = TypeVar('TEntity')\nTId = TypeVar('TId')\n\nclass Repository(Generic[TEntity, TId], Protocol):\n    async def get_by_id_async(self, id: TId) -&gt; Optional[TEntity]:\n        \"\"\"Get entity by ID, returns None if not found.\"\"\"\n        ...\n\n    async def save_async(self, entity: TEntity) -&gt; None:\n        \"\"\"Save entity to storage.\"\"\"\n        ...\n\n    async def delete_async(self, id: TId) -&gt; bool:\n        \"\"\"Delete entity, returns True if deleted.\"\"\"\n        ...\n\n    async def get_all_async(self) -&gt; List[TEntity]:\n        \"\"\"Get all entities.\"\"\"\n        ...\n\n# Concrete implementation:\nclass PizzaRepository(Repository[Pizza, str]):\n    def __init__(self):\n        self._pizzas: Dict[str, Pizza] = {}\n\n    async def get_by_id_async(self, id: str) -&gt; Optional[Pizza]:\n        return self._pizzas.get(id)\n\n    async def save_async(self, pizza: Pizza) -&gt; None:\n        self._pizzas[pizza.id] = pizza\n\n    async def delete_async(self, id: str) -&gt; bool:\n        if id in self._pizzas:\n            del self._pizzas[id]\n            return True\n        return False\n\n    async def get_all_async(self) -&gt; List[Pizza]:\n        return list(self._pizzas.values())\n</code></pre>"},{"location":"references/python_typing_guide/#cqrs-commands-and-queries","title":"CQRS Commands and Queries","text":"<pre><code>from typing import Generic, TypeVar\nfrom dataclasses import dataclass\n\nTResult = TypeVar('TResult')\n\n# Base command and query types:\nclass Command(Generic[TResult]):\n    \"\"\"Base class for commands with typed results.\"\"\"\n    pass\n\nclass Query(Generic[TResult]):\n    \"\"\"Base class for queries with typed results.\"\"\"\n    pass\n\n# Specific commands with clear return types:\n@dataclass\nclass CreatePizzaCommand(Command[Pizza]):\n    name: str\n    price: float\n    ingredients: List[str]\n\n@dataclass\nclass UpdatePizzaPriceCommand(Command[Optional[Pizza]]):\n    pizza_id: str\n    new_price: float\n\n@dataclass\nclass DeletePizzaCommand(Command[bool]):\n    pizza_id: str\n\n# Queries with different return types:\n@dataclass\nclass GetPizzaByIdQuery(Query[Optional[Pizza]]):\n    pizza_id: str\n\n@dataclass\nclass GetAvailablePizzasQuery(Query[List[Pizza]]):\n    pass\n\n@dataclass\nclass GetPizzasByPriceRangeQuery(Query[List[Pizza]]):\n    min_price: float\n    max_price: float\n\n# Handler interfaces with type safety:\nTRequest = TypeVar('TRequest')\nTResponse = TypeVar('TResponse')\n\nclass Handler(Generic[TRequest, TResponse], Protocol):\n    async def handle_async(self, request: TRequest) -&gt; TResponse:\n        \"\"\"Handle the request and return typed response.\"\"\"\n        ...\n\n# Concrete handlers:\nclass CreatePizzaHandler(Handler[CreatePizzaCommand, Pizza]):\n    def __init__(self, repository: PizzaRepository):\n        self._repository = repository\n\n    async def handle_async(self, command: CreatePizzaCommand) -&gt; Pizza:\n        pizza = Pizza(\n            id=generate_id(),\n            name=command.name,\n            price=command.price,\n            ingredients=command.ingredients\n        )\n        await self._repository.save_async(pizza)\n        return pizza\n\nclass GetPizzaByIdHandler(Handler[GetPizzaByIdQuery, Optional[Pizza]]):\n    def __init__(self, repository: PizzaRepository):\n        self._repository = repository\n\n    async def handle_async(self, query: GetPizzaByIdQuery) -&gt; Optional[Pizza]:\n        return await self._repository.get_by_id_async(query.pizza_id)\n</code></pre>"},{"location":"references/python_typing_guide/#api-controllers-with-type-safety","title":"API Controllers with Type Safety","text":"<pre><code>from typing import List, Optional\nfrom fastapi import HTTPException\nfrom neuroglia.mvc import ControllerBase\n\n# DTOs with type hints:\n@dataclass\nclass PizzaDto:\n    id: str\n    name: str\n    price: float\n    ingredients: List[str]\n    is_available: bool\n\n@dataclass\nclass CreatePizzaDto:\n    name: str\n    price: float\n    ingredients: List[str]\n\n@dataclass\nclass UpdatePizzaPriceDto:\n    new_price: float\n\n# Controller with clear type signatures:\nclass PizzaController(ControllerBase):\n    def __init__(self, mediator, mapper, service_provider):\n        super().__init__(service_provider, mapper, mediator)\n\n    async def get_pizza(self, pizza_id: str) -&gt; Optional[PizzaDto]:\n        \"\"\"Get a pizza by ID.\"\"\"\n        query = GetPizzaByIdQuery(pizza_id=pizza_id)\n        pizza = await self.mediator.execute_async(query)\n\n        if pizza is None:\n            return None\n\n        return self.mapper.map(pizza, PizzaDto)\n\n    async def create_pizza(self, create_dto: CreatePizzaDto) -&gt; PizzaDto:\n        \"\"\"Create a new pizza.\"\"\"\n        command = CreatePizzaCommand(\n            name=create_dto.name,\n            price=create_dto.price,\n            ingredients=create_dto.ingredients\n        )\n\n        pizza = await self.mediator.execute_async(command)\n        return self.mapper.map(pizza, PizzaDto)\n\n    async def get_all_pizzas(self) -&gt; List[PizzaDto]:\n        \"\"\"Get all available pizzas.\"\"\"\n        query = GetAvailablePizzasQuery()\n        pizzas = await self.mediator.execute_async(query)\n\n        return [self.mapper.map(pizza, PizzaDto) for pizza in pizzas]\n</code></pre>"},{"location":"references/python_typing_guide/#advanced-generic-patterns","title":"\ud83c\udfa8 Advanced Generic Patterns","text":""},{"location":"references/python_typing_guide/#bounded-type-variables","title":"Bounded Type Variables","text":"<p>You can constrain what types a <code>TypeVar</code> can be:</p> <pre><code>from typing import TypeVar\nfrom abc import ABC\n\n# Constraint to specific types:\nNumberType = TypeVar('NumberType', int, float)\n\ndef add_numbers(a: NumberType, b: NumberType) -&gt; NumberType:\n    return a + b\n\n# Bound to a base class:\nclass Entity(ABC):\n    def __init__(self, id: str):\n        self.id = id\n\nEntityType = TypeVar('EntityType', bound=Entity)\n\nclass EntityService(Generic[EntityType]):\n    def __init__(self, repository: Repository[EntityType, str]):\n        self._repository = repository\n\n    async def get_by_id(self, id: str) -&gt; Optional[EntityType]:\n        return await self._repository.get_by_id_async(id)\n\n# Usage - only works with Entity subclasses:\nclass Pizza(Entity):\n    def __init__(self, id: str, name: str):\n        super().__init__(id)\n        self.name = name\n\npizza_service = EntityService[Pizza](pizza_repository)  # \u2705 Works\n# str_service = EntityService[str](string_repo)         # \u274c Error: str is not an Entity\n</code></pre>"},{"location":"references/python_typing_guide/#generic-protocols","title":"Generic Protocols","text":"<p>Protocols define interfaces that any type can implement:</p> <pre><code>from typing import Protocol, TypeVar\n\nclass Comparable(Protocol):\n    \"\"\"Protocol for types that can be compared.\"\"\"\n    def __lt__(self, other: 'Comparable') -&gt; bool: ...\n    def __eq__(self, other: object) -&gt; bool: ...\n\nT = TypeVar('T', bound=Comparable)\n\ndef sort_items(items: List[T]) -&gt; List[T]:\n    \"\"\"Sort any list of comparable items.\"\"\"\n    return sorted(items)\n\n# Works with any type that implements comparison:\nnumbers = [3, 1, 4, 1, 5]\nsorted_numbers = sort_items(numbers)  # \u2705 int implements comparison\n\nnames = [\"Charlie\", \"Alice\", \"Bob\"]\nsorted_names = sort_items(names)      # \u2705 str implements comparison\n\n@dataclass\nclass Pizza:\n    name: str\n    price: float\n\n    def __lt__(self, other: 'Pizza') -&gt; bool:\n        return self.price &lt; other.price\n\n    def __eq__(self, other: object) -&gt; bool:\n        return isinstance(other, Pizza) and self.name == other.name\n\npizzas = [\n    Pizza(\"Margherita\", 12.99),\n    Pizza(\"Pepperoni\", 14.99),\n    Pizza(\"Hawaiian\", 13.49)\n]\nsorted_pizzas = sort_items(pizzas)    # \u2705 Pizza implements Comparable\n</code></pre>"},{"location":"references/python_typing_guide/#testing-with-types","title":"\ud83e\uddea Testing with Types","text":"<p>Type hints make tests more reliable and easier to understand:</p> <pre><code>from typing import List, Dict, Any, Optional\nimport pytest\nfrom unittest.mock import Mock, AsyncMock\n\nclass TestPizzaRepository:\n    def setup_method(self) -&gt; None:\n        \"\"\"Setup test fixtures with proper types.\"\"\"\n        self.repository: PizzaRepository = PizzaRepository()\n        self.sample_pizza: Pizza = Pizza(\n            id=\"1\",\n            name=\"Margherita\",\n            price=12.99,\n            ingredients=[\"tomato\", \"mozzarella\", \"basil\"]\n        )\n\n    async def test_save_and_retrieve_pizza(self) -&gt; None:\n        \"\"\"Test saving and retrieving a pizza.\"\"\"\n        # Save pizza\n        await self.repository.save_async(self.sample_pizza)\n\n        # Retrieve pizza\n        retrieved_pizza: Optional[Pizza] = await self.repository.get_by_id_async(\"1\")\n\n        # Assertions with type safety\n        assert retrieved_pizza is not None\n        assert retrieved_pizza.name == \"Margherita\"\n        assert retrieved_pizza.price == 12.99\n\n    async def test_get_nonexistent_pizza(self) -&gt; None:\n        \"\"\"Test retrieving a pizza that doesn't exist.\"\"\"\n        result: Optional[Pizza] = await self.repository.get_by_id_async(\"999\")\n        assert result is None\n\n    async def test_get_all_pizzas(self) -&gt; None:\n        \"\"\"Test getting all pizzas.\"\"\"\n        pizzas: List[Pizza] = [\n            Pizza(\"1\", \"Margherita\", 12.99, [\"tomato\", \"mozzarella\"]),\n            Pizza(\"2\", \"Pepperoni\", 14.99, [\"tomato\", \"mozzarella\", \"pepperoni\"])\n        ]\n\n        for pizza in pizzas:\n            await self.repository.save_async(pizza)\n\n        all_pizzas: List[Pizza] = await self.repository.get_all_async()\n        assert len(all_pizzas) == 2\n\n# Generic type testing:\nT = TypeVar('T')\n\nclass Stack(Generic[T]):\n    def __init__(self):\n        self._items: List[T] = []\n\n    def push(self, item: T) -&gt; None:\n        self._items.append(item)\n\n    def pop(self) -&gt; T:\n        if not self._items:\n            raise IndexError(\"Stack is empty\")\n        return self._items.pop()\n\n    def is_empty(self) -&gt; bool:\n        return len(self._items) == 0\n\n# Test with multiple types:\nclass TestStack:\n    def test_string_stack(self):\n        stack = Stack[str]()\n        stack.push(\"hello\")\n        stack.push(\"world\")\n\n        assert stack.pop() == \"world\"\n        assert stack.pop() == \"hello\"\n        assert stack.is_empty()\n\n    def test_int_stack(self):\n        stack = Stack[int]()\n        stack.push(1)\n        stack.push(2)\n\n        assert stack.pop() == 2\n        assert stack.pop() == 1\n        assert stack.is_empty()\n\n    def test_pizza_stack(self):\n        stack = Stack[Pizza]()\n        pizza = Pizza(\"1\", \"Margherita\", 12.99, [\"tomato\", \"mozzarella\"])\n        stack.push(pizza)\n\n        popped_pizza = stack.pop()\n        assert popped_pizza.name == \"Margherita\"\n        assert stack.is_empty()\n\n# Mock with proper type hints:\nclass TestPizzaHandler:\n    def setup_method(self) -&gt; None:\n        \"\"\"Setup mocks with proper type hints.\"\"\"\n        self.mock_repository: Mock = Mock(spec=PizzaRepository)\n        self.handler: CreatePizzaHandler = CreatePizzaHandler(self.mock_repository)\n\n    async def test_create_pizza_success(self) -&gt; None:\n        \"\"\"Test successful pizza creation.\"\"\"\n        # Setup mock\n        self.mock_repository.save_async = AsyncMock()\n\n        # Create command\n        command: CreatePizzaCommand = CreatePizzaCommand(\n            name=\"Test Pizza\",\n            price=15.99,\n            ingredients=[\"cheese\", \"tomato\"]\n        )\n\n        # Execute handler\n        result: Pizza = await self.handler.handle_async(command)\n\n        # Verify results\n        assert result.name == \"Test Pizza\"\n        assert result.price == 15.99\n        self.mock_repository.save_async.assert_called_once()\n</code></pre>"},{"location":"references/python_typing_guide/#type-checking-tools","title":"\ud83c\udfaf Type Checking Tools","text":""},{"location":"references/python_typing_guide/#using-mypy","title":"Using mypy","text":"<p>Add type checking to your development workflow:</p> <pre><code># Install mypy\npip install mypy\n\n# Check types in your code\nmypy src/\n\n# Configuration in mypy.ini:\n[mypy]\npython_version = 3.9\nwarn_return_any = True\nwarn_unused_configs = True\ndisallow_untyped_defs = True\n</code></pre> <p>Example mypy output:</p> <pre><code>src/api/controllers/pizza_controller.py:15: error: Function is missing a return type annotation\nsrc/application/handlers/pizza_handler.py:23: error: Argument 1 to \"save_async\" has incompatible type \"str\"; expected \"Pizza\"\n</code></pre>"},{"location":"references/python_typing_guide/#ide-support","title":"IDE Support","text":"<p>Modern IDEs use type hints to provide:</p> <ul> <li>Autocomplete: Suggests methods and attributes</li> <li>Error Detection: Highlights type mismatches</li> <li>Refactoring: Safely rename and move code</li> <li>Documentation: Shows parameter and return types</li> </ul> <pre><code># IDE will show you available methods on pizzas:\npizzas: List[Pizza] = await repository.get_all_async()\n# When you type \"pizzas.\" IDE shows: append, clear, copy, count, etc.\n\n# IDE catches type errors immediately:\npizza: Pizza = Pizza(\"1\", \"Margherita\", 12.99, [\"tomato\"])\npizza.price = \"expensive\"  # IDE warns: Cannot assign str to float\n</code></pre>"},{"location":"references/python_typing_guide/#best-practices","title":"\ud83d\ude80 Best Practices","text":""},{"location":"references/python_typing_guide/#1-start-simple-add-complexity-gradually","title":"1. Start Simple, Add Complexity Gradually","text":"<pre><code># Start with basic types:\ndef calculate_total(price: float, quantity: int) -&gt; float:\n    return price * quantity\n\n# Add more specific types as needed:\nfrom decimal import Decimal\n\ndef calculate_total_precise(price: Decimal, quantity: int) -&gt; Decimal:\n    return price * quantity\n\n# Use generics for reusable components:\nT = TypeVar('T')\n\ndef get_or_default(items: List[T], index: int, default: T) -&gt; T:\n    return items[index] if 0 &lt;= index &lt; len(items) else default\n</code></pre>"},{"location":"references/python_typing_guide/#2-use-type-aliases-for-complex-types","title":"2. Use Type Aliases for Complex Types","text":"<pre><code>from typing import Dict, List, Tuple, TypeAlias\n\n# Create aliases for readability:\nPizzaMenu: TypeAlias = Dict[str, float]\nOrderItem: TypeAlias = Tuple[str, int]  # (pizza_name, quantity)\nCustomerOrder: TypeAlias = Dict[str, List[OrderItem]]\n\ndef process_orders(orders: CustomerOrder) -&gt; Dict[str, float]:\n    \"\"\"Process customer orders and return totals.\"\"\"\n    totals: Dict[str, float] = {}\n\n    for customer_id, items in orders.items():\n        total = 0.0\n        for pizza_name, quantity in items:\n            # ... calculation logic\n            pass\n        totals[customer_id] = total\n\n    return totals\n</code></pre>"},{"location":"references/python_typing_guide/#3-use-descriptive-type-variable-names","title":"3. Use Descriptive Type Variable Names","text":"<pre><code># Good - descriptive names:\nTEntity = TypeVar('TEntity')\nTId = TypeVar('TId')\nTRequest = TypeVar('TRequest')\nTResponse = TypeVar('TResponse')\n\n# Avoid - generic names unless appropriate:\nT = TypeVar('T')  # Only use for truly generic cases\n</code></pre>"},{"location":"references/python_typing_guide/#4-provide-type-bounds-when-appropriate","title":"4. Provide Type Bounds When Appropriate","text":"<pre><code># Good - constrained when you need specific capabilities:\nfrom typing import Protocol\n\nclass Serializable(Protocol):\n    def to_dict(self) -&gt; dict: ...\n\nTSerializable = TypeVar('TSerializable', bound=Serializable)\n\nclass ApiService(Generic[TSerializable]):\n    async def send_data(self, data: TSerializable) -&gt; None:\n        json_data = data.to_dict()  # Safe - we know it has to_dict()\n        # ... send to API\n</code></pre>"},{"location":"references/python_typing_guide/#5-document-complex-types","title":"5. Document Complex Types","text":"<pre><code>from typing import NewType, Dict, List\n\n# Create semantic types:\nCustomerId = NewType('CustomerId', str)\nPizzaId = NewType('PizzaId', str)\nPrice = NewType('Price', float)\n\nclass OrderService:\n    \"\"\"Service for processing pizza orders.\"\"\"\n\n    def calculate_order_total(\n        self,\n        customer_id: CustomerId,\n        items: Dict[PizzaId, int]  # pizza_id -&gt; quantity\n    ) -&gt; Price:\n        \"\"\"\n        Calculate total price for a customer's order.\n\n        Args:\n            customer_id: Unique identifier for the customer\n            items: Dictionary mapping pizza IDs to quantities\n\n        Returns:\n            Total price for the order\n\n        Raises:\n            ValueError: If any pizza ID is not found\n        \"\"\"\n        # Implementation here...\n        pass\n</code></pre>"},{"location":"references/python_typing_guide/#6-handle-optional-values-explicitly","title":"6. Handle Optional Values Explicitly","text":"<pre><code>from typing import Optional\n\n# Be explicit about None handling:\ndef get_customer_name(customer_id: str) -&gt; Optional[str]:\n    \"\"\"Get customer name, returns None if not found.\"\"\"\n    # Database lookup...\n    return customer_name if found else None\n\ndef format_greeting(customer_id: str) -&gt; str:\n    \"\"\"Create personalized greeting.\"\"\"\n    name = get_customer_name(customer_id)\n\n    if name is not None:\n        return f\"Hello, {name}!\"\n    else:\n        return \"Hello, valued customer!\"\n\n# Or use walrus operator (Python 3.8+):\ndef format_greeting_modern(customer_id: str) -&gt; str:\n    \"\"\"Create personalized greeting using walrus operator.\"\"\"\n    if (name := get_customer_name(customer_id)) is not None:\n        return f\"Hello, {name}!\"\n    else:\n        return \"Hello, valued customer!\"\n</code></pre>"},{"location":"references/python_typing_guide/#7-use-protocols-for-duck-typing","title":"7. Use Protocols for Duck Typing","text":"<pre><code>from typing import Protocol\n\nclass Serializable(Protocol):\n    \"\"\"Protocol for objects that can be serialized.\"\"\"\n    def to_dict(self) -&gt; Dict[str, any]:\n        \"\"\"Convert object to dictionary representation.\"\"\"\n        ...\n\nclass Jsonifiable(Protocol):\n    \"\"\"Protocol for objects that can be converted to JSON.\"\"\"\n    def to_json(self) -&gt; str:\n        \"\"\"Convert object to JSON string.\"\"\"\n        ...\n\n# Function that works with any serializable object:\ndef save_to_database(obj: Serializable) -&gt; None:\n    \"\"\"Save any serializable object to database.\"\"\"\n    data = obj.to_dict()\n    # Database save logic...\n\n# Both Pizza and Customer can implement Serializable:\nclass Pizza:\n    def to_dict(self) -&gt; Dict[str, any]:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"price\": self.price,\n            \"ingredients\": self.ingredients\n        }\n\nclass Customer:\n    def to_dict(self) -&gt; Dict[str, any]:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"email\": self.email\n        }\n\n# Both work with save_to_database:\npizza = Pizza(\"1\", \"Margherita\", 12.99, [\"tomato\", \"mozzarella\"])\ncustomer = Customer(\"c1\", \"Mario\", \"mario@pizzeria.com\")\n\nsave_to_database(pizza)     # \u2705 Works\nsave_to_database(customer)  # \u2705 Works\n</code></pre>"},{"location":"references/python_typing_guide/#common-pitfalls-to-avoid","title":"\u274c Common Pitfalls to Avoid","text":""},{"location":"references/python_typing_guide/#1-overusing-any","title":"1. Overusing <code>Any</code>","text":"<pre><code>from typing import Any\n\n# \u274c Avoid - defeats the purpose of type hints:\ndef process_data(data: Any) -&gt; Any:\n    return data.some_method()\n\n# \u2705 Better - be specific:\ndef process_pizza_data(pizza: Pizza) -&gt; PizzaDto:\n    return PizzaDto(\n        id=pizza.id,\n        name=pizza.name,\n        price=pizza.price,\n        ingredients=pizza.ingredients,\n        is_available=pizza.is_available\n    )\n\n# \u2705 Or use generics if truly generic:\nT = TypeVar('T')\n\ndef process_data(data: T, processor: Callable[[T], str]) -&gt; str:\n    return processor(data)\n</code></pre>"},{"location":"references/python_typing_guide/#2-mixing-union-and-optional-incorrectly","title":"2. Mixing Union and Optional Incorrectly","text":"<pre><code># \u274c Wrong - Optional[T] is equivalent to Union[T, None]:\ndef get_pizza(id: str) -&gt; Union[Pizza, None]:  # Redundant\n    pass\n\ndef get_pizza_wrong(id: str) -&gt; Optional[Pizza, str]:  # Error!\n    pass\n\n# \u2705 Correct usage:\ndef get_pizza(id: str) -&gt; Optional[Pizza]:  # Returns Pizza or None\n    pass\n\ndef get_pizza_or_error(id: str) -&gt; Union[Pizza, str]:  # Returns Pizza or error message\n    pass\n</code></pre>"},{"location":"references/python_typing_guide/#3-runtime-type-checking-with-generics","title":"3. Runtime Type Checking with Generics","text":"<pre><code># \u274c Wrong - generics are erased at runtime:\ndef bad_function(value: T) -&gt; str:\n    if isinstance(value, str):  # This works, but defeats the purpose\n        return value\n    return str(value)\n\n# \u2705 Better - use proper type bounds:\nStrOrConvertible = TypeVar('StrOrConvertible', str, int, float)\n\ndef good_function(value: StrOrConvertible) -&gt; str:\n    return str(value)\n</code></pre>"},{"location":"references/python_typing_guide/#4-overcomplicating-simple-cases","title":"4. Overcomplicating Simple Cases","text":"<pre><code># \u274c Overkill for simple functions:\nT = TypeVar('T')\ndef identity(x: T) -&gt; T:\n    return x\n\n# \u2705 Simple functions often don't need generics:\ndef identity(x):\n    return x\n</code></pre>"},{"location":"references/python_typing_guide/#5-missing-type-bounds","title":"5. Missing Type Bounds","text":"<pre><code># \u274c Too permissive - might not have needed methods:\nT = TypeVar('T')\n\ndef sort_and_print(items: List[T]) -&gt; None:\n    sorted_items = sorted(items)  # Might fail if T doesn't support comparison\n    print(sorted_items)\n\n# \u2705 Use bounds when you need specific capabilities:\nfrom typing import Protocol\n\nclass Comparable(Protocol):\n    def __lt__(self, other: 'Comparable') -&gt; bool: ...\n\nT = TypeVar('T', bound=Comparable)\n\ndef sort_and_print(items: List[T]) -&gt; None:\n    sorted_items = sorted(items)  # Safe - T is guaranteed to be comparable\n    print(sorted_items)\n</code></pre>"},{"location":"references/python_typing_guide/#6-not-using-forward-references","title":"6. Not Using Forward References","text":"<pre><code># \u274c This might cause issues if Order references Customer and vice versa:\nclass Customer:\n    def __init__(self, name: str):\n        self.name = name\n        self.orders: List[Order] = []  # Error: Order not defined yet\n\nclass Order:\n    def __init__(self, customer: Customer):\n        self.customer = customer\n\n# \u2705 Use string forward references:\nfrom typing import List, TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from .order import Order\n\nclass Customer:\n    def __init__(self, name: str):\n        self.name = name\n        self.orders: List['Order'] = []  # Forward reference\n\n# \u2705 Or use `from __future__ import annotations` (Python 3.7+):\nfrom __future__ import annotations\nfrom typing import List\n\nclass Customer:\n    def __init__(self, name: str):\n        self.name = name\n        self.orders: List[Order] = []  # Works without quotes\n\nclass Order:\n    def __init__(self, customer: Customer):\n        self.customer = customer\n</code></pre>"},{"location":"references/python_typing_guide/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Python Object-Oriented Programming - Classes, inheritance, and composition patterns</li> <li>Python Modular Code - Module organization and import patterns</li> <li>CQRS &amp; Mediation - Type-safe command/query patterns in the framework</li> <li>MVC Controllers - Type-safe API development techniques</li> <li>Data Access - Repository patterns with full type safety</li> </ul>"},{"location":"references/python_typing_guide/#further-reading","title":"\ud83d\udcda Further Reading","text":"<ul> <li>PEP 484 - Type Hints - Original type hints specification</li> <li>PEP 526 - Variable Annotations - Variable type annotations</li> <li>PEP 585 - Type Hinting Generics - Built-in generic types</li> <li>Python typing module documentation - Official typing reference</li> <li>mypy documentation - Static type checker documentation</li> <li>Real Python: Type Checking - Comprehensive typing tutorial</li> <li>FastAPI and Type Hints - Type hints in web development</li> </ul>"},{"location":"references/source_code_naming_convention/","title":"\ud83c\udff7\ufe0f Source Code Naming Conventions","text":"<p>Consistent naming conventions are crucial for maintainable, readable, and professional codebases. The Neuroglia framework follows Python's established conventions while adding domain-specific patterns for clean architecture. This reference provides comprehensive guidelines for naming across all layers of your application.</p>"},{"location":"references/source_code_naming_convention/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>When to use snake_case vs CamelCase vs PascalCase across different contexts</li> <li>Naming patterns for entities, events, handlers, controllers, and methods</li> <li>Layer-specific conventions that enforce clean architecture boundaries</li> <li>Benefits of consistent naming conventions for team productivity</li> <li>Mario's Pizzeria examples demonstrating proper naming in practice</li> </ul>"},{"location":"references/source_code_naming_convention/#benefits-of-naming-conventions","title":"\ud83d\udccb Benefits of Naming Conventions","text":""},{"location":"references/source_code_naming_convention/#cognitive-load-reduction","title":"\ud83e\udde0 Cognitive Load Reduction","text":"<p>Consistent patterns reduce mental overhead when reading code. Developers can instantly identify the purpose and layer of any component based on its name.</p>"},{"location":"references/source_code_naming_convention/#team-collaboration","title":"\ud83d\udc65 Team Collaboration","text":"<p>Standardized naming eliminates debates about \"what to call this\" and ensures new team members can navigate the codebase intuitively.</p>"},{"location":"references/source_code_naming_convention/#searchability-navigation","title":"\ud83d\udd0d Searchability &amp; Navigation","text":"<p>Well-named components are easier to find using IDE search, grep, and other tools. Consistent patterns enable powerful refactoring operations.</p>"},{"location":"references/source_code_naming_convention/#architecture-enforcement","title":"\ud83c\udfd7\ufe0f Architecture Enforcement","text":"<p>Naming conventions reinforce clean architecture boundaries - you can immediately tell if a component violates layer dependencies.</p>"},{"location":"references/source_code_naming_convention/#productivity-maintenance","title":"\ud83d\ude80 Productivity &amp; Maintenance","text":"<p>Less time spent deciphering unclear names means more time focused on business logic and feature development.</p>"},{"location":"references/source_code_naming_convention/#python-language-conventions","title":"\ud83d\udc0d Python Language Conventions","text":"<p>The framework strictly follows PEP 8 and Python naming conventions as the foundation:</p>"},{"location":"references/source_code_naming_convention/#snake_case-usage","title":"snake_case Usage","text":"<p>Files and Modules:</p> <pre><code># \u2705 Correct\nuser_service.py\ncreate_order_command.py\nbank_account_repository.py\n\n# \u274c Incorrect\nUserService.py\nCreateOrderCommand.py\nBankAccount-Repository.py\n</code></pre> <p>Variables and Functions:</p> <pre><code># \u2705 Correct\nuser_name = \"Mario\"\ntotal_amount = calculate_order_total()\norder_placed_at = datetime.now()\n\ndef process_payment_async(amount: Decimal) -&gt; bool:\n    pass\n\n# \u274c Incorrect\nuserName = \"Mario\"\ntotalAmount = calculateOrderTotal()\nOrderPlacedAt = datetime.now()\n\ndef ProcessPaymentAsync(amount: Decimal) -&gt; bool:\n    pass\n</code></pre> <p>Method and Attribute Names:</p> <pre><code>class Pizza:\n    def __init__(self):\n        self.pizza_name = \"\"        # snake_case attributes\n        self.base_price = Decimal(\"0\")\n        self.available_sizes = []\n\n    def calculate_total_price(self):  # snake_case methods\n        pass\n\n    async def save_to_database_async(self):  # async suffix\n        pass\n</code></pre>"},{"location":"references/source_code_naming_convention/#pascalcase-usage","title":"PascalCase Usage","text":"<p>Classes, Types, and Interfaces:</p> <pre><code># \u2705 Correct - Classes\nclass OrderService:\n    pass\n\nclass CreatePizzaCommand:\n    pass\n\nclass PizzaOrderHandler:\n    pass\n\n# \u2705 Correct - Type Variables\nTEntity = TypeVar(\"TEntity\")\nTKey = TypeVar(\"TKey\")\nTResult = TypeVar(\"TResult\")\n\n# \u2705 Correct - Exceptions\nclass ValidationException(Exception):\n    pass\n\nclass OrderNotFoundException(Exception):\n    pass\n</code></pre> <p>Enums:</p> <pre><code>class OrderStatus(Enum):\n    PENDING = \"pending\"\n    CONFIRMED = \"confirmed\"\n    PREPARING = \"preparing\"\n    READY = \"ready\"\n    DELIVERED = \"delivered\"\n    CANCELLED = \"cancelled\"\n</code></pre>"},{"location":"references/source_code_naming_convention/#upper_case-usage","title":"UPPER_CASE Usage","text":"<p>Constants:</p> <pre><code># \u2705 Correct - Module-level constants\nDEFAULT_PIZZA_SIZE = \"medium\"\nMAX_ORDER_ITEMS = 20\nAPI_BASE_URL = \"https://api.mariospizza.com\"\n\n# \u2705 Correct - Class constants\nclass PizzaService:\n    DEFAULT_COOKING_TIME = 15  # minutes\n    MAX_TOPPINGS_PER_PIZZA = 8\n</code></pre>"},{"location":"references/source_code_naming_convention/#layer-specific-naming-conventions","title":"\ud83c\udfd7\ufe0f Layer-Specific Naming Conventions","text":"<p>The framework enforces different naming patterns for each architectural layer to maintain clean separation of concerns.</p>"},{"location":"references/source_code_naming_convention/#api-layer-api","title":"\ud83c\udf10 API Layer (<code>api/</code>)","text":"<p>The API layer handles HTTP requests and responses, following REST conventions.</p> <p>Controllers:</p> <pre><code># Pattern: {Entity}Controller (PascalCase)\nclass PizzasController(ControllerBase):\n    pass\n\nclass OrdersController(ControllerBase):\n    pass\n\nclass CustomersController(ControllerBase):\n    pass\n\n# \u274c Avoid\nclass PizzaController:      # Singular form\nclass Pizza_Controller:     # snake_case\nclass pizzaController:      # camelCase\n</code></pre> <p>Controller Methods:</p> <pre><code>class PizzasController(ControllerBase):\n    # Pattern: HTTP verb + descriptive name (snake_case)\n    @get(\"/{pizza_id}\")\n    async def get_pizza(self, pizza_id: str) -&gt; PizzaDto:\n        pass\n\n    @post(\"/\")\n    async def create_pizza(self, pizza_dto: CreatePizzaDto) -&gt; PizzaDto:\n        pass\n\n    @put(\"/{pizza_id}\")\n    async def update_pizza(self, pizza_id: str, pizza_dto: UpdatePizzaDto) -&gt; PizzaDto:\n        pass\n\n    @delete(\"/{pizza_id}\")\n    async def delete_pizza(self, pizza_id: str) -&gt; None:\n        pass\n\n    # Complex operations get descriptive names\n    @post(\"/{pizza_id}/customize\")\n    async def customize_pizza_toppings(self, pizza_id: str, toppings: List[str]) -&gt; PizzaDto:\n        pass\n</code></pre> <p>DTOs (Data Transfer Objects):</p> <pre><code># Pattern: {Purpose}{Entity}Dto (PascalCase)\n@dataclass\nclass PizzaDto:\n    pizza_id: str           # snake_case fields\n    pizza_name: str\n    base_price: Decimal\n    available_sizes: List[str]\n\n@dataclass\nclass CreatePizzaDto:\n    pizza_name: str\n    base_price: Decimal\n    ingredient_ids: List[str]\n\n@dataclass\nclass UpdatePizzaDto:\n    pizza_name: Optional[str] = None\n    base_price: Optional[Decimal] = None\n\n# Specialized DTOs\n@dataclass\nclass PizzaMenuItemDto:     # Specific context\n    pass\n\n@dataclass\nclass PizzaInventoryDto:    # Different view\n    pass\n</code></pre>"},{"location":"references/source_code_naming_convention/#application-layer-application","title":"\ud83d\udcbc Application Layer (<code>application/</code>)","text":"<p>The application layer orchestrates business operations through commands, queries, and handlers.</p> <p>Commands (Write Operations):</p> <pre><code># Pattern: {Verb}{Entity}Command (PascalCase)\n@dataclass\nclass CreatePizzaCommand(Command[OperationResult[PizzaDto]]):\n    pizza_name: str         # snake_case fields\n    base_price: Decimal\n    ingredient_ids: List[str]\n\n@dataclass\nclass UpdatePizzaCommand(Command[OperationResult[PizzaDto]]):\n    pizza_id: str\n    pizza_name: Optional[str] = None\n    base_price: Optional[Decimal] = None\n\n@dataclass\nclass DeletePizzaCommand(Command[OperationResult]):\n    pizza_id: str\n\n# Complex business operations\n@dataclass\nclass ProcessOrderPaymentCommand(Command[OperationResult[PaymentDto]]):\n    order_id: str\n    payment_method: PaymentMethod\n    amount: Decimal\n</code></pre> <p>Queries (Read Operations):</p> <pre><code># Pattern: {Action}{Entity}Query (PascalCase)\n@dataclass\nclass GetPizzaByIdQuery(Query[PizzaDto]):\n    pizza_id: str\n\n@dataclass\nclass GetPizzasByTypeQuery(Query[List[PizzaDto]]):\n    pizza_type: PizzaType\n    include_unavailable: bool = False\n\n@dataclass\nclass SearchPizzasQuery(Query[List[PizzaDto]]):\n    search_term: str\n    max_results: int = 50\n\n# Complex queries with business logic\n@dataclass\nclass GetPopularPizzasForRegionQuery(Query[List[PizzaDto]]):\n    region_code: str\n    date_range: DateRange\n    min_order_count: int = 10\n</code></pre> <p>Handlers:</p> <pre><code># Pattern: {Command/Query}Handler (PascalCase)\nclass CreatePizzaCommandHandler(CommandHandler[CreatePizzaCommand, OperationResult[PizzaDto]]):\n    def __init__(self,\n                 pizza_repository: PizzaRepository,\n                 mapper: Mapper,\n                 event_bus: EventBus):\n        self._pizza_repository = pizza_repository    # snake_case fields\n        self._mapper = mapper\n        self._event_bus = event_bus\n\n    async def handle_async(self, command: CreatePizzaCommand) -&gt; OperationResult[PizzaDto]:\n        # snake_case method names and variables\n        validation_result = await self._validate_command(command)\n        if not validation_result.is_success:\n            return validation_result\n\n        pizza = Pizza(\n            name=command.pizza_name,\n            base_price=command.base_price\n        )\n\n        await self._pizza_repository.save_async(pizza)\n\n        # Raise domain event\n        pizza_created_event = PizzaCreatedEvent(\n            pizza_id=pizza.id,\n            pizza_name=pizza.name\n        )\n        await self._event_bus.publish_async(pizza_created_event)\n\n        return self.created(self._mapper.map(pizza, PizzaDto))\n</code></pre> <p>Services:</p> <pre><code># Pattern: {Entity}Service or {Purpose}Service (PascalCase)\nclass PizzaService:\n    async def calculate_cooking_time_async(self, pizza: Pizza) -&gt; int:\n        pass\n\n    async def check_ingredient_availability_async(self, ingredients: List[str]) -&gt; bool:\n        pass\n\nclass OrderService:\n    async def process_order_async(self, order: Order) -&gt; OperationResult[Order]:\n        pass\n\nclass PaymentService:\n    async def process_payment_async(self, payment_info: PaymentInfo) -&gt; PaymentResult:\n        pass\n\n# Specialized services\nclass PizzaRecommendationService:\n    pass\n\nclass OrderNotificationService:\n    pass\n</code></pre>"},{"location":"references/source_code_naming_convention/#domain-layer-domain","title":"\ud83c\udfdb\ufe0f Domain Layer (<code>domain/</code>)","text":"<p>The domain layer contains core business logic and entities, following domain-driven design principles.</p> <p>Entities:</p> <pre><code># Pattern: {BusinessConcept} (PascalCase, singular)\nclass Pizza(Entity[str]):\n    def __init__(self, name: str, base_price: Decimal):\n        super().__init__()\n        self.name = name                    # snake_case attributes\n        self.base_price = base_price\n        self.available_sizes = []\n        self.created_at = datetime.now()\n\n    # Business method names in snake_case\n    def add_ingredient(self, ingredient: Ingredient) -&gt; None:\n        if not self.can_add_ingredient(ingredient):\n            raise BusinessRuleViolation(\"Cannot add ingredient to pizza\")\n\n        self.ingredients.append(ingredient)\n        self.raise_event(IngredientAddedEvent(self.id, ingredient.id))\n\n    def calculate_total_price(self, size: PizzaSize) -&gt; Decimal:\n        base_cost = self.base_price * size.price_multiplier\n        ingredient_cost = sum(i.price for i in self.ingredients)\n        return base_cost + ingredient_cost\n\n    def can_add_ingredient(self, ingredient: Ingredient) -&gt; bool:\n        # Business rules\n        return len(self.ingredients) &lt; self.MAX_INGREDIENTS\n\nclass Order(Entity[str]):\n    def __init__(self, customer_id: str):\n        super().__init__()\n        self.customer_id = customer_id\n        self.order_items = []\n        self.status = OrderStatus.PENDING\n        self.total_amount = Decimal(\"0\")\n\n    def add_pizza(self, pizza: Pizza, quantity: int) -&gt; None:\n        if self.status != OrderStatus.PENDING:\n            raise BusinessRuleViolation(\"Cannot modify confirmed order\")\n\n        order_item = OrderItem(pizza, quantity)\n        self.order_items.append(order_item)\n        self._recalculate_total()\n\n        self.raise_event(PizzaAddedToOrderEvent(self.id, pizza.id, quantity))\n</code></pre> <p>Value Objects:</p> <pre><code># Pattern: {Concept} (PascalCase, represents a value)\n@dataclass(frozen=True)\nclass Money:\n    amount: Decimal\n    currency: str = \"USD\"\n\n    def add(self, other: 'Money') -&gt; 'Money':\n        if self.currency != other.currency:\n            raise ValueError(\"Cannot add different currencies\")\n        return Money(self.amount + other.amount, self.currency)\n\n@dataclass(frozen=True)\nclass Address:\n    street: str\n    city: str\n    state: str\n    zip_code: str\n    country: str = \"USA\"\n\n    def to_display_string(self) -&gt; str:\n        return f\"{self.street}, {self.city}, {self.state} {self.zip_code}\"\n\n@dataclass(frozen=True)\nclass EmailAddress:\n    value: str\n\n    def __post_init__(self):\n        if \"@\" not in self.value:\n            raise ValueError(\"Invalid email address\")\n</code></pre> <p>Domain Events:</p> <pre><code># Pattern: {Entity}{Action}Event (PascalCase)\n@dataclass\nclass PizzaCreatedEvent(DomainEvent[str]):\n    pizza_id: str\n    pizza_name: str\n    created_by: str\n    created_at: datetime = field(default_factory=datetime.now)\n\n@dataclass\nclass OrderConfirmedEvent(DomainEvent[str]):\n    order_id: str\n    customer_id: str\n    total_amount: Decimal\n    estimated_delivery: datetime\n\n@dataclass\nclass PaymentProcessedEvent(DomainEvent[str]):\n    payment_id: str\n    order_id: str\n    amount: Decimal\n    payment_method: str\n\n# Complex business events\n@dataclass\nclass PizzaCustomizationCompletedEvent(DomainEvent[str]):\n    pizza_id: str\n    customization_options: Dict[str, Any]\n    final_price: Decimal\n</code></pre> <p>Repository Interfaces:</p> <pre><code># Pattern: {Entity}Repository (PascalCase)\nclass PizzaRepository(Repository[Pizza, str]):\n    @abstractmethod\n    async def get_by_name_async(self, name: str) -&gt; Optional[Pizza]:\n        pass\n\n    @abstractmethod\n    async def get_popular_pizzas_async(self, limit: int = 10) -&gt; List[Pizza]:\n        pass\n\n    @abstractmethod\n    async def search_by_ingredients_async(self, ingredients: List[str]) -&gt; List[Pizza]:\n        pass\n\nclass OrderRepository(Repository[Order, str]):\n    @abstractmethod\n    async def get_by_customer_id_async(self, customer_id: str) -&gt; List[Order]:\n        pass\n\n    @abstractmethod\n    async def get_pending_orders_async(self) -&gt; List[Order]:\n        pass\n</code></pre> <p>Business Exceptions:</p> <pre><code># Pattern: {Reason}Exception (PascalCase)\nclass BusinessRuleViolation(Exception):\n    def __init__(self, message: str, rule_name: str = None):\n        super().__init__(message)\n        self.rule_name = rule_name\n\nclass PizzaNotAvailableException(BusinessRuleViolation):\n    def __init__(self, pizza_name: str):\n        super().__init__(f\"Pizza '{pizza_name}' is not available\")\n        self.pizza_name = pizza_name\n\nclass InsufficientInventoryException(BusinessRuleViolation):\n    def __init__(self, ingredient_name: str, requested: int, available: int):\n        super().__init__(f\"Insufficient {ingredient_name}: requested {requested}, available {available}\")\n        self.ingredient_name = ingredient_name\n</code></pre>"},{"location":"references/source_code_naming_convention/#integration-layer-integration","title":"\ud83d\udd0c Integration Layer (<code>integration/</code>)","text":"<p>The integration layer handles external systems, databases, and infrastructure concerns.</p> <p>Repository Implementations:</p> <pre><code># Pattern: {Technology}{Entity}Repository (PascalCase)\nclass MongoDbPizzaRepository(PizzaRepository):\n    def __init__(self, database: Database):\n        self._collection = database.pizzas    # snake_case field\n\n    async def save_async(self, pizza: Pizza) -&gt; None:\n        pizza_doc = {\n            \"_id\": pizza.id,\n            \"name\": pizza.name,\n            \"base_price\": float(pizza.base_price),\n            \"ingredients\": [i.to_dict() for i in pizza.ingredients],\n            \"created_at\": pizza.created_at.isoformat()\n        }\n        await self._collection.insert_one(pizza_doc)\n\n    async def get_by_id_async(self, pizza_id: str) -&gt; Optional[Pizza]:\n        doc = await self._collection.find_one({\"_id\": pizza_id})\n        return self._map_to_pizza(doc) if doc else None\n\nclass InMemoryPizzaRepository(PizzaRepository):\n    def __init__(self):\n        self._store: Dict[str, Pizza] = {}    # snake_case field\n\n    async def save_async(self, pizza: Pizza) -&gt; None:\n        self._store[pizza.id] = pizza\n</code></pre> <p>External Service Clients:</p> <pre><code># Pattern: {Service}Client or {System}Service (PascalCase)\nclass PaymentGatewayClient:\n    def __init__(self, api_key: str, base_url: str):\n        self._api_key = api_key\n        self._base_url = base_url\n        self._http_client = httpx.AsyncClient()\n\n    async def process_payment_async(self, payment_request: PaymentRequest) -&gt; PaymentResponse:\n        pass\n\n    async def refund_payment_async(self, transaction_id: str) -&gt; RefundResponse:\n        pass\n\nclass EmailNotificationService:\n    async def send_order_confirmation_async(self, order: Order, customer_email: str) -&gt; None:\n        pass\n\n    async def send_delivery_notification_async(self, order: Order) -&gt; None:\n        pass\n\nclass InventoryManagementService:\n    async def check_ingredient_availability_async(self, ingredient_id: str) -&gt; int:\n        pass\n\n    async def reserve_ingredients_async(self, reservations: List[IngredientReservation]) -&gt; bool:\n        pass\n</code></pre> <p>Configuration Models:</p> <pre><code># Pattern: {Purpose}Settings or {System}Config (PascalCase)\nclass DatabaseSettings(BaseSettings):\n    connection_string: str           # snake_case fields\n    database_name: str\n    connection_timeout: int = 30\n\n    class Config:\n        env_prefix = \"DATABASE_\"\n\nclass ApiSettings(BaseSettings):\n    host: str = \"0.0.0.0\"\n    port: int = 8000\n    debug: bool = False\n    cors_origins: List[str] = [\"*\"]\n\nclass PaymentGatewaySettings(BaseSettings):\n    api_key: str\n    webhook_secret: str\n    sandbox_mode: bool = True\n    timeout_seconds: int = 30\n</code></pre>"},{"location":"references/source_code_naming_convention/#testing-naming-conventions","title":"\ud83e\uddea Testing Naming Conventions","text":"<p>Consistent test naming makes it easy to understand what's being tested and why tests might be failing.</p>"},{"location":"references/source_code_naming_convention/#test-files","title":"Test Files","text":"<pre><code># Pattern: test_{module_under_test}.py\ntest_pizza_service.py\ntest_order_controller.py\ntest_create_pizza_command_handler.py\ntest_mongo_pizza_repository.py\n</code></pre>"},{"location":"references/source_code_naming_convention/#test-classes","title":"Test Classes","text":"<pre><code># Pattern: Test{ClassUnderTest}\nclass TestPizzaService:\n    pass\n\nclass TestCreatePizzaCommandHandler:\n    pass\n\nclass TestOrderController:\n    pass\n</code></pre>"},{"location":"references/source_code_naming_convention/#test-methods","title":"Test Methods","text":"<pre><code>class TestPizzaService:\n    # Pattern: test_{method}_{scenario}_{expected_result}\n    def test_calculate_total_price_with_large_pizza_returns_correct_amount(self):\n        pass\n\n    def test_add_ingredient_with_max_ingredients_raises_exception(self):\n        pass\n\n    def test_create_pizza_with_valid_data_returns_success(self):\n        pass\n\n    # Async tests\n    @pytest.mark.asyncio\n    async def test_save_pizza_async_with_valid_data_saves_successfully(self):\n        pass\n\n    @pytest.mark.asyncio\n    async def test_get_pizza_by_id_async_with_nonexistent_id_returns_none(self):\n        pass\n</code></pre>"},{"location":"references/source_code_naming_convention/#test-fixtures-and-utilities","title":"Test Fixtures and Utilities","text":"<pre><code># Pattern: create_{entity} or {entity}_fixture\n@pytest.fixture\ndef pizza_fixture():\n    return Pizza(name=\"Margherita\", base_price=Decimal(\"12.99\"))\n\n@pytest.fixture\ndef customer_fixture():\n    return Customer(name=\"Mario\", email=\"mario@test.com\")\n\ndef create_test_pizza(name: str = \"Test Pizza\") -&gt; Pizza:\n    return Pizza(name=name, base_price=Decimal(\"10.00\"))\n\ndef create_mock_repository() -&gt; Mock:\n    repository = Mock(spec=PizzaRepository)\n    repository.save_async.return_value = None\n    return repository\n</code></pre>"},{"location":"references/source_code_naming_convention/#case-conversion-patterns","title":"\ud83d\udd04 Case Conversion Patterns","text":"<p>The framework provides utilities to handle different naming conventions across system boundaries.</p>"},{"location":"references/source_code_naming_convention/#api-boundary-conversion","title":"API Boundary Conversion","text":"<pre><code># Internal Python code uses snake_case\nclass PizzaService:\n    def __init__(self):\n        self.total_price = Decimal(\"0\")      # snake_case\n        self.cooking_time = 15\n        self.ingredient_list = []\n\n# API DTOs can use camelCase for frontend compatibility\nclass PizzaDto(CamelModel):\n    pizza_name: str          # Becomes \"pizzaName\" in JSON\n    base_price: Decimal      # Becomes \"basePrice\" in JSON\n    cooking_time: int        # Becomes \"cookingTime\" in JSON\n    ingredient_list: List[str]  # Becomes \"ingredientList\" in JSON\n\n# Frontend receives camelCase JSON\n{\n    \"pizzaName\": \"Margherita\",\n    \"basePrice\": 12.99,\n    \"cookingTime\": 15,\n    \"ingredientList\": [\"tomato\", \"mozzarella\", \"basil\"]\n}\n</code></pre>"},{"location":"references/source_code_naming_convention/#database-field-mapping","title":"Database Field Mapping","text":"<pre><code># Python entity with snake_case\nclass Pizza(Entity):\n    def __init__(self):\n        self.pizza_name = \"\"         # snake_case in Python\n        self.base_price = Decimal(\"0\")\n        self.created_at = datetime.now()\n\n# MongoDB document mapping\npizza_document = {\n    \"pizza_name\": pizza.pizza_name,      # snake_case in database\n    \"base_price\": float(pizza.base_price),\n    \"created_at\": pizza.created_at.isoformat()\n}\n\n# SQL table with snake_case columns\nCREATE TABLE pizzas (\n    pizza_id UUID PRIMARY KEY,\n    pizza_name VARCHAR(100) NOT NULL,    -- snake_case columns\n    base_price DECIMAL(10,2) NOT NULL,\n    created_at TIMESTAMP DEFAULT NOW()\n);\n</code></pre>"},{"location":"references/source_code_naming_convention/#file-and-directory-naming","title":"\ud83d\udcc1 File and Directory Naming","text":"<p>Consistent file organization makes codebases navigable and maintainable.</p>"},{"location":"references/source_code_naming_convention/#file-naming-patterns","title":"File Naming Patterns","text":"<pre><code># \u2705 Correct - snake_case for all files\npizza_service.py\ncreate_order_command.py\nmongo_pizza_repository.py\norder_controller.py\npizza_created_event.py\n\n# \u274c Incorrect\nPizzaService.py\nCreateOrderCommand.py\nMongoPizzaRepository.py\nOrderController.py\n</code></pre>"},{"location":"references/source_code_naming_convention/#directory-structure","title":"Directory Structure","text":"<pre><code>src/marios_pizzeria/\n\u251c\u2500\u2500 api/                          # Layer directories\n\u2502   \u251c\u2500\u2500 controllers/              # Component type directories\n\u2502   \u2502   \u251c\u2500\u2500 pizzas_controller.py  # Plural for REST controllers\n\u2502   \u2502   \u251c\u2500\u2500 orders_controller.py\n\u2502   \u2502   \u2514\u2500\u2500 customers_controller.py\n\u2502   \u2514\u2500\u2500 dtos/\n\u2502       \u251c\u2500\u2500 pizza_dto.py          # Singular entity + dto\n\u2502       \u251c\u2500\u2500 create_pizza_dto.py   # Action + entity + dto\n\u2502       \u2514\u2500\u2500 order_dto.py\n\u251c\u2500\u2500 application/\n\u2502   \u251c\u2500\u2500 commands/\n\u2502   \u2502   \u251c\u2500\u2500 pizzas/               # Group by entity\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 create_pizza_command.py\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 update_pizza_command.py\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 delete_pizza_command.py\n\u2502   \u2502   \u2514\u2500\u2500 orders/\n\u2502   \u2502       \u251c\u2500\u2500 create_order_command.py\n\u2502   \u2502       \u2514\u2500\u2500 confirm_order_command.py\n\u2502   \u251c\u2500\u2500 queries/\n\u2502   \u2502   \u251c\u2500\u2500 get_pizza_by_id_query.py\n\u2502   \u2502   \u2514\u2500\u2500 search_pizzas_query.py\n\u2502   \u2514\u2500\u2500 handlers/\n\u2502       \u251c\u2500\u2500 create_pizza_handler.py\n\u2502       \u2514\u2500\u2500 process_order_handler.py\n\u251c\u2500\u2500 domain/\n\u2502   \u251c\u2500\u2500 entities/\n\u2502   \u2502   \u251c\u2500\u2500 pizza.py              # Singular entity names\n\u2502   \u2502   \u251c\u2500\u2500 order.py\n\u2502   \u2502   \u2514\u2500\u2500 customer.py\n\u2502   \u251c\u2500\u2500 events/\n\u2502   \u2502   \u251c\u2500\u2500 pizza_events.py       # Group related events\n\u2502   \u2502   \u2514\u2500\u2500 order_events.py\n\u2502   \u251c\u2500\u2500 repositories/\n\u2502   \u2502   \u251c\u2500\u2500 pizza_repository.py   # Abstract interfaces\n\u2502   \u2502   \u2514\u2500\u2500 order_repository.py\n\u2502   \u2514\u2500\u2500 exceptions/\n\u2502       \u251c\u2500\u2500 business_exceptions.py\n\u2502       \u2514\u2500\u2500 validation_exceptions.py\n\u2514\u2500\u2500 integration/\n    \u251c\u2500\u2500 repositories/\n    \u2502   \u251c\u2500\u2500 mongodb_pizza_repository.py  # Technology + entity + repository\n    \u2502   \u2514\u2500\u2500 postgres_order_repository.py\n    \u251c\u2500\u2500 services/\n    \u2502   \u251c\u2500\u2500 payment_gateway_client.py\n    \u2502   \u2514\u2500\u2500 email_notification_service.py\n    \u2514\u2500\u2500 configuration/\n        \u251c\u2500\u2500 database_settings.py\n        \u2514\u2500\u2500 api_settings.py\n</code></pre>"},{"location":"references/source_code_naming_convention/#common-anti-patterns-to-avoid","title":"\u26a1 Common Anti-Patterns to Avoid","text":""},{"location":"references/source_code_naming_convention/#inconsistent-casing","title":"\u274c Inconsistent Casing","text":"<pre><code># \u274c Mixed conventions in same context\nclass PizzaService:\n    def __init__(self):\n        self.pizzaName = \"\"          # camelCase in Python\n        self.base_price = Decimal(\"0\")  # snake_case\n        self.CookingTime = 15        # PascalCase\n\n# \u2705 Consistent snake_case\nclass PizzaService:\n    def __init__(self):\n        self.pizza_name = \"\"\n        self.base_price = Decimal(\"0\")\n        self.cooking_time = 15\n</code></pre>"},{"location":"references/source_code_naming_convention/#unclear-abbreviations","title":"\u274c Unclear Abbreviations","text":"<pre><code># \u274c Cryptic abbreviations\nclass PzSvc:           # Pizza Service?\n    def calc_ttl_prc(self):  # Calculate total price?\n        pass\n\ndef proc_ord(ord_id):  # Process order?\n    pass\n\n# \u2705 Clear, descriptive names\nclass PizzaService:\n    def calculate_total_price(self):\n        pass\n\ndef process_order(order_id: str):\n    pass\n</code></pre>"},{"location":"references/source_code_naming_convention/#misleading-names","title":"\u274c Misleading Names","text":"<pre><code># \u274c Name doesn't match behavior\nclass PizzaService:\n    def get_pizza(self, pizza_id: str):\n        # Actually creates and saves a new pizza!\n        pizza = Pizza(\"New Pizza\", Decimal(\"10.00\"))\n        self.repository.save(pizza)\n        return pizza\n\n# \u2705 Name matches behavior\nclass PizzaService:\n    def create_pizza(self, name: str, price: Decimal) -&gt; Pizza:\n        pizza = Pizza(name, price)\n        self.repository.save(pizza)\n        return pizza\n\n    def get_pizza(self, pizza_id: str) -&gt; Optional[Pizza]:\n        return self.repository.get_by_id(pizza_id)\n</code></pre>"},{"location":"references/source_code_naming_convention/#generic-names","title":"\u274c Generic Names","text":"<pre><code># \u274c Too generic\nclass Manager:\n    pass\n\nclass Helper:\n    pass\n\ndef process(data):\n    pass\n\n# \u2705 Specific and descriptive\nclass OrderManager:\n    pass\n\nclass PizzaValidationHelper:\n    pass\n\ndef process_payment_transaction(payment_info: PaymentInfo):\n    pass\n</code></pre>"},{"location":"references/source_code_naming_convention/#framework-specific-patterns","title":"\ud83c\udfaf Framework-Specific Patterns","text":""},{"location":"references/source_code_naming_convention/#command-and-query-naming","title":"Command and Query Naming","text":"<pre><code># Commands (imperative, action-oriented)\nclass CreatePizzaCommand:         # Create + Entity + Command\nclass UpdateOrderStatusCommand:   # Update + Entity + Attribute + Command\nclass ProcessPaymentCommand:      # Process + Concept + Command\nclass CancelOrderCommand:         # Cancel + Entity + Command\n\n# Queries (descriptive, question-oriented)\nclass GetPizzaByIdQuery:          # Get + Entity + Criteria + Query\nclass FindOrdersByCustomerQuery:  # Find + Entity + Criteria + Query\nclass SearchPizzasQuery:          # Search + Entity + Query\nclass CountActiveOrdersQuery:     # Count + Description + Query\n</code></pre>"},{"location":"references/source_code_naming_convention/#event-naming","title":"Event Naming","text":"<pre><code># Domain Events (past tense, what happened)\nclass PizzaCreatedEvent:          # Entity + Action + Event\nclass OrderConfirmedEvent:        # Entity + Action + Event\nclass PaymentProcessedEvent:      # Concept + Action + Event\nclass InventoryUpdatedEvent:      # System + Action + Event\n\n# Integration Events (external system communication)\nclass CustomerRegisteredIntegrationEvent:  # Action + Integration + Event\nclass OrderShippedIntegrationEvent:        # Action + Integration + Event\n</code></pre>"},{"location":"references/source_code_naming_convention/#repository-naming","title":"Repository Naming","text":"<pre><code># Abstract repositories (domain layer)\nclass PizzaRepository(Repository[Pizza, str]):\n    pass\n\n# Concrete implementations (integration layer)\nclass MongoDbPizzaRepository(PizzaRepository):\n    pass\n\nclass PostgreSqlOrderRepository(OrderRepository):\n    pass\n\nclass InMemoryCustomerRepository(CustomerRepository):  # For testing\n    pass\n</code></pre>"},{"location":"references/source_code_naming_convention/#best-practices-summary","title":"\ud83d\ude80 Best Practices Summary","text":""},{"location":"references/source_code_naming_convention/#dos","title":"\u2705 Do's","text":"<ol> <li>Be Consistent: Use the same patterns throughout your codebase</li> <li>Be Descriptive: Names should clearly indicate purpose and behavior</li> <li>Follow Layer Conventions: Different layers have different naming patterns</li> <li>Use Standard Suffixes: Command, Query, Handler, Repository, Service, etc.</li> <li>Group Related Items: Use directories and modules to organize related code</li> <li>Consider Context: API DTOs might need different casing than internal models</li> <li>Test Names Should Tell Stories: Long, descriptive test method names are good</li> </ol>"},{"location":"references/source_code_naming_convention/#donts","title":"\u274c Don'ts","text":"<ol> <li>Don't Mix Conventions: Pick snake_case or camelCase and stick to it within context</li> <li>Don't Use Abbreviations: Prefer <code>customer_service</code> over <code>cust_svc</code></li> <li>Don't Use Generic Names: Avoid <code>Manager</code>, <code>Helper</code>, <code>Utility</code> without context</li> <li>Don't Ignore Framework Patterns: Follow established Command/Query/Handler patterns</li> <li>Don't Violate Layer Naming: Controllers in API layer, Handlers in Application layer</li> <li>Don't Use Misleading Names: Names should match actual behavior</li> <li>Don't Skip Namespace Prefixes: Use clear module organization</li> </ol>"},{"location":"references/source_code_naming_convention/#marios-pizzeria-example","title":"\ud83c\udf55 Mario's Pizzeria Example","text":"<p>Here's how all these conventions work together in a complete feature:</p> <pre><code># Domain Layer - domain/entities/pizza.py\nclass Pizza(Entity[str]):\n    def __init__(self, name: str, base_price: Decimal):\n        super().__init__()\n        self.name = name\n        self.base_price = base_price\n        self.toppings = []\n\n    def add_topping(self, topping: Topping) -&gt; None:\n        if len(self.toppings) &gt;= self.MAX_TOPPINGS:\n            raise TooManyToppingsException(self.name)\n\n        self.toppings.append(topping)\n        self.raise_event(ToppingAddedEvent(self.id, topping.id))\n\n# Domain Layer - domain/events/pizza_events.py\n@dataclass\nclass PizzaCreatedEvent(DomainEvent[str]):\n    pizza_id: str\n    pizza_name: str\n    base_price: Decimal\n\n# Application Layer - application/commands/create_pizza_command.py\n@dataclass\nclass CreatePizzaCommand(Command[OperationResult[PizzaDto]]):\n    pizza_name: str\n    base_price: Decimal\n    topping_ids: List[str]\n\n# Application Layer - application/handlers/create_pizza_handler.py\nclass CreatePizzaCommandHandler(CommandHandler[CreatePizzaCommand, OperationResult[PizzaDto]]):\n    async def handle_async(self, command: CreatePizzaCommand) -&gt; OperationResult[PizzaDto]:\n        pizza = Pizza(command.pizza_name, command.base_price)\n        await self._pizza_repository.save_async(pizza)\n        return self.created(self._mapper.map(pizza, PizzaDto))\n\n# API Layer - api/controllers/pizzas_controller.py\nclass PizzasController(ControllerBase):\n    @post(\"/\", response_model=PizzaDto, status_code=201)\n    async def create_pizza(self, create_dto: CreatePizzaDto) -&gt; PizzaDto:\n        command = self.mapper.map(create_dto, CreatePizzaCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n# Integration Layer - integration/repositories/mongodb_pizza_repository.py\nclass MongoDbPizzaRepository(PizzaRepository):\n    async def save_async(self, pizza: Pizza) -&gt; None:\n        document = self._map_to_document(pizza)\n        await self._collection.insert_one(document)\n</code></pre> <p>This example demonstrates how naming conventions create a clear, navigable codebase where each component's purpose and location are immediately obvious.</p>"},{"location":"references/source_code_naming_convention/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Python Typing Guide - Complete guide to type hints, generics, and advanced typing patterns</li> <li>Python Object-Oriented Programming - OOP principles and class design</li> <li>CQRS &amp; Mediation - Command and query pattern implementation</li> <li>Dependency Injection - Service registration and naming patterns</li> </ul>"},{"location":"references/test-mermaid/","title":"Mermaid Test Page","text":"<p>This page tests Mermaid diagram rendering in MkDocs.</p>"},{"location":"references/test-mermaid/#basic-flowchart","title":"Basic Flowchart","text":"<pre><code>graph TD\n    A[Start] --&gt; B{Is it working?}\n    B --&gt;|Yes| C[Great!]\n    B --&gt;|No| D[Debug]\n    D --&gt; A\n    C --&gt; E[End]</code></pre>"},{"location":"references/test-mermaid/#sequence-diagram","title":"Sequence Diagram","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Controller\n    participant Service\n    participant Database\n\n    User-&gt;&gt;Controller: HTTP Request\n    Controller-&gt;&gt;Service: Business Logic\n    Service-&gt;&gt;Database: Query Data\n    Database--&gt;&gt;Service: Result\n    Service--&gt;&gt;Controller: Response\n    Controller--&gt;&gt;User: HTTP Response</code></pre>"},{"location":"references/test-mermaid/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>graph TB\n    subgraph \"Application Layer\"\n        A[Controllers] --&gt; B[Mediator]\n        B --&gt; C[Command Handlers]\n        B --&gt; D[Query Handlers]\n    end\n\n    subgraph \"Domain Layer\"\n        E[Entities] --&gt; F[Value Objects]\n        E --&gt; G[Domain Events]\n    end\n\n    subgraph \"Integration Layer\"\n        H[Repositories] --&gt; I[External APIs]\n        H --&gt; J[Database]\n    end\n\n    C --&gt; E\n    D --&gt; H\n    A --&gt; B</code></pre>"},{"location":"references/test-mermaid/#class-diagram","title":"Class Diagram","text":"<pre><code>classDiagram\n    class Controller {\n        +service_provider: ServiceProvider\n        +mediator: Mediator\n        +mapper: Mapper\n        +process(result: OperationResult): Response\n    }\n\n    class CommandHandler {\n        +handle_async(command: Command): OperationResult\n    }\n\n    class QueryHandler {\n        +handle_async(query: Query): Result\n    }\n\n    Controller --&gt; CommandHandler : uses\n    Controller --&gt; QueryHandler : uses\n    CommandHandler --&gt; Entity : creates/modifies\n    QueryHandler --&gt; Repository : reads from</code></pre>"},{"location":"samples/","title":"\ud83d\udcbc Sample Applications","text":"<p>Comprehensive sample applications that demonstrate real-world implementation of the Neuroglia framework. Each sample showcases different architectural patterns, integration scenarios, and business domains to provide practical guidance for building production-ready systems.</p>"},{"location":"samples/#production-ready-examples","title":"\ud83c\udfe6 Production-Ready Examples","text":""},{"location":"samples/#openbank-event-sourcing-banking-system","title":"\ud83c\udfe6 OpenBank - Event Sourcing Banking System","text":"<p>A complete banking system demonstrating event sourcing, CQRS, and financial domain modeling. Shows how to handle complex business rules, audit trails, and regulatory compliance.</p> <p>Domain Focus:</p> <ul> <li>Account management</li> <li>Transaction processing</li> <li>Balance calculations</li> <li>Regulatory compliance</li> </ul> <p>Key Patterns:</p> <ul> <li>Event sourcing with snapshots</li> <li>Complex domain aggregates</li> <li>Financial calculations with precision</li> <li>Audit trail implementation</li> </ul> <p>Technology Stack:</p> <ul> <li>EventStoreDB for event persistence</li> <li>MongoDB for read models</li> <li>FastAPI for REST APIs</li> <li>Comprehensive test coverage</li> </ul>"},{"location":"samples/#api-gateway-microservice-orchestration","title":"\ud83c\udf10 API Gateway - Microservice Orchestration","text":"<p>Demonstrates microservice coordination, request routing, and cross-cutting concerns like authentication, rate limiting, and monitoring.</p> <p>Domain Focus:</p> <ul> <li>Service discovery and routing</li> <li>Authentication and authorization</li> <li>Request/response transformation</li> <li>Circuit breaker patterns</li> </ul> <p>Key Patterns:</p> <ul> <li>Gateway aggregation pattern</li> <li>Service mesh integration</li> <li>Distributed tracing</li> <li>Health check orchestration</li> </ul> <p>Technology Stack:</p> <ul> <li>FastAPI for gateway implementation</li> <li>Redis for caching and rate limiting</li> <li>Prometheus for metrics</li> <li>Distributed logging</li> </ul>"},{"location":"samples/#desktop-controller-background-services","title":"\ud83d\udda5\ufe0f Desktop Controller - Background Services","text":"<p>Shows how to build background services that interact with system resources, handle long-running operations, and manage desktop environments.</p> <p>Domain Focus:</p> <ul> <li>System resource management</li> <li>Process orchestration</li> <li>File system operations</li> <li>Desktop environment control</li> </ul> <p>Key Patterns:</p> <ul> <li>Background service patterns</li> <li>Resource locking mechanisms</li> <li>Process lifecycle management</li> <li>System integration patterns</li> </ul> <p>Technology Stack:</p> <ul> <li>Background service hosting</li> <li>File system watchers</li> <li>System API integration</li> <li>Inter-process communication</li> </ul>"},{"location":"samples/#getting-started-with-samples","title":"\ud83d\ude80 Getting Started with Samples","text":""},{"location":"samples/#quick-start-guide","title":"Quick Start Guide","text":"<ol> <li>Choose Your Domain: Select the sample that matches your use case</li> <li>Review Architecture: Understand the patterns and structure</li> <li>Run Locally: Follow setup instructions for local development</li> <li>Explore Code: Study the implementation details</li> <li>Adapt and Extend: Customize for your specific needs</li> </ol>"},{"location":"samples/#sample-complexity-levels","title":"Sample Complexity Levels","text":""},{"location":"samples/#beginner-level","title":"\ud83d\udfe2 Beginner Level","text":"<ul> <li>Desktop Controller: Straightforward background services</li> <li>Clear separation of concerns</li> <li>Basic integration patterns</li> </ul>"},{"location":"samples/#intermediate-level","title":"\ud83d\udfe1 Intermediate Level","text":"<ul> <li>API Gateway: Microservice coordination</li> <li>Cross-cutting concerns implementation</li> <li>Distributed system patterns</li> </ul>"},{"location":"samples/#advanced-level","title":"\ud83d\udd34 Advanced Level","text":"<ul> <li>OpenBank: Complex event sourcing</li> <li>Lab Resource Manager: Kubernetes operators</li> <li>Advanced domain modeling</li> </ul>"},{"location":"samples/#development-and-testing","title":"\ud83e\uddea Development and Testing","text":""},{"location":"samples/#local-development-setup","title":"Local Development Setup","text":"<p>Each sample includes:</p> <ul> <li>Docker Compose: Complete local environment</li> <li>Development Scripts: Build, test, and run commands</li> <li>Database Migrations: Schema and data setup</li> <li>Mock Services: External dependency simulation</li> </ul>"},{"location":"samples/#testing-strategies","title":"Testing Strategies","text":"<pre><code>graph LR\n    A[Unit Tests&lt;br/&gt;\ud83e\uddea Components] --&gt; B[Integration Tests&lt;br/&gt;\ud83d\udd17 Services]\n    B --&gt; C[End-to-End Tests&lt;br/&gt;\ud83c\udfaf Workflows]\n    C --&gt; D[Performance Tests&lt;br/&gt;\u26a1 Load Testing]\n\n    style A fill:#e8f5e8\n    style B fill:#e3f2fd\n    style C fill:#fff3e0\n    style D fill:#f3e5f5</code></pre>"},{"location":"samples/#deployment-options","title":"Deployment Options","text":"<ul> <li>Local Development: Docker Compose environments</li> <li>Cloud Deployment: Kubernetes manifests and Helm charts</li> <li>CI/CD Pipelines: GitHub Actions and Jenkins examples</li> <li>Monitoring Setup: Observability and logging configuration</li> </ul>"},{"location":"samples/#sample-comparison-matrix","title":"\ud83d\udcca Sample Comparison Matrix","text":"Feature OpenBank API Gateway Desktop Controller Complexity \ud83d\udd34 Advanced \ud83d\udfe1 Intermediate \ud83d\udfe2 Beginner Domain Financial Integration System Architecture Event Sourcing Gateway Pattern Background Services Storage EventStore + Mongo Redis + SQL File System Integration REST APIs Multiple Services System APIs Deployment Cloud/On-Premise Cloud Native Desktop/Server"},{"location":"samples/#learning-outcomes","title":"\ud83c\udf93 Learning Outcomes","text":""},{"location":"samples/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Real-world Implementation: See patterns in action</li> <li>Best Practices: Production-ready code examples</li> <li>Testing Strategies: Comprehensive test coverage</li> <li>Deployment Patterns: Multiple deployment scenarios</li> <li>Performance Optimization: Scalability considerations</li> </ul>"},{"location":"samples/#skills-developed","title":"Skills Developed","text":"<ul> <li>Architecture Design: Pattern selection and implementation</li> <li>Domain Modeling: Business logic representation</li> <li>Integration Patterns: External system coordination</li> <li>Testing Mastery: Test strategy development</li> <li>Operations Knowledge: Deployment and monitoring</li> </ul>"},{"location":"samples/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\ud83c\udfaf Architecture Patterns - Foundational design patterns</li> <li>\ud83d\ude80 Framework Features - Detailed feature documentation</li> <li>\ud83d\udcd6 Implementation Guides - Step-by-step tutorials</li> <li>\ud83c\udf55 Mario's Pizzeria - Unified domain example</li> </ul>"},{"location":"samples/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ol> <li>Explore Sample Code: Clone and run the samples locally</li> <li>Study Implementation: Review architecture decisions and patterns</li> <li>Adapt for Your Needs: Use samples as starting templates</li> <li>Contribute Back: Share improvements and additional samples</li> </ol> <p>Each sample application is production-ready and includes comprehensive documentation, tests, and deployment guides. They serve as both learning resources and starting templates for your own applications.</p>"},{"location":"samples/api_gateway/","title":"\ud83d\ude80 API Gateway Sample Application","text":"<p>The API Gateway sample demonstrates how to build a modern microservice gateway using the Neuroglia framework. This application showcases advanced patterns including OAuth2 authentication, external service integration, background task processing, and cloud event handling.</p>"},{"location":"samples/api_gateway/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>Microservice Gateway Patterns: How to build a centralized API gateway for service orchestration</li> <li>OAuth2 Authentication &amp; Authorization: Implementing JWT-based security with Keycloak integration</li> <li>External Service Integration: Connecting to multiple external APIs with proper abstraction</li> <li>Background Task Processing: Asynchronous task execution with Redis-backed job scheduling</li> <li>Object Storage Integration: File management with MinIO S3-compatible storage</li> <li>Cloud Events: Event-driven communication between microservices</li> <li>Advanced Dependency Injection: Complex service configuration and lifetime management</li> </ul>"},{"location":"samples/api_gateway/#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<pre><code>graph TB\n    subgraph \"API Gateway Service\"\n        A[PromptController] --&gt; B[Mediator]\n        B --&gt; C[Command/Query Handlers]\n        C --&gt; D[Domain Models]\n        C --&gt; E[Integration Services]\n\n        F[OAuth2 Middleware] --&gt; A\n        G[Cloud Event Middleware] --&gt; A\n        H[Exception Handling] --&gt; A\n    end\n\n    subgraph \"External Dependencies\"\n        I[Keycloak OAuth2]\n        J[Redis Cache]\n        K[MinIO Storage]\n        L[External APIs]\n        M[Background Tasks]\n    end\n\n    E --&gt; I\n    E --&gt; J\n    E --&gt; K\n    E --&gt; L\n    C --&gt; M</code></pre> <p>The API Gateway follows a distributed microservice pattern where:</p> <ul> <li>Gateway Layer: Centralized entry point for multiple downstream services</li> <li>Authentication Layer: OAuth2/JWT-based security with external identity provider</li> <li>Integration Layer: Multiple external service clients with proper abstraction</li> <li>DTOs: Data transfer objects for external communication</li> </ul>"},{"location":"samples/api_gateway/#key-features-demonstrated","title":"\ud83d\ude80 Key Features Demonstrated","text":""},{"location":"samples/api_gateway/#1-oauth2-authentication-security","title":"1. OAuth2 Authentication &amp; Security","text":"<pre><code># JWT token validation with Keycloak\n@post(\"/item\", response_model=ItemPromptCommandResponseDto)\nasync def create_new_item_prompt(\n    self,\n    command_dto: CreateNewItemPromptCommandDto,\n    key: str = Depends(validate_mosaic_authentication)\n) -&gt; Any:\n    # Protected endpoint with API key validation\n</code></pre>"},{"location":"samples/api_gateway/#2-multi-service-integration","title":"2. Multi-Service Integration","text":"<pre><code># External service clients\nMinioStorageManager.configure(builder)          # Object storage\nMosaicApiClient.configure(builder)              # External API\nAsyncStringCacheRepository.configure(builder)   # Redis caching\nBackgroundTaskScheduler.configure(builder)      # Async processing\n</code></pre>"},{"location":"samples/api_gateway/#3-advanced-domain-model","title":"3. Advanced Domain Model","text":"<pre><code>@map_to(PromptResponseDto)\n@dataclass\nclass PromptResponse:\n    id: str\n    prompt_id: str\n    content: str\n    status: PromptStatus\n    metadata: dict[str, Any]\n    created_at: datetime.datetime\n</code></pre>"},{"location":"samples/api_gateway/#4-background-task-processing","title":"4. Background Task Processing","text":"<pre><code># Asynchronous task execution\nBackgroundTaskScheduler.configure(builder, [\"application.tasks\"])\n\n# Redis-backed job queue\nbackground_job_store: dict[str, str | int] = {\n    \"redis_host\": \"redis47\",\n    \"redis_port\": 6379,\n    \"redis_db\": 0\n}\n</code></pre>"},{"location":"samples/api_gateway/#5-cloud-events-integration","title":"5. Cloud Events Integration","text":"<pre><code># Event publishing and consumption\nCloudEventIngestor.configure(builder, [\"application.events.integration\"])\nCloudEventPublisher.configure(builder)\napp.add_middleware(CloudEventMiddleware, service_provider=app.services)\n</code></pre>"},{"location":"samples/api_gateway/#configuration-settings","title":"\ud83d\udd27 Configuration &amp; Settings","text":""},{"location":"samples/api_gateway/#application-settings","title":"Application Settings","text":"<pre><code>class AiGatewaySettings(ApplicationSettings):\n    # OAuth2 Configuration\n    jwt_authority: str = \"http://keycloak47/realms/mozart\"\n    jwt_audience: str = \"ai-gateways\"\n    required_scope: str = \"api\"\n\n    # External Service Settings\n    s3_endpoint: str                    # MinIO storage\n    connection_strings: dict[str, str]  # Redis, databases\n    mosaic_api_keys: list[str]         # API authentication\n\n    # Background Processing\n    background_job_store: dict[str, str | int]\n    redis_max_connections: int = 10\n</code></pre>"},{"location":"samples/api_gateway/#service-registration","title":"Service Registration","text":"<pre><code># Core framework services\nMapper.configure(builder, application_modules)\nMediator.configure(builder, application_modules)\nJsonSerializer.configure(builder)\n\n# Custom application services\nAsyncStringCacheRepository.configure(builder, Prompt, str)\nBackgroundTaskScheduler.configure(builder, [\"application.tasks\"])\nMinioStorageManager.configure(builder)\nLocalFileSystemManager.configure(builder)\n\n# External integrations\nbuilder.services.add_singleton(AiGatewaySettings, singleton=app_settings)\n</code></pre>"},{"location":"samples/api_gateway/#testing-strategy","title":"\ud83e\uddea Testing Strategy","text":""},{"location":"samples/api_gateway/#unit-tests","title":"Unit Tests","text":"<pre><code>class TestPromptController:\n    def setup_method(self):\n        self.mock_mediator = Mock(spec=Mediator)\n        self.mock_mapper = Mock(spec=Mapper)\n        self.controller = PromptController(\n            service_provider=Mock(),\n            mapper=self.mock_mapper,\n            mediator=self.mock_mediator\n        )\n\n    @pytest.mark.asyncio\n    async def test_create_prompt_success(self):\n        # Test successful prompt creation\n        command_dto = CreateNewItemPromptCommandDto(content=\"test\")\n        result = await self.controller.create_new_item_prompt(command_dto, \"valid-key\")\n\n        assert result.status == \"created\"\n        self.mock_mediator.execute_async.assert_called_once()\n</code></pre>"},{"location":"samples/api_gateway/#integration-tests","title":"Integration Tests","text":"<pre><code>@pytest.mark.integration\nclass TestApiGatewayIntegration:\n    @pytest.mark.asyncio\n    async def test_full_prompt_workflow(self, test_client):\n        # Test complete workflow from API to external services\n        response = await test_client.post(\n            \"/api/prompts/item\",\n            json={\"content\": \"test prompt\"},\n            headers={\"Authorization\": \"Bearer valid-token\"}\n        )\n\n        assert response.status_code == 201\n        assert \"id\" in response.json()\n</code></pre>"},{"location":"samples/api_gateway/#implementation-details","title":"\ud83d\udcda Implementation Details","text":""},{"location":"samples/api_gateway/#1-controller-layer-apicontrollers","title":"1. Controller Layer (<code>api/controllers/</code>)","text":"<ul> <li>PromptController: Main API endpoints for prompt management</li> <li>AppController: Application health and metadata endpoints</li> <li>InternalController: Internal service endpoints</li> <li>Authentication Schemes: OAuth2 and API key validation</li> </ul>"},{"location":"samples/api_gateway/#2-application-layer-application","title":"2. Application Layer (<code>application/</code>)","text":"<ul> <li>Commands: Write operations (CreateNewPromptCommand)</li> <li>Queries: Read operations (GetPromptByIdQuery)</li> <li>Services: Business logic orchestration</li> <li>Tasks: Background job definitions</li> <li>Events: Integration event handlers</li> </ul>"},{"location":"samples/api_gateway/#3-domain-layer-domain","title":"3. Domain Layer (<code>domain/</code>)","text":"<ul> <li>Prompt: Core domain entity with business rules</li> <li>PromptResponse: Value object for API responses</li> <li>Domain Events: Business event definitions</li> <li>Validation: Domain-specific validation logic</li> </ul>"},{"location":"samples/api_gateway/#4-integration-layer-integration","title":"4. Integration Layer (<code>integration/</code>)","text":"<ul> <li>External API Clients: Mosaic, GenAI, Mozart APIs</li> <li>Storage Services: MinIO object storage, Redis caching</li> <li>Background Services: Task scheduling and execution</li> <li>DTOs: Data transfer objects for external communication</li> </ul>"},{"location":"samples/api_gateway/#background-processing","title":"\ud83d\udd04 Background Processing","text":"<p>The API Gateway demonstrates advanced background processing patterns:</p> <pre><code># Task scheduling configuration\nBackgroundTaskScheduler.configure(builder, [\"application.tasks\"])\n\n# Redis-backed job store\nbuilder.services.add_singleton(AiGatewaySettings, singleton=app_settings)\n\n# Asynchronous task execution\n@task_handler\nclass ProcessPromptTask:\n    async def execute_async(self, prompt_id: str):\n        # Long-running prompt processing\n        prompt = await self.prompt_service.get_by_id(prompt_id)\n        result = await self.genai_client.process_prompt(prompt)\n        await self.storage_service.store_result(result)\n</code></pre>"},{"location":"samples/api_gateway/#external-service-integration","title":"\ud83c\udf10 External Service Integration","text":""},{"location":"samples/api_gateway/#minio-object-storage","title":"MinIO Object Storage","text":"<pre><code>class MinioStorageManager:\n    async def upload_file_async(self, bucket: str, key: str, data: bytes) -&gt; str:\n        # S3-compatible object storage\n        return await self.client.put_object(bucket, key, data)\n</code></pre>"},{"location":"samples/api_gateway/#redis-caching","title":"Redis Caching","text":"<pre><code>class AsyncStringCacheRepository:\n    async def get_async(self, key: str) -&gt; Optional[str]:\n        return await self.redis_client.get(key)\n\n    async def set_async(self, key: str, value: str, ttl: int = None):\n        await self.redis_client.set(key, value, ex=ttl)\n</code></pre>"},{"location":"samples/api_gateway/#external-api-integration","title":"External API Integration","text":"<pre><code>class MosaicApiClient:\n    async def submit_prompt_async(self, prompt: PromptDto) -&gt; PromptResponseDto:\n        # OAuth2 authenticated API calls\n        token = await self.get_access_token()\n        response = await self.http_client.post(\n            \"/api/prompts\",\n            json=prompt.dict(),\n            headers={\"Authorization\": f\"Bearer {token}\"}\n        )\n        return PromptResponseDto.parse_obj(response.json())\n</code></pre>"},{"location":"samples/api_gateway/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"samples/api_gateway/#1-prerequisites","title":"1. Prerequisites","text":"<pre><code># Install dependencies\npip install -r requirements.txt\n\n# Configure external services\ndocker-compose up -d redis keycloak minio\n</code></pre>"},{"location":"samples/api_gateway/#2-configuration","title":"2. Configuration","text":"<pre><code># Set environment variables\nexport JWT_AUTHORITY=\"http://localhost:8080/realms/mozart\"\nexport S3_ENDPOINT=\"http://localhost:9000\"\nexport REDIS_URL=\"redis://localhost:6379\"\n</code></pre>"},{"location":"samples/api_gateway/#3-run-the-application","title":"3. Run the Application","text":"<pre><code># Start the API Gateway\npython samples/api-gateway/main.py\n\n# Access Swagger UI\nopen http://localhost:8000/docs\n</code></pre>"},{"location":"samples/api_gateway/#4-test-the-api","title":"4. Test the API","text":"<pre><code># Get access token from Keycloak\ncurl -X POST http://localhost:8080/realms/mozart/protocol/openid-connect/token \\\n  -H \"Content-Type: application/x-www-form-urlencoded\" \\\n  -d \"grant_type=client_credentials&amp;client_id=ai-gateway&amp;client_secret=secret\"\n\n# Call protected endpoint\ncurl -X POST http://localhost:8000/api/prompts/item \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"content\": \"Generate a sample prompt\"}'\n</code></pre>"},{"location":"samples/api_gateway/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>CQRS &amp; Mediation - Command/Query patterns</li> <li>Dependency Injection - Service configuration</li> <li>Data Access - Repository patterns</li> <li>OpenBank Sample - Event sourcing comparison</li> <li>Desktop Controller Sample - Background services</li> </ul>"},{"location":"samples/api_gateway/#comparison-with-openbank-sample","title":"\ud83d\udd0d Comparison with OpenBank Sample","text":"<p>The API Gateway and OpenBank samples demonstrate different architectural patterns within the Neuroglia framework. Here's a detailed comparison:</p>"},{"location":"samples/api_gateway/#architecture-patterns","title":"Architecture Patterns","text":"Aspect API Gateway OpenBank Primary Pattern Microservice Gateway Event Sourcing + DDD Data Persistence Multi-store (Redis, MinIO, MongoDB) Event Store + Read Models State Management Stateless with caching Event-sourced aggregates External Integration Multiple external APIs Focused domain model Background Processing Async task queues Event-driven projections"},{"location":"samples/api_gateway/#domain-complexity","title":"Domain Complexity","text":""},{"location":"samples/api_gateway/#api-gateway-integration-focused","title":"API Gateway - Integration-Focused","text":"<pre><code># Simple domain model focused on orchestration\n@dataclass\nclass PromptResponse:\n    id: str\n    prompt_id: str\n    content: str\n    status: PromptStatus\n    metadata: dict[str, Any]\n</code></pre>"},{"location":"samples/api_gateway/#openbank-rich-domain-model","title":"OpenBank - Rich Domain Model","text":"<pre><code># Complex aggregate with business rules\nclass BankAccountV1(AggregateRoot[str]):\n    def record_transaction(self, amount: Decimal, transaction_type: BankTransactionTypeV1):\n        # Complex business logic and invariants\n        if transaction_type == BankTransactionTypeV1.DEBIT:\n            if self.state.balance + amount &lt; -self.state.overdraft_limit:\n                raise InsufficientFundsException()\n\n        # Event sourcing\n        self.raise_event(BankAccountTransactionRecordedDomainEventV1(...))\n</code></pre>"},{"location":"samples/api_gateway/#data-persistence-strategy","title":"Data Persistence Strategy","text":""},{"location":"samples/api_gateway/#api-gateway-multi-store-architecture","title":"API Gateway - Multi-Store Architecture","text":"<pre><code># Multiple specialized storage systems\nAsyncStringCacheRepository.configure(builder, Prompt, str)  # Redis caching\nMinioStorageManager.configure(builder)                      # Object storage\nBackgroundTaskScheduler.configure(builder)                 # Job queue\n\n# Standard CRUD operations\nasync def save_prompt(self, prompt: Prompt):\n    await self.cache_repository.set_async(prompt.id, prompt.content)\n    await self.storage_manager.upload_async(prompt.id, prompt.data)\n</code></pre>"},{"location":"samples/api_gateway/#openbank-event-sourcing","title":"OpenBank - Event Sourcing","text":"<pre><code># Event-driven persistence\nESEventStore.configure(builder, EventStoreOptions(database_name, consumer_group))\n\n# Write model: Event sourcing\nDataAccessLayer.WriteModel.configure(\n    builder,\n    [\"samples.openbank.domain.models\"],\n    lambda builder_, entity_type, key_type: EventSourcingRepository.configure(...)\n)\n\n# Read model: Projections\nDataAccessLayer.ReadModel.configure(\n    builder,\n    [\"samples.openbank.integration.models\"],\n    lambda builder_, entity_type, key_type: MongoRepository.configure(...)\n)\n</code></pre>"},{"location":"samples/api_gateway/#authentication-security","title":"Authentication &amp; Security","text":""},{"location":"samples/api_gateway/#api-gateway-oauth2-api-keys","title":"API Gateway - OAuth2 + API Keys","text":"<pre><code># Multiple authentication schemes\n@post(\"/item\", dependencies=[Depends(validate_mosaic_authentication)])\nasync def create_item_prompt(self, command_dto: CreateNewItemPromptCommandDto):\n    # API key validation for external services\n\n@get(\"/status\", dependencies=[Depends(validate_token)])\nasync def get_status(self):\n    # JWT token validation for internal services\n</code></pre>"},{"location":"samples/api_gateway/#openbank-domain-focused-security","title":"OpenBank - Domain-Focused Security","text":"<pre><code># Business rule enforcement\nclass BankAccountV1(AggregateRoot[str]):\n    def record_transaction(self, amount: Decimal, transaction_type: BankTransactionTypeV1):\n        # Domain-level authorization\n        if not self.is_authorized_for_transaction(amount):\n            raise UnauthorizedTransactionException()\n</code></pre>"},{"location":"samples/api_gateway/#external-service-integration_1","title":"External Service Integration","text":""},{"location":"samples/api_gateway/#api-gateway-extensive-integration","title":"API Gateway - Extensive Integration","text":"<pre><code># Multiple external service clients\nclass MosaicApiClient:\n    async def submit_prompt_async(self, prompt: PromptDto) -&gt; PromptResponseDto:\n        token = await self.oauth_client.get_token_async()\n        return await self.http_client.post(\"/api/prompts\", prompt, token)\n\nclass GenAiClient:\n    async def process_prompt_async(self, prompt: str) -&gt; str:\n        return await self.ai_service.generate_response(prompt)\n\nclass MinioStorageManager:\n    async def store_file_async(self, bucket: str, key: str, data: bytes):\n        return await self.s3_client.put_object(bucket, key, data)\n</code></pre>"},{"location":"samples/api_gateway/#openbank-minimal-integration","title":"OpenBank - Minimal Integration","text":"<pre><code># Focused on domain logic, minimal external dependencies\nclass CreateBankAccountCommandHandler:\n    async def handle_async(self, command: CreateBankAccountCommand):\n        # Pure domain logic without external service calls\n        owner = await self.person_repository.get_by_id_async(command.owner_id)\n        account = BankAccountV1(str(uuid.uuid4()), owner, command.initial_balance)\n        await self.account_repository.save_async(account)\n</code></pre>"},{"location":"samples/api_gateway/#background-processing_1","title":"Background Processing","text":""},{"location":"samples/api_gateway/#api-gateway-task-queue-pattern","title":"API Gateway - Task Queue Pattern","text":"<pre><code># Redis-backed job queues\nBackgroundTaskScheduler.configure(builder, [\"application.tasks\"])\n\n@task_handler\nclass ProcessPromptTask:\n    async def execute_async(self, prompt_id: str):\n        prompt = await self.prompt_service.get_by_id(prompt_id)\n        result = await self.genai_client.process_prompt(prompt)\n        await self.storage_service.store_result(result)\n</code></pre>"},{"location":"samples/api_gateway/#openbank-event-driven-projections","title":"OpenBank - Event-Driven Projections","text":"<pre><code># Event handlers for read model updates\nclass BankAccountEventHandler:\n    @event_handler(BankAccountCreatedDomainEventV1)\n    async def handle_account_created(self, event: BankAccountCreatedDomainEventV1):\n        projection = BankAccountProjection.from_event(event)\n        await self.read_model_repository.save_async(projection)\n</code></pre>"},{"location":"samples/api_gateway/#testing-strategies","title":"Testing Strategies","text":""},{"location":"samples/api_gateway/#api-gateway-integration-heavy-testing","title":"API Gateway - Integration-Heavy Testing","text":"<pre><code>@pytest.mark.integration\nclass TestApiGatewayIntegration:\n    async def test_full_prompt_workflow(self, test_client, mock_external_services):\n        # Test complete workflow including external services\n        response = await test_client.post(\"/api/prompts/item\", json=prompt_data)\n\n        # Verify external service calls\n        mock_external_services.genai_client.process_prompt.assert_called_once()\n        mock_external_services.storage_manager.upload.assert_called_once()\n</code></pre>"},{"location":"samples/api_gateway/#openbank-domain-focused-testing","title":"OpenBank - Domain-Focused Testing","text":"<pre><code>class TestBankAccountAggregate:\n    def test_transaction_recording(self):\n        # Pure domain logic testing\n        account = BankAccountV1(\"123\", owner, Decimal(\"1000\"))\n        account.record_transaction(Decimal(\"-100\"), BankTransactionTypeV1.DEBIT)\n\n        # Verify business rules and events\n        assert account.state.balance == Decimal(\"900\")\n        events = account.get_uncommitted_events()\n        assert isinstance(events[-1], BankAccountTransactionRecordedDomainEventV1)\n</code></pre>"},{"location":"samples/api_gateway/#use-case-recommendations","title":"Use Case Recommendations","text":""},{"location":"samples/api_gateway/#choose-api-gateway-pattern-when","title":"Choose API Gateway Pattern when","text":"<ul> <li>\u2705 Building microservice orchestration layers</li> <li>\u2705 Integrating multiple external services</li> <li>\u2705 Need background job processing</li> <li>\u2705 Require complex authentication schemes</li> <li>\u2705 Working with heterogeneous data stores</li> <li>\u2705 Building service mesh entry points</li> </ul>"},{"location":"samples/api_gateway/#choose-event-sourcing-pattern-when","title":"Choose Event Sourcing Pattern when","text":"<ul> <li>\u2705 Need complete audit trails</li> <li>\u2705 Complex business logic and invariants</li> <li>\u2705 Temporal queries are important</li> <li>\u2705 Regulatory compliance requirements</li> <li>\u2705 High consistency requirements</li> <li>\u2705 Rich domain models with behavior</li> </ul>"},{"location":"samples/api_gateway/#framework-features-utilized","title":"Framework Features Utilized","text":"Feature API Gateway Usage OpenBank Usage CQRS/Mediation Service orchestration Domain command/query separation Dependency Injection External service clients Repository abstractions Event Handling Integration events Domain events + projections Data Access Multi-repository pattern Event sourcing + read models Background Processing Async task queues Event-driven handlers Mapping DTO transformations Domain-to-DTO mapping Validation API contract validation Business rule enforcement <p>Both samples showcase different strengths of the Neuroglia framework, demonstrating its flexibility in supporting various architectural patterns while maintaining clean architecture principles.</p>"},{"location":"samples/desktop_controller/","title":"\ud83d\udda5\ufe0f Desktop Controller Sample Application","text":"<p>The Desktop Controller sample demonstrates how to build a remote desktop management system using the Neuroglia framework. This application showcases system integration patterns including SSH-based remote control, background service registration, cloud event publishing, and OAuth2 security for enterprise desktop management.</p>"},{"location":"samples/desktop_controller/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>Remote System Control: SSH-based command execution on host systems</li> <li>Background Service Patterns: Periodic self-registration and heartbeat services</li> <li>Cloud Event Publishing: Automated service discovery and registration events</li> <li>System Integration: Host system information gathering and state management</li> <li>OAuth2 Security: Enterprise authentication with secure SSH key management</li> <li>File System Integration: Remote file management and data persistence</li> <li>Docker Host Communication: Container-to-host communication patterns</li> </ul>"},{"location":"samples/desktop_controller/#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<pre><code>graph TB\n    subgraph \"Desktop Controller Service\"\n        A[HostController] --&gt; B[Mediator]\n        B --&gt; C[Command/Query Handlers]\n        C --&gt; D[Domain Models]\n        C --&gt; E[SSH Integration Services]\n\n        F[OAuth2 Middleware] --&gt; A\n        G[Background Registrator] --&gt; H[Cloud Event Bus]\n        I[SSH Client] --&gt; J[Docker Host]\n\n        C --&gt; K[File System Repository]\n        K --&gt; I\n    end\n\n    subgraph \"External Dependencies\"\n        L[Keycloak OAuth2]\n        M[Desktop Registry]\n        N[Docker Host/VM]\n        O[Remote File System]\n    end\n\n    F --&gt; L\n    H --&gt; M\n    I --&gt; N\n    K --&gt; O\n\n    style A fill:#e1f5fe\n    style G fill:#f3e5f5\n    style I fill:#fff3e0</code></pre> <p>This architecture enables secure remote control of desktop systems through containerized services that communicate with their host environments via SSH while maintaining enterprise security standards.</p>"},{"location":"samples/desktop_controller/#key-features-demonstrated","title":"\ud83d\ude80 Key Features Demonstrated","text":""},{"location":"samples/desktop_controller/#1-ssh-based-remote-control","title":"1. SSH-Based Remote Control","text":"<pre><code># Secure command execution on host systems\nclass SecuredHost:\n    async def run_command_async(self, command: HostCommand) -&gt; HostCommandResult:\n        stdin, stdout, stderr = await asyncio.to_thread(\n            self.ssh_client.exec_command, command.line\n        )\n\n        exit_status = stdout.channel.recv_exit_status()\n        return HostCommandResult(\n            command=command.line,\n            exit_status=exit_status,\n            stdout=stdout.read().decode(),\n            stderr=stderr.read().decode()\n        )\n</code></pre>"},{"location":"samples/desktop_controller/#2-background-service-registration","title":"2. Background Service Registration","text":"<pre><code># Periodic self-registration with cloud events\nclass DesktopRegistrator(HostedService):\n    async def start_async(self):\n        while not self.cancellation_token.is_cancelled:\n            await self._register_desktop()\n            await asyncio.sleep(self.registration_interval_seconds)\n\n    async def _register_desktop(self):\n        event = DesktopHostRegistrationRequestedIntegrationEventV1(\n            desktop_id=self.desktop_id,\n            host_ip_address=self.host_ip,\n            registration_timestamp=datetime.utcnow()\n        )\n        await self.cloud_event_publisher.publish_async(event)\n</code></pre>"},{"location":"samples/desktop_controller/#3-host-system-information-management","title":"3. Host System Information Management","text":"<pre><code># Domain model for host information\n@dataclass\nclass HostInfo(Entity[str]):\n    desktop_id: str\n    host_ip_address: str\n    host_state: HostState\n    last_seen: datetime\n    is_locked: bool\n    system_info: dict[str, Any]\n\n    def update_system_state(self, new_state: HostState):\n        self.host_state = new_state\n        self.last_seen = datetime.now(timezone.utc)\n</code></pre>"},{"location":"samples/desktop_controller/#4-commandquery-pattern-for-remote-operations","title":"4. Command/Query Pattern for Remote Operations","text":"<pre><code># Remote command execution\n@dataclass\nclass SetHostLockCommand(Command):\n    script_name: str = \"/usr/local/bin/lock.sh\"\n\nclass HostLockCommandsHandler(CommandHandler[SetHostLockCommand, OperationResult[Any]]):\n    async def handle_async(self, command: SetHostLockCommand) -&gt; OperationResult[Any]:\n        host_command = HostCommand(line=command.script_name)\n        result = await self.docker_host_command_runner.run_async(host_command)\n\n        if result.exit_status == 0:\n            return self.success(\"Host locked successfully\")\n        return self.bad_request(f\"Lock command failed: {result.stderr}\")\n</code></pre>"},{"location":"samples/desktop_controller/#5-oauth2-with-ssh-security","title":"5. OAuth2 with SSH Security","text":"<pre><code># Dual security: OAuth2 for API + SSH for host access\n@get(\"/info\", dependencies=[Depends(validate_token)])\nasync def get_host_info(self):\n    query = ReadHostInfoQuery()\n    result = await self.mediator.execute_async(query)\n    return self.process(result)\n</code></pre>"},{"location":"samples/desktop_controller/#configuration-settings","title":"\ud83d\udd27 Configuration &amp; Settings","text":""},{"location":"samples/desktop_controller/#application-settings","title":"Application Settings","text":"<pre><code>class DesktopControllerSettings(ApplicationSettings):\n    # OAuth2 Configuration\n    jwt_authority: str = \"http://keycloak47/realms/mozart\"\n    jwt_audience: str = \"desktops\"\n    required_scope: str = \"api\"\n\n    # SSH Configuration\n    docker_host_user_name: str = \"sys-admin\"\n    docker_host_host_name: str = \"host.docker.internal\"\n\n    # File System Configuration\n    remotefs_base_folder: str = \"/tmp\"\n    hostinfo_filename: str = \"hostinfo.json\"\n    userinfo_filename: str = \"userinfo.json\"\n\n    # Registration Configuration\n    desktop_registration_interval: int = 30  # seconds\n</code></pre>"},{"location":"samples/desktop_controller/#ssh-client-configuration","title":"SSH Client Configuration","text":"<pre><code>class SshClientSettings(BaseModel):\n    username: str\n    hostname: str\n    port: int = 22\n    private_key_filename: str = \"/app/id_rsa\"\n\n# SSH key setup required:\n# 1. Generate SSH key pair\n# 2. Mount private key to container at /app/id_rsa\n# 3. Add public key to host's ~/.ssh/authorized_keys\n</code></pre>"},{"location":"samples/desktop_controller/#testing-strategy","title":"\ud83e\uddea Testing Strategy","text":""},{"location":"samples/desktop_controller/#unit-tests","title":"Unit Tests","text":"<pre><code>class TestHostController:\n    def test_host_lock_command_success(self):\n        # Test successful host locking\n        command = SetHostLockCommand(script_name=\"/usr/local/bin/lock.sh\")\n\n        # Mock SSH client response\n        mock_result = HostCommandResult(\n            command=\"/usr/local/bin/lock.sh\",\n            exit_status=0,\n            stdout=\"Host locked\",\n            stderr=\"\"\n        )\n\n        result = await handler.handle_async(command)\n        assert result.is_success\n        assert \"locked successfully\" in result.data\n</code></pre>"},{"location":"samples/desktop_controller/#integration-tests","title":"Integration Tests","text":"<pre><code>class TestDesktopControllerIntegration:\n    @pytest.mark.integration\n    async def test_ssh_host_communication(self):\n        # Test actual SSH communication with test host\n        ssh_client = SecuredHost(test_ssh_settings)\n        command = HostCommand(line=\"echo 'test'\")\n\n        result = await ssh_client.run_command_async(command)\n\n        assert result.exit_status == 0\n        assert \"test\" in result.stdout\n</code></pre>"},{"location":"samples/desktop_controller/#implementation-details","title":"\ud83d\udcda Implementation Details","text":""},{"location":"samples/desktop_controller/#1-controller-layer-apicontrollers","title":"1. Controller Layer (<code>api/controllers/</code>)","text":"<ul> <li>HostController: Host system management and information endpoints</li> <li>UserController: User session and information management</li> <li>HostScriptController: Custom script execution on host systems</li> <li>OAuth2Scheme: Authentication and authorization middleware</li> </ul>"},{"location":"samples/desktop_controller/#2-application-layer-application","title":"2. Application Layer (<code>application/</code>)","text":"<ul> <li>Commands: System control operations (lock, unlock, script execution)</li> <li>Queries: System information retrieval (host info, user info, lock status)</li> <li>Services: Background registration, SSH command execution</li> <li>Events: Integration events for desktop registration</li> </ul>"},{"location":"samples/desktop_controller/#3-domain-layer-domain","title":"3. Domain Layer (<code>domain/</code>)","text":"<ul> <li>HostInfo: Desktop system information and state</li> <li>UserInfo: User session and authentication state</li> <li>HostIsLocked: Lock state management for security</li> <li>Domain Events: System state change notifications</li> </ul>"},{"location":"samples/desktop_controller/#4-integration-layer-integration","title":"4. Integration Layer (<code>integration/</code>)","text":"<ul> <li>SSH Services: Secure host communication via SSH</li> <li>File System Repository: Remote file management</li> <li>Cloud Event Models: External service communication</li> <li>Enums: System state and configuration enumerations</li> </ul>"},{"location":"samples/desktop_controller/#external-service-integration","title":"\ud83c\udf10 External Service Integration","text":""},{"location":"samples/desktop_controller/#ssh-host-communication","title":"SSH Host Communication","text":"<pre><code>class SecuredDockerHost:\n    \"\"\"SSH-based secure communication with Docker host system\"\"\"\n\n    async def execute_system_command(self, command: str) -&gt; CommandResult:\n        ssh_command = HostCommand(line=command)\n        return await self.secured_host.run_command_async(ssh_command)\n</code></pre>"},{"location":"samples/desktop_controller/#cloud-event-publishing","title":"Cloud Event Publishing","text":"<pre><code>class DesktopRegistrationEvent:\n    \"\"\"Periodic registration with external desktop registry\"\"\"\n\n    event_type = \"com.cisco.mozart.desktop.registered.v1\"\n\n    async def publish_registration(self):\n        cloud_event = CloudEvent(\n            type=self.event_type,\n            source=f\"desktop-controller/{self.desktop_id}\",\n            data=DesktopHostRegistrationRequestedIntegrationEventV1(\n                desktop_id=self.desktop_id,\n                host_ip_address=self.get_host_ip(),\n                capabilities=self.get_host_capabilities()\n            )\n        )\n        await self.cloud_event_bus.publish_async(cloud_event)\n</code></pre>"},{"location":"samples/desktop_controller/#remote-file-system-access","title":"Remote File System Access","text":"<pre><code>class RemoteFileSystemRepository:\n    \"\"\"File-based data persistence on host system\"\"\"\n\n    async def save_host_info(self, host_info: HostInfo):\n        json_data = self.json_serializer.serialize(host_info)\n        await self.write_file_async(\"hostinfo.json\", json_data)\n\n    async def write_file_async(self, filename: str, content: str):\n        # Use SSH to write files to host filesystem\n        command = f\"echo '{content}' &gt; {self.base_path}/{filename}\"\n        await self.ssh_client.run_command_async(HostCommand(line=command))\n</code></pre>"},{"location":"samples/desktop_controller/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"samples/desktop_controller/#prerequisites","title":"Prerequisites","text":"<pre><code># 1. Docker and Docker Desktop installed\n# 2. SSH key pair generated\nssh-keygen -t rsa -b 4096 -f ~/.ssh/desktop_controller_key\n\n# 3. Copy public key to target host\nssh-copy-id -i ~/.ssh/desktop_controller_key.pub user@target-host\n</code></pre>"},{"location":"samples/desktop_controller/#running-the-application","title":"Running the Application","text":"<pre><code># 1. Clone and setup\ngit clone &lt;repository&gt;\ncd samples/desktop-controller\n\n# 2. Configure environment\ncp .env.example .env\n# Edit .env with your settings\n\n# 3. Mount SSH private key and run\ndocker run -d\n  -p 8080:80\n  -v ~/.ssh/desktop_controller_key:/app/id_rsa:ro\n  -e DOCKER_HOST_USER_NAME=sys-admin\n  -e JWT_AUTHORITY=http://your-keycloak/realms/mozart\n  desktop-controller:latest\n\n# 4. Test the API\ncurl -H \"Authorization: Bearer &lt;token&gt;\"\n     http://localhost:8080/api/host/info\n</code></pre>"},{"location":"samples/desktop_controller/#development-setup","title":"Development Setup","text":"<pre><code># 1. Install dependencies\npoetry install\n\n# 2. Configure SSH access\nsudo cp ~/.ssh/desktop_controller_key ./id_rsa\nsudo chmod 600 ./id_rsa\n\n# 3. Start development server\npoetry run python main.py\n\n# 4. Access Swagger UI\nopen http://localhost:8080/docs\n</code></pre>"},{"location":"samples/desktop_controller/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>OAuth2 Security - Authentication patterns</li> <li>Background Services - Hosted service patterns</li> <li>Cloud Events - Event publishing and consumption</li> <li>System Integration - External system communication</li> <li>API Gateway Sample - Service gateway patterns</li> <li>OpenBank Sample - Event sourcing and CQRS patterns</li> </ul>"},{"location":"samples/desktop_controller/#comparison-with-other-samples","title":"\ud83d\udd0d Comparison with Other Samples","text":""},{"location":"samples/desktop_controller/#architecture-patterns","title":"Architecture Patterns","text":""},{"location":"samples/desktop_controller/#desktop-controller-system-integration-focused","title":"Desktop Controller - System Integration Focused","text":"<pre><code># SSH-based system control\nclass HostController(ControllerBase):\n    @post(\"/lock\")\n    async def lock_host(self):\n        command = SetHostLockCommand()\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n# Background service registration\nclass DesktopRegistrator(HostedService):\n    async def start_async(self):\n        while not self.stopping:\n            await self.register_desktop()\n            await asyncio.sleep(30)\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-service-orchestration","title":"API Gateway - Service Orchestration","text":"<pre><code># External API orchestration\nclass PromptController(ControllerBase):\n    @post(\"/prompts\")\n    async def create_prompt(self, dto: CreatePromptDto):\n        command = self.mapper.map(dto, CreatePromptCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-rich-domain-model","title":"OpenBank - Rich Domain Model","text":"<pre><code># Event-sourced business logic\nclass BankAccount(AggregateRoot[str]):\n    def try_add_transaction(self, transaction: BankTransaction) -&gt; bool:\n        if self.can_process_transaction(transaction):\n            self.state.on(self.register_event(TransactionRecorded(transaction)))\n            return True\n        return False\n</code></pre>"},{"location":"samples/desktop_controller/#domain-complexity","title":"Domain Complexity","text":""},{"location":"samples/desktop_controller/#desktop-controller-system-state-management","title":"Desktop Controller - System State Management","text":"<ul> <li>Focus: Host system control and monitoring</li> <li>Entities: HostInfo, UserInfo, SystemState</li> <li>Operations: Lock/unlock, script execution, information gathering</li> <li>State: Current system state with periodic updates</li> </ul>"},{"location":"samples/desktop_controller/#api-gateway-service-integration","title":"API Gateway - Service Integration","text":"<ul> <li>Focus: Request routing and external service coordination</li> <li>Entities: Prompt, PromptResponse, ServiceConfiguration</li> <li>Operations: Create, process, route requests</li> <li>State: Request/response transformation and routing</li> </ul>"},{"location":"samples/desktop_controller/#openbank-business-domain-model","title":"OpenBank - Business Domain Model","text":"<ul> <li>Focus: Financial business rules and transactions</li> <li>Entities: BankAccount, Person, Transaction</li> <li>Operations: Account creation, money transfer, balance inquiry</li> <li>State: Event-sourced business state with full history</li> </ul>"},{"location":"samples/desktop_controller/#data-persistence-strategy","title":"Data Persistence Strategy","text":""},{"location":"samples/desktop_controller/#desktop-controller-file-based-remote-storage","title":"Desktop Controller - File-Based + Remote Storage","text":"<pre><code># File-based persistence on remote host\nclass RemoteFileSystemRepository:\n    async def save_host_info(self, host_info: HostInfo):\n        json_content = self.serializer.serialize(host_info)\n        await self.write_remote_file(\"hostinfo.json\", json_content)\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-multi-store-architecture","title":"API Gateway - Multi-Store Architecture","text":"<pre><code># Multiple storage backends\nservices.add_scoped(MinioStorageManager)      # Object storage\nservices.add_scoped(RedisCache)               # Caching\nservices.add_scoped(MongoRepository)          # Document storage\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-event-sourcing","title":"OpenBank - Event Sourcing","text":"<pre><code># Event store with projections\nclass EventStoreRepository:\n    async def save_async(self, aggregate: AggregateRoot):\n        events = aggregate._pending_events\n        await self.event_store.append_events_async(aggregate.id, events)\n</code></pre>"},{"location":"samples/desktop_controller/#authentication-security","title":"Authentication &amp; Security","text":""},{"location":"samples/desktop_controller/#desktop-controller-oauth2-ssh-keys","title":"Desktop Controller - OAuth2 + SSH Keys","text":"<pre><code># Dual security model\n@get(\"/info\", dependencies=[Depends(validate_token)])\nasync def get_host_info(self):\n    # OAuth2 for API access + SSH for host communication\n    pass\n\n# SSH key management\nclass SshClientSettings:\n    private_key_filename: str = \"/app/id_rsa\"\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-oauth2-api-keys","title":"API Gateway - OAuth2 + API Keys","text":"<pre><code># Multiple authentication schemes\n@post(\"/item\", dependencies=[Depends(validate_oauth2_token)])\nasync def create_item_oauth(self, item_data: ItemDto):\n    pass\n\n@get(\"/health\", dependencies=[Depends(validate_api_key)])\nasync def health_check(self):\n    pass\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-domain-focused-security","title":"OpenBank - Domain-Focused Security","text":"<pre><code># Business rule-based security\nclass BankAccount:\n    def withdraw(self, amount: Decimal, user: Person):\n        if not self.is_owner(user):\n            raise UnauthorizedOperationException()\n        if not self.has_sufficient_funds(amount):\n            raise InsufficientFundsException()\n</code></pre>"},{"location":"samples/desktop_controller/#external-service-integration_1","title":"External Service Integration","text":""},{"location":"samples/desktop_controller/#desktop-controller-system-integration","title":"Desktop Controller - System Integration","text":"<pre><code># Direct system integration via SSH\nclass DockerHostCommandRunner:\n    async def run_async(self, command: HostCommand) -&gt; HostCommandResult:\n        return await self.ssh_client.execute_command(command)\n\n# Cloud event publishing for registration\nclass DesktopRegistrator:\n    async def register_desktop(self):\n        event = DesktopRegistrationEvent(self.host_info)\n        await self.cloud_event_bus.publish_async(event)\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-extensive-integration","title":"API Gateway - Extensive Integration","text":"<pre><code># Multiple external service clients\nservices.add_scoped(MosaicApiClient)\nservices.add_scoped(MinioStorageManager)\nservices.add_scoped(RedisCache)\nservices.add_scoped(GenAiApiClient)\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-minimal-integration","title":"OpenBank - Minimal Integration","text":"<pre><code># Domain-focused with minimal external dependencies\nservices.add_singleton(EventStoreClient)\nservices.add_scoped(MongoRepository)  # For read models\n</code></pre>"},{"location":"samples/desktop_controller/#background-processing","title":"Background Processing","text":""},{"location":"samples/desktop_controller/#desktop-controller-periodic-registration","title":"Desktop Controller - Periodic Registration","text":"<pre><code># Background service for system registration\nclass DesktopRegistrator(HostedService):\n    async def start_async(self):\n        self.registration_task = asyncio.create_task(self.registration_loop())\n\n    async def registration_loop(self):\n        while not self.stopping:\n            await self.register_with_registry()\n            await asyncio.sleep(self.interval)\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-task-queue-pattern","title":"API Gateway - Task Queue Pattern","text":"<pre><code># Redis-backed background task processing\n@dataclass\nclass ProcessPromptTask(BackgroundTask):\n    prompt_id: str\n    user_id: str\n\nclass PromptProcessingService:\n    async def queue_processing_task(self, prompt: Prompt):\n        task = ProcessPromptTask(prompt.id, prompt.user_id)\n        await self.task_scheduler.schedule_async(task)\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-event-driven-projections","title":"OpenBank - Event-Driven Projections","text":"<pre><code># Domain event-driven read model updates\nclass BankAccountProjectionHandler:\n    @dispatch(BankAccountCreatedDomainEventV1)\n    async def handle_async(self, event: BankAccountCreatedDomainEventV1):\n        projection = BankAccountProjection.from_event(event)\n        await self.projection_repository.save_async(projection)\n</code></pre>"},{"location":"samples/desktop_controller/#testing-strategies","title":"Testing Strategies","text":""},{"location":"samples/desktop_controller/#desktop-controller-system-integration-testing","title":"Desktop Controller - System Integration Testing","text":"<pre><code># SSH integration tests\n@pytest.mark.integration\nclass TestSSHIntegration:\n    async def test_host_command_execution(self):\n        ssh_client = SecuredHost(test_settings)\n        result = await ssh_client.run_command_async(HostCommand(\"echo test\"))\n        assert result.exit_status == 0\n        assert \"test\" in result.stdout\n\n# Background service testing\nclass TestDesktopRegistrator:\n    async def test_periodic_registration(self):\n        registrator = DesktopRegistrator(mock_cloud_event_bus)\n        await registrator.start_async()\n        # Verify registration events are published\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-integration-heavy-testing","title":"API Gateway - Integration-Heavy Testing","text":"<pre><code># External service integration tests\n@pytest.mark.integration\nclass TestExternalServices:\n    async def test_mosaic_api_integration(self):\n        client = MosaicApiClient(test_settings)\n        response = await client.get_data_async(\"test-id\")\n        assert response.status_code == 200\n\n# Background task testing\nclass TestTaskProcessing:\n    async def test_prompt_processing_workflow(self):\n        task = ProcessPromptTask(\"prompt-123\", \"user-456\")\n        result = await self.task_processor.process_async(task)\n        assert result.is_success\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-domain-focused-testing","title":"OpenBank - Domain-Focused Testing","text":"<pre><code># Rich domain behavior testing\nclass TestBankAccount:\n    def test_account_creation_raises_creation_event(self):\n        account = BankAccount()\n        account.create_account(\"owner-123\", Decimal(\"1000.00\"))\n\n        events = account._pending_events\n        assert len(events) == 1\n        assert isinstance(events[0], BankAccountCreatedDomainEventV1)\n\n# Event sourcing testing\nclass TestEventStore:\n    async def test_aggregate_reconstruction_from_events(self):\n        events = [creation_event, transaction_event]\n        account = await self.repository.load_from_events(events)\n        assert account.balance == expected_balance\n</code></pre>"},{"location":"samples/desktop_controller/#use-case-recommendations","title":"Use Case Recommendations","text":""},{"location":"samples/desktop_controller/#choose-desktop-controller-pattern-when","title":"Choose Desktop Controller Pattern when","text":"<ul> <li>\u2705 Building system administration and control applications</li> <li>\u2705 Managing remote desktop or VM environments</li> <li>\u2705 Implementing SSH-based automation and control</li> <li>\u2705 Creating enterprise desktop management solutions</li> <li>\u2705 Needing periodic service registration and discovery</li> <li>\u2705 Integrating containerized apps with host systems</li> <li>\u2705 Building secure remote command execution systems</li> </ul>"},{"location":"samples/desktop_controller/#choose-api-gateway-pattern-when","title":"Choose API Gateway Pattern when","text":"<ul> <li>\u2705 Building microservice entry points and orchestration</li> <li>\u2705 Implementing complex external service integration</li> <li>\u2705 Creating service mesh control planes</li> <li>\u2705 Needing advanced authentication and authorization</li> <li>\u2705 Building background task processing systems</li> <li>\u2705 Implementing file storage and caching solutions</li> </ul>"},{"location":"samples/desktop_controller/#choose-event-sourcing-pattern-when","title":"Choose Event Sourcing Pattern when","text":"<ul> <li>\u2705 Rich domain models with behavior</li> <li>\u2705 Complete audit trails and temporal queries</li> <li>\u2705 Event-driven architecture with projections</li> <li>\u2705 Financial or business-critical applications</li> <li>\u2705 CQRS with separate read/write models</li> </ul>"},{"location":"samples/desktop_controller/#framework-features-utilized","title":"Framework Features Utilized","text":"<p>The Desktop Controller sample demonstrates unique aspects of the Neuroglia framework:</p> <ul> <li>Background Services: <code>HostedService</code> for long-running registration tasks</li> <li>SSH Integration: Custom integration services for secure system communication</li> <li>Cloud Event Publishing: External service registration and discovery</li> <li>File-Based Repositories: Remote filesystem data persistence</li> <li>OAuth2 Security: Enterprise authentication with secure key management</li> <li>System Integration Patterns: Container-to-host communication strategies</li> </ul> <p>Both samples showcase different strengths of the Neuroglia framework, demonstrating its flexibility in supporting various architectural patterns while maintaining clean architecture principles.</p>"},{"location":"samples/desktop_controller/#overview","title":"Overview","text":""},{"location":"samples/desktop_controller/#controllers-interactions","title":"Controller's Interactions","text":"<p>TODO</p>"},{"location":"samples/desktop_controller/#controllers-context","title":"Controller's Context","text":"<p>TODO</p>"},{"location":"samples/desktop_controller/#design","title":"Design","text":"<p>TODO</p>"},{"location":"samples/desktop_controller/#development","title":"Development","text":""},{"location":"samples/desktop_controller/#setup","title":"Setup","text":"<pre><code># 0. Prerequisites:\n#    Have Python 3.12 installed\n#\n#    - Create/Activate a local python environment (e.g. with pyenv)\n#      pyenv virtualenv 3.12.2 desktop-controller\n#      pyenv activate desktop-controller\n#\n#    - Start Docker Desktop locally\n#\n# 1. Clone the repository\ncd ~/\n\ngit clone git@....\n\ncd desktop-controller\n\n# pip install pre-commit\npre-commit install\n\n# pip install poetry\npoetry lock &amp;&amp; poetry install\n\n# 2. Start the docker-compose stack\n# sudo apt-get install make\nmake up\n\n# Access Swagger UI\nopen http://localhost:8080/docs\n</code></pre>"},{"location":"samples/desktop_controller/#key-implementation-highlights","title":"\ud83d\udca1 Key Implementation Highlights","text":"<p>The Desktop Controller sample uniquely demonstrates:</p>"},{"location":"samples/desktop_controller/#1-dual-security-architecture","title":"1. Dual Security Architecture","text":"<ul> <li>API Security: OAuth2/JWT for REST API access</li> <li>System Security: SSH key-based authentication for host communication</li> <li>Separation of Concerns: Different security models for different access layers</li> </ul>"},{"location":"samples/desktop_controller/#2-container-to-host-communication","title":"2. Container-to-Host Communication","text":"<ul> <li>SSH Bridge: Secure communication between containerized service and host system</li> <li>Command Execution: Remote shell command execution with result capture</li> <li>File System Access: Remote file management on host filesystem</li> </ul>"},{"location":"samples/desktop_controller/#3-background-service-registration","title":"3. Background Service Registration","text":"<ul> <li>Self-Discovery: Periodic registration with external service registry</li> <li>Cloud Events: Standards-based event publishing for service discovery</li> <li>Heartbeat Pattern: Continuous availability signaling</li> </ul>"},{"location":"samples/desktop_controller/#4-system-integration-patterns","title":"4. System Integration Patterns","text":"<ul> <li>Host Information Gathering: Real-time system state collection</li> <li>Remote Control Operations: Secure desktop management capabilities</li> <li>State Persistence: File-based data storage for inter-application communication</li> </ul> <p>This sample showcases how the Neuroglia framework can effectively bridge containerized microservices with host system management, providing enterprise-grade security and reliability for remote desktop control scenarios.</p> <p>Both the Desktop Controller and other samples demonstrate the framework's versatility in handling diverse architectural patterns - from event-sourced business applications to system integration and service orchestration solutions.</p>"},{"location":"samples/lab-resource-manager/","title":"\ud83e\uddea Lab Resource Manager Sample Application","text":"<p>The Lab Resource Manager demonstrates Resource Oriented Architecture (ROA) patterns using Neuroglia's advanced features. It simulates a system for managing ephemeral lab environments for students, showcasing watchers, controllers, and reconciliation loops.</p>"},{"location":"samples/lab-resource-manager/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>Resource Oriented Architecture: Declarative resource management patterns</li> <li>Watcher Pattern: Continuous monitoring of resource changes</li> <li>Controller Pattern: Event-driven business logic responses</li> <li>Reconciliation Loops: Periodic consistency checks and drift correction</li> <li>State Machine Implementation: Resource lifecycle management</li> <li>Asynchronous Coordination: Multiple concurrent components working together</li> </ul>"},{"location":"samples/lab-resource-manager/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Lab Resource Manager                            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502   Watcher       \u2502    \u2502   Controller    \u2502    \u2502  Reconciler     \u2502 \u2502\n\u2502  \u2502   (2s polling)  \u2502\u2500\u2500\u2500\u25b6\u2502   (immediate)   \u2502    \u2502   (10s loop)    \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502           \u2502                       \u2502                       \u2502        \u2502\n\u2502           \u25bc                       \u25bc                       \u25bc        \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502                    Resource Storage                           \u2502 \u2502\n\u2502  \u2502            (Kubernetes-like API with versioning)              \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"samples/lab-resource-manager/#domain-model","title":"\ud83c\udfaf Domain Model","text":""},{"location":"samples/lab-resource-manager/#labinstance-resource","title":"LabInstance Resource","text":"<p>The core resource representing a student lab environment:</p> <pre><code>@dataclass\nclass LabInstanceResource:\n    api_version: str = \"lab.neuroglia.com/v1\"\n    kind: str = \"LabInstance\"\n    metadata: Dict[str, Any] = None  # Name, namespace, timestamps, versions\n    spec: Dict[str, Any] = None      # Desired state: template, duration, student\n    status: Dict[str, Any] = None    # Current state: phase, endpoint, conditions\n</code></pre>"},{"location":"samples/lab-resource-manager/#resource-states","title":"Resource States","text":"<p>Lab instances progress through a defined lifecycle:</p> <pre><code>PENDING \u2500\u2500\u2192 PROVISIONING \u2500\u2500\u2192 READY \u2500\u2500\u2192 DELETING \u2500\u2500\u2192 DELETED\n   \u2502              \u2502             \u2502\n   \u25bc              \u25bc             \u25bc\nFAILED        FAILED         FAILED\n</code></pre>"},{"location":"samples/lab-resource-manager/#sample-resource","title":"Sample Resource","text":"<pre><code>{\n  \"apiVersion\": \"lab.neuroglia.com/v1\",\n  \"kind\": \"LabInstance\",\n  \"metadata\": {\n    \"name\": \"python-basics-lab\",\n    \"namespace\": \"student-labs\",\n    \"resourceVersion\": \"1\",\n    \"creationTimestamp\": \"2025-09-09T21:34:19Z\"\n  },\n  \"spec\": {\n    \"template\": \"python-basics\",\n    \"studentEmail\": \"student@example.com\",\n    \"duration\": \"60m\",\n    \"environment\": {\n      \"PYTHON_VERSION\": \"3.11\"\n    }\n  },\n  \"status\": {\n    \"state\": \"ready\",\n    \"message\": \"Lab instance is ready\",\n    \"endpoint\": \"https://lab-python-basics.example.com\",\n    \"readyAt\": \"2025-09-09T21:34:25Z\"\n  }\n}\n</code></pre>"},{"location":"samples/lab-resource-manager/#component-implementation","title":"\ud83d\udd27 Component Implementation","text":""},{"location":"samples/lab-resource-manager/#1-watcher-labinstancewatcher","title":"1. Watcher: LabInstanceWatcher","text":"<p>Continuously monitors for resource changes:</p> <pre><code>class LabInstanceWatcher:\n    async def start_watching(self):\n        while self.is_running:\n            # Poll for changes since last known version\n            changes = self.storage.list_resources(since_version=self.last_resource_version)\n\n            for resource in changes:\n                resource_version = int(resource.metadata.get('resourceVersion', '0'))\n                if resource_version &gt; self.last_resource_version:\n                    await self._handle_resource_change(resource)\n                    self.last_resource_version = max(self.last_resource_version, resource_version)\n\n            await asyncio.sleep(self.poll_interval)\n</code></pre> <p>Key Features:</p> <ul> <li>Polls every 2 seconds for near-real-time responsiveness</li> <li>Uses resource versioning to detect changes efficiently</li> <li>Notifies multiple event handlers when changes occur</li> <li>Handles errors gracefully with continued monitoring</li> </ul>"},{"location":"samples/lab-resource-manager/#2-controller-labinstancecontroller","title":"2. Controller: LabInstanceController","text":"<p>Implements business logic for state transitions:</p> <pre><code>class LabInstanceController:\n    async def handle_resource_event(self, resource: LabInstanceResource):\n        current_state = resource.status.get('state')\n\n        if current_state == ResourceState.PENDING.value:\n            await self._start_provisioning(resource)\n        elif current_state == ResourceState.PROVISIONING.value:\n            await self._check_provisioning_status(resource)\n        elif current_state == ResourceState.READY.value:\n            await self._monitor_lab_instance(resource)\n</code></pre> <p>Key Features:</p> <ul> <li>Event-driven processing responding immediately to changes</li> <li>State machine implementation with clear transitions</li> <li>Business rule enforcement (timeouts, validation, etc.)</li> <li>Integration with external provisioning systems</li> </ul>"},{"location":"samples/lab-resource-manager/#3-reconciler-labinstancescheduler","title":"3. Reconciler: LabInstanceScheduler","text":"<p>Provides safety and eventual consistency:</p> <pre><code>class LabInstanceScheduler:\n    async def start_reconciliation(self):\n        while self.is_running:\n            await self._reconcile_all_resources()\n            await asyncio.sleep(self.reconcile_interval)\n\n    async def _reconcile_resource(self, resource):\n        # Check for stuck states\n        if self._is_stuck_provisioning(resource):\n            await self._mark_as_failed(resource, \"Provisioning timeout\")\n\n        # Check for expiration\n        if self._is_expired(resource):\n            await self._schedule_deletion(resource)\n</code></pre> <p>Key Features:</p> <ul> <li>Runs every 10 seconds scanning all resources</li> <li>Detects stuck states and takes corrective action</li> <li>Enforces business policies (lab expiration, cleanup)</li> <li>Provides safety net for controller failures</li> </ul>"},{"location":"samples/lab-resource-manager/#execution-flow","title":"\u26a1 Execution Flow","text":""},{"location":"samples/lab-resource-manager/#1-resource-creation","title":"1. Resource Creation","text":"<pre><code>1. API creates LabInstance resource (state: PENDING)\n2. Storage backend assigns resource version and timestamps\n3. Watcher detects new resource on next poll cycle (\u22642s)\n4. Controller receives sevent and starts provisioning\n5. Resource state transitions to PROVISIONING\n</code></pre>"},{"location":"samples/lab-resource-manager/#2-state-progression","title":"2. State Progression","text":"<pre><code>6. Watcher detects state change to PROVISIONING\n7. Controller checks provisioning status periodically\n8. When provisioning completes, state transitions to READY\n9. Watcher detects READY state\n10. Controller begins monitoring ready lab instance\n</code></pre>"},{"location":"samples/lab-resource-manager/#3-reconciliation-safety","title":"3. Reconciliation Safety","text":"<pre><code>11. Reconciler runs every 10 seconds checking all resources\n12. Detects if any resource is stuck in PROVISIONING too long\n13. Marks stuck resources as FAILED with timeout message\n14. Detects expired READY resources and schedules deletion\n</code></pre>"},{"location":"samples/lab-resource-manager/#running-the-sample","title":"\ud83d\ude80 Running the Sample","text":""},{"location":"samples/lab-resource-manager/#prerequisites","title":"Prerequisites","text":"<pre><code>cd samples/lab-resource-manager\n</code></pre>"},{"location":"samples/lab-resource-manager/#option-1-full-interactive-demo","title":"Option 1: Full Interactive Demo","text":"<pre><code>python run_watcher_demo.py\n</code></pre> <p>This runs the complete demonstration showing:</p> <ul> <li>Resource creation and state transitions</li> <li>Watcher detecting changes in real-time</li> <li>Controller responding with business logic</li> <li>Reconciler providing safety and cleanup</li> </ul>"},{"location":"samples/lab-resource-manager/#option-2-simple-patterns-demo","title":"Option 2: Simple Patterns Demo","text":"<pre><code>python simple_demo.py\n</code></pre> <p>A simplified version focusing on the core patterns without framework dependencies.</p>"},{"location":"samples/lab-resource-manager/#expected-output","title":"Expected Output","text":"<pre><code>\ud83c\udfaf Resource Oriented Architecture: Watcher &amp; Reconciliation Demo\n============================================================\n\ud83d\udc40 LabInstance Watcher started\n\ud83d\udd04 LabInstance Scheduler started reconciliation\n\ud83d\udce6 Created resource: student-labs/python-basics-lab\n\ud83d\udd0d Watcher detected change: student-labs/python-basics-lab -&gt; pending\n\ud83c\udfae Controller processing: student-labs/python-basics-lab (state: pending)\n\ud83d\ude80 Starting provisioning for: student-labs/python-basics-lab\n\ud83d\udd04 Updated resource: student-labs/python-basics-lab -&gt; {'status': {'state': 'provisioning'}}\n\ud83d\udd0d Watcher detected change: student-labs/python-basics-lab -&gt; provisioning\n\ud83c\udfae Controller processing: student-labs/python-basics-lab (state: provisioning)\n\ud83d\udd04 Reconciling 2 lab instances\n\u26a0\ufe0f Reconciler: Lab instance stuck in provisioning: student-labs/python-basics-lab\n</code></pre>"},{"location":"samples/lab-resource-manager/#key-implementation-details","title":"\ud83d\udca1 Key Implementation Details","text":""},{"location":"samples/lab-resource-manager/#resource-versioning","title":"Resource Versioning","text":"<p>Each resource change increments the version:</p> <pre><code>def update_resource(self, resource_id: str, updates: Dict[str, Any]):\n    resource = self.resources[resource_id]\n    self.resource_version += 1\n    resource.metadata['resourceVersion'] = str(self.resource_version)\n</code></pre>"},{"location":"samples/lab-resource-manager/#event-handling","title":"Event Handling","text":"<p>Watchers notify multiple handlers:</p> <pre><code>watcher.add_event_handler(controller.handle_resource_event)\nwatcher.add_event_handler(audit_logger.log_change)\nwatcher.add_event_handler(metrics_collector.record_event)\n</code></pre>"},{"location":"samples/lab-resource-manager/#error-resilience","title":"Error Resilience","text":"<p>All components handle errors gracefully:</p> <pre><code>try:\n    await self._provision_lab_instance(resource)\nexcept Exception as e:\n    logger.error(f\"Provisioning failed: {e}\")\n    await self._mark_as_failed(resource, str(e))\n</code></pre>"},{"location":"samples/lab-resource-manager/#concurrent-processing","title":"Concurrent Processing","text":"<p>Components run independently:</p> <pre><code>async def main():\n    watcher_task = asyncio.create_task(watcher.start_watching())\n    scheduler_task = asyncio.create_task(scheduler.start_reconciliation())\n\n    # Both run concurrently until stopped\n    await asyncio.gather(watcher_task, scheduler_task)\n</code></pre>"},{"location":"samples/lab-resource-manager/#design-patterns-demonstrated","title":"\ud83c\udfaf Design Patterns Demonstrated","text":""},{"location":"samples/lab-resource-manager/#1-observer-pattern","title":"1. Observer Pattern","text":"<p>Watchers observe storage and notify controllers of changes.</p>"},{"location":"samples/lab-resource-manager/#2-state-machine","title":"2. State Machine","text":"<p>Resources progress through well-defined states with clear transitions.</p>"},{"location":"samples/lab-resource-manager/#3-command-pattern","title":"3. Command Pattern","text":"<p>Controllers execute commands based on resource state.</p>"},{"location":"samples/lab-resource-manager/#4-strategy-pattern","title":"4. Strategy Pattern","text":"<p>Different provisioning strategies for different lab templates.</p>"},{"location":"samples/lab-resource-manager/#5-circuit-breaker","title":"5. Circuit Breaker","text":"<p>Reconcilers detect failures and prevent cascade issues.</p>"},{"location":"samples/lab-resource-manager/#configuration-options","title":"\ud83d\udd27 Configuration Options","text":""},{"location":"samples/lab-resource-manager/#timing-configuration","title":"Timing Configuration","text":"<pre><code># Development: Fast feedback\nwatcher = LabInstanceWatcher(storage, poll_interval=1.0)\nscheduler = LabInstanceScheduler(storage, reconcile_interval=5.0)\n\n# Production: Optimized performance\nwatcher = LabInstanceWatcher(storage, poll_interval=5.0)\nscheduler = LabInstanceScheduler(storage, reconcile_interval=30.0)\n</code></pre>"},{"location":"samples/lab-resource-manager/#timeout-configuration","title":"Timeout Configuration","text":"<pre><code>class LabInstanceController:\n    PROVISIONING_TIMEOUT = 300  # 5 minutes\n    MAX_RETRIES = 3\n    RETRY_BACKOFF = 30  # seconds\n</code></pre>"},{"location":"samples/lab-resource-manager/#resource-policies","title":"Resource Policies","text":"<pre><code>class LabInstanceScheduler:\n    DEFAULT_LAB_DURATION = 3600  # 1 hour\n    CLEANUP_GRACE_PERIOD = 300   # 5 minutes\n    MAX_CONCURRENT_PROVISIONS = 10\n</code></pre>"},{"location":"samples/lab-resource-manager/#testing-the-sample","title":"\ud83e\uddea Testing the Sample","text":"<p>The sample includes comprehensive tests:</p> <pre><code># Run all sample tests\npytest samples/lab-resource-manager/tests/\n\n# Test individual components\npytest samples/lab-resource-manager/tests/test_watcher.py\npytest samples/lab-resource-manager/tests/test_controller.py\npytest samples/lab-resource-manager/tests/test_reconciler.py\n</code></pre>"},{"location":"samples/lab-resource-manager/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\ud83c\udfaf Resource Oriented Architecture - Core ROA concepts</li> <li>\ud83c\udfd7\ufe0f Watcher &amp; Reconciliation Patterns - Detailed patterns</li> <li>\u26a1 Execution Flow - Component coordination</li> <li>\ud83c\udfaf CQRS &amp; Mediation - Command/Query handling</li> <li>\ud83d\uddc4\ufe0f Data Access - Storage patterns</li> <li>\ud83d\udccb Source Code Naming Conventions - Consistent naming patterns used in this sample</li> </ul>"},{"location":"samples/lab-resource-manager/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<p>After exploring this sample:</p> <ol> <li>Extend the Domain: Add more resource types (LabTemplate, StudentSession)</li> <li>Add Persistence: Integrate with MongoDB or Event Store</li> <li>Implement Authentication: Add student authentication and authorization</li> <li>Add Monitoring: Integrate metrics collection and alerting</li> <li>Scale Horizontally: Implement resource sharding for multiple instances</li> </ol>"},{"location":"samples/openbank/","title":"\ud83c\udfe6 OpenBank Sample Application","text":"<p>OpenBank is a comprehensive sample application that demonstrates advanced Neuroglia features including event sourcing, CQRS, domain-driven design, and event-driven architecture. It simulates a simple banking system with persons and accounts.</p>"},{"location":"samples/openbank/#overview","title":"\ud83c\udfaf Overview","text":"<p>The OpenBank sample showcases:</p> <ul> <li>Event Sourcing: Complete event-sourced domain with event store</li> <li>CQRS: Separate command and query models</li> <li>Domain-Driven Design: Rich domain models with business rules</li> <li>Event-Driven Architecture: Domain events and integration events</li> <li>Clean Architecture: Clear separation of layers</li> <li>Repository Pattern: Both write (event sourcing) and read (MongoDB) repositories</li> </ul>"},{"location":"samples/openbank/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    API Layer                                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502  PersonsController \u2502  \u2502 AccountsController \u2502  \u2502  Other APIs  \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Application Layer                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502    Commands     \u2502  \u2502     Queries     \u2502  \u2502     Events     \u2502   \u2502\n\u2502  \u2502   Handlers      \u2502  \u2502    Handlers     \u2502  \u2502   Handlers     \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Domain Layer                                 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502     Person      \u2502  \u2502     Account     \u2502  \u2502    Address     \u2502   \u2502\n\u2502  \u2502   Aggregate     \u2502  \u2502   Aggregate     \u2502  \u2502 Value Object   \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Integration Layer                              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502 Event Store     \u2502  \u2502   MongoDB       \u2502  \u2502  API Clients   \u2502   \u2502\n\u2502  \u2502 Repository      \u2502  \u2502  Repository     \u2502  \u2502                \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"samples/openbank/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"samples/openbank/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+</li> <li>Docker and Docker Compose</li> <li>MongoDB (via Docker)</li> <li>EventStoreDB (via Docker)</li> </ul>"},{"location":"samples/openbank/#setup","title":"Setup","text":"<ol> <li>Start Dependencies:</li> </ol> <pre><code>cd samples/openbank\ndocker-compose up -d mongodb eventstoredb\n</code></pre> <ol> <li>Install Dependencies:</li> </ol> <pre><code>pip install -r requirements.txt\n</code></pre> <ol> <li>Run the Application:</li> </ol> <pre><code>python api/main.py\n</code></pre> <ol> <li> <p>Access the API:</p> </li> <li> <p>API Documentation: http://localhost:8000/api/docs</p> </li> <li>EventStoreDB UI: http://localhost:2113 (admin/changeit)</li> </ol>"},{"location":"samples/openbank/#project-structure","title":"\ud83d\udcc1 Project Structure","text":"<pre><code>samples/openbank/\n\u251c\u2500\u2500 api/\n\u2502   \u251c\u2500\u2500 main.py                     # Application entry point\n\u2502   \u2514\u2500\u2500 controllers/\n\u2502       \u251c\u2500\u2500 persons_controller.py   # Person management API\n\u2502       \u2514\u2500\u2500 accounts_controller.py  # Account management API\n\u251c\u2500\u2500 application/\n\u2502   \u251c\u2500\u2500 commands/\n\u2502   \u2502   \u251c\u2500\u2500 persons/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 register_person_command.py\n\u2502   \u2502   \u2514\u2500\u2500 accounts/\n\u2502   \u2502       \u251c\u2500\u2500 open_account_command.py\n\u2502   \u2502       \u2514\u2500\u2500 deposit_command.py\n\u2502   \u251c\u2500\u2500 queries/\n\u2502   \u2502   \u251c\u2500\u2500 person_by_id.py\n\u2502   \u2502   \u2514\u2500\u2500 account_by_owner.py\n\u2502   \u2514\u2500\u2500 events/\n\u2502       \u251c\u2500\u2500 integration/\n\u2502       \u2502   \u2514\u2500\u2500 person_registered_handler.py\n\u2502       \u2514\u2500\u2500 domain/\n\u251c\u2500\u2500 domain/\n\u2502   \u2514\u2500\u2500 models/\n\u2502       \u251c\u2500\u2500 person.py               # Person aggregate\n\u2502       \u251c\u2500\u2500 account.py              # Account aggregate\n\u2502       \u2514\u2500\u2500 address.py              # Address value object\n\u2514\u2500\u2500 integration/\n    \u251c\u2500\u2500 models/                     # DTOs and read models\n    \u2502   \u251c\u2500\u2500 person.py\n    \u2502   \u2514\u2500\u2500 account.py\n    \u2514\u2500\u2500 commands/                   # API command DTOs\n        \u2514\u2500\u2500 persons/\n            \u2514\u2500\u2500 register_person_command_dto.py\n</code></pre>"},{"location":"samples/openbank/#domain-models","title":"\ud83c\udfdb\ufe0f Domain Models","text":""},{"location":"samples/openbank/#person-aggregate","title":"Person Aggregate","text":"<p>The Person aggregate manages person registration and personal information:</p> <pre><code>from dataclasses import dataclass\nfrom datetime import date\nfrom neuroglia.data.abstractions import AggregateRoot\nfrom samples.openbank.integration import PersonGender\n\n@dataclass\nclass PersonState:\n    \"\"\"Person aggregate state\"\"\"\n    id: str = None\n    first_name: str = None\n    last_name: str = None\n    nationality: str = None\n    gender: PersonGender = None\n    date_of_birth: date = None\n    address: Address = None\n\nclass Person(AggregateRoot[str]):\n    \"\"\"Person aggregate root\"\"\"\n\n    def __init__(self, id: str = None):\n        super().__init__(id)\n        self.state = PersonState()\n\n    def register(self, first_name: str, last_name: str, nationality: str,\n                gender: PersonGender, date_of_birth: date, address: Address):\n        \"\"\"Register a new person\"\"\"\n\n        # Validate business rules\n        if not first_name or not last_name:\n            raise ValueError(\"First name and last name are required\")\n\n        if date_of_birth &gt;= date.today():\n            raise ValueError(\"Date of birth must be in the past\")\n\n        # Raise domain event\n        self.apply(PersonRegisteredEvent(\n            person_id=self.id,\n            first_name=first_name,\n            last_name=last_name,\n            nationality=nationality,\n            gender=gender,\n            date_of_birth=date_of_birth,\n            address=address\n        ))\n\n    def update_address(self, new_address: Address):\n        \"\"\"Update person's address\"\"\"\n        self.apply(PersonAddressUpdatedEvent(\n            person_id=self.id,\n            old_address=self.state.address,\n            new_address=new_address\n        ))\n\n    # Event handlers\n    def on_person_registered(self, event: PersonRegisteredEvent):\n        \"\"\"Handle person registered event\"\"\"\n        self.state.id = event.person_id\n        self.state.first_name = event.first_name\n        self.state.last_name = event.last_name\n        self.state.nationality = event.nationality\n        self.state.gender = event.gender\n        self.state.date_of_birth = event.date_of_birth\n        self.state.address = event.address\n\n    def on_person_address_updated(self, event: PersonAddressUpdatedEvent):\n        \"\"\"Handle address updated event\"\"\"\n        self.state.address = event.new_address\n</code></pre>"},{"location":"samples/openbank/#account-aggregate","title":"Account Aggregate","text":"<p>The Account aggregate manages banking accounts and transactions:</p> <pre><code>from decimal import Decimal\nfrom neuroglia.data.abstractions import AggregateRoot\n\n@dataclass\nclass AccountState:\n    \"\"\"Account aggregate state\"\"\"\n    id: str = None\n    owner_id: str = None\n    account_number: str = None\n    balance: Decimal = Decimal('0.00')\n    currency: str = 'USD'\n    is_active: bool = True\n\nclass Account(AggregateRoot[str]):\n    \"\"\"Account aggregate root\"\"\"\n\n    def __init__(self, id: str = None):\n        super().__init__(id)\n        self.state = AccountState()\n\n    def open(self, owner_id: str, account_number: str, initial_deposit: Decimal = None):\n        \"\"\"Open a new account\"\"\"\n\n        # Validate business rules\n        if not owner_id:\n            raise ValueError(\"Owner ID is required\")\n\n        if not account_number:\n            raise ValueError(\"Account number is required\")\n\n        if initial_deposit and initial_deposit &lt; Decimal('0'):\n            raise ValueError(\"Initial deposit cannot be negative\")\n\n        # Raise domain event\n        self.apply(AccountOpenedEvent(\n            account_id=self.id,\n            owner_id=owner_id,\n            account_number=account_number,\n            initial_deposit=initial_deposit or Decimal('0.00')\n        ))\n\n    def deposit(self, amount: Decimal, description: str = None):\n        \"\"\"Deposit money to the account\"\"\"\n\n        # Validate business rules\n        if amount &lt;= Decimal('0'):\n            raise ValueError(\"Deposit amount must be positive\")\n\n        if not self.state.is_active:\n            raise ValueError(\"Cannot deposit to inactive account\")\n\n        # Raise domain event\n        self.apply(MoneyDepositedEvent(\n            account_id=self.id,\n            amount=amount,\n            description=description,\n            balance_after=self.state.balance + amount\n        ))\n\n    def withdraw(self, amount: Decimal, description: str = None):\n        \"\"\"Withdraw money from the account\"\"\"\n\n        # Validate business rules\n        if amount &lt;= Decimal('0'):\n            raise ValueError(\"Withdrawal amount must be positive\")\n\n        if not self.state.is_active:\n            raise ValueError(\"Cannot withdraw from inactive account\")\n\n        if self.state.balance &lt; amount:\n            raise ValueError(\"Insufficient funds\")\n\n        # Raise domain event\n        self.apply(MoneyWithdrawnEvent(\n            account_id=self.id,\n            amount=amount,\n            description=description,\n            balance_after=self.state.balance - amount\n        ))\n\n    # Event handlers\n    def on_account_opened(self, event: AccountOpenedEvent):\n        \"\"\"Handle account opened event\"\"\"\n        self.state.id = event.account_id\n        self.state.owner_id = event.owner_id\n        self.state.account_number = event.account_number\n        self.state.balance = event.initial_deposit\n\n    def on_money_deposited(self, event: MoneyDepositedEvent):\n        \"\"\"Handle money deposited event\"\"\"\n        self.state.balance = event.balance_after\n\n    def on_money_withdrawn(self, event: MoneyWithdrawnEvent):\n        \"\"\"Handle money withdrawn event\"\"\"\n        self.state.balance = event.balance_after\n</code></pre>"},{"location":"samples/openbank/#application-layer","title":"\ud83d\udcbc Application Layer","text":""},{"location":"samples/openbank/#command-handlers","title":"Command Handlers","text":"<p>Command handlers execute business operations:</p> <pre><code>from neuroglia.mediation.mediator import CommandHandler\nfrom neuroglia.data.infrastructure.abstractions import Repository\n\nclass RegisterPersonCommandHandler(CommandHandler[RegisterPersonCommand, OperationResult[PersonDto]]):\n    \"\"\"Handles person registration commands\"\"\"\n\n    def __init__(self,\n                 mapper: Mapper,\n                 person_repository: Repository[Person, str]):\n        self.mapper = mapper\n        self.person_repository = person_repository\n\n    async def handle_async(self, command: RegisterPersonCommand) -&gt; OperationResult[PersonDto]:\n        try:\n            # Create new person aggregate\n            person = Person(str(uuid.uuid4()))\n\n            # Execute business operation\n            person.register(\n                first_name=command.first_name,\n                last_name=command.last_name,\n                nationality=command.nationality,\n                gender=command.gender,\n                date_of_birth=command.date_of_birth,\n                address=command.address\n            )\n\n            # Save to event store\n            saved_person = await self.person_repository.add_async(person)\n\n            # Map to DTO and return\n            person_dto = self.mapper.map(saved_person.state, PersonDto)\n            return self.created(person_dto)\n\n        except ValueError as ex:\n            return self.bad_request(str(ex))\n        except Exception as ex:\n            return self.internal_error(f\"Failed to register person: {ex}\")\n\nclass DepositCommandHandler(CommandHandler[DepositCommand, OperationResult[AccountDto]]):\n    \"\"\"Handles money deposit commands\"\"\"\n\n    def __init__(self,\n                 mapper: Mapper,\n                 account_repository: Repository[Account, str]):\n        self.mapper = mapper\n        self.account_repository = account_repository\n\n    async def handle_async(self, command: DepositCommand) -&gt; OperationResult[AccountDto]:\n        try:\n            # Load account from event store\n            account = await self.account_repository.get_by_id_async(command.account_id)\n            if account is None:\n                return self.not_found(\"Account not found\")\n\n            # Execute business operation\n            account.deposit(command.amount, command.description)\n\n            # Save changes\n            await self.account_repository.update_async(account)\n\n            # Map to DTO and return\n            account_dto = self.mapper.map(account.state, AccountDto)\n            return self.ok(account_dto)\n\n        except ValueError as ex:\n            return self.bad_request(str(ex))\n        except Exception as ex:\n            return self.internal_error(f\"Failed to deposit money: {ex}\")\n</code></pre>"},{"location":"samples/openbank/#query-handlers","title":"Query Handlers","text":"<p>Query handlers retrieve data for read operations:</p> <pre><code>class GetPersonByIdQueryHandler(QueryHandler[GetPersonByIdQuery, OperationResult[PersonDto]]):\n    \"\"\"Handles person lookup queries\"\"\"\n\n    def __init__(self,\n                 mapper: Mapper,\n                 person_repository: Repository[PersonDto, str]):  # Read model repository\n        self.mapper = mapper\n        self.person_repository = person_repository\n\n    async def handle_async(self, query: GetPersonByIdQuery) -&gt; OperationResult[PersonDto]:\n        person = await self.person_repository.get_by_id_async(query.person_id)\n\n        if person is None:\n            return self.not_found(f\"Person with ID {query.person_id} not found\")\n\n        return self.ok(person)\n\nclass GetAccountsByOwnerQueryHandler(QueryHandler[GetAccountsByOwnerQuery, OperationResult[List[AccountDto]]]):\n    \"\"\"Handles account lookup by owner queries\"\"\"\n\n    def __init__(self, account_repository: Repository[AccountDto, str]):\n        self.account_repository = account_repository\n\n    async def handle_async(self, query: GetAccountsByOwnerQuery) -&gt; OperationResult[List[AccountDto]]:\n        accounts = await self.account_repository.find_by_criteria_async(\n            {\"owner_id\": query.owner_id}\n        )\n        return self.ok(accounts)\n</code></pre>"},{"location":"samples/openbank/#event-handling","title":"\ud83d\udce1 Event Handling","text":""},{"location":"samples/openbank/#domain-events","title":"Domain Events","text":"<p>Domain events represent business events within aggregates:</p> <pre><code>@dataclass\nclass PersonRegisteredEvent(DomainEvent):\n    \"\"\"Event raised when a person is registered\"\"\"\n    person_id: str\n    first_name: str\n    last_name: str\n    nationality: str\n    gender: PersonGender\n    date_of_birth: date\n    address: Address\n\n@dataclass\nclass AccountOpenedEvent(DomainEvent):\n    \"\"\"Event raised when an account is opened\"\"\"\n    account_id: str\n    owner_id: str\n    account_number: str\n    initial_deposit: Decimal\n\n@dataclass\nclass MoneyDepositedEvent(DomainEvent):\n    \"\"\"Event raised when money is deposited\"\"\"\n    account_id: str\n    amount: Decimal\n    description: str\n    balance_after: Decimal\n</code></pre>"},{"location":"samples/openbank/#integration-events","title":"Integration Events","text":"<p>Integration events handle cross-bounded-context communication:</p> <pre><code>class PersonRegisteredIntegrationEventHandler(EventHandler[PersonRegisteredEvent]):\n    \"\"\"Handles person registered events for integration purposes\"\"\"\n\n    def __init__(self,\n                 cloud_event_publisher: CloudEventPublisher,\n                 mapper: Mapper):\n        self.cloud_event_publisher = cloud_event_publisher\n        self.mapper = mapper\n\n    async def handle_async(self, event: PersonRegisteredEvent):\n        # Create integration event\n        integration_event = PersonRegisteredIntegrationEvent(\n            person_id=event.person_id,\n            email=event.email,\n            full_name=f\"{event.first_name} {event.last_name}\",\n            timestamp=datetime.utcnow()\n        )\n\n        # Publish as CloudEvent\n        await self.cloud_event_publisher.publish_async(\n            event_type=\"person.registered.v1\",\n            data=integration_event,\n            source=\"openbank.persons\"\n        )\n</code></pre>"},{"location":"samples/openbank/#data-access","title":"\ud83d\uddc4\ufe0f Data Access","text":""},{"location":"samples/openbank/#event-sourcing-repository","title":"Event Sourcing Repository","text":"<p>The write model uses event sourcing:</p> <pre><code># Configuration in main.py\nfrom neuroglia.data.infrastructure.event_sourcing import EventSourcingRepository\nfrom neuroglia.data.infrastructure.event_sourcing.event_store import ESEventStore\n\n# Configure Event Store\nESEventStore.configure(builder, EventStoreOptions(database_name, consumer_group))\n\n# Configure event sourcing repositories\nDataAccessLayer.WriteModel.configure(\n    builder,\n    [\"samples.openbank.domain.models\"],\n    lambda builder_, entity_type, key_type: EventSourcingRepository.configure(\n        builder_, entity_type, key_type\n    )\n)\n</code></pre>"},{"location":"samples/openbank/#read-model-repository","title":"Read Model Repository","text":"<p>The read model uses MongoDB:</p> <pre><code># Configuration in main.py\nfrom neuroglia.data.infrastructure.mongo import MongoRepository\n\n# Configure MongoDB repositories\nDataAccessLayer.ReadModel.configure(\n    builder,\n    [\"samples.openbank.integration.models\", \"samples.openbank.application.events\"],\n    lambda builder_, entity_type, key_type: MongoRepository.configure(\n        builder_, entity_type, key_type, database_name\n    )\n)\n</code></pre>"},{"location":"samples/openbank/#api-layer","title":"\ud83c\udf10 API Layer","text":""},{"location":"samples/openbank/#controllers","title":"Controllers","text":"<p>Controllers expose the domain through REST APIs:</p> <pre><code>class PersonsController(ControllerBase):\n    \"\"\"Persons management API\"\"\"\n\n    @post(\"/\", response_model=PersonDto, status_code=201)\n    async def register_person(self, command: RegisterPersonCommandDto) -&gt; PersonDto:\n        \"\"\"Register a new person\"\"\"\n        # Map DTO to domain command\n        domain_command = self.mapper.map(command, RegisterPersonCommand)\n\n        # Execute through mediator\n        result = await self.mediator.execute_async(domain_command)\n\n        # Process and return result\n        return self.process(result)\n\n    @get(\"/\", response_model=List[PersonDto])\n    async def list_persons(self) -&gt; List[PersonDto]:\n        \"\"\"List all registered persons\"\"\"\n        query = ListPersonsQuery()\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/{person_id}\", response_model=PersonDto)\n    async def get_person_by_id(self, person_id: str) -&gt; PersonDto:\n        \"\"\"Get person by ID\"\"\"\n        query = GetPersonByIdQuery(person_id=person_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\nclass AccountsController(ControllerBase):\n    \"\"\"Accounts management API\"\"\"\n\n    @post(\"/\", response_model=AccountDto, status_code=201)\n    async def open_account(self, command: OpenAccountCommandDto) -&gt; AccountDto:\n        \"\"\"Open a new account\"\"\"\n        domain_command = self.mapper.map(command, OpenAccountCommand)\n        result = await self.mediator.execute_async(domain_command)\n        return self.process(result)\n\n    @post(\"/{account_id}/deposit\", response_model=AccountDto)\n    async def deposit(self, account_id: str, command: DepositCommandDto) -&gt; AccountDto:\n        \"\"\"Deposit money to account\"\"\"\n        domain_command = self.mapper.map(command, DepositCommand)\n        domain_command.account_id = account_id\n        result = await self.mediator.execute_async(domain_command)\n        return self.process(result)\n\n    @get(\"/by-owner/{owner_id}\", response_model=List[AccountDto])\n    async def get_accounts_by_owner(self, owner_id: str) -&gt; List[AccountDto]:\n        \"\"\"Get all accounts for a person\"\"\"\n        query = GetAccountsByOwnerQuery(owner_id=owner_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"samples/openbank/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"samples/openbank/#unit-tests","title":"Unit Tests","text":"<p>Test domain logic in isolation:</p> <pre><code>def test_person_registration():\n    # Arrange\n    person = Person(\"test-id\")\n    address = Address(\"123 Main St\", \"Anytown\", \"12345\", \"USA\")\n\n    # Act\n    person.register(\n        first_name=\"John\",\n        last_name=\"Doe\",\n        nationality=\"US\",\n        gender=PersonGender.MALE,\n        date_of_birth=date(1990, 1, 1),\n        address=address\n    )\n\n    # Assert\n    assert person.state.first_name == \"John\"\n    assert person.state.last_name == \"Doe\"\n    assert len(person.uncommitted_events) == 1\n    assert isinstance(person.uncommitted_events[0], PersonRegisteredEvent)\n\ndef test_account_deposit():\n    # Arrange\n    account = Account(\"test-account\")\n    account.open(\"owner-id\", \"123456789\", Decimal('100.00'))\n\n    # Act\n    account.deposit(Decimal('50.00'), \"Test deposit\")\n\n    # Assert\n    assert account.state.balance == Decimal('150.00')\n    assert len(account.uncommitted_events) == 2  # Open + Deposit\n</code></pre>"},{"location":"samples/openbank/#integration-tests","title":"Integration Tests","text":"<p>Test the complete flow:</p> <pre><code>@pytest.mark.asyncio\nasync def test_person_registration_flow():\n    # Arrange\n    client = TestClient(app)\n    person_data = {\n        \"first_name\": \"John\",\n        \"last_name\": \"Doe\",\n        \"nationality\": \"US\",\n        \"gender\": \"MALE\",\n        \"date_of_birth\": \"1990-01-01\",\n        \"address\": {\n            \"street\": \"123 Main St\",\n            \"city\": \"Anytown\",\n            \"postal_code\": \"12345\",\n            \"country\": \"USA\"\n        }\n    }\n\n    # Act\n    response = client.post(\"/api/v1/persons\", json=person_data)\n\n    # Assert\n    assert response.status_code == 201\n    person = response.json()\n    assert person[\"first_name\"] == \"John\"\n    assert person[\"last_name\"] == \"Doe\"\n\n    # Verify person can be retrieved\n    get_response = client.get(f\"/api/v1/persons/{person['id']}\")\n    assert get_response.status_code == 200\n</code></pre>"},{"location":"samples/openbank/#running-the-sample","title":"\ud83d\ude80 Running the Sample","text":""},{"location":"samples/openbank/#start-the-application","title":"Start the Application","text":"<ol> <li>Start infrastructure:</li> </ol> <pre><code>docker-compose up -d\n</code></pre> <ol> <li>Run the application:</li> </ol> <pre><code>python api/main.py\n</code></pre>"},{"location":"samples/openbank/#example-api-calls","title":"Example API Calls","text":"<p>Register a Person:</p> <pre><code>curl -X POST \"http://localhost:8000/api/v1/persons\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"first_name\": \"John\",\n    \"last_name\": \"Doe\",\n    \"nationality\": \"US\",\n    \"gender\": \"MALE\",\n    \"date_of_birth\": \"1990-01-01\",\n    \"address\": {\n      \"street\": \"123 Main St\",\n      \"city\": \"Anytown\",\n      \"postal_code\": \"12345\",\n      \"country\": \"USA\"\n    }\n  }'\n</code></pre> <p>Open an Account:</p> <pre><code>curl -X POST \"http://localhost:8000/api/v1/accounts\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"owner_id\": \"PERSON_ID_FROM_ABOVE\",\n    \"account_number\": \"123456789\",\n    \"initial_deposit\": 1000.00\n  }'\n</code></pre> <p>Deposit Money:</p> <pre><code>curl -X POST \"http://localhost:8000/api/v1/accounts/ACCOUNT_ID/deposit\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"amount\": 500.00,\n    \"description\": \"Salary deposit\"\n  }'\n</code></pre>"},{"location":"samples/openbank/#key-learnings","title":"\ud83d\udccb Key Learnings","text":"<p>The OpenBank sample demonstrates:</p> <ol> <li>Event Sourcing: How to store state as a sequence of events</li> <li>CQRS: Separation of write and read models</li> <li>Domain-Driven Design: Rich domain models with business rules</li> <li>Clean Architecture: Clear separation of concerns</li> <li>Event-Driven Architecture: How events enable loose coupling</li> <li>Repository Pattern: Abstract data access for different storage types</li> <li>Integration Events: Cross-bounded-context communication</li> </ol>"},{"location":"samples/openbank/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Basic Neuroglia concepts</li> <li>Event Sourcing - Event sourcing patterns</li> <li>CQRS &amp; Mediation - Command and query patterns</li> <li>Event Handling - Event-driven architecture</li> <li>Source Code Naming Conventions - Naming patterns used throughout this sample</li> </ul>"},{"location":"tutorials/","title":"\ud83d\udcd6 Tutorials","text":"<p>Learn Neuroglia by building real applications step-by-step.</p>"},{"location":"tutorials/#marios-pizzeria-complete-tutorial-series","title":"\ud83c\udf55 Mario's Pizzeria - Complete Tutorial Series","text":"<p>Build a production-ready pizza ordering system from scratch. This comprehensive 9-part tutorial teaches you everything you need to know about building applications with Neuroglia.</p> <p>What You'll Build: A complete pizza ordering and management system with:</p> <ul> <li>REST API with CRUD operations</li> <li>Clean architecture with proper layer separation</li> <li>CQRS pattern for commands and queries</li> <li>Event-driven features with domain events</li> <li>MongoDB persistence with repository pattern</li> <li>OAuth2 authentication with Keycloak</li> <li>Distributed tracing with OpenTelemetry</li> <li>Docker deployment</li> </ul> <p>Prerequisites: Complete the Getting Started guide first to understand the basics.</p>"},{"location":"tutorials/#tutorial-parts","title":"Tutorial Parts","text":""},{"location":"tutorials/#part-1-project-setup-structure","title":"Part 1: Project Setup &amp; Structure","text":"<p>Learn: Project organization, dependency injection, application bootstrapping</p> <p>\u2192 Start Part 1: Project Setup</p>"},{"location":"tutorials/#part-2-domain-model","title":"Part 2: Domain Model","text":"<p>Learn: Domain-Driven Design, entities, value objects, business rules</p> <p>\u2192 Continue to Part 2: Domain Model</p>"},{"location":"tutorials/#part-3-commands-queries-cqrs","title":"Part 3: Commands &amp; Queries (CQRS)","text":"<p>Learn: CQRS pattern, command handlers, query handlers, mediator</p> <p>\u2192 Continue to Part 3: CQRS</p>"},{"location":"tutorials/#part-4-api-controllers","title":"Part 4: API Controllers","text":"<p>Learn: REST APIs, FastAPI integration, DTOs, request/response handling</p> <p>\u2192 Continue to Part 4: API Controllers</p>"},{"location":"tutorials/#part-5-events-integration","title":"Part 5: Events &amp; Integration","text":"<p>Learn: Domain events, event handlers, event-driven architecture</p> <p>\u2192 Continue to Part 5: Events</p>"},{"location":"tutorials/#part-6-persistence-repositories","title":"Part 6: Persistence &amp; Repositories","text":"<p>Learn: Repository pattern, MongoDB integration, data access layer</p> <p>\u2192 Continue to Part 6: Persistence</p>"},{"location":"tutorials/#part-7-authentication-authorization","title":"Part 7: Authentication &amp; Authorization","text":"<p>Learn: OAuth2, Keycloak integration, JWT tokens, role-based access</p> <p>\u2192 Continue to Part 7: Authentication</p>"},{"location":"tutorials/#part-8-observability","title":"Part 8: Observability","text":"<p>Learn: OpenTelemetry, distributed tracing, metrics, structured logging</p> <p>\u2192 Continue to Part 8: Observability</p>"},{"location":"tutorials/#part-9-deployment","title":"Part 9: Deployment","text":"<p>Learn: Docker containers, docker-compose, production configuration</p> <p>\u2192 Continue to Part 9: Deployment</p>"},{"location":"tutorials/#what-youll-learn","title":"\ud83d\udcda What You'll Learn","text":""},{"location":"tutorials/#architecture-design","title":"Architecture &amp; Design","text":"<ul> <li>Clean Architecture - Layer separation and dependency rules</li> <li>Domain-Driven Design - Rich domain models with business logic</li> <li>CQRS - Command Query Responsibility Segregation</li> <li>Event-Driven Architecture - Domain events and eventual consistency</li> </ul>"},{"location":"tutorials/#framework-features","title":"Framework Features","text":"<ul> <li>Dependency Injection - Service registration and lifetime management</li> <li>Mediator Pattern - Decoupled request handling</li> <li>Repository Pattern - Abstract data access</li> <li>Pipeline Behaviors - Cross-cutting concerns</li> </ul>"},{"location":"tutorials/#infrastructure","title":"Infrastructure","text":"<ul> <li>MongoDB - Document database integration</li> <li>Keycloak - Authentication and authorization</li> <li>OpenTelemetry - Observability and monitoring</li> <li>Docker - Containerization and deployment</li> </ul>"},{"location":"tutorials/#learning-path","title":"\ud83c\udfaf Learning Path","text":""},{"location":"tutorials/#recommended-order","title":"Recommended Order","text":"<ol> <li>Getting Started - Understand the basics (30 min)</li> <li>Tutorial Parts 1-3 - Core architecture and patterns (4 hours)</li> <li>Tutorial Parts 4-6 - API and persistence (4 hours)</li> <li>Tutorial Parts 7-9 - Security and deployment (4 hours)</li> </ol>"},{"location":"tutorials/#alternative-paths","title":"Alternative Paths","text":"<p>Already know Clean Architecture? \u2192 Skip to Part 3: CQRS</p> <p>Just want to see the code? \u2192 Check the complete sample</p> <p>Need specific features? \u2192 Jump to relevant parts (each part is self-contained)</p>"},{"location":"tutorials/#tips-for-success","title":"\ud83d\udca1 Tips for Success","text":"<ol> <li>Code along - Type the examples yourself, don't just read</li> <li>Experiment - Modify the code and see what happens</li> <li>Take breaks - Each part takes ~1-2 hours, pace yourself</li> <li>Use Git - Commit after each part to track progress</li> <li>Ask questions - Open issues if something isn't clear</li> </ol>"},{"location":"tutorials/#ready-to-start","title":"\ud83d\ude80 Ready to Start?","text":"<p>Begin with Part 1: Project Setup to create your Mario's Pizzeria application!</p> <p>Already completed the tutorial? Check out:</p> <ul> <li>Feature Documentation - Deep dive into framework features</li> <li>Architecture Patterns - Design pattern explanations</li> <li>Sample Applications - More examples</li> </ul>"},{"location":"tutorials/mario-pizzeria-01-setup/","title":"Part 1: Project Setup &amp; Structure","text":"<p>Time: 30 minutes | Prerequisites: Python 3.11+, Poetry</p> <p>Welcome to the Mario's Pizzeria tutorial series! In this first part, you'll set up your development environment and understand the project structure that supports clean architecture principles.</p>"},{"location":"tutorials/mario-pizzeria-01-setup/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<p>By the end of this tutorial, you'll understand:</p> <ul> <li>How to structure a Neuroglia application using clean architecture layers</li> <li>The role of the <code>WebApplicationBuilder</code> in bootstrapping applications</li> <li>How dependency injection works in the framework</li> <li>How to configure multiple sub-applications (API + UI)</li> </ul>"},{"location":"tutorials/mario-pizzeria-01-setup/#project-setup","title":"\ud83d\udce6 Project Setup","text":""},{"location":"tutorials/mario-pizzeria-01-setup/#1-install-dependencies","title":"1. Install Dependencies","text":"<p>First, let's install the framework and required packages:</p> <pre><code># Create a new project directory\nmkdir mario-pizzeria\ncd mario-pizzeria\n\n# Initialize poetry project\npoetry init -n\n\n# Add Neuroglia framework\npoetry add neuroglia\n\n# Add additional dependencies\npoetry add fastapi uvicorn motor pymongo\npoetry add python-multipart jinja2  # For UI support\npoetry add starlette  # For session middleware\n\n# Install all dependencies\npoetry install\n</code></pre>"},{"location":"tutorials/mario-pizzeria-01-setup/#2-create-directory-structure","title":"2. Create Directory Structure","text":"<p>Neuroglia enforces clean architecture with strict layer separation. Create this structure:</p> <pre><code>mario-pizzeria/\n\u251c\u2500\u2500 main.py                    # Application entry point\n\u251c\u2500\u2500 api/                       # \ud83c\udf10 API Layer (REST controllers, DTOs)\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 controllers/\n\u2502   \u2502   \u2514\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 dtos/\n\u2502       \u2514\u2500\u2500 __init__.py\n\u251c\u2500\u2500 application/               # \ud83d\udcbc Application Layer (Commands, Queries, Handlers)\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 commands/\n\u2502   \u2502   \u2514\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 queries/\n\u2502   \u2502   \u2514\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 events/\n\u2502   \u2502   \u2514\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 services/\n\u2502       \u2514\u2500\u2500 __init__.py\n\u251c\u2500\u2500 domain/                    # \ud83c\udfdb\ufe0f Domain Layer (Entities, Business Rules)\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 entities/\n\u2502   \u2502   \u2514\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 repositories/\n\u2502       \u2514\u2500\u2500 __init__.py\n\u251c\u2500\u2500 integration/               # \ud83d\udd0c Integration Layer (Database, External APIs)\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 repositories/\n\u2502       \u2514\u2500\u2500 __init__.py\n\u2514\u2500\u2500 ui/                        # Web UI (templates, static files)\n    \u251c\u2500\u2500 controllers/\n    \u2502   \u2514\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 templates/\n</code></pre> <p>Why this structure?</p> <p>The Dependency Rule states that dependencies only point inward:</p> <pre><code>API \u2192 Application \u2192 Domain \u2190 Integration\n</code></pre> <ul> <li>Domain: Pure business logic, no external dependencies</li> <li>Application: Orchestrates domain logic, defines use cases</li> <li>Integration: Implements technical concerns (database, HTTP clients)</li> <li>API: Exposes functionality via REST endpoints</li> </ul> <p>This separation makes code testable, maintainable, and replaceable.</p>"},{"location":"tutorials/mario-pizzeria-01-setup/#creating-the-application-entry-point","title":"\ud83d\ude80 Creating the Application Entry Point","text":"<p>Let's create <code>main.py</code> - the heart of your application:</p> <pre><code>#!/usr/bin/env python3\n\"\"\"\nMario's Pizzeria - A Clean Architecture Sample Application\n\"\"\"\n\nimport logging\nfrom neuroglia.hosting.web import WebApplicationBuilder, SubAppConfig\nfrom neuroglia.mediation import Mediator\nfrom neuroglia.mapping import Mapper\nfrom neuroglia.serialization.json import JsonSerializer\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlog = logging.getLogger(__name__)\n\ndef create_pizzeria_app():\n    \"\"\"\n    Create Mario's Pizzeria application using WebApplicationBuilder.\n\n    This demonstrates the framework's opinionated approach to application\n    bootstrapping with dependency injection and modular configuration.\n    \"\"\"\n\n    # 1\ufe0f\u20e3 Create the application builder\n    builder = WebApplicationBuilder()\n\n    # 2\ufe0f\u20e3 Configure core framework services\n    # Mediator: Handles commands and queries (CQRS pattern)\n    Mediator.configure(\n        builder,\n        [\n            \"application.commands\",   # Command handlers\n            \"application.queries\",    # Query handlers\n            \"application.events\"      # Event handlers\n        ]\n    )\n\n    # Mapper: Object-to-object transformations (entities \u2194 DTOs)\n    Mapper.configure(\n        builder,\n        [\n            \"application.mapping\",\n            \"api.dtos\",\n            \"domain.entities\"\n        ]\n    )\n\n    # JsonSerializer: Type-aware JSON serialization\n    JsonSerializer.configure(\n        builder,\n        [\n            \"domain.entities\"\n        ]\n    )\n\n    # 3\ufe0f\u20e3 Configure sub-applications\n    # API sub-app: REST API with JSON responses\n    builder.add_sub_app(\n        SubAppConfig(\n            path=\"/api\",                    # Mounted at /api prefix\n            name=\"api\",\n            title=\"Mario's Pizzeria API\",\n            description=\"Pizza ordering REST API\",\n            version=\"1.0.0\",\n            controllers=[\"api.controllers\"],  # Auto-discover controllers\n            docs_url=\"/docs\",                # OpenAPI docs at /api/docs\n        )\n    )\n\n    # UI sub-app: Web interface with templates\n    builder.add_sub_app(\n        SubAppConfig(\n            path=\"/\",                       # Mounted at root\n            name=\"ui\",\n            title=\"Mario's Pizzeria UI\",\n            description=\"Pizza ordering web interface\",\n            version=\"1.0.0\",\n            controllers=[\"ui.controllers\"],\n            static_files={\"/static\": \"static\"},  # Serve static assets\n            templates_dir=\"ui/templates\",        # Jinja2 templates\n            docs_url=None,                  # No API docs for UI\n        )\n    )\n\n    # 4\ufe0f\u20e3 Build the complete application\n    app = builder.build_app_with_lifespan(\n        title=\"Mario's Pizzeria\",\n        description=\"Complete pizza ordering system\",\n        version=\"1.0.0\",\n        debug=True\n    )\n\n    log.info(\"\ud83c\udf55 Mario's Pizzeria is ready!\")\n    return app\n\n\ndef main():\n    \"\"\"Entry point for running the application\"\"\"\n    import uvicorn\n\n    print(\"\ud83c\udf55 Starting Mario's Pizzeria on http://localhost:8080\")\n    print(\"\ud83d\udcd6 API Documentation: http://localhost:8080/api/docs\")\n    print(\"\ud83c\udf10 UI: http://localhost:8080/\")\n\n    # Run with hot reload for development\n    uvicorn.run(\n        \"main:app\",\n        host=\"0.0.0.0\",\n        port=8080,\n        reload=True,\n        log_level=\"info\"\n    )\n\n\n# Create app instance for uvicorn\napp = create_pizzeria_app()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tutorials/mario-pizzeria-01-setup/#understanding-the-code","title":"\ud83d\udd0d Understanding the Code","text":""},{"location":"tutorials/mario-pizzeria-01-setup/#webapplicationbuilder","title":"WebApplicationBuilder","text":"<p>The <code>WebApplicationBuilder</code> is the central bootstrapping mechanism in Neuroglia:</p> <pre><code>builder = WebApplicationBuilder()\n</code></pre> <p>It provides:</p> <ul> <li>Service Container: Dependency injection with scoped, singleton, transient lifetimes</li> <li>Configuration: Automatic scanning and registration</li> <li>Sub-App Support: Multiple FastAPI apps mounted to a main host</li> <li>Lifespan Management: Startup/shutdown hooks for resources</li> </ul>"},{"location":"tutorials/mario-pizzeria-01-setup/#mediator-pattern","title":"Mediator Pattern","text":"<p>The <code>Mediator</code> decouples request handling from execution:</p> <pre><code>Mediator.configure(builder, [\"application.commands\", \"application.queries\"])\n</code></pre> <p>Why use mediator?</p> <p>\u274c Without Mediator (tight coupling):</p> <pre><code># Controller directly calls service\nclass PizzaController:\n    def __init__(self, pizza_service: PizzaService):\n        self.service = pizza_service\n\n    def create_pizza(self, data):\n        return self.service.create_pizza(data)  # Direct dependency\n</code></pre> <p>\u2705 With Mediator (loose coupling):</p> <pre><code># Controller sends command to mediator\nclass PizzaController:\n    def __init__(self, mediator: Mediator):\n        self.mediator = mediator\n\n    async def create_pizza(self, data):\n        command = CreatePizzaCommand(name=data.name)\n        return await self.mediator.execute_async(command)  # Mediator routes it\n</code></pre> <p>The mediator automatically finds and executes the right handler. Controllers stay thin and testable.</p>"},{"location":"tutorials/mario-pizzeria-01-setup/#sub-application-architecture","title":"Sub-Application Architecture","text":"<p>Neuroglia supports multiple FastAPI apps mounted to a main host:</p> <pre><code>builder.add_sub_app(SubAppConfig(path=\"/api\", ...))   # API at /api\nbuilder.add_sub_app(SubAppConfig(path=\"/\", ...))      # UI at /\n</code></pre> <p>Benefits:</p> <ul> <li>Separation of Concerns: API logic separate from UI logic</li> <li>Different Authentication: JWT for API, sessions for UI</li> <li>Independent Documentation: OpenAPI docs only for API</li> <li>Static File Handling: Serve assets efficiently for UI</li> </ul> <p>This is Mario's Pizzeria's actual architecture.</p>"},{"location":"tutorials/mario-pizzeria-01-setup/#test-your-setup","title":"\ud83e\uddea Test Your Setup","text":"<p>Run the application:</p> <pre><code>poetry run python main.py\n</code></pre> <p>You should see:</p> <pre><code>\ud83c\udf55 Starting Mario's Pizzeria on http://localhost:8080\n\ud83d\udcd6 API Documentation: http://localhost:8080/api/docs\n\ud83c\udf10 UI: http://localhost:8080/\nINFO:     Started server process\nINFO:     Waiting for application startup.\n\ud83c\udf55 Mario's Pizzeria is ready!\nINFO:     Application startup complete.\n</code></pre> <p>Visit http://localhost:8080/api/docs - you'll see the OpenAPI documentation (empty for now).</p>"},{"location":"tutorials/mario-pizzeria-01-setup/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ol> <li>Clean Architecture Layers: Domain \u2192 Application \u2192 API/Integration</li> <li>WebApplicationBuilder: Central bootstrapping with DI container</li> <li>Mediator Pattern: Decouples controllers from business logic</li> <li>Sub-Applications: Multiple FastAPI apps with different concerns</li> <li>Auto-Discovery: Framework automatically finds and registers controllers/handlers</li> </ol>"},{"location":"tutorials/mario-pizzeria-01-setup/#whats-next","title":"\ud83d\ude80 What's Next?","text":"<p>In Part 2: Domain Model, you'll learn:</p> <ul> <li>How to create domain entities with business rules</li> <li>The difference between <code>Entity</code> and <code>AggregateRoot</code></li> <li>Domain events and why they matter</li> <li>Value objects for type safety</li> </ul>"},{"location":"tutorials/mario-pizzeria-01-setup/#common-issues","title":"\ud83d\udca1 Common Issues","text":"<p>ImportError: No module named 'neuroglia'</p> <pre><code># Make sure you're in the poetry shell\npoetry install\npoetry shell\n</code></pre> <p>Port 8080 already in use</p> <pre><code># Change the port in main()\nuvicorn.run(\"main:app\", port=8081, ...)\n</code></pre> <p>Module not found when running</p> <pre><code># Run from project root directory\ncd mario-pizzeria\npoetry run python main.py\n</code></pre> <p>Next: Part 2: Domain Model \u2192</p>"},{"location":"tutorials/mario-pizzeria-02-domain/","title":"Part 2: Domain Model &amp; Business Rules","text":"<p>Time: 45 minutes | Prerequisites: Part 1</p> <p>In this tutorial, you'll learn how to model your business domain using Domain-Driven Design (DDD) principles. We'll create entities with business rules, understand aggregates, and use domain events.</p>"},{"location":"tutorials/mario-pizzeria-02-domain/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>The difference between <code>Entity</code>, <code>AggregateRoot</code>, and <code>AggregateState</code></li> <li>How to enforce business rules at the domain layer</li> <li>What domain events are and why they matter</li> <li>Value objects for type safety and validation</li> </ul>"},{"location":"tutorials/mario-pizzeria-02-domain/#domain-driven-design-basics","title":"\ud83e\uddf1 Domain-Driven Design Basics","text":""},{"location":"tutorials/mario-pizzeria-02-domain/#the-problem","title":"The Problem","text":"<p>Traditional \"anemic\" domain models have no behavior:</p> <pre><code># \u274c Anemic model - just data, no logic\nclass Order:\n    def __init__(self):\n        self.id = None\n        self.items = []\n        self.status = \"pending\"\n        self.total = 0.0\n</code></pre> <p>All business logic ends up in services, making code hard to test and maintain.</p>"},{"location":"tutorials/mario-pizzeria-02-domain/#the-solution-rich-domain-models","title":"The Solution: Rich Domain Models","text":"<p>Rich domain models contain both data AND behavior:</p> <pre><code># \u2705 Rich model - data + business rules\nclass Order(AggregateRoot):\n    def add_item(self, pizza):\n        if self.status != OrderStatus.PENDING:\n            raise ValueError(\"Cannot modify confirmed orders\")\n        self.items.append(pizza)\n        self.raise_event(PizzaAddedEvent(...))\n</code></pre> <p>Business rules live where they belong: in the domain.</p>"},{"location":"tutorials/mario-pizzeria-02-domain/#creating-domain-entities","title":"\ud83d\udce6 Creating Domain Entities","text":""},{"location":"tutorials/mario-pizzeria-02-domain/#step-1-define-enums-and-value-objects","title":"Step 1: Define Enums and Value Objects","text":"<p>Create <code>domain/entities/enums.py</code>:</p> <pre><code>\"\"\"Domain enumerations\"\"\"\nfrom enum import Enum\n\nclass OrderStatus(str, Enum):\n    \"\"\"Order lifecycle states\"\"\"\n    PENDING = \"pending\"         # Order created, not confirmed\n    CONFIRMED = \"confirmed\"     # Customer confirmed order\n    COOKING = \"cooking\"         # Kitchen is preparing\n    READY = \"ready\"             # Ready for pickup/delivery\n    DELIVERING = \"delivering\"   # Out for delivery\n    DELIVERED = \"delivered\"     # Completed\n    CANCELLED = \"cancelled\"     # Cancelled by customer/staff\n\nclass PizzaSize(str, Enum):\n    \"\"\"Available pizza sizes\"\"\"\n    SMALL = \"small\"      # 10 inch\n    MEDIUM = \"medium\"    # 12 inch\n    LARGE = \"large\"      # 14 inch\n    XLARGE = \"xlarge\"    # 16 inch\n</code></pre> <p>Create <code>domain/entities/order_item.py</code> (value object):</p> <pre><code>\"\"\"OrderItem value object\"\"\"\nfrom dataclasses import dataclass\nfrom decimal import Decimal\nfrom uuid import uuid4\n\nfrom .enums import PizzaSize\n\n@dataclass\nclass OrderItem:\n    \"\"\"\n    Value object representing a pizza in an order.\n\n    Value objects:\n    - Are immutable (no setters)\n    - Are compared by value, not identity\n    - Have no lifecycle (created/destroyed with aggregate)\n    \"\"\"\n    line_item_id: str\n    name: str\n    size: PizzaSize\n    quantity: int\n    unit_price: Decimal\n\n    @property\n    def total_price(self) -&gt; Decimal:\n        \"\"\"Calculate total price for this line item\"\"\"\n        return self.unit_price * self.quantity\n\n    @staticmethod\n    def create(name: str, size: PizzaSize, quantity: int, unit_price: Decimal):\n        \"\"\"Factory method for creating order items\"\"\"\n        return OrderItem(\n            line_item_id=str(uuid4()),\n            name=name,\n            size=size,\n            quantity=quantity,\n            unit_price=unit_price\n        )\n</code></pre> <p>Why value objects?</p> <ul> <li>Type Safety: Can't pass a string where an <code>OrderItem</code> is expected</li> <li>Validation: Business rules enforced at creation</li> <li>Immutability: No accidental modifications</li> <li>Reusability: Shared across aggregates</li> </ul>"},{"location":"tutorials/mario-pizzeria-02-domain/#step-2-define-domain-events","title":"Step 2: Define Domain Events","text":"<p>Create <code>domain/events/__init__.py</code>:</p> <pre><code>\"\"\"Domain events for Mario's Pizzeria\"\"\"\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom decimal import Decimal\n\nfrom neuroglia.eventing.domain_event import DomainEvent\n\n@dataclass\nclass OrderCreatedEvent(DomainEvent):\n    \"\"\"Raised when a new order is created\"\"\"\n    aggregate_id: str\n    customer_id: str\n    order_time: datetime\n\n@dataclass\nclass PizzaAddedToOrderEvent(DomainEvent):\n    \"\"\"Raised when a pizza is added to an order\"\"\"\n    aggregate_id: str\n    line_item_id: str\n    pizza_name: str\n    pizza_size: str\n    price: Decimal\n\n@dataclass\nclass OrderConfirmedEvent(DomainEvent):\n    \"\"\"Raised when customer confirms the order\"\"\"\n    aggregate_id: str\n    confirmed_time: datetime\n\n@dataclass\nclass CookingStartedEvent(DomainEvent):\n    \"\"\"Raised when kitchen starts cooking\"\"\"\n    aggregate_id: str\n    cooking_started_time: datetime\n    user_id: str\n    user_name: str\n\n@dataclass\nclass OrderReadyEvent(DomainEvent):\n    \"\"\"Raised when order is ready for pickup/delivery\"\"\"\n    aggregate_id: str\n    ready_time: datetime\n    user_id: str\n    user_name: str\n\n@dataclass\nclass OrderCancelledEvent(DomainEvent):\n    \"\"\"Raised when order is cancelled\"\"\"\n    aggregate_id: str\n    reason: str\n</code></pre> <p>What are domain events?</p> <p>Domain events represent things that happened in your business domain. They:</p> <ul> <li>Enable event-driven architecture (other parts of the system can react)</li> <li>Provide audit trails (who did what, when)</li> <li>Enable eventual consistency (updates can be async)</li> <li>Decouple aggregates (Order doesn't need to know about Kitchen)</li> </ul>"},{"location":"tutorials/mario-pizzeria-02-domain/#step-3-create-aggregate-state","title":"Step 3: Create Aggregate State","text":"<p>Create <code>domain/entities/order.py</code>:</p> <pre><code>\"\"\"Order entity for Mario's Pizzeria domain\"\"\"\nfrom datetime import datetime, timezone\nfrom decimal import Decimal\nfrom typing import Optional\nfrom uuid import uuid4\n\nfrom multipledispatch import dispatch\n\nfrom neuroglia.data.abstractions import AggregateRoot, AggregateState\n\nfrom .enums import OrderStatus\nfrom .order_item import OrderItem\nfrom domain.events import (\n    OrderCreatedEvent,\n    PizzaAddedToOrderEvent,\n    PizzaRemovedFromOrderEvent,\n    OrderConfirmedEvent,\n    CookingStartedEvent,\n    OrderReadyEvent,\n    OrderCancelledEvent,\n)\n\nclass OrderState(AggregateState[str]):\n    \"\"\"\n    State for Order aggregate - contains all persisted data.\n\n    AggregateState:\n    - Holds the current state of the aggregate\n    - Updates via event handlers (on() methods)\n    - Separated from business logic (in AggregateRoot)\n    \"\"\"\n\n    # Type annotations for JSON serialization\n    customer_id: Optional[str]\n    order_items: list[OrderItem]\n    status: OrderStatus\n    order_time: Optional[datetime]\n    confirmed_time: Optional[datetime]\n    cooking_started_time: Optional[datetime]\n    actual_ready_time: Optional[datetime]\n    estimated_ready_time: Optional[datetime]\n    notes: Optional[str]\n\n    def __init__(self):\n        super().__init__()\n        self.customer_id = None\n        self.order_items = []\n        self.status = OrderStatus.PENDING\n        self.order_time = None\n        self.confirmed_time = None\n        self.cooking_started_time = None\n        self.actual_ready_time = None\n        self.estimated_ready_time = None\n        self.notes = None\n\n    @dispatch(OrderCreatedEvent)\n    def on(self, event: OrderCreatedEvent) -&gt; None:\n        \"\"\"Handle order creation event\"\"\"\n        self.id = event.aggregate_id\n        self.customer_id = event.customer_id\n        self.order_time = event.order_time\n        self.status = OrderStatus.PENDING\n\n    @dispatch(PizzaAddedToOrderEvent)\n    def on(self, event: PizzaAddedToOrderEvent) -&gt; None:\n        \"\"\"Handle pizza added - state updated by business logic\"\"\"\n        pass  # Items added directly in aggregate\n\n    @dispatch(OrderConfirmedEvent)\n    def on(self, event: OrderConfirmedEvent) -&gt; None:\n        \"\"\"Handle order confirmation\"\"\"\n        self.status = OrderStatus.CONFIRMED\n        self.confirmed_time = event.confirmed_time\n\n    @dispatch(CookingStartedEvent)\n    def on(self, event: CookingStartedEvent) -&gt; None:\n        \"\"\"Handle cooking started\"\"\"\n        self.status = OrderStatus.COOKING\n        self.cooking_started_time = event.cooking_started_time\n\n    @dispatch(OrderReadyEvent)\n    def on(self, event: OrderReadyEvent) -&gt; None:\n        \"\"\"Handle order ready\"\"\"\n        self.status = OrderStatus.READY\n        self.actual_ready_time = event.ready_time\n\n    @dispatch(OrderCancelledEvent)\n    def on(self, event: OrderCancelledEvent) -&gt; None:\n        \"\"\"Handle order cancellation\"\"\"\n        self.status = OrderStatus.CANCELLED\n        if event.reason:\n            self.notes = f\"Cancelled: {event.reason}\"\n</code></pre> <p>Why separate state from aggregate?</p> <ul> <li>Event Sourcing Ready: State rebuilds from events</li> <li>Testability: Can test state changes independently</li> <li>Persistence: State is what gets saved to database</li> <li>Clarity: Clear separation between data and behavior</li> </ul>"},{"location":"tutorials/mario-pizzeria-02-domain/#step-4-create-aggregate-root","title":"Step 4: Create Aggregate Root","text":"<p>Continue in <code>domain/entities/order.py</code>:</p> <pre><code>class Order(AggregateRoot[OrderState, str]):\n    \"\"\"\n    Order aggregate root with business rules and lifecycle management.\n\n    AggregateRoot:\n    - Enforces business rules\n    - Raises domain events\n    - Controls state transitions\n    - Transaction boundary (save/load as a unit)\n    \"\"\"\n\n    def __init__(self, customer_id: str, estimated_ready_time: Optional[datetime] = None):\n        super().__init__()\n\n        # Raise and apply creation event\n        self.state.on(\n            self.register_event(\n                OrderCreatedEvent(\n                    aggregate_id=str(uuid4()),\n                    customer_id=customer_id,\n                    order_time=datetime.now(timezone.utc)\n                )\n            )\n        )\n\n        if estimated_ready_time:\n            self.state.estimated_ready_time = estimated_ready_time\n\n    # Properties for calculated values\n    @property\n    def total_amount(self) -&gt; Decimal:\n        \"\"\"Calculate total order amount\"\"\"\n        return sum(\n            (item.total_price for item in self.state.order_items),\n            Decimal(\"0.00\")\n        )\n\n    @property\n    def pizza_count(self) -&gt; int:\n        \"\"\"Get total number of pizzas\"\"\"\n        return len(self.state.order_items)\n\n    # Business operations\n    def add_order_item(self, order_item: OrderItem) -&gt; None:\n        \"\"\"\n        Add a pizza to the order.\n\n        Business Rule: Can only modify pending orders\n        \"\"\"\n        if self.state.status != OrderStatus.PENDING:\n            raise ValueError(\"Cannot modify confirmed orders\")\n\n        # Update state\n        self.state.order_items.append(order_item)\n\n        # Raise event\n        self.state.on(\n            self.register_event(\n                PizzaAddedToOrderEvent(\n                    aggregate_id=self.id(),\n                    line_item_id=order_item.line_item_id,\n                    pizza_name=order_item.name,\n                    pizza_size=order_item.size.value,\n                    price=order_item.total_price\n                )\n            )\n        )\n\n    def remove_pizza(self, line_item_id: str) -&gt; None:\n        \"\"\"\n        Remove a pizza from the order.\n\n        Business Rule: Can only modify pending orders\n        \"\"\"\n        if self.state.status != OrderStatus.PENDING:\n            raise ValueError(\"Cannot modify confirmed orders\")\n\n        # Remove from state\n        self.state.order_items = [\n            item for item in self.state.order_items\n            if item.line_item_id != line_item_id\n        ]\n\n        # Raise event\n        self.state.on(\n            self.register_event(\n                PizzaRemovedFromOrderEvent(\n                    aggregate_id=self.id(),\n                    line_item_id=line_item_id\n                )\n            )\n        )\n\n    def confirm_order(self) -&gt; None:\n        \"\"\"\n        Confirm the order.\n\n        Business Rules:\n        - Only pending orders can be confirmed\n        - Must have at least one item\n        \"\"\"\n        if self.state.status != OrderStatus.PENDING:\n            raise ValueError(\"Only pending orders can be confirmed\")\n\n        if len(self.state.order_items) == 0:\n            raise ValueError(\"Cannot confirm empty order\")\n\n        # Update state and raise event\n        self.state.on(\n            self.register_event(\n                OrderConfirmedEvent(\n                    aggregate_id=self.id(),\n                    confirmed_time=datetime.now(timezone.utc)\n                )\n            )\n        )\n\n    def start_cooking(self, user_id: str, user_name: str) -&gt; None:\n        \"\"\"\n        Start cooking the order.\n\n        Business Rule: Only confirmed orders can be cooked\n        \"\"\"\n        if self.state.status != OrderStatus.CONFIRMED:\n            raise ValueError(\"Only confirmed orders can be cooked\")\n\n        self.state.on(\n            self.register_event(\n                CookingStartedEvent(\n                    aggregate_id=self.id(),\n                    cooking_started_time=datetime.now(timezone.utc),\n                    user_id=user_id,\n                    user_name=user_name\n                )\n            )\n        )\n\n    def mark_ready(self, user_id: str, user_name: str) -&gt; None:\n        \"\"\"\n        Mark order as ready.\n\n        Business Rule: Only cooking orders can be marked ready\n        \"\"\"\n        if self.state.status != OrderStatus.COOKING:\n            raise ValueError(\"Only cooking orders can be marked ready\")\n\n        self.state.on(\n            self.register_event(\n                OrderReadyEvent(\n                    aggregate_id=self.id(),\n                    ready_time=datetime.now(timezone.utc),\n                    user_id=user_id,\n                    user_name=user_name\n                )\n            )\n        )\n\n    def cancel_order(self, reason: str) -&gt; None:\n        \"\"\"\n        Cancel the order.\n\n        Business Rule: Cannot cancel delivered orders\n        \"\"\"\n        if self.state.status == OrderStatus.DELIVERED:\n            raise ValueError(\"Cannot cancel delivered orders\")\n\n        self.state.on(\n            self.register_event(\n                OrderCancelledEvent(\n                    aggregate_id=self.id(),\n                    reason=reason\n                )\n            )\n        )\n</code></pre>"},{"location":"tutorials/mario-pizzeria-02-domain/#testing-your-domain-model","title":"\ud83e\uddea Testing Your Domain Model","text":"<p>Create <code>tests/domain/test_order.py</code>:</p> <pre><code>\"\"\"Tests for Order domain entity\"\"\"\nimport pytest\nfrom datetime import datetime, timezone\nfrom decimal import Decimal\n\nfrom domain.entities import Order, OrderItem, PizzaSize, OrderStatus\nfrom domain.events import OrderCreatedEvent, PizzaAddedToOrderEvent, OrderConfirmedEvent\n\ndef test_create_order():\n    \"\"\"Test order creation\"\"\"\n    order = Order(customer_id=\"cust-123\")\n\n    assert order.state.customer_id == \"cust-123\"\n    assert order.state.status == OrderStatus.PENDING\n    assert order.pizza_count == 0\n\n    # Check event was raised\n    events = order.get_uncommitted_events()\n    assert len(events) == 1\n    assert isinstance(events[0], OrderCreatedEvent)\n\ndef test_add_pizza_to_order():\n    \"\"\"Test adding pizza to order\"\"\"\n    order = Order(customer_id=\"cust-123\")\n\n    item = OrderItem.create(\n        name=\"Margherita\",\n        size=PizzaSize.LARGE,\n        quantity=1,\n        unit_price=Decimal(\"12.99\")\n    )\n\n    order.add_order_item(item)\n\n    assert order.pizza_count == 1\n    assert order.total_amount == Decimal(\"12.99\")\n\n    # Check event\n    events = order.get_uncommitted_events()\n    assert any(isinstance(e, PizzaAddedToOrderEvent) for e in events)\n\ndef test_cannot_modify_confirmed_order():\n    \"\"\"Test business rule: cannot modify confirmed orders\"\"\"\n    order = Order(customer_id=\"cust-123\")\n\n    item = OrderItem.create(\n        name=\"Pepperoni\",\n        size=PizzaSize.MEDIUM,\n        quantity=1,\n        unit_price=Decimal(\"10.99\")\n    )\n\n    order.add_order_item(item)\n    order.confirm_order()\n\n    # Should raise error\n    with pytest.raises(ValueError, match=\"Cannot modify confirmed orders\"):\n        order.add_order_item(item)\n\ndef test_cannot_confirm_empty_order():\n    \"\"\"Test business rule: cannot confirm empty order\"\"\"\n    order = Order(customer_id=\"cust-123\")\n\n    with pytest.raises(ValueError, match=\"Cannot confirm empty order\"):\n        order.confirm_order()\n\ndef test_order_lifecycle():\n    \"\"\"Test complete order lifecycle\"\"\"\n    order = Order(customer_id=\"cust-123\")\n\n    # Add pizza\n    item = OrderItem.create(\"Margherita\", PizzaSize.LARGE, 1, Decimal(\"12.99\"))\n    order.add_order_item(item)\n\n    # Confirm\n    order.confirm_order()\n    assert order.state.status == OrderStatus.CONFIRMED\n\n    # Start cooking\n    order.start_cooking(user_id=\"chef-1\", user_name=\"Mario\")\n    assert order.state.status == OrderStatus.COOKING\n\n    # Mark ready\n    order.mark_ready(user_id=\"chef-1\", user_name=\"Mario\")\n    assert order.state.status == OrderStatus.READY\n</code></pre> <p>Run tests:</p> <pre><code>poetry run pytest tests/domain/ -v\n</code></pre>"},{"location":"tutorials/mario-pizzeria-02-domain/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ol> <li>Rich Domain Models: Business logic lives in the domain, not services</li> <li>Aggregate Pattern: <code>AggregateRoot</code> + <code>AggregateState</code> for encapsulation</li> <li>Domain Events: Track what happened, enable event-driven architecture</li> <li>Value Objects: Immutable, validated, compared by value</li> <li>Business Rules: Enforced in domain methods with clear error messages</li> </ol>"},{"location":"tutorials/mario-pizzeria-02-domain/#whats-next","title":"\ud83d\ude80 What's Next?","text":"<p>In Part 3: Commands &amp; Queries, you'll learn:</p> <ul> <li>How to implement CQRS (Command Query Responsibility Segregation)</li> <li>Creating commands and queries</li> <li>Writing command/query handlers</li> <li>Using the mediator to route requests</li> </ul> <p>Previous: \u2190 Part 1: Project Setup | Next: Part 3: Commands &amp; Queries \u2192</p>"},{"location":"tutorials/mario-pizzeria-03-cqrs/","title":"Part 3: Commands &amp; Queries (CQRS)","text":"<p>Time: 1 hour | Prerequisites: Part 2</p> <p>In this tutorial, you'll implement CQRS (Command Query Responsibility Segregation), the architectural pattern that separates read and write operations for better scalability and maintainability.</p>"},{"location":"tutorials/mario-pizzeria-03-cqrs/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>What CQRS is and why it matters</li> <li>The difference between commands and queries</li> <li>How to create command/query handlers</li> <li>Using the mediator pattern to route requests</li> <li>Testing CQRS components</li> </ul>"},{"location":"tutorials/mario-pizzeria-03-cqrs/#understanding-cqrs","title":"\ud83e\udd14 Understanding CQRS","text":""},{"location":"tutorials/mario-pizzeria-03-cqrs/#the-problem","title":"The Problem","text":"<p>Traditional applications mix reads and writes in the same models:</p> <pre><code># \u274c Mixed concerns - same service handles reads and writes\nclass OrderService:\n    def create_order(self, data):  # Write\n        order = Order(**data)\n        self.db.save(order)\n        return order\n\n    def get_order(self, order_id):  # Read\n        return self.db.get(order_id)\n\n    def list_orders(self, filters):  # Read\n        return self.db.query(filters)\n</code></pre> <p>Problems:</p> <ul> <li>Read and write models often have different requirements</li> <li>Difficult to optimize separately</li> <li>Security: reads and writes mixed together</li> <li>Scaling: can't scale reads independently</li> </ul>"},{"location":"tutorials/mario-pizzeria-03-cqrs/#the-solution-cqrs","title":"The Solution: CQRS","text":"<p>CQRS separates commands (writes) from queries (reads):</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Commands   \u2502       \u2502   Queries    \u2502\n\u2502  (Writes)   \u2502       \u2502   (Reads)    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                     \u2502\n       \u25bc                     \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Command    \u2502       \u2502    Query     \u2502\n\u2502  Handlers   \u2502       \u2502   Handlers   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                     \u2502\n       \u25bc                     \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502       Domain / Repository       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Benefits:</p> <ul> <li>Separation: Different models for reads vs writes</li> <li>Optimization: Query handlers can use denormalized views</li> <li>Security: Easy to apply different permissions</li> <li>Scalability: Scale read and write sides independently</li> <li>Clarity: Clear intent (is this changing state or just reading?)</li> </ul>"},{"location":"tutorials/mario-pizzeria-03-cqrs/#creating-commands","title":"\ud83d\udcdd Creating Commands","text":"<p>Commands represent intentions to change state.</p>"},{"location":"tutorials/mario-pizzeria-03-cqrs/#step-1-define-the-command","title":"Step 1: Define the Command","text":"<p>Create <code>application/commands/place_order_command.py</code>:</p> <pre><code>\"\"\"Place Order Command\"\"\"\nfrom dataclasses import dataclass, field\nfrom typing import Optional\n\nfrom api.dtos import CreatePizzaDto, OrderDto\nfrom neuroglia.core import OperationResult\nfrom neuroglia.mediation import Command\n\n\n@dataclass\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"\n    Command to place a new pizza order.\n\n    Commands:\n    - Represent an intention to do something\n    - Have imperative names (Place, Create, Update, Delete)\n    - Return a result (success/failure)\n    - Are validated before execution\n    \"\"\"\n    customer_name: str\n    customer_phone: str\n    customer_address: Optional[str] = None\n    customer_email: Optional[str] = None\n    pizzas: list[CreatePizzaDto] = field(default_factory=list)\n    payment_method: str = \"cash\"\n    notes: Optional[str] = None\n</code></pre> <p>Command characteristics:</p> <ul> <li>Intention: \"Place an order\" (verb + noun)</li> <li>Generic return type: <code>Command[OperationResult[OrderDto]]</code> tells mediator what to expect</li> <li>Immutable: Uses <code>@dataclass</code> with no setters</li> <li>Validated: Framework can automatically validate before handler executes</li> </ul>"},{"location":"tutorials/mario-pizzeria-03-cqrs/#step-2-create-the-command-handler","title":"Step 2: Create the Command Handler","text":"<p>Continue in <code>application/commands/place_order_command.py</code>:</p> <pre><code>from domain.entities import Customer, Order, OrderItem, PizzaSize\nfrom domain.repositories import IOrderRepository, ICustomerRepository\nfrom neuroglia.mapping import Mapper\nfrom neuroglia.mediation import CommandHandler\nfrom neuroglia.data.unit_of_work import IUnitOfWork\nfrom uuid import uuid4\nfrom decimal import Decimal\n\n\nclass PlaceOrderCommandHandler(\n    CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]\n):\n    \"\"\"\n    Handler for placing pizza orders.\n\n    Handler responsibilities:\n    - Validate the command\n    - Coordinate domain operations\n    - Persist changes via repositories\n    - Return result\n    \"\"\"\n\n    def __init__(\n        self,\n        order_repository: IOrderRepository,\n        customer_repository: ICustomerRepository,\n        mapper: Mapper,\n        unit_of_work: IUnitOfWork,\n    ):\n        \"\"\"\n        Dependencies injected by framework's DI container.\n\n        Notice: Handler doesn't create its own dependencies!\n        \"\"\"\n        self.order_repository = order_repository\n        self.customer_repository = customer_repository\n        self.mapper = mapper\n        self.unit_of_work = unit_of_work\n\n    async def handle_async(\n        self,\n        request: PlaceOrderCommand\n    ) -&gt; OperationResult[OrderDto]:\n        \"\"\"\n        Execute the command.\n\n        Pattern: Try to execute, return OperationResult with success/failure\n        \"\"\"\n        try:\n            # 1\ufe0f\u20e3 Get or create customer\n            customer = await self._get_or_create_customer(request)\n\n            # 2\ufe0f\u20e3 Create order (domain logic)\n            order = Order(customer_id=customer.id())\n            if request.notes:\n                order.state.notes = request.notes\n\n            # 3\ufe0f\u20e3 Add pizzas to order\n            for pizza_dto in request.pizzas:\n                size = PizzaSize(pizza_dto.size.lower())\n\n                # Business logic: Calculate price\n                base_price = self._calculate_pizza_price(pizza_dto.name)\n\n                # Create order item (value object)\n                order_item = OrderItem(\n                    line_item_id=str(uuid4()),\n                    name=pizza_dto.name,\n                    size=size,\n                    quantity=1,\n                    unit_price=base_price\n                )\n\n                # Add to order (business rules enforced here)\n                order.add_order_item(order_item)\n\n            # 4\ufe0f\u20e3 Validate order has items\n            if order.pizza_count == 0:\n                return self.bad_request(\"Order must contain at least one pizza\")\n\n            # 5\ufe0f\u20e3 Confirm order (triggers domain event)\n            order.confirm_order()\n\n            # 6\ufe0f\u20e3 Persist changes\n            await self.unit_of_work.register(order)\n            await self.unit_of_work.save_changes_async()\n\n            # 7\ufe0f\u20e3 Map to DTO and return success\n            order_dto = self.mapper.map(order, OrderDto)\n            return self.created(order_dto)\n\n        except ValueError as e:\n            # Business rule violation\n            return self.bad_request(str(e))\n        except Exception as e:\n            # Unexpected error\n            return self.internal_server_error(f\"Failed to place order: {str(e)}\")\n\n    async def _get_or_create_customer(\n        self,\n        request: PlaceOrderCommand\n    ) -&gt; Customer:\n        \"\"\"Helper to find existing customer or create new one\"\"\"\n        customers = await self.customer_repository.list_async()\n\n        # Try to find by phone\n        for customer in customers:\n            if customer.state.phone == request.customer_phone:\n                return customer\n\n        # Create new customer\n        customer = Customer(\n            name=request.customer_name,\n            phone=request.customer_phone,\n            email=request.customer_email,\n            address=request.customer_address\n        )\n\n        await self.customer_repository.add_async(customer)\n        return customer\n\n    def _calculate_pizza_price(self, pizza_name: str) -&gt; Decimal:\n        \"\"\"Business logic: Calculate pizza base price\"\"\"\n        prices = {\n            \"margherita\": Decimal(\"12.99\"),\n            \"pepperoni\": Decimal(\"14.99\"),\n            \"supreme\": Decimal(\"17.99\"),\n        }\n        return prices.get(pizza_name.lower(), Decimal(\"12.99\"))\n</code></pre> <p>Key points:</p> <ul> <li>Handler does orchestration, not business logic (that's in domain)</li> <li>Uses dependency injection for repositories</li> <li>Returns OperationResult for consistent error handling</li> <li>Validates before persisting</li> <li>Uses UnitOfWork for transactional boundaries</li> </ul>"},{"location":"tutorials/mario-pizzeria-03-cqrs/#creating-queries","title":"\ud83d\udd0d Creating Queries","text":"<p>Queries represent requests for information without side effects.</p>"},{"location":"tutorials/mario-pizzeria-03-cqrs/#step-1-define-the-query","title":"Step 1: Define the Query","text":"<p>Create <code>application/queries/get_order_by_id_query.py</code>:</p> <pre><code>\"\"\"Get Order By ID Query\"\"\"\nfrom dataclasses import dataclass\n\nfrom api.dtos import OrderDto\nfrom neuroglia.core import OperationResult\nfrom neuroglia.mediation import Query\n\n\n@dataclass\nclass GetOrderByIdQuery(Query[OperationResult[OrderDto]]):\n    \"\"\"\n    Query to retrieve an order by ID.\n\n    Queries:\n    - Request information without side effects\n    - Have question-like names (Get, Find, List, Search)\n    - Return data (DTOs, view models)\n    - Can be cached\n    \"\"\"\n    order_id: str\n</code></pre>"},{"location":"tutorials/mario-pizzeria-03-cqrs/#step-2-create-the-query-handler","title":"Step 2: Create the Query Handler","text":"<p>Continue in <code>application/queries/get_order_by_id_query.py</code>:</p> <pre><code>from domain.repositories import IOrderRepository, ICustomerRepository\nfrom neuroglia.mapping import Mapper\nfrom neuroglia.mediation import QueryHandler\n\n\nclass GetOrderByIdQueryHandler(\n    QueryHandler[GetOrderByIdQuery, OperationResult[OrderDto]]\n):\n    \"\"\"\n    Handler for retrieving orders by ID.\n\n    Query handlers:\n    - Read-only operations\n    - Can use optimized read models\n    - Should be fast (consider caching)\n    - No business rule changes\n    \"\"\"\n\n    def __init__(\n        self,\n        order_repository: IOrderRepository,\n        customer_repository: ICustomerRepository,\n        mapper: Mapper,\n    ):\n        self.order_repository = order_repository\n        self.customer_repository = customer_repository\n        self.mapper = mapper\n\n    async def handle_async(\n        self,\n        request: GetOrderByIdQuery\n    ) -&gt; OperationResult[OrderDto]:\n        \"\"\"Execute the query\"\"\"\n        try:\n            # 1\ufe0f\u20e3 Get order from repository\n            order = await self.order_repository.get_async(request.order_id)\n\n            if not order:\n                return self.not_found(\"Order\", request.order_id)\n\n            # 2\ufe0f\u20e3 Get related data (customer)\n            customer = None\n            if order.state.customer_id:\n                customer = await self.customer_repository.get_async(\n                    order.state.customer_id\n                )\n\n            # 3\ufe0f\u20e3 Map to DTO (with customer details)\n            order_dto = self.mapper.map(order, OrderDto)\n\n            if customer:\n                order_dto.customer_name = customer.state.name\n                order_dto.customer_phone = customer.state.phone\n\n            # 4\ufe0f\u20e3 Return success\n            return self.ok(order_dto)\n\n        except Exception as e:\n            return self.bad_request(f\"Failed to get order: {str(e)}\")\n</code></pre> <p>Query handler characteristics:</p> <ul> <li>Read-only: No state changes</li> <li>Fast: Optimized for retrieval</li> <li>Idempotent: Same input = same output</li> <li>Can use different storage: Could query a read-optimized database</li> </ul>"},{"location":"tutorials/mario-pizzeria-03-cqrs/#using-the-mediator","title":"\ud83d\udea6 Using the Mediator","text":"<p>The mediator routes commands/queries to their handlers without controllers needing to know about handlers directly.</p>"},{"location":"tutorials/mario-pizzeria-03-cqrs/#how-it-works","title":"How it Works","text":"<pre><code># In controller\nasync def create_order(self, data: CreateOrderDto):\n    # Create command\n    command = self.mapper.map(data, PlaceOrderCommand)\n\n    # Send to mediator (framework finds the handler)\n    result = await self.mediator.execute_async(command)\n\n    # Process result\n    return self.process(result)\n</code></pre> <p>The magic:</p> <ol> <li>Mediator inspects command type: <code>PlaceOrderCommand</code></li> <li>Looks up registered handler: <code>PlaceOrderCommandHandler</code></li> <li>Resolves handler dependencies from DI container</li> <li>Executes <code>handler.handle_async(command)</code></li> <li>Returns result to caller</li> </ol> <p>Benefits:</p> <ul> <li>Controllers don't depend on concrete handlers</li> <li>Easy to add middleware (logging, validation, transactions)</li> <li>Handlers can be tested independently</li> <li>Clear request \u2192 response flow</li> </ul>"},{"location":"tutorials/mario-pizzeria-03-cqrs/#testing-cqrs-components","title":"\ud83e\uddea Testing CQRS Components","text":""},{"location":"tutorials/mario-pizzeria-03-cqrs/#testing-a-command-handler","title":"Testing a Command Handler","text":"<p>Create <code>tests/application/commands/test_place_order_handler.py</code>:</p> <pre><code>\"\"\"Tests for PlaceOrderCommandHandler\"\"\"\nimport pytest\nfrom decimal import Decimal\nfrom unittest.mock import AsyncMock, Mock\n\nfrom application.commands.place_order_command import (\n    PlaceOrderCommand,\n    PlaceOrderCommandHandler\n)\nfrom api.dtos import CreatePizzaDto\nfrom domain.entities import Customer, Order\n\n\n@pytest.fixture\ndef mock_repositories():\n    \"\"\"Create mock repositories\"\"\"\n    order_repo = AsyncMock()\n    customer_repo = AsyncMock()\n    return order_repo, customer_repo\n\n\n@pytest.fixture\ndef handler(mock_repositories):\n    \"\"\"Create handler with mocked dependencies\"\"\"\n    order_repo, customer_repo = mock_repositories\n    mapper = Mock()\n    unit_of_work = AsyncMock()\n\n    return PlaceOrderCommandHandler(\n        order_repository=order_repo,\n        customer_repository=customer_repo,\n        mapper=mapper,\n        unit_of_work=unit_of_work\n    )\n\n\n@pytest.mark.asyncio\nasync def test_place_order_success(handler, mock_repositories):\n    \"\"\"Test successful order placement\"\"\"\n    order_repo, customer_repo = mock_repositories\n\n    # Setup: Mock customer exists\n    mock_customer = Mock(spec=Customer)\n    mock_customer.id.return_value = \"cust-123\"\n    customer_repo.list_async.return_value = [mock_customer]\n\n    # Execute command\n    command = PlaceOrderCommand(\n        customer_name=\"John Doe\",\n        customer_phone=\"555-1234\",\n        pizzas=[\n            CreatePizzaDto(name=\"Margherita\", size=\"large\"),\n        ]\n    )\n\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n    assert result.status_code == 201  # Created\n    handler.unit_of_work.save_changes_async.assert_called_once()\n\n\n@pytest.mark.asyncio\nasync def test_place_order_empty_pizzas(handler, mock_repositories):\n    \"\"\"Test business rule: order must have pizzas\"\"\"\n    order_repo, customer_repo = mock_repositories\n\n    # Setup\n    mock_customer = Mock(spec=Customer)\n    mock_customer.id.return_value = \"cust-123\"\n    customer_repo.list_async.return_value = [mock_customer]\n\n    # Execute with no pizzas\n    command = PlaceOrderCommand(\n        customer_name=\"John Doe\",\n        customer_phone=\"555-1234\",\n        pizzas=[]  # Empty!\n    )\n\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert not result.is_success\n    assert result.status_code == 400\n    assert \"at least one pizza\" in result.error_message.lower()\n</code></pre>"},{"location":"tutorials/mario-pizzeria-03-cqrs/#testing-a-query-handler","title":"Testing a Query Handler","text":"<p>Create <code>tests/application/queries/test_get_order_handler.py</code>:</p> <pre><code>\"\"\"Tests for GetOrderByIdQueryHandler\"\"\"\nimport pytest\nfrom unittest.mock import AsyncMock, Mock\n\nfrom application.queries.get_order_by_id_query import (\n    GetOrderByIdQuery,\n    GetOrderByIdQueryHandler\n)\nfrom domain.entities import Order, OrderStatus\n\n\n@pytest.mark.asyncio\nasync def test_get_order_success():\n    \"\"\"Test successful order retrieval\"\"\"\n    # Setup mocks\n    order_repo = AsyncMock()\n    customer_repo = AsyncMock()\n    mapper = Mock()\n\n    mock_order = Mock(spec=Order)\n    mock_order.state.customer_id = \"cust-123\"\n    mock_order.state.status = OrderStatus.CONFIRMED\n\n    order_repo.get_async.return_value = mock_order\n    customer_repo.get_async.return_value = None\n\n    # Create handler\n    handler = GetOrderByIdQueryHandler(\n        order_repository=order_repo,\n        customer_repository=customer_repo,\n        mapper=mapper\n    )\n\n    # Execute query\n    query = GetOrderByIdQuery(order_id=\"order-123\")\n    result = await handler.handle_async(query)\n\n    # Assert\n    assert result.is_success\n    order_repo.get_async.assert_called_once_with(\"order-123\")\n\n\n@pytest.mark.asyncio\nasync def test_get_order_not_found():\n    \"\"\"Test order not found scenario\"\"\"\n    order_repo = AsyncMock()\n    customer_repo = AsyncMock()\n    mapper = Mock()\n\n    order_repo.get_async.return_value = None  # Not found\n\n    handler = GetOrderByIdQueryHandler(\n        order_repository=order_repo,\n        customer_repository=customer_repo,\n        mapper=mapper\n    )\n\n    query = GetOrderByIdQuery(order_id=\"nonexistent\")\n    result = await handler.handle_async(query)\n\n    assert not result.is_success\n    assert result.status_code == 404\n</code></pre> <p>Run tests:</p> <pre><code>poetry run pytest tests/application/ -v\n</code></pre>"},{"location":"tutorials/mario-pizzeria-03-cqrs/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ol> <li>CQRS Separation: Commands change state, queries read state</li> <li>Mediator Pattern: Decouples controllers from handlers</li> <li>Dependency Injection: Handlers receive dependencies, don't create them</li> <li>OperationResult: Consistent error handling across handlers</li> <li>Testability: Easy to mock dependencies and test handlers in isolation</li> </ol>"},{"location":"tutorials/mario-pizzeria-03-cqrs/#whats-next","title":"\ud83d\ude80 What's Next?","text":"<p>In Part 4: API Controllers, you'll learn:</p> <ul> <li>How to create REST controllers using FastAPI</li> <li>Connecting controllers to mediator</li> <li>DTOs for API contracts</li> <li>OpenAPI documentation generation</li> </ul> <p>Previous: \u2190 Part 2: Domain Model | Next: Part 4: API Controllers \u2192</p>"},{"location":"tutorials/mario-pizzeria-04-api/","title":"Part 4: REST API Controllers","text":"<p>Time: 45 minutes | Prerequisites: Part 3</p> <p>In this tutorial, you'll create REST API controllers that expose your application's functionality over HTTP. You'll learn how Neuroglia integrates with FastAPI to provide clean, testable controllers.</p>"},{"location":"tutorials/mario-pizzeria-04-api/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>How to create REST controllers using <code>ControllerBase</code></li> <li>Using FastAPI decorators for routing</li> <li>Creating DTOs (Data Transfer Objects) for API contracts</li> <li>Auto-generated OpenAPI documentation</li> <li>Error handling and response formatting</li> </ul>"},{"location":"tutorials/mario-pizzeria-04-api/#understanding-controllers","title":"\ud83c\udf10 Understanding Controllers","text":""},{"location":"tutorials/mario-pizzeria-04-api/#the-problem","title":"The Problem","text":"<p>Traditional FastAPI apps mix routing, validation, and business logic:</p> <pre><code># \u274c Mixed concerns - everything in one place\n@app.post(\"/orders\")\nasync def create_order(data: dict):\n    # Validation\n    if not data.get(\"customer_name\"):\n        raise HTTPException(400, \"Name required\")\n\n    # Business logic\n    order = Order(**data)\n\n    # Persistence\n    db.save(order)\n\n    return order\n</code></pre> <p>Problems:</p> <ul> <li>Hard to test (depends on global <code>app</code>)</li> <li>No separation of concerns</li> <li>Difficult to reuse logic</li> <li>Can't mock dependencies</li> </ul>"},{"location":"tutorials/mario-pizzeria-04-api/#the-solution-controller-pattern","title":"The Solution: Controller Pattern","text":"<p>Controllers are thin orchestration layers that delegate to handlers:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  HTTP Request\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Controller  \u2502  \u2022 Parse request\n\u2502              \u2502  \u2022 Create command/query\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2022 Send to mediator\n       \u25bc          \u2022 Format response\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Mediator   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Handler    \u2502  \u2022 Business logic\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2022 Domain operations\n</code></pre> <p>Benefits:</p> <ul> <li>Controllers stay thin (10-20 lines per endpoint)</li> <li>Easy dependency injection</li> <li>Testable without HTTP layer</li> <li>Reusable business logic</li> </ul>"},{"location":"tutorials/mario-pizzeria-04-api/#creating-dtos","title":"\ud83d\udce6 Creating DTOs","text":"<p>DTOs define your API contract - what data goes in and out.</p>"},{"location":"tutorials/mario-pizzeria-04-api/#step-1-create-request-dtos","title":"Step 1: Create Request DTOs","text":"<p>Create <code>api/dtos/order_dtos.py</code>:</p> <pre><code>\"\"\"Data Transfer Objects for Order API\"\"\"\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom typing import Optional\n\nfrom neuroglia.utils import CamelModel\n\n\n@dataclass\nclass CreatePizzaDto:\n    \"\"\"DTO for adding a pizza to an order\"\"\"\n    name: str\n    size: str  # \"small\", \"medium\", \"large\", \"xlarge\"\n    toppings: list[str] = field(default_factory=list)\n\n\nclass CreateOrderDto(CamelModel):\n    \"\"\"\n    DTO for creating a new order.\n\n    CamelModel automatically converts:\n    - customer_name \u2192 customerName in JSON\n    - customer_phone \u2192 customerPhone in JSON\n    \"\"\"\n    customer_name: str\n    customer_phone: str\n    customer_address: Optional[str] = None\n    customer_email: Optional[str] = None\n    pizzas: list[CreatePizzaDto] = field(default_factory=list)\n    payment_method: str = \"cash\"\n    notes: Optional[str] = None\n</code></pre> <p>Why CamelModel?</p> <p>JavaScript/TypeScript clients expect <code>camelCase</code>, but Python uses <code>snake_case</code>. <code>CamelModel</code> handles conversion automatically:</p> <pre><code># Python code\ndto = CreateOrderDto(\n    customer_name=\"John Doe\",\n    customer_phone=\"555-1234\"\n)\n\n# Serializes to JSON as:\n{\n    \"customerName\": \"John Doe\",\n    \"customerPhone\": \"555-1234\"\n}\n</code></pre>"},{"location":"tutorials/mario-pizzeria-04-api/#step-2-create-response-dtos","title":"Step 2: Create Response DTOs","text":"<p>Continue in <code>api/dtos/order_dtos.py</code>:</p> <pre><code>class PizzaDto(CamelModel):\n    \"\"\"DTO for pizza in an order response\"\"\"\n    id: str\n    name: str\n    size: str\n    toppings: list[str]\n    base_price: Decimal\n    total_price: Decimal\n\n\nclass OrderDto(CamelModel):\n    \"\"\"DTO for order response\"\"\"\n    id: str\n    customer_name: str\n    customer_phone: str\n    customer_address: Optional[str] = None\n    pizzas: list[PizzaDto]\n    status: str\n    order_time: datetime\n    confirmed_time: Optional[datetime] = None\n    cooking_started_time: Optional[datetime] = None\n    actual_ready_time: Optional[datetime] = None\n    estimated_ready_time: Optional[datetime] = None\n    notes: Optional[str] = None\n    total_amount: Decimal\n    pizza_count: int\n\n    # Staff tracking\n    chef_name: Optional[str] = None\n    ready_by_name: Optional[str] = None\n    delivery_name: Optional[str] = None\n\n\nclass UpdateOrderStatusDto(CamelModel):\n    \"\"\"DTO for updating order status\"\"\"\n    status: str\n    reason: Optional[str] = None\n</code></pre> <p>DTO Best Practices:</p> <ul> <li>Immutable: Use <code>@dataclass(frozen=True)</code> or Pydantic models</li> <li>Validation: Use Pydantic for automatic validation</li> <li>No Business Logic: DTOs are just data containers</li> <li>Version Control: Create new DTOs for API v2, don't modify existing</li> </ul>"},{"location":"tutorials/mario-pizzeria-04-api/#creating-controllers","title":"\ud83c\udfae Creating Controllers","text":""},{"location":"tutorials/mario-pizzeria-04-api/#step-1-create-the-controller-class","title":"Step 1: Create the Controller Class","text":"<p>Create <code>api/controllers/orders_controller.py</code>:</p> <pre><code>\"\"\"Orders REST API Controller\"\"\"\nfrom typing import List, Optional\n\nfrom fastapi import HTTPException\nfrom classy_fastapi import get, post, put\n\nfrom neuroglia.mvc import ControllerBase\nfrom neuroglia.dependency_injection import ServiceProviderBase\nfrom neuroglia.mapping import Mapper\nfrom neuroglia.mediation import Mediator\n\nfrom api.dtos import CreateOrderDto, OrderDto, UpdateOrderStatusDto\nfrom application.commands import (\n    PlaceOrderCommand,\n    StartCookingCommand,\n    CompleteOrderCommand,\n)\nfrom application.queries import (\n    GetOrderByIdQuery,\n    GetActiveOrdersQuery,\n    GetOrdersByStatusQuery,\n)\n\n\nclass OrdersController(ControllerBase):\n    \"\"\"\n    Pizza order management endpoints.\n\n    ControllerBase provides:\n    - Dependency injection (service_provider, mapper, mediator)\n    - Helper methods (process, ok, created, not_found, etc.)\n    - Consistent error handling\n    - Auto-registration with framework\n    \"\"\"\n\n    def __init__(\n        self,\n        service_provider: ServiceProviderBase,\n        mapper: Mapper,\n        mediator: Mediator\n    ):\n        \"\"\"\n        Dependencies injected by framework.\n\n        All controllers get these three by default.\n        \"\"\"\n        super().__init__(service_provider, mapper, mediator)\n</code></pre>"},{"location":"tutorials/mario-pizzeria-04-api/#step-2-add-get-endpoints","title":"Step 2: Add GET Endpoints","text":"<p>Continue in <code>api/controllers/orders_controller.py</code>:</p> <pre><code>    @get(\n        \"/{order_id}\",\n        response_model=OrderDto,\n        responses=ControllerBase.error_responses\n    )\n    async def get_order(self, order_id: str):\n        \"\"\"\n        Get order details by ID.\n\n        Returns:\n            OrderDto: Order details\n\n        Raises:\n            404: Order not found\n        \"\"\"\n        query = GetOrderByIdQuery(order_id=order_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\n        \"/\",\n        response_model=List[OrderDto],\n        responses=ControllerBase.error_responses\n    )\n    async def get_orders(self, status: Optional[str] = None):\n        \"\"\"\n        Get orders, optionally filtered by status.\n\n        Query Parameters:\n            status: Filter by order status (pending, confirmed, cooking, etc.)\n\n        Returns:\n            List[OrderDto]: List of orders\n        \"\"\"\n        if status:\n            query = GetOrdersByStatusQuery(status=status)\n        else:\n            query = GetActiveOrdersQuery()\n\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre> <p>Key points:</p> <ul> <li><code>@get</code> decorator from <code>classy_fastapi</code> (cleaner than FastAPI's <code>@app.get</code>)</li> <li><code>response_model</code> enables automatic serialization and OpenAPI docs</li> <li><code>self.process()</code> handles <code>OperationResult</code> and converts to HTTP responses</li> <li>Query parameters automatically parsed by FastAPI</li> </ul>"},{"location":"tutorials/mario-pizzeria-04-api/#step-3-add-post-endpoint","title":"Step 3: Add POST Endpoint","text":"<pre><code>    @post(\n        \"/\",\n        response_model=OrderDto,\n        status_code=201,\n        responses=ControllerBase.error_responses\n    )\n    async def place_order(self, request: CreateOrderDto):\n        \"\"\"\n        Place a new pizza order.\n\n        Body:\n            CreateOrderDto: Order details with pizzas\n\n        Returns:\n            OrderDto: Created order with ID\n\n        Status Codes:\n            201: Order created successfully\n            400: Invalid request (validation failed)\n        \"\"\"\n        # Map DTO to command\n        command = self.mapper.map(request, PlaceOrderCommand)\n\n        # Execute via mediator\n        result = await self.mediator.execute_async(command)\n\n        # Process result (converts OperationResult to HTTP response)\n        return self.process(result)\n</code></pre> <p>The flow:</p> <ol> <li>FastAPI validates <code>CreateOrderDto</code> (automatic)</li> <li>Controller maps DTO \u2192 Command</li> <li>Mediator routes to handler</li> <li>Handler executes business logic</li> <li>Handler returns <code>OperationResult</code></li> <li><code>self.process()</code> converts to HTTP response:</li> <li>Success (200) \u2192 Return data</li> <li>Created (201) \u2192 Return data with Location header</li> <li>Not Found (404) \u2192 HTTPException</li> <li>Bad Request (400) \u2192 HTTPException with error details</li> </ol>"},{"location":"tutorials/mario-pizzeria-04-api/#step-4-add-put-endpoints","title":"Step 4: Add PUT Endpoints","text":"<pre><code>    @put(\n        \"/{order_id}/cook\",\n        response_model=OrderDto,\n        responses=ControllerBase.error_responses\n    )\n    async def start_cooking(self, order_id: str):\n        \"\"\"\n        Start cooking an order.\n\n        Path Parameters:\n            order_id: Order to start cooking\n\n        Returns:\n            OrderDto: Updated order\n\n        Status Codes:\n            200: Order cooking started\n            404: Order not found\n            400: Invalid state transition\n        \"\"\"\n        command = StartCookingCommand(order_id=order_id)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @put(\n        \"/{order_id}/ready\",\n        response_model=OrderDto,\n        responses=ControllerBase.error_responses\n    )\n    async def complete_order(self, order_id: str):\n        \"\"\"\n        Mark order as ready for pickup/delivery.\n\n        Path Parameters:\n            order_id: Order to mark as ready\n\n        Returns:\n            OrderDto: Updated order\n        \"\"\"\n        command = CompleteOrderCommand(order_id=order_id)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"tutorials/mario-pizzeria-04-api/#understanding-selfprocess","title":"\ud83d\udd0d Understanding <code>self.process()</code>","text":"<p>The <code>process()</code> method converts <code>OperationResult</code> to HTTP responses:</p> <pre><code># In handler\nreturn self.created(order_dto)  # OperationResult with status 201\n\n# In controller\nreturn self.process(result)  # Converts to HTTP response\n\n# Result:\n# - Status code: 201\n# - Body: order_dto serialized to JSON\n# - Headers: Location: /api/orders/{id}\n</code></pre> <p>Built-in result helpers:</p> <pre><code># Success responses\nself.ok(data)           # 200 OK\nself.created(data)      # 201 Created\nself.accepted(data)     # 202 Accepted\nself.no_content()       # 204 No Content\n\n# Error responses\nself.bad_request(msg)           # 400 Bad Request\nself.unauthorized(msg)          # 401 Unauthorized\nself.forbidden(msg)             # 403 Forbidden\nself.not_found(entity, id)      # 404 Not Found\nself.conflict(msg)              # 409 Conflict\nself.internal_server_error(msg) # 500 Internal Server Error\n</code></pre>"},{"location":"tutorials/mario-pizzeria-04-api/#auto-generated-documentation","title":"\ud83d\udcd6 Auto-Generated Documentation","text":"<p>FastAPI automatically generates OpenAPI docs. Start your app and visit:</p> <ul> <li>Swagger UI: http://localhost:8080/api/docs</li> <li>ReDoc: http://localhost:8080/api/redoc</li> <li>OpenAPI JSON: http://localhost:8080/api/openapi.json</li> </ul> <p>Your endpoints appear with:</p> <ul> <li>Request schemas (CreateOrderDto)</li> <li>Response schemas (OrderDto)</li> <li>Status codes (201, 400, 404, etc.)</li> <li>Descriptions from docstrings</li> <li>Try it out feature for testing</li> </ul>"},{"location":"tutorials/mario-pizzeria-04-api/#testing-controllers","title":"\ud83e\uddea Testing Controllers","text":"<p>Create <code>tests/api/controllers/test_orders_controller.py</code>:</p> <pre><code>\"\"\"Tests for OrdersController\"\"\"\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import AsyncMock, Mock\n\nfrom main import create_pizzeria_app\n\n\n@pytest.fixture\ndef test_client():\n    \"\"\"Create test client with mocked dependencies\"\"\"\n    app = create_pizzeria_app()\n    return TestClient(app)\n\n\ndef test_get_order_not_found(test_client):\n    \"\"\"Test 404 when order doesn't exist\"\"\"\n    response = test_client.get(\"/api/orders/nonexistent\")\n\n    assert response.status_code == 404\n    assert \"not found\" in response.json()[\"detail\"].lower()\n\n\ndef test_place_order_success(test_client):\n    \"\"\"Test successful order creation\"\"\"\n    order_data = {\n        \"customerName\": \"John Doe\",\n        \"customerPhone\": \"555-1234\",\n        \"pizzas\": [\n            {\n                \"name\": \"Margherita\",\n                \"size\": \"large\",\n                \"toppings\": [\"basil\", \"mozzarella\"]\n            }\n        ]\n    }\n\n    response = test_client.post(\"/api/orders/\", json=order_data)\n\n    assert response.status_code == 201\n    data = response.json()\n    assert data[\"id\"] is not None\n    assert data[\"customerName\"] == \"John Doe\"\n    assert data[\"status\"] == \"confirmed\"\n    assert len(data[\"pizzas\"]) == 1\n\n\ndef test_place_order_validation_error(test_client):\n    \"\"\"Test validation with invalid data\"\"\"\n    invalid_data = {\n        # Missing required customerName\n        \"customerPhone\": \"555-1234\"\n    }\n\n    response = test_client.post(\"/api/orders/\", json=invalid_data)\n\n    assert response.status_code == 422  # Validation error\n</code></pre> <p>Run tests:</p> <pre><code>poetry run pytest tests/api/ -v\n</code></pre>"},{"location":"tutorials/mario-pizzeria-04-api/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ol> <li>Controllers are thin: Delegate to mediator, don't contain business logic</li> <li>DTOs define contracts: Use CamelModel for case conversion</li> <li>Mediator pattern: Controllers don't know about handlers</li> <li>Consistent responses: Use OperationResult \u2192 self.process() flow</li> <li>Auto-documentation: FastAPI generates OpenAPI docs automatically</li> <li>Testable: Use TestClient for integration tests</li> </ol>"},{"location":"tutorials/mario-pizzeria-04-api/#whats-next","title":"\ud83d\ude80 What's Next?","text":"<p>In Part 5: Events &amp; Integration, you'll learn:</p> <ul> <li>How to publish and handle domain events</li> <li>Event-driven architecture patterns</li> <li>Integrating with external systems via events</li> <li>Background event processing</li> </ul> <p>Previous: \u2190 Part 3: Commands &amp; Queries | Next: Part 5: Events &amp; Integration \u2192</p>"},{"location":"tutorials/mario-pizzeria-05-events/","title":"Part 5: Events &amp; Integration","text":"<p>Time: 45 minutes | Prerequisites: Part 4</p> <p>In this tutorial, you'll learn how to use domain events to build reactive, loosely-coupled systems. Events enable different parts of your application to react to business occurrences without direct dependencies.</p>"},{"location":"tutorials/mario-pizzeria-05-events/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>What domain events are and when to use them</li> <li>How to publish and handle events</li> <li>Event-driven architecture patterns</li> <li>CloudEvents for external integration</li> <li>Asynchronous event processing</li> </ul>"},{"location":"tutorials/mario-pizzeria-05-events/#understanding-events","title":"\ud83d\udca1 Understanding Events","text":""},{"location":"tutorials/mario-pizzeria-05-events/#the-problem","title":"The Problem","text":"<p>Without events, components are tightly coupled:</p> <pre><code># \u274c Tight coupling - Order knows about Kitchen and Notifications\nclass OrderService:\n    def confirm_order(self, order_id):\n        order = self.repo.get(order_id)\n        order.confirm()\n\n        # Direct dependencies on other systems\n        self.kitchen_service.add_to_queue(order)  # \ud83d\ude1f\n        self.notification_service.send_sms(order)  # \ud83d\ude1f\n        self.analytics_service.track_order(order)  # \ud83d\ude1f\n\n        self.repo.save(order)\n</code></pre> <p>Problems:</p> <ul> <li>Order service knows about Kitchen, Notifications, Analytics</li> <li>Can't add new reactions without modifying OrderService</li> <li>Difficult to test (must mock 3+ services)</li> <li>Changes ripple across services</li> </ul>"},{"location":"tutorials/mario-pizzeria-05-events/#the-solution-domain-events","title":"The Solution: Domain Events","text":"<p>Events decouple the \"what happened\" from \"what to do about it\":</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Order     \u2502  Order confirmed!\n\u2502  (raises    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   event)    \u2502      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n                     \u25bc\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502  Event Bus   \u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u25bc            \u25bc            \u25bc\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 Kitchen \u2502  \u2502  Notify \u2502  \u2502Analytics\u2502\n  \u2502 Handler \u2502  \u2502 Handler \u2502  \u2502 Handler \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Benefits:</p> <ul> <li>Loose Coupling: Order doesn't know who listens</li> <li>Extensibility: Add handlers without changing domain</li> <li>Testability: Test handlers independently</li> <li>Scalability: Process events asynchronously</li> </ul>"},{"location":"tutorials/mario-pizzeria-05-events/#publishing-domain-events","title":"\ud83d\udce3 Publishing Domain Events","text":"<p>Domain events are automatically published when you use <code>AggregateRoot</code>.</p>"},{"location":"tutorials/mario-pizzeria-05-events/#how-it-works","title":"How It Works","text":"<p>In your domain entity (from Part 2):</p> <pre><code>from neuroglia.data.abstractions import AggregateRoot, AggregateState\nfrom domain.events import OrderConfirmedEvent\n\nclass Order(AggregateRoot[OrderState, str]):\n\n    def confirm_order(self) -&gt; None:\n        \"\"\"Confirm the order\"\"\"\n        if self.state.status != OrderStatus.PENDING:\n            raise ValueError(\"Only pending orders can be confirmed\")\n\n        # 1\ufe0f\u20e3 Create event\n        event = OrderConfirmedEvent(\n            aggregate_id=self.id(),\n            confirmed_time=datetime.now(timezone.utc),\n            total_amount=self.total_amount,\n            pizza_count=self.pizza_count\n        )\n\n        # 2\ufe0f\u20e3 Register event (stored in aggregate)\n        self.register_event(event)\n\n        # 3\ufe0f\u20e3 Apply to state\n        self.state.on(event)\n</code></pre> <p>When are events published?</p> <p>Events are automatically dispatched when you use <code>UnitOfWork</code>:</p> <pre><code># In handler\nawait self.unit_of_work.register(order)\nawait self.unit_of_work.save_changes_async()\n\n# UnitOfWork does:\n# 1. Save aggregate to repository\n# 2. Get uncommitted events from aggregate\n# 3. Publish each event to event bus\n# 4. Clear uncommitted events\n</code></pre> <p>This is configured in <code>main.py</code>:</p> <pre><code>from neuroglia.data.unit_of_work import UnitOfWork\nfrom neuroglia.mediation.behaviors import DomainEventDispatchingMiddleware\n\n# Configure UnitOfWork\nUnitOfWork.configure(builder)\n\n# Add middleware to auto-publish events\nDomainEventDispatchingMiddleware.configure(builder)\n</code></pre>"},{"location":"tutorials/mario-pizzeria-05-events/#handling-domain-events","title":"\ud83c\udfa7 Handling Domain Events","text":"<p>Event handlers react to domain events.</p>"},{"location":"tutorials/mario-pizzeria-05-events/#step-1-create-event-handler","title":"Step 1: Create Event Handler","text":"<p>Create <code>application/events/order_event_handlers.py</code>:</p> <pre><code>\"\"\"Order event handlers\"\"\"\nimport logging\n\nfrom domain.events import OrderConfirmedEvent\nfrom neuroglia.mediation import DomainEventHandler\n\nlogger = logging.getLogger(__name__)\n\n\nclass OrderConfirmedEventHandler(DomainEventHandler[OrderConfirmedEvent]):\n    \"\"\"\n    Handles OrderConfirmedEvent.\n\n    DomainEventHandler:\n    - Processes events after they're published\n    - Can have side effects (send email, update systems)\n    - Runs asynchronously\n    - Multiple handlers can listen to same event\n    \"\"\"\n\n    async def handle_async(self, event: OrderConfirmedEvent) -&gt; None:\n        \"\"\"\n        Process order confirmed event.\n\n        This runs AFTER the order is saved to the database.\n        \"\"\"\n        logger.info(\n            f\"\ud83c\udf55 Order {event.aggregate_id} confirmed! \"\n            f\"Total: ${event.total_amount}, Pizzas: {event.pizza_count}\"\n        )\n\n        # Send confirmation SMS\n        await self._send_customer_sms(event)\n\n        # Add to kitchen queue\n        await self._notify_kitchen(event)\n\n        # Track in analytics\n        await self._track_analytics(event)\n\n    async def _send_customer_sms(self, event: OrderConfirmedEvent):\n        \"\"\"Send SMS notification to customer\"\"\"\n        # In real app: integrate with Twilio, SNS, etc.\n        logger.info(f\"\ud83d\udcf1 SMS sent: Order {event.aggregate_id} confirmed\")\n\n    async def _notify_kitchen(self, event: OrderConfirmedEvent):\n        \"\"\"Add order to kitchen queue\"\"\"\n        # In real app: update kitchen display system\n        logger.info(f\"\ud83d\udc68\u200d\ud83c\udf73 Kitchen notified of order {event.aggregate_id}\")\n\n    async def _track_analytics(self, event: OrderConfirmedEvent):\n        \"\"\"Track order in analytics\"\"\"\n        # In real app: send to analytics service\n        logger.info(f\"\ud83d\udcca Analytics tracked for order {event.aggregate_id}\")\n</code></pre> <p>Handler characteristics:</p> <ul> <li>Async: All handlers are async for non-blocking execution</li> <li>Side Effects Only: Don't modify domain state (that happened already)</li> <li>Idempotent: Should be safe to run multiple times</li> <li>Independent: One handler failure shouldn't affect others</li> </ul>"},{"location":"tutorials/mario-pizzeria-05-events/#step-2-create-multiple-handlers-for-same-event","title":"Step 2: Create Multiple Handlers for Same Event","text":"<p>You can have multiple handlers for the same event:</p> <pre><code>class OrderConfirmedEmailHandler(DomainEventHandler[OrderConfirmedEvent]):\n    \"\"\"Sends email receipt when order is confirmed\"\"\"\n\n    def __init__(self, email_service: EmailService):\n        self.email_service = email_service\n\n    async def handle_async(self, event: OrderConfirmedEvent) -&gt; None:\n        \"\"\"Send email receipt\"\"\"\n        logger.info(f\"\ud83d\udce7 Sending email receipt for order {event.aggregate_id}\")\n\n        await self.email_service.send_receipt(\n            order_id=event.aggregate_id,\n            total=event.total_amount\n        )\n\n\nclass OrderConfirmedMetricsHandler(DomainEventHandler[OrderConfirmedEvent]):\n    \"\"\"Records metrics when order is confirmed\"\"\"\n\n    async def handle_async(self, event: OrderConfirmedEvent) -&gt; None:\n        \"\"\"Record order metrics\"\"\"\n        logger.info(f\"\ud83d\udcc8 Recording metrics for order {event.aggregate_id}\")\n\n        # Record metrics (e.g., Prometheus, CloudWatch)\n        # metrics.order_total.observe(event.total_amount)\n        # metrics.pizza_count.observe(event.pizza_count)\n</code></pre> <p>All three handlers will execute when <code>OrderConfirmedEvent</code> is published!</p>"},{"location":"tutorials/mario-pizzeria-05-events/#step-3-handler-for-order-lifecycle","title":"Step 3: Handler for Order Lifecycle","text":"<p>Create handlers for other events:</p> <pre><code>class CookingStartedEventHandler(DomainEventHandler[CookingStartedEvent]):\n    \"\"\"Handles cooking started events\"\"\"\n\n    async def handle_async(self, event: CookingStartedEvent) -&gt; None:\n        \"\"\"Process cooking started\"\"\"\n        logger.info(\n            f\"\ud83d\udc68\u200d\ud83c\udf73 Cooking started for order {event.aggregate_id} \"\n            f\"by {event.user_name} at {event.cooking_started_time}\"\n        )\n\n        # Update customer app with cooking status\n        # Send estimated ready time notification\n        # Update kitchen display\n\n\nclass OrderReadyEventHandler(DomainEventHandler[OrderReadyEvent]):\n    \"\"\"Handles order ready events\"\"\"\n\n    async def handle_async(self, event: OrderReadyEvent) -&gt; None:\n        \"\"\"Process order ready\"\"\"\n        logger.info(\n            f\"\u2705 Order {event.aggregate_id} is ready! \"\n            f\"Completed by {event.user_name}\"\n        )\n\n        # Send \"order ready\" SMS/push notification\n        # Update pickup queue display\n        # Print pickup receipt\n\n        # Calculate if order was on time\n        if event.estimated_ready_time:\n            delta = (event.ready_time - event.estimated_ready_time).total_seconds()\n            if delta &gt; 300:  # 5 minutes late\n                logger.warning(f\"\u23f0 Order was {delta/60:.1f} minutes late\")\n</code></pre>"},{"location":"tutorials/mario-pizzeria-05-events/#cloudevents-for-external-integration","title":"\ud83c\udf10 CloudEvents for External Integration","text":"<p>CloudEvents is a standard format for event interoperability.</p>"},{"location":"tutorials/mario-pizzeria-05-events/#what-are-cloudevents","title":"What are CloudEvents?","text":"<p>CloudEvents provide a common event format:</p> <pre><code>{\n  \"specversion\": \"1.0\",\n  \"type\": \"com.mario-pizzeria.order.confirmed\",\n  \"source\": \"/orders/service\",\n  \"id\": \"A234-1234-1234\",\n  \"time\": \"2025-10-25T14:30:00Z\",\n  \"datacontenttype\": \"application/json\",\n  \"data\": {\n    \"orderId\": \"order-123\",\n    \"totalAmount\": 29.98,\n    \"pizzaCount\": 2\n  }\n}\n</code></pre> <p>Benefits:</p> <ul> <li>Interoperability: Works across languages and platforms</li> <li>Routing: Type-based routing in event brokers</li> <li>Metadata: Standardized headers (source, time, type)</li> <li>Tools: Compatible with Knative, Azure Event Grid, etc.</li> </ul>"},{"location":"tutorials/mario-pizzeria-05-events/#publishing-cloudevents","title":"Publishing CloudEvents","text":"<p>Create <code>application/events/base_domain_event_handler.py</code>:</p> <pre><code>\"\"\"Base handler for publishing CloudEvents\"\"\"\nfrom typing import Generic, TypeVar\n\nfrom neuroglia.eventing.cloud_events.infrastructure import CloudEventBus\nfrom neuroglia.eventing.cloud_events.infrastructure.cloud_event_publisher import (\n    CloudEventPublishingOptions\n)\nfrom neuroglia.eventing.domain_event import DomainEvent\nfrom neuroglia.mediation import Mediator\n\nTEvent = TypeVar(\"TEvent\", bound=DomainEvent)\n\n\nclass BaseDomainEventHandler(Generic[TEvent]):\n    \"\"\"\n    Base class for event handlers that publish CloudEvents.\n\n    Provides helper to convert domain events to CloudEvents.\n    \"\"\"\n\n    def __init__(\n        self,\n        mediator: Mediator,\n        cloud_event_bus: CloudEventBus,\n        cloud_event_publishing_options: CloudEventPublishingOptions,\n    ):\n        self.mediator = mediator\n        self.cloud_event_bus = cloud_event_bus\n        self.publishing_options = cloud_event_publishing_options\n\n    async def publish_cloud_event_async(self, event: TEvent) -&gt; None:\n        \"\"\"\n        Publish domain event as CloudEvent.\n\n        The framework automatically:\n        - Converts domain event to CloudEvent format\n        - Adds metadata (type, source, time, id)\n        - Publishes to configured event bus\n        \"\"\"\n        if self.cloud_event_bus and self.publishing_options:\n            await self.cloud_event_bus.publish_async(\n                event,\n                self.publishing_options\n            )\n</code></pre> <p>Use in handlers:</p> <pre><code>class OrderConfirmedEventHandler(\n    BaseDomainEventHandler[OrderConfirmedEvent],\n    DomainEventHandler[OrderConfirmedEvent]\n):\n\n    async def handle_async(self, event: OrderConfirmedEvent) -&gt; None:\n        \"\"\"Process and publish event\"\"\"\n        logger.info(f\"Order {event.aggregate_id} confirmed\")\n\n        # Handle internally\n        await self._send_notifications(event)\n\n        # Publish to external systems via CloudEvents\n        await self.publish_cloud_event_async(event)\n</code></pre>"},{"location":"tutorials/mario-pizzeria-05-events/#configure-cloudevents-in-mainpy","title":"Configure CloudEvents in main.py","text":"<pre><code>from neuroglia.eventing.cloud_events.infrastructure import (\n    CloudEventPublisher,\n    CloudEventIngestor\n)\n\n# Configure CloudEvent publishing\nCloudEventPublisher.configure(builder)\n\n# Configure CloudEvent consumption (optional)\nCloudEventIngestor.configure(\n    builder,\n    [\"application.events.integration\"]  # External event handlers\n)\n</code></pre>"},{"location":"tutorials/mario-pizzeria-05-events/#testing-event-handlers","title":"\ud83e\uddea Testing Event Handlers","text":"<p>Create <code>tests/application/events/test_order_event_handlers.py</code>:</p> <pre><code>\"\"\"Tests for order event handlers\"\"\"\nimport pytest\nfrom unittest.mock import AsyncMock, Mock\nfrom datetime import datetime, timezone\nfrom decimal import Decimal\n\nfrom application.events.order_event_handlers import (\n    OrderConfirmedEventHandler\n)\nfrom domain.events import OrderConfirmedEvent\n\n\n@pytest.fixture\ndef handler():\n    \"\"\"Create handler with mocked dependencies\"\"\"\n    mediator = AsyncMock()\n    cloud_event_bus = AsyncMock()\n    publishing_options = Mock()\n\n    return OrderConfirmedEventHandler(\n        mediator=mediator,\n        cloud_event_bus=cloud_event_bus,\n        cloud_event_publishing_options=publishing_options\n    )\n\n\n@pytest.mark.asyncio\nasync def test_order_confirmed_handler(handler):\n    \"\"\"Test OrderConfirmedEventHandler processes event\"\"\"\n    # Create event\n    event = OrderConfirmedEvent(\n        aggregate_id=\"order-123\",\n        confirmed_time=datetime.now(timezone.utc),\n        total_amount=Decimal(\"29.98\"),\n        pizza_count=2\n    )\n\n    # Handle event\n    await handler.handle_async(event)\n\n    # Verify CloudEvent published\n    handler.cloud_event_bus.publish_async.assert_called_once()\n\n\n@pytest.mark.asyncio\nasync def test_multiple_handlers_same_event():\n    \"\"\"Test multiple handlers can process same event\"\"\"\n    event = OrderConfirmedEvent(\n        aggregate_id=\"order-123\",\n        confirmed_time=datetime.now(timezone.utc),\n        total_amount=Decimal(\"29.98\"),\n        pizza_count=2\n    )\n\n    # Create multiple handlers\n    handler1 = OrderConfirmedEventHandler(Mock(), AsyncMock(), Mock())\n    handler2 = OrderConfirmedEmailHandler(Mock())\n\n    # Both should handle event\n    await handler1.handle_async(event)\n    await handler2.handle_async(event)\n\n    # Each handler processes independently\n    assert True  # Both completed without error\n</code></pre>"},{"location":"tutorials/mario-pizzeria-05-events/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ol> <li>Domain Events: Represent business occurrences, raised by aggregates</li> <li>Loose Coupling: Events decouple publishers from subscribers</li> <li>Multiple Handlers: Many handlers can react to one event</li> <li>Automatic Publishing: UnitOfWork + middleware handles event dispatch</li> <li>CloudEvents: Standard format for external integration</li> <li>Async Processing: Handlers run asynchronously for performance</li> </ol>"},{"location":"tutorials/mario-pizzeria-05-events/#whats-next","title":"\ud83d\ude80 What's Next?","text":"<p>In Part 6: Persistence &amp; Repositories, you'll learn:</p> <ul> <li>Implementing the repository pattern</li> <li>MongoDB integration with Motor</li> <li>Transaction management with UnitOfWork</li> <li>Data persistence strategies</li> </ul> <p>Previous: \u2190 Part 4: API Controllers | Next: Part 6: Persistence &amp; Repositories \u2192</p>"},{"location":"tutorials/mario-pizzeria-06-persistence/","title":"Part 6: Persistence &amp; Repositories","text":"<p>Time: 45 minutes | Prerequisites: Part 5</p> <p>In this tutorial, you'll implement data persistence using the Repository pattern with MongoDB. You'll learn how to abstract data access and maintain clean separation between domain and infrastructure.</p>"},{"location":"tutorials/mario-pizzeria-06-persistence/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>The Repository pattern and why it matters</li> <li>MongoDB integration with Motor (async driver)</li> <li>Implementing repositories for aggregates</li> <li>Transaction management with UnitOfWork</li> <li>Testing data access layers</li> </ul>"},{"location":"tutorials/mario-pizzeria-06-persistence/#understanding-the-repository-pattern","title":"\ud83d\udcbe Understanding the Repository Pattern","text":""},{"location":"tutorials/mario-pizzeria-06-persistence/#the-problem","title":"The Problem","text":"<p>Without repositories, domain logic is polluted with database code:</p> <pre><code># \u274c Domain entity knows about MongoDB\nclass Order(AggregateRoot):\n    async def save(self):\n        collection = mongo_client.db.orders\n        await collection.insert_one(self.__dict__)  # \ud83d\ude31\n</code></pre> <p>Problems:</p> <ul> <li>Domain depends on infrastructure (MongoDB)</li> <li>Can't test without database</li> <li>Can't swap database implementations</li> <li>Violates clean architecture</li> </ul>"},{"location":"tutorials/mario-pizzeria-06-persistence/#the-solution-repository-pattern","title":"The Solution: Repository Pattern","text":"<p>Repositories abstract data access behind interfaces:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Domain     \u2502  Uses interface\n\u2502   (Order)    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n                          \u25bc\n                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                 \u2502  IOrderRepo    \u2502  (interface)\n                 \u2502  - get()       \u2502\n                 \u2502  - add()       \u2502\n                 \u2502  - list()      \u2502\n                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u25bc                 \u25bc                 \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502MongoOrderRepo\u2502  \u2502  FileRepo    \u2502  \u2502 InMemoryRepo \u2502\n\u2502              \u2502  \u2502              \u2502  \u2502              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Benefits:</p> <ul> <li>Testability: Use in-memory repo for tests</li> <li>Flexibility: Swap implementations without changing domain</li> <li>Clean Architecture: Domain doesn't depend on infrastructure</li> <li>Consistency: Standard interface for all data access</li> </ul>"},{"location":"tutorials/mario-pizzeria-06-persistence/#defining-repository-interfaces","title":"\ud83d\udcdd Defining Repository Interfaces","text":""},{"location":"tutorials/mario-pizzeria-06-persistence/#step-1-create-repository-interface","title":"Step 1: Create Repository Interface","text":"<p>Create <code>domain/repositories/__init__.py</code>:</p> <pre><code>\"\"\"Repository interfaces for domain entities\"\"\"\nfrom abc import ABC, abstractmethod\nfrom typing import List, Optional\n\nfrom domain.entities import Order\n\n\nclass IOrderRepository(ABC):\n    \"\"\"\n    Interface for Order persistence.\n\n    Domain defines the contract, infrastructure implements it.\n    \"\"\"\n\n    @abstractmethod\n    async def get_async(self, order_id: str) -&gt; Optional[Order]:\n        \"\"\"Get order by ID\"\"\"\n        pass\n\n    @abstractmethod\n    async def add_async(self, order: Order) -&gt; None:\n        \"\"\"Add new order\"\"\"\n        pass\n\n    @abstractmethod\n    async def update_async(self, order: Order) -&gt; None:\n        \"\"\"Update existing order\"\"\"\n        pass\n\n    @abstractmethod\n    async def delete_async(self, order_id: str) -&gt; None:\n        \"\"\"Delete order\"\"\"\n        pass\n\n    @abstractmethod\n    async def list_async(self) -&gt; List[Order]:\n        \"\"\"Get all orders\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_by_status_async(self, status: str) -&gt; List[Order]:\n        \"\"\"Find orders by status\"\"\"\n        pass\n</code></pre> <p>Key points:</p> <ul> <li>Interface only: No implementation details</li> <li>Domain types: Works with <code>Order</code> entities, not dicts/documents</li> <li>Async: All methods async for non-blocking I/O</li> <li>Business queries: <code>find_by_status_async</code> reflects business needs</li> </ul>"},{"location":"tutorials/mario-pizzeria-06-persistence/#mongodb-implementation","title":"\ud83d\uddc4\ufe0f MongoDB Implementation","text":""},{"location":"tutorials/mario-pizzeria-06-persistence/#step-1-install-motor","title":"Step 1: Install Motor","text":"<p>Motor is the async MongoDB driver:</p> <pre><code>poetry add motor pymongo\n</code></pre>"},{"location":"tutorials/mario-pizzeria-06-persistence/#step-2-implement-mongodb-repository","title":"Step 2: Implement MongoDB Repository","text":"<p>Create <code>integration/repositories/mongo_order_repository.py</code>:</p> <pre><code>\"\"\"MongoDB implementation of IOrderRepository\"\"\"\nfrom typing import List, Optional\n\nfrom motor.motor_asyncio import AsyncIOMotorCollection\n\nfrom domain.entities import Order, OrderStatus\nfrom domain.repositories import IOrderRepository\nfrom neuroglia.data.infrastructure.mongo import MotorRepository\n\n\nclass MongoOrderRepository(\n    MotorRepository[Order, str],\n    IOrderRepository\n):\n    \"\"\"\n    MongoDB implementation of order repository.\n\n    MotorRepository provides:\n    - Automatic serialization/deserialization\n    - CRUD operations\n    - Query helpers\n    \"\"\"\n\n    def __init__(self, collection: AsyncIOMotorCollection):\n        \"\"\"\n        Initialize with MongoDB collection.\n\n        Collection is injected by DI container.\n        \"\"\"\n        super().__init__(collection, Order, str)\n\n    async def find_by_status_async(\n        self,\n        status: str\n    ) -&gt; List[Order]:\n        \"\"\"Find orders by status\"\"\"\n        # Convert status string to enum\n        order_status = OrderStatus(status.lower())\n\n        # Query MongoDB\n        cursor = self.collection.find({\"state.status\": order_status.value})\n\n        # Deserialize to Order entities\n        orders = []\n        async for doc in cursor:\n            order = await self._deserialize_async(doc)\n            orders.append(order)\n\n        return orders\n\n    async def find_active_orders_async(self) -&gt; List[Order]:\n        \"\"\"Find orders that are not delivered or cancelled\"\"\"\n        active_statuses = [\n            OrderStatus.PENDING.value,\n            OrderStatus.CONFIRMED.value,\n            OrderStatus.COOKING.value,\n            OrderStatus.READY.value,\n            OrderStatus.DELIVERING.value,\n        ]\n\n        cursor = self.collection.find({\n            \"state.status\": {\"$in\": active_statuses}\n        })\n\n        orders = []\n        async for doc in cursor:\n            order = await self._deserialize_async(doc)\n            orders.append(order)\n\n        return orders\n</code></pre> <p>What MotorRepository provides:</p> <ul> <li><code>get_async(id)</code>: Get by ID</li> <li><code>add_async(entity)</code>: Insert new entity</li> <li><code>update_async(entity)</code>: Update existing entity</li> <li><code>delete_async(id)</code>: Delete by ID</li> <li><code>list_async()</code>: Get all entities</li> <li>Automatic serialization using JsonSerializer</li> <li>Automatic deserialization to domain entities</li> </ul>"},{"location":"tutorials/mario-pizzeria-06-persistence/#step-3-configure-mongodb-connection","title":"Step 3: Configure MongoDB Connection","text":"<p>In <code>main.py</code>:</p> <pre><code>from neuroglia.data.infrastructure.mongo import MotorRepository\nfrom domain.entities import Order, Customer, Pizza\nfrom domain.repositories import (\n    IOrderRepository,\n    ICustomerRepository,\n    IPizzaRepository\n)\nfrom integration.repositories import (\n    MongoOrderRepository,\n    MongoCustomerRepository,\n    MongoPizzaRepository\n)\n\ndef create_pizzeria_app():\n    builder = WebApplicationBuilder()\n\n    # ... other configuration ...\n\n    # Configure MongoDB repositories\n    MotorRepository.configure(\n        builder,\n        entity_type=Order,\n        key_type=str,\n        database_name=\"mario_pizzeria\",\n        collection_name=\"orders\"\n    )\n\n    MotorRepository.configure(\n        builder,\n        entity_type=Customer,\n        key_type=str,\n        database_name=\"mario_pizzeria\",\n        collection_name=\"customers\"\n    )\n\n    # Register repository implementations\n    builder.services.add_scoped(IOrderRepository, MongoOrderRepository)\n    builder.services.add_scoped(ICustomerRepository, MongoCustomerRepository)\n\n    return builder.build_app_with_lifespan(...)\n</code></pre> <p>Configuration does:</p> <ol> <li>Creates MongoDB connection pool</li> <li>Sets up collection access</li> <li>Registers serialization/deserialization</li> <li>Binds interface to implementation in DI</li> </ol>"},{"location":"tutorials/mario-pizzeria-06-persistence/#step-4-environment-configuration","title":"Step 4: Environment Configuration","text":"<p>Create <code>.env</code> file:</p> <pre><code># MongoDB Configuration\nMONGODB_URI=mongodb://localhost:27017\nMONGODB_DATABASE=mario_pizzeria\n\n# Or for MongoDB Atlas\n# MONGODB_URI=mongodb+srv://user:pass@cluster.mongodb.net/\n\n# Application Settings\nLOG_LEVEL=INFO\n</code></pre> <p>Load in <code>application/settings.py</code>:</p> <pre><code>\"\"\"Application settings\"\"\"\nfrom pydantic_settings import BaseSettings\n\n\nclass AppSettings(BaseSettings):\n    \"\"\"Application configuration\"\"\"\n\n    # MongoDB\n    mongodb_uri: str = \"mongodb://localhost:27017\"\n    mongodb_database: str = \"mario_pizzeria\"\n\n    # Logging\n    log_level: str = \"INFO\"\n\n    class Config:\n        env_file = \".env\"\n\n\n# Singleton instance\napp_settings = AppSettings()\n</code></pre>"},{"location":"tutorials/mario-pizzeria-06-persistence/#transaction-management-with-unitofwork","title":"\ud83d\udd04 Transaction Management with UnitOfWork","text":"<p>The UnitOfWork pattern manages transactions and event publishing.</p>"},{"location":"tutorials/mario-pizzeria-06-persistence/#how-unitofwork-works","title":"How UnitOfWork Works","text":"<pre><code># In command handler\nasync def handle_async(self, command: PlaceOrderCommand):\n    # 1\ufe0f\u20e3 Create order (in memory)\n    order = Order(customer_id=command.customer_id)\n    order.add_order_item(item)\n    order.confirm_order()  # Raises OrderConfirmedEvent\n\n    # 2\ufe0f\u20e3 Register with UnitOfWork\n    await self.unit_of_work.register(order)\n\n    # 3\ufe0f\u20e3 Save changes (transaction)\n    await self.unit_of_work.save_changes_async()\n\n    # UnitOfWork does:\n    # - Saves order to repository\n    # - Gets uncommitted events from order\n    # - Publishes events to event bus\n    # - Clears uncommitted events\n    # - All in a single transaction!\n</code></pre> <p>Benefits:</p> <ul> <li>Atomic: All changes succeed or fail together</li> <li>Event consistency: Events only published if save succeeds</li> <li>Automatic: No manual event publishing needed</li> </ul>"},{"location":"tutorials/mario-pizzeria-06-persistence/#configure-unitofwork","title":"Configure UnitOfWork","text":"<p>In <code>main.py</code>:</p> <pre><code>from neuroglia.data.unit_of_work import UnitOfWork\nfrom neuroglia.mediation.behaviors import DomainEventDispatchingMiddleware\n\n# Configure UnitOfWork\nUnitOfWork.configure(builder)\n\n# Add middleware for automatic event publishing\nDomainEventDispatchingMiddleware.configure(builder)\n</code></pre>"},{"location":"tutorials/mario-pizzeria-06-persistence/#testing-repositories","title":"\ud83e\uddea Testing Repositories","text":""},{"location":"tutorials/mario-pizzeria-06-persistence/#option-1-in-memory-repository-unit-tests","title":"Option 1: In-Memory Repository (Unit Tests)","text":"<p>Create <code>tests/fixtures/in_memory_order_repository.py</code>:</p> <pre><code>\"\"\"In-memory repository for testing\"\"\"\nfrom typing import Dict, List, Optional\n\nfrom domain.entities import Order, OrderStatus\nfrom domain.repositories import IOrderRepository\n\n\nclass InMemoryOrderRepository(IOrderRepository):\n    \"\"\"In-memory implementation for testing\"\"\"\n\n    def __init__(self):\n        self._orders: Dict[str, Order] = {}\n\n    async def get_async(self, order_id: str) -&gt; Optional[Order]:\n        return self._orders.get(order_id)\n\n    async def add_async(self, order: Order) -&gt; None:\n        self._orders[order.id()] = order\n\n    async def update_async(self, order: Order) -&gt; None:\n        self._orders[order.id()] = order\n\n    async def delete_async(self, order_id: str) -&gt; None:\n        self._orders.pop(order_id, None)\n\n    async def list_async(self) -&gt; List[Order]:\n        return list(self._orders.values())\n\n    async def find_by_status_async(self, status: str) -&gt; List[Order]:\n        order_status = OrderStatus(status.lower())\n        return [\n            o for o in self._orders.values()\n            if o.state.status == order_status\n        ]\n</code></pre> <p>Use in tests:</p> <pre><code>@pytest.fixture\ndef order_repository():\n    return InMemoryOrderRepository()\n\n\n@pytest.mark.asyncio\nasync def test_place_order_handler(order_repository):\n    \"\"\"Test handler with in-memory repository\"\"\"\n    handler = PlaceOrderHandler(\n        order_repository=order_repository,\n        # ... other mocks\n    )\n\n    command = PlaceOrderCommand(...)\n    result = await handler.handle_async(command)\n\n    assert result.is_success\n\n    # Verify order was saved\n    orders = await order_repository.list_async()\n    assert len(orders) == 1\n</code></pre>"},{"location":"tutorials/mario-pizzeria-06-persistence/#option-2-integration-tests-with-mongodb","title":"Option 2: Integration Tests with MongoDB","text":"<p>Create <code>tests/integration/test_mongo_order_repository.py</code>:</p> <pre><code>\"\"\"Integration tests for MongoDB repository\"\"\"\nimport pytest\nfrom motor.motor_asyncio import AsyncIOMotorClient\n\nfrom domain.entities import Order, OrderItem, PizzaSize\nfrom integration.repositories import MongoOrderRepository\nfrom decimal import Decimal\n\n\n@pytest.fixture\nasync def mongo_client():\n    \"\"\"Create test MongoDB client\"\"\"\n    client = AsyncIOMotorClient(\"mongodb://localhost:27017\")\n    yield client\n\n    # Cleanup\n    await client.mario_pizzeria_test.orders.delete_many({})\n    client.close()\n\n\n@pytest.fixture\nasync def order_repository(mongo_client):\n    \"\"\"Create repository with test collection\"\"\"\n    collection = mongo_client.mario_pizzeria_test.orders\n    return MongoOrderRepository(collection)\n\n\n@pytest.mark.asyncio\n@pytest.mark.integration\nasync def test_crud_operations(order_repository):\n    \"\"\"Test complete CRUD workflow\"\"\"\n    # Create\n    order = Order(customer_id=\"cust-123\")\n    item = OrderItem.create(\n        name=\"Margherita\",\n        size=PizzaSize.LARGE,\n        quantity=1,\n        unit_price=Decimal(\"12.99\")\n    )\n    order.add_order_item(item)\n    order.confirm_order()\n\n    await order_repository.add_async(order)\n\n    # Read\n    retrieved = await order_repository.get_async(order.id())\n    assert retrieved is not None\n    assert retrieved.state.customer_id == \"cust-123\"\n    assert retrieved.pizza_count == 1\n\n    # Update\n    retrieved.start_cooking(user_id=\"chef-1\", user_name=\"Mario\")\n    await order_repository.update_async(retrieved)\n\n    # Verify update\n    updated = await order_repository.get_async(order.id())\n    assert updated.state.status == OrderStatus.COOKING\n\n    # Delete\n    await order_repository.delete_async(order.id())\n    deleted = await order_repository.get_async(order.id())\n    assert deleted is None\n</code></pre> <p>Run integration tests:</p> <pre><code># Start MongoDB\ndocker run -d -p 27017:27017 mongo:latest\n\n# Run tests\npoetry run pytest tests/integration/ -m integration -v\n</code></pre>"},{"location":"tutorials/mario-pizzeria-06-persistence/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ol> <li>Repository Pattern: Abstracts data access behind interfaces</li> <li>Clean Architecture: Domain doesn't depend on infrastructure</li> <li>Motor: Async MongoDB driver for Python</li> <li>MotorRepository: Framework base class with CRUD operations</li> <li>UnitOfWork: Manages transactions and event publishing</li> <li>Testing: Use in-memory repos for unit tests, real DB for integration tests</li> </ol>"},{"location":"tutorials/mario-pizzeria-06-persistence/#whats-next","title":"\ud83d\ude80 What's Next?","text":"<p>In Part 7: Authentication &amp; Authorization, you'll learn:</p> <ul> <li>OAuth2 and JWT authentication</li> <li>Keycloak integration</li> <li>Role-based access control (RBAC)</li> <li>Protecting API endpoints</li> </ul> <p>Previous: \u2190 Part 5: Events &amp; Integration | Next: Part 7: Authentication &amp; Authorization \u2192</p>"},{"location":"tutorials/mario-pizzeria-07-auth/","title":"Part 7: Authentication &amp; Security","text":"<p>Time: 30 minutes | Prerequisites: Part 6</p> <p>In this tutorial, you'll secure your application with authentication and authorization. Mario's Pizzeria uses OAuth2/JWT for API authentication and Keycloak for SSO in the web UI.</p>"},{"location":"tutorials/mario-pizzeria-07-auth/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>OAuth2 and JWT authentication basics</li> <li>Keycloak integration for SSO</li> <li>Role-based access control (RBAC)</li> <li>Protecting API endpoints</li> <li>Session vs token authentication</li> </ul>"},{"location":"tutorials/mario-pizzeria-07-auth/#authentication-strategies","title":"\ud83d\udd10 Authentication Strategies","text":"<p>Mario's Pizzeria uses two authentication strategies:</p>"},{"location":"tutorials/mario-pizzeria-07-auth/#api-authentication-jwt-tokens","title":"API Authentication (JWT Tokens)","text":"<pre><code>External Apps \u2192 JWT Token \u2192 API Endpoints\n</code></pre> <p>Use case: Mobile apps, external integrations</p>"},{"location":"tutorials/mario-pizzeria-07-auth/#ui-authentication-keycloak-sso","title":"UI Authentication (Keycloak SSO)","text":"<pre><code>Web Users \u2192 Keycloak Login \u2192 Session Cookies \u2192 UI\n</code></pre> <p>Use case: Web interface, staff portal</p>"},{"location":"tutorials/mario-pizzeria-07-auth/#jwt-authentication-for-api","title":"\ud83c\udfab JWT Authentication for API","text":""},{"location":"tutorials/mario-pizzeria-07-auth/#step-1-install-dependencies","title":"Step 1: Install Dependencies","text":"<pre><code>poetry add python-jose[cryptography] passlib python-multipart\n</code></pre>"},{"location":"tutorials/mario-pizzeria-07-auth/#step-2-create-authentication-service","title":"Step 2: Create Authentication Service","text":"<p>Create <code>application/services/auth_service.py</code>:</p> <pre><code>\"\"\"Authentication service\"\"\"\nfrom datetime import datetime, timedelta\nfrom typing import Optional\n\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\n\n\nclass AuthService:\n    \"\"\"Handles authentication and token generation\"\"\"\n\n    SECRET_KEY = \"your-secret-key-here\"  # Use environment variable in production!\n    ALGORITHM = \"HS256\"\n    ACCESS_TOKEN_EXPIRE_MINUTES = 30\n\n    def __init__(self):\n        self.pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n    def verify_password(self, plain_password: str, hashed_password: str) -&gt; bool:\n        \"\"\"Verify password against hash\"\"\"\n        return self.pwd_context.verify(plain_password, hashed_password)\n\n    def hash_password(self, password: str) -&gt; str:\n        \"\"\"Hash a password\"\"\"\n        return self.pwd_context.hash(password)\n\n    def create_access_token(\n        self,\n        data: dict,\n        expires_delta: Optional[timedelta] = None\n    ) -&gt; str:\n        \"\"\"Create JWT access token\"\"\"\n        to_encode = data.copy()\n\n        if expires_delta:\n            expire = datetime.utcnow() + expires_delta\n        else:\n            expire = datetime.utcnow() + timedelta(\n                minutes=self.ACCESS_TOKEN_EXPIRE_MINUTES\n            )\n\n        to_encode.update({\"exp\": expire})\n        encoded_jwt = jwt.encode(to_encode, self.SECRET_KEY, algorithm=self.ALGORITHM)\n        return encoded_jwt\n\n    def decode_token(self, token: str) -&gt; Optional[dict]:\n        \"\"\"Decode and verify JWT token\"\"\"\n        try:\n            payload = jwt.decode(\n                token,\n                self.SECRET_KEY,\n                algorithms=[self.ALGORITHM]\n            )\n            return payload\n        except JWTError:\n            return None\n</code></pre>"},{"location":"tutorials/mario-pizzeria-07-auth/#step-3-protect-api-endpoints","title":"Step 3: Protect API Endpoints","text":"<p>Create <code>api/dependencies/auth.py</code>:</p> <pre><code>\"\"\"Authentication dependencies\"\"\"\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\n\nfrom application.services import AuthService\n\n\nsecurity = HTTPBearer()\n\n\nasync def get_current_user(\n    credentials: HTTPAuthorizationCredentials = Depends(security),\n    auth_service: AuthService = Depends()\n):\n    \"\"\"\n    Dependency to extract and verify JWT token.\n\n    Usage:\n        @get(\"/protected\")\n        async def protected_endpoint(user = Depends(get_current_user)):\n            return {\"user\": user[\"username\"]}\n    \"\"\"\n    token = credentials.credentials\n    payload = auth_service.decode_token(token)\n\n    if payload is None:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid authentication credentials\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n    return payload\n\n\nasync def require_role(required_role: str):\n    \"\"\"\n    Dependency factory for role-based access control.\n\n    Usage:\n        @get(\"/admin\")\n        async def admin_endpoint(user = Depends(require_role(\"admin\"))):\n            return {\"message\": \"Admin only\"}\n    \"\"\"\n    async def role_checker(user = Depends(get_current_user)):\n        user_roles = user.get(\"roles\", [])\n        if required_role not in user_roles:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=f\"Role '{required_role}' required\"\n            )\n        return user\n\n    return role_checker\n</code></pre>"},{"location":"tutorials/mario-pizzeria-07-auth/#step-4-use-in-controllers","title":"Step 4: Use in Controllers","text":"<pre><code>from fastapi import Depends\nfrom api.dependencies.auth import get_current_user, require_role\n\nclass OrdersController(ControllerBase):\n\n    @get(\n        \"/{order_id}\",\n        response_model=OrderDto,\n        dependencies=[Depends(get_current_user)]  # Requires authentication\n    )\n    async def get_order(self, order_id: str):\n        \"\"\"Protected endpoint - requires valid JWT\"\"\"\n        query = GetOrderByIdQuery(order_id=order_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @delete(\n        \"/{order_id}\",\n        dependencies=[Depends(require_role(\"admin\"))]  # Requires admin role\n    )\n    async def delete_order(self, order_id: str):\n        \"\"\"Admin-only endpoint\"\"\"\n        # Only admins can delete orders\n        pass\n</code></pre>"},{"location":"tutorials/mario-pizzeria-07-auth/#keycloak-integration-for-web-ui","title":"\ud83d\udd11 Keycloak Integration for Web UI","text":""},{"location":"tutorials/mario-pizzeria-07-auth/#step-1-run-keycloak","title":"Step 1: Run Keycloak","text":"<pre><code># Using Docker\ndocker run -d \\\n  -p 8081:8080 \\\n  -e KEYCLOAK_ADMIN=admin \\\n  -e KEYCLOAK_ADMIN_PASSWORD=admin \\\n  quay.io/keycloak/keycloak:latest \\\n  start-dev\n</code></pre> <p>Access Keycloak admin: http://localhost:8081</p>"},{"location":"tutorials/mario-pizzeria-07-auth/#step-2-configure-keycloak-realm","title":"Step 2: Configure Keycloak Realm","text":"<ol> <li>Create realm: <code>mario-pizzeria</code></li> <li>Create client: <code>mario-pizzeria-web</code></li> <li>Create roles: <code>customer</code>, <code>staff</code>, <code>chef</code>, <code>admin</code></li> <li>Create test users with roles</li> </ol>"},{"location":"tutorials/mario-pizzeria-07-auth/#step-3-install-keycloak-client","title":"Step 3: Install Keycloak Client","text":"<pre><code>poetry add python-keycloak\n</code></pre>"},{"location":"tutorials/mario-pizzeria-07-auth/#step-4-keycloak-authentication-flow","title":"Step 4: Keycloak Authentication Flow","text":"<p>Create <code>ui/middleware/keycloak_middleware.py</code>:</p> <pre><code>\"\"\"Keycloak authentication middleware\"\"\"\nfrom starlette.middleware.sessions import SessionMiddleware\nfrom starlette.requests import Request\nfrom fastapi import HTTPException, status\n\n\nasync def require_keycloak_auth(request: Request):\n    \"\"\"\n    Middleware to enforce Keycloak authentication.\n\n    Checks if user is authenticated via session.\n    Redirects to Keycloak login if not.\n    \"\"\"\n    user_id = request.session.get(\"user_id\")\n    authenticated = request.session.get(\"authenticated\", False)\n\n    if not authenticated or not user_id:\n        # Redirect to Keycloak login\n        raise HTTPException(\n            status_code=status.HTTP_302_FOUND,\n            headers={\"Location\": \"/auth/login\"}\n        )\n\n    return user_id\n</code></pre>"},{"location":"tutorials/mario-pizzeria-07-auth/#step-5-session-configuration","title":"Step 5: Session Configuration","text":"<p>In <code>main.py</code>:</p> <pre><code>from starlette.middleware.sessions import SessionMiddleware\n\n# UI sub-app with session support\nbuilder.add_sub_app(\n    SubAppConfig(\n        path=\"/\",\n        name=\"ui\",\n        title=\"Mario's Pizzeria UI\",\n        middleware=[\n            (\n                SessionMiddleware,\n                {\n                    \"secret_key\": \"your-secret-key\",\n                    \"session_cookie\": \"mario_session\",\n                    \"max_age\": 3600,  # 1 hour\n                    \"same_site\": \"lax\",\n                    \"https_only\": False  # Set True in production\n                }\n            )\n        ],\n        controllers=[\"ui.controllers\"],\n    )\n)\n</code></pre>"},{"location":"tutorials/mario-pizzeria-07-auth/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ol> <li>JWT for APIs: Stateless authentication for external clients</li> <li>Keycloak for Web: SSO with centralized user management</li> <li>RBAC: Role-based access control with dependencies</li> <li>Session vs Token: Sessions for web UI, tokens for API</li> <li>Security: Always use HTTPS in production, rotate secrets</li> </ol>"},{"location":"tutorials/mario-pizzeria-07-auth/#whats-next","title":"\ud83d\ude80 What's Next?","text":"<p>In Part 8: Observability, you'll learn:</p> <ul> <li>OpenTelemetry integration</li> <li>Distributed tracing</li> <li>Metrics and monitoring</li> <li>Logging best practices</li> </ul> <p>Previous: \u2190 Part 6: Persistence | Next: Part 8: Observability \u2192</p>"},{"location":"tutorials/mario-pizzeria-08-observability/","title":"Part 8: Observability &amp; Tracing","text":"<p>Time: 30 minutes | Prerequisites: Part 7</p> <p>In this tutorial, you'll add observability to your application using OpenTelemetry. You'll learn how Neuroglia provides automatic tracing for CQRS operations and how to add custom instrumentation.</p>"},{"location":"tutorials/mario-pizzeria-08-observability/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>OpenTelemetry basics (traces, spans, metrics)</li> <li>Automatic CQRS tracing in Neuroglia</li> <li>Custom instrumentation for business operations</li> <li>Distributed tracing across services</li> <li>Observability stack (Jaeger, Prometheus, Grafana)</li> </ul>"},{"location":"tutorials/mario-pizzeria-08-observability/#understanding-observability","title":"\ud83d\udcca Understanding Observability","text":"<p>Observability answers: \"What is my system doing right now?\"</p>"},{"location":"tutorials/mario-pizzeria-08-observability/#the-three-pillars","title":"The Three Pillars","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Traces    \u2502  \u2502   Metrics   \u2502  \u2502    Logs     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Request flow\u2502  \u2502 Counters    \u2502  \u2502 Event records\u2502\n\u2502 Performance \u2502  \u2502 Gauges      \u2502  \u2502 Errors      \u2502\n\u2502 Dependencies\u2502  \u2502 Histograms  \u2502  \u2502 Debug info  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Traces: Show request flow through services Metrics: Aggregate statistics (requests/sec, latency) Logs: Detailed event records</p>"},{"location":"tutorials/mario-pizzeria-08-observability/#automatic-cqrs-tracing","title":"\ud83d\udd0d Automatic CQRS Tracing","text":"<p>Neuroglia automatically traces all CQRS operations!</p>"},{"location":"tutorials/mario-pizzeria-08-observability/#what-you-get-for-free","title":"What You Get For Free","text":"<p>Every command/query execution creates spans:</p> <pre><code>\ud83c\udf55 Place Order Request\n\u251c\u2500\u2500 PlaceOrderCommand (handler execution)\n\u2502   \u251c\u2500\u2500 MongoCustomerRepository.get_async\n\u2502   \u251c\u2500\u2500 Order.add_order_item (domain operation)\n\u2502   \u251c\u2500\u2500 Order.confirm_order (domain operation)\n\u2502   \u251c\u2500\u2500 MongoOrderRepository.add_async\n\u2502   \u2514\u2500\u2500 Event: OrderConfirmedEvent\n\u2514\u2500\u2500 Response: OrderDto\n</code></pre> <p>Automatically captured:</p> <ul> <li>Command/query name and type</li> <li>Handler execution time</li> <li>Repository operations</li> <li>Domain events published</li> <li>Errors and exceptions</li> </ul>"},{"location":"tutorials/mario-pizzeria-08-observability/#enable-observability","title":"Enable Observability","text":"<p>In <code>main.py</code>:</p> <pre><code>from neuroglia.observability import Observability\n\ndef create_pizzeria_app():\n    builder = WebApplicationBuilder()\n\n    # ... other configuration ...\n\n    # Configure observability (BEFORE building app)\n    Observability.configure(builder)\n\n    app = builder.build_app_with_lifespan(...)\n    return app\n</code></pre> <p>That's it! All CQRS operations are now traced.</p>"},{"location":"tutorials/mario-pizzeria-08-observability/#environment-configuration","title":"Environment Configuration","text":"<p>Create <code>observability/otel-collector-config.yaml</code>:</p> <pre><code>receivers:\n  otlp:\n    protocols:\n      grpc:\n        endpoint: 0.0.0.0:4317\n      http:\n        endpoint: 0.0.0.0:4318\n\nprocessors:\n  batch:\n    timeout: 1s\n    send_batch_size: 1024\n\nexporters:\n  jaeger:\n    endpoint: jaeger:14250\n    tls:\n      insecure: true\n\n  prometheus:\n    endpoint: 0.0.0.0:8889\n\nservice:\n  pipelines:\n    traces:\n      receivers: [otlp]\n      processors: [batch]\n      exporters: [jaeger]\n\n    metrics:\n      receivers: [otlp]\n      processors: [batch]\n      exporters: [prometheus]\n</code></pre>"},{"location":"tutorials/mario-pizzeria-08-observability/#custom-instrumentation","title":"\ud83c\udfa8 Custom Instrumentation","text":"<p>Add custom spans for business operations:</p>"},{"location":"tutorials/mario-pizzeria-08-observability/#step-1-install-opentelemetry","title":"Step 1: Install OpenTelemetry","text":"<pre><code>poetry add opentelemetry-api opentelemetry-sdk\npoetry add opentelemetry-instrumentation-fastapi\n</code></pre>"},{"location":"tutorials/mario-pizzeria-08-observability/#step-2-add-custom-spans","title":"Step 2: Add Custom Spans","text":"<pre><code>from neuroglia.observability.tracing import add_span_attributes\nfrom opentelemetry import trace\n\ntracer = trace.get_tracer(__name__)\n\n\nclass PlaceOrderCommandHandler(CommandHandler):\n\n    async def handle_async(self, command: PlaceOrderCommand):\n        # Add business context to automatic span\n        add_span_attributes({\n            \"order.customer_name\": command.customer_name,\n            \"order.pizza_count\": len(command.pizzas),\n            \"order.payment_method\": command.payment_method,\n        })\n\n        # Create custom span for business logic\n        with tracer.start_as_current_span(\"calculate_order_total\") as span:\n            total = self._calculate_total(command.pizzas)\n            span.set_attribute(\"order.total_amount\", float(total))\n\n        # Automatic tracing continues...\n        order = Order(command.customer_id)\n        # ...\n</code></pre>"},{"location":"tutorials/mario-pizzeria-08-observability/#step-3-trace-repository-operations","title":"Step 3: Trace Repository Operations","text":"<p>Repository operations are automatically traced:</p> <pre><code>class MongoOrderRepository(MotorRepository):\n\n    async def find_by_status_async(self, status: str):\n        # Automatic span: \"MongoOrderRepository.find_by_status_async\"\n        # Captures: status parameter, execution time, result count\n\n        orders = await self.find_async({\"status\": status})\n        return orders\n</code></pre> <p>What's traced:</p> <ul> <li>Method name and class</li> <li>Parameters (customer_id, status, etc.)</li> <li>Execution time</li> <li>Result count</li> <li>Errors/exceptions</li> </ul>"},{"location":"tutorials/mario-pizzeria-08-observability/#custom-metrics","title":"\ud83d\udcc8 Custom Metrics","text":"<p>Track business metrics:</p>"},{"location":"tutorials/mario-pizzeria-08-observability/#step-1-define-metrics","title":"Step 1: Define Metrics","text":"<p>Create <code>observability/metrics.py</code>:</p> <pre><code>\"\"\"Business metrics for Mario's Pizzeria\"\"\"\nfrom opentelemetry import metrics\n\nmeter = metrics.get_meter(__name__)\n\n# Counters\norders_created = meter.create_counter(\n    name=\"mario.orders.created\",\n    description=\"Total orders created\",\n    unit=\"1\"\n)\n\norders_completed = meter.create_counter(\n    name=\"mario.orders.completed\",\n    description=\"Total orders completed\",\n    unit=\"1\"\n)\n\n# Histograms\norder_value = meter.create_histogram(\n    name=\"mario.order.value\",\n    description=\"Order value distribution\",\n    unit=\"USD\"\n)\n\ncooking_time = meter.create_histogram(\n    name=\"mario.cooking.time\",\n    description=\"Time to cook orders\",\n    unit=\"seconds\"\n)\n\n# Gauges (via callback)\ndef get_active_orders():\n    # Query database for active count\n    return 42\n\nactive_orders = meter.create_observable_gauge(\n    name=\"mario.orders.active\",\n    description=\"Current active orders\",\n    callbacks=[lambda options: get_active_orders()],\n    unit=\"1\"\n)\n</code></pre>"},{"location":"tutorials/mario-pizzeria-08-observability/#step-2-record-metrics","title":"Step 2: Record Metrics","text":"<p>In handlers:</p> <pre><code>from observability.metrics import orders_created, order_value\n\nclass PlaceOrderCommandHandler(CommandHandler):\n\n    async def handle_async(self, command: PlaceOrderCommand):\n        # ... create order ...\n\n        # Record metrics\n        orders_created.add(\n            1,\n            {\n                \"payment_method\": command.payment_method,\n                \"customer_type\": \"new\" if new_customer else \"returning\"\n            }\n        )\n\n        order_value.record(\n            float(order.total_amount),\n            {\"payment_method\": command.payment_method}\n        )\n\n        return self.created(order_dto)\n</code></pre>"},{"location":"tutorials/mario-pizzeria-08-observability/#observability-stack-with-docker","title":"\ud83d\udc33 Observability Stack with Docker","text":"<p>Create <code>docker-compose.observability.yml</code>:</p> <pre><code>version: \"3.8\"\n\nservices:\n  # OpenTelemetry Collector\n  otel-collector:\n    image: otel/opentelemetry-collector:latest\n    command: [\"--config=/etc/otel-collector-config.yaml\"]\n    volumes:\n      - ./observability/otel-collector-config.yaml:/etc/otel-collector-config.yaml\n    ports:\n      - \"4317:4317\" # OTLP gRPC\n      - \"4318:4318\" # OTLP HTTP\n      - \"8889:8889\" # Prometheus metrics\n\n  # Jaeger (Tracing UI)\n  jaeger:\n    image: jaegertracing/all-in-one:latest\n    ports:\n      - \"16686:16686\" # Jaeger UI\n      - \"14250:14250\" # Collector\n    environment:\n      - COLLECTOR_OTLP_ENABLED=true\n\n  # Prometheus (Metrics)\n  prometheus:\n    image: prom/prometheus:latest\n    volumes:\n      - ./observability/prometheus.yml:/etc/prometheus/prometheus.yml\n    ports:\n      - \"9090:9090\"\n    command:\n      - \"--config.file=/etc/prometheus/prometheus.yml\"\n\n  # Grafana (Dashboards)\n  grafana:\n    image: grafana/grafana:latest\n    ports:\n      - \"3000:3000\"\n    environment:\n      - GF_SECURITY_ADMIN_PASSWORD=admin\n    volumes:\n      - ./observability/grafana/dashboards:/etc/grafana/provisioning/dashboards\n      - ./observability/grafana/datasources:/etc/grafana/provisioning/datasources\n</code></pre>"},{"location":"tutorials/mario-pizzeria-08-observability/#start-observability-stack","title":"Start Observability Stack","text":"<pre><code># Start services\ndocker-compose -f docker-compose.observability.yml up -d\n\n# Access UIs\n# Jaeger: http://localhost:16686\n# Prometheus: http://localhost:9090\n# Grafana: http://localhost:3000 (admin/admin)\n</code></pre>"},{"location":"tutorials/mario-pizzeria-08-observability/#viewing-traces","title":"\ud83d\udd0d Viewing Traces","text":""},{"location":"tutorials/mario-pizzeria-08-observability/#in-jaeger","title":"In Jaeger","text":"<ol> <li>Open http://localhost:16686</li> <li>Select service: <code>mario-pizzeria</code></li> <li>Click \"Find Traces\"</li> <li>Click on a trace to see:</li> <li>Complete request flow</li> <li>Each handler/repository call</li> <li>Timing breakdown</li> <li>Errors and exceptions</li> </ol>"},{"location":"tutorials/mario-pizzeria-08-observability/#example-trace","title":"Example Trace","text":"<pre><code>PlaceOrderCommand [200ms]\n\u251c\u2500 GetOrCreateCustomer [50ms]\n\u2502  \u2514\u2500 MongoCustomerRepository.find_by_phone [45ms]\n\u251c\u2500 Order.add_order_item [5ms]\n\u251c\u2500 Order.confirm_order [2ms]\n\u251c\u2500 MongoOrderRepository.add_async [80ms]\n\u2514\u2500 DomainEventDispatch [60ms]\n   \u2514\u2500 OrderConfirmedEvent [55ms]\n      \u251c\u2500 SendSMS [30ms]\n      \u2514\u2500 NotifyKitchen [20ms]\n</code></pre>"},{"location":"tutorials/mario-pizzeria-08-observability/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ol> <li>Automatic Tracing: Neuroglia traces all CQRS operations</li> <li>Custom Spans: Add business context with <code>add_span_attributes</code></li> <li>Business Metrics: Track orders, revenue, performance</li> <li>OpenTelemetry: Standard observability protocol</li> <li>Jaeger UI: Visualize distributed traces</li> <li>Production Ready: Export to Datadog, New Relic, etc.</li> </ol>"},{"location":"tutorials/mario-pizzeria-08-observability/#whats-next","title":"\ud83d\ude80 What's Next?","text":"<p>In Part 9: Deployment, you'll learn:</p> <ul> <li>Docker containerization</li> <li>Docker Compose orchestration</li> <li>Production configuration</li> <li>Scaling considerations</li> </ul> <p>Previous: \u2190 Part 7: Authentication | Next: Part 9: Deployment \u2192</p>"},{"location":"tutorials/mario-pizzeria-09-deployment/","title":"Part 9: Deployment &amp; Production","text":"<p>Time: 30 minutes | Prerequisites: Part 8</p> <p>In this final tutorial, you'll learn how to containerize and deploy Mario's Pizzeria. You'll create Docker images, orchestrate services with Docker Compose, and configure for production.</p>"},{"location":"tutorials/mario-pizzeria-09-deployment/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>Docker containerization for Python apps</li> <li>Multi-service orchestration with Docker Compose</li> <li>Production configuration and secrets</li> <li>Scaling and performance considerations</li> <li>Deployment best practices</li> </ul>"},{"location":"tutorials/mario-pizzeria-09-deployment/#containerizing-the-application","title":"\ud83d\udc33 Containerizing the Application","text":""},{"location":"tutorials/mario-pizzeria-09-deployment/#step-1-create-dockerfile","title":"Step 1: Create Dockerfile","text":"<p>Create <code>Dockerfile</code>:</p> <pre><code># Multi-stage build for smaller images\nFROM python:3.11-slim as builder\n\n# Install Poetry\nRUN pip install poetry\n\n# Set working directory\nWORKDIR /app\n\n# Copy dependency files\nCOPY pyproject.toml poetry.lock ./\n\n# Install dependencies (without dev dependencies)\nRUN poetry config virtualenvs.create false \\\n    &amp;&amp; poetry install --no-dev --no-interaction --no-ansi\n\n# Final stage\nFROM python:3.11-slim\n\nWORKDIR /app\n\n# Copy installed packages from builder\nCOPY --from=builder /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages\nCOPY --from=builder /usr/local/bin /usr/local/bin\n\n# Copy application code\nCOPY . .\n\n# Set environment variables\nENV PYTHONUNBUFFERED=1\nENV PYTHONPATH=/app\n\n# Expose port\nEXPOSE 8080\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \\\n    CMD python -c \"import requests; requests.get('http://localhost:8080/health')\"\n\n# Run application\nCMD [\"python\", \"main.py\"]\n</code></pre> <p>Key features:</p> <ul> <li>Multi-stage build: Smaller final image</li> <li>Poetry: Dependency management</li> <li>Health check: Container health monitoring</li> <li>Non-root user: Security best practice</li> </ul>"},{"location":"tutorials/mario-pizzeria-09-deployment/#step-2-build-and-test","title":"Step 2: Build and Test","text":"<pre><code># Build image\ndocker build -t mario-pizzeria:latest .\n\n# Run container\ndocker run -d \\\n  -p 8080:8080 \\\n  --name mario-app \\\n  -e MONGODB_URI=mongodb://host.docker.internal:27017 \\\n  mario-pizzeria:latest\n\n# Check logs\ndocker logs -f mario-app\n\n# Test\ncurl http://localhost:8080/health\n</code></pre>"},{"location":"tutorials/mario-pizzeria-09-deployment/#docker-compose-orchestration","title":"\ud83c\udfbc Docker Compose Orchestration","text":""},{"location":"tutorials/mario-pizzeria-09-deployment/#step-1-create-docker-composeyml","title":"Step 1: Create docker-compose.yml","text":"<p>Create <code>docker-compose.yml</code>:</p> <pre><code>version: \"3.8\"\n\nservices:\n  # MongoDB database\n  mongodb:\n    image: mongo:7.0\n    container_name: mario-mongodb\n    ports:\n      - \"27017:27017\"\n    environment:\n      MONGO_INITDB_ROOT_USERNAME: admin\n      MONGO_INITDB_ROOT_PASSWORD_FILE: /run/secrets/db_root_password\n      MONGO_INITDB_DATABASE: mario_pizzeria\n    volumes:\n      - mongodb_data:/data/db\n      - ./deployment/mongo/init-mario-db.js:/docker-entrypoint-initdb.d/init.js:ro\n    secrets:\n      - db_root_password\n    networks:\n      - mario-network\n    healthcheck:\n      test: [\"CMD\", \"mongosh\", \"--eval\", \"db.adminCommand('ping')\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n  # Mario's Pizzeria application\n  mario-app:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    container_name: mario-app\n    ports:\n      - \"8080:8080\"\n    environment:\n      # Database\n      MONGODB_URI: mongodb://admin:password@mongodb:27017\n      MONGODB_DATABASE: mario_pizzeria\n\n      # Application\n      LOG_LEVEL: INFO\n\n      # Observability\n      OTEL_EXPORTER_OTLP_ENDPOINT: http://otel-collector:4318\n      OTEL_SERVICE_NAME: mario-pizzeria\n\n      # Security\n      SESSION_SECRET_KEY_FILE: /run/secrets/session_secret\n    depends_on:\n      mongodb:\n        condition: service_healthy\n      otel-collector:\n        condition: service_started\n    secrets:\n      - session_secret\n    networks:\n      - mario-network\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8080/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n    restart: unless-stopped\n\n  # OpenTelemetry Collector\n  otel-collector:\n    image: otel/opentelemetry-collector:latest\n    container_name: mario-otel-collector\n    command: [\"--config=/etc/otel-collector-config.yaml\"]\n    volumes:\n      - ./deployment/otel/otel-collector-config.yaml:/etc/otel-collector-config.yaml\n    ports:\n      - \"4317:4317\" # OTLP gRPC\n      - \"4318:4318\" # OTLP HTTP\n    networks:\n      - mario-network\n\n  # Jaeger for tracing\n  jaeger:\n    image: jaegertracing/all-in-one:latest\n    container_name: mario-jaeger\n    ports:\n      - \"16686:16686\" # Jaeger UI\n      - \"14250:14250\" # Collector\n    environment:\n      - COLLECTOR_OTLP_ENABLED=true\n    networks:\n      - mario-network\n\n  # Prometheus for metrics\n  prometheus:\n    image: prom/prometheus:latest\n    container_name: mario-prometheus\n    volumes:\n      - ./deployment/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml\n      - prometheus_data:/prometheus\n    ports:\n      - \"9090:9090\"\n    command:\n      - \"--config.file=/etc/prometheus/prometheus.yml\"\n      - \"--storage.tsdb.path=/prometheus\"\n    networks:\n      - mario-network\n\n  # Grafana for dashboards\n  grafana:\n    image: grafana/grafana:latest\n    container_name: mario-grafana\n    ports:\n      - \"3000:3000\"\n    environment:\n      - GF_SECURITY_ADMIN_PASSWORD_FILE=/run/secrets/grafana_admin_password\n    volumes:\n      - ./deployment/grafana/dashboards:/etc/grafana/provisioning/dashboards\n      - ./deployment/grafana/datasources:/etc/grafana/provisioning/datasources\n      - grafana_data:/var/lib/grafana\n    secrets:\n      - grafana_admin_password\n    networks:\n      - mario-network\n    depends_on:\n      - prometheus\n\n# Docker secrets (production: use Docker Swarm or Kubernetes secrets)\nsecrets:\n  db_root_password:\n    file: ./deployment/secrets/db_root_password.txt\n  session_secret:\n    file: ./deployment/secrets/session_secret.txt\n  grafana_admin_password:\n    file: ./deployment/secrets/grafana_admin_password.txt\n\n# Persistent volumes\nvolumes:\n  mongodb_data:\n  prometheus_data:\n  grafana_data:\n\n# Network\nnetworks:\n  mario-network:\n    driver: bridge\n</code></pre>"},{"location":"tutorials/mario-pizzeria-09-deployment/#step-2-create-secrets","title":"Step 2: Create Secrets","text":"<pre><code># Create secrets directory\nmkdir -p deployment/secrets\n\n# Generate secrets\necho \"StrongDatabasePassword123!\" &gt; deployment/secrets/db_root_password.txt\nopenssl rand -base64 32 &gt; deployment/secrets/session_secret.txt\necho \"admin\" &gt; deployment/secrets/grafana_admin_password.txt\n\n# Secure permissions\nchmod 600 deployment/secrets/*\n</code></pre>"},{"location":"tutorials/mario-pizzeria-09-deployment/#step-3-start-all-services","title":"Step 3: Start All Services","text":"<pre><code># Start all services\ndocker-compose up -d\n\n# Check status\ndocker-compose ps\n\n# View logs\ndocker-compose logs -f mario-app\n\n# Stop services\ndocker-compose down\n\n# Stop and remove volumes (clean slate)\ndocker-compose down -v\n</code></pre>"},{"location":"tutorials/mario-pizzeria-09-deployment/#production-configuration","title":"\u2699\ufe0f Production Configuration","text":""},{"location":"tutorials/mario-pizzeria-09-deployment/#environment-variables","title":"Environment Variables","text":"<p>Create <code>.env.production</code>:</p> <pre><code># Database\nMONGODB_URI=mongodb://admin:${DB_PASSWORD}@mongodb-cluster:27017/?replicaSet=rs0\nMONGODB_DATABASE=mario_pizzeria\n\n# Security\nSESSION_SECRET_KEY=${SESSION_SECRET}\nJWT_SECRET_KEY=${JWT_SECRET}\n\n# Keycloak\nKEYCLOAK_SERVER_URL=https://auth.mario-pizzeria.com\nKEYCLOAK_REALM=mario-pizzeria\nKEYCLOAK_CLIENT_ID=mario-pizzeria-api\n\n# Observability\nOTEL_EXPORTER_OTLP_ENDPOINT=https://otel-collector.mario-pizzeria.com:4318\nOTEL_SERVICE_NAME=mario-pizzeria\nOTEL_TRACES_SAMPLER=parentbased_traceidratio\nOTEL_TRACES_SAMPLER_ARG=0.1  # Sample 10% in production\n\n# Application\nLOG_LEVEL=WARNING\nDEBUG=false\nWORKERS=4  # Uvicorn workers\n</code></pre>"},{"location":"tutorials/mario-pizzeria-09-deployment/#production-mainpy","title":"Production main.py","text":"<p>Update for production settings:</p> <pre><code>import os\nfrom neuroglia.hosting.web import WebApplicationBuilder\n\ndef create_pizzeria_app():\n    # Load settings based on environment\n    env = os.getenv(\"ENVIRONMENT\", \"development\")\n\n    if env == \"production\":\n        from application.settings import ProductionSettings\n        settings = ProductionSettings()\n    else:\n        from application.settings import DevelopmentSettings\n        settings = DevelopmentSettings()\n\n    builder = WebApplicationBuilder(settings)\n\n    # ... configuration ...\n\n    app = builder.build_app_with_lifespan(\n        title=\"Mario's Pizzeria\",\n        description=\"Pizza ordering system\",\n        version=\"1.0.0\",\n        debug=(env != \"production\")\n    )\n\n    return app\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    # Production: Multiple workers\n    workers = int(os.getenv(\"WORKERS\", \"1\"))\n\n    uvicorn.run(\n        \"main:app\",\n        host=\"0.0.0.0\",\n        port=8080,\n        workers=workers,\n        log_level=os.getenv(\"LOG_LEVEL\", \"info\").lower(),\n        access_log=True,\n        proxy_headers=True,  # Behind reverse proxy\n        forwarded_allow_ips=\"*\"\n    )\n</code></pre>"},{"location":"tutorials/mario-pizzeria-09-deployment/#scaling-considerations","title":"\ud83d\udcca Scaling Considerations","text":""},{"location":"tutorials/mario-pizzeria-09-deployment/#horizontal-scaling","title":"Horizontal Scaling","text":"<p>Scale app instances:</p> <pre><code># Scale to 3 instances\ndocker-compose up -d --scale mario-app=3\n</code></pre> <p>Add load balancer (nginx):</p> <pre><code># Add to docker-compose.yml\nnginx:\n  image: nginx:latest\n  ports:\n    - \"80:80\"\n    - \"443:443\"\n  volumes:\n    - ./deployment/nginx/nginx.conf:/etc/nginx/nginx.conf\n    - ./deployment/nginx/ssl:/etc/nginx/ssl\n  depends_on:\n    - mario-app\n  networks:\n    - mario-network\n</code></pre>"},{"location":"tutorials/mario-pizzeria-09-deployment/#database-replication","title":"Database Replication","text":"<p>MongoDB replica set:</p> <pre><code>services:\n  mongodb-primary:\n    image: mongo:7.0\n    command: --replSet rs0\n    # ...\n\n  mongodb-secondary:\n    image: mongo:7.0\n    command: --replSet rs0\n    # ...\n</code></pre>"},{"location":"tutorials/mario-pizzeria-09-deployment/#deployment-checklist","title":"\ud83d\ude80 Deployment Checklist","text":"<p>Before Production:</p> <ul> <li>[ ] Set strong secrets (database, JWT, sessions)</li> <li>[ ] Enable HTTPS/TLS</li> <li>[ ] Configure CORS properly</li> <li>[ ] Set up database backups</li> <li>[ ] Configure log rotation</li> <li>[ ] Enable rate limiting</li> <li>[ ] Set up monitoring alerts</li> <li>[ ] Test disaster recovery</li> <li>[ ] Document runbooks</li> <li>[ ] Load test application</li> </ul>"},{"location":"tutorials/mario-pizzeria-09-deployment/#key-takeaways","title":"\ud83d\udcdd Key Takeaways","text":"<ol> <li>Docker: Containerize for consistency</li> <li>Docker Compose: Orchestrate multi-service applications</li> <li>Secrets Management: Never commit secrets to git</li> <li>Health Checks: Monitor container health</li> <li>Observability: Logs, traces, metrics in production</li> <li>Scaling: Horizontal scaling with load balancer</li> <li>Security: HTTPS, secrets, rate limiting</li> </ol>"},{"location":"tutorials/mario-pizzeria-09-deployment/#congratulations","title":"\ud83c\udf89 Congratulations","text":"<p>You've completed the Mario's Pizzeria tutorial series! You now know how to:</p> <p>\u2705 Set up clean architecture projects with Neuroglia \u2705 Model domains with DDD patterns \u2705 Implement CQRS with commands and queries \u2705 Build REST APIs with FastAPI \u2705 Use event-driven architecture \u2705 Persist data with repositories \u2705 Secure applications with auth \u2705 Add observability with OpenTelemetry \u2705 Deploy with Docker</p>"},{"location":"tutorials/mario-pizzeria-09-deployment/#additional-resources","title":"\ud83d\udd17 Additional Resources","text":"<ul> <li>Neuroglia Documentation</li> <li>Core Concepts</li> <li>Feature Guides</li> <li>Pattern Examples</li> <li>Mario's Pizzeria Case Study</li> </ul>"},{"location":"tutorials/mario-pizzeria-09-deployment/#get-help","title":"\ud83d\udcac Get Help","text":"<ul> <li>GitHub Issues: Report bugs or request features</li> <li>Discussions: Ask questions and share ideas</li> </ul> <p>Previous: \u2190 Part 8: Observability | Back to: Tutorial Index</p>"}]}