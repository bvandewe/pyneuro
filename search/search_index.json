{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\ude80 Neuroglia Python Framework","text":"<p>Neuroglia is a lightweight, opinionated framework built on top of FastAPI that provides a comprehensive set of tools and patterns for building clean, maintainable, and scalable microservices. It enforces architectural best practices and provides out-of-the-box implementations of common patterns.</p>"},{"location":"#what-makes-neuroglia-special","title":"\u2728 What Makes Neuroglia Special?","text":"<ul> <li>\ud83c\udfd7\ufe0f Clean Architecture Enforced: Clear separation between API, Application, Domain, and Integration layers</li> <li>\ud83d\udc89 Powerful Dependency Injection: Lightweight container with automatic service discovery</li> <li>\ud83c\udfaf CQRS &amp; Mediation Built-in: Command Query Responsibility Segregation with mediator pattern</li> <li>\ud83d\udce1 Event-Driven by Design: Native CloudEvents, event sourcing, and reactive programming</li> <li>\ud83c\udfaf Resource Oriented Architecture: Declarative resource management with watchers and reconciliation loops</li> <li>\ud83d\udd0c MVC Done Right: Class-based controllers with automatic discovery and OpenAPI generation</li> <li>\ud83d\uddc4\ufe0f Flexible Data Access: Repository pattern with MongoDB, Event Store, and in-memory support</li> <li>\ud83d\udcca Smart Object Mapping: Bidirectional mapping between domain models and DTOs</li> <li>\u26a1 Reactive Programming: Built-in RxPy support for asynchronous event handling</li> </ul>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"<p>Get up and running in minutes:</p> <pre><code># Install Neuroglia\npip install neuroglia\n\n# Create your first app\npython -c \"\nfrom neuroglia.hosting.web import WebApplicationBuilder\n\nbuilder = WebApplicationBuilder()\nbuilder.add_controllers(['api.controllers'])\n\napp = builder.build()\napp.use_controllers()\napp.run()\n\"\n</code></pre> <p>\ud83d\udc49 Get Started Now</p>"},{"location":"#architecture-overview","title":"\ud83c\udfaf Architecture Overview","text":"<p>Neuroglia promotes a clean, layered architecture:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  API Layer                      \u2502  \u2190 Controllers, DTOs, Routes\n\u2502            (FastAPI Integration)                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 Commands &amp; Queries\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Application Layer                  \u2502  \u2190 Handlers, Services, Workflows\n\u2502         (CQRS, Mediation, Use Cases)            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 Domain Operations\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502               Domain Layer                      \u2502  \u2190 Business Logic, Entities, Rules\n\u2502         (Pure Business Logic)                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 Interface Implementation\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            Integration Layer                    \u2502  \u2190 Databases, APIs, Infrastructure\n\u2502      (Repositories, External Services)          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>\ud83d\udcd6 Learn the Architecture</p>"},{"location":"#core-features","title":"\ud83c\udfaa Core Features","text":""},{"location":"#dependency-injection","title":"\ud83d\udc89 Dependency Injection","text":"<p>Powerful, lightweight DI container with automatic service discovery:</p> <pre><code># Automatic registration\nservices.add_scoped(UserService)\nservices.add_singleton(CacheService)\n\n# Constructor injection\nclass UserController(ControllerBase):\n    def __init__(self, user_service: UserService):\n        self.user_service = user_service\n</code></pre> <p>\ud83d\udcd6 Dependency Injection Guide</p>"},{"location":"#cqrs-mediation","title":"\ud83c\udfaf CQRS &amp; Mediation","text":"<p>Clean separation of commands and queries with built-in mediation:</p> <pre><code># Command\n@dataclass\nclass CreateUserCommand(Command[OperationResult[UserDto]]):\n    email: str\n    first_name: str\n\n# Handler\nclass CreateUserHandler(CommandHandler[CreateUserCommand, OperationResult[UserDto]]):\n    async def handle_async(self, command: CreateUserCommand) -&gt; OperationResult[UserDto]:\n        # Business logic here\n        return self.created(user_dto)\n\n# Usage in controller\nresult = await self.mediator.execute_async(command)\n</code></pre> <p>\ud83d\udcd6 CQRS &amp; Mediation Guide</p>"},{"location":"#mvc-controllers","title":"\ud83d\udd0c MVC Controllers","text":"<p>Class-based controllers with automatic discovery and full FastAPI integration:</p> <pre><code>class UsersController(ControllerBase):\n    @post(\"/\", response_model=UserDto, status_code=201)\n    async def create_user(self, user_dto: CreateUserDto) -&gt; UserDto:\n        command = self.mapper.map(user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre> <p>\ud83d\udcd6 MVC Controllers Guide</p>"},{"location":"#event-driven-architecture","title":"\ud83d\udce1 Event-Driven Architecture","text":"<p>Native support for CloudEvents and reactive programming:</p> <pre><code># Domain events\nclass UserCreatedEvent(DomainEvent):\n    user_id: str\n    email: str\n\n# Event handlers\nclass WelcomeEmailHandler(EventHandler[UserCreatedEvent]):\n    async def handle_async(self, event: UserCreatedEvent):\n        await self.email_service.send_welcome(event.email)\n</code></pre> <p>\ud83d\udcd6 Event Handling Guide</p>"},{"location":"#resource-oriented-architecture","title":"\ud83c\udfaf Resource Oriented Architecture","text":"<p>Declarative resource management with watchers, controllers, and reconciliation loops:</p> <pre><code># Resource definition\n@dataclass\nclass LabInstanceResource:\n    spec: Dict[str, Any]      # Desired state\n    status: Dict[str, Any]    # Current state\n\n# Watcher detects changes\nclass LabInstanceWatcher:\n    async def start_watching(self):\n        while self.is_running:\n            changes = self.storage.list_resources(since_version=self.last_version)\n            for resource in changes:\n                await self._handle_resource_change(resource)\n\n# Controller responds with business logic  \nclass LabInstanceController:\n    async def handle_resource_event(self, resource):\n        if resource.status.get('state') == 'pending':\n            await self._start_provisioning(resource)\n\n# Reconciler ensures consistency\nclass LabInstanceScheduler:\n    async def start_reconciliation(self):\n        while self.is_running:\n            await self._reconcile_all_resources()\n            await asyncio.sleep(self.reconcile_interval)\n</code></pre> <p>\ud83d\udcd6 Resource Oriented Architecture Guide</p>"},{"location":"#data-access","title":"\ud83d\uddc4\ufe0f Data Access","text":"<p>Flexible repository pattern with multiple storage backends:</p> <pre><code># Repository interface\nclass IUserRepository(Repository[User, str]):\n    async def get_by_email(self, email: str) -&gt; User:\n        pass\n\n# MongoDB implementation\nclass MongoUserRepository(IUserRepository):\n    # Implementation\n\n# Event sourcing implementation  \nclass EventSourcedUserRepository(IUserRepository):\n    # Implementation\n</code></pre> <p>\ud83d\udcd6 Data Access Guide</p>"},{"location":"#sample-applications","title":"\ud83c\udf93 Sample Applications","text":"<p>Learn by example with complete, production-ready sample applications:</p>"},{"location":"#openbank-event-sourced-banking-system","title":"\ud83c\udfe6 OpenBank - Event-Sourced Banking System","text":"<p>A comprehensive banking domain showcasing:</p> <ul> <li>\u2705 Event sourcing with EventStoreDB</li> <li>\u2705 CQRS with separate read/write models  </li> <li>\u2705 Domain-driven design patterns</li> <li>\u2705 Event-driven architecture</li> <li>\u2705 Clean architecture layers</li> </ul> <p>\ud83d\udc49 Explore OpenBank</p>"},{"location":"#lab-resource-manager-resource-oriented-architecture","title":"\ud83e\uddea Lab Resource Manager - Resource Oriented Architecture","text":"<p>A comprehensive ROA implementation featuring:</p> <ul> <li>\u2705 Declarative resource management patterns</li> <li>\u2705 Watcher pattern for change detection</li> <li>\u2705 Controller pattern for business logic responses</li> <li>\u2705 Reconciliation loops for consistency enforcement</li> <li>\u2705 State machine implementation with lifecycle management</li> <li>\u2705 Asynchronous component coordination</li> </ul> <p>\ud83d\udc49 Explore Lab Resource Manager</p>"},{"location":"#api-gateway-microservice-gateway","title":"\ud83d\udeaa API Gateway - Microservice Gateway","text":"<p>An intelligent API gateway featuring:</p> <ul> <li>\u2705 Request routing and load balancing</li> <li>\u2705 Authentication and authorization</li> <li>\u2705 Rate limiting and caching</li> <li>\u2705 Monitoring and observability</li> </ul> <p>\ud83d\udc49 Explore API Gateway</p>"},{"location":"#desktop-controller-remote-management","title":"\ud83d\udda5\ufe0f Desktop Controller - Remote Management","text":"<p>A desktop management API demonstrating:</p> <ul> <li>\u2705 Background services and scheduling</li> <li>\u2705 Real-time communication</li> <li>\u2705 System integration patterns</li> <li>\u2705 Docker containerization</li> </ul> <p>\ud83d\udc49 Explore Desktop Controller</p>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":""},{"location":"#getting-started","title":"\ud83d\ude80 Getting Started","text":"<ul> <li>Quick Start Guide - Build your first app in 10 minutes</li> <li>Architecture Overview - Understand the framework's design</li> <li>Project Structure - Organize your code properly</li> </ul>"},{"location":"#feature-guides","title":"\ud83c\udfaa Feature Guides","text":"Feature Description Documentation Dependency Injection Service container and automatic registration \ud83d\udcd6 Guide CQRS &amp; Mediation Command/Query separation with mediator \ud83d\udcd6 Guide MVC Controllers Class-based API controllers \ud83d\udcd6 Guide Data Access Repository pattern and persistence \ud83d\udcd6 Guide Event Handling Events, messaging, and reactive programming \ud83d\udcd6 Guide Object Mapping Automatic object-to-object mapping \ud83d\udcd6 Guide Configuration Settings and environment management \ud83d\udcd6 Guide Hosting Web application hosting and lifecycle \ud83d\udcd6 Guide"},{"location":"#requirements","title":"\ud83d\udccb Requirements","text":"<ul> <li>Python 3.11+</li> <li>FastAPI (automatic)</li> <li>Pydantic (automatic)</li> <li>Optional: MongoDB, EventStoreDB, Redis (based on features used)</li> </ul>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions! Here's how you can help:</p> <ul> <li>\ud83d\udc1b Report bugs - Found an issue? Let us know!</li> <li>\ud83d\udca1 Suggest features - Have an idea? We'd love to hear it!</li> <li>\ud83d\udcdd Improve docs - Help make our documentation better</li> <li>\ud83d\udd27 Submit PRs - Code contributions are always welcome</li> </ul> <p>\ud83d\udc49 Contributing Guide</p>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"#why-choose-neuroglia","title":"\ud83c\udf1f Why Choose Neuroglia?","text":"<p>\u2705 Production Ready: Battle-tested patterns and practices \u2705 Developer Friendly: Intuitive APIs and excellent documentation \u2705 Highly Testable: Built with testing in mind from day one \u2705 Scalable: Patterns that grow with your application \u2705 Modern: Leverages the latest Python and FastAPI features \u2705 Flexible: Use only what you need, when you need it  </p> <p>Ready to build something amazing? Get Started Now \ud83d\ude80</p>"},{"location":"#running-background-tasks","title":"Running Background Tasks","text":"<p>Neuroglia integrates with apscheduler for background tasks:</p> <pre><code>from apscheduler.schedulers.asyncio import AsyncIOScheduler\nfrom neuroglia.hosting.abstractions import HostedService\n\nclass BackgroundTaskService(HostedService):\n    def __init__(self):\n        self._scheduler = AsyncIOScheduler()\n\n    async def start_async(self):\n        # Add jobs\n        self._scheduler.add_job(self._process_data, 'interval', minutes=5)\n        self._scheduler.start()\n\n    async def stop_async(self):\n        self._scheduler.shutdown()\n\n    async def _process_data(self):\n        # Task implementation\n        pass\n</code></pre>"},{"location":"#advanced-features","title":"Advanced Features","text":""},{"location":"#real-time-communication-with-cloudevents","title":"Real-time Communication with CloudEvents","text":"<pre><code>from neuroglia.eventing.cloud_events.infrastructure import CloudEventIngestor\nfrom neuroglia.eventing.cloud_events.decorators import cloud_event_handler\n\nclass NotificationService:\n    def __init__(self, event_ingestor: CloudEventIngestor):\n        event_ingestor.subscribe(\"user.created\", self._on_user_created)\n\n    @cloud_event_handler\n    async def _on_user_created(self, event_data):\n        # Process user created event\n        user_id = event_data[\"id\"]\n        # Send notification\n</code></pre>"},{"location":"#custom-repository-implementation","title":"Custom Repository Implementation","text":"<pre><code>from neuroglia.data.infrastructure.abstractions import Repository\n\nclass CustomRepository(Repository[Entity, str]):\n    async def add(self, entity: Entity) -&gt; None:\n        # Custom implementation\n\n    async def update(self, entity: Entity) -&gt; None:\n        # Custom implementation\n\n    async def remove(self, entity: Entity) -&gt; None:\n        # Custom implementation\n\n    async def find_by_id(self, id: str) -&gt; Optional[Entity]:\n        # Custom implementation\n</code></pre>"},{"location":"#samples","title":"Samples","text":""},{"location":"#openbank","title":"OpenBank","text":"<p>Implements a simplified Bank that manages Accounts, Users and Transactions with full Event Sourcing, CQRS</p> <p>Explore OpenBank</p>"},{"location":"#desktop-controller","title":"Desktop Controller","text":"<p>Remotely and securely control custom files or commands on a Desktop running the app as a Docker container...</p> <p>Explore Desktop Controller</p>"},{"location":"#api-gateway","title":"API Gateway","text":"<p>Expose single entry point for 3rd party clients into an internal layer, like a GenAI stack... Models a Prompt entity, enforces a business logic (e.g. Prompt' state-machine), handles scheduled background task (with persistence), exposes API with multiple Security schemes, ...</p> <p>Explore API Gateway</p>"},{"location":"#cisco-remote-output-collector","title":"Cisco Remote Output Collector","text":"<p>Statefull microservice that handles complex and custom HTTP Commands which in turn each encapsulates arbitrary interactions with given Cisco Device(s) via Telnet, such as <code>FindPrompt</code>, <code>CollectCommandLineOutput</code>, <code>AddConfiguration</code>, <code>SaveConfiguration</code>, <code>Ping</code>, <code>Traceroute</code>, <code>ClearNatTranslation</code>, <code>CheckReachability</code>, <code>BounceInterface</code>, <code>RunViaTelnetTo</code>, <code>FindSpanningTreeRoot</code>, ... etc.</p> <p>Explore IOS ROC</p> <p>Current state: functional but simple implemention, 100% stateless collection of multiple CLI to a single device via Telnet.</p> <p>TODO:</p> <ul> <li>[ ] Add Session management (defines a Pod for subsequent scenarios) with persistence</li> <li>[ ] Add DeviceConnection and ConnectionManager</li> <li>[ ] Add DeviceDrivers and PromptPatterns libraries</li> <li>[ ] ...</li> </ul>"},{"location":"#deployment","title":"Deployment","text":""},{"location":"#docker-deployment","title":"Docker Deployment","text":"<p>The framework is designed to work seamlessly with Docker. A typical Dockerfile might look like:</p> <pre><code>FROM python:3.10-slim\n\nWORKDIR /app\n\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\nCOPY . .\n\nEXPOSE 8000\n\nCMD [\"uvicorn\", \"api.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n</code></pre>"},{"location":"#environment-configuration","title":"Environment Configuration","text":"<p>Following the 12-Factor App principles, configuration is stored in environment variables:</p> <pre><code>from neuroglia.hosting.abstractions import ApplicationSettings\nfrom pydantic import BaseSettings\n\nclass MyAppSettings(ApplicationSettings):\n    database_url: str\n    api_key: str\n    debug_mode: bool = False\n</code></pre>"},{"location":"#testing","title":"Testing","text":"<p>The framework supports comprehensive testing with pytest:</p> <pre><code># Example test for a command handler\nasync def test_create_user_command():\n    # Arrange\n    handler = CreateUserCommandHandler(mock_repository)\n    command = CreateUserCommand(\"test\", \"test@example.com\")\n\n    # Act\n    result = await handler.handle(command)\n\n    # Assert\n    assert result is not None\n    assert mock_repository.add.called_once\n</code></pre>"},{"location":"#best-practices","title":"Best Practices","text":"<ol> <li>Keep Domain Models Pure: Domain models should be free of infrastructure concerns</li> <li>Use Commands for State Changes: All state-changing operations should be modeled as commands</li> <li>Use Queries for Reading Data: All data retrieval should be modeled as queries</li> <li>Leverage Dependency Injection: Always use DI to create loosely coupled components</li> <li>Handle Errors with Problem Details: Use the standard ProblemDetails format for error responses</li> <li>Follow Layered Architecture: Maintain clear boundaries between API, Application, Domain, and Integration layers</li> </ol>"},{"location":"#conclusion","title":"Conclusion","text":"<p>The Neuroglia Python Framework provides a comprehensive foundation for building clean, maintainable, and feature-rich microservices. By embracing modern architectural patterns like CQRS, Event Sourcing, and Clean Architecture, it helps developers create applications that are easier to understand, test, and evolve over time.</p> <p>For more information, check out the sample applications or contribute to the framework development.</p>"},{"location":"MERMAID_SETUP/","title":"\ud83c\udfaf Mermaid Diagram Setup Summary","text":""},{"location":"MERMAID_SETUP/#completed-configuration","title":"\u2705 Completed Configuration","text":"<p>The Neuroglia Python Framework documentation now has full Mermaid diagram support configured and tested.</p>"},{"location":"MERMAID_SETUP/#what-was-configured","title":"\ud83d\udccb What Was Configured","text":"<ol> <li>MkDocs Configuration (<code>mkdocs.yml</code>):</li> <li>Added <code>mkdocs-mermaid2-plugin</code> to plugins section</li> <li>Configured <code>pymdownx.superfences</code> with custom Mermaid fence support</li> <li>Added Mermaid theme configuration with auto dark/light mode</li> <li> <p>Set primary colors to match Material theme (#1976d2)</p> </li> <li> <p>Dependencies (<code>pyproject.toml</code>):</p> </li> <li>Added <code>mkdocs-mermaid2-plugin &gt;= 1.1.1</code> dependency</li> <li> <p>Updated Poetry lock file with new dependencies</p> </li> <li> <p>Documentation Files:</p> </li> <li>Created comprehensive Mermaid documentation (<code>docs/features/mermaid-diagrams.md</code>)</li> <li>Added architecture diagram to ROA documentation</li> <li> <p>Updated navigation in <code>mkdocs.yml</code> to include Mermaid documentation</p> </li> <li> <p>Build Tools:</p> </li> <li>Created automated build script (<code>build_docs.sh</code>) with validation</li> <li>Created validation script (<code>validate_mermaid.py</code>) for testing</li> </ol>"},{"location":"MERMAID_SETUP/#technical-details","title":"\ud83d\udd27 Technical Details","text":""},{"location":"MERMAID_SETUP/#mermaid-plugin-configuration","title":"Mermaid Plugin Configuration","text":"<pre><code>plugins:\n  - search\n  - mermaid2:\n      arguments:\n        theme: auto\n        themeVariables:\n          primaryColor: '#1976d2'\n          primaryTextColor: '#ffffff'\n          primaryBorderColor: '#1976d2'\n          lineColor: '#1976d2'\n          secondaryColor: '#f5f5f5'\n          tertiaryColor: '#ffffff'\n</code></pre>"},{"location":"MERMAID_SETUP/#superfences-configuration","title":"Superfences Configuration","text":"<pre><code>markdown_extensions:\n  - pymdownx.superfences:\n      custom_fences:\n        - name: mermaid\n          class: mermaid\n          format: !!python/name:pymdownx.superfences.fence_code_format\n</code></pre>"},{"location":"MERMAID_SETUP/#validation-results","title":"\ud83d\udcca Validation Results","text":"<ul> <li>\u2705 Plugin Loading: Mermaid2 plugin initializes successfully</li> <li>\u2705 JavaScript Library: Uses Mermaid 10.4.0 from unpkg CDN</li> <li>\u2705 Theme Support: Auto theme switching (light/dark mode)</li> <li>\u2705 Diagram Count: Found diagrams in 4 documentation files</li> <li>\u2705 HTML Generation: All 18 generated HTML files contain Mermaid content</li> <li>\u2705 Build Process: Clean builds complete in ~4 seconds</li> </ul>"},{"location":"MERMAID_SETUP/#usage-examples","title":"\ud83d\ude80 Usage Examples","text":""},{"location":"MERMAID_SETUP/#basic-flowchart","title":"Basic Flowchart","text":"<pre><code>```mermaid\ngraph TD\n    A[Start] --&gt; B{Decision}\n    B --&gt;|Yes| C[Action 1]\n    B --&gt;|No| D[Action 2]\n    C --&gt; E[End]\n    D --&gt; E\n```\n</code></pre>"},{"location":"MERMAID_SETUP/#sequence-diagram","title":"Sequence Diagram","text":"<pre><code>```mermaid\nsequenceDiagram\n    participant Client\n    participant API\n    participant Service\n    participant Database\n\n    Client-&gt;&gt;API: Request\n    API-&gt;&gt;Service: Process\n    Service-&gt;&gt;Database: Query\n    Database--&gt;&gt;Service: Data\n    Service--&gt;&gt;API: Result\n    API--&gt;&gt;Client: Response\n```\n</code></pre>"},{"location":"MERMAID_SETUP/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>```mermaid\ngraph TB\n    subgraph \"API Layer\"\n        A[Controllers]\n        B[DTOs]\n    end\n\n    subgraph \"Application Layer\"\n        C[Commands/Queries]\n        D[Handlers]\n    end\n\n    subgraph \"Domain Layer\"\n        E[Entities]\n        F[Value Objects]\n    end\n\n    A --&gt; C\n    C --&gt; D\n    D --&gt; E\n```\n</code></pre>"},{"location":"MERMAID_SETUP/#build-commands","title":"\ud83d\udee0\ufe0f Build Commands","text":""},{"location":"MERMAID_SETUP/#development-server","title":"Development Server","text":"<pre><code>poetry run mkdocs serve\n# Serves on http://127.0.0.1:8000 with live reload\n</code></pre>"},{"location":"MERMAID_SETUP/#production-build","title":"Production Build","text":"<pre><code>./build_docs.sh\n# Automated build with validation and reporting\n</code></pre>"},{"location":"MERMAID_SETUP/#manual-build","title":"Manual Build","text":"<pre><code>poetry run mkdocs build --clean\n# Builds to ./site directory\n</code></pre>"},{"location":"MERMAID_SETUP/#generated-files","title":"\ud83d\udcc1 Generated Files","text":"<p>The documentation build generates: - HTML Files: 18 static HTML files in <code>./site/</code> - Mermaid Content: All diagrams converted to interactive SVG - Theme Support: Automatic dark/light mode switching - Mobile Responsive: Works on all device sizes</p>"},{"location":"MERMAID_SETUP/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Mermaid Diagrams Guide</li> <li>Resource Oriented Architecture (includes Mermaid examples)</li> <li>Sample Applications (various Mermaid diagrams)</li> </ul>"},{"location":"MERMAID_SETUP/#external-resources","title":"\ud83d\udcda External Resources","text":"<ul> <li>Mermaid.js Official Documentation</li> <li>MkDocs Material Theme</li> <li>Mermaid2 Plugin Documentation</li> </ul>"},{"location":"MERMAID_SETUP/#success-confirmation","title":"\ud83c\udf89 Success Confirmation","text":"<p>The setup is fully functional and ready for production use. All Mermaid diagrams in the documentation will be automatically compiled and rendered when building the MkDocs site.</p>"},{"location":"architecture/","title":"\ud83c\udfd7\ufe0f Architecture Guide","text":"<p>Neuroglia implements a clean, layered architecture that promotes separation of concerns, testability, and maintainability. This guide explains the architectural principles and how they're implemented in the framework.</p>"},{"location":"architecture/#architectural-principles","title":"\ud83c\udfaf Architectural Principles","text":""},{"location":"architecture/#1-clean-architecture","title":"1. Clean Architecture","text":"<p>Neuroglia follows Clean Architecture principles:</p> <ul> <li>Dependency Rule: Dependencies always point inward (toward the domain)</li> <li>Independent of Frameworks: Business logic doesn't depend on framework details</li> <li>Testable: Business rules can be tested without external dependencies</li> <li>Independent of UI: The application can work with different interfaces</li> <li>Independent of Database: Business rules aren't bound to a specific database</li> </ul>"},{"location":"architecture/#2-separation-of-concerns","title":"2. Separation of Concerns","text":"<p>Each layer has a specific responsibility and doesn't concern itself with the details of other layers:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 API Layer                        \u2502  \u2190 External Interface\n\u2502            (Controllers, DTOs)                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 depends on\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Application Layer                   \u2502  \u2190 Orchestration\n\u2502         (Commands, Queries, Handlers)           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 depends on\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502               Domain Layer                       \u2502  \u2190 Business Logic\n\u2502            (Entities, Services)                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 implements\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            Integration Layer                     \u2502  \u2190 External Concerns\n\u2502        (Repositories, API Clients)              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#3-inversion-of-control","title":"3. Inversion of Control","text":"<p>The framework uses dependency injection to invert control flow and reduce coupling between components.</p>"},{"location":"architecture/#layer-breakdown","title":"\ud83c\udfe2 Layer Breakdown","text":""},{"location":"architecture/#api-layer-srcapi","title":"\ud83d\udce1 API Layer (<code>src/api/</code>)","text":"<p>Purpose: Defines the external interface of your application</p> <p>Responsibilities:</p> <ul> <li>HTTP endpoints and routing</li> <li>Request/response DTOs</li> <li>Authentication and authorization</li> <li>Input validation</li> <li>OpenAPI documentation</li> </ul> <p>Key Components:</p> <ul> <li>Controllers: Handle HTTP requests and delegate to application layer</li> <li>DTOs: Data Transfer Objects for API contracts</li> <li>Middleware: Cross-cutting concerns like authentication, logging</li> </ul> <p>Example Structure:</p> <pre><code>api/\n\u251c\u2500\u2500 controllers/\n\u2502   \u251c\u2500\u2500 users_controller.py\n\u2502   \u2514\u2500\u2500 orders_controller.py\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 user_dto.py\n\u2502   \u2514\u2500\u2500 order_dto.py\n\u2514\u2500\u2500 middleware/\n    \u251c\u2500\u2500 auth_middleware.py\n    \u2514\u2500\u2500 logging_middleware.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Keep controllers thin - delegate business logic to application layer</li> <li>Use DTOs to define API contracts</li> <li>Validate input at the API boundary</li> <li>Map between DTOs and domain models</li> </ul>"},{"location":"architecture/#application-layer-srcapplication","title":"\ud83d\udcbc Application Layer (<code>src/application/</code>)","text":"<p>Purpose: Orchestrates business workflows and coordinates domain operations</p> <p>Responsibilities:</p> <ul> <li>Command and query handling</li> <li>Business workflow orchestration</li> <li>Transaction management</li> <li>Event publishing</li> <li>Application services</li> </ul> <p>Key Components:</p> <ul> <li>Commands: Represent actions that change state</li> <li>Queries: Represent read operations</li> <li>Handlers: Process commands and queries</li> <li>Services: Application-specific business logic</li> </ul> <p>Example Structure:</p> <pre><code>application/\n\u251c\u2500\u2500 commands/\n\u2502   \u251c\u2500\u2500 create_user_command.py\n\u2502   \u2514\u2500\u2500 update_user_command.py\n\u251c\u2500\u2500 queries/\n\u2502   \u251c\u2500\u2500 get_user_query.py\n\u2502   \u2514\u2500\u2500 list_users_query.py\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 user_service.py\n\u2502   \u2514\u2500\u2500 notification_service.py\n\u2514\u2500\u2500 events/\n    \u251c\u2500\u2500 user_created_event.py\n    \u2514\u2500\u2500 user_updated_event.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Each command/query should have a single responsibility</li> <li>Use the mediator pattern to decouple handlers</li> <li>Keep application services focused on coordination</li> <li>Publish domain events for side effects</li> </ul>"},{"location":"architecture/#domain-layer-srcdomain","title":"\ud83c\udfdb\ufe0f Domain Layer (<code>src/domain/</code>)","text":"<p>Purpose: Contains the core business logic and rules</p> <p>Responsibilities:</p> <ul> <li>Business entities and aggregates</li> <li>Value objects</li> <li>Domain services</li> <li>Business rules and invariants</li> <li>Domain events</li> </ul> <p>Key Components:</p> <ul> <li>Entities: Objects with identity and lifecycle</li> <li>Value Objects: Immutable objects defined by their attributes</li> <li>Aggregates: Consistency boundaries</li> <li>Domain Services: Business logic that doesn't belong to entities</li> </ul> <p>Example Structure:</p> <pre><code>domain/\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 user.py\n\u2502   \u251c\u2500\u2500 order.py\n\u2502   \u2514\u2500\u2500 address.py\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 pricing_service.py\n\u2502   \u2514\u2500\u2500 validation_service.py\n\u2514\u2500\u2500 events/\n    \u251c\u2500\u2500 user_registered.py\n    \u2514\u2500\u2500 order_placed.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Keep domain models rich with behavior</li> <li>Enforce business invariants</li> <li>Use domain events for decoupling</li> <li>Avoid dependencies on infrastructure</li> </ul>"},{"location":"architecture/#integration-layer-srcintegration","title":"\ud83d\udd0c Integration Layer (<code>src/integration/</code>)","text":"<p>Purpose: Handles external integrations and infrastructure concerns</p> <p>Responsibilities:</p> <ul> <li>Database repositories</li> <li>External API clients</li> <li>Message queue integration</li> <li>File system operations</li> <li>Caching</li> </ul> <p>Key Components:</p> <ul> <li>Repositories: Data access implementations</li> <li>API Clients: External service integrations</li> <li>DTOs: External data contracts</li> <li>Infrastructure Services: Technical concerns</li> </ul> <p>Example Structure:</p> <pre><code>integration/\n\u251c\u2500\u2500 repositories/\n\u2502   \u251c\u2500\u2500 user_repository.py\n\u2502   \u2514\u2500\u2500 order_repository.py\n\u251c\u2500\u2500 clients/\n\u2502   \u251c\u2500\u2500 payment_client.py\n\u2502   \u2514\u2500\u2500 email_client.py\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 user_entity.py\n\u2502   \u2514\u2500\u2500 payment_dto.py\n\u2514\u2500\u2500 services/\n    \u251c\u2500\u2500 cache_service.py\n    \u2514\u2500\u2500 file_service.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Implement domain repository interfaces</li> <li>Handle external failures gracefully</li> <li>Use DTOs for external data contracts</li> <li>Isolate infrastructure concerns</li> </ul>"},{"location":"architecture/#data-flow","title":"\ud83d\udd04 Data Flow","text":""},{"location":"architecture/#command-flow-write-operations","title":"Command Flow (Write Operations)","text":"<ol> <li>Controller receives HTTP request with DTO</li> <li>Controller maps DTO to Command and sends to Mediator</li> <li>Mediator routes Command to appropriate Handler</li> <li>Handler loads domain entities via Repository</li> <li>Handler executes business logic on domain entities</li> <li>Handler saves changes via Repository</li> <li>Handler publishes domain events</li> <li>Handler returns result to Controller</li> <li>Controller maps result to DTO and returns HTTP response</li> </ol> <pre><code>HTTP Request \u2192 Controller \u2192 Command \u2192 Handler \u2192 Domain \u2192 Repository \u2192 Database\n                    \u2193           \u2193        \u2193\n               HTTP Response \u2190 DTO \u2190 Result \u2190 Events\n</code></pre>"},{"location":"architecture/#query-flow-read-operations","title":"Query Flow (Read Operations)","text":"<ol> <li>Controller receives HTTP request with parameters</li> <li>Controller creates Query and sends to Mediator</li> <li>Mediator routes Query to appropriate Handler</li> <li>Handler loads data via Repository or Read Model</li> <li>Handler returns data to Controller</li> <li>Controller maps data to DTO and returns HTTP response</li> </ol> <pre><code>HTTP Request \u2192 Controller \u2192 Query \u2192 Handler \u2192 Repository \u2192 Database\n                    \u2193         \u2193       \u2193\n               HTTP Response \u2190 DTO \u2190 Result\n</code></pre>"},{"location":"architecture/#patterns-implemented","title":"\ud83c\udfad Patterns Implemented","text":""},{"location":"architecture/#1-command-query-responsibility-segregation-cqrs","title":"1. Command Query Responsibility Segregation (CQRS)","text":"<p>Separates read and write operations to optimize performance and scalability:</p> <pre><code># Command (Write)\n@dataclass\nclass CreateUserCommand(Command[OperationResult[UserDto]]):\n    email: str\n    first_name: str\n    last_name: str\n\n# Query (Read)\n@dataclass\nclass GetUserQuery(Query[OperationResult[UserDto]]):\n    user_id: str\n</code></pre>"},{"location":"architecture/#2-mediator-pattern","title":"2. Mediator Pattern","text":"<p>Decouples components by routing requests through a central mediator:</p> <pre><code># In controller\nresult = await self.mediator.execute_async(command)\n</code></pre>"},{"location":"architecture/#3-repository-pattern","title":"3. Repository Pattern","text":"<p>Abstracts data access and provides a consistent interface:</p> <pre><code>class UserRepository(Repository[User, str]):\n    async def add_async(self, user: User) -&gt; User:\n        # Implementation details\n        pass\n</code></pre>"},{"location":"architecture/#4-event-sourcing-optional","title":"4. Event Sourcing (Optional)","text":"<p>Stores state changes as events rather than current state:</p> <pre><code>class User(AggregateRoot[str]):\n    def register(self, email: str, name: str):\n        self.apply(UserRegisteredEvent(email, name))\n</code></pre>"},{"location":"architecture/#5-dependency-injection","title":"5. Dependency Injection","text":"<p>Manages object creation and dependencies:</p> <pre><code># Automatic registration\nbuilder.services.add_scoped(UserService)\n\n# Resolution\nuser_service = provider.get_required_service(UserService)\n</code></pre>"},{"location":"architecture/#testing-architecture","title":"\ud83e\uddea Testing Architecture","text":"<p>The layered architecture makes testing straightforward:</p>"},{"location":"architecture/#unit-tests","title":"Unit Tests","text":"<p>Test individual components in isolation:</p> <pre><code>def test_user_registration():\n    # Arrange\n    command = CreateUserCommand(\"test@example.com\", \"John\", \"Doe\")\n    handler = CreateUserCommandHandler(mock_repository)\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n</code></pre>"},{"location":"architecture/#integration-tests","title":"Integration Tests","text":"<p>Test interactions between layers:</p> <pre><code>def test_create_user_endpoint():\n    # Test API \u2192 Application \u2192 Domain integration\n    response = test_client.post(\"/api/v1/users\", json=user_data)\n    assert response.status_code == 201\n</code></pre>"},{"location":"architecture/#architecture-tests","title":"Architecture Tests","text":"<p>Verify architectural constraints:</p> <pre><code>def test_domain_has_no_infrastructure_dependencies():\n    # Ensure domain layer doesn't depend on infrastructure\n    domain_modules = get_domain_modules()\n    for module in domain_modules:\n        assert not has_infrastructure_imports(module)\n</code></pre>"},{"location":"architecture/#benefits","title":"\ud83d\ude80 Benefits","text":""},{"location":"architecture/#maintainability","title":"Maintainability","text":"<ul> <li>Clear boundaries: Each layer has well-defined responsibilities</li> <li>Loose coupling: Changes in one layer don't affect others</li> <li>High cohesion: Related functionality is grouped together</li> </ul>"},{"location":"architecture/#testability","title":"Testability","text":"<ul> <li>Isolated testing: Each layer can be tested independently</li> <li>Mock dependencies: External dependencies can be easily mocked</li> <li>Fast tests: Business logic tests don't require infrastructure</li> </ul>"},{"location":"architecture/#scalability","title":"Scalability","text":"<ul> <li>CQRS: Read and write models can be optimized separately</li> <li>Event-driven: Asynchronous processing for better performance</li> <li>Microservice ready: Clear boundaries make extraction easier</li> </ul>"},{"location":"architecture/#flexibility","title":"Flexibility","text":"<ul> <li>Technology agnostic: Swap implementations without affecting business logic</li> <li>Framework independence: Business logic isn't tied to web framework</li> <li>Future-proof: Architecture adapts to changing requirements</li> </ul>"},{"location":"architecture/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Build your first application</li> <li>Dependency Injection - Managing dependencies</li> <li>CQRS &amp; Mediation - Command and query patterns</li> <li>Data Access - Repository pattern and persistence</li> <li>Event Handling - Event-driven architecture</li> </ul>"},{"location":"getting-started/","title":"\ud83d\ude80 Getting Started with Neuroglia","text":"<p>This guide will help you create your first Neuroglia application from scratch. By the end, you'll have a working REST API with dependency injection, CQRS patterns, and clean architecture.</p>"},{"location":"getting-started/#prerequisites","title":"\ud83d\udccb Prerequisites","text":"<ul> <li>Python 3.11 or higher</li> <li>Basic understanding of FastAPI and async/await patterns</li> <li>Familiarity with dependency injection concepts</li> </ul>"},{"location":"getting-started/#quick-setup","title":"\u26a1 Quick Setup","text":""},{"location":"getting-started/#1-installation","title":"1. Installation","text":"<pre><code># Install from PyPI (when available)\npip install neuroglia\n\n# Or install from source\ngit clone &lt;repository-url&gt;\ncd pyneuro\npip install -e .\n</code></pre>"},{"location":"getting-started/#2-project-structure","title":"2. Project Structure","text":"<p>Create a new project with the following structure:</p> <pre><code>my-app/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 main.py                 # Application entry point\n\u2502   \u251c\u2500\u2500 api/                    # API Layer\n\u2502   \u2502   \u2514\u2500\u2500 controllers/        # REST controllers\n\u2502   \u251c\u2500\u2500 application/            # Application Layer\n\u2502   \u2502   \u251c\u2500\u2500 commands/           # Command handlers\n\u2502   \u2502   \u251c\u2500\u2500 queries/            # Query handlers\n\u2502   \u2502   \u2514\u2500\u2500 services/           # Business services\n\u2502   \u251c\u2500\u2500 domain/                 # Domain Layer\n\u2502   \u2502   \u2514\u2500\u2500 models/             # Domain entities\n\u2502   \u2514\u2500\u2500 integration/            # Integration Layer\n\u2502       \u251c\u2500\u2500 models/             # DTOs and external models\n\u2502       \u2514\u2500\u2500 services/           # External service clients\n\u2514\u2500\u2500 requirements.txt\n</code></pre>"},{"location":"getting-started/#3-create-your-first-application","title":"3. Create Your First Application","text":"<p>main.py - Application entry point:</p> <pre><code>import logging\nfrom neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.mediation.mediator import Mediator\nfrom neuroglia.mapping.mapper import Mapper\nfrom neuroglia.serialization.json import JsonSerializer\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlog = logging.getLogger(__name__)\n\ndef create_app():\n    \"\"\"Create and configure the Neuroglia application\"\"\"\n\n    # Create the application builder\n    builder = WebApplicationBuilder()\n\n    # Configure core services\n    Mapper.configure(builder, [\"application\", \"domain\", \"integration\"])\n    Mediator.configure(builder, [\"application\"])\n    JsonSerializer.configure(builder)\n\n    # Register controllers\n    builder.add_controllers([\"api.controllers\"])\n\n    # Build the application\n    app = builder.build()\n\n    # Configure middleware and routes\n    app.use_controllers()\n\n    return app\n\nif __name__ == \"__main__\":\n    app = create_app()\n    app.run()\n</code></pre>"},{"location":"getting-started/#4-create-a-domain-model","title":"4. Create a Domain Model","text":"<p>domain/models/user.py:</p> <pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Optional\nfrom neuroglia.data.abstractions import Entity\n\n@dataclass\nclass User(Entity[str]):\n    \"\"\"User domain entity\"\"\"\n\n    id: str\n    email: str\n    first_name: str\n    last_name: str\n    is_active: bool = True\n    created_at: Optional[datetime] = None\n\n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.utcnow()\n\n    @property\n    def full_name(self) -&gt; str:\n        \"\"\"Get the user's full name\"\"\"\n        return f\"{self.first_name} {self.last_name}\"\n\n    def deactivate(self):\n        \"\"\"Deactivate the user\"\"\"\n        self.is_active = False\n</code></pre>"},{"location":"getting-started/#5-create-dtos-for-the-api","title":"5. Create DTOs for the API","text":"<p>integration/models/user_dto.py:</p> <pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Optional\n\n@dataclass\nclass UserDto:\n    \"\"\"User data transfer object\"\"\"\n\n    id: str\n    email: str\n    first_name: str\n    last_name: str\n    full_name: str\n    is_active: bool\n    created_at: Optional[datetime] = None\n\n@dataclass\nclass CreateUserDto:\n    \"\"\"DTO for creating a new user\"\"\"\n\n    email: str\n    first_name: str\n    last_name: str\n</code></pre>"},{"location":"getting-started/#6-create-commands-and-queries","title":"6. Create Commands and Queries","text":"<p>application/commands/create_user_command.py:</p> <pre><code>from dataclasses import dataclass\nfrom neuroglia.core.operation_result import OperationResult\nfrom neuroglia.mediation.mediator import Command, CommandHandler\nfrom neuroglia.mapping.mapper import Mapper, map_from\nfrom integration.models.user_dto import CreateUserDto, UserDto\nfrom domain.models.user import User\nimport uuid\n\n@map_from(CreateUserDto)\n@dataclass\nclass CreateUserCommand(Command[OperationResult[UserDto]]):\n    \"\"\"Command to create a new user\"\"\"\n\n    email: str\n    first_name: str\n    last_name: str\n\nclass CreateUserCommandHandler(CommandHandler[CreateUserCommand, OperationResult[UserDto]]):\n    \"\"\"Handler for CreateUserCommand\"\"\"\n\n    def __init__(self, mapper: Mapper):\n        self.mapper = mapper\n        # In a real app, you'd inject a repository here\n        self._users = {}  # Simple in-memory storage for demo\n\n    async def handle_async(self, command: CreateUserCommand) -&gt; OperationResult[UserDto]:\n        # Create the domain entity\n        user = User(\n            id=str(uuid.uuid4()),\n            email=command.email,\n            first_name=command.first_name,\n            last_name=command.last_name\n        )\n\n        # Store the user (in a real app, use a repository)\n        self._users[user.id] = user\n\n        # Map to DTO and return\n        user_dto = self.mapper.map(user, UserDto)\n        return self.created(user_dto)\n</code></pre> <p>application/queries/get_user_query.py:</p> <pre><code>from dataclasses import dataclass\nfrom neuroglia.core.operation_result import OperationResult\nfrom neuroglia.mediation.mediator import Query, QueryHandler\nfrom neuroglia.mapping.mapper import Mapper\nfrom integration.models.user_dto import UserDto\nfrom typing import Optional\n\n@dataclass\nclass GetUserQuery(Query[OperationResult[UserDto]]):\n    \"\"\"Query to get a user by ID\"\"\"\n\n    user_id: str\n\nclass GetUserQueryHandler(QueryHandler[GetUserQuery, OperationResult[UserDto]]):\n    \"\"\"Handler for GetUserQuery\"\"\"\n\n    def __init__(self, mapper: Mapper):\n        self.mapper = mapper\n        # In a real app, you'd inject a repository here\n        self._users = {}  # Simple in-memory storage for demo\n\n    async def handle_async(self, query: GetUserQuery) -&gt; OperationResult[UserDto]:\n        user = self._users.get(query.user_id)\n\n        if user is None:\n            return self.not_found(f\"User with ID {query.user_id} not found\")\n\n        user_dto = self.mapper.map(user, UserDto)\n        return self.ok(user_dto)\n</code></pre>"},{"location":"getting-started/#7-create-a-controller","title":"7. Create a Controller","text":"<p>api/controllers/users_controller.py:</p> <pre><code>from typing import List\nfrom fastapi import status\nfrom classy_fastapi.decorators import get, post\nfrom neuroglia.mvc.controller_base import ControllerBase\nfrom neuroglia.dependency_injection.service_provider import ServiceProviderBase\nfrom neuroglia.mapping.mapper import Mapper\nfrom neuroglia.mediation.mediator import Mediator\n\nfrom integration.models.user_dto import UserDto, CreateUserDto\nfrom application.commands.create_user_command import CreateUserCommand\nfrom application.queries.get_user_query import GetUserQuery\n\nclass UsersController(ControllerBase):\n    \"\"\"Users API controller\"\"\"\n\n    def __init__(self, service_provider: ServiceProviderBase, mapper: Mapper, mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n    @post(\"/\", response_model=UserDto, status_code=status.HTTP_201_CREATED)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        \"\"\"Create a new user\"\"\"\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @get(\"/{user_id}\", response_model=UserDto)\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        \"\"\"Get a user by ID\"\"\"\n        query = GetUserQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"getting-started/#8-configure-object-mapping","title":"8. Configure Object Mapping","text":"<p>Add mapping profiles to configure how objects are mapped between layers:</p> <p>application/mapping/user_mapping.py:</p> <pre><code>from neuroglia.mapping.mapper import Mapper\nfrom domain.models.user import User\nfrom integration.models.user_dto import UserDto\n\ndef configure_user_mapping():\n    \"\"\"Configure mapping between User and UserDto\"\"\"\n\n    # Map from User entity to UserDto\n    Mapper.create_map(User, UserDto).add_member_mapping(\n        lambda src: src.full_name, lambda dst: dst.full_name\n    )\n\n    # Map from UserDto back to User (if needed)\n    Mapper.create_map(UserDto, User)\n\n# Auto-configure when module is imported\nconfigure_user_mapping()\n</code></pre>"},{"location":"getting-started/#9-run-your-application","title":"9. Run Your Application","text":"<pre><code>cd my-app\npython src/main.py\n</code></pre> <p>Your API will be available at:</p> <ul> <li>API Documentation: http://localhost:8000/api/docs</li> <li>Create User: <code>POST http://localhost:8000/api/v1/users/</code></li> <li>Get User: <code>GET http://localhost:8000/api/v1/users/{user_id}</code></li> </ul>"},{"location":"getting-started/#testing-your-api","title":"\ud83e\uddea Testing Your API","text":"<p>Use curl or any HTTP client to test your endpoints:</p> <pre><code># Create a user\ncurl -X POST \"http://localhost:8000/api/v1/users/\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"email\": \"john.doe@example.com\",\n    \"first_name\": \"John\",\n    \"last_name\": \"Doe\"\n  }'\n\n# Get the user (replace {user_id} with the ID from the response above)\ncurl \"http://localhost:8000/api/v1/users/{user_id}\"\n</code></pre>"},{"location":"getting-started/#what-youve-learned","title":"\ud83c\udfaf What You've Learned","text":"<p>Congratulations! You've created a complete Neuroglia application that demonstrates:</p> <p>\u2705 Clean Architecture: Separation of concerns across layers \u2705 Dependency Injection: Automatic service registration and resolution \u2705 CQRS Pattern: Commands for writes, queries for reads \u2705 Object Mapping: Automatic mapping between domain models and DTOs \u2705 MVC Controllers: Clean REST API endpoints \u2705 Mediation: Decoupled request handling  </p>"},{"location":"getting-started/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<p>Now that you have a basic application running, explore these advanced features:</p> <ul> <li>Data Access: Add real repositories with MongoDB or Event Store</li> <li>Event Handling: Implement event-driven architecture with CloudEvents</li> <li>Authentication: Add security to your APIs</li> <li>Background Tasks: Process long-running tasks</li> <li>Testing: Write comprehensive tests for your application</li> </ul>"},{"location":"getting-started/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Architecture Guide - Deep dive into the framework's architecture</li> <li>Dependency Injection - Advanced DI patterns</li> <li>CQRS &amp; Mediation - Command and query patterns</li> <li>Sample Applications - Complete example applications</li> </ul>"},{"location":"test-mermaid/","title":"Mermaid Test Page","text":"<p>This page tests Mermaid diagram rendering in MkDocs.</p>"},{"location":"test-mermaid/#basic-flowchart","title":"Basic Flowchart","text":"<pre><code>graph TD\n    A[Start] --&gt; B{Is it working?}\n    B --&gt;|Yes| C[Great!]\n    B --&gt;|No| D[Debug]\n    D --&gt; A\n    C --&gt; E[End]</code></pre>"},{"location":"test-mermaid/#sequence-diagram","title":"Sequence Diagram","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Controller\n    participant Service\n    participant Database\n\n    User-&gt;&gt;Controller: HTTP Request\n    Controller-&gt;&gt;Service: Business Logic\n    Service-&gt;&gt;Database: Query Data\n    Database--&gt;&gt;Service: Result\n    Service--&gt;&gt;Controller: Response\n    Controller--&gt;&gt;User: HTTP Response</code></pre>"},{"location":"test-mermaid/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>graph TB\n    subgraph \"Application Layer\"\n        A[Controllers] --&gt; B[Mediator]\n        B --&gt; C[Command Handlers]\n        B --&gt; D[Query Handlers]\n    end\n\n    subgraph \"Domain Layer\"\n        E[Entities] --&gt; F[Value Objects]\n        E --&gt; G[Domain Events]\n    end\n\n    subgraph \"Integration Layer\"\n        H[Repositories] --&gt; I[External APIs]\n        H --&gt; J[Database]\n    end\n\n    C --&gt; E\n    D --&gt; H\n    A --&gt; B</code></pre>"},{"location":"test-mermaid/#class-diagram","title":"Class Diagram","text":"<pre><code>classDiagram\n    class Controller {\n        +service_provider: ServiceProvider\n        +mediator: Mediator\n        +mapper: Mapper\n        +process(result: OperationResult): Response\n    }\n\n    class CommandHandler {\n        +handle_async(command: Command): OperationResult\n    }\n\n    class QueryHandler {\n        +handle_async(query: Query): Result\n    }\n\n    Controller --&gt; CommandHandler : uses\n    Controller --&gt; QueryHandler : uses\n    CommandHandler --&gt; Entity : creates/modifies\n    QueryHandler --&gt; Repository : reads from</code></pre>"},{"location":"features/DOCUMENTATION_UPDATES/","title":"\ud83d\udcdd Documentation Updates Summary","text":""},{"location":"features/DOCUMENTATION_UPDATES/#new-roa-features-added-to-main-readmemd","title":"New ROA Features Added to Main README.md","text":""},{"location":"features/DOCUMENTATION_UPDATES/#key-features-section","title":"\ud83d\ude80 Key Features Section","text":"<ul> <li>Added Resource Oriented Architecture to the key features list</li> <li>Positioned ROA alongside other core features like CQRS, Event-Driven Architecture, etc.</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#documentation-links-section","title":"\ud83d\udcda Documentation Links Section","text":"<ul> <li>Added link to Resource Oriented Architecture documentation</li> <li>Positioned in logical order with other architectural features</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#sample-applications-section","title":"\ud83d\udccb Sample Applications Section","text":"<ul> <li>Added Lab Resource Manager sample with ROA demonstration</li> <li>Includes brief description highlighting key ROA patterns</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#framework-components-table","title":"\ud83c\udfd7\ufe0f Framework Components Table","text":"<ul> <li>Added Resource Oriented Architecture component entry</li> <li>Links to comprehensive ROA documentation</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#new-documentation-files-created","title":"New Documentation Files Created","text":""},{"location":"features/DOCUMENTATION_UPDATES/#1-docsfeaturesresource-oriented-architecturemd","title":"1. <code>docs/features/resource-oriented-architecture.md</code>","text":"<p>Comprehensive ROA feature documentation covering: - Overview of ROA concepts and benefits - Core components: Resources, Watchers, Controllers, Reconcilers - Key patterns: Declarative state, event-driven processing, state machines - Execution model: timing, coordination, concurrent processing - Safety and reliability: timeouts, error recovery, drift detection - Observability: metrics, logging, resource versioning - Configuration and scaling considerations - Use cases and related documentation links</p>"},{"location":"features/DOCUMENTATION_UPDATES/#2-docssampleslab-resource-managermd","title":"2. <code>docs/samples/lab-resource-manager.md</code>","text":"<p>Complete sample application documentation covering: - What developers will learn from the sample - Detailed architecture diagrams - Domain model with LabInstance resources - Component implementation details (Watcher, Controller, Reconciler) - Execution flow explanations - Running instructions with multiple demo options - Key implementation details and design patterns - Configuration options and testing guidance - Next steps for extending the sample</p>"},{"location":"features/DOCUMENTATION_UPDATES/#3-updates-to-docsindexmd","title":"3. Updates to <code>docs/index.md</code>","text":"<p>Enhanced main documentation index with: - ROA added to \"What Makes Neuroglia Special\" features list - New ROA section in Core Features with code examples - Lab Resource Manager added to Sample Applications section</p>"},{"location":"features/DOCUMENTATION_UPDATES/#4-updates-to-mkdocsyml","title":"4. Updates to <code>mkdocs.yml</code>","text":"<p>Enhanced navigation structure with: - Resource Oriented Architecture in Features section - Watcher &amp; Reconciliation Patterns documentation links - Watcher &amp; Reconciliation Execution documentation links - Lab Resource Manager in Sample Applications section</p>"},{"location":"features/DOCUMENTATION_UPDATES/#content-highlights","title":"Content Highlights","text":""},{"location":"features/DOCUMENTATION_UPDATES/#roa-documentation-features","title":"\ud83c\udfaf ROA Documentation Features","text":"<ul> <li>Practical Examples: Real code samples showing patterns in action</li> <li>Architecture Diagrams: Visual representation of component relationships</li> <li>Execution Models: Detailed timing and coordination explanations</li> <li>Safety Mechanisms: Comprehensive error handling and recovery patterns</li> <li>Configuration Guidance: Production-ready tuning recommendations</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#lab-resource-manager-sample-features","title":"\ud83e\uddea Lab Resource Manager Sample Features","text":"<ul> <li>Complete Implementation: Working demonstration with multiple complexity levels</li> <li>Real-time Execution: Live demonstration showing patterns in action</li> <li>Educational Focus: Clear explanations of why and how patterns work</li> <li>Multiple Demo Options: From simple pattern demos to full framework integration</li> <li>Comprehensive Testing: Unit and integration test examples</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#documentation-quality-standards","title":"Documentation Quality Standards","text":""},{"location":"features/DOCUMENTATION_UPDATES/#standards-applied","title":"\u2705 Standards Applied","text":"<ul> <li>Consistent Formatting: Following existing documentation style and emoji usage</li> <li>Cross-References: Proper linking between related documentation sections</li> <li>Code Examples: Working, realistic code samples throughout</li> <li>Progressive Complexity: Simple to advanced examples</li> <li>Practical Focus: Real-world use cases and implementation guidance</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#link-structure","title":"\ud83d\udd17 Link Structure","text":"<ul> <li>Bidirectional Links: Documents reference each other appropriately</li> <li>Logical Navigation: Features \u2192 Samples \u2192 Getting Started flow</li> <li>MkDocs Integration: Proper navigation structure for documentation site</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#impact-on-framework","title":"Impact on Framework","text":""},{"location":"features/DOCUMENTATION_UPDATES/#enhanced-capabilities","title":"\ud83d\udcc8 Enhanced Capabilities","text":"<ul> <li>New Architectural Pattern: ROA adds powerful resource management capabilities</li> <li>Complete Pattern Implementation: Watchers, controllers, and reconcilers working together</li> <li>Real-world Examples: Practical demonstration of complex distributed system patterns</li> <li>Educational Value: Developers can learn advanced patterns through working examples</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#framework-positioning","title":"\ud83c\udfaf Framework Positioning","text":"<ul> <li>Kubernetes-like Patterns: Brings declarative resource management to Python applications</li> <li>Production-Ready: Comprehensive error handling, monitoring, and configuration options</li> <li>Framework Integration: ROA patterns work seamlessly with existing CQRS and DI features</li> </ul> <p>The documentation updates provide comprehensive coverage of the new ROA features while maintaining consistency with existing documentation standards and navigation patterns.</p>"},{"location":"features/cqrs-mediation/","title":"\ud83c\udfaf CQRS &amp; Mediation","text":"<p>Neuroglia implements Command Query Responsibility Segregation (CQRS) through a powerful mediation pattern that decouples your application logic and promotes clean separation between commands (writes) and queries (reads).</p>"},{"location":"features/cqrs-mediation/#overview","title":"\ud83c\udfad Overview","text":"<p>The mediation system provides:</p> <ul> <li>Commands: Operations that modify state</li> <li>Queries: Operations that retrieve data  </li> <li>Events: Notifications of state changes</li> <li>Handlers: Process commands, queries, and events</li> <li>Mediator: Routes requests to appropriate handlers</li> </ul>"},{"location":"features/cqrs-mediation/#core-concepts","title":"\ud83c\udfd7\ufe0f Core Concepts","text":""},{"location":"features/cqrs-mediation/#commands","title":"Commands","text":"<p>Commands represent intentions to change the system state:</p> <pre><code>from dataclasses import dataclass\nfrom neuroglia.mediation.mediator import Command\nfrom neuroglia.core.operation_result import OperationResult\n\n@dataclass\nclass CreateUserCommand(Command[OperationResult[UserDto]]):\n    \"\"\"Command to create a new user\"\"\"\n    email: str\n    first_name: str\n    last_name: str\n    password: str\n\n@dataclass\nclass UpdateUserCommand(Command[OperationResult[UserDto]]):\n    \"\"\"Command to update an existing user\"\"\"\n    user_id: str\n    first_name: str\n    last_name: str\n\n@dataclass\nclass DeactivateUserCommand(Command[OperationResult]):\n    \"\"\"Command to deactivate a user\"\"\"\n    user_id: str\n</code></pre>"},{"location":"features/cqrs-mediation/#queries","title":"Queries","text":"<p>Queries represent requests for data without side effects:</p> <pre><code>from dataclasses import dataclass\nfrom typing import List\nfrom neuroglia.mediation.mediator import Query\n\n@dataclass\nclass GetUserByIdQuery(Query[OperationResult[UserDto]]):\n    \"\"\"Query to get a user by ID\"\"\"\n    user_id: str\n\n@dataclass\nclass GetUsersByDepartmentQuery(Query[OperationResult[List[UserDto]]]):\n    \"\"\"Query to get users by department\"\"\"\n    department_id: str\n    include_inactive: bool = False\n\n@dataclass\nclass SearchUsersQuery(Query[OperationResult[List[UserDto]]]):\n    \"\"\"Query to search users\"\"\"\n    search_term: str\n    page: int = 1\n    page_size: int = 20\n</code></pre>"},{"location":"features/cqrs-mediation/#events","title":"Events","text":"<p>Events represent things that have happened in the system:</p> <pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom neuroglia.data.abstractions import DomainEvent\n\n@dataclass\nclass UserCreatedEvent(DomainEvent):\n    \"\"\"Event raised when a user is created\"\"\"\n    user_id: str\n    email: str\n    created_at: datetime\n\n@dataclass\nclass UserUpdatedEvent(DomainEvent):\n    \"\"\"Event raised when a user is updated\"\"\"\n    user_id: str\n    changes: dict\n    updated_at: datetime\n\n@dataclass\nclass UserDeactivatedEvent(DomainEvent):\n    \"\"\"Event raised when a user is deactivated\"\"\"\n    user_id: str\n    reason: str\n    deactivated_at: datetime\n</code></pre>"},{"location":"features/cqrs-mediation/#handlers","title":"\ud83c\udfaa Handlers","text":""},{"location":"features/cqrs-mediation/#command-handlers","title":"Command Handlers","text":"<p>Process commands and execute business logic:</p> <pre><code>from neuroglia.mediation.mediator import CommandHandler\nfrom neuroglia.mapping.mapper import Mapper\nfrom neuroglia.data.abstractions import Repository\n\nclass CreateUserCommandHandler(CommandHandler[CreateUserCommand, OperationResult[UserDto]]):\n    \"\"\"Handles user creation commands\"\"\"\n\n    def __init__(self, \n                 user_repository: Repository[User, str],\n                 mapper: Mapper,\n                 password_service: IPasswordService,\n                 email_service: IEmailService):\n        self.user_repository = user_repository\n        self.mapper = mapper\n        self.password_service = password_service\n        self.email_service = email_service\n\n    async def handle_async(self, command: CreateUserCommand) -&gt; OperationResult[UserDto]:\n        # Validate business rules\n        existing_user = await self.user_repository.get_by_email_async(command.email)\n        if existing_user:\n            return self.conflict(\"User with this email already exists\")\n\n        # Hash password\n        password_hash = await self.password_service.hash_password(command.password)\n\n        # Create domain entity\n        user = User.create(\n            email=command.email,\n            first_name=command.first_name,\n            last_name=command.last_name,\n            password_hash=password_hash\n        )\n\n        # Save to repository\n        saved_user = await self.user_repository.add_async(user)\n\n        # Send welcome email (side effect)\n        await self.email_service.send_welcome_email(saved_user.email)\n\n        # Map to DTO and return success\n        user_dto = self.mapper.map(saved_user, UserDto)\n        return self.created(user_dto)\n</code></pre>"},{"location":"features/cqrs-mediation/#query-handlers","title":"Query Handlers","text":"<p>Process queries and return data:</p> <pre><code>class GetUserByIdQueryHandler(QueryHandler[GetUserByIdQuery, OperationResult[UserDto]]):\n    \"\"\"Handles user lookup queries\"\"\"\n\n    def __init__(self, \n                 user_repository: Repository[User, str],\n                 mapper: Mapper):\n        self.user_repository = user_repository\n        self.mapper = mapper\n\n    async def handle_async(self, query: GetUserByIdQuery) -&gt; OperationResult[UserDto]:\n        user = await self.user_repository.get_by_id_async(query.user_id)\n\n        if user is None:\n            return self.not_found(f\"User with ID {query.user_id} not found\")\n\n        user_dto = self.mapper.map(user, UserDto)\n        return self.ok(user_dto)\n\nclass SearchUsersQueryHandler(QueryHandler[SearchUsersQuery, OperationResult[List[UserDto]]]):\n    \"\"\"Handles user search queries\"\"\"\n\n    def __init__(self, \n                 user_repository: Repository[User, str],\n                 mapper: Mapper):\n        self.user_repository = user_repository\n        self.mapper = mapper\n\n    async def handle_async(self, query: SearchUsersQuery) -&gt; OperationResult[List[UserDto]]:\n        users = await self.user_repository.search_async(\n            search_term=query.search_term,\n            page=query.page,\n            page_size=query.page_size\n        )\n\n        user_dtos = [self.mapper.map(user, UserDto) for user in users]\n        return self.ok(user_dtos)\n</code></pre>"},{"location":"features/cqrs-mediation/#event-handlers","title":"Event Handlers","text":"<p>Process events for side effects and integrations:</p> <pre><code>from neuroglia.mediation.mediator import EventHandler\n\nclass UserCreatedEventHandler(EventHandler[UserCreatedEvent]):\n    \"\"\"Handles user created events\"\"\"\n\n    def __init__(self, \n                 audit_service: IAuditService,\n                 analytics_service: IAnalyticsService):\n        self.audit_service = audit_service\n        self.analytics_service = analytics_service\n\n    async def handle_async(self, event: UserCreatedEvent):\n        # Log audit entry\n        await self.audit_service.log_user_created(event.user_id, event.created_at)\n\n        # Track analytics\n        await self.analytics_service.track_user_registration(event.user_id)\n\nclass SendWelcomeEmailHandler(EventHandler[UserCreatedEvent]):\n    \"\"\"Sends welcome email when user is created\"\"\"\n\n    def __init__(self, email_service: IEmailService):\n        self.email_service = email_service\n\n    async def handle_async(self, event: UserCreatedEvent):\n        await self.email_service.send_welcome_email(event.email)\n</code></pre>"},{"location":"features/cqrs-mediation/#mediator-usage","title":"\ud83d\ude80 Mediator Usage","text":""},{"location":"features/cqrs-mediation/#configuration","title":"Configuration","text":"<p>Configure the mediator in your application startup:</p> <pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.mediation.mediator import Mediator\n\nbuilder = WebApplicationBuilder()\n\n# Configure mediator with handler modules\nMediator.configure(builder, [\n    \"application.commands\",\n    \"application.queries\",\n    \"application.events\"\n])\n\napp = builder.build()\n</code></pre>"},{"location":"features/cqrs-mediation/#in-controllers","title":"In Controllers","text":"<p>Use the mediator in your API controllers:</p> <pre><code>from neuroglia.mvc.controller_base import ControllerBase\n\nclass UsersController(ControllerBase):\n\n    @post(\"/\", response_model=UserDto, status_code=201)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        # Map DTO to command\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n\n        # Execute through mediator\n        result = await self.mediator.execute_async(command)\n\n        # Process result and return\n        return self.process(result)\n\n    @get(\"/{user_id}\", response_model=UserDto)\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        # Create query\n        query = GetUserByIdQuery(user_id=user_id)\n\n        # Execute through mediator\n        result = await self.mediator.execute_async(query)\n\n        # Process result and return\n        return self.process(result)\n\n    @get(\"/\", response_model=List[UserDto])\n    async def search_users(self, \n                          search: str = \"\",\n                          page: int = 1,\n                          page_size: int = 20) -&gt; List[UserDto]:\n        # Create query\n        query = SearchUsersQuery(\n            search_term=search,\n            page=page,\n            page_size=page_size\n        )\n\n        # Execute through mediator\n        result = await self.mediator.execute_async(query)\n\n        # Process result and return\n        return self.process(result)\n</code></pre>"},{"location":"features/cqrs-mediation/#in-services","title":"In Services","text":"<p>Use the mediator in application services:</p> <pre><code>class UserService:\n    def __init__(self, mediator: Mediator):\n        self.mediator = mediator\n\n    async def register_user(self, registration_data: UserRegistrationData) -&gt; UserDto:\n        # Create command\n        command = CreateUserCommand(\n            email=registration_data.email,\n            first_name=registration_data.first_name,\n            last_name=registration_data.last_name,\n            password=registration_data.password\n        )\n\n        # Execute command\n        result = await self.mediator.execute_async(command)\n\n        if result.is_success:\n            return result.data\n        else:\n            raise UserRegistrationException(result.error_message)\n</code></pre>"},{"location":"features/cqrs-mediation/#advanced-patterns","title":"\ud83c\udfad Advanced Patterns","text":""},{"location":"features/cqrs-mediation/#pipeline-behaviors","title":"Pipeline Behaviors","text":"<p>Add cross-cutting concerns through pipeline behaviors:</p> <pre><code>from neuroglia.mediation.mediator import PipelineBehavior\n\nclass ValidationBehavior(PipelineBehavior):\n    \"\"\"Validates requests before processing\"\"\"\n\n    async def handle_async(self, request, next_handler):\n        # Validate request\n        if hasattr(request, 'validate'):\n            validation_result = request.validate()\n            if not validation_result.is_valid:\n                return OperationResult.validation_error(validation_result.errors)\n\n        # Continue to next behavior/handler\n        return await next_handler()\n\nclass LoggingBehavior(PipelineBehavior):\n    \"\"\"Logs requests and responses\"\"\"\n\n    def __init__(self, logger: Logger):\n        self.logger = logger\n\n    async def handle_async(self, request, next_handler):\n        request_name = type(request).__name__\n        self.logger.info(f\"Executing {request_name}\")\n\n        try:\n            result = await next_handler()\n            self.logger.info(f\"Completed {request_name}\")\n            return result\n        except Exception as ex:\n            self.logger.error(f\"Failed {request_name}: {ex}\")\n            raise\n\n# Register behaviors\nbuilder.services.add_pipeline_behavior(ValidationBehavior)\nbuilder.services.add_pipeline_behavior(LoggingBehavior)\n</code></pre>"},{"location":"features/cqrs-mediation/#transaction-behavior","title":"Transaction Behavior","text":"<p>Wrap commands in database transactions:</p> <pre><code>class TransactionBehavior(PipelineBehavior):\n    \"\"\"Wraps commands in database transactions\"\"\"\n\n    def __init__(self, unit_of_work: IUnitOfWork):\n        self.unit_of_work = unit_of_work\n\n    async def handle_async(self, request, next_handler):\n        # Only apply to commands\n        if not isinstance(request, Command):\n            return await next_handler()\n\n        async with self.unit_of_work.begin_transaction():\n            try:\n                result = await next_handler()\n                await self.unit_of_work.commit()\n                return result\n            except Exception:\n                await self.unit_of_work.rollback()\n                raise\n</code></pre>"},{"location":"features/cqrs-mediation/#caching-behavior","title":"Caching Behavior","text":"<p>Cache query results:</p> <pre><code>class CachingBehavior(PipelineBehavior):\n    \"\"\"Caches query results\"\"\"\n\n    def __init__(self, cache_service: ICacheService):\n        self.cache_service = cache_service\n\n    async def handle_async(self, request, next_handler):\n        # Only cache queries\n        if not isinstance(request, Query):\n            return await next_handler()\n\n        # Generate cache key\n        cache_key = f\"{type(request).__name__}:{hash(str(request))}\"\n\n        # Try to get from cache\n        cached_result = await self.cache_service.get_async(cache_key)\n        if cached_result:\n            return cached_result\n\n        # Execute query\n        result = await next_handler()\n\n        # Cache successful results\n        if result.is_success:\n            await self.cache_service.set_async(cache_key, result, expiry=timedelta(minutes=5))\n\n        return result\n</code></pre>"},{"location":"features/cqrs-mediation/#domain-events","title":"\ud83c\udfdb\ufe0f Domain Events","text":""},{"location":"features/cqrs-mediation/#publishing-events","title":"Publishing Events","text":"<p>Publish domain events from entities or handlers:</p> <pre><code>class User(AggregateRoot[str]):\n    def create(self, email: str, first_name: str, last_name: str):\n        # Apply business rules\n        self.email = email\n        self.first_name = first_name\n        self.last_name = last_name\n        self.created_at = datetime.utcnow()\n\n        # Raise domain event\n        self.raise_event(UserCreatedEvent(\n            user_id=self.id,\n            email=self.email,\n            created_at=self.created_at\n        ))\n\nclass CreateUserCommandHandler(CommandHandler[CreateUserCommand, OperationResult[UserDto]]):\n    async def handle_async(self, command: CreateUserCommand) -&gt; OperationResult[UserDto]:\n        # Create user (events are raised automatically)\n        user = User.create(command.email, command.first_name, command.last_name)\n\n        # Save user (this will publish the events)\n        await self.user_repository.add_async(user)\n\n        return self.created(self.mapper.map(user, UserDto))\n</code></pre>"},{"location":"features/cqrs-mediation/#event-dispatching","title":"Event Dispatching","text":"<p>Events are automatically dispatched to registered handlers:</p> <pre><code># Multiple handlers can listen to the same event\nclass UserCreatedEventHandler(EventHandler[UserCreatedEvent]):\n    async def handle_async(self, event: UserCreatedEvent):\n        # Handle audit logging\n        pass\n\nclass WelcomeEmailHandler(EventHandler[UserCreatedEvent]):\n    async def handle_async(self, event: UserCreatedEvent):\n        # Send welcome email\n        pass\n\nclass AnalyticsHandler(EventHandler[UserCreatedEvent]):\n    async def handle_async(self, event: UserCreatedEvent):\n        # Track user registration\n        pass\n</code></pre>"},{"location":"features/cqrs-mediation/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"features/cqrs-mediation/#testing-handlers","title":"Testing Handlers","text":"<p>Test handlers in isolation:</p> <pre><code>import pytest\nfrom unittest.mock import Mock\n\n@pytest.mark.asyncio\nasync def test_create_user_command_handler():\n    # Arrange\n    mock_repository = Mock()\n    mock_mapper = Mock()\n    mock_password_service = Mock()\n    mock_email_service = Mock()\n\n    handler = CreateUserCommandHandler(\n        mock_repository, \n        mock_mapper, \n        mock_password_service,\n        mock_email_service\n    )\n\n    command = CreateUserCommand(\n        email=\"test@example.com\",\n        first_name=\"John\",\n        last_name=\"Doe\",\n        password=\"password123\"\n    )\n\n    # Configure mocks\n    mock_repository.get_by_email_async.return_value = None\n    mock_password_service.hash_password.return_value = \"hashed_password\"\n    mock_repository.add_async.return_value = test_user\n    mock_mapper.map.return_value = test_user_dto\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n    assert result.data == test_user_dto\n    mock_repository.add_async.assert_called_once()\n    mock_email_service.send_welcome_email.assert_called_once()\n</code></pre>"},{"location":"features/cqrs-mediation/#integration-testing","title":"Integration Testing","text":"<p>Test the complete flow through the mediator:</p> <pre><code>@pytest.mark.asyncio\nasync def test_user_creation_flow():\n    # Arrange\n    test_client = TestClient(app)\n\n    user_data = {\n        \"email\": \"test@example.com\",\n        \"first_name\": \"John\",\n        \"last_name\": \"Doe\",\n        \"password\": \"password123\"\n    }\n\n    # Act\n    response = test_client.post(\"/api/v1/users\", json=user_data)\n\n    # Assert\n    assert response.status_code == 201\n\n    created_user = response.json()\n    assert created_user[\"email\"] == user_data[\"email\"]\n    assert created_user[\"first_name\"] == user_data[\"first_name\"]\n\n    # Verify user was actually created\n    get_response = test_client.get(f\"/api/v1/users/{created_user['id']}\")\n    assert get_response.status_code == 200\n</code></pre>"},{"location":"features/cqrs-mediation/#best-practices","title":"\ud83d\ude80 Best Practices","text":""},{"location":"features/cqrs-mediation/#1-single-responsibility","title":"1. Single Responsibility","text":"<p>Each command/query should have a single, well-defined purpose:</p> <pre><code># Good - Single responsibility\nclass CreateUserCommand: pass\nclass UpdateUserEmailCommand: pass\nclass DeactivateUserCommand: pass\n\n# Avoid - Multiple responsibilities\nclass ManageUserCommand: pass  # Too broad\n</code></pre>"},{"location":"features/cqrs-mediation/#2-immutable-requests","title":"2. Immutable Requests","text":"<p>Make commands and queries immutable:</p> <pre><code># Good - Immutable\n@dataclass(frozen=True)\nclass CreateUserCommand:\n    email: str\n    first_name: str\n    last_name: str\n\n# Avoid - Mutable\nclass CreateUserCommand:\n    def __init__(self):\n        self.email = None\n        self.first_name = None\n</code></pre>"},{"location":"features/cqrs-mediation/#3-rich-domain-models","title":"3. Rich Domain Models","text":"<p>Use domain events to decouple side effects:</p> <pre><code># Good - Domain events\nclass User:\n    def activate(self):\n        self.is_active = True\n        self.raise_event(UserActivatedEvent(self.id))\n\n# Avoid - Direct coupling\nclass User:\n    def activate(self, email_service: IEmailService):\n        self.is_active = True\n        email_service.send_activation_email(self.email)  # Tight coupling\n</code></pre>"},{"location":"features/cqrs-mediation/#4-validation","title":"4. Validation","text":"<p>Validate inputs at the right level:</p> <pre><code># Domain validation (business rules)\nclass CreateUserCommand:\n    def validate(self) -&gt; ValidationResult:\n        errors = []\n        if not self.email or '@' not in self.email:\n            errors.append(\"Valid email is required\")\n        return ValidationResult(errors)\n\n# Input validation (format/required fields)\nclass CreateUserDto:\n    email: str = Field(..., regex=r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$')\n    first_name: str = Field(..., min_length=1, max_length=50)\n</code></pre>"},{"location":"features/cqrs-mediation/#5-error-handling","title":"5. Error Handling","text":"<p>Use consistent error handling patterns:</p> <pre><code>class CreateUserCommandHandler(CommandHandler):\n    async def handle_async(self, command: CreateUserCommand) -&gt; OperationResult[UserDto]:\n        try:\n            # Business logic\n            user = await self.create_user(command)\n            return self.created(user)\n\n        except EmailAlreadyExistsException:\n            return self.conflict(\"Email already exists\")\n        except InvalidEmailException:\n            return self.bad_request(\"Invalid email format\")\n        except Exception as ex:\n            return self.internal_error(f\"Failed to create user: {ex}\")\n</code></pre>"},{"location":"features/cqrs-mediation/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Basic CQRS usage</li> <li>Architecture Guide - How CQRS fits in the architecture</li> <li>Dependency Injection - DI with handlers</li> <li>Data Access - Repositories and units of work</li> <li>Event Handling - Domain events and integration events</li> </ul>"},{"location":"features/data-access/","title":"\ud83d\uddc4\ufe0f Data Access","text":"<p>Neuroglia provides a flexible data access layer that supports multiple storage backends through a unified repository pattern. It includes built-in support for MongoDB, Event Store, and in-memory repositories, with extensibility for other data stores.</p>"},{"location":"features/data-access/#overview","title":"\ud83c\udfaf Overview","text":"<p>The data access system provides:</p> <ul> <li>Repository Pattern: Unified interface for data operations</li> <li>Multiple Storage Backends: MongoDB, Event Store, in-memory, and custom implementations</li> <li>Event Sourcing: Complete event sourcing support with EventStoreDB</li> <li>CQRS Support: Separate read and write models</li> <li>Query Abstractions: Flexible querying capabilities</li> <li>Unit of Work: Transaction management across repositories</li> </ul>"},{"location":"features/data-access/#core-abstractions","title":"\ud83c\udfd7\ufe0f Core Abstractions","text":""},{"location":"features/data-access/#repository-interface","title":"Repository Interface","text":"<p>The base repository interface defines standard CRUD operations:</p> <pre><code>from abc import ABC, abstractmethod\nfrom typing import Generic, TypeVar, List, Optional\n\nTEntity = TypeVar('TEntity')\nTKey = TypeVar('TKey')\n\nclass Repository(Generic[TEntity, TKey], ABC):\n    \"\"\"Base repository interface\"\"\"\n\n    @abstractmethod\n    async def get_by_id_async(self, id: TKey) -&gt; Optional[TEntity]:\n        \"\"\"Get entity by ID\"\"\"\n        pass\n\n    @abstractmethod\n    async def add_async(self, entity: TEntity) -&gt; TEntity:\n        \"\"\"Add new entity\"\"\"\n        pass\n\n    @abstractmethod\n    async def update_async(self, entity: TEntity) -&gt; TEntity:\n        \"\"\"Update existing entity\"\"\"\n        pass\n\n    @abstractmethod\n    async def remove_async(self, entity: TEntity):\n        \"\"\"Remove entity\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_async(self, predicate) -&gt; List[TEntity]:\n        \"\"\"Find entities matching predicate\"\"\"\n        pass\n</code></pre>"},{"location":"features/data-access/#queryable-interface","title":"Queryable Interface","text":"<p>For advanced querying capabilities:</p> <pre><code>from neuroglia.data.abstractions import Queryable\n\nclass ExtendedRepository(Repository[TEntity, TKey], Queryable[TEntity]):\n    \"\"\"Repository with advanced querying\"\"\"\n\n    async def where(self, predicate) -&gt; 'ExtendedRepository[TEntity, TKey]':\n        \"\"\"Filter entities\"\"\"\n        pass\n\n    async def order_by(self, selector) -&gt; 'ExtendedRepository[TEntity, TKey]':\n        \"\"\"Order entities\"\"\"\n        pass\n\n    async def take(self, count: int) -&gt; 'ExtendedRepository[TEntity, TKey]':\n        \"\"\"Take specified number of entities\"\"\"\n        pass\n</code></pre>"},{"location":"features/data-access/#mongodb-integration","title":"\ud83d\uddc3\ufe0f MongoDB Integration","text":""},{"location":"features/data-access/#mongodb-repository","title":"MongoDB Repository","text":"<p>Built-in MongoDB repository implementation:</p> <pre><code>from neuroglia.data.infrastructure.mongo import MongoRepository\nfrom motor.motor_asyncio import AsyncIOMotorClient\n\nclass UserRepository(MongoRepository[User, str]):\n    \"\"\"MongoDB repository for users\"\"\"\n\n    def __init__(self, connection_string: str, database_name: str):\n        super().__init__(connection_string, database_name, \"users\")\n\n    async def get_by_email_async(self, email: str) -&gt; Optional[User]:\n        \"\"\"Custom method to find user by email\"\"\"\n        filter_dict = {\"email\": email}\n        document = await self.collection.find_one(filter_dict)\n\n        if document is None:\n            return None\n\n        return self._map_document_to_entity(document)\n\n    async def find_by_department_async(self, department: str) -&gt; List[User]:\n        \"\"\"Find users by department\"\"\"\n        filter_dict = {\"department\": department}\n        cursor = self.collection.find(filter_dict)\n\n        users = []\n        async for document in cursor:\n            users.append(self._map_document_to_entity(document))\n\n        return users\n</code></pre>"},{"location":"features/data-access/#configuration","title":"Configuration","text":"<p>Configure MongoDB repositories in your application:</p> <pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.hosting.configuration.data_access_layer import DataAccessLayer\n\nbuilder = WebApplicationBuilder()\n\n# Configure MongoDB repositories for read models\nDataAccessLayer.ReadModel.configure(\n    builder,\n    [\"integration.models\"],  # Modules containing DTOs\n    lambda builder_, entity_type, key_type: MongoRepository.configure(\n        builder_, entity_type, key_type, \"myapp_db\"\n    )\n)\n\napp = builder.build()\n</code></pre>"},{"location":"features/data-access/#event-sourcing","title":"\ud83d\udcc5 Event Sourcing","text":""},{"location":"features/data-access/#event-store-repository","title":"Event Store Repository","text":"<p>For event-sourced aggregates:</p> <pre><code>from neuroglia.data.infrastructure.event_sourcing import EventSourcingRepository\nfrom neuroglia.data.abstractions import AggregateRoot\n\nclass Person(AggregateRoot[str]):\n    \"\"\"Event-sourced person aggregate\"\"\"\n\n    def __init__(self, id: str = None):\n        super().__init__(id)\n        self.state = PersonState()\n\n    def register(self, first_name: str, last_name: str, email: str):\n        \"\"\"Register a new person\"\"\"\n        self.apply(PersonRegisteredEvent(\n            person_id=self.id,\n            first_name=first_name,\n            last_name=last_name,\n            email=email\n        ))\n\n    def change_email(self, new_email: str):\n        \"\"\"Change person's email\"\"\"\n        self.apply(PersonEmailChangedEvent(\n            person_id=self.id,\n            old_email=self.state.email,\n            new_email=new_email\n        ))\n\n    # Event handlers\n    def on_person_registered(self, event: PersonRegisteredEvent):\n        self.state.id = event.person_id\n        self.state.first_name = event.first_name\n        self.state.last_name = event.last_name\n        self.state.email = event.email\n\n    def on_person_email_changed(self, event: PersonEmailChangedEvent):\n        self.state.email = event.new_email\n</code></pre>"},{"location":"features/data-access/#event-store-configuration","title":"Event Store Configuration","text":"<p>Configure EventStoreDB integration:</p> <pre><code>from neuroglia.data.infrastructure.event_sourcing.event_store import ESEventStore\nfrom neuroglia.data.infrastructure.event_sourcing.abstractions import EventStoreOptions\n\n# Configure EventStore\nbuilder = WebApplicationBuilder()\n\nESEventStore.configure(\n    builder,\n    EventStoreOptions(\n        database_name=\"myapp\",\n        consumer_group=\"myapp_consumers\"\n    )\n)\n\n# Configure event sourcing repositories for write models\nDataAccessLayer.WriteModel.configure(\n    builder,\n    [\"domain.models\"],  # Modules containing aggregates\n    lambda builder_, entity_type, key_type: EventSourcingRepository.configure(\n        builder_, entity_type, key_type\n    )\n)\n</code></pre>"},{"location":"features/data-access/#in-memory-repository","title":"\ud83d\udcbe In-Memory Repository","text":"<p>For testing and development:</p> <pre><code>from neuroglia.data.infrastructure.memory import MemoryRepository\n\nclass InMemoryUserRepository(MemoryRepository[User, str]):\n    \"\"\"In-memory repository for testing\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self._users_by_email = {}\n\n    async def add_async(self, user: User) -&gt; User:\n        \"\"\"Add user and index by email\"\"\"\n        result = await super().add_async(user)\n        self._users_by_email[user.email] = user\n        return result\n\n    async def get_by_email_async(self, email: str) -&gt; Optional[User]:\n        \"\"\"Get user by email\"\"\"\n        return self._users_by_email.get(email)\n\n    async def remove_async(self, user: User):\n        \"\"\"Remove user and clean up email index\"\"\"\n        await super().remove_async(user)\n        if user.email in self._users_by_email:\n            del self._users_by_email[user.email]\n</code></pre>"},{"location":"features/data-access/#cqrs-with-separate-models","title":"\ud83d\udd04 CQRS with Separate Models","text":""},{"location":"features/data-access/#write-model-commands","title":"Write Model (Commands)","text":"<p>Use event-sourced aggregates for write operations:</p> <pre><code>class CreateUserCommandHandler(CommandHandler[CreateUserCommand, OperationResult[UserDto]]):\n    \"\"\"Handles user creation commands\"\"\"\n\n    def __init__(self, \n                 user_repository: Repository[User, str],  # Event-sourced repository\n                 mapper: Mapper):\n        self.user_repository = user_repository\n        self.mapper = mapper\n\n    async def handle_async(self, command: CreateUserCommand) -&gt; OperationResult[UserDto]:\n        # Create aggregate\n        user = User(str(uuid.uuid4()))\n        user.register(command.first_name, command.last_name, command.email)\n\n        # Save to event store\n        saved_user = await self.user_repository.add_async(user)\n\n        # Return DTO\n        user_dto = self.mapper.map(saved_user.state, UserDto)\n        return self.created(user_dto)\n</code></pre>"},{"location":"features/data-access/#read-model-queries","title":"Read Model (Queries)","text":"<p>Use optimized read models for queries:</p> <pre><code>@dataclass\nclass UserReadModel:\n    \"\"\"Optimized read model for user queries\"\"\"\n    id: str\n    first_name: str\n    last_name: str\n    email: str\n    full_name: str\n    department: str\n    created_at: datetime\n    is_active: bool\n\nclass GetUsersQueryHandler(QueryHandler[GetUsersQuery, OperationResult[List[UserDto]]]):\n    \"\"\"Handles user queries using read model\"\"\"\n\n    def __init__(self, \n                 read_model_repository: Repository[UserReadModel, str]):\n        self.read_model_repository = read_model_repository\n\n    async def handle_async(self, query: GetUsersQuery) -&gt; OperationResult[List[UserDto]]:\n        # Query optimized read model\n        users = await self.read_model_repository.find_async(\n            lambda u: u.department == query.department if query.department else True\n        )\n\n        # Map to DTOs\n        user_dtos = [self._map_to_dto(user) for user in users]\n        return self.ok(user_dtos)\n</code></pre>"},{"location":"features/data-access/#custom-repository-implementation","title":"\ud83c\udfed Custom Repository Implementation","text":""},{"location":"features/data-access/#creating-custom-repository","title":"Creating Custom Repository","text":"<p>Implement the repository interface for custom data stores:</p> <pre><code>import aioredis\nfrom typing import Optional, List\n\nclass RedisUserRepository(Repository[User, str]):\n    \"\"\"Redis-based user repository\"\"\"\n\n    def __init__(self, redis_url: str):\n        self.redis_url = redis_url\n        self._redis = None\n\n    async def _get_redis(self):\n        \"\"\"Get Redis connection\"\"\"\n        if self._redis is None:\n            self._redis = await aioredis.from_url(self.redis_url)\n        return self._redis\n\n    async def get_by_id_async(self, user_id: str) -&gt; Optional[User]:\n        \"\"\"Get user from Redis\"\"\"\n        redis = await self._get_redis()\n        data = await redis.get(f\"user:{user_id}\")\n\n        if data is None:\n            return None\n\n        return self._deserialize_user(data)\n\n    async def add_async(self, user: User) -&gt; User:\n        \"\"\"Add user to Redis\"\"\"\n        redis = await self._get_redis()\n        data = self._serialize_user(user)\n        await redis.set(f\"user:{user.id}\", data)\n\n        # Add to email index\n        await redis.set(f\"user:email:{user.email}\", user.id)\n\n        return user\n\n    async def update_async(self, user: User) -&gt; User:\n        \"\"\"Update user in Redis\"\"\"\n        return await self.add_async(user)  # Redis is key-value, so update = set\n\n    async def remove_async(self, user: User):\n        \"\"\"Remove user from Redis\"\"\"\n        redis = await self._get_redis()\n        await redis.delete(f\"user:{user.id}\")\n        await redis.delete(f\"user:email:{user.email}\")\n\n    async def find_async(self, predicate) -&gt; List[User]:\n        \"\"\"Find users (basic implementation)\"\"\"\n        redis = await self._get_redis()\n        keys = await redis.keys(\"user:*\")\n\n        users = []\n        for key in keys:\n            if not key.startswith(\"user:email:\"):\n                data = await redis.get(key)\n                user = self._deserialize_user(data)\n                if predicate(user):\n                    users.append(user)\n\n        return users\n\n    def _serialize_user(self, user: User) -&gt; str:\n        \"\"\"Serialize user to JSON\"\"\"\n        import json\n        return json.dumps({\n            'id': user.id,\n            'first_name': user.first_name,\n            'last_name': user.last_name,\n            'email': user.email\n        })\n\n    def _deserialize_user(self, data: str) -&gt; User:\n        \"\"\"Deserialize user from JSON\"\"\"\n        import json\n        user_data = json.loads(data)\n        return User(\n            id=user_data['id'],\n            first_name=user_data['first_name'],\n            last_name=user_data['last_name'],\n            email=user_data['email']\n        )\n</code></pre>"},{"location":"features/data-access/#unit-of-work-pattern","title":"\ud83d\udd04 Unit of Work Pattern","text":"<p>For transaction management across multiple repositories:</p> <pre><code>from abc import ABC, abstractmethod\nfrom contextlib import asynccontextmanager\n\nclass IUnitOfWork(ABC):\n    \"\"\"Unit of work interface\"\"\"\n\n    @property\n    @abstractmethod\n    def users(self) -&gt; Repository[User, str]:\n        pass\n\n    @property\n    @abstractmethod\n    def orders(self) -&gt; Repository[Order, str]:\n        pass\n\n    @abstractmethod\n    async def commit_async(self):\n        \"\"\"Commit all changes\"\"\"\n        pass\n\n    @abstractmethod\n    async def rollback_async(self):\n        \"\"\"Rollback all changes\"\"\"\n        pass\n\n    @asynccontextmanager\n    async def transaction(self):\n        \"\"\"Context manager for transactions\"\"\"\n        try:\n            yield self\n            await self.commit_async()\n        except Exception:\n            await self.rollback_async()\n            raise\n\nclass MongoUnitOfWork(IUnitOfWork):\n    \"\"\"MongoDB implementation of unit of work\"\"\"\n\n    def __init__(self, client: AsyncIOMotorClient, database_name: str):\n        self.client = client\n        self.database_name = database_name\n        self.session = None\n        self._users = None\n        self._orders = None\n\n    @property\n    def users(self) -&gt; Repository[User, str]:\n        if self._users is None:\n            self._users = MongoUserRepository(self.client, self.database_name, self.session)\n        return self._users\n\n    @property\n    def orders(self) -&gt; Repository[Order, str]:\n        if self._orders is None:\n            self._orders = MongoOrderRepository(self.client, self.database_name, self.session)\n        return self._orders\n\n    async def commit_async(self):\n        \"\"\"Commit transaction\"\"\"\n        if self.session:\n            await self.session.commit_transaction()\n\n    async def rollback_async(self):\n        \"\"\"Rollback transaction\"\"\"\n        if self.session:\n            await self.session.abort_transaction()\n\n    @asynccontextmanager\n    async def transaction(self):\n        \"\"\"Start a MongoDB transaction\"\"\"\n        async with await self.client.start_session() as session:\n            self.session = session\n            async with session.start_transaction():\n                try:\n                    yield self\n                    await session.commit_transaction()\n                except Exception:\n                    await session.abort_transaction()\n                    raise\n                finally:\n                    self.session = None\n\n# Usage in command handler\nclass ProcessOrderCommandHandler(CommandHandler[ProcessOrderCommand, OperationResult]):\n    def __init__(self, unit_of_work: IUnitOfWork):\n        self.unit_of_work = unit_of_work\n\n    async def handle_async(self, command: ProcessOrderCommand) -&gt; OperationResult:\n        async with self.unit_of_work.transaction():\n            # Get user\n            user = await self.unit_of_work.users.get_by_id_async(command.user_id)\n            if user is None:\n                return self.not_found(\"User not found\")\n\n            # Create order\n            order = Order.create(command.items, user.id)\n            await self.unit_of_work.orders.add_async(order)\n\n            # Update user stats\n            user.increment_order_count()\n            await self.unit_of_work.users.update_async(user)\n\n            # Transaction commits automatically\n            return self.ok()\n</code></pre>"},{"location":"features/data-access/#testing-with-repositories","title":"\ud83e\uddea Testing with Repositories","text":""},{"location":"features/data-access/#test-doubles","title":"Test Doubles","text":"<p>Use in-memory repositories for testing:</p> <pre><code>import pytest\nfrom unittest.mock import Mock\n\n@pytest.fixture\ndef user_repository():\n    \"\"\"In-memory user repository for testing\"\"\"\n    return InMemoryUserRepository()\n\n@pytest.mark.asyncio\nasync def test_create_user_command(user_repository):\n    # Arrange\n    mapper = Mock()\n    mapper.map.return_value = test_user_dto\n\n    handler = CreateUserCommandHandler(user_repository, mapper)\n    command = CreateUserCommand(\"John\", \"Doe\", \"john@example.com\")\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n\n    # Verify user was saved\n    saved_user = await user_repository.get_by_id_async(result.data.id)\n    assert saved_user is not None\n    assert saved_user.email == \"john@example.com\"\n</code></pre>"},{"location":"features/data-access/#integration-testing","title":"Integration Testing","text":"<p>Test with real databases:</p> <pre><code>import pytest\nimport motor.motor_asyncio\nfrom testcontainers.mongodb import MongoDbContainer\n\n@pytest.fixture(scope=\"session\")\nasync def mongodb_container():\n    \"\"\"Start MongoDB container for testing\"\"\"\n    with MongoDbContainer() as container:\n        yield container\n\n@pytest.fixture\nasync def mongo_repository(mongodb_container):\n    \"\"\"MongoDB repository for integration testing\"\"\"\n    connection_string = mongodb_container.get_connection_url()\n    return MongoUserRepository(connection_string, \"test_db\")\n\n@pytest.mark.asyncio\nasync def test_user_repository_integration(mongo_repository):\n    # Arrange\n    user = User(\"test-id\", \"John\", \"Doe\", \"john@test.com\")\n\n    # Act\n    saved_user = await mongo_repository.add_async(user)\n    retrieved_user = await mongo_repository.get_by_id_async(user.id)\n\n    # Assert\n    assert saved_user.id == user.id\n    assert retrieved_user is not None\n    assert retrieved_user.email == user.email\n</code></pre>"},{"location":"features/data-access/#best-practices","title":"\ud83d\ude80 Best Practices","text":""},{"location":"features/data-access/#1-use-interface-segregation","title":"1. Use Interface Segregation","text":"<p>Define specific repository interfaces for different use cases:</p> <pre><code># Good - Specific interfaces\nclass IUserReadRepository(ABC):\n    async def get_by_email_async(self, email: str) -&gt; Optional[UserDto]:\n        pass\n\n    async def search_async(self, criteria: UserSearchCriteria) -&gt; List[UserDto]:\n        pass\n\nclass IUserWriteRepository(ABC):\n    async def add_async(self, user: User) -&gt; User:\n        pass\n\n    async def update_async(self, user: User) -&gt; User:\n        pass\n\n# Avoid - Generic repository for everything\nclass IGenericUserRepository(Repository[User, str]):\n    # Too broad, mixes read and write concerns\n    pass\n</code></pre>"},{"location":"features/data-access/#2-separate-read-and-write-models","title":"2. Separate Read and Write Models","text":"<p>Use different models for commands and queries:</p> <pre><code># Write model (domain entity)\nclass User(AggregateRoot[str]):\n    # Rich domain model with behavior\n    def change_email(self, new_email: str):\n        # Business logic and validation\n        pass\n\n# Read model (DTO)\n@dataclass\nclass UserListDto:\n    # Optimized for display\n    id: str\n    display_name: str\n    email: str\n    last_login: datetime\n    status: str\n</code></pre>"},{"location":"features/data-access/#3-handle-concurrency","title":"3. Handle Concurrency","text":"<p>Implement optimistic concurrency for event-sourced aggregates:</p> <pre><code>class User(AggregateRoot[str]):\n    def __init__(self, id: str = None):\n        super().__init__(id)\n        self.version = 0  # Concurrency token\n\n    def apply_event(self, event: DomainEvent):\n        super().apply_event(event)\n        self.version += 1\n\nclass EventSourcingRepository(Repository[User, str]):\n    async def update_async(self, user: User) -&gt; User:\n        # Check for concurrent modifications\n        current_version = await self.get_version(user.id)\n        if current_version != user.original_version:\n            raise ConcurrencyException(\"Entity was modified by another process\")\n\n        # Save events\n        await self.save_events(user.uncommitted_events, user.version)\n        return user\n</code></pre>"},{"location":"features/data-access/#4-use-specifications-pattern","title":"4. Use Specifications Pattern","text":"<p>For complex queries:</p> <pre><code>from abc import ABC, abstractmethod\n\nclass Specification(ABC):\n    @abstractmethod\n    def is_satisfied_by(self, entity) -&gt; bool:\n        pass\n\n    def and_(self, other: 'Specification') -&gt; 'Specification':\n        return AndSpecification(self, other)\n\n    def or_(self, other: 'Specification') -&gt; 'Specification':\n        return OrSpecification(self, other)\n\nclass ActiveUserSpecification(Specification):\n    def is_satisfied_by(self, user: User) -&gt; bool:\n        return user.is_active\n\nclass UserInDepartmentSpecification(Specification):\n    def __init__(self, department: str):\n        self.department = department\n\n    def is_satisfied_by(self, user: User) -&gt; bool:\n        return user.department == self.department\n\n# Usage\nactive_engineering_users = ActiveUserSpecification().and_(\n    UserInDepartmentSpecification(\"Engineering\")\n)\n\nusers = await repository.find_async(active_engineering_users.is_satisfied_by)\n</code></pre>"},{"location":"features/data-access/#5-repository-registration","title":"5. Repository Registration","text":"<p>Register repositories properly in DI container:</p> <pre><code># In application startup\nbuilder = WebApplicationBuilder()\n\n# Register by interface\nbuilder.services.add_scoped(IUserRepository, MongoUserRepository)\nbuilder.services.add_scoped(IOrderRepository, EventSourcedOrderRepository)\n\n# Register factory for complex initialization\ndef create_user_repository(provider: ServiceProviderBase) -&gt; IUserRepository:\n    config = provider.get_required_service(DatabaseConfig)\n    if config.use_event_sourcing:\n        return EventSourcedUserRepository(config.event_store_connection)\n    else:\n        return MongoUserRepository(config.mongo_connection, config.database_name)\n\nbuilder.services.add_scoped(IUserRepository, factory=create_user_repository)\n</code></pre>"},{"location":"features/data-access/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Basic repository usage</li> <li>Architecture Guide - How repositories fit in the architecture</li> <li>CQRS &amp; Mediation - Using repositories with CQRS</li> <li>Event Sourcing - Event sourcing with repositories</li> <li>Dependency Injection - DI with repositories</li> </ul>"},{"location":"features/dependency-injection/","title":"\ud83d\udc89 Dependency Injection","text":"<p>Neuroglia provides a lightweight, powerful dependency injection (DI) container that manages service registration, lifetime, and resolution. The DI system supports automatic service discovery and follows common DI patterns.</p>"},{"location":"features/dependency-injection/#overview","title":"\ud83c\udfaf Overview","text":"<p>The dependency injection system consists of:</p> <ul> <li>ServiceCollection: Registry for service definitions</li> <li>ServiceProvider: Container for resolving and managing services</li> <li>ServiceLifetime: Controls when services are created and disposed</li> <li>Automatic Discovery: Services can be automatically discovered and registered</li> </ul>"},{"location":"features/dependency-injection/#service-lifetimes","title":"\ud83c\udfd7\ufe0f Service Lifetimes","text":""},{"location":"features/dependency-injection/#singleton","title":"Singleton","text":"<p>Created once and reused for the entire application lifetime:</p> <pre><code>from neuroglia.dependency_injection.service_provider import ServiceCollection\n\nservices = ServiceCollection()\nservices.add_singleton(DatabaseConnection)\nservices.add_singleton(CacheService)\n</code></pre> <p>Use Cases:</p> <ul> <li>Database connections</li> <li>Configuration services</li> <li>Caching services</li> <li>Application-wide state</li> </ul>"},{"location":"features/dependency-injection/#scoped","title":"Scoped","text":"<p>Created once per scope (typically per HTTP request):</p> <pre><code>services.add_scoped(UserRepository)\nservices.add_scoped(OrderService)\n</code></pre> <p>Use Cases:</p> <ul> <li>Repositories</li> <li>Unit of Work</li> <li>Request-specific services</li> <li>Database contexts</li> </ul>"},{"location":"features/dependency-injection/#transient","title":"Transient","text":"<p>Created each time they are requested:</p> <pre><code>services.add_transient(EmailService)\nservices.add_transient(CalculationService)\n</code></pre> <p>Use Cases:</p> <ul> <li>Stateless services</li> <li>Lightweight operations</li> <li>Services with short lifecycles</li> </ul>"},{"location":"features/dependency-injection/#registration-patterns","title":"\ud83d\udd27 Registration Patterns","text":""},{"location":"features/dependency-injection/#interface-and-implementation","title":"Interface and Implementation","text":"<p>Register services by interface and implementation:</p> <pre><code>from abc import ABC, abstractmethod\n\nclass IUserRepository(ABC):\n    @abstractmethod\n    async def get_by_id(self, user_id: str) -&gt; User:\n        pass\n\nclass MongoUserRepository(IUserRepository):\n    async def get_by_id(self, user_id: str) -&gt; User:\n        # MongoDB implementation\n        pass\n\n# Registration\nservices.add_scoped(IUserRepository, MongoUserRepository)\n</code></pre>"},{"location":"features/dependency-injection/#factory-functions","title":"Factory Functions","text":"<p>Use factory functions for complex initialization:</p> <pre><code>def create_database_connection() -&gt; DatabaseConnection:\n    connection_string = get_connection_string()\n    return DatabaseConnection(connection_string)\n\nservices.add_singleton(DatabaseConnection, factory=create_database_connection)\n</code></pre>"},{"location":"features/dependency-injection/#generic-services","title":"Generic Services","text":"<p>Register generic services with type parameters:</p> <pre><code>from typing import TypeVar, Generic\n\nT = TypeVar('T')\n\nclass Repository(Generic[T]):\n    def __init__(self, db_context: DbContext):\n        self.db_context = db_context\n\n# Registration\nservices.add_scoped(Repository[User])\nservices.add_scoped(Repository[Order])\n</code></pre>"},{"location":"features/dependency-injection/#automatic-discovery","title":"\ud83d\udd0d Automatic Discovery","text":"<p>Neuroglia can automatically discover and register services based on conventions:</p>"},{"location":"features/dependency-injection/#module-based-discovery","title":"Module-Based Discovery","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\n\nbuilder = WebApplicationBuilder()\n\n# Automatically discover and register services in modules\nbuilder.services.discover_services([\n    \"application.services\",\n    \"integration.repositories\",\n    \"domain.services\"\n])\n</code></pre>"},{"location":"features/dependency-injection/#attribute-based-registration","title":"Attribute-Based Registration","text":"<p>Use decorators to mark services for automatic registration:</p> <pre><code>from neuroglia.dependency_injection import service\n\n@service(lifetime=ServiceLifetime.SCOPED)\nclass UserService:\n    def __init__(self, user_repository: IUserRepository):\n        self.user_repository = user_repository\n\n@service(interface=IUserRepository, lifetime=ServiceLifetime.SCOPED)\nclass MongoUserRepository(IUserRepository):\n    def __init__(self, db_context: MongoContext):\n        self.db_context = db_context\n</code></pre>"},{"location":"features/dependency-injection/#service-resolution","title":"\ud83d\udd04 Service Resolution","text":""},{"location":"features/dependency-injection/#manual-resolution","title":"Manual Resolution","text":"<pre><code># Build the service provider\nprovider = services.build_service_provider()\n\n# Resolve services\nuser_service = provider.get_required_service(UserService)\nuser_repo = provider.get_service(IUserRepository)  # Returns None if not registered\nall_repos = provider.get_services(IRepository)  # Returns all implementations\n</code></pre>"},{"location":"features/dependency-injection/#constructor-injection","title":"Constructor Injection","text":"<p>Services are automatically injected into constructors:</p> <pre><code>class UserController(ControllerBase):\n    def __init__(self, \n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator,\n                 user_service: UserService):  # Automatically injected\n        super().__init__(service_provider, mapper, mediator)\n        self.user_service = user_service\n</code></pre>"},{"location":"features/dependency-injection/#property-injection","title":"Property Injection","text":"<p>Access services through the service provider:</p> <pre><code>class UserService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.service_provider = service_provider\n\n    def get_email_service(self) -&gt; EmailService:\n        return self.service_provider.get_required_service(EmailService)\n</code></pre>"},{"location":"features/dependency-injection/#advanced-patterns","title":"\ud83c\udfad Advanced Patterns","text":""},{"location":"features/dependency-injection/#service-locator-pattern","title":"Service Locator Pattern","text":"<pre><code>class ServiceLocator:\n    _provider: ServiceProviderBase = None\n\n    @classmethod\n    def configure(cls, provider: ServiceProviderBase):\n        cls._provider = provider\n\n    @classmethod\n    def get_service(cls, service_type: Type[T]) -&gt; T:\n        return cls._provider.get_required_service(service_type)\n\n# Usage\nemail_service = ServiceLocator.get_service(EmailService)\n</code></pre>"},{"location":"features/dependency-injection/#conditional-registration","title":"Conditional Registration","text":"<p>Register services based on conditions:</p> <pre><code>if app_settings.use_redis_cache:\n    services.add_singleton(ICacheService, RedisCacheService)\nelse:\n    services.add_singleton(ICacheService, MemoryCacheService)\n</code></pre>"},{"location":"features/dependency-injection/#decorated-services","title":"Decorated Services","text":"<p>Wrap services with additional behavior:</p> <pre><code>class LoggingUserService(IUserService):\n    def __init__(self, inner: IUserService, logger: Logger):\n        self.inner = inner\n        self.logger = logger\n\n    async def create_user(self, user_data: UserData) -&gt; User:\n        self.logger.info(f\"Creating user: {user_data.email}\")\n        result = await self.inner.create_user(user_data)\n        self.logger.info(f\"User created: {result.id}\")\n        return result\n\n# Registration with decoration\nservices.add_scoped(IUserService, UserService)\nservices.decorate(IUserService, LoggingUserService)\n</code></pre>"},{"location":"features/dependency-injection/#configuration-integration","title":"\ud83d\udd27 Configuration Integration","text":""},{"location":"features/dependency-injection/#configuration-objects","title":"Configuration Objects","text":"<p>Bind configuration sections to objects:</p> <pre><code>from dataclasses import dataclass\n\n@dataclass\nclass DatabaseConfig:\n    connection_string: str\n    timeout: int\n    retry_count: int\n\n# Register configuration\nservices.configure(DatabaseConfig, app_settings.database)\n\n# Use in services\nclass UserRepository:\n    def __init__(self, config: DatabaseConfig):\n        self.connection_string = config.connection_string\n</code></pre>"},{"location":"features/dependency-injection/#options-pattern","title":"Options Pattern","text":"<p>Use the options pattern for configuration:</p> <pre><code>from neuroglia.configuration import IOptions\n\nclass UserService:\n    def __init__(self, options: IOptions[UserServiceOptions]):\n        self.options = options.value\n\n    def send_welcome_email(self, user: User):\n        if self.options.send_welcome_emails:\n            # Send email logic\n            pass\n</code></pre>"},{"location":"features/dependency-injection/#testing-with-di","title":"\ud83e\uddea Testing with DI","text":""},{"location":"features/dependency-injection/#test-service-registration","title":"Test Service Registration","text":"<p>Override services for testing:</p> <pre><code>import pytest\nfrom neuroglia.dependency_injection import ServiceCollection\n\n@pytest.fixture\ndef test_services():\n    services = ServiceCollection()\n\n    # Register test implementations\n    services.add_singleton(IUserRepository, InMemoryUserRepository)\n    services.add_singleton(IEmailService, MockEmailService)\n\n    return services.build_service_provider()\n\ndef test_user_creation(test_services):\n    user_service = test_services.get_required_service(UserService)\n    result = user_service.create_user(user_data)\n    assert result.is_success\n</code></pre>"},{"location":"features/dependency-injection/#mock-dependencies","title":"Mock Dependencies","text":"<p>Use mocking frameworks with DI:</p> <pre><code>from unittest.mock import Mock\n\ndef test_user_service_with_mocks():\n    # Arrange\n    mock_repo = Mock(spec=IUserRepository)\n    mock_repo.add_async.return_value = test_user\n\n    services = ServiceCollection()\n    services.add_instance(IUserRepository, mock_repo)\n    provider = services.build_service_provider()\n\n    # Act\n    user_service = provider.get_required_service(UserService)\n    result = await user_service.create_user(user_data)\n\n    # Assert\n    mock_repo.add_async.assert_called_once()\n    assert result.email == test_user.email\n</code></pre>"},{"location":"features/dependency-injection/#framework-integration","title":"\ud83c\udfaa Framework Integration","text":""},{"location":"features/dependency-injection/#web-application-builder","title":"Web Application Builder","text":"<p>The WebApplicationBuilder provides convenient methods for service registration:</p> <pre><code>from neuroglia.hosting.web import WebApplicationBuilder\n\nbuilder = WebApplicationBuilder()\n\n# Configure framework services\nbuilder.services.add_mediation([\"application\"])\nbuilder.services.add_mapping([\"application\", \"domain\"])\nbuilder.services.add_repositories([\"integration.repositories\"])\n\n# Add custom services\nbuilder.services.add_scoped(UserService)\nbuilder.services.add_singleton(EmailService)\n\napp = builder.build()\n</code></pre>"},{"location":"features/dependency-injection/#controller-dependencies","title":"Controller Dependencies","text":"<p>Controllers automatically receive dependencies:</p> <pre><code>class UsersController(ControllerBase):\n    def __init__(self, \n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator,\n                 user_service: UserService,\n                 email_service: EmailService):\n        super().__init__(service_provider, mapper, mediator)\n        self.user_service = user_service\n        self.email_service = email_service\n</code></pre>"},{"location":"features/dependency-injection/#middleware-dependencies","title":"Middleware Dependencies","text":"<p>Middleware can also use dependency injection:</p> <pre><code>class AuthenticationMiddleware:\n    def __init__(self, auth_service: IAuthService):\n        self.auth_service = auth_service\n\n    async def __call__(self, request: Request, call_next):\n        # Use auth_service for authentication logic\n        pass\n</code></pre>"},{"location":"features/dependency-injection/#best-practices","title":"\ud83d\ude80 Best Practices","text":""},{"location":"features/dependency-injection/#1-register-by-interface","title":"1. Register by Interface","text":"<p>Always register services by their interface when possible:</p> <pre><code># Good\nservices.add_scoped(IUserRepository, MongoUserRepository)\n\n# Avoid\nservices.add_scoped(MongoUserRepository)\n</code></pre>"},{"location":"features/dependency-injection/#2-use-appropriate-lifetimes","title":"2. Use Appropriate Lifetimes","text":"<p>Choose the correct lifetime for your services:</p> <ul> <li>Singleton: Expensive to create, stateless, or application-wide</li> <li>Scoped: Request-specific, maintains state during request</li> <li>Transient: Lightweight, stateless, or disposable</li> </ul>"},{"location":"features/dependency-injection/#3-avoid-service-locator","title":"3. Avoid Service Locator","text":"<p>Prefer constructor injection over service locator:</p> <pre><code># Good - Constructor injection\nclass UserService:\n    def __init__(self, user_repository: IUserRepository):\n        self.user_repository = user_repository\n\n# Avoid - Service locator\nclass UserService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.service_provider = service_provider\n\n    def some_method(self):\n        repo = self.service_provider.get_required_service(IUserRepository)\n</code></pre>"},{"location":"features/dependency-injection/#4-validate-dependencies","title":"4. Validate Dependencies","text":"<p>Ensure all required dependencies are registered:</p> <pre><code>def validate_services(provider: ServiceProviderBase):\n    \"\"\"Validate that all required services are registered\"\"\"\n    required_services = [IUserRepository, IEmailService, ICacheService]\n\n    for service_type in required_services:\n        service = provider.get_service(service_type)\n        if service is None:\n            raise ValueError(f\"Required service {service_type} not registered\")\n</code></pre>"},{"location":"features/dependency-injection/#5-use-factories-for-complex-objects","title":"5. Use Factories for Complex Objects","text":"<p>Use factory functions for services that need complex initialization:</p> <pre><code>def create_user_repository(provider: ServiceProviderBase) -&gt; IUserRepository:\n    config = provider.get_required_service(DatabaseConfig)\n    connection = provider.get_required_service(DatabaseConnection)\n\n    if config.use_caching:\n        cache = provider.get_required_service(ICacheService)\n        return CachedUserRepository(connection, cache)\n    else:\n        return UserRepository(connection)\n\nservices.add_scoped(IUserRepository, factory=create_user_repository)\n</code></pre>"},{"location":"features/dependency-injection/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Basic DI usage</li> <li>Architecture Guide - How DI fits in the architecture</li> <li>CQRS &amp; Mediation - DI with command handlers</li> <li>Data Access - DI with repositories</li> <li>Testing - Testing with dependency injection</li> </ul>"},{"location":"features/event-sourcing/","title":"\ud83c\udfaf Event Sourcing","text":"<p>Event Sourcing is a data storage pattern where state changes are stored as a sequence of immutable events rather than updating data in place. Neuroglia provides comprehensive event sourcing support with EventStoreDB integration, aggregate root patterns, and event-driven projections.</p>"},{"location":"features/event-sourcing/#overview","title":"\ud83c\udfaf Overview","text":"<p>Event Sourcing offers several key benefits:</p> <ul> <li>Complete Audit Trail: Every state change is captured as an immutable event</li> <li>Temporal Queries: Query system state at any point in time</li> <li>Event Replay: Reconstruct current state by replaying events</li> <li>Business Intelligence: Analyze patterns and trends from event streams</li> <li>Debugging: Full visibility into how state changes occurred</li> <li>Scalability: Events can be replayed to create optimized read models</li> </ul>"},{"location":"features/event-sourcing/#core-concepts","title":"\ud83c\udfd7\ufe0f Core Concepts","text":""},{"location":"features/event-sourcing/#events-as-source-of-truth","title":"Events as Source of Truth","text":"<p>In traditional systems, current state is stored directly:</p> <pre><code># Traditional approach - current state only\nclass BankAccount:\n    def __init__(self, id: str, balance: Decimal):\n        self.id = id\n        self.balance = balance  # Current state stored directly\n\n    def withdraw(self, amount: Decimal):\n        self.balance -= amount  # State updated in place\n</code></pre> <p>With Event Sourcing, we store the events that led to the current state:</p> <pre><code># Event Sourcing approach - events as source of truth\nclass BankAccountCreatedEvent(DomainEvent[str]):\n    def __init__(self, account_id: str, initial_balance: Decimal):\n        super().__init__(account_id)\n        self.initial_balance = initial_balance\n\nclass MoneyWithdrawnEvent(DomainEvent[str]):\n    def __init__(self, account_id: str, amount: Decimal):\n        super().__init__(account_id)\n        self.amount = amount\n\nclass BankAccount(AggregateRoot[BankAccountState, str]):\n    def __init__(self, id: str, initial_balance: Decimal):\n        super().__init__()\n        self.state.on(self.register_event(BankAccountCreatedEvent(id, initial_balance)))\n\n    def withdraw(self, amount: Decimal):\n        if self.state.balance &lt; amount:\n            raise InsufficientFundsException()\n        self.state.on(self.register_event(MoneyWithdrawnEvent(self.state.id, amount)))\n</code></pre>"},{"location":"features/event-sourcing/#state-reconstruction-from-events","title":"State Reconstruction from Events","text":"<p>Current state is derived by applying events in sequence using the <code>@dispatch</code> decorator:</p> <pre><code>from neuroglia.data.abstractions import AggregateRoot, DomainEvent\nfrom neuroglia.mapping.mapper import map_to\nfrom decimal import Decimal\nfrom multipledispatch import dispatch\n\nclass BankAccountCreatedDomainEventV1(DomainEvent[str]):\n    def __init__(self, aggregate_id: str, owner_id: str, overdraft_limit: Decimal):\n        super().__init__(aggregate_id)\n        self.owner_id = owner_id\n        self.overdraft_limit = overdraft_limit\n\nclass BankAccountTransactionRecordedDomainEventV1(DomainEvent[str]):\n    def __init__(self, aggregate_id: str, transaction_id: str, amount: Decimal):\n        super().__init__(aggregate_id)\n        self.transaction_id = transaction_id\n        self.amount = amount\n\nclass BankAccountV1(AggregateRoot[str]):\n    def __init__(self, account_id: str = None):\n        super().__init__(account_id)\n        self._balance = Decimal('0.00')\n        self._owner_id = \"\"\n        self._overdraft_limit = Decimal('0.00')\n\n    @property\n    def balance(self) -&gt; Decimal:\n        return self._balance\n\n    @dispatch(BankAccountCreatedDomainEventV1)\n    def state_manager(self, event: BankAccountCreatedDomainEventV1):\n        \"\"\"Handle account creation for state reconstruction\"\"\"\n        self._owner_id = event.owner_id\n        self._overdraft_limit = event.overdraft_limit\n\n    @dispatch(BankAccountTransactionRecordedDomainEventV1)\n    def state_manager(self, event: BankAccountTransactionRecordedDomainEventV1):\n        \"\"\"Handle transaction recording for state reconstruction\"\"\"\n        self._balance += event.amount\n</code></pre>"},{"location":"features/event-sourcing/#aggregate-root-pattern","title":"\ud83d\ude80 Aggregate Root Pattern","text":""},{"location":"features/event-sourcing/#defining-aggregates","title":"Defining Aggregates","text":"<p>Aggregates are domain objects that encapsulate business logic and raise domain events:</p> <pre><code>from neuroglia.data.abstractions import AggregateRoot, AggregateState, DomainEvent\nfrom decimal import Decimal\nfrom datetime import datetime\nimport uuid\n\nclass BankAccountV1(AggregateRoot[BankAccountState, str]):\n    \"\"\"Bank Account aggregate with event sourcing\"\"\"\n\n    def __init__(self, owner: Person, initial_balance: Decimal):\n        super().__init__()\n\n        # Validate business rules\n        if initial_balance &lt; Decimal('0.00'):\n            raise InvalidInitialBalanceException(\"Initial balance cannot be negative\")\n\n        # Register creation event and apply to state\n        self.state.on(self.register_event(BankAccountCreatedDomainEventV1(\n            aggregate_id=str(uuid.uuid4()).replace('-', ''),\n            owner_id=owner.id(),\n            initial_balance=initial_balance,\n            created_at=datetime.utcnow()\n        )))\n\n    def get_available_balance(self) -&gt; Decimal:\n        \"\"\"Get the available balance including overdraft\"\"\"\n        return Decimal(self.state.balance) + Decimal(self.state.overdraft_limit)\n\n    def try_add_transaction(self, transaction: BankTransactionV1) -&gt; bool:\n        \"\"\"Record a financial transaction\"\"\"\n\n        # Business rule validation  \n        if (transaction.type != BankTransactionTypeV1.DEPOSIT and \n            transaction.type != BankTransactionTypeV1.INTEREST and \n            not (transaction.type == BankTransactionTypeV1.TRANSFER and transaction.to_account_id == self.id()) and \n            transaction.amount &gt; self.get_available_balance()):\n            return False\n\n        # Register transaction event and apply to state\n        self.state.on(self.register_event(BankAccountTransactionRecordedDomainEventV1(\n            self.id(), transaction\n        )))\n        return True\n\n    def set_overdraft_limit(self, limit: Decimal):\n        \"\"\"Set the overdraft limit for the account\"\"\"\n        if limit &lt; Decimal('0.00'):\n            raise InvalidOverdraftLimitException(\"Overdraft limit cannot be negative\")\n\n        self.state.on(self.register_event(OverdraftLimitChangedDomainEventV1(\n            aggregate_id=self.state.id,\n            old_limit=self.state.overdraft_limit,\n            new_limit=limit\n        )))\n\n    def close_account(self, reason: str):\n        \"\"\"Close the bank account\"\"\"\n        if self.state.balance != Decimal('0.00'):\n            raise AccountHasBalanceException(\"Cannot close account with non-zero balance\")\n\n        self.state.on(self.register_event(BankAccountClosedDomainEventV1(\n            aggregate_id=self.state.id,\n            reason=reason,\n            final_balance=self.state.balance\n        )))\n</code></pre>"},{"location":"features/event-sourcing/#aggregate-state-management","title":"Aggregate State Management","text":"<p>The aggregate manages its internal state through event application:</p> <pre><code>from multipledispatch import dispatch\nfrom decimal import Decimal\nfrom typing import List\n\nclass BankAccountV1(AggregateRoot[str]):\n    \"\"\"Bank Account aggregate with event sourcing\"\"\"\n\n    def __init__(self, account_id: str = None):\n        super().__init__(account_id)\n        self._balance = Decimal('0.00')\n        self._overdraft_limit = Decimal('0.00')\n        self._owner_id = \"\"\n        self._is_closed = False\n        self._transactions = []\n\n    @property\n    def balance(self) -&gt; Decimal:\n        return self._balance\n\n    @property\n    def owner_id(self) -&gt; str:\n        return self._owner_id\n\n    @property\n    def overdraft_limit(self) -&gt; Decimal:\n        return self._overdraft_limit\n\n    @dispatch(BankAccountCreatedDomainEventV1)\n    def state_manager(self, event: BankAccountCreatedDomainEventV1):\n        \"\"\"Handle account creation\"\"\"\n        self._owner_id = event.owner_id\n        self._overdraft_limit = event.overdraft_limit\n\n    @dispatch(BankAccountTransactionRecordedDomainEventV1)\n    def state_manager(self, event: BankAccountTransactionRecordedDomainEventV1):\n        \"\"\"Handle transaction recording\"\"\"\n        # Update balance based on transaction amount\n        self._balance += event.amount\n        self.last_modified = event.timestamp\n\n    @dispatch(OverdraftLimitChangedDomainEventV1)\n    def on(self, event: OverdraftLimitChangedDomainEventV1):\n        \"\"\"Handle overdraft limit changes\"\"\"\n        self.overdraft_limit = event.new_limit\n        self.last_modified = event.timestamp\n\n    @dispatch(BankAccountClosedDomainEventV1)\n    def on(self, event: BankAccountClosedDomainEventV1):\n        \"\"\"Handle account closure\"\"\"\n        self.is_closed = True\n        self.last_modified = event.timestamp\n</code></pre>"},{"location":"features/event-sourcing/#event-store-configuration","title":"\ud83c\udfea Event Store Configuration","text":""},{"location":"features/event-sourcing/#eventstoredb-setup","title":"EventStoreDB Setup","text":"<p>Configure EventStoreDB as the event storage backend:</p> <pre><code>from neuroglia.data.infrastructure.event_sourcing.event_store import ESEventStore\nfrom neuroglia.data.infrastructure.event_sourcing.abstractions import EventStoreOptions\nfrom neuroglia.hosting.web import WebApplicationBuilder\n\ndef configure_event_store(builder: WebApplicationBuilder):\n    \"\"\"Configure EventStoreDB for event sourcing\"\"\"\n\n    # Event store configuration\n    database_name = \"bankingsystem\"\n    consumer_group = \"banking-api-v1\"\n\n    ESEventStore.configure(\n        builder, \n        EventStoreOptions(\n            database_name=database_name,\n            consumer_group=consumer_group,\n            connection_string=\"esdb://localhost:2113?tls=false\",\n            credentials={\"username\": \"admin\", \"password\": \"changeit\"}\n        )\n    )\n\n    # Configure event sourcing repository for write model\n    EventSourcingRepository.configure(builder, BankAccountV1, str)\n\n    return builder\n</code></pre>"},{"location":"features/event-sourcing/#repository-configuration","title":"Repository Configuration","text":"<p>Set up separate repositories for write and read models:</p> <pre><code>from neuroglia.hosting.configuration.data_access_layer import DataAccessLayer\nfrom neuroglia.data.infrastructure.event_sourcing.event_sourcing_repository import EventSourcingRepository\nfrom neuroglia.data.infrastructure.mongo.mongo_repository import MongoRepository\n\ndef configure_data_access(builder: WebApplicationBuilder):\n    \"\"\"Configure write and read model repositories\"\"\"\n\n    # Write Model: Event-sourced aggregates\n    DataAccessLayer.WriteModel.configure(\n        builder,\n        [\"samples.banking.domain.models\"],  # Domain aggregate modules\n        lambda builder_, entity_type, key_type: EventSourcingRepository.configure(\n            builder_, entity_type, key_type\n        )\n    )\n\n    # Read Model: MongoDB projections\n    DataAccessLayer.ReadModel.configure(\n        builder,\n        [\"samples.banking.integration.models\"],  # Read model modules\n        lambda builder_, entity_type, key_type: MongoRepository.configure(\n            builder_, entity_type, key_type, database_name=\"banking_read_models\"\n        )\n    )\n\n    return builder\n</code></pre>"},{"location":"features/event-sourcing/#event-driven-projections","title":"\ud83d\udcca Event-Driven Projections","text":""},{"location":"features/event-sourcing/#creating-read-model-projections","title":"Creating Read Model Projections","text":"<p>Transform domain events into optimized read models:</p> <pre><code>from neuroglia.eventing import event_handler\n\nclass BankAccountProjectionHandler:\n    \"\"\"Handles domain events to update read model projections\"\"\"\n\n    def __init__(self, read_repository: Repository[BankAccountProjection, str]):\n        self.read_repository = read_repository\n\n    @event_handler(BankAccountCreatedDomainEventV1)\n    async def handle_account_created(self, event: BankAccountCreatedDomainEventV1):\n        \"\"\"Create read model projection when account is created\"\"\"\n\n        projection = BankAccountProjection(\n            id=event.aggregate_id,\n            owner_id=event.owner_id,\n            balance=event.initial_balance,\n            overdraft_limit=Decimal('0.00'),\n            status=\"ACTIVE\",\n            created_at=event.created_at,\n            last_modified=event.created_at,\n            transaction_count=0,\n            last_transaction_at=None\n        )\n\n        await self.read_repository.add_async(projection)\n\n    @event_handler(BankAccountTransactionRecordedDomainEventV1)\n    async def handle_transaction_recorded(self, event: BankAccountTransactionRecordedDomainEventV1):\n        \"\"\"Update projection when transaction is recorded\"\"\"\n\n        projection = await self.read_repository.get_by_id_async(event.aggregate_id)\n        if projection:\n            projection.balance += event.amount\n            projection.transaction_count += 1\n            projection.last_transaction_at = event.timestamp\n            projection.last_modified = event.timestamp\n\n            await self.read_repository.update_async(projection)\n\n    @event_handler(BankAccountClosedDomainEventV1)\n    async def handle_account_closed(self, event: BankAccountClosedDomainEventV1):\n        \"\"\"Update projection when account is closed\"\"\"\n\n        projection = await self.read_repository.get_by_id_async(event.aggregate_id)\n        if projection:\n            projection.status = \"CLOSED\"\n            projection.last_modified = event.timestamp\n\n            await self.read_repository.update_async(projection)\n</code></pre>"},{"location":"features/event-sourcing/#read-model-optimization","title":"Read Model Optimization","text":"<p>Design read models for specific query patterns:</p> <pre><code>@dataclass\nclass BankAccountProjection:\n    \"\"\"Optimized read model for bank account queries\"\"\"\n\n    id: str\n    owner_id: str\n    balance: Decimal\n    overdraft_limit: Decimal\n    status: str  # ACTIVE, CLOSED, SUSPENDED\n    created_at: datetime\n    last_modified: datetime\n    transaction_count: int\n    last_transaction_at: Optional[datetime]\n\n    # Denormalized owner information for efficient queries\n    owner_name: Optional[str] = None\n    owner_email: Optional[str] = None\n\n    # Aggregated transaction data\n    total_debits: Decimal = Decimal('0.00')\n    total_credits: Decimal = Decimal('0.00')\n    largest_transaction: Decimal = Decimal('0.00')\n\n@dataclass\nclass AccountSummaryProjection:\n    \"\"\"Summary projection for dashboard queries\"\"\"\n\n    owner_id: str\n    total_accounts: int\n    total_balance: Decimal\n    active_accounts: int\n    closed_accounts: int\n    last_activity: datetime\n</code></pre>"},{"location":"features/event-sourcing/#temporal-queries","title":"\ud83d\udd70\ufe0f Temporal Queries","text":""},{"location":"features/event-sourcing/#point-in-time-state-reconstruction","title":"Point-in-Time State Reconstruction","text":"<p>Query aggregate state at any specific point in time:</p> <pre><code>class TemporalQueryService:\n    \"\"\"Service for temporal queries on event-sourced aggregates\"\"\"\n\n    def __init__(self, event_store: EventStore, aggregator: Aggregator):\n        self.event_store = event_store\n        self.aggregator = aggregator\n\n    async def get_account_balance_at_date(self, account_id: str, as_of_date: datetime) -&gt; Decimal:\n        \"\"\"Get account balance as it was at a specific date\"\"\"\n\n        stream_id = f\"BankAccount-{account_id}\"\n\n        # Read events up to the specified date\n        events = await self.event_store.read_async(\n            stream_id,\n            direction=StreamReadDirection.FORWARDS,\n            from_position=0,\n            to_date=as_of_date\n        )\n\n        # Reconstruct state at that point in time\n        account = self.aggregator.aggregate(events, BankAccountV1)\n        return account.state.balance if account else Decimal('0.00')\n\n    async def get_transaction_history_between_dates(\n        self, \n        account_id: str, \n        from_date: datetime, \n        to_date: datetime\n    ) -&gt; List[BankTransactionV1]:\n        \"\"\"Get all transactions within a date range\"\"\"\n\n        stream_id = f\"BankAccount-{account_id}\"\n\n        events = await self.event_store.read_async(\n            stream_id,\n            direction=StreamReadDirection.FORWARDS,\n            from_date=from_date,\n            to_date=to_date\n        )\n\n        transactions = []\n        for event_record in events:\n            if isinstance(event_record.data, BankAccountTransactionRecordedDomainEventV1):\n                transaction = BankTransactionV1(\n                    id=event_record.data.transaction_id,\n                    amount=event_record.data.amount,\n                    type=event_record.data.transaction_type,\n                    recorded_at=event_record.data.timestamp\n                )\n                transactions.append(transaction)\n\n        return transactions\n</code></pre>"},{"location":"features/event-sourcing/#business-intelligence-queries","title":"Business Intelligence Queries","text":"<p>Analyze historical data patterns:</p> <pre><code>class BusinessIntelligenceService:\n    \"\"\"Service for analyzing business patterns from events\"\"\"\n\n    def __init__(self, event_store: EventStore):\n        self.event_store = event_store\n\n    async def get_transaction_analytics(\n        self, \n        from_date: datetime, \n        to_date: datetime\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Analyze transaction patterns over time\"\"\"\n\n        # Query all transaction events in date range\n        events = await self.event_store.get_events_by_type_async(\n            BankAccountTransactionRecordedDomainEventV1,\n            from_date=from_date,\n            to_date=to_date\n        )\n\n        if not events:\n            return {\"message\": \"No transactions found in date range\"}\n\n        # Calculate analytics\n        total_transactions = len(events)\n        total_amount = sum(e.amount for e in events)\n        debit_transactions = [e for e in events if e.amount &lt; 0]\n        credit_transactions = [e for e in events if e.amount &gt; 0]\n\n        return {\n            \"period\": {\"from\": from_date.isoformat(), \"to\": to_date.isoformat()},\n            \"total_transactions\": total_transactions,\n            \"total_amount\": float(total_amount),\n            \"average_transaction\": float(total_amount / total_transactions),\n            \"debit_count\": len(debit_transactions),\n            \"credit_count\": len(credit_transactions),\n            \"largest_debit\": float(min(e.amount for e in debit_transactions)) if debit_transactions else 0,\n            \"largest_credit\": float(max(e.amount for e in credit_transactions)) if credit_transactions else 0,\n            \"daily_breakdown\": self._calculate_daily_breakdown(events, from_date, to_date)\n        }\n\n    def _calculate_daily_breakdown(self, events: List[BankAccountTransactionRecordedDomainEventV1], from_date: datetime, to_date: datetime) -&gt; List[Dict]:\n        \"\"\"Calculate daily transaction breakdown\"\"\"\n        daily_data = {}\n\n        for event in events:\n            day_key = event.timestamp.date().isoformat()\n            if day_key not in daily_data:\n                daily_data[day_key] = {\"count\": 0, \"amount\": Decimal('0.00')}\n\n            daily_data[day_key][\"count\"] += 1\n            daily_data[day_key][\"amount\"] += event.amount\n\n        return [\n            {\n                \"date\": date,\n                \"transaction_count\": data[\"count\"],\n                \"total_amount\": float(data[\"amount\"])\n            }\n            for date, data in sorted(daily_data.items())\n        ]\n</code></pre>"},{"location":"features/event-sourcing/#testing-event-sourced-systems","title":"\ud83e\uddea Testing Event-Sourced Systems","text":""},{"location":"features/event-sourcing/#unit-testing-aggregates","title":"Unit Testing Aggregates","text":"<p>Test business logic by verifying events are raised correctly:</p> <pre><code>import pytest\nfrom decimal import Decimal\n\nclass TestBankAccountAggregate:\n    \"\"\"Unit tests for BankAccount aggregate\"\"\"\n\n    def test_account_creation_raises_creation_event(self):\n        \"\"\"Test that creating an account raises the correct event\"\"\"\n        account = BankAccountV1()\n        owner_id = \"john-doe-123\"\n        overdraft_limit = Decimal(\"1000.00\")\n\n        account.create_account(owner_id, overdraft_limit)\n\n        events = account._pending_events\n\n        assert len(events) == 1\n        assert isinstance(events[0], BankAccountCreatedDomainEventV1)\n        assert events[0].owner_id == owner_id\n        assert events[0].overdraft_limit == overdraft_limit\n\n    def test_transaction_recording_updates_balance_and_raises_event(self):\n        \"\"\"Test that recording a transaction updates balance and raises event\"\"\"\n        account = self._create_test_account()\n\n        # Create a transaction using the actual method signature\n        transaction_id = \"trans-123\"\n        amount = Decimal(\"100.00\")\n\n        result = account.try_add_transaction(transaction_id, amount)\n\n        # Verify transaction was accepted\n        assert result == True\n\n        # Verify event was registered\n        events = account._pending_events\n        transaction_events = [e for e in events if isinstance(e, BankAccountTransactionRecordedDomainEventV1)]\n\n        assert len(transaction_events) == 1\n\n    def test_insufficient_funds_raises_exception(self):\n        \"\"\"Test that insufficient funds rejects transaction\"\"\"\n        account = self._create_test_account()\n\n        # Create transaction that exceeds available balance\n        large_transaction = BankTransactionV1(\n            type=BankTransactionTypeV1.WITHDRAWAL,\n            amount=Decimal(\"2000.00\"),  # More than available balance\n            from_account_id=account.id(),\n            to_account_id=None\n        )\n\n        result = account.try_add_transaction(large_transaction)\n\n        # Verify transaction was rejected\n        assert result == False\n\n        # Verify no event was registered\n        events = account._pending_events\n        transaction_events = [e for e in events if isinstance(e, BankAccountTransactionRecordedDomainEventV1)]\n        assert len(transaction_events) == 0\n\n    def test_state_reconstruction_from_events(self):\n        \"\"\"Test that aggregate state can be reconstructed from events\"\"\"\n\n        # Create aggregate\n        account = BankAccountV1()\n\n        # Create and apply events directly to simulate repository loading\n        creation_event = BankAccountCreatedDomainEventV1(\n            aggregate_id=account.id,\n            owner_id=\"owner-123\",\n            overdraft_limit=Decimal(\"500.00\")\n        )\n\n        transaction_event = BankAccountTransactionRecordedDomainEventV1(\n            aggregate_id=account.id,\n            transaction_id=\"trans-123\",\n            amount=Decimal(\"100.00\")\n        )\n\n        # Apply events to reconstruct state\n        account.state_manager(creation_event)\n        account.state_manager(transaction_event)\n\n        # Verify state reconstruction\n        assert account.owner_id == \"owner-123\"\n        assert account.overdraft_limit == Decimal(\"500.00\")\n        assert account.balance == Decimal(\"100.00\")\n\n    def _create_test_account(self) -&gt; BankAccountV1:\n        \"\"\"Helper method to create a test account\"\"\"\n        account = BankAccountV1()\n        account.create_account(\"test-owner\", Decimal(\"1000.00\"))\n        # Clear pending events for clean testing\n        account._pending_events.clear()\n        return account\n</code></pre>"},{"location":"features/event-sourcing/#integration-testing-with-event-store","title":"Integration Testing with Event Store","text":"<p>Test the complete event sourcing workflow:</p> <pre><code>@pytest.mark.integration\nclass TestEventSourcingIntegration:\n    \"\"\"Integration tests for event sourcing workflow\"\"\"\n\n    @pytest.fixture\n    async def event_store(self):\n        \"\"\"Create test event store\"\"\"\n        options = EventStoreOptions(\n            database_name=\"test_banking\",\n            consumer_group=\"test_group\",\n            connection_string=\"esdb://localhost:2113?tls=false\"\n        )\n        # Return configured event store for testing\n        pass\n\n    @pytest.fixture\n    async def repository(self, event_store):\n        \"\"\"Create test repository\"\"\"\n        aggregator = Aggregator()\n        return EventSourcingRepository(event_store, aggregator)\n\n    @pytest.mark.asyncio\n    async def test_complete_aggregate_lifecycle(self, repository):\n        \"\"\"Test complete aggregate lifecycle with persistence\"\"\"\n\n        # Create aggregate\n        owner = Person(\"integration@test.com\", \"Integration\", \"Test\")\n        account = BankAccountV1(owner, Decimal(\"1000.00\"))\n\n        # Save to event store\n        saved_account = await repository.add_async(account)\n        assert saved_account.state.state_version &gt; 0\n\n        # Load from event store\n        loaded_account = await repository.get_async(saved_account.id())\n        assert loaded_account is not None\n        assert loaded_account.state.balance == Decimal(\"1000.00\")\n        assert loaded_account.state.owner_id == owner.id()\n\n        # Modify and save again\n        transaction = BankTransactionV1(\n            type=BankTransactionTypeV1.WITHDRAWAL,\n            amount=Decimal(\"200.00\"),\n            from_account_id=loaded_account.id(),\n            to_account_id=None\n        )\n        loaded_account.try_add_transaction(transaction)\n        updated_account = await repository.update_async(loaded_account)\n\n        # Verify persistence\n        final_account = await repository.get_async(updated_account.id())\n        assert len(final_account.state.transactions) == 1\n\n    @pytest.mark.asyncio\n    async def test_concurrent_modifications_throw_concurrency_exception(self, repository):\n        \"\"\"Test that concurrent modifications are detected\"\"\"\n\n        # Create and save account\n        owner = Person(\"concurrent@test.com\", \"Concurrent\", \"Test\")\n        account = BankAccountV1(owner, Decimal(\"1000.00\"))\n        saved_account = await repository.add_async(account)\n        account_id = saved_account.id()\n\n        # Load same account in two instances\n        account1 = await repository.get_async(account_id)\n        account2 = await repository.get_async(account_id)\n\n        # Modify both\n        transaction1 = BankTransactionV1(BankTransactionTypeV1.WITHDRAWAL, Decimal(\"100.00\"), account_id, None)\n        transaction2 = BankTransactionV1(BankTransactionTypeV1.WITHDRAWAL, Decimal(\"200.00\"), account_id, None)\n\n        account1.try_add_transaction(transaction1)\n        account2.try_add_transaction(transaction2)\n\n        # Save first modification\n        await repository.update_async(account1)\n\n        # Second modification should fail due to concurrency\n        with pytest.raises(ConcurrencyException):\n            await repository.update_async(account2)\n</code></pre>"},{"location":"features/event-sourcing/#advanced-patterns","title":"\ud83d\udd27 Advanced Patterns","text":""},{"location":"features/event-sourcing/#event-versioning","title":"Event Versioning","text":"<p>Handle evolving event schemas over time:</p> <pre><code># V1 Event\n@dataclass\nclass BankAccountCreatedDomainEventV1(DomainEvent[str]):\n    owner_id: str\n    initial_balance: Decimal\n\n# V2 Event - Added account type\n@dataclass  \nclass BankAccountCreatedDomainEventV2(DomainEvent[str]):\n    owner_id: str\n    initial_balance: Decimal\n    account_type: str  # New field\n\n# Event upcasting for backward compatibility\nclass EventUpcaster:\n    def upcast(self, event_data: dict, event_type: str) -&gt; dict:\n        if event_type == \"BankAccountCreatedDomainEventV1\":\n            # Upcast V1 to V2 by adding default account type\n            event_data[\"account_type\"] = \"CHECKING\"\n            return event_data\n        return event_data\n</code></pre>"},{"location":"features/event-sourcing/#snapshots-for-performance","title":"Snapshots for Performance","text":"<p>Optimize performance for long event streams:</p> <pre><code>@dataclass\nclass BankAccountSnapshot:\n    \"\"\"Snapshot of bank account state for performance optimization\"\"\"\n\n    aggregate_id: str\n    version: int\n    balance: Decimal\n    overdraft_limit: Decimal\n    transaction_count: int\n    created_at: datetime\n    snapshot_at: datetime\n\nclass SnapshotRepository:\n    \"\"\"Repository for managing aggregate snapshots\"\"\"\n\n    async def save_snapshot_async(self, aggregate: BankAccountV1) -&gt; None:\n        \"\"\"Save a snapshot of the current aggregate state\"\"\"\n        snapshot = BankAccountSnapshot(\n            aggregate_id=aggregate.state.id,\n            version=aggregate.state.state_version,\n            balance=aggregate.state.balance,\n            overdraft_limit=aggregate.state.overdraft_limit,\n            transaction_count=len(aggregate.state.transactions),\n            created_at=aggregate.state.created_at,\n            snapshot_at=datetime.utcnow()\n        )\n        await self.repository.add_async(snapshot)\n\n    async def load_from_snapshot_async(self, aggregate_id: str) -&gt; Optional[BankAccountV1]:\n        \"\"\"Load aggregate from latest snapshot plus subsequent events\"\"\"\n        snapshot = await self.get_latest_snapshot_async(aggregate_id)\n        if not snapshot:\n            return None\n\n        # Load events since snapshot\n        events = await self.event_store.read_async(\n            f\"BankAccount-{aggregate_id}\",\n            from_version=snapshot.version + 1\n        )\n\n        # Reconstruct aggregate from snapshot + events\n        aggregate = self._create_from_snapshot(snapshot)\n        self._apply_events(aggregate, events)\n\n        return aggregate\n</code></pre>"},{"location":"features/event-sourcing/#saga-pattern-for-distributed-transactions","title":"Saga Pattern for Distributed Transactions","text":"<p>Coordinate long-running business processes:</p> <pre><code>class MoneyTransferSaga:\n    \"\"\"Saga for coordinating money transfers between accounts\"\"\"\n\n    @saga_step\n    async def debit_source_account(self, transfer_id: str, source_account_id: str, amount: Decimal):\n        \"\"\"Step 1: Debit the source account\"\"\"\n        command = DebitAccountCommand(source_account_id, amount, transfer_id)\n        result = await self.mediator.execute_async(command)\n\n        if result.is_success:\n            await self.complete_step(\"debit_source\", transfer_id)\n        else:\n            await self.compensate_transfer(transfer_id, \"Failed to debit source account\")\n\n    @saga_step\n    async def credit_target_account(self, transfer_id: str, target_account_id: str, amount: Decimal):\n        \"\"\"Step 2: Credit the target account\"\"\"\n        command = CreditAccountCommand(target_account_id, amount, transfer_id)\n        result = await self.mediator.execute_async(command)\n\n        if result.is_success:\n            await self.complete_saga(transfer_id)\n        else:\n            await self.compensate_debit(transfer_id, source_account_id, amount)\n\n    @compensating_action\n    async def compensate_debit(self, transfer_id: str, account_id: str, amount: Decimal):\n        \"\"\"Compensate by crediting back the debited amount\"\"\"\n        compensation_command = CreditAccountCommand(account_id, amount, f\"compensation-{transfer_id}\")\n        await self.mediator.execute_async(compensation_command)\n</code></pre>"},{"location":"features/event-sourcing/#monitoring-and-observability","title":"\ud83d\udcca Monitoring and Observability","text":""},{"location":"features/event-sourcing/#event-stream-health-monitoring","title":"Event Stream Health Monitoring","text":"<p>Monitor the health of your event streams:</p> <pre><code>class EventStoreHealthService:\n    \"\"\"Service for monitoring event store health\"\"\"\n\n    async def get_stream_statistics(self, stream_id: str) -&gt; Dict[str, Any]:\n        \"\"\"Get statistics for a specific event stream\"\"\"\n        descriptor = await self.event_store.get_stream_descriptor_async(stream_id)\n\n        return {\n            \"stream_id\": stream_id,\n            \"event_count\": descriptor.length,\n            \"first_event_at\": descriptor.first_event_at.isoformat() if descriptor.first_event_at else None,\n            \"last_event_at\": descriptor.last_event_at.isoformat() if descriptor.last_event_at else None,\n            \"stream_age_days\": (datetime.utcnow() - descriptor.first_event_at).days if descriptor.first_event_at else 0\n        }\n\n    async def detect_problematic_streams(self, max_age_days: int = 30) -&gt; List[str]:\n        \"\"\"Detect streams that haven't had events for a long time\"\"\"\n        all_streams = await self.event_store.list_streams_async()\n        problematic_streams = []\n\n        for stream_id in all_streams:\n            descriptor = await self.event_store.get_stream_descriptor_async(stream_id)\n            if descriptor.last_event_at:\n                age = (datetime.utcnow() - descriptor.last_event_at).days\n                if age &gt; max_age_days:\n                    problematic_streams.append(stream_id)\n\n        return problematic_streams\n</code></pre>"},{"location":"features/event-sourcing/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Data Access - Repository patterns and data persistence</li> <li>CQRS &amp; Mediation - Command/Query separation patterns  </li> <li>Domain Events - Domain event modeling</li> <li>OpenBank Sample - Complete event sourcing implementation</li> <li>Testing Strategies - Testing event-sourced systems</li> </ul>"},{"location":"features/event-sourcing/#best-practices","title":"\ud83c\udfaf Best Practices","text":""},{"location":"features/event-sourcing/#dos","title":"Do's \u2705","text":"<ul> <li>Design events as immutable facts - Events represent what happened, not what should happen</li> <li>Use meaningful event names - Events should clearly describe business occurrences</li> <li>Keep events focused - Each event should represent a single business fact</li> <li>Version your events - Plan for schema evolution from the beginning</li> <li>Test event handlers thoroughly - Ensure state transitions work correctly</li> <li>Monitor stream health - Track stream growth and performance metrics</li> </ul>"},{"location":"features/event-sourcing/#donts","title":"Don'ts \u274c","text":"<ul> <li>Don't modify events - Events are immutable historical facts</li> <li>Don't make events too granular - Avoid events for every minor state change</li> <li>Don't ignore concurrency - Handle concurrent modifications appropriately</li> <li>Don't skip snapshots - Use snapshots for performance with long streams</li> <li>Don't forget about eventual consistency - Read models may lag behind write models</li> <li>Don't ignore event ordering - Event sequence matters for state reconstruction</li> </ul> <p>Event Sourcing provides powerful capabilities for building auditable, scalable, and maintainable systems. The Neuroglia framework makes it straightforward to implement event sourcing patterns while maintaining clean architecture principles.</p>"},{"location":"features/mermaid-diagrams/","title":"\ud83d\udcca Mermaid Diagrams in Documentation","text":"<p>The Neuroglia Python Framework documentation supports Mermaid diagrams for creating visual representations of architecture, workflows, and system interactions.</p>"},{"location":"features/mermaid-diagrams/#overview","title":"\ud83c\udfaf Overview","text":"<p>Mermaid is a powerful diagramming tool that allows you to create diagrams using simple text-based syntax. Our documentation site automatically renders Mermaid diagrams when you include them in markdown files.</p>"},{"location":"features/mermaid-diagrams/#supported-diagram-types","title":"\ud83c\udfd7\ufe0f Supported Diagram Types","text":""},{"location":"features/mermaid-diagrams/#flowcharts","title":"Flowcharts","text":"<p>Perfect for representing decision flows, process flows, and system workflows:</p> <pre><code>graph TD\n    A[User Request] --&gt; B{Authentication}\n    B --&gt;|Valid| C[Route to Controller]\n    B --&gt;|Invalid| D[Return 401]\n    C --&gt; E[Execute Handler]\n    E --&gt; F[Return Response]\n    D --&gt; G[End]\n    F --&gt; G</code></pre>"},{"location":"features/mermaid-diagrams/#sequence-diagrams","title":"Sequence Diagrams","text":"<p>Ideal for showing interaction between components over time:</p> <pre><code>sequenceDiagram\n    participant C as Controller\n    participant M as Mediator\n    participant H as Handler\n    participant R as Repository\n    participant D as Database\n\n    C-&gt;&gt;M: Send Command\n    M-&gt;&gt;H: Route to Handler\n    H-&gt;&gt;R: Query/Save Data\n    R-&gt;&gt;D: Execute SQL\n    D--&gt;&gt;R: Return Result\n    R--&gt;&gt;H: Domain Objects\n    H--&gt;&gt;M: Operation Result\n    M--&gt;&gt;C: Response</code></pre>"},{"location":"features/mermaid-diagrams/#class-diagrams","title":"Class Diagrams","text":"<p>Great for documenting domain models and relationships:</p> <pre><code>classDiagram\n    class Controller {\n        +ServiceProvider service_provider\n        +Mediator mediator\n        +Mapper mapper\n        +process(result) Response\n    }\n\n    class CommandHandler {\n        &lt;&lt;abstract&gt;&gt;\n        +handle_async(command) OperationResult\n    }\n\n    class Entity {\n        +str id\n        +datetime created_at\n        +raise_event(event)\n        +get_uncommitted_events()\n    }\n\n    class Repository {\n        &lt;&lt;interface&gt;&gt;\n        +save_async(entity)\n        +get_by_id_async(id)\n        +delete_async(id)\n    }\n\n    Controller --&gt; CommandHandler : uses\n    CommandHandler --&gt; Entity : manipulates\n    CommandHandler --&gt; Repository : persists through</code></pre>"},{"location":"features/mermaid-diagrams/#architecture-diagrams","title":"Architecture Diagrams","text":"<p>Perfect for system overview and component relationships:</p> <pre><code>graph TB\n    subgraph \"\ud83c\udf10 API Layer\"\n        A[Controllers]\n        B[DTOs]\n        C[Middleware]\n    end\n\n    subgraph \"\ud83d\udcbc Application Layer\"\n        D[Commands/Queries]\n        E[Handlers]\n        F[Services]\n        G[Mediator]\n    end\n\n    subgraph \"\ud83c\udfdb\ufe0f Domain Layer\"\n        H[Entities]\n        I[Value Objects]\n        J[Domain Events]\n        K[Business Rules]\n    end\n\n    subgraph \"\ud83d\udd0c Integration Layer\"\n        L[Repositories]\n        M[External APIs]\n        N[Database]\n        O[Event Bus]\n    end\n\n    A --&gt; G\n    G --&gt; E\n    E --&gt; H\n    E --&gt; L\n    L --&gt; N\n    E --&gt; O\n\n    style A fill:#e1f5fe\n    style G fill:#f3e5f5\n    style H fill:#e8f5e8\n    style L fill:#fff3e0</code></pre>"},{"location":"features/mermaid-diagrams/#state-diagrams","title":"State Diagrams","text":"<p>Useful for modeling entity lifecycle and business processes:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; Draft\n    Draft --&gt; Submitted : submit()\n    Submitted --&gt; Approved : approve()\n    Submitted --&gt; Rejected : reject()\n    Rejected --&gt; Draft : revise()\n    Approved --&gt; Published : publish()\n    Published --&gt; Archived : archive()\n    Archived --&gt; [*]\n\n    state Submitted {\n        [*] --&gt; PendingReview\n        PendingReview --&gt; InReview : assign_reviewer()\n        InReview --&gt; ReviewComplete : complete_review()\n    }</code></pre>"},{"location":"features/mermaid-diagrams/#usage-in-documentation","title":"\ud83d\ude80 Usage in Documentation","text":""},{"location":"features/mermaid-diagrams/#basic-syntax","title":"Basic Syntax","text":"<p>To include a Mermaid diagram in your documentation:</p> <pre><code>```mermaid\ngraph TD\n    A[Start] --&gt; B[Process]\n    B --&gt; C[End]\n```\n</code></pre>"},{"location":"features/mermaid-diagrams/#best-practices","title":"Best Practices","text":"<ol> <li>Use Descriptive Labels: Make node labels clear and meaningful</li> <li>Consistent Styling: Use subgraphs for logical grouping</li> <li>Appropriate Diagram Types: Choose the right diagram for your content</li> <li>Keep It Simple: Don't overcomplicate diagrams</li> <li>Use Colors Wisely: Leverage styling for emphasis</li> </ol>"},{"location":"features/mermaid-diagrams/#advanced-styling","title":"Advanced Styling","text":"<p>You can add custom styling to your diagrams:</p> <pre><code>graph TD\n    A[API Request] --&gt; B[Authentication]\n    B --&gt; C[Authorization]\n    C --&gt; D[Business Logic]\n    D --&gt; E[Data Access]\n    E --&gt; F[Response]\n\n    classDef apiStyle fill:#e3f2fd,stroke:#1976d2,stroke-width:2px\n    classDef processStyle fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\n    classDef dataStyle fill:#e8f5e8,stroke:#388e3c,stroke-width:2px\n\n    class A,F apiStyle\n    class B,C,D processStyle\n    class E dataStyle</code></pre>"},{"location":"features/mermaid-diagrams/#configuration","title":"\ud83d\udd27 Configuration","text":"<p>The documentation site is configured with:</p> <ul> <li>Theme: Auto (follows system dark/light mode)</li> <li>Primary Color: Blue (#1976d2) matching Material theme</li> <li>Auto-refresh: Diagrams update automatically during development</li> <li>High DPI: Support for crisp diagrams on retina displays</li> </ul>"},{"location":"features/mermaid-diagrams/#documentation-standards","title":"\ud83d\udcdd Documentation Standards","text":"<p>When adding Mermaid diagrams to documentation:</p> <ol> <li>Always include a text description before the diagram</li> <li>Use consistent terminology across all diagrams</li> <li>Reference framework concepts (Controllers, Handlers, etc.)</li> <li>Include diagrams in relevant sections of feature documentation</li> <li>Test rendering locally before committing</li> </ol>"},{"location":"features/mermaid-diagrams/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Architecture Overview</li> <li>CQRS &amp; Mediation</li> <li>Dependency Injection</li> <li>Sample Applications</li> </ul>"},{"location":"features/mermaid-diagrams/#external-resources","title":"\ud83d\udcda External Resources","text":"<ul> <li>Mermaid Documentation</li> <li>Mermaid Live Editor</li> <li>MkDocs Material</li> </ul>"},{"location":"features/mvc-controllers/","title":"\ud83d\udd0c MVC Controllers","text":"<p>Neuroglia provides a powerful MVC controller system built on top of FastAPI that enables class-based API development with automatic discovery, dependency injection, and OpenAPI documentation generation.</p>"},{"location":"features/mvc-controllers/#overview","title":"\ud83c\udfaf Overview","text":"<p>The MVC system provides:</p> <ul> <li>Class-based Controllers: Organize related endpoints in classes</li> <li>Automatic Discovery: Controllers are automatically found and registered</li> <li>Dependency Injection: Full DI support in controllers</li> <li>OpenAPI Integration: Automatic documentation generation</li> <li>Routing: Flexible routing with prefixes and tags</li> <li>Response Processing: Built-in result processing and error handling</li> </ul>"},{"location":"features/mvc-controllers/#controller-basics","title":"\ud83c\udfd7\ufe0f Controller Basics","text":""},{"location":"features/mvc-controllers/#creating-a-controller","title":"Creating a Controller","text":"<p>All controllers inherit from <code>ControllerBase</code>:</p> <pre><code>from neuroglia.mvc.controller_base import ControllerBase\nfrom neuroglia.dependency_injection.service_provider import ServiceProviderBase\nfrom neuroglia.mapping.mapper import Mapper\nfrom neuroglia.mediation.mediator import Mediator\n\nclass UsersController(ControllerBase):\n    def __init__(self, \n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n</code></pre>"},{"location":"features/mvc-controllers/#basic-endpoints","title":"Basic Endpoints","text":"<p>Use FastAPI decorators to define endpoints:</p> <pre><code>from classy_fastapi.decorators import get, post, put, delete\nfrom fastapi import status\nfrom typing import List\n\nclass UsersController(ControllerBase):\n\n    @get(\"/\", response_model=List[UserDto])\n    async def get_users(self) -&gt; List[UserDto]:\n        \"\"\"Get all users\"\"\"\n        query = GetAllUsersQuery()\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/{user_id}\", response_model=UserDto)\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        \"\"\"Get user by ID\"\"\"\n        query = GetUserByIdQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @post(\"/\", response_model=UserDto, status_code=status.HTTP_201_CREATED)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        \"\"\"Create a new user\"\"\"\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @put(\"/{user_id}\", response_model=UserDto)\n    async def update_user(self, user_id: str, update_user_dto: UpdateUserDto) -&gt; UserDto:\n        \"\"\"Update an existing user\"\"\"\n        command = self.mapper.map(update_user_dto, UpdateUserCommand)\n        command.user_id = user_id\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @delete(\"/{user_id}\", status_code=status.HTTP_204_NO_CONTENT)\n    async def delete_user(self, user_id: str):\n        \"\"\"Delete a user\"\"\"\n        command = DeleteUserCommand(user_id=user_id)\n        result = await self.mediator.execute_async(command)\n        self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#advanced-features","title":"\ud83d\ude80 Advanced Features","text":""},{"location":"features/mvc-controllers/#query-parameters","title":"Query Parameters","text":"<p>Handle query parameters for filtering and pagination:</p> <pre><code>from fastapi import Query\nfrom typing import Optional\n\nclass UsersController(ControllerBase):\n\n    @get(\"/\", response_model=List[UserDto])\n    async def get_users(self,\n                       department: Optional[str] = Query(None, description=\"Filter by department\"),\n                       active_only: bool = Query(True, description=\"Include only active users\"),\n                       page: int = Query(1, ge=1, description=\"Page number\"),\n                       page_size: int = Query(20, ge=1, le=100, description=\"Items per page\")) -&gt; List[UserDto]:\n        \"\"\"Get users with filtering and pagination\"\"\"\n\n        query = GetUsersQuery(\n            department=department,\n            active_only=active_only,\n            page=page,\n            page_size=page_size\n        )\n\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#request-body-validation","title":"Request Body Validation","text":"<p>Use Pydantic models for request validation:</p> <pre><code>from pydantic import BaseModel, Field, EmailStr\nfrom typing import Optional\n\nclass CreateUserDto(BaseModel):\n    email: EmailStr = Field(..., description=\"User's email address\")\n    first_name: str = Field(..., min_length=1, max_length=50, description=\"First name\")\n    last_name: str = Field(..., min_length=1, max_length=50, description=\"Last name\")\n    department: Optional[str] = Field(None, max_length=100, description=\"Department\")\n\n    class Config:\n        schema_extra = {\n            \"example\": {\n                \"email\": \"john.doe@company.com\",\n                \"first_name\": \"John\",\n                \"last_name\": \"Doe\",\n                \"department\": \"Engineering\"\n            }\n        }\n\nclass UsersController(ControllerBase):\n\n    @post(\"/\", response_model=UserDto, status_code=status.HTTP_201_CREATED)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        \"\"\"Create a new user\"\"\"\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#file-uploads","title":"File Uploads","text":"<p>Handle file uploads:</p> <pre><code>from fastapi import UploadFile, File\n\nclass UsersController(ControllerBase):\n\n    @post(\"/{user_id}/avatar\", response_model=UserDto)\n    async def upload_avatar(self, \n                           user_id: str,\n                           file: UploadFile = File(..., description=\"Avatar image\")) -&gt; UserDto:\n        \"\"\"Upload user avatar\"\"\"\n\n        # Validate file type\n        if not file.content_type.startswith('image/'):\n            return self.bad_request(\"File must be an image\")\n\n        # Create command\n        command = UploadUserAvatarCommand(\n            user_id=user_id,\n            file_name=file.filename,\n            file_content=await file.read(),\n            content_type=file.content_type\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#response-headers","title":"Response Headers","text":"<p>Set custom response headers:</p> <pre><code>from fastapi import Response\n\nclass UsersController(ControllerBase):\n\n    @get(\"/{user_id}/export\", response_class=Response)\n    async def export_user_data(self, user_id: str, response: Response):\n        \"\"\"Export user data as CSV\"\"\"\n\n        query = ExportUserDataQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n\n        if not result.is_success:\n            return self.process(result)\n\n        # Set CSV headers\n        response.headers[\"Content-Type\"] = \"text/csv\"\n        response.headers[\"Content-Disposition\"] = f\"attachment; filename=user_{user_id}.csv\"\n\n        return result.data\n</code></pre>"},{"location":"features/mvc-controllers/#controller-configuration","title":"\ud83c\udfaa Controller Configuration","text":""},{"location":"features/mvc-controllers/#custom-routing","title":"Custom Routing","text":"<p>Customize controller routing:</p> <pre><code>class UsersController(ControllerBase):\n    def __init__(self, service_provider, mapper, mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n        # Custom prefix and tags\n        self.router.prefix = \"/users\"\n        self.router.tags = [\"User Management\"]\n\n        # Add custom middleware to this controller\n        self.router.middleware(\"http\")(self.auth_middleware)\n\n    async def auth_middleware(self, request, call_next):\n        \"\"\"Custom authentication middleware for this controller\"\"\"\n        # Authentication logic\n        response = await call_next(request)\n        return response\n</code></pre>"},{"location":"features/mvc-controllers/#nested-controllers","title":"Nested Controllers","text":"<p>Create hierarchical resource structures:</p> <pre><code>class UserAccountsController(ControllerBase):\n    \"\"\"Handles user account operations\"\"\"\n\n    def __init__(self, service_provider, mapper, mediator):\n        super().__init__(service_provider, mapper, mediator)\n        self.router.prefix = \"/users/{user_id}/accounts\"\n\n    @get(\"/\", response_model=List[AccountDto])\n    async def get_user_accounts(self, user_id: str) -&gt; List[AccountDto]:\n        \"\"\"Get all accounts for a user\"\"\"\n        query = GetUserAccountsQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @post(\"/\", response_model=AccountDto, status_code=status.HTTP_201_CREATED)\n    async def create_account(self, user_id: str, create_account_dto: CreateAccountDto) -&gt; AccountDto:\n        \"\"\"Create a new account for a user\"\"\"\n        command = self.mapper.map(create_account_dto, CreateAccountCommand)\n        command.user_id = user_id\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#error-handling","title":"\ud83d\udee1\ufe0f Error Handling","text":""},{"location":"features/mvc-controllers/#built-in-error-responses","title":"Built-in Error Responses","text":"<p>Controllers include standard error responses:</p> <pre><code>class UsersController(ControllerBase):\n\n    @get(\"/{user_id}\", \n         response_model=UserDto,\n         responses=ControllerBase.error_responses)  # Adds 400, 404, 500 responses\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        \"\"\"Get user by ID\"\"\"\n        query = GetUserByIdQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)  # Automatically handles error responses\n</code></pre>"},{"location":"features/mvc-controllers/#custom-error-handling","title":"Custom Error Handling","text":"<p>Add custom error handling:</p> <pre><code>from fastapi import HTTPException\n\nclass UsersController(ControllerBase):\n\n    @post(\"/\", response_model=UserDto, status_code=status.HTTP_201_CREATED)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        \"\"\"Create a new user\"\"\"\n        try:\n            command = self.mapper.map(create_user_dto, CreateUserCommand)\n            result = await self.mediator.execute_async(command)\n            return self.process(result)\n\n        except EmailAlreadyExistsException:\n            raise HTTPException(\n                status_code=status.HTTP_409_CONFLICT,\n                detail=\"A user with this email already exists\"\n            )\n        except ValidationException as ex:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=str(ex)\n            )\n</code></pre>"},{"location":"features/mvc-controllers/#global-error-handling","title":"Global Error Handling","text":"<p>Use middleware for global error handling:</p> <pre><code>from neuroglia.hosting.web import ExceptionHandlingMiddleware\n\n# In main.py\napp.add_middleware(ExceptionHandlingMiddleware, service_provider=app.services)\n</code></pre>"},{"location":"features/mvc-controllers/#authentication-authorization","title":"\ud83d\udd10 Authentication &amp; Authorization","text":""},{"location":"features/mvc-controllers/#dependency-injection-for-auth","title":"Dependency Injection for Auth","text":"<p>Inject authentication services:</p> <pre><code>from fastapi import Depends\nfrom neuroglia.security import IAuthService, AuthUser\n\nclass UsersController(ControllerBase):\n\n    def __init__(self, \n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator,\n                 auth_service: IAuthService):\n        super().__init__(service_provider, mapper, mediator)\n        self.auth_service = auth_service\n\n    @get(\"/profile\", response_model=UserDto)\n    async def get_current_user(self, \n                              current_user: AuthUser = Depends(auth_service.get_current_user)) -&gt; UserDto:\n        \"\"\"Get current user's profile\"\"\"\n        query = GetUserByIdQuery(user_id=current_user.user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#role-based-authorization","title":"Role-based Authorization","text":"<p>Implement role-based access control:</p> <pre><code>from neuroglia.security import require_role\n\nclass UsersController(ControllerBase):\n\n    @get(\"/\", response_model=List[UserDto])\n    @require_role(\"admin\")  # Custom decorator\n    async def get_all_users(self) -&gt; List[UserDto]:\n        \"\"\"Get all users (admin only)\"\"\"\n        query = GetAllUsersQuery()\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @delete(\"/{user_id}\")\n    @require_role([\"admin\", \"manager\"])  # Multiple roles\n    async def delete_user(self, user_id: str):\n        \"\"\"Delete a user (admin or manager only)\"\"\"\n        command = DeleteUserCommand(user_id=user_id)\n        result = await self.mediator.execute_async(command)\n        self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#response-processing","title":"\ud83d\udcca Response Processing","text":""},{"location":"features/mvc-controllers/#the-process-method","title":"The <code>process</code> Method","text":"<p>The <code>process</code> method handles <code>OperationResult</code> objects automatically:</p> <pre><code># OperationResult with data\nresult = OperationResult.success(user_dto)\nreturn self.process(result)  # Returns user_dto with 200 status\n\n# OperationResult with error\nresult = OperationResult.not_found(\"User not found\")\nreturn self.process(result)  # Raises HTTPException with 404 status\n\n# OperationResult created\nresult = OperationResult.created(user_dto)\nreturn self.process(result)  # Returns user_dto with 201 status\n</code></pre>"},{"location":"features/mvc-controllers/#custom-response-processing","title":"Custom Response Processing","text":"<p>Override response processing for special cases:</p> <pre><code>class UsersController(ControllerBase):\n\n    @get(\"/{user_id}\", response_model=UserDto)\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        \"\"\"Get user by ID\"\"\"\n        query = GetUserByIdQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n\n        # Custom processing\n        if not result.is_success:\n            if result.status_code == 404:\n                # Log the attempt\n                self.logger.warning(f\"Attempt to access non-existent user: {user_id}\")\n            return self.process(result)\n\n        # Add custom headers for successful responses\n        response = self.process(result)\n        # Custom logic here\n        return response\n</code></pre>"},{"location":"features/mvc-controllers/#testing-controllers","title":"\ud83e\uddea Testing Controllers","text":""},{"location":"features/mvc-controllers/#unit-testing","title":"Unit Testing","text":"<p>Test controllers with mocked dependencies:</p> <pre><code>import pytest\nfrom unittest.mock import Mock, AsyncMock\n\n@pytest.mark.asyncio\nasync def test_get_user_success():\n    # Arrange\n    mock_mediator = Mock()\n    mock_mediator.execute_async = AsyncMock(return_value=OperationResult.success(test_user_dto))\n\n    controller = UsersController(\n        service_provider=mock_service_provider,\n        mapper=mock_mapper,\n        mediator=mock_mediator\n    )\n\n    # Act\n    result = await controller.get_user(\"user123\")\n\n    # Assert\n    assert result == test_user_dto\n    mock_mediator.execute_async.assert_called_once()\n</code></pre>"},{"location":"features/mvc-controllers/#integration-testing","title":"Integration Testing","text":"<p>Test controllers with TestClient:</p> <pre><code>from fastapi.testclient import TestClient\n\ndef test_create_user_integration():\n    # Arrange\n    client = TestClient(app)\n    user_data = {\n        \"email\": \"test@example.com\",\n        \"first_name\": \"John\",\n        \"last_name\": \"Doe\"\n    }\n\n    # Act\n    response = client.post(\"/api/v1/users\", json=user_data)\n\n    # Assert\n    assert response.status_code == 201\n\n    created_user = response.json()\n    assert created_user[\"email\"] == user_data[\"email\"]\n    assert \"id\" in created_user\n</code></pre>"},{"location":"features/mvc-controllers/#api-testing","title":"API Testing","text":"<p>Test the complete API flow:</p> <pre><code>def test_user_crud_flow():\n    client = TestClient(app)\n\n    # Create user\n    create_response = client.post(\"/api/v1/users\", json=test_user_data)\n    assert create_response.status_code == 201\n    user = create_response.json()\n    user_id = user[\"id\"]\n\n    # Get user\n    get_response = client.get(f\"/api/v1/users/{user_id}\")\n    assert get_response.status_code == 200\n    assert get_response.json()[\"id\"] == user_id\n\n    # Update user\n    update_data = {\"first_name\": \"Jane\"}\n    update_response = client.put(f\"/api/v1/users/{user_id}\", json=update_data)\n    assert update_response.status_code == 200\n    assert update_response.json()[\"first_name\"] == \"Jane\"\n\n    # Delete user\n    delete_response = client.delete(f\"/api/v1/users/{user_id}\")\n    assert delete_response.status_code == 204\n\n    # Verify deletion\n    get_deleted_response = client.get(f\"/api/v1/users/{user_id}\")\n    assert get_deleted_response.status_code == 404\n</code></pre>"},{"location":"features/mvc-controllers/#best-practices","title":"\ud83d\ude80 Best Practices","text":""},{"location":"features/mvc-controllers/#1-keep-controllers-thin","title":"1. Keep Controllers Thin","text":"<p>Controllers should delegate to the application layer:</p> <pre><code># Good - Thin controller\nclass UsersController(ControllerBase):\n    @post(\"/\", response_model=UserDto)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n# Avoid - Business logic in controller\nclass UsersController(ControllerBase):\n    @post(\"/\", response_model=UserDto)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        # Validate email\n        if not self.is_valid_email(create_user_dto.email):\n            raise HTTPException(400, \"Invalid email\")\n\n        # Check if user exists\n        existing = await self.user_repo.get_by_email(create_user_dto.email)\n        if existing:\n            raise HTTPException(409, \"User exists\")\n\n        # Create user\n        user = User(...)\n        # ... more business logic\n</code></pre>"},{"location":"features/mvc-controllers/#2-use-dtos-for-api-contracts","title":"2. Use DTOs for API Contracts","text":"<p>Always use DTOs to define your API contracts:</p> <pre><code># API DTOs\nclass CreateUserDto(BaseModel):\n    email: str\n    first_name: str\n    last_name: str\n\nclass UserDto(BaseModel):\n    id: str\n    email: str\n    first_name: str\n    last_name: str\n    created_at: datetime\n\n# Domain entities stay separate\nclass User(Entity[str]):\n    def __init__(self, email: str, first_name: str, last_name: str):\n        # Domain logic\n        pass\n</code></pre>"},{"location":"features/mvc-controllers/#3-consistent-error-handling","title":"3. Consistent Error Handling","text":"<p>Use consistent patterns for error handling:</p> <pre><code>class UsersController(ControllerBase):\n\n    @get(\"/{user_id}\", \n         response_model=UserDto,\n         responses={\n             404: {\"description\": \"User not found\"},\n             400: {\"description\": \"Invalid user ID format\"}\n         })\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        # Validate input format\n        if not self.is_valid_uuid(user_id):\n            return self.bad_request(\"Invalid user ID format\")\n\n        # Execute query\n        query = GetUserByIdQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n\n        # Process will handle 404 automatically\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#4-document-your-apis","title":"4. Document Your APIs","text":"<p>Provide comprehensive API documentation:</p> <pre><code>class UsersController(ControllerBase):\n\n    @post(\"/\",\n          response_model=UserDto,\n          status_code=status.HTTP_201_CREATED,\n          summary=\"Create a new user\",\n          description=\"Creates a new user account in the system\",\n          response_description=\"The created user\",\n          tags=[\"User Management\"])\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        \"\"\"\n        Create a new user account.\n\n        - **email**: User's email address (must be unique)\n        - **first_name**: User's first name\n        - **last_name**: User's last name\n\n        Returns the created user with generated ID and timestamps.\n        \"\"\"\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#5-version-your-apis","title":"5. Version Your APIs","text":"<p>Plan for API versioning:</p> <pre><code># v1 controller\nclass V1UsersController(ControllerBase):\n    def __init__(self, service_provider, mapper, mediator):\n        super().__init__(service_provider, mapper, mediator)\n        self.router.prefix = \"/v1/users\"\n\n# v2 controller with breaking changes\nclass V2UsersController(ControllerBase):\n    def __init__(self, service_provider, mapper, mediator):\n        super().__init__(service_provider, mapper, mediator)\n        self.router.prefix = \"/v2/users\"\n</code></pre>"},{"location":"features/mvc-controllers/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Basic controller usage</li> <li>Architecture Guide - How controllers fit in the architecture</li> <li>CQRS &amp; Mediation - Using mediator in controllers</li> <li>Dependency Injection - DI in controllers</li> <li>Data Access - Working with data in controllers</li> </ul>"},{"location":"features/resource-oriented-architecture/","title":"\ud83c\udfaf Resource Oriented Architecture (ROA)","text":"<p>Resource Oriented Architecture is a powerful pattern for building systems that manage resources through their lifecycle, similar to how Kubernetes manages cluster resources. Neuroglia provides comprehensive support for ROA patterns including watchers, controllers, and reconciliation loops.</p>"},{"location":"features/resource-oriented-architecture/#overview","title":"\ud83c\udfaf Overview","text":"<p>ROA provides:</p> <ul> <li>\ud83d\udcca Resource Management: Declarative resource definitions with desired vs actual state</li> <li>\ud83d\udc40 Watchers: Continuous monitoring of resource changes through polling or event streams</li> <li>\ud83c\udfae Controllers: Business logic that responds to resource changes and implements state transitions</li> <li>\ud83d\udd04 Reconciliation: Periodic loops that ensure system consistency and handle drift detection</li> <li>\ud83d\udee1\ufe0f Safety Mechanisms: Timeout handling, error recovery, and corrective actions</li> </ul>"},{"location":"features/resource-oriented-architecture/#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<pre><code>graph TB\n    subgraph \"\ud83d\udcca Resource Layer\"\n        A[Resource Definition]\n        B[Resource Storage]\n        C[Resource Events]\n    end\n\n    subgraph \"\ud83d\udc40 Observation Layer\"\n        D[Watcher] --&gt; E[Event Stream]\n        F[Poller] --&gt; G[Change Detection]\n    end\n\n    subgraph \"\ud83c\udfae Control Layer\"\n        H[Controller] --&gt; I[Business Logic]\n        I --&gt; J[State Transitions]\n        I --&gt; K[Action Execution]\n    end\n\n    subgraph \"\ud83d\udd04 Reconciliation Layer\"\n        L[Reconciliation Loop] --&gt; M[Drift Detection]\n        M --&gt; N[Corrective Actions]\n        N --&gt; O[State Restoration]\n    end\n\n    subgraph \"\ud83d\udee1\ufe0f Safety Layer\"\n        P[Error Handling] --&gt; Q[Retry Logic]\n        Q --&gt; R[Circuit Breaker]\n        R --&gt; S[Timeout Management]\n    end\n\n    A --&gt; B\n    B --&gt; C\n    C --&gt; D\n    C --&gt; F\n    E --&gt; H\n    G --&gt; H\n    H --&gt; L\n    L --&gt; P\n\n    style A fill:#e3f2fd\n    style H fill:#f3e5f5\n    style L fill:#e8f5e8\n    style P fill:#fff3e0</code></pre>"},{"location":"features/resource-oriented-architecture/#core-components","title":"\ud83c\udfd7\ufe0f Core Components","text":""},{"location":"features/resource-oriented-architecture/#resource-definition","title":"Resource Definition","text":"<p>Resources are declarative objects that define desired state:</p> <pre><code>@dataclass\nclass LabInstanceResource:\n    api_version: str = \"lab.neuroglia.com/v1\"\n    kind: str = \"LabInstance\"\n    metadata: Dict[str, Any] = None\n    spec: Dict[str, Any] = None      # Desired state\n    status: Dict[str, Any] = None    # Current state\n</code></pre>"},{"location":"features/resource-oriented-architecture/#watcher-pattern","title":"Watcher Pattern","text":"<p>Watchers continuously monitor resources for changes:</p> <pre><code>class LabInstanceWatcher:\n    async def start_watching(self):\n        while self.is_running:\n            # Poll for changes since last known version\n            changes = self.storage.list_resources(since_version=self.last_resource_version)\n\n            for resource in changes:\n                await self._handle_resource_change(resource)\n\n            await asyncio.sleep(self.poll_interval)\n</code></pre>"},{"location":"features/resource-oriented-architecture/#controller-pattern","title":"Controller Pattern","text":"<p>Controllers respond to resource changes with business logic:</p> <pre><code>class LabInstanceController:\n    async def handle_resource_event(self, resource: LabInstanceResource):\n        current_state = resource.status.get('state')\n\n        if current_state == ResourceState.PENDING.value:\n            await self._start_provisioning(resource)\n        elif current_state == ResourceState.PROVISIONING.value:\n            await self._check_provisioning_status(resource)\n</code></pre>"},{"location":"features/resource-oriented-architecture/#reconciliation-loop","title":"Reconciliation Loop","text":"<p>Reconcilers ensure eventual consistency:</p> <pre><code>class LabInstanceScheduler:\n    async def start_reconciliation(self):\n        while self.is_running:\n            await self._reconcile_all_resources()\n            await asyncio.sleep(self.reconcile_interval)\n\n    async def _reconcile_resource(self, resource):\n        # Check for stuck states, timeouts, and drift\n        # Take corrective actions as needed\n</code></pre>"},{"location":"features/resource-oriented-architecture/#key-patterns","title":"\ud83d\ude80 Key Patterns","text":""},{"location":"features/resource-oriented-architecture/#1-declarative-state-management","title":"1. Declarative State Management","text":"<p>Resources define what should exist, not how to create it:</p> <pre><code># Desired state (spec)\nspec = {\n    'template': 'python-basics',\n    'duration': '60m',\n    'studentEmail': 'student@example.com'\n}\n\n# Current state (status)\nstatus = {\n    'state': 'ready',\n    'endpoint': 'https://lab-instance.example.com',\n    'readyAt': '2025-09-09T21:34:19Z'\n}\n</code></pre>"},{"location":"features/resource-oriented-architecture/#2-event-driven-processing","title":"2. Event-Driven Processing","text":"<p>Watchers detect changes and notify controllers immediately:</p> <pre><code>Resource Change \u2192 Watcher Detection \u2192 Controller Response \u2192 State Update\n</code></pre>"},{"location":"features/resource-oriented-architecture/#3-asynchronous-reconciliation","title":"3. Asynchronous Reconciliation","text":"<p>Controllers handle immediate responses while reconcilers provide safety:</p> <pre><code># Controller: Immediate response to events\nasync def handle_resource_event(self, resource):\n    if resource.state == PENDING:\n        await self.start_provisioning(resource)\n\n# Reconciler: Periodic safety checks\nasync def reconcile_resource(self, resource):\n    if self.is_stuck_provisioning(resource):\n        await self.mark_as_failed(resource)\n</code></pre>"},{"location":"features/resource-oriented-architecture/#4-state-machine-implementation","title":"4. State Machine Implementation","text":"<p>Resources progress through well-defined states:</p> <pre><code>PENDING \u2192 PROVISIONING \u2192 READY \u2192 (cleanup) \u2192 DELETING \u2192 DELETED\n    \u2193                      \u2193\n  FAILED              \u2190 FAILED\n</code></pre>"},{"location":"features/resource-oriented-architecture/#execution-model","title":"\u26a1 Execution Model","text":""},{"location":"features/resource-oriented-architecture/#timing-and-coordination","title":"Timing and Coordination","text":"<ul> <li>Watchers: Poll every 2-5 seconds for near-real-time responsiveness</li> <li>Controllers: Respond immediately to detected changes</li> <li>Reconcilers: Run every 10-30 seconds for consistency checks</li> </ul>"},{"location":"features/resource-oriented-architecture/#concurrent-processing","title":"Concurrent Processing","text":"<p>All components run concurrently:</p> <pre><code>async def main():\n    # Start all components concurrently\n    watcher_task = asyncio.create_task(watcher.start_watching())\n    scheduler_task = asyncio.create_task(scheduler.start_reconciliation())\n\n    # Controllers are event-driven (no separate task needed)\n    watcher.add_event_handler(controller.handle_resource_event)\n</code></pre>"},{"location":"features/resource-oriented-architecture/#safety-and-reliability","title":"\ud83d\udee1\ufe0f Safety and Reliability","text":""},{"location":"features/resource-oriented-architecture/#timeout-handling","title":"Timeout Handling","text":"<p>Reconcilers detect and handle stuck states:</p> <pre><code>if resource.state == PROVISIONING and age &gt; timeout_threshold:\n    await self.mark_as_failed(resource, \"Provisioning timeout\")\n</code></pre>"},{"location":"features/resource-oriented-architecture/#error-recovery","title":"Error Recovery","text":"<p>Controllers and reconcilers implement retry logic:</p> <pre><code>try:\n    await self.provision_lab_instance(resource)\nexcept Exception as e:\n    resource.status['retries'] = resource.status.get('retries', 0) + 1\n    if resource.status['retries'] &lt; max_retries:\n        await self.schedule_retry(resource)\n    else:\n        await self.mark_as_failed(resource, str(e))\n</code></pre>"},{"location":"features/resource-oriented-architecture/#drift-detection","title":"Drift Detection","text":"<p>Reconcilers verify that actual state matches desired state:</p> <pre><code>async def check_drift(self, resource):\n    actual_state = await self.get_actual_infrastructure_state(resource)\n    desired_state = resource.spec\n\n    if actual_state != desired_state:\n        await self.correct_drift(resource, actual_state, desired_state)\n</code></pre>"},{"location":"features/resource-oriented-architecture/#observability","title":"\ud83d\udcca Observability","text":""},{"location":"features/resource-oriented-architecture/#metrics-and-logging","title":"Metrics and Logging","text":"<p>ROA components provide rich observability:</p> <pre><code>logger.info(f\"\ud83d\udd0d Watcher detected change: {resource_id} -&gt; {state}\")\nlogger.info(f\"\ud83c\udfae Controller processing: {resource_id} (state: {state})\")\nlogger.info(f\"\ud83d\udd04 Reconciling {len(resources)} resources\")\nlogger.warning(f\"\u26a0\ufe0f Reconciler: Resource stuck: {resource_id}\")\n</code></pre>"},{"location":"features/resource-oriented-architecture/#resource-versioning","title":"Resource Versioning","text":"<p>Track changes with resource versions:</p> <pre><code>resource.metadata['resourceVersion'] = str(self.next_version())\nresource.metadata['lastModified'] = datetime.now(timezone.utc).isoformat()\n</code></pre>"},{"location":"features/resource-oriented-architecture/#configuration","title":"\ud83d\udd27 Configuration","text":""},{"location":"features/resource-oriented-architecture/#tuning-parameters","title":"Tuning Parameters","text":"<p>Adjust timing for your use case:</p> <pre><code># Development: Fast feedback\nwatcher = LabInstanceWatcher(storage, poll_interval=1.0)\nscheduler = LabInstanceScheduler(storage, reconcile_interval=5.0)\n\n# Production: Balanced performance\nwatcher = LabInstanceWatcher(storage, poll_interval=5.0)\nscheduler = LabInstanceScheduler(storage, reconcile_interval=30.0)\n</code></pre>"},{"location":"features/resource-oriented-architecture/#scaling-considerations","title":"Scaling Considerations","text":"<ul> <li>Multiple Watchers: Use resource sharding for scale</li> <li>Controller Parallelism: Process multiple resources concurrently</li> <li>Reconciler Batching: Group operations for efficiency</li> </ul>"},{"location":"features/resource-oriented-architecture/#use-cases","title":"\ud83c\udfaf Use Cases","text":"<p>ROA is ideal for:</p> <ul> <li>Infrastructure Management: Cloud resources, containers, services</li> <li>Workflow Orchestration: Multi-step processes with dependencies</li> <li>Resource Lifecycle: Provisioning, monitoring, cleanup</li> <li>System Integration: Managing external system state</li> <li>DevOps Automation: CI/CD pipelines, deployment management</li> </ul>"},{"location":"features/resource-oriented-architecture/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\ud83c\udfd7\ufe0f Watcher &amp; Reconciliation Patterns - Detailed pattern explanations</li> <li>\u26a1 Execution Flow - How components coordinate</li> <li>\ud83e\uddea Lab Resource Manager Sample - Complete ROA implementation</li> <li>\ud83c\udfaf CQRS &amp; Mediation - Command/Query patterns used in ROA</li> <li>\ud83d\uddc4\ufe0f Data Access - Repository patterns for resource storage</li> </ul>"},{"location":"features/watcher-reconciliation-execution/","title":"How Watcher and Reconciliation Loop Execute","text":"<p>This document provides a detailed explanation of how the Resource Watcher and Reconciliation Loop patterns execute in our Resource Oriented Architecture (ROA) implementation.</p>"},{"location":"features/watcher-reconciliation-execution/#execution-flow-overview","title":"\ud83d\udd04 Execution Flow Overview","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Resource       \u2502    \u2502  Resource       \u2502    \u2502  Background     \u2502\n\u2502  Watcher        \u2502    \u2502  Controller     \u2502    \u2502  Scheduler      \u2502\n\u2502                 \u2502    \u2502                 \u2502    \u2502                 \u2502\n\u2502 \u2022 Polls storage \u2502\u2500\u2500\u2500\u25b6\u2502 \u2022 Reconciles    \u2502\u25c4\u2500\u2500\u25b6\u2502 \u2022 Monitors all  \u2502\n\u2502 \u2022 Detects \u0394     \u2502    \u2502   resources     \u2502    \u2502   resources     \u2502\n\u2502 \u2022 Emits events  \u2502    \u2502 \u2022 Updates state \u2502    \u2502 \u2022 Enforces      \u2502\n\u2502 \u2022 Triggers      \u2502    \u2502 \u2022 Publishes     \u2502    \u2502   lifecycle     \u2502\n\u2502   reconciliation\u2502    \u2502   events        \u2502    \u2502                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                       \u2502                       \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                 \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502    Event Bus &amp;          \u2502\n                    \u2502  Cloud Events           \u2502\n                    \u2502                         \u2502\n                    \u2502 \u2022 Resource created      \u2502\n                    \u2502 \u2022 Resource updated      \u2502\n                    \u2502 \u2022 Status changed        \u2502\n                    \u2502 \u2022 Reconciliation done   \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"features/watcher-reconciliation-execution/#1-resource-watcher-execution","title":"1\ufe0f\u20e3 Resource Watcher Execution","text":""},{"location":"features/watcher-reconciliation-execution/#polling-loop-implementation","title":"Polling Loop Implementation","text":"<pre><code>class ResourceWatcherBase:\n    async def _watch_loop(self, namespace=None, label_selector=None):\n        \"\"\"\n        Main watch loop - executes continuously:\n\n        1. List current resources from storage\n        2. Compare with cached resources\n        3. Detect changes (CREATED, UPDATED, DELETED, STATUS_UPDATED)\n        4. Process each change\n        5. Update cache\n        6. Sleep until next poll\n        \"\"\"\n        while self._watching:\n            try:\n                # STEP 1: Get current state from storage\n                current_resources = await self._list_resources(namespace, label_selector)\n                current_resource_map = {r.id: r for r in current_resources}\n\n                # STEP 2: Detect changes by comparing with cache\n                changes = self._detect_changes(current_resource_map)\n\n                # STEP 3: Process each detected change\n                for change in changes:\n                    await self._process_change(change)\n\n                # STEP 4: Update cache with current state\n                self._resource_cache = current_resource_map\n\n                # STEP 5: Wait before next poll\n                await asyncio.sleep(self.watch_interval)\n\n            except Exception as e:\n                log.error(f\"Error in watch loop: {e}\")\n                await asyncio.sleep(self.watch_interval)\n</code></pre>"},{"location":"features/watcher-reconciliation-execution/#change-detection-algorithm","title":"Change Detection Algorithm","text":"<pre><code>def _detect_changes(self, current_resources):\n    \"\"\"\n    Change detection compares current vs cached state:\n\n    \u2022 CREATED: resource_id in current but not in cache\n    \u2022 DELETED: resource_id in cache but not in current  \n    \u2022 UPDATED: generation increased (spec changed)\n    \u2022 STATUS_UPDATED: status fields changed\n    \"\"\"\n    changes = []\n    current_ids = set(current_resources.keys())\n    cached_ids = set(self._resource_cache.keys())\n\n    # New resources (CREATED)\n    for resource_id in current_ids - cached_ids:\n        changes.append(ResourceChangeEvent(\n            change_type=ResourceChangeType.CREATED,\n            resource=current_resources[resource_id]\n        ))\n\n    # Deleted resources (DELETED)  \n    for resource_id in cached_ids - current_ids:\n        changes.append(ResourceChangeEvent(\n            change_type=ResourceChangeType.DELETED,\n            resource=self._resource_cache[resource_id]\n        ))\n\n    # Modified resources (UPDATED/STATUS_UPDATED)\n    for resource_id in current_ids &amp; cached_ids:\n        current = current_resources[resource_id]\n        cached = self._resource_cache[resource_id]\n\n        # Spec changed (generation incremented)\n        if current.metadata.generation &gt; cached.metadata.generation:\n            changes.append(ResourceChangeEvent(\n                change_type=ResourceChangeType.UPDATED,\n                resource=current,\n                old_resource=cached\n            ))\n        # Status changed\n        elif self._has_status_changed(current, cached):\n            changes.append(ResourceChangeEvent(\n                change_type=ResourceChangeType.STATUS_UPDATED,\n                resource=current,\n                old_resource=cached\n            ))\n\n    return changes\n</code></pre>"},{"location":"features/watcher-reconciliation-execution/#event-processing-and-controller-triggering","title":"Event Processing and Controller Triggering","text":"<pre><code>async def _process_change(self, change):\n    \"\"\"\n    When changes are detected:\n\n    1. Call registered change handlers (like controllers)\n    2. Publish CloudEvents to event bus\n    3. Handle errors gracefully\n    \"\"\"\n    # STEP 1: Call all registered handlers\n    for handler in self._change_handlers:\n        try:\n            if asyncio.iscoroutinefunction(handler):\n                await handler(change)  # Triggers controller reconciliation\n            else:\n                handler(change)\n        except Exception as e:\n            log.error(f\"Change handler failed: {e}\")\n\n    # STEP 2: Publish event to broader system\n    await self._publish_change_event(change)\n\n# Example: Lab Instance Watcher\nclass LabInstanceWatcher(ResourceWatcherBase):\n    def __init__(self, repository, controller, event_publisher):\n        super().__init__(event_publisher)\n        # Register controller as change handler\n        self.add_change_handler(self._handle_resource_change)\n\n    async def _handle_resource_change(self, change):\n        \"\"\"Called automatically when changes detected\"\"\"\n        if change.change_type in [ResourceChangeType.CREATED, ResourceChangeType.UPDATED]:\n            # Trigger reconciliation for new/updated resources\n            await self.controller.reconcile(change.resource)\n        elif change.change_type == ResourceChangeType.DELETED:\n            # Trigger cleanup for deleted resources\n            await self.controller.finalize(change.resource)\n</code></pre>"},{"location":"features/watcher-reconciliation-execution/#2-reconciliation-loop-execution","title":"2\ufe0f\u20e3 Reconciliation Loop Execution","text":""},{"location":"features/watcher-reconciliation-execution/#controller-reconciliation-pattern","title":"Controller Reconciliation Pattern","text":"<pre><code>class ResourceControllerBase:\n    async def reconcile(self, resource):\n        \"\"\"\n        Main reconciliation entry point:\n\n        1. Check if reconciliation is needed\n        2. Execute reconciliation logic with timeout\n        3. Handle results (success, failure, requeue)\n        4. Update resource status\n        5. Emit reconciliation events\n        \"\"\"\n        start_time = datetime.now()\n\n        try:\n            # STEP 1: Check if reconciliation needed\n            if not resource.needs_reconciliation():\n                log.debug(f\"Resource {resource.metadata.name} does not need reconciliation\")\n                return\n\n            # STEP 2: Execute reconciliation with timeout\n            result = await asyncio.wait_for(\n                self._do_reconcile(resource),\n                timeout=self._reconciliation_timeout.total_seconds()\n            )\n\n            # STEP 3: Handle reconciliation result\n            await self._handle_reconciliation_result(resource, result, start_time)\n\n        except asyncio.TimeoutError:\n            await self._handle_reconciliation_error(resource, TimeoutError(), start_time)\n        except Exception as e:\n            await self._handle_reconciliation_error(resource, e, start_time)\n</code></pre>"},{"location":"features/watcher-reconciliation-execution/#lab-instance-controller-implementation","title":"Lab Instance Controller Implementation","text":"<pre><code>class LabInstanceController(ResourceControllerBase):\n    async def _do_reconcile(self, resource: LabInstanceRequest):\n        \"\"\"\n        Lab-specific reconciliation logic:\n\n        \u2022 PENDING \u2192 PROVISIONING: Check if should start\n        \u2022 PROVISIONING \u2192 RUNNING: Start container\n        \u2022 RUNNING \u2192 COMPLETED: Monitor completion\n        \u2022 Handle errors and timeouts\n        \"\"\"\n        current_phase = resource.status.phase\n\n        if current_phase == LabInstancePhase.PENDING:\n            if resource.should_start_now():\n                # Time to start - provision container\n                success = await self._provision_lab_instance(resource)\n                return ReconciliationResult.success() if success else ReconciliationResult.requeue()\n            else:\n                # Not time yet - requeue when it should start\n                remaining_time = resource.get_time_until_start()\n                return ReconciliationResult.requeue_after(remaining_time)\n\n        elif current_phase == LabInstancePhase.PROVISIONING:\n            # Check if container is ready\n            if await self._is_container_ready(resource):\n                resource.transition_to_running()\n                await self._repository.save_async(resource)\n                return ReconciliationResult.success()\n            else:\n                # Still provisioning - check again soon\n                return ReconciliationResult.requeue_after(timedelta(seconds=30))\n\n        elif current_phase == LabInstancePhase.RUNNING:\n            # Monitor for completion or timeout\n            if resource.is_expired():\n                await self._timeout_lab_instance(resource)\n                return ReconciliationResult.success()\n            else:\n                # Check again when it should expire\n                remaining_time = resource.get_remaining_duration()\n                return ReconciliationResult.requeue_after(remaining_time)\n\n        # No action needed for terminal phases\n        return ReconciliationResult.success()\n</code></pre>"},{"location":"features/watcher-reconciliation-execution/#3-background-scheduler-as-reconciliation-loop","title":"3\ufe0f\u20e3 Background Scheduler as Reconciliation Loop","text":""},{"location":"features/watcher-reconciliation-execution/#scheduler-service-implementation","title":"Scheduler Service Implementation","text":"<pre><code>class LabInstanceSchedulerService(HostedService):\n    \"\"\"\n    Background service that acts as a reconciliation loop:\n\n    \u2022 Runs independently of watchers\n    \u2022 Periodically scans all resources\n    \u2022 Applies policies and enforces state\n    \u2022 Handles bulk operations\n    \"\"\"\n\n    async def _run_scheduler_loop(self):\n        \"\"\"Main scheduler loop - runs continuously\"\"\"\n        cleanup_counter = 0\n\n        while self._running:\n            try:\n                # PHASE 1: Process scheduled instances (PENDING \u2192 PROVISIONING)\n                await self._process_scheduled_instances()\n\n                # PHASE 2: Monitor running instances (RUNNING state health)\n                await self._process_running_instances()\n\n                # PHASE 3: Periodic cleanup (expired/failed instances)\n                cleanup_counter += self._scheduler_interval\n                if cleanup_counter &gt;= self._cleanup_interval:\n                    await self._cleanup_expired_instances()\n                    cleanup_counter = 0\n\n                # Wait before next iteration\n                await asyncio.sleep(self._scheduler_interval)\n\n            except Exception as e:\n                log.error(f\"Error in scheduler loop: {e}\")\n                await asyncio.sleep(self._scheduler_interval)\n\n    async def _process_scheduled_instances(self):\n        \"\"\"Reconcile PENDING instances that should start\"\"\"\n        try:\n            # Find all pending instances that are scheduled\n            pending_instances = await self._repository.find_scheduled_pending_async()\n\n            for instance in pending_instances:\n                if instance.should_start_now():\n                    # Move toward desired state: PENDING \u2192 PROVISIONING \u2192 RUNNING\n                    await self._start_lab_instance(instance)\n\n        except Exception as e:\n            log.error(f\"Error processing scheduled instances: {e}\")\n\n    async def _process_running_instances(self):\n        \"\"\"Reconcile RUNNING instances for health/completion\"\"\"\n        try:\n            running_instances = await self._repository.find_running_instances_async()\n\n            for instance in running_instances:\n                # Check actual container state vs desired state\n                container_status = await self._container_service.get_container_status_async(\n                    instance.status.container_id\n                )\n\n                # Reconcile based on actual vs desired state\n                if container_status == \"stopped\":\n                    # Container stopped - instance should complete\n                    await self._complete_lab_instance(instance)\n                elif container_status == \"error\":\n                    # Container errored - instance should fail\n                    await self._fail_lab_instance(instance, \"Container error\")\n                elif instance.is_expired():\n                    # Policy violation - enforce timeout\n                    await self._timeout_lab_instance(instance)\n\n        except Exception as e:\n            log.error(f\"Error processing running instances: {e}\")\n</code></pre>"},{"location":"features/watcher-reconciliation-execution/#4-integration-patterns-and-event-flow","title":"4\ufe0f\u20e3 Integration Patterns and Event Flow","text":""},{"location":"features/watcher-reconciliation-execution/#complete-event-flow-example","title":"Complete Event Flow Example","text":"<pre><code>1. User creates LabInstanceRequest\n   \u2514\u2500 Resource saved to storage\n\n2. Watcher detects CREATED event (next poll cycle)\n   \u251c\u2500 Publishes labinstancerequest.created CloudEvent  \n   \u2514\u2500 Triggers controller.reconcile(resource)\n\n3. Controller reconciliation\n   \u251c\u2500 Checks: resource.should_start_now() \u2192 false (scheduled for later)\n   \u2514\u2500 Returns: ReconciliationResult.requeue_after(delay)\n\n4. Scheduler loop (independent polling)\n   \u251c\u2500 Finds pending instances that should start\n   \u251c\u2500 Calls _start_lab_instance(resource)\n   \u2502  \u251c\u2500 Transitions: PENDING \u2192 PROVISIONING\n   \u2502  \u251c\u2500 Creates container\n   \u2502  \u2514\u2500 Transitions: PROVISIONING \u2192 RUNNING\n   \u2514\u2500 Updates resource status in storage\n\n5. Watcher detects STATUS_UPDATED event\n   \u251c\u2500 Publishes labinstancerequest.status_updated CloudEvent\n   \u2514\u2500 Triggers controller.reconcile(resource) again\n\n6. Controller reconciliation (RUNNING phase)\n   \u251c\u2500 Calculates when instance should expire\n   \u2514\u2500 Returns: ReconciliationResult.requeue_after(remaining_time)\n\n7. Time passes... scheduler monitors container health\n\n8. Container completes/fails/times out\n   \u251c\u2500 Scheduler detects state change\n   \u251c\u2500 Updates resource: RUNNING \u2192 COMPLETED/FAILED/TIMEOUT\n   \u2514\u2500 Cleans up container resources\n\n9. Watcher detects final STATUS_UPDATED event\n   \u251c\u2500 Publishes final CloudEvent\n   \u2514\u2500 Controller reconciliation confirms no action needed\n</code></pre>"},{"location":"features/watcher-reconciliation-execution/#timing-and-coordination","title":"Timing and Coordination","text":"Component Frequency Purpose Watcher 5-10 seconds Detect changes, trigger reactive reconciliation Scheduler 30-60 seconds Proactive reconciliation, policy enforcement Controller Event-driven Handle specific resource changes"},{"location":"features/watcher-reconciliation-execution/#error-handling-and-resilience","title":"Error Handling and Resilience","text":"<pre><code># Watcher error handling\nasync def _watch_loop(self):\n    while self._watching:\n        try:\n            # Process changes\n            pass\n        except Exception as e:\n            log.error(f\"Watch loop error: {e}\")\n            await asyncio.sleep(self.watch_interval)  # Continue watching\n\n# Controller error handling  \nasync def reconcile(self, resource):\n    try:\n        result = await asyncio.wait_for(self._do_reconcile(resource), timeout=300)\n    except asyncio.TimeoutError:\n        # Handle timeout - mark for retry\n        result = ReconciliationResult.requeue()\n    except Exception as e:\n        # Handle error - exponential backoff\n        result = ReconciliationResult.failed(e)\n\n# Scheduler error handling\nasync def _run_scheduler_loop(self):\n    while self._running:\n        try:\n            # Process all phases\n            pass\n        except Exception as e:\n            log.error(f\"Scheduler error: {e}\")\n            await asyncio.sleep(self._scheduler_interval)  # Continue scheduling\n</code></pre>"},{"location":"features/watcher-reconciliation-execution/#observability-and-monitoring","title":"\ud83d\udcca Observability and Monitoring","text":""},{"location":"features/watcher-reconciliation-execution/#key-metrics-to-monitor","title":"Key Metrics to Monitor","text":"<pre><code># Watcher metrics\n{\n    \"watch_loop_iterations\": 1234,\n    \"changes_detected\": 56,\n    \"events_published\": 78,\n    \"cache_hit_ratio\": 0.95,\n    \"average_poll_duration\": \"150ms\"\n}\n\n# Controller metrics  \n{\n    \"reconciliations_total\": 234,\n    \"reconciliations_successful\": 220,\n    \"reconciliations_failed\": 4,\n    \"reconciliations_requeued\": 10,\n    \"average_reconciliation_time\": \"2.3s\"\n}\n\n# Scheduler metrics\n{\n    \"scheduler_loop_iterations\": 567,\n    \"resources_processed\": 890,\n    \"state_transitions\": 123,\n    \"cleanup_operations\": 45,\n    \"average_loop_duration\": \"5.2s\"\n}\n</code></pre> <p>This architecture provides a robust, scalable foundation for declarative resource management that automatically maintains desired state while being resilient to failures and providing comprehensive observability.</p>"},{"location":"features/watcher-reconciliation-patterns/","title":"Resource Watcher and Reconciliation Loop Patterns","text":"<p>This document explains how the Resource Watcher and Reconciliation Loop patterns work in our Resource Oriented Architecture (ROA) implementation, providing the foundation for Kubernetes-style declarative resource management.</p>"},{"location":"features/watcher-reconciliation-patterns/#overview","title":"\ud83c\udfaf Overview","text":"<p>The ROA implementation uses two complementary patterns:</p> <ol> <li>Resource Watcher: Detects changes to resources and emits events</li> <li>Reconciliation Loop: Continuously ensures actual state matches desired state</li> </ol> <p>These patterns work together to provide: - Declarative Management: Specify desired state, controllers make it happen - Event-Driven Processing: React to changes as they occur - Self-Healing: Automatically correct drift from desired state - Extensibility: Pluggable controllers for different resource types</p>"},{"location":"features/watcher-reconciliation-patterns/#resource-watcher-pattern","title":"\ud83d\udd0d Resource Watcher Pattern","text":""},{"location":"features/watcher-reconciliation-patterns/#how-the-watcher-works","title":"How the Watcher Works","text":"<pre><code>class ResourceWatcherBase(Generic[TResourceSpec, TResourceStatus]):\n    \"\"\"\n    The watcher follows a polling pattern:\n    1. Periodically lists resources from storage\n    2. Compares current state with cached state\n    3. Detects changes (CREATED, UPDATED, DELETED, STATUS_UPDATED)\n    4. Emits events for detected changes\n    5. Updates cache with current state\n    \"\"\"\n\n    async def _watch_loop(self, namespace=None, label_selector=None):\n        while self._watching:\n            # 1. Get current resources\n            current_resources = await self._list_resources(namespace, label_selector)\n            current_resource_map = {r.id: r for r in current_resources}\n\n            # 2. Detect changes\n            changes = self._detect_changes(current_resource_map)\n\n            # 3. Process each change\n            for change in changes:\n                await self._process_change(change)\n\n            # 4. Update cache\n            self._resource_cache = current_resource_map\n\n            # 5. Wait before next poll\n            await asyncio.sleep(self.watch_interval)\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#change-detection-logic","title":"Change Detection Logic","text":"<p>The watcher detects four types of changes:</p> <pre><code>def _detect_changes(self, current_resources):\n    changes = []\n    current_ids = set(current_resources.keys())\n    cached_ids = set(self._resource_cache.keys())\n\n    # 1. CREATED: New resources that weren't in cache\n    for resource_id in current_ids - cached_ids:\n        changes.append(ResourceChangeEvent(\n            change_type=ResourceChangeType.CREATED,\n            resource=current_resources[resource_id]\n        ))\n\n    # 2. DELETED: Cached resources no longer present\n    for resource_id in cached_ids - current_ids:\n        changes.append(ResourceChangeEvent(\n            change_type=ResourceChangeType.DELETED,\n            resource=self._resource_cache[resource_id]\n        ))\n\n    # 3. UPDATED: Spec changed (generation increment)\n    # 4. STATUS_UPDATED: Status changed (observed generation, etc.)\n    for resource_id in current_ids &amp; cached_ids:\n        current = current_resources[resource_id]\n        cached = self._resource_cache[resource_id]\n\n        if current.metadata.generation &gt; cached.metadata.generation:\n            # Spec was updated\n            changes.append(ResourceChangeEvent(\n                change_type=ResourceChangeType.UPDATED,\n                resource=current,\n                old_resource=cached\n            ))\n        elif self._has_status_changed(current, cached):\n            # Status was updated\n            changes.append(ResourceChangeEvent(\n                change_type=ResourceChangeType.STATUS_UPDATED,\n                resource=current,\n                old_resource=cached\n            ))\n\n    return changes\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#event-processing-and-publishing","title":"Event Processing and Publishing","text":"<p>When changes are detected, the watcher:</p> <pre><code>async def _process_change(self, change):\n    # 1. Call registered change handlers\n    for handler in self._change_handlers:\n        if asyncio.iscoroutinefunction(handler):\n            await handler(change)\n        else:\n            handler(change)\n\n    # 2. Publish CloudEvent\n    await self._publish_change_event(change)\n\nasync def _publish_change_event(self, change):\n    event_type = f\"{resource.kind.lower()}.{change.change_type.value.lower()}\"\n\n    event = CloudEvent(\n        source=f\"watcher/{resource.kind.lower()}\",\n        type=event_type,  # e.g., \"labinstancerequest.created\"\n        subject=f\"{resource.metadata.namespace}/{resource.metadata.name}\",\n        data={\n            \"resourceUid\": resource.id,\n            \"apiVersion\": resource.api_version,\n            \"kind\": resource.kind,\n            \"changeType\": change.change_type.value,\n            \"generation\": resource.metadata.generation,\n            \"observedGeneration\": resource.status.observed_generation\n        }\n    )\n\n    await self.event_publisher.publish_async(event)\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#reconciliation-loop-pattern","title":"\ud83d\udd04 Reconciliation Loop Pattern","text":""},{"location":"features/watcher-reconciliation-patterns/#how-reconciliation-works","title":"How Reconciliation Works","text":"<pre><code>class ResourceControllerBase(Generic[TResourceSpec, TResourceStatus]):\n    \"\"\"\n    Controllers implement the reconciliation pattern:\n    1. Receive resource change events\n    2. Compare current state with desired state\n    3. Take actions to move toward desired state\n    4. Update resource status\n    5. Emit reconciliation events\n    \"\"\"\n\n    async def reconcile(self, resource):\n        # 1. Check if reconciliation is needed\n        if not resource.needs_reconciliation():\n            return\n\n        # 2. Execute reconciliation with timeout\n        result = await asyncio.wait_for(\n            self._do_reconcile(resource),\n            timeout=self._reconciliation_timeout.total_seconds()\n        )\n\n        # 3. Handle result (success, failure, requeue)\n        await self._handle_reconciliation_result(resource, result)\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#reconciliation-states","title":"Reconciliation States","text":"<p>Controllers can return different reconciliation results:</p> <pre><code>class ReconciliationStatus(Enum):\n    SUCCESS = \"Success\"          # Reconciliation completed successfully\n    FAILED = \"Failed\"            # Reconciliation failed, needs attention\n    REQUEUE = \"Requeue\"          # Retry immediately\n    REQUEUE_AFTER = \"RequeueAfter\"  # Retry after specified delay\n\n# Example usage in controller\nasync def _do_reconcile(self, resource):\n    if resource.status.phase == LabInstancePhase.PENDING:\n        if resource.should_start_now():\n            success = await self._start_lab_instance(resource)\n            return ReconciliationResult.success() if success else ReconciliationResult.requeue()\n        else:\n            # Not time to start yet, check again in 30 seconds\n            return ReconciliationResult.requeue_after(timedelta(seconds=30))\n\n    elif resource.status.phase == LabInstancePhase.RUNNING:\n        if resource.is_expired():\n            await self._stop_lab_instance(resource)\n            return ReconciliationResult.success()\n        else:\n            # Check again when it should expire\n            remaining = resource.get_remaining_duration()\n            return ReconciliationResult.requeue_after(remaining)\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#integration-patterns","title":"\ud83d\udd27 Integration Patterns","text":""},{"location":"features/watcher-reconciliation-patterns/#pattern-1-watcher-controller-integration","title":"Pattern 1: Watcher \u2192 Controller Integration","text":"<pre><code># Watcher detects changes and triggers controller\nclass LabInstanceWatcher(ResourceWatcherBase[LabInstanceRequestSpec, LabInstanceRequestStatus]):\n    def __init__(self, repository, controller, event_publisher):\n        super().__init__(event_publisher)\n        self.repository = repository\n        self.controller = controller\n\n        # Register controller as change handler\n        self.add_change_handler(self._handle_resource_change)\n\n    async def _list_resources(self, namespace=None, label_selector=None):\n        return await self.repository.list_async(namespace=namespace)\n\n    async def _handle_resource_change(self, change):\n        \"\"\"Called when resource changes are detected.\"\"\"\n        resource = change.resource\n\n        if change.change_type in [ResourceChangeType.CREATED, ResourceChangeType.UPDATED]:\n            # Trigger reconciliation for created or updated resources\n            await self.controller.reconcile(resource)\n        elif change.change_type == ResourceChangeType.DELETED:\n            # Trigger finalization for deleted resources\n            await self.controller.finalize(resource)\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#pattern-2-background-scheduler-as-reconciliation-loop","title":"Pattern 2: Background Scheduler as Reconciliation Loop","text":"<pre><code>class LabInstanceSchedulerService(HostedService):\n    \"\"\"\n    Background service that acts as a reconciliation loop:\n    1. Periodically scans all resources\n    2. Identifies resources that need reconciliation\n    3. Applies appropriate actions\n    4. Updates resource status\n    \"\"\"\n\n    async def _run_scheduler_loop(self):\n        while self._running:\n            # Reconciliation phases\n            await self._process_scheduled_instances()  # PENDING \u2192 PROVISIONING\n            await self._process_running_instances()    # RUNNING monitoring\n            await self._cleanup_expired_instances()    # TIMEOUT/CLEANUP\n\n            await asyncio.sleep(self._scheduler_interval)\n\n    async def _process_scheduled_instances(self):\n        \"\"\"Reconcile PENDING resources that should be started.\"\"\"\n        pending_instances = await self.repository.find_by_phase_async(LabInstancePhase.PENDING)\n\n        for instance in pending_instances:\n            if instance.should_start_now():\n                # Move toward desired state: PENDING \u2192 PROVISIONING \u2192 RUNNING\n                await self._start_lab_instance(instance)\n\n    async def _process_running_instances(self):\n        \"\"\"Reconcile RUNNING resources for completion/errors.\"\"\"\n        running_instances = await self.repository.find_by_phase_async(LabInstancePhase.RUNNING)\n\n        for instance in running_instances:\n            # Check actual container state vs desired state\n            container_status = await self.container_service.get_container_status_async(\n                instance.status.container_id\n            )\n\n            if container_status == \"stopped\":\n                # Actual state differs from desired, reconcile\n                await self._complete_lab_instance(instance)\n            elif instance.is_expired():\n                # Policy violation, enforce timeout\n                await self._timeout_lab_instance(instance)\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#pattern-3-event-driven-reconciliation","title":"Pattern 3: Event-Driven Reconciliation","text":"<pre><code>class LabInstanceEventHandler:\n    \"\"\"Handle resource events and trigger reconciliation.\"\"\"\n\n    async def handle_lab_instance_created(self, event):\n        \"\"\"When a lab instance is created, ensure it's properly scheduled.\"\"\"\n        resource_id = event.data[\"resourceUid\"]\n        resource = await self.repository.get_by_id_async(resource_id)\n\n        if resource and resource.status.phase == LabInstancePhase.PENDING:\n            # Ensure resource is in scheduling queue\n            await self.controller.reconcile(resource)\n\n    async def handle_lab_instance_updated(self, event):\n        \"\"\"When a lab instance is updated, re-reconcile.\"\"\"\n        resource_id = event.data[\"resourceUid\"]\n        resource = await self.repository.get_by_id_async(resource_id)\n\n        if resource:\n            await self.controller.reconcile(resource)\n\n    async def handle_container_event(self, event):\n        \"\"\"When container state changes, update resource status.\"\"\"\n        container_id = event.data[\"containerId\"]\n\n        # Find resource with this container\n        instances = await self.repository.find_by_container_id_async(container_id)\n\n        for instance in instances:\n            # Reconcile to reflect new container state\n            await self.controller.reconcile(instance)\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#complete-integration-example","title":"\ud83d\ude80 Complete Integration Example","text":"<p>Here's how all patterns work together:</p> <pre><code># 1. Setup watcher and controller\nwatcher = LabInstanceWatcher(repository, controller, event_publisher)\nscheduler = LabInstanceSchedulerService(repository, container_service, event_bus)\n\n# 2. Start background processes\nawait watcher.watch(namespace=\"default\")\nawait scheduler.start_async()\n\n# 3. Create a resource (triggers CREATED event)\nlab_instance = LabInstanceRequest(...)\nawait repository.save_async(lab_instance)\n\n# 4. Watcher detects CREATED event\n# 5. Watcher calls controller.reconcile(lab_instance)\n# 6. Controller checks if action needed (should_start_now?)\n# 7. If not time yet, controller returns REQUEUE_AFTER\n# 8. Scheduler loop independently checks all PENDING resources\n# 9. When time arrives, scheduler starts the lab instance\n# 10. Status update triggers STATUS_UPDATED event\n# 11. Watcher publishes CloudEvent\n# 12. Other services can react to the event\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#observability-and-monitoring","title":"\ud83d\udcca Observability and Monitoring","text":"<p>Both patterns provide rich observability:</p>"},{"location":"features/watcher-reconciliation-patterns/#watcher-metrics","title":"Watcher Metrics","text":"<pre><code>watcher_metrics = {\n    \"is_watching\": watcher.is_watching(),\n    \"cached_resources\": watcher.get_cached_resource_count(),\n    \"watch_interval\": watcher.watch_interval,\n    \"events_published\": watcher.events_published_count,\n    \"change_handlers\": len(watcher._change_handlers)\n}\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#controller-metrics","title":"Controller Metrics","text":"<pre><code>controller_metrics = {\n    \"reconciliations_total\": controller.reconciliation_count,\n    \"reconciliations_successful\": controller.success_count,\n    \"reconciliations_failed\": controller.failure_count,\n    \"average_reconciliation_duration\": controller.avg_duration,\n    \"pending_reconciliations\": controller.queue_size\n}\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#scheduler-metrics","title":"Scheduler Metrics","text":"<pre><code>scheduler_metrics = {\n    \"running\": scheduler._running,\n    \"scheduler_interval\": scheduler._scheduler_interval,\n    \"instances_by_phase\": {\n        phase.value: await repository.count_by_phase_async(phase)\n        for phase in LabInstancePhase\n    },\n    \"processed_this_cycle\": scheduler.processed_count\n}\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#configuration-and-tuning","title":"\u2699\ufe0f Configuration and Tuning","text":""},{"location":"features/watcher-reconciliation-patterns/#watcher-configuration","title":"Watcher Configuration","text":"<pre><code>watcher = LabInstanceWatcher(\n    repository=repository,\n    controller=controller,\n    event_publisher=event_publisher,\n    watch_interval=5.0  # Poll every 5 seconds\n)\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#controller-configuration","title":"Controller Configuration","text":"<pre><code>controller = LabInstanceController(\n    service_provider=service_provider,\n    event_publisher=event_publisher\n)\ncontroller._reconciliation_timeout = timedelta(minutes=10)\ncontroller._max_retry_attempts = 5\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#scheduler-configuration","title":"Scheduler Configuration","text":"<pre><code>scheduler = LabInstanceSchedulerService(\n    repository=repository,\n    container_service=container_service,\n    event_bus=event_bus\n)\nscheduler._scheduler_interval = 30      # 30 second reconciliation loop\nscheduler._cleanup_interval = 300       # 5 minute cleanup cycle\n</code></pre> <p>This architecture provides a robust, observable, and extensible foundation for managing resources in a declarative, Kubernetes-style manner while integrating seamlessly with traditional CQRS patterns.</p>"},{"location":"samples/api_gateway/","title":"\ud83d\ude80 API Gateway Sample Application","text":"<p>The API Gateway sample demonstrates how to build a modern microservice gateway using the Neuroglia framework. This application showcases advanced patterns including OAuth2 authentication, external service integration, background task processing, and cloud event handling.</p>"},{"location":"samples/api_gateway/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>Microservice Gateway Patterns: How to build a centralized API gateway for service orchestration</li> <li>OAuth2 Authentication &amp; Authorization: Implementing JWT-based security with Keycloak integration</li> <li>External Service Integration: Connecting to multiple external APIs with proper abstraction</li> <li>Background Task Processing: Asynchronous task execution with Redis-backed job scheduling</li> <li>Object Storage Integration: File management with MinIO S3-compatible storage</li> <li>Cloud Events: Event-driven communication between microservices</li> <li>Advanced Dependency Injection: Complex service configuration and lifetime management</li> </ul>"},{"location":"samples/api_gateway/#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<pre><code>graph TB\n    subgraph \"API Gateway Service\"\n        A[PromptController] --&gt; B[Mediator]\n        B --&gt; C[Command/Query Handlers]\n        C --&gt; D[Domain Models]\n        C --&gt; E[Integration Services]\n\n        F[OAuth2 Middleware] --&gt; A\n        G[Cloud Event Middleware] --&gt; A\n        H[Exception Handling] --&gt; A\n    end\n\n    subgraph \"External Dependencies\"\n        I[Keycloak OAuth2]\n        J[Redis Cache]\n        K[MinIO Storage]\n        L[External APIs]\n        M[Background Tasks]\n    end\n\n    E --&gt; I\n    E --&gt; J\n    E --&gt; K\n    E --&gt; L\n    C --&gt; M</code></pre> <p>The API Gateway follows a distributed microservice pattern where:</p> <ul> <li>Gateway Layer: Centralized entry point for multiple downstream services</li> <li>Authentication Layer: OAuth2/JWT-based security with external identity provider</li> <li>Integration Layer: Multiple external service clients with proper abstraction</li> <li>DTOs: Data transfer objects for external communication</li> </ul>"},{"location":"samples/api_gateway/#key-features-demonstrated","title":"\ud83d\ude80 Key Features Demonstrated","text":""},{"location":"samples/api_gateway/#1-oauth2-authentication-security","title":"1. OAuth2 Authentication &amp; Security","text":"<pre><code># JWT token validation with Keycloak\n@post(\"/item\", response_model=ItemPromptCommandResponseDto)\nasync def create_new_item_prompt(\n    self, \n    command_dto: CreateNewItemPromptCommandDto, \n    key: str = Depends(validate_mosaic_authentication)\n) -&gt; Any:\n    # Protected endpoint with API key validation\n</code></pre>"},{"location":"samples/api_gateway/#2-multi-service-integration","title":"2. Multi-Service Integration","text":"<pre><code># External service clients\nMinioStorageManager.configure(builder)          # Object storage\nMosaicApiClient.configure(builder)              # External API\nAsyncStringCacheRepository.configure(builder)   # Redis caching\nBackgroundTaskScheduler.configure(builder)      # Async processing\n</code></pre>"},{"location":"samples/api_gateway/#3-advanced-domain-model","title":"3. Advanced Domain Model","text":"<pre><code>@map_to(PromptResponseDto)\n@dataclass\nclass PromptResponse:\n    id: str\n    prompt_id: str\n    content: str\n    status: PromptStatus\n    metadata: dict[str, Any]\n    created_at: datetime.datetime\n</code></pre>"},{"location":"samples/api_gateway/#4-background-task-processing","title":"4. Background Task Processing","text":"<pre><code># Asynchronous task execution\nBackgroundTaskScheduler.configure(builder, [\"application.tasks\"])\n\n# Redis-backed job queue\nbackground_job_store: dict[str, str | int] = {\n    \"redis_host\": \"redis47\", \n    \"redis_port\": 6379, \n    \"redis_db\": 0\n}\n</code></pre>"},{"location":"samples/api_gateway/#5-cloud-events-integration","title":"5. Cloud Events Integration","text":"<pre><code># Event publishing and consumption\nCloudEventIngestor.configure(builder, [\"application.events.integration\"])\nCloudEventPublisher.configure(builder)\napp.add_middleware(CloudEventMiddleware, service_provider=app.services)\n</code></pre>"},{"location":"samples/api_gateway/#configuration-settings","title":"\ud83d\udd27 Configuration &amp; Settings","text":""},{"location":"samples/api_gateway/#application-settings","title":"Application Settings","text":"<pre><code>class AiGatewaySettings(ApplicationSettings):\n    # OAuth2 Configuration\n    jwt_authority: str = \"http://keycloak47/realms/mozart\"\n    jwt_audience: str = \"ai-gateways\"\n    required_scope: str = \"api\"\n\n    # External Service Settings\n    s3_endpoint: str                    # MinIO storage\n    connection_strings: dict[str, str]  # Redis, databases\n    mosaic_api_keys: list[str]         # API authentication\n\n    # Background Processing\n    background_job_store: dict[str, str | int]\n    redis_max_connections: int = 10\n</code></pre>"},{"location":"samples/api_gateway/#service-registration","title":"Service Registration","text":"<pre><code># Core framework services\nMapper.configure(builder, application_modules)\nMediator.configure(builder, application_modules)\nJsonSerializer.configure(builder)\n\n# Custom application services\nAsyncStringCacheRepository.configure(builder, Prompt, str)\nBackgroundTaskScheduler.configure(builder, [\"application.tasks\"])\nMinioStorageManager.configure(builder)\nLocalFileSystemManager.configure(builder)\n\n# External integrations\nbuilder.services.add_singleton(AiGatewaySettings, singleton=app_settings)\n</code></pre>"},{"location":"samples/api_gateway/#testing-strategy","title":"\ud83e\uddea Testing Strategy","text":""},{"location":"samples/api_gateway/#unit-tests","title":"Unit Tests","text":"<pre><code>class TestPromptController:\n    def setup_method(self):\n        self.mock_mediator = Mock(spec=Mediator)\n        self.mock_mapper = Mock(spec=Mapper)\n        self.controller = PromptController(\n            service_provider=Mock(),\n            mapper=self.mock_mapper,\n            mediator=self.mock_mediator\n        )\n\n    @pytest.mark.asyncio\n    async def test_create_prompt_success(self):\n        # Test successful prompt creation\n        command_dto = CreateNewItemPromptCommandDto(content=\"test\")\n        result = await self.controller.create_new_item_prompt(command_dto, \"valid-key\")\n\n        assert result.status == \"created\"\n        self.mock_mediator.execute_async.assert_called_once()\n</code></pre>"},{"location":"samples/api_gateway/#integration-tests","title":"Integration Tests","text":"<pre><code>@pytest.mark.integration\nclass TestApiGatewayIntegration:\n    @pytest.mark.asyncio\n    async def test_full_prompt_workflow(self, test_client):\n        # Test complete workflow from API to external services\n        response = await test_client.post(\n            \"/api/prompts/item\",\n            json={\"content\": \"test prompt\"},\n            headers={\"Authorization\": \"Bearer valid-token\"}\n        )\n\n        assert response.status_code == 201\n        assert \"id\" in response.json()\n</code></pre>"},{"location":"samples/api_gateway/#implementation-details","title":"\ud83d\udcda Implementation Details","text":""},{"location":"samples/api_gateway/#1-controller-layer-apicontrollers","title":"1. Controller Layer (<code>api/controllers/</code>)","text":"<ul> <li>PromptController: Main API endpoints for prompt management</li> <li>AppController: Application health and metadata endpoints</li> <li>InternalController: Internal service endpoints</li> <li>Authentication Schemes: OAuth2 and API key validation</li> </ul>"},{"location":"samples/api_gateway/#2-application-layer-application","title":"2. Application Layer (<code>application/</code>)","text":"<ul> <li>Commands: Write operations (CreateNewPromptCommand)</li> <li>Queries: Read operations (GetPromptByIdQuery)</li> <li>Services: Business logic orchestration</li> <li>Tasks: Background job definitions</li> <li>Events: Integration event handlers</li> </ul>"},{"location":"samples/api_gateway/#3-domain-layer-domain","title":"3. Domain Layer (<code>domain/</code>)","text":"<ul> <li>Prompt: Core domain entity with business rules</li> <li>PromptResponse: Value object for API responses</li> <li>Domain Events: Business event definitions</li> <li>Validation: Domain-specific validation logic</li> </ul>"},{"location":"samples/api_gateway/#4-integration-layer-integration","title":"4. Integration Layer (<code>integration/</code>)","text":"<ul> <li>External API Clients: Mosaic, GenAI, Mozart APIs</li> <li>Storage Services: MinIO object storage, Redis caching</li> <li>Background Services: Task scheduling and execution</li> <li>DTOs: Data transfer objects for external communication</li> </ul>"},{"location":"samples/api_gateway/#background-processing","title":"\ud83d\udd04 Background Processing","text":"<p>The API Gateway demonstrates advanced background processing patterns:</p> <pre><code># Task scheduling configuration\nBackgroundTaskScheduler.configure(builder, [\"application.tasks\"])\n\n# Redis-backed job store\nbuilder.services.add_singleton(AiGatewaySettings, singleton=app_settings)\n\n# Asynchronous task execution\n@task_handler\nclass ProcessPromptTask:\n    async def execute_async(self, prompt_id: str):\n        # Long-running prompt processing\n        prompt = await self.prompt_service.get_by_id(prompt_id)\n        result = await self.genai_client.process_prompt(prompt)\n        await self.storage_service.store_result(result)\n</code></pre>"},{"location":"samples/api_gateway/#external-service-integration","title":"\ud83c\udf10 External Service Integration","text":""},{"location":"samples/api_gateway/#minio-object-storage","title":"MinIO Object Storage","text":"<pre><code>class MinioStorageManager:\n    async def upload_file_async(self, bucket: str, key: str, data: bytes) -&gt; str:\n        # S3-compatible object storage\n        return await self.client.put_object(bucket, key, data)\n</code></pre>"},{"location":"samples/api_gateway/#redis-caching","title":"Redis Caching","text":"<pre><code>class AsyncStringCacheRepository:\n    async def get_async(self, key: str) -&gt; Optional[str]:\n        return await self.redis_client.get(key)\n\n    async def set_async(self, key: str, value: str, ttl: int = None):\n        await self.redis_client.set(key, value, ex=ttl)\n</code></pre>"},{"location":"samples/api_gateway/#external-api-integration","title":"External API Integration","text":"<pre><code>class MosaicApiClient:\n    async def submit_prompt_async(self, prompt: PromptDto) -&gt; PromptResponseDto:\n        # OAuth2 authenticated API calls\n        token = await self.get_access_token()\n        response = await self.http_client.post(\n            \"/api/prompts\",\n            json=prompt.dict(),\n            headers={\"Authorization\": f\"Bearer {token}\"}\n        )\n        return PromptResponseDto.parse_obj(response.json())\n</code></pre>"},{"location":"samples/api_gateway/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"samples/api_gateway/#1-prerequisites","title":"1. Prerequisites","text":"<pre><code># Install dependencies\npip install -r requirements.txt\n\n# Configure external services\ndocker-compose up -d redis keycloak minio\n</code></pre>"},{"location":"samples/api_gateway/#2-configuration","title":"2. Configuration","text":"<pre><code># Set environment variables\nexport JWT_AUTHORITY=\"http://localhost:8080/realms/mozart\"\nexport S3_ENDPOINT=\"http://localhost:9000\"\nexport REDIS_URL=\"redis://localhost:6379\"\n</code></pre>"},{"location":"samples/api_gateway/#3-run-the-application","title":"3. Run the Application","text":"<pre><code># Start the API Gateway\npython samples/api-gateway/main.py\n\n# Access Swagger UI\nopen http://localhost:8000/docs\n</code></pre>"},{"location":"samples/api_gateway/#4-test-the-api","title":"4. Test the API","text":"<pre><code># Get access token from Keycloak\ncurl -X POST http://localhost:8080/realms/mozart/protocol/openid-connect/token \\\n  -H \"Content-Type: application/x-www-form-urlencoded\" \\\n  -d \"grant_type=client_credentials&amp;client_id=ai-gateway&amp;client_secret=secret\"\n\n# Call protected endpoint\ncurl -X POST http://localhost:8000/api/prompts/item \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"content\": \"Generate a sample prompt\"}'\n</code></pre>"},{"location":"samples/api_gateway/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>CQRS &amp; Mediation - Command/Query patterns</li> <li>Dependency Injection - Service configuration</li> <li>Data Access - Repository patterns</li> <li>OpenBank Sample - Event sourcing comparison</li> <li>Desktop Controller Sample - Background services</li> </ul>"},{"location":"samples/api_gateway/#comparison-with-openbank-sample","title":"\ud83d\udd0d Comparison with OpenBank Sample","text":"<p>The API Gateway and OpenBank samples demonstrate different architectural patterns within the Neuroglia framework. Here's a detailed comparison:</p>"},{"location":"samples/api_gateway/#architecture-patterns","title":"Architecture Patterns","text":"Aspect API Gateway OpenBank Primary Pattern Microservice Gateway Event Sourcing + DDD Data Persistence Multi-store (Redis, MinIO, MongoDB) Event Store + Read Models State Management Stateless with caching Event-sourced aggregates External Integration Multiple external APIs Focused domain model Background Processing Async task queues Event-driven projections"},{"location":"samples/api_gateway/#domain-complexity","title":"Domain Complexity","text":""},{"location":"samples/api_gateway/#api-gateway-integration-focused","title":"API Gateway - Integration-Focused","text":"<pre><code># Simple domain model focused on orchestration\n@dataclass\nclass PromptResponse:\n    id: str\n    prompt_id: str\n    content: str\n    status: PromptStatus\n    metadata: dict[str, Any]\n</code></pre>"},{"location":"samples/api_gateway/#openbank-rich-domain-model","title":"OpenBank - Rich Domain Model","text":"<pre><code># Complex aggregate with business rules\nclass BankAccountV1(AggregateRoot[str]):\n    def record_transaction(self, amount: Decimal, transaction_type: BankTransactionTypeV1):\n        # Complex business logic and invariants\n        if transaction_type == BankTransactionTypeV1.DEBIT:\n            if self.state.balance + amount &lt; -self.state.overdraft_limit:\n                raise InsufficientFundsException()\n\n        # Event sourcing\n        self.raise_event(BankAccountTransactionRecordedDomainEventV1(...))\n</code></pre>"},{"location":"samples/api_gateway/#data-persistence-strategy","title":"Data Persistence Strategy","text":""},{"location":"samples/api_gateway/#api-gateway-multi-store-architecture","title":"API Gateway - Multi-Store Architecture","text":"<pre><code># Multiple specialized storage systems\nAsyncStringCacheRepository.configure(builder, Prompt, str)  # Redis caching\nMinioStorageManager.configure(builder)                      # Object storage\nBackgroundTaskScheduler.configure(builder)                 # Job queue\n\n# Standard CRUD operations\nasync def save_prompt(self, prompt: Prompt):\n    await self.cache_repository.set_async(prompt.id, prompt.content)\n    await self.storage_manager.upload_async(prompt.id, prompt.data)\n</code></pre>"},{"location":"samples/api_gateway/#openbank-event-sourcing","title":"OpenBank - Event Sourcing","text":"<pre><code># Event-driven persistence\nESEventStore.configure(builder, EventStoreOptions(database_name, consumer_group))\n\n# Write model: Event sourcing\nDataAccessLayer.WriteModel.configure(\n    builder, \n    [\"samples.openbank.domain.models\"], \n    lambda builder_, entity_type, key_type: EventSourcingRepository.configure(...)\n)\n\n# Read model: Projections\nDataAccessLayer.ReadModel.configure(\n    builder,\n    [\"samples.openbank.integration.models\"], \n    lambda builder_, entity_type, key_type: MongoRepository.configure(...)\n)\n</code></pre>"},{"location":"samples/api_gateway/#authentication-security","title":"Authentication &amp; Security","text":""},{"location":"samples/api_gateway/#api-gateway-oauth2-api-keys","title":"API Gateway - OAuth2 + API Keys","text":"<pre><code># Multiple authentication schemes\n@post(\"/item\", dependencies=[Depends(validate_mosaic_authentication)])\nasync def create_item_prompt(self, command_dto: CreateNewItemPromptCommandDto):\n    # API key validation for external services\n\n@get(\"/status\", dependencies=[Depends(validate_token)])\nasync def get_status(self):\n    # JWT token validation for internal services\n</code></pre>"},{"location":"samples/api_gateway/#openbank-domain-focused-security","title":"OpenBank - Domain-Focused Security","text":"<pre><code># Business rule enforcement\nclass BankAccountV1(AggregateRoot[str]):\n    def record_transaction(self, amount: Decimal, transaction_type: BankTransactionTypeV1):\n        # Domain-level authorization\n        if not self.is_authorized_for_transaction(amount):\n            raise UnauthorizedTransactionException()\n</code></pre>"},{"location":"samples/api_gateway/#external-service-integration_1","title":"External Service Integration","text":""},{"location":"samples/api_gateway/#api-gateway-extensive-integration","title":"API Gateway - Extensive Integration","text":"<pre><code># Multiple external service clients\nclass MosaicApiClient:\n    async def submit_prompt_async(self, prompt: PromptDto) -&gt; PromptResponseDto:\n        token = await self.oauth_client.get_token_async()\n        return await self.http_client.post(\"/api/prompts\", prompt, token)\n\nclass GenAiClient:\n    async def process_prompt_async(self, prompt: str) -&gt; str:\n        return await self.ai_service.generate_response(prompt)\n\nclass MinioStorageManager:\n    async def store_file_async(self, bucket: str, key: str, data: bytes):\n        return await self.s3_client.put_object(bucket, key, data)\n</code></pre>"},{"location":"samples/api_gateway/#openbank-minimal-integration","title":"OpenBank - Minimal Integration","text":"<pre><code># Focused on domain logic, minimal external dependencies\nclass CreateBankAccountCommandHandler:\n    async def handle_async(self, command: CreateBankAccountCommand):\n        # Pure domain logic without external service calls\n        owner = await self.person_repository.get_by_id_async(command.owner_id)\n        account = BankAccountV1(str(uuid.uuid4()), owner, command.initial_balance)\n        await self.account_repository.save_async(account)\n</code></pre>"},{"location":"samples/api_gateway/#background-processing_1","title":"Background Processing","text":""},{"location":"samples/api_gateway/#api-gateway-task-queue-pattern","title":"API Gateway - Task Queue Pattern","text":"<pre><code># Redis-backed job queues\nBackgroundTaskScheduler.configure(builder, [\"application.tasks\"])\n\n@task_handler\nclass ProcessPromptTask:\n    async def execute_async(self, prompt_id: str):\n        prompt = await self.prompt_service.get_by_id(prompt_id)\n        result = await self.genai_client.process_prompt(prompt)\n        await self.storage_service.store_result(result)\n</code></pre>"},{"location":"samples/api_gateway/#openbank-event-driven-projections","title":"OpenBank - Event-Driven Projections","text":"<pre><code># Event handlers for read model updates\nclass BankAccountEventHandler:\n    @event_handler(BankAccountCreatedDomainEventV1)\n    async def handle_account_created(self, event: BankAccountCreatedDomainEventV1):\n        projection = BankAccountProjection.from_event(event)\n        await self.read_model_repository.save_async(projection)\n</code></pre>"},{"location":"samples/api_gateway/#testing-strategies","title":"Testing Strategies","text":""},{"location":"samples/api_gateway/#api-gateway-integration-heavy-testing","title":"API Gateway - Integration-Heavy Testing","text":"<pre><code>@pytest.mark.integration\nclass TestApiGatewayIntegration:\n    async def test_full_prompt_workflow(self, test_client, mock_external_services):\n        # Test complete workflow including external services\n        response = await test_client.post(\"/api/prompts/item\", json=prompt_data)\n\n        # Verify external service calls\n        mock_external_services.genai_client.process_prompt.assert_called_once()\n        mock_external_services.storage_manager.upload.assert_called_once()\n</code></pre>"},{"location":"samples/api_gateway/#openbank-domain-focused-testing","title":"OpenBank - Domain-Focused Testing","text":"<pre><code>class TestBankAccountAggregate:\n    def test_transaction_recording(self):\n        # Pure domain logic testing\n        account = BankAccountV1(\"123\", owner, Decimal(\"1000\"))\n        account.record_transaction(Decimal(\"-100\"), BankTransactionTypeV1.DEBIT)\n\n        # Verify business rules and events\n        assert account.state.balance == Decimal(\"900\")\n        events = account.get_uncommitted_events()\n        assert isinstance(events[-1], BankAccountTransactionRecordedDomainEventV1)\n</code></pre>"},{"location":"samples/api_gateway/#use-case-recommendations","title":"Use Case Recommendations","text":""},{"location":"samples/api_gateway/#choose-api-gateway-pattern-when","title":"Choose API Gateway Pattern when","text":"<ul> <li>\u2705 Building microservice orchestration layers</li> <li>\u2705 Integrating multiple external services</li> <li>\u2705 Need background job processing</li> <li>\u2705 Require complex authentication schemes</li> <li>\u2705 Working with heterogeneous data stores</li> <li>\u2705 Building service mesh entry points</li> </ul>"},{"location":"samples/api_gateway/#choose-event-sourcing-pattern-when","title":"Choose Event Sourcing Pattern when","text":"<ul> <li>\u2705 Need complete audit trails</li> <li>\u2705 Complex business logic and invariants</li> <li>\u2705 Temporal queries are important</li> <li>\u2705 Regulatory compliance requirements</li> <li>\u2705 High consistency requirements</li> <li>\u2705 Rich domain models with behavior</li> </ul>"},{"location":"samples/api_gateway/#framework-features-utilized","title":"Framework Features Utilized","text":"Feature API Gateway Usage OpenBank Usage CQRS/Mediation Service orchestration Domain command/query separation Dependency Injection External service clients Repository abstractions Event Handling Integration events Domain events + projections Data Access Multi-repository pattern Event sourcing + read models Background Processing Async task queues Event-driven handlers Mapping DTO transformations Domain-to-DTO mapping Validation API contract validation Business rule enforcement <p>Both samples showcase different strengths of the Neuroglia framework, demonstrating its flexibility in supporting various architectural patterns while maintaining clean architecture principles.</p>"},{"location":"samples/desktop_controller/","title":"\ud83d\udda5\ufe0f Desktop Controller Sample Application","text":"<p>The Desktop Controller sample demonstrates how to build a remote desktop management system using the Neuroglia framework. This application showcases system integration patterns including SSH-based remote control, background service registration, cloud event publishing, and OAuth2 security for enterprise desktop management.</p>"},{"location":"samples/desktop_controller/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>Remote System Control: SSH-based command execution on host systems</li> <li>Background Service Patterns: Periodic self-registration and heartbeat services  </li> <li>Cloud Event Publishing: Automated service discovery and registration events</li> <li>System Integration: Host system information gathering and state management</li> <li>OAuth2 Security: Enterprise authentication with secure SSH key management</li> <li>File System Integration: Remote file management and data persistence</li> <li>Docker Host Communication: Container-to-host communication patterns</li> </ul>"},{"location":"samples/desktop_controller/#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<pre><code>graph TB\n    subgraph \"Desktop Controller Service\"\n        A[HostController] --&gt; B[Mediator]\n        B --&gt; C[Command/Query Handlers]\n        C --&gt; D[Domain Models]\n        C --&gt; E[SSH Integration Services]\n\n        F[OAuth2 Middleware] --&gt; A\n        G[Background Registrator] --&gt; H[Cloud Event Bus]\n        I[SSH Client] --&gt; J[Docker Host]\n\n        C --&gt; K[File System Repository]\n        K --&gt; I\n    end\n\n    subgraph \"External Dependencies\"\n        L[Keycloak OAuth2]\n        M[Desktop Registry]\n        N[Docker Host/VM]\n        O[Remote File System]\n    end\n\n    F --&gt; L\n    H --&gt; M\n    I --&gt; N\n    K --&gt; O\n\n    style A fill:#e1f5fe\n    style G fill:#f3e5f5\n    style I fill:#fff3e0</code></pre> <p>This architecture enables secure remote control of desktop systems through containerized services that communicate with their host environments via SSH while maintaining enterprise security standards.</p>"},{"location":"samples/desktop_controller/#key-features-demonstrated","title":"\ud83d\ude80 Key Features Demonstrated","text":""},{"location":"samples/desktop_controller/#1-ssh-based-remote-control","title":"1. SSH-Based Remote Control","text":"<pre><code># Secure command execution on host systems\nclass SecuredHost:\n    async def run_command_async(self, command: HostCommand) -&gt; HostCommandResult:\n        stdin, stdout, stderr = await asyncio.to_thread(\n            self.ssh_client.exec_command, command.line\n        )\n\n        exit_status = stdout.channel.recv_exit_status()\n        return HostCommandResult(\n            command=command.line,\n            exit_status=exit_status,\n            stdout=stdout.read().decode(),\n            stderr=stderr.read().decode()\n        )\n</code></pre>"},{"location":"samples/desktop_controller/#2-background-service-registration","title":"2. Background Service Registration","text":"<pre><code># Periodic self-registration with cloud events\nclass DesktopRegistrator(HostedService):\n    async def start_async(self):\n        while not self.cancellation_token.is_cancelled:\n            await self._register_desktop()\n            await asyncio.sleep(self.registration_interval_seconds)\n\n    async def _register_desktop(self):\n        event = DesktopHostRegistrationRequestedIntegrationEventV1(\n            desktop_id=self.desktop_id,\n            host_ip_address=self.host_ip,\n            registration_timestamp=datetime.utcnow()\n        )\n        await self.cloud_event_publisher.publish_async(event)\n</code></pre>"},{"location":"samples/desktop_controller/#3-host-system-information-management","title":"3. Host System Information Management","text":"<pre><code># Domain model for host information\n@dataclass\nclass HostInfo(Entity[str]):\n    desktop_id: str\n    host_ip_address: str\n    host_state: HostState\n    last_seen: datetime\n    is_locked: bool\n    system_info: dict[str, Any]\n\n    def update_system_state(self, new_state: HostState):\n        self.host_state = new_state\n        self.last_seen = datetime.utcnow()\n</code></pre>"},{"location":"samples/desktop_controller/#4-commandquery-pattern-for-remote-operations","title":"4. Command/Query Pattern for Remote Operations","text":"<pre><code># Remote command execution\n@dataclass\nclass SetHostLockCommand(Command):\n    script_name: str = \"/usr/local/bin/lock.sh\"\n\nclass HostLockCommandsHandler(CommandHandler[SetHostLockCommand, OperationResult[Any]]):\n    async def handle_async(self, command: SetHostLockCommand) -&gt; OperationResult[Any]:\n        host_command = HostCommand(line=command.script_name)\n        result = await self.docker_host_command_runner.run_async(host_command)\n\n        if result.exit_status == 0:\n            return self.success(\"Host locked successfully\")\n        return self.bad_request(f\"Lock command failed: {result.stderr}\")\n</code></pre>"},{"location":"samples/desktop_controller/#5-oauth2-with-ssh-security","title":"5. OAuth2 with SSH Security","text":"<pre><code># Dual security: OAuth2 for API + SSH for host access\n@get(\"/info\", dependencies=[Depends(validate_token)])\nasync def get_host_info(self):\n    query = ReadHostInfoQuery()\n    result = await self.mediator.execute_async(query)\n    return self.process(result)\n</code></pre>"},{"location":"samples/desktop_controller/#configuration-settings","title":"\ud83d\udd27 Configuration &amp; Settings","text":""},{"location":"samples/desktop_controller/#application-settings","title":"Application Settings","text":"<pre><code>class DesktopControllerSettings(ApplicationSettings):\n    # OAuth2 Configuration\n    jwt_authority: str = \"http://keycloak47/realms/mozart\"\n    jwt_audience: str = \"desktops\"\n    required_scope: str = \"api\"\n\n    # SSH Configuration\n    docker_host_user_name: str = \"sys-admin\"\n    docker_host_host_name: str = \"host.docker.internal\"\n\n    # File System Configuration\n    remotefs_base_folder: str = \"/tmp\"\n    hostinfo_filename: str = \"hostinfo.json\"\n    userinfo_filename: str = \"userinfo.json\"\n\n    # Registration Configuration\n    desktop_registration_interval: int = 30  # seconds\n</code></pre>"},{"location":"samples/desktop_controller/#ssh-client-configuration","title":"SSH Client Configuration","text":"<pre><code>class SshClientSettings(BaseModel):\n    username: str\n    hostname: str\n    port: int = 22\n    private_key_filename: str = \"/app/id_rsa\"\n\n# SSH key setup required:\n# 1. Generate SSH key pair\n# 2. Mount private key to container at /app/id_rsa\n# 3. Add public key to host's ~/.ssh/authorized_keys\n</code></pre>"},{"location":"samples/desktop_controller/#testing-strategy","title":"\ud83e\uddea Testing Strategy","text":""},{"location":"samples/desktop_controller/#unit-tests","title":"Unit Tests","text":"<pre><code>class TestHostController:\n    def test_host_lock_command_success(self):\n        # Test successful host locking\n        command = SetHostLockCommand(script_name=\"/usr/local/bin/lock.sh\")\n\n        # Mock SSH client response\n        mock_result = HostCommandResult(\n            command=\"/usr/local/bin/lock.sh\",\n            exit_status=0,\n            stdout=\"Host locked\",\n            stderr=\"\"\n        )\n\n        result = await handler.handle_async(command)\n        assert result.is_success\n        assert \"locked successfully\" in result.data\n</code></pre>"},{"location":"samples/desktop_controller/#integration-tests","title":"Integration Tests","text":"<pre><code>class TestDesktopControllerIntegration:\n    @pytest.mark.integration\n    async def test_ssh_host_communication(self):\n        # Test actual SSH communication with test host\n        ssh_client = SecuredHost(test_ssh_settings)\n        command = HostCommand(line=\"echo 'test'\")\n\n        result = await ssh_client.run_command_async(command)\n\n        assert result.exit_status == 0\n        assert \"test\" in result.stdout\n</code></pre>"},{"location":"samples/desktop_controller/#implementation-details","title":"\ud83d\udcda Implementation Details","text":""},{"location":"samples/desktop_controller/#1-controller-layer-apicontrollers","title":"1. Controller Layer (<code>api/controllers/</code>)","text":"<ul> <li>HostController: Host system management and information endpoints</li> <li>UserController: User session and information management</li> <li>HostScriptController: Custom script execution on host systems</li> <li>OAuth2Scheme: Authentication and authorization middleware</li> </ul>"},{"location":"samples/desktop_controller/#2-application-layer-application","title":"2. Application Layer (<code>application/</code>)","text":"<ul> <li>Commands: System control operations (lock, unlock, script execution)</li> <li>Queries: System information retrieval (host info, user info, lock status)</li> <li>Services: Background registration, SSH command execution</li> <li>Events: Integration events for desktop registration</li> </ul>"},{"location":"samples/desktop_controller/#3-domain-layer-domain","title":"3. Domain Layer (<code>domain/</code>)","text":"<ul> <li>HostInfo: Desktop system information and state</li> <li>UserInfo: User session and authentication state</li> <li>HostIsLocked: Lock state management for security</li> <li>Domain Events: System state change notifications</li> </ul>"},{"location":"samples/desktop_controller/#4-integration-layer-integration","title":"4. Integration Layer (<code>integration/</code>)","text":"<ul> <li>SSH Services: Secure host communication via SSH</li> <li>File System Repository: Remote file management</li> <li>Cloud Event Models: External service communication</li> <li>Enums: System state and configuration enumerations</li> </ul>"},{"location":"samples/desktop_controller/#external-service-integration","title":"\ud83c\udf10 External Service Integration","text":""},{"location":"samples/desktop_controller/#ssh-host-communication","title":"SSH Host Communication","text":"<pre><code>class SecuredDockerHost:\n    \"\"\"SSH-based secure communication with Docker host system\"\"\"\n\n    async def execute_system_command(self, command: str) -&gt; CommandResult:\n        ssh_command = HostCommand(line=command)\n        return await self.secured_host.run_command_async(ssh_command)\n</code></pre>"},{"location":"samples/desktop_controller/#cloud-event-publishing","title":"Cloud Event Publishing","text":"<pre><code>class DesktopRegistrationEvent:\n    \"\"\"Periodic registration with external desktop registry\"\"\"\n\n    event_type = \"com.cisco.mozart.desktop.registered.v1\"\n\n    async def publish_registration(self):\n        cloud_event = CloudEvent(\n            type=self.event_type,\n            source=f\"desktop-controller/{self.desktop_id}\",\n            data=DesktopHostRegistrationRequestedIntegrationEventV1(\n                desktop_id=self.desktop_id,\n                host_ip_address=self.get_host_ip(),\n                capabilities=self.get_host_capabilities()\n            )\n        )\n        await self.cloud_event_bus.publish_async(cloud_event)\n</code></pre>"},{"location":"samples/desktop_controller/#remote-file-system-access","title":"Remote File System Access","text":"<pre><code>class RemoteFileSystemRepository:\n    \"\"\"File-based data persistence on host system\"\"\"\n\n    async def save_host_info(self, host_info: HostInfo):\n        json_data = self.json_serializer.serialize(host_info)\n        await self.write_file_async(\"hostinfo.json\", json_data)\n\n    async def write_file_async(self, filename: str, content: str):\n        # Use SSH to write files to host filesystem\n        command = f\"echo '{content}' &gt; {self.base_path}/{filename}\"\n        await self.ssh_client.run_command_async(HostCommand(line=command))\n</code></pre>"},{"location":"samples/desktop_controller/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"samples/desktop_controller/#prerequisites","title":"Prerequisites","text":"<pre><code># 1. Docker and Docker Desktop installed\n# 2. SSH key pair generated\nssh-keygen -t rsa -b 4096 -f ~/.ssh/desktop_controller_key\n\n# 3. Copy public key to target host\nssh-copy-id -i ~/.ssh/desktop_controller_key.pub user@target-host\n</code></pre>"},{"location":"samples/desktop_controller/#running-the-application","title":"Running the Application","text":"<pre><code># 1. Clone and setup\ngit clone &lt;repository&gt;\ncd samples/desktop-controller\n\n# 2. Configure environment\ncp .env.example .env\n# Edit .env with your settings\n\n# 3. Mount SSH private key and run\ndocker run -d \n  -p 8080:80 \n  -v ~/.ssh/desktop_controller_key:/app/id_rsa:ro \n  -e DOCKER_HOST_USER_NAME=sys-admin \n  -e JWT_AUTHORITY=http://your-keycloak/realms/mozart \n  desktop-controller:latest\n\n# 4. Test the API\ncurl -H \"Authorization: Bearer &lt;token&gt;\" \n     http://localhost:8080/api/host/info\n</code></pre>"},{"location":"samples/desktop_controller/#development-setup","title":"Development Setup","text":"<pre><code># 1. Install dependencies\npoetry install\n\n# 2. Configure SSH access\nsudo cp ~/.ssh/desktop_controller_key ./id_rsa\nsudo chmod 600 ./id_rsa\n\n# 3. Start development server\npoetry run python main.py\n\n# 4. Access Swagger UI\nopen http://localhost:8080/docs\n</code></pre>"},{"location":"samples/desktop_controller/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>OAuth2 Security - Authentication patterns</li> <li>Background Services - Hosted service patterns</li> <li>Cloud Events - Event publishing and consumption</li> <li>System Integration - External system communication</li> <li>API Gateway Sample - Service gateway patterns</li> <li>OpenBank Sample - Event sourcing and CQRS patterns</li> </ul>"},{"location":"samples/desktop_controller/#comparison-with-other-samples","title":"\ud83d\udd0d Comparison with Other Samples","text":""},{"location":"samples/desktop_controller/#architecture-patterns","title":"Architecture Patterns","text":""},{"location":"samples/desktop_controller/#desktop-controller-system-integration-focused","title":"Desktop Controller - System Integration Focused","text":"<pre><code># SSH-based system control\nclass HostController(ControllerBase):\n    @post(\"/lock\")\n    async def lock_host(self):\n        command = SetHostLockCommand()\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n# Background service registration\nclass DesktopRegistrator(HostedService):\n    async def start_async(self):\n        while not self.stopping:\n            await self.register_desktop()\n            await asyncio.sleep(30)\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-service-orchestration","title":"API Gateway - Service Orchestration","text":"<pre><code># External API orchestration\nclass PromptController(ControllerBase):\n    @post(\"/prompts\")\n    async def create_prompt(self, dto: CreatePromptDto):\n        command = self.mapper.map(dto, CreatePromptCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-rich-domain-model","title":"OpenBank - Rich Domain Model","text":"<pre><code># Event-sourced business logic\nclass BankAccount(AggregateRoot[str]):\n    def try_add_transaction(self, transaction: BankTransaction) -&gt; bool:\n        if self.can_process_transaction(transaction):\n            self.state.on(self.register_event(TransactionRecorded(transaction)))\n            return True\n        return False\n</code></pre>"},{"location":"samples/desktop_controller/#domain-complexity","title":"Domain Complexity","text":""},{"location":"samples/desktop_controller/#desktop-controller-system-state-management","title":"Desktop Controller - System State Management","text":"<ul> <li>Focus: Host system control and monitoring</li> <li>Entities: HostInfo, UserInfo, SystemState</li> <li>Operations: Lock/unlock, script execution, information gathering</li> <li>State: Current system state with periodic updates</li> </ul>"},{"location":"samples/desktop_controller/#api-gateway-service-integration","title":"API Gateway - Service Integration","text":"<ul> <li>Focus: Request routing and external service coordination</li> <li>Entities: Prompt, PromptResponse, ServiceConfiguration</li> <li>Operations: Create, process, route requests</li> <li>State: Request/response transformation and routing</li> </ul>"},{"location":"samples/desktop_controller/#openbank-business-domain-model","title":"OpenBank - Business Domain Model","text":"<ul> <li>Focus: Financial business rules and transactions</li> <li>Entities: BankAccount, Person, Transaction</li> <li>Operations: Account creation, money transfer, balance inquiry</li> <li>State: Event-sourced business state with full history</li> </ul>"},{"location":"samples/desktop_controller/#data-persistence-strategy","title":"Data Persistence Strategy","text":""},{"location":"samples/desktop_controller/#desktop-controller-file-based-remote-storage","title":"Desktop Controller - File-Based + Remote Storage","text":"<pre><code># File-based persistence on remote host\nclass RemoteFileSystemRepository:\n    async def save_host_info(self, host_info: HostInfo):\n        json_content = self.serializer.serialize(host_info)\n        await self.write_remote_file(\"hostinfo.json\", json_content)\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-multi-store-architecture","title":"API Gateway - Multi-Store Architecture","text":"<pre><code># Multiple storage backends\nservices.add_scoped(MinioStorageManager)      # Object storage\nservices.add_scoped(RedisCache)               # Caching\nservices.add_scoped(MongoRepository)          # Document storage\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-event-sourcing","title":"OpenBank - Event Sourcing","text":"<pre><code># Event store with projections\nclass EventStoreRepository:\n    async def save_async(self, aggregate: AggregateRoot):\n        events = aggregate._pending_events\n        await self.event_store.append_events_async(aggregate.id, events)\n</code></pre>"},{"location":"samples/desktop_controller/#authentication-security","title":"Authentication &amp; Security","text":""},{"location":"samples/desktop_controller/#desktop-controller-oauth2-ssh-keys","title":"Desktop Controller - OAuth2 + SSH Keys","text":"<pre><code># Dual security model\n@get(\"/info\", dependencies=[Depends(validate_token)])\nasync def get_host_info(self):\n    # OAuth2 for API access + SSH for host communication\n    pass\n\n# SSH key management\nclass SshClientSettings:\n    private_key_filename: str = \"/app/id_rsa\"\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-oauth2-api-keys","title":"API Gateway - OAuth2 + API Keys","text":"<pre><code># Multiple authentication schemes\n@post(\"/item\", dependencies=[Depends(validate_oauth2_token)])\nasync def create_item_oauth(self, item_data: ItemDto):\n    pass\n\n@get(\"/health\", dependencies=[Depends(validate_api_key)])\nasync def health_check(self):\n    pass\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-domain-focused-security","title":"OpenBank - Domain-Focused Security","text":"<pre><code># Business rule-based security\nclass BankAccount:\n    def withdraw(self, amount: Decimal, user: Person):\n        if not self.is_owner(user):\n            raise UnauthorizedOperationException()\n        if not self.has_sufficient_funds(amount):\n            raise InsufficientFundsException()\n</code></pre>"},{"location":"samples/desktop_controller/#external-service-integration_1","title":"External Service Integration","text":""},{"location":"samples/desktop_controller/#desktop-controller-system-integration","title":"Desktop Controller - System Integration","text":"<pre><code># Direct system integration via SSH\nclass DockerHostCommandRunner:\n    async def run_async(self, command: HostCommand) -&gt; HostCommandResult:\n        return await self.ssh_client.execute_command(command)\n\n# Cloud event publishing for registration\nclass DesktopRegistrator:\n    async def register_desktop(self):\n        event = DesktopRegistrationEvent(self.host_info)\n        await self.cloud_event_bus.publish_async(event)\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-extensive-integration","title":"API Gateway - Extensive Integration","text":"<pre><code># Multiple external service clients\nservices.add_scoped(MosaicApiClient)\nservices.add_scoped(MinioStorageManager)\nservices.add_scoped(RedisCache)\nservices.add_scoped(GenAiApiClient)\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-minimal-integration","title":"OpenBank - Minimal Integration","text":"<pre><code># Domain-focused with minimal external dependencies\nservices.add_singleton(EventStoreClient)\nservices.add_scoped(MongoRepository)  # For read models\n</code></pre>"},{"location":"samples/desktop_controller/#background-processing","title":"Background Processing","text":""},{"location":"samples/desktop_controller/#desktop-controller-periodic-registration","title":"Desktop Controller - Periodic Registration","text":"<pre><code># Background service for system registration\nclass DesktopRegistrator(HostedService):\n    async def start_async(self):\n        self.registration_task = asyncio.create_task(self.registration_loop())\n\n    async def registration_loop(self):\n        while not self.stopping:\n            await self.register_with_registry()\n            await asyncio.sleep(self.interval)\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-task-queue-pattern","title":"API Gateway - Task Queue Pattern","text":"<pre><code># Redis-backed background task processing\n@dataclass\nclass ProcessPromptTask(BackgroundTask):\n    prompt_id: str\n    user_id: str\n\nclass PromptProcessingService:\n    async def queue_processing_task(self, prompt: Prompt):\n        task = ProcessPromptTask(prompt.id, prompt.user_id)\n        await self.task_scheduler.schedule_async(task)\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-event-driven-projections","title":"OpenBank - Event-Driven Projections","text":"<pre><code># Domain event-driven read model updates\nclass BankAccountProjectionHandler:\n    @dispatch(BankAccountCreatedDomainEventV1)\n    async def handle_async(self, event: BankAccountCreatedDomainEventV1):\n        projection = BankAccountProjection.from_event(event)\n        await self.projection_repository.save_async(projection)\n</code></pre>"},{"location":"samples/desktop_controller/#testing-strategies","title":"Testing Strategies","text":""},{"location":"samples/desktop_controller/#desktop-controller-system-integration-testing","title":"Desktop Controller - System Integration Testing","text":"<pre><code># SSH integration tests\n@pytest.mark.integration\nclass TestSSHIntegration:\n    async def test_host_command_execution(self):\n        ssh_client = SecuredHost(test_settings)\n        result = await ssh_client.run_command_async(HostCommand(\"echo test\"))\n        assert result.exit_status == 0\n        assert \"test\" in result.stdout\n\n# Background service testing\nclass TestDesktopRegistrator:\n    async def test_periodic_registration(self):\n        registrator = DesktopRegistrator(mock_cloud_event_bus)\n        await registrator.start_async()\n        # Verify registration events are published\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-integration-heavy-testing","title":"API Gateway - Integration-Heavy Testing","text":"<pre><code># External service integration tests\n@pytest.mark.integration\nclass TestExternalServices:\n    async def test_mosaic_api_integration(self):\n        client = MosaicApiClient(test_settings)\n        response = await client.get_data_async(\"test-id\")\n        assert response.status_code == 200\n\n# Background task testing\nclass TestTaskProcessing:\n    async def test_prompt_processing_workflow(self):\n        task = ProcessPromptTask(\"prompt-123\", \"user-456\")\n        result = await self.task_processor.process_async(task)\n        assert result.is_success\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-domain-focused-testing","title":"OpenBank - Domain-Focused Testing","text":"<pre><code># Rich domain behavior testing\nclass TestBankAccount:\n    def test_account_creation_raises_creation_event(self):\n        account = BankAccount()\n        account.create_account(\"owner-123\", Decimal(\"1000.00\"))\n\n        events = account._pending_events\n        assert len(events) == 1\n        assert isinstance(events[0], BankAccountCreatedDomainEventV1)\n\n# Event sourcing testing\nclass TestEventStore:\n    async def test_aggregate_reconstruction_from_events(self):\n        events = [creation_event, transaction_event]\n        account = await self.repository.load_from_events(events)\n        assert account.balance == expected_balance\n</code></pre>"},{"location":"samples/desktop_controller/#use-case-recommendations","title":"Use Case Recommendations","text":""},{"location":"samples/desktop_controller/#choose-desktop-controller-pattern-when","title":"Choose Desktop Controller Pattern when","text":"<ul> <li>\u2705 Building system administration and control applications</li> <li>\u2705 Managing remote desktop or VM environments</li> <li>\u2705 Implementing SSH-based automation and control</li> <li>\u2705 Creating enterprise desktop management solutions</li> <li>\u2705 Needing periodic service registration and discovery</li> <li>\u2705 Integrating containerized apps with host systems</li> <li>\u2705 Building secure remote command execution systems</li> </ul>"},{"location":"samples/desktop_controller/#choose-api-gateway-pattern-when","title":"Choose API Gateway Pattern when","text":"<ul> <li>\u2705 Building microservice entry points and orchestration</li> <li>\u2705 Implementing complex external service integration</li> <li>\u2705 Creating service mesh control planes</li> <li>\u2705 Needing advanced authentication and authorization</li> <li>\u2705 Building background task processing systems</li> <li>\u2705 Implementing file storage and caching solutions</li> </ul>"},{"location":"samples/desktop_controller/#choose-event-sourcing-pattern-when","title":"Choose Event Sourcing Pattern when","text":"<ul> <li>\u2705 Rich domain models with behavior</li> <li>\u2705 Complete audit trails and temporal queries</li> <li>\u2705 Event-driven architecture with projections</li> <li>\u2705 Financial or business-critical applications</li> <li>\u2705 CQRS with separate read/write models</li> </ul>"},{"location":"samples/desktop_controller/#framework-features-utilized","title":"Framework Features Utilized","text":"<p>The Desktop Controller sample demonstrates unique aspects of the Neuroglia framework:</p> <ul> <li>Background Services: <code>HostedService</code> for long-running registration tasks</li> <li>SSH Integration: Custom integration services for secure system communication</li> <li>Cloud Event Publishing: External service registration and discovery</li> <li>File-Based Repositories: Remote filesystem data persistence</li> <li>OAuth2 Security: Enterprise authentication with secure key management</li> <li>System Integration Patterns: Container-to-host communication strategies</li> </ul> <p>Both samples showcase different strengths of the Neuroglia framework, demonstrating its flexibility in supporting various architectural patterns while maintaining clean architecture principles.</p>"},{"location":"samples/desktop_controller/#overview","title":"Overview","text":""},{"location":"samples/desktop_controller/#controllers-interactions","title":"Controller's Interactions","text":"<p>TODO</p>"},{"location":"samples/desktop_controller/#controllers-context","title":"Controller's Context","text":"<p>TODO</p>"},{"location":"samples/desktop_controller/#design","title":"Design","text":"<p>TODO</p>"},{"location":"samples/desktop_controller/#development","title":"Development","text":""},{"location":"samples/desktop_controller/#setup","title":"Setup","text":"<pre><code># 0. Prerequisites:\n#    Have Python 3.12 installed\n# \n#    - Create/Activate a local python environment (e.g. with pyenv)\n#      pyenv virtualenv 3.12.2 desktop-controller\n#      pyenv activate desktop-controller\n# \n#    - Start Docker Desktop locally\n#\n# 1. Clone the repository\ncd ~/\n\ngit clone git@....\n\ncd desktop-controller\n\n# pip install pre-commit\npre-commit install\n\n# pip install poetry\npoetry lock &amp;&amp; poetry install \n\n# 2. Start the docker-compose stack\n# sudo apt-get install make\nmake up\n\n# Access Swagger UI\nopen http://localhost:8080/docs\n</code></pre>"},{"location":"samples/desktop_controller/#key-implementation-highlights","title":"\ud83d\udca1 Key Implementation Highlights","text":"<p>The Desktop Controller sample uniquely demonstrates:</p>"},{"location":"samples/desktop_controller/#1-dual-security-architecture","title":"1. Dual Security Architecture","text":"<ul> <li>API Security: OAuth2/JWT for REST API access</li> <li>System Security: SSH key-based authentication for host communication</li> <li>Separation of Concerns: Different security models for different access layers</li> </ul>"},{"location":"samples/desktop_controller/#2-container-to-host-communication","title":"2. Container-to-Host Communication","text":"<ul> <li>SSH Bridge: Secure communication between containerized service and host system</li> <li>Command Execution: Remote shell command execution with result capture</li> <li>File System Access: Remote file management on host filesystem</li> </ul>"},{"location":"samples/desktop_controller/#3-background-service-registration","title":"3. Background Service Registration","text":"<ul> <li>Self-Discovery: Periodic registration with external service registry</li> <li>Cloud Events: Standards-based event publishing for service discovery</li> <li>Heartbeat Pattern: Continuous availability signaling</li> </ul>"},{"location":"samples/desktop_controller/#4-system-integration-patterns","title":"4. System Integration Patterns","text":"<ul> <li>Host Information Gathering: Real-time system state collection</li> <li>Remote Control Operations: Secure desktop management capabilities</li> <li>State Persistence: File-based data storage for inter-application communication</li> </ul> <p>This sample showcases how the Neuroglia framework can effectively bridge containerized microservices with host system management, providing enterprise-grade security and reliability for remote desktop control scenarios.</p> <p>Both the Desktop Controller and other samples demonstrate the framework's versatility in handling diverse architectural patterns - from event-sourced business applications to system integration and service orchestration solutions.</p>"},{"location":"samples/lab-resource-manager/","title":"\ud83e\uddea Lab Resource Manager Sample Application","text":"<p>The Lab Resource Manager demonstrates Resource Oriented Architecture (ROA) patterns using Neuroglia's advanced features. It simulates a system for managing ephemeral lab environments for students, showcasing watchers, controllers, and reconciliation loops.</p>"},{"location":"samples/lab-resource-manager/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>Resource Oriented Architecture: Declarative resource management patterns</li> <li>Watcher Pattern: Continuous monitoring of resource changes</li> <li>Controller Pattern: Event-driven business logic responses</li> <li>Reconciliation Loops: Periodic consistency checks and drift correction</li> <li>State Machine Implementation: Resource lifecycle management</li> <li>Asynchronous Coordination: Multiple concurrent components working together</li> </ul>"},{"location":"samples/lab-resource-manager/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Lab Resource Manager                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502   Watcher       \u2502    \u2502   Controller    \u2502    \u2502  Reconciler     \u2502 \u2502\n\u2502  \u2502   (2s polling)  \u2502\u2500\u2500\u2500\u25b6\u2502   (immediate)   \u2502    \u2502   (10s loop)    \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502           \u2502                       \u2502                       \u2502       \u2502\n\u2502           \u25bc                       \u25bc                       \u25bc       \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502                    Resource Storage                             \u2502 \u2502\n\u2502  \u2502            (Kubernetes-like API with versioning)               \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n</code></pre>"},{"location":"samples/lab-resource-manager/#domain-model","title":"\ud83c\udfaf Domain Model","text":""},{"location":"samples/lab-resource-manager/#labinstance-resource","title":"LabInstance Resource","text":"<p>The core resource representing a student lab environment:</p> <pre><code>@dataclass\nclass LabInstanceResource:\n    api_version: str = \"lab.neuroglia.com/v1\"\n    kind: str = \"LabInstance\" \n    metadata: Dict[str, Any] = None  # Name, namespace, timestamps, versions\n    spec: Dict[str, Any] = None      # Desired state: template, duration, student\n    status: Dict[str, Any] = None    # Current state: phase, endpoint, conditions\n</code></pre>"},{"location":"samples/lab-resource-manager/#resource-states","title":"Resource States","text":"<p>Lab instances progress through a defined lifecycle:</p> <pre><code>PENDING \u2500\u2500\u2192 PROVISIONING \u2500\u2500\u2192 READY \u2500\u2500\u2192 DELETING \u2500\u2500\u2192 DELETED\n   \u2502              \u2502             \u2502\n   \u25bc              \u25bc             \u25bc\nFAILED        FAILED         FAILED\n</code></pre>"},{"location":"samples/lab-resource-manager/#sample-resource","title":"Sample Resource","text":"<pre><code>{\n  \"apiVersion\": \"lab.neuroglia.com/v1\",\n  \"kind\": \"LabInstance\",\n  \"metadata\": {\n    \"name\": \"python-basics-lab\",\n    \"namespace\": \"student-labs\",\n    \"resourceVersion\": \"1\",\n    \"creationTimestamp\": \"2025-09-09T21:34:19Z\"\n  },\n  \"spec\": {\n    \"template\": \"python-basics\",\n    \"studentEmail\": \"student@example.com\",\n    \"duration\": \"60m\",\n    \"environment\": {\n      \"PYTHON_VERSION\": \"3.11\"\n    }\n  },\n  \"status\": {\n    \"state\": \"ready\",\n    \"message\": \"Lab instance is ready\",\n    \"endpoint\": \"https://lab-python-basics.example.com\",\n    \"readyAt\": \"2025-09-09T21:34:25Z\"\n  }\n}\n</code></pre>"},{"location":"samples/lab-resource-manager/#component-implementation","title":"\ud83d\udd27 Component Implementation","text":""},{"location":"samples/lab-resource-manager/#1-watcher-labinstancewatcher","title":"1. Watcher: LabInstanceWatcher","text":"<p>Continuously monitors for resource changes:</p> <pre><code>class LabInstanceWatcher:\n    async def start_watching(self):\n        while self.is_running:\n            # Poll for changes since last known version\n            changes = self.storage.list_resources(since_version=self.last_resource_version)\n\n            for resource in changes:\n                resource_version = int(resource.metadata.get('resourceVersion', '0'))\n                if resource_version &gt; self.last_resource_version:\n                    await self._handle_resource_change(resource)\n                    self.last_resource_version = max(self.last_resource_version, resource_version)\n\n            await asyncio.sleep(self.poll_interval)\n</code></pre> <p>Key Features: - Polls every 2 seconds for near-real-time responsiveness - Uses resource versioning to detect changes efficiently - Notifies multiple event handlers when changes occur - Handles errors gracefully with continued monitoring</p>"},{"location":"samples/lab-resource-manager/#2-controller-labinstancecontroller","title":"2. Controller: LabInstanceController","text":"<p>Implements business logic for state transitions:</p> <pre><code>class LabInstanceController:\n    async def handle_resource_event(self, resource: LabInstanceResource):\n        current_state = resource.status.get('state')\n\n        if current_state == ResourceState.PENDING.value:\n            await self._start_provisioning(resource)\n        elif current_state == ResourceState.PROVISIONING.value:\n            await self._check_provisioning_status(resource)\n        elif current_state == ResourceState.READY.value:\n            await self._monitor_lab_instance(resource)\n</code></pre> <p>Key Features: - Event-driven processing responding immediately to changes - State machine implementation with clear transitions - Business rule enforcement (timeouts, validation, etc.) - Integration with external provisioning systems</p>"},{"location":"samples/lab-resource-manager/#3-reconciler-labinstancescheduler","title":"3. Reconciler: LabInstanceScheduler","text":"<p>Provides safety and eventual consistency:</p> <pre><code>class LabInstanceScheduler:\n    async def start_reconciliation(self):\n        while self.is_running:\n            await self._reconcile_all_resources()\n            await asyncio.sleep(self.reconcile_interval)\n\n    async def _reconcile_resource(self, resource):\n        # Check for stuck states\n        if self._is_stuck_provisioning(resource):\n            await self._mark_as_failed(resource, \"Provisioning timeout\")\n\n        # Check for expiration\n        if self._is_expired(resource):\n            await self._schedule_deletion(resource)\n</code></pre> <p>Key Features: - Runs every 10 seconds scanning all resources - Detects stuck states and takes corrective action - Enforces business policies (lab expiration, cleanup) - Provides safety net for controller failures</p>"},{"location":"samples/lab-resource-manager/#execution-flow","title":"\u26a1 Execution Flow","text":""},{"location":"samples/lab-resource-manager/#1-resource-creation","title":"1. Resource Creation","text":"<pre><code>1. API creates LabInstance resource (state: PENDING)\n2. Storage backend assigns resource version and timestamps\n3. Watcher detects new resource on next poll cycle (\u22642s)\n4. Controller receives sevent and starts provisioning\n5. Resource state transitions to PROVISIONING\n</code></pre>"},{"location":"samples/lab-resource-manager/#2-state-progression","title":"2. State Progression","text":"<pre><code>6. Watcher detects state change to PROVISIONING\n7. Controller checks provisioning status periodically\n8. When provisioning completes, state transitions to READY\n9. Watcher detects READY state\n10. Controller begins monitoring ready lab instance\n</code></pre>"},{"location":"samples/lab-resource-manager/#3-reconciliation-safety","title":"3. Reconciliation Safety","text":"<pre><code>11. Reconciler runs every 10 seconds checking all resources\n12. Detects if any resource is stuck in PROVISIONING too long\n13. Marks stuck resources as FAILED with timeout message\n14. Detects expired READY resources and schedules deletion\n</code></pre>"},{"location":"samples/lab-resource-manager/#running-the-sample","title":"\ud83d\ude80 Running the Sample","text":""},{"location":"samples/lab-resource-manager/#prerequisites","title":"Prerequisites","text":"<pre><code>cd samples/lab-resource-manager\n</code></pre>"},{"location":"samples/lab-resource-manager/#option-1-full-interactive-demo","title":"Option 1: Full Interactive Demo","text":"<pre><code>python run_watcher_demo.py\n</code></pre> <p>This runs the complete demonstration showing: - Resource creation and state transitions - Watcher detecting changes in real-time - Controller responding with business logic - Reconciler providing safety and cleanup</p>"},{"location":"samples/lab-resource-manager/#option-2-simple-patterns-demo","title":"Option 2: Simple Patterns Demo","text":"<pre><code>python simple_demo.py\n</code></pre> <p>A simplified version focusing on the core patterns without framework dependencies.</p>"},{"location":"samples/lab-resource-manager/#expected-output","title":"Expected Output","text":"<pre><code>\ud83c\udfaf Resource Oriented Architecture: Watcher &amp; Reconciliation Demo\n============================================================\n\ud83d\udc40 LabInstance Watcher started\n\ud83d\udd04 LabInstance Scheduler started reconciliation\n\ud83d\udce6 Created resource: student-labs/python-basics-lab\n\ud83d\udd0d Watcher detected change: student-labs/python-basics-lab -&gt; pending\n\ud83c\udfae Controller processing: student-labs/python-basics-lab (state: pending)\n\ud83d\ude80 Starting provisioning for: student-labs/python-basics-lab\n\ud83d\udd04 Updated resource: student-labs/python-basics-lab -&gt; {'status': {'state': 'provisioning'}}\n\ud83d\udd0d Watcher detected change: student-labs/python-basics-lab -&gt; provisioning\n\ud83c\udfae Controller processing: student-labs/python-basics-lab (state: provisioning)\n\ud83d\udd04 Reconciling 2 lab instances\n\u26a0\ufe0f Reconciler: Lab instance stuck in provisioning: student-labs/python-basics-lab\n</code></pre>"},{"location":"samples/lab-resource-manager/#key-implementation-details","title":"\ud83d\udca1 Key Implementation Details","text":""},{"location":"samples/lab-resource-manager/#resource-versioning","title":"Resource Versioning","text":"<p>Each resource change increments the version:</p> <pre><code>def update_resource(self, resource_id: str, updates: Dict[str, Any]):\n    resource = self.resources[resource_id]\n    self.resource_version += 1\n    resource.metadata['resourceVersion'] = str(self.resource_version)\n</code></pre>"},{"location":"samples/lab-resource-manager/#event-handling","title":"Event Handling","text":"<p>Watchers notify multiple handlers:</p> <pre><code>watcher.add_event_handler(controller.handle_resource_event)\nwatcher.add_event_handler(audit_logger.log_change)\nwatcher.add_event_handler(metrics_collector.record_event)\n</code></pre>"},{"location":"samples/lab-resource-manager/#error-resilience","title":"Error Resilience","text":"<p>All components handle errors gracefully:</p> <pre><code>try:\n    await self._provision_lab_instance(resource)\nexcept Exception as e:\n    logger.error(f\"Provisioning failed: {e}\")\n    await self._mark_as_failed(resource, str(e))\n</code></pre>"},{"location":"samples/lab-resource-manager/#concurrent-processing","title":"Concurrent Processing","text":"<p>Components run independently:</p> <pre><code>async def main():\n    watcher_task = asyncio.create_task(watcher.start_watching())\n    scheduler_task = asyncio.create_task(scheduler.start_reconciliation())\n\n    # Both run concurrently until stopped\n    await asyncio.gather(watcher_task, scheduler_task)\n</code></pre>"},{"location":"samples/lab-resource-manager/#design-patterns-demonstrated","title":"\ud83c\udfaf Design Patterns Demonstrated","text":""},{"location":"samples/lab-resource-manager/#1-observer-pattern","title":"1. Observer Pattern","text":"<p>Watchers observe storage and notify controllers of changes.</p>"},{"location":"samples/lab-resource-manager/#2-state-machine","title":"2. State Machine","text":"<p>Resources progress through well-defined states with clear transitions.</p>"},{"location":"samples/lab-resource-manager/#3-command-pattern","title":"3. Command Pattern","text":"<p>Controllers execute commands based on resource state.</p>"},{"location":"samples/lab-resource-manager/#4-strategy-pattern","title":"4. Strategy Pattern","text":"<p>Different provisioning strategies for different lab templates.</p>"},{"location":"samples/lab-resource-manager/#5-circuit-breaker","title":"5. Circuit Breaker","text":"<p>Reconcilers detect failures and prevent cascade issues.</p>"},{"location":"samples/lab-resource-manager/#configuration-options","title":"\ud83d\udd27 Configuration Options","text":""},{"location":"samples/lab-resource-manager/#timing-configuration","title":"Timing Configuration","text":"<pre><code># Development: Fast feedback\nwatcher = LabInstanceWatcher(storage, poll_interval=1.0)\nscheduler = LabInstanceScheduler(storage, reconcile_interval=5.0)\n\n# Production: Optimized performance  \nwatcher = LabInstanceWatcher(storage, poll_interval=5.0)\nscheduler = LabInstanceScheduler(storage, reconcile_interval=30.0)\n</code></pre>"},{"location":"samples/lab-resource-manager/#timeout-configuration","title":"Timeout Configuration","text":"<pre><code>class LabInstanceController:\n    PROVISIONING_TIMEOUT = 300  # 5 minutes\n    MAX_RETRIES = 3\n    RETRY_BACKOFF = 30  # seconds\n</code></pre>"},{"location":"samples/lab-resource-manager/#resource-policies","title":"Resource Policies","text":"<pre><code>class LabInstanceScheduler:\n    DEFAULT_LAB_DURATION = 3600  # 1 hour\n    CLEANUP_GRACE_PERIOD = 300   # 5 minutes\n    MAX_CONCURRENT_PROVISIONS = 10\n</code></pre>"},{"location":"samples/lab-resource-manager/#testing-the-sample","title":"\ud83e\uddea Testing the Sample","text":"<p>The sample includes comprehensive tests:</p> <pre><code># Run all sample tests\npytest samples/lab-resource-manager/tests/\n\n# Test individual components\npytest samples/lab-resource-manager/tests/test_watcher.py\npytest samples/lab-resource-manager/tests/test_controller.py\npytest samples/lab-resource-manager/tests/test_reconciler.py\n</code></pre>"},{"location":"samples/lab-resource-manager/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\ud83c\udfaf Resource Oriented Architecture - Core ROA concepts</li> <li>\ud83c\udfd7\ufe0f Watcher &amp; Reconciliation Patterns - Detailed patterns</li> <li>\u26a1 Execution Flow - Component coordination</li> <li>\ud83c\udfaf CQRS &amp; Mediation - Command/Query handling</li> <li>\ud83d\uddc4\ufe0f Data Access - Storage patterns</li> </ul>"},{"location":"samples/lab-resource-manager/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<p>After exploring this sample:</p> <ol> <li>Extend the Domain: Add more resource types (LabTemplate, StudentSession)</li> <li>Add Persistence: Integrate with MongoDB or Event Store</li> <li>Implement Authentication: Add student authentication and authorization</li> <li>Add Monitoring: Integrate metrics collection and alerting</li> <li>Scale Horizontally: Implement resource sharding for multiple instances</li> </ol>"},{"location":"samples/openbank/","title":"\ud83c\udfe6 OpenBank Sample Application","text":"<p>OpenBank is a comprehensive sample application that demonstrates advanced Neuroglia features including event sourcing, CQRS, domain-driven design, and event-driven architecture. It simulates a simple banking system with persons and accounts.</p>"},{"location":"samples/openbank/#overview","title":"\ud83c\udfaf Overview","text":"<p>The OpenBank sample showcases:</p> <ul> <li>Event Sourcing: Complete event-sourced domain with event store</li> <li>CQRS: Separate command and query models</li> <li>Domain-Driven Design: Rich domain models with business rules</li> <li>Event-Driven Architecture: Domain events and integration events</li> <li>Clean Architecture: Clear separation of layers</li> <li>Repository Pattern: Both write (event sourcing) and read (MongoDB) repositories</li> </ul>"},{"location":"samples/openbank/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    API Layer                                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502  PersonsController \u2502  \u2502 AccountsController \u2502  \u2502  Other APIs  \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Application Layer                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502    Commands     \u2502  \u2502     Queries     \u2502  \u2502     Events     \u2502   \u2502\n\u2502  \u2502   Handlers      \u2502  \u2502    Handlers     \u2502  \u2502   Handlers     \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Domain Layer                                 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502     Person      \u2502  \u2502     Account     \u2502  \u2502    Address     \u2502   \u2502\n\u2502  \u2502   Aggregate     \u2502  \u2502   Aggregate     \u2502  \u2502 Value Object   \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Integration Layer                              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502 Event Store     \u2502  \u2502   MongoDB       \u2502  \u2502  API Clients   \u2502   \u2502\n\u2502  \u2502 Repository      \u2502  \u2502  Repository     \u2502  \u2502                \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"samples/openbank/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"samples/openbank/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+</li> <li>Docker and Docker Compose</li> <li>MongoDB (via Docker)</li> <li>EventStoreDB (via Docker)</li> </ul>"},{"location":"samples/openbank/#setup","title":"Setup","text":"<ol> <li>Start Dependencies:</li> </ol> <pre><code>cd samples/openbank\ndocker-compose up -d mongodb eventstoredb\n</code></pre> <ol> <li>Install Dependencies:</li> </ol> <pre><code>pip install -r requirements.txt\n</code></pre> <ol> <li>Run the Application:</li> </ol> <pre><code>python api/main.py\n</code></pre> <ol> <li> <p>Access the API:</p> </li> <li> <p>API Documentation: http://localhost:8000/api/docs</p> </li> <li>EventStoreDB UI: http://localhost:2113 (admin/changeit)</li> </ol>"},{"location":"samples/openbank/#project-structure","title":"\ud83d\udcc1 Project Structure","text":"<pre><code>samples/openbank/\n\u251c\u2500\u2500 api/\n\u2502   \u251c\u2500\u2500 main.py                     # Application entry point\n\u2502   \u2514\u2500\u2500 controllers/\n\u2502       \u251c\u2500\u2500 persons_controller.py   # Person management API\n\u2502       \u2514\u2500\u2500 accounts_controller.py  # Account management API\n\u251c\u2500\u2500 application/\n\u2502   \u251c\u2500\u2500 commands/\n\u2502   \u2502   \u251c\u2500\u2500 persons/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 register_person_command.py\n\u2502   \u2502   \u2514\u2500\u2500 accounts/\n\u2502   \u2502       \u251c\u2500\u2500 open_account_command.py\n\u2502   \u2502       \u2514\u2500\u2500 deposit_command.py\n\u2502   \u251c\u2500\u2500 queries/\n\u2502   \u2502   \u251c\u2500\u2500 person_by_id.py\n\u2502   \u2502   \u2514\u2500\u2500 account_by_owner.py\n\u2502   \u2514\u2500\u2500 events/\n\u2502       \u251c\u2500\u2500 integration/\n\u2502       \u2502   \u2514\u2500\u2500 person_registered_handler.py\n\u2502       \u2514\u2500\u2500 domain/\n\u251c\u2500\u2500 domain/\n\u2502   \u2514\u2500\u2500 models/\n\u2502       \u251c\u2500\u2500 person.py               # Person aggregate\n\u2502       \u251c\u2500\u2500 account.py              # Account aggregate\n\u2502       \u2514\u2500\u2500 address.py              # Address value object\n\u2514\u2500\u2500 integration/\n    \u251c\u2500\u2500 models/                     # DTOs and read models\n    \u2502   \u251c\u2500\u2500 person.py\n    \u2502   \u2514\u2500\u2500 account.py\n    \u2514\u2500\u2500 commands/                   # API command DTOs\n        \u2514\u2500\u2500 persons/\n            \u2514\u2500\u2500 register_person_command_dto.py\n</code></pre>"},{"location":"samples/openbank/#domain-models","title":"\ud83c\udfdb\ufe0f Domain Models","text":""},{"location":"samples/openbank/#person-aggregate","title":"Person Aggregate","text":"<p>The Person aggregate manages person registration and personal information:</p> <pre><code>from dataclasses import dataclass\nfrom datetime import date\nfrom neuroglia.data.abstractions import AggregateRoot\nfrom samples.openbank.integration import PersonGender\n\n@dataclass\nclass PersonState:\n    \"\"\"Person aggregate state\"\"\"\n    id: str = None\n    first_name: str = None\n    last_name: str = None\n    nationality: str = None\n    gender: PersonGender = None\n    date_of_birth: date = None\n    address: Address = None\n\nclass Person(AggregateRoot[str]):\n    \"\"\"Person aggregate root\"\"\"\n\n    def __init__(self, id: str = None):\n        super().__init__(id)\n        self.state = PersonState()\n\n    def register(self, first_name: str, last_name: str, nationality: str, \n                gender: PersonGender, date_of_birth: date, address: Address):\n        \"\"\"Register a new person\"\"\"\n\n        # Validate business rules\n        if not first_name or not last_name:\n            raise ValueError(\"First name and last name are required\")\n\n        if date_of_birth &gt;= date.today():\n            raise ValueError(\"Date of birth must be in the past\")\n\n        # Raise domain event\n        self.apply(PersonRegisteredEvent(\n            person_id=self.id,\n            first_name=first_name,\n            last_name=last_name,\n            nationality=nationality,\n            gender=gender,\n            date_of_birth=date_of_birth,\n            address=address\n        ))\n\n    def update_address(self, new_address: Address):\n        \"\"\"Update person's address\"\"\"\n        self.apply(PersonAddressUpdatedEvent(\n            person_id=self.id,\n            old_address=self.state.address,\n            new_address=new_address\n        ))\n\n    # Event handlers\n    def on_person_registered(self, event: PersonRegisteredEvent):\n        \"\"\"Handle person registered event\"\"\"\n        self.state.id = event.person_id\n        self.state.first_name = event.first_name\n        self.state.last_name = event.last_name\n        self.state.nationality = event.nationality\n        self.state.gender = event.gender\n        self.state.date_of_birth = event.date_of_birth\n        self.state.address = event.address\n\n    def on_person_address_updated(self, event: PersonAddressUpdatedEvent):\n        \"\"\"Handle address updated event\"\"\"\n        self.state.address = event.new_address\n</code></pre>"},{"location":"samples/openbank/#account-aggregate","title":"Account Aggregate","text":"<p>The Account aggregate manages banking accounts and transactions:</p> <pre><code>from decimal import Decimal\nfrom neuroglia.data.abstractions import AggregateRoot\n\n@dataclass\nclass AccountState:\n    \"\"\"Account aggregate state\"\"\"\n    id: str = None\n    owner_id: str = None\n    account_number: str = None\n    balance: Decimal = Decimal('0.00')\n    currency: str = 'USD'\n    is_active: bool = True\n\nclass Account(AggregateRoot[str]):\n    \"\"\"Account aggregate root\"\"\"\n\n    def __init__(self, id: str = None):\n        super().__init__(id)\n        self.state = AccountState()\n\n    def open(self, owner_id: str, account_number: str, initial_deposit: Decimal = None):\n        \"\"\"Open a new account\"\"\"\n\n        # Validate business rules\n        if not owner_id:\n            raise ValueError(\"Owner ID is required\")\n\n        if not account_number:\n            raise ValueError(\"Account number is required\")\n\n        if initial_deposit and initial_deposit &lt; Decimal('0'):\n            raise ValueError(\"Initial deposit cannot be negative\")\n\n        # Raise domain event\n        self.apply(AccountOpenedEvent(\n            account_id=self.id,\n            owner_id=owner_id,\n            account_number=account_number,\n            initial_deposit=initial_deposit or Decimal('0.00')\n        ))\n\n    def deposit(self, amount: Decimal, description: str = None):\n        \"\"\"Deposit money to the account\"\"\"\n\n        # Validate business rules\n        if amount &lt;= Decimal('0'):\n            raise ValueError(\"Deposit amount must be positive\")\n\n        if not self.state.is_active:\n            raise ValueError(\"Cannot deposit to inactive account\")\n\n        # Raise domain event\n        self.apply(MoneyDepositedEvent(\n            account_id=self.id,\n            amount=amount,\n            description=description,\n            balance_after=self.state.balance + amount\n        ))\n\n    def withdraw(self, amount: Decimal, description: str = None):\n        \"\"\"Withdraw money from the account\"\"\"\n\n        # Validate business rules\n        if amount &lt;= Decimal('0'):\n            raise ValueError(\"Withdrawal amount must be positive\")\n\n        if not self.state.is_active:\n            raise ValueError(\"Cannot withdraw from inactive account\")\n\n        if self.state.balance &lt; amount:\n            raise ValueError(\"Insufficient funds\")\n\n        # Raise domain event\n        self.apply(MoneyWithdrawnEvent(\n            account_id=self.id,\n            amount=amount,\n            description=description,\n            balance_after=self.state.balance - amount\n        ))\n\n    # Event handlers\n    def on_account_opened(self, event: AccountOpenedEvent):\n        \"\"\"Handle account opened event\"\"\"\n        self.state.id = event.account_id\n        self.state.owner_id = event.owner_id\n        self.state.account_number = event.account_number\n        self.state.balance = event.initial_deposit\n\n    def on_money_deposited(self, event: MoneyDepositedEvent):\n        \"\"\"Handle money deposited event\"\"\"\n        self.state.balance = event.balance_after\n\n    def on_money_withdrawn(self, event: MoneyWithdrawnEvent):\n        \"\"\"Handle money withdrawn event\"\"\"\n        self.state.balance = event.balance_after\n</code></pre>"},{"location":"samples/openbank/#application-layer","title":"\ud83d\udcbc Application Layer","text":""},{"location":"samples/openbank/#command-handlers","title":"Command Handlers","text":"<p>Command handlers execute business operations:</p> <pre><code>from neuroglia.mediation.mediator import CommandHandler\nfrom neuroglia.data.infrastructure.abstractions import Repository\n\nclass RegisterPersonCommandHandler(CommandHandler[RegisterPersonCommand, OperationResult[PersonDto]]):\n    \"\"\"Handles person registration commands\"\"\"\n\n    def __init__(self, \n                 mapper: Mapper,\n                 person_repository: Repository[Person, str]):\n        self.mapper = mapper\n        self.person_repository = person_repository\n\n    async def handle_async(self, command: RegisterPersonCommand) -&gt; OperationResult[PersonDto]:\n        try:\n            # Create new person aggregate\n            person = Person(str(uuid.uuid4()))\n\n            # Execute business operation\n            person.register(\n                first_name=command.first_name,\n                last_name=command.last_name,\n                nationality=command.nationality,\n                gender=command.gender,\n                date_of_birth=command.date_of_birth,\n                address=command.address\n            )\n\n            # Save to event store\n            saved_person = await self.person_repository.add_async(person)\n\n            # Map to DTO and return\n            person_dto = self.mapper.map(saved_person.state, PersonDto)\n            return self.created(person_dto)\n\n        except ValueError as ex:\n            return self.bad_request(str(ex))\n        except Exception as ex:\n            return self.internal_error(f\"Failed to register person: {ex}\")\n\nclass DepositCommandHandler(CommandHandler[DepositCommand, OperationResult[AccountDto]]):\n    \"\"\"Handles money deposit commands\"\"\"\n\n    def __init__(self, \n                 mapper: Mapper,\n                 account_repository: Repository[Account, str]):\n        self.mapper = mapper\n        self.account_repository = account_repository\n\n    async def handle_async(self, command: DepositCommand) -&gt; OperationResult[AccountDto]:\n        try:\n            # Load account from event store\n            account = await self.account_repository.get_by_id_async(command.account_id)\n            if account is None:\n                return self.not_found(\"Account not found\")\n\n            # Execute business operation\n            account.deposit(command.amount, command.description)\n\n            # Save changes\n            await self.account_repository.update_async(account)\n\n            # Map to DTO and return\n            account_dto = self.mapper.map(account.state, AccountDto)\n            return self.ok(account_dto)\n\n        except ValueError as ex:\n            return self.bad_request(str(ex))\n        except Exception as ex:\n            return self.internal_error(f\"Failed to deposit money: {ex}\")\n</code></pre>"},{"location":"samples/openbank/#query-handlers","title":"Query Handlers","text":"<p>Query handlers retrieve data for read operations:</p> <pre><code>class GetPersonByIdQueryHandler(QueryHandler[GetPersonByIdQuery, OperationResult[PersonDto]]):\n    \"\"\"Handles person lookup queries\"\"\"\n\n    def __init__(self, \n                 mapper: Mapper,\n                 person_repository: Repository[PersonDto, str]):  # Read model repository\n        self.mapper = mapper\n        self.person_repository = person_repository\n\n    async def handle_async(self, query: GetPersonByIdQuery) -&gt; OperationResult[PersonDto]:\n        person = await self.person_repository.get_by_id_async(query.person_id)\n\n        if person is None:\n            return self.not_found(f\"Person with ID {query.person_id} not found\")\n\n        return self.ok(person)\n\nclass GetAccountsByOwnerQueryHandler(QueryHandler[GetAccountsByOwnerQuery, OperationResult[List[AccountDto]]]):\n    \"\"\"Handles account lookup by owner queries\"\"\"\n\n    def __init__(self, account_repository: Repository[AccountDto, str]):\n        self.account_repository = account_repository\n\n    async def handle_async(self, query: GetAccountsByOwnerQuery) -&gt; OperationResult[List[AccountDto]]:\n        accounts = await self.account_repository.find_by_criteria_async(\n            {\"owner_id\": query.owner_id}\n        )\n        return self.ok(accounts)\n</code></pre>"},{"location":"samples/openbank/#event-handling","title":"\ud83d\udce1 Event Handling","text":""},{"location":"samples/openbank/#domain-events","title":"Domain Events","text":"<p>Domain events represent business events within aggregates:</p> <pre><code>@dataclass\nclass PersonRegisteredEvent(DomainEvent):\n    \"\"\"Event raised when a person is registered\"\"\"\n    person_id: str\n    first_name: str\n    last_name: str\n    nationality: str\n    gender: PersonGender\n    date_of_birth: date\n    address: Address\n\n@dataclass\nclass AccountOpenedEvent(DomainEvent):\n    \"\"\"Event raised when an account is opened\"\"\"\n    account_id: str\n    owner_id: str\n    account_number: str\n    initial_deposit: Decimal\n\n@dataclass\nclass MoneyDepositedEvent(DomainEvent):\n    \"\"\"Event raised when money is deposited\"\"\"\n    account_id: str\n    amount: Decimal\n    description: str\n    balance_after: Decimal\n</code></pre>"},{"location":"samples/openbank/#integration-events","title":"Integration Events","text":"<p>Integration events handle cross-bounded-context communication:</p> <pre><code>class PersonRegisteredIntegrationEventHandler(EventHandler[PersonRegisteredEvent]):\n    \"\"\"Handles person registered events for integration purposes\"\"\"\n\n    def __init__(self, \n                 cloud_event_publisher: CloudEventPublisher,\n                 mapper: Mapper):\n        self.cloud_event_publisher = cloud_event_publisher\n        self.mapper = mapper\n\n    async def handle_async(self, event: PersonRegisteredEvent):\n        # Create integration event\n        integration_event = PersonRegisteredIntegrationEvent(\n            person_id=event.person_id,\n            email=event.email,\n            full_name=f\"{event.first_name} {event.last_name}\",\n            timestamp=datetime.utcnow()\n        )\n\n        # Publish as CloudEvent\n        await self.cloud_event_publisher.publish_async(\n            event_type=\"person.registered.v1\",\n            data=integration_event,\n            source=\"openbank.persons\"\n        )\n</code></pre>"},{"location":"samples/openbank/#data-access","title":"\ud83d\uddc4\ufe0f Data Access","text":""},{"location":"samples/openbank/#event-sourcing-repository","title":"Event Sourcing Repository","text":"<p>The write model uses event sourcing:</p> <pre><code># Configuration in main.py\nfrom neuroglia.data.infrastructure.event_sourcing import EventSourcingRepository\nfrom neuroglia.data.infrastructure.event_sourcing.event_store import ESEventStore\n\n# Configure Event Store\nESEventStore.configure(builder, EventStoreOptions(database_name, consumer_group))\n\n# Configure event sourcing repositories\nDataAccessLayer.WriteModel.configure(\n    builder, \n    [\"samples.openbank.domain.models\"], \n    lambda builder_, entity_type, key_type: EventSourcingRepository.configure(\n        builder_, entity_type, key_type\n    )\n)\n</code></pre>"},{"location":"samples/openbank/#read-model-repository","title":"Read Model Repository","text":"<p>The read model uses MongoDB:</p> <pre><code># Configuration in main.py\nfrom neuroglia.data.infrastructure.mongo import MongoRepository\n\n# Configure MongoDB repositories\nDataAccessLayer.ReadModel.configure(\n    builder,\n    [\"samples.openbank.integration.models\", \"samples.openbank.application.events\"],\n    lambda builder_, entity_type, key_type: MongoRepository.configure(\n        builder_, entity_type, key_type, database_name\n    )\n)\n</code></pre>"},{"location":"samples/openbank/#api-layer","title":"\ud83c\udf10 API Layer","text":""},{"location":"samples/openbank/#controllers","title":"Controllers","text":"<p>Controllers expose the domain through REST APIs:</p> <pre><code>class PersonsController(ControllerBase):\n    \"\"\"Persons management API\"\"\"\n\n    @post(\"/\", response_model=PersonDto, status_code=201)\n    async def register_person(self, command: RegisterPersonCommandDto) -&gt; PersonDto:\n        \"\"\"Register a new person\"\"\"\n        # Map DTO to domain command\n        domain_command = self.mapper.map(command, RegisterPersonCommand)\n\n        # Execute through mediator\n        result = await self.mediator.execute_async(domain_command)\n\n        # Process and return result\n        return self.process(result)\n\n    @get(\"/\", response_model=List[PersonDto])\n    async def list_persons(self) -&gt; List[PersonDto]:\n        \"\"\"List all registered persons\"\"\"\n        query = ListPersonsQuery()\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/{person_id}\", response_model=PersonDto)\n    async def get_person_by_id(self, person_id: str) -&gt; PersonDto:\n        \"\"\"Get person by ID\"\"\"\n        query = GetPersonByIdQuery(person_id=person_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\nclass AccountsController(ControllerBase):\n    \"\"\"Accounts management API\"\"\"\n\n    @post(\"/\", response_model=AccountDto, status_code=201)\n    async def open_account(self, command: OpenAccountCommandDto) -&gt; AccountDto:\n        \"\"\"Open a new account\"\"\"\n        domain_command = self.mapper.map(command, OpenAccountCommand)\n        result = await self.mediator.execute_async(domain_command)\n        return self.process(result)\n\n    @post(\"/{account_id}/deposit\", response_model=AccountDto)\n    async def deposit(self, account_id: str, command: DepositCommandDto) -&gt; AccountDto:\n        \"\"\"Deposit money to account\"\"\"\n        domain_command = self.mapper.map(command, DepositCommand)\n        domain_command.account_id = account_id\n        result = await self.mediator.execute_async(domain_command)\n        return self.process(result)\n\n    @get(\"/by-owner/{owner_id}\", response_model=List[AccountDto])\n    async def get_accounts_by_owner(self, owner_id: str) -&gt; List[AccountDto]:\n        \"\"\"Get all accounts for a person\"\"\"\n        query = GetAccountsByOwnerQuery(owner_id=owner_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"samples/openbank/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"samples/openbank/#unit-tests","title":"Unit Tests","text":"<p>Test domain logic in isolation:</p> <pre><code>def test_person_registration():\n    # Arrange\n    person = Person(\"test-id\")\n    address = Address(\"123 Main St\", \"Anytown\", \"12345\", \"USA\")\n\n    # Act\n    person.register(\n        first_name=\"John\",\n        last_name=\"Doe\",\n        nationality=\"US\",\n        gender=PersonGender.MALE,\n        date_of_birth=date(1990, 1, 1),\n        address=address\n    )\n\n    # Assert\n    assert person.state.first_name == \"John\"\n    assert person.state.last_name == \"Doe\"\n    assert len(person.uncommitted_events) == 1\n    assert isinstance(person.uncommitted_events[0], PersonRegisteredEvent)\n\ndef test_account_deposit():\n    # Arrange\n    account = Account(\"test-account\")\n    account.open(\"owner-id\", \"123456789\", Decimal('100.00'))\n\n    # Act\n    account.deposit(Decimal('50.00'), \"Test deposit\")\n\n    # Assert\n    assert account.state.balance == Decimal('150.00')\n    assert len(account.uncommitted_events) == 2  # Open + Deposit\n</code></pre>"},{"location":"samples/openbank/#integration-tests","title":"Integration Tests","text":"<p>Test the complete flow:</p> <pre><code>@pytest.mark.asyncio\nasync def test_person_registration_flow():\n    # Arrange\n    client = TestClient(app)\n    person_data = {\n        \"first_name\": \"John\",\n        \"last_name\": \"Doe\",\n        \"nationality\": \"US\",\n        \"gender\": \"MALE\",\n        \"date_of_birth\": \"1990-01-01\",\n        \"address\": {\n            \"street\": \"123 Main St\",\n            \"city\": \"Anytown\",\n            \"postal_code\": \"12345\",\n            \"country\": \"USA\"\n        }\n    }\n\n    # Act\n    response = client.post(\"/api/v1/persons\", json=person_data)\n\n    # Assert\n    assert response.status_code == 201\n    person = response.json()\n    assert person[\"first_name\"] == \"John\"\n    assert person[\"last_name\"] == \"Doe\"\n\n    # Verify person can be retrieved\n    get_response = client.get(f\"/api/v1/persons/{person['id']}\")\n    assert get_response.status_code == 200\n</code></pre>"},{"location":"samples/openbank/#running-the-sample","title":"\ud83d\ude80 Running the Sample","text":""},{"location":"samples/openbank/#start-the-application","title":"Start the Application","text":"<ol> <li>Start infrastructure:</li> </ol> <pre><code>docker-compose up -d\n</code></pre> <ol> <li>Run the application:</li> </ol> <pre><code>python api/main.py\n</code></pre>"},{"location":"samples/openbank/#example-api-calls","title":"Example API Calls","text":"<p>Register a Person:</p> <pre><code>curl -X POST \"http://localhost:8000/api/v1/persons\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"first_name\": \"John\",\n    \"last_name\": \"Doe\",\n    \"nationality\": \"US\",\n    \"gender\": \"MALE\",\n    \"date_of_birth\": \"1990-01-01\",\n    \"address\": {\n      \"street\": \"123 Main St\",\n      \"city\": \"Anytown\",\n      \"postal_code\": \"12345\",\n      \"country\": \"USA\"\n    }\n  }'\n</code></pre> <p>Open an Account:</p> <pre><code>curl -X POST \"http://localhost:8000/api/v1/accounts\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"owner_id\": \"PERSON_ID_FROM_ABOVE\",\n    \"account_number\": \"123456789\",\n    \"initial_deposit\": 1000.00\n  }'\n</code></pre> <p>Deposit Money:</p> <pre><code>curl -X POST \"http://localhost:8000/api/v1/accounts/ACCOUNT_ID/deposit\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"amount\": 500.00,\n    \"description\": \"Salary deposit\"\n  }'\n</code></pre>"},{"location":"samples/openbank/#key-learnings","title":"\ud83d\udccb Key Learnings","text":"<p>The OpenBank sample demonstrates:</p> <ol> <li>Event Sourcing: How to store state as a sequence of events</li> <li>CQRS: Separation of write and read models</li> <li>Domain-Driven Design: Rich domain models with business rules</li> <li>Clean Architecture: Clear separation of concerns</li> <li>Event-Driven Architecture: How events enable loose coupling</li> <li>Repository Pattern: Abstract data access for different storage types</li> <li>Integration Events: Cross-bounded-context communication</li> </ol>"},{"location":"samples/openbank/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Basic Neuroglia concepts</li> <li>Architecture Guide - Understanding the architecture</li> <li>Event Sourcing - Event sourcing patterns</li> <li>CQRS &amp; Mediation - Command and query patterns</li> <li>Event Handling - Event-driven architecture</li> </ul>"}]}