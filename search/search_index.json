{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83e\udde0 Neuroglia Python Framework","text":"<p>A lightweight, opinionated Python framework built on FastAPI that enforces clean architecture principles and provides comprehensive tooling for building production-ready microservices.</p>"},{"location":"#perfect-for","title":"\ud83c\udfaf Perfect For","text":"<ul> <li>Microservices: Clean architecture for scalable service development</li> <li>Event-Driven Systems: Built-in CloudEvents and domain event support</li> <li>API Development: FastAPI-based with automatic OpenAPI documentation</li> <li>Domain-Driven Design: Enforce DDD patterns and bounded contexts</li> <li>Clean Code: Opinionated structure that promotes maintainable code</li> </ul>"},{"location":"#whats-included","title":"\ud83d\ude80 What's Included","text":""},{"location":"#framework-core","title":"\ud83c\udfd7\ufe0f Framework Core","text":"<p>Clean architecture patterns with dependency injection, CQRS, event-driven design, and comprehensive testing utilities.</p>"},{"location":"#real-world-samples","title":"\ud83c\udf55 Real-World Samples","text":"<p>Complete production examples like Mario's Pizzeria demonstrating every framework feature in realistic business scenarios.</p>"},{"location":"#cli-tooling","title":"\u2699\ufe0f CLI Tooling","text":"<p>PyNeuroctl command-line interface for managing, testing, and deploying your applications with zero configuration.</p>"},{"location":"#key-features","title":"\u2728 Key Features","text":"<ul> <li>\ud83c\udfaf CQRS &amp; Mediation: Built-in Command Query Responsibility Segregation with mediator pattern</li> <li>\ud83d\udc89 Dependency Injection: Lightweight container with automatic service discovery</li> <li>\ud83d\udd0c MVC Controllers: Class-based controllers with automatic OpenAPI generation</li> <li>\ud83d\udce1 Event-Driven: Native CloudEvents support and domain event handling</li> <li>\ud83d\uddc4\ufe0f Data Access: Repository pattern with file-based, MongoDB, and event sourcing support</li> <li>\ud83e\uddea Testing Utilities: Comprehensive testing patterns for all architectural layers</li> </ul>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"<p>Coming soon: Get started with Neuroglia in minutes:</p> <pre><code># Install the framework\npip install neuroglia\n\n# Create your first app\npyneuroctl new myapp --template minimal\ncd myapp\n\n# Run the application\npython main.py\n</code></pre> <p>Visit <code>http://localhost:8000/docs</code> to explore the auto-generated API documentation.</p>"},{"location":"#learn-more","title":"\ud83d\udcda Learn More","text":"<ul> <li>Getting Started - Step-by-step tutorial building your first application</li> <li>Mario's Pizzeria - Complete bounded context with visual architecture diagrams</li> <li>Patterns - Software design patterns and best practices</li> <li>Features - Deep dive into framework capabilities</li> <li>Guides - How-to procedures and troubleshooting</li> </ul>"},{"location":"#reference-documentation","title":"\ud83d\udcd6 Reference Documentation","text":"<ul> <li>Source Code Naming Conventions - Comprehensive naming patterns for maintainable codebases</li> <li>12-Factor App Compliance - How Neuroglia meets cloud-native application standards</li> <li>Python Typing Guide - Complete guide to type hints, generics, and advanced typing patterns</li> <li>OAuth OIDC</li> </ul> <p>Neuroglia Python Framework - Building better software through better architecture \ud83e\udde0\u2728</p>"},{"location":"ai-agent-guide/","title":"\ud83e\udd16 AI Agent Quick Reference Guide","text":"<p>Fast-track guide for AI agents to understand and work with the Neuroglia Python Framework</p>"},{"location":"ai-agent-guide/#framework-overview","title":"\ud83c\udfaf Framework Overview","text":"<p>Neuroglia is a clean architecture Python framework built on FastAPI that enforces separation of concerns, CQRS, dependency injection, and event-driven patterns for maintainable microservices.</p>"},{"location":"ai-agent-guide/#core-architecture","title":"\ud83c\udfd7\ufe0f Core Architecture","text":"<pre><code>src/\n\u251c\u2500\u2500 api/           # \ud83c\udf10 Controllers, DTOs, Routes (FastAPI)\n\u251c\u2500\u2500 application/   # \ud83d\udcbc Commands, Queries, Handlers, Services\n\u251c\u2500\u2500 domain/        # \ud83c\udfdb\ufe0f Entities, Value Objects, Business Rules\n\u2514\u2500\u2500 integration/   # \ud83d\udd0c Repositories, External APIs, Infrastructure\n</code></pre> <p>Dependency Rule: <code>API \u2192 Application \u2192 Domain \u2190 Integration</code></p>"},{"location":"ai-agent-guide/#quick-start-patterns","title":"\u26a1 Quick Start Patterns","text":""},{"location":"ai-agent-guide/#1-cqrs-commandquery-pattern","title":"1. CQRS Command/Query Pattern","text":"<pre><code># Commands (Write operations)\n@dataclass\nclass CreateOrderCommand(Command[Order]):\n    customer_id: str\n    items: List[OrderItemDto]\n\nclass CreateOrderHandler(CommandHandler[CreateOrderCommand, Order]):\n    async def handle_async(self, command: CreateOrderCommand) -&gt; Order:\n        # Business logic here\n        return order\n\n# Queries (Read operations)\n@dataclass\nclass GetOrderQuery(Query[Optional[Order]]):\n    order_id: str\n\nclass GetOrderHandler(QueryHandler[GetOrderQuery, Optional[Order]]):\n    async def handle_async(self, query: GetOrderQuery) -&gt; Optional[Order]:\n        return await self.repository.get_by_id_async(query.order_id)\n</code></pre>"},{"location":"ai-agent-guide/#2-api-controllers-fastapi-integration","title":"2. API Controllers (FastAPI Integration)","text":"<pre><code>from neuroglia.mvc import ControllerBase\nfrom classy_fastapi.decorators import get, post\n\nclass OrdersController(ControllerBase):\n    @post(\"/\", response_model=OrderDto, status_code=201)\n    async def create_order(self, dto: CreateOrderDto) -&gt; OrderDto:\n        command = self.mapper.map(dto, CreateOrderCommand)\n        order = await self.mediator.execute_async(command)\n        return self.mapper.map(order, OrderDto)\n\n    @get(\"/{order_id}\", response_model=OrderDto)\n    async def get_order(self, order_id: str) -&gt; OrderDto:\n        query = GetOrderQuery(order_id=order_id)\n        order = await self.mediator.execute_async(query)\n        return self.mapper.map(order, OrderDto)\n</code></pre>"},{"location":"ai-agent-guide/#3-repository-pattern","title":"3. Repository Pattern","text":"<pre><code># Abstract repository\nclass OrderRepository(Repository[Order, str]):\n    async def get_by_customer_async(self, customer_id: str) -&gt; List[Order]:\n        pass\n\n# MongoDB implementation\nclass MongoOrderRepository(MongoRepository[Order, str]):\n    async def get_by_customer_async(self, customer_id: str) -&gt; List[Order]:\n        cursor = self.collection.find({\"customer_id\": customer_id})\n        return [self._to_entity(doc) async for doc in cursor]\n</code></pre>"},{"location":"ai-agent-guide/#4-dependency-injection-application-setup","title":"4. Dependency Injection &amp; Application Setup","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\n\ndef create_app():\n    builder = WebApplicationBuilder()\n    services = builder.services\n\n    # Register services\n    services.add_scoped(OrderRepository, MongoOrderRepository)\n    services.add_mediator()  # Auto-discovers handlers\n    services.add_controllers([\"api.controllers\"])\n    services.add_object_mapping()\n\n    app = builder.build()\n    app.use_controllers()\n    return app\n</code></pre>"},{"location":"ai-agent-guide/#framework-modules-reference","title":"\ud83e\udde9 Framework Modules Reference","text":"Module Purpose Key Classes <code>neuroglia.core</code> Base types, utilities <code>OperationResult</code>, <code>Entity</code>, <code>ValueObject</code> <code>neuroglia.dependency_injection</code> DI container <code>ServiceCollection</code>, <code>ServiceProvider</code>, <code>ServiceLifetime</code> <code>neuroglia.mediation</code> CQRS patterns <code>Mediator</code>, <code>Command</code>, <code>Query</code>, <code>CommandHandler</code>, <code>QueryHandler</code> <code>neuroglia.mvc</code> FastAPI controllers <code>ControllerBase</code>, auto-discovery <code>neuroglia.data</code> Repository &amp; persistence <code>Repository</code>, <code>MongoRepository</code>, <code>InMemoryRepository</code>, <code>EventStore</code> <code>neuroglia.data.resources</code> Resource management <code>ResourceController</code>, <code>ResourceWatcher</code>, <code>Reconciler</code> <code>neuroglia.eventing</code> Event handling <code>DomainEvent</code>, <code>EventHandler</code>, <code>EventBus</code> <code>neuroglia.eventing.cloud_events</code> CloudEvents integration <code>CloudEvent</code>, <code>CloudEventPublisher</code>, <code>CloudEventIngestor</code> <code>neuroglia.mapping</code> Object mapping <code>Mapper</code>, convention-based mapping <code>neuroglia.hosting</code> App lifecycle <code>WebApplicationBuilder</code>, <code>WebApplication</code>, <code>HostedService</code> <code>neuroglia.serialization</code> JSON/data serialization <code>JsonSerializer</code>, <code>JsonEncoder</code>, <code>TypeRegistry</code> <code>neuroglia.validation</code> Business rule validation <code>BusinessRule</code>, <code>ValidationResult</code>, <code>PropertyValidator</code>, <code>EntityValidator</code> <code>neuroglia.reactive</code> Reactive programming <code>Observable</code>, <code>Observer</code> (RxPy integration) <code>neuroglia.integration</code> External services <code>HttpServiceClient</code>, <code>CacheRepository</code>, <code>BackgroundTaskScheduler</code> <code>neuroglia.utils</code> Utility functions <code>CaseConversion</code>, <code>CamelModel</code>, <code>TypeFinder</code> <code>neuroglia.expressions</code> Expression evaluation <code>JavaScriptExpressionTranslator</code> <code>neuroglia.logging</code> Enhanced logging Structured logging, correlation IDs, performance monitoring"},{"location":"ai-agent-guide/#sample-applications","title":"\ud83d\udcc1 Sample Applications","text":"<p>The framework includes complete sample applications that demonstrate real-world usage:</p>"},{"location":"ai-agent-guide/#marios-pizzeria-samplesmario-pizzeria","title":"\ud83c\udf55 Mario's Pizzeria (<code>samples/mario-pizzeria/</code>)","text":"<ul> <li>Full CQRS implementation with sophisticated domain models</li> <li>MongoDB repositories for orders, customers, pizzas</li> <li>Event-driven architecture with domain events</li> <li>Complete API with OpenAPI documentation</li> </ul> <p>Key Files:</p> <ul> <li><code>domain/entities/</code>: <code>Order</code>, <code>Pizza</code>, <code>Customer</code> with business logic</li> <li><code>application/commands/</code>: <code>PlaceOrderCommand</code>, <code>CreatePizzaCommand</code></li> <li><code>application/queries/</code>: <code>GetOrderByIdQuery</code>, <code>GetMenuItemsQuery</code></li> <li><code>api/controllers/</code>: <code>OrdersController</code>, <code>MenuController</code></li> </ul>"},{"location":"ai-agent-guide/#openbank-samplesopenbank","title":"\ud83c\udfe6 OpenBank (<code>samples/openbank/</code>)","text":"<ul> <li>Event sourcing with EventStore</li> <li>Complex domain modeling (accounts, transactions)</li> <li>Banking business rules and validation</li> </ul>"},{"location":"ai-agent-guide/#desktop-controller-samplesdesktop-controller","title":"\ud83c\udf9b\ufe0f Desktop Controller (<code>samples/desktop-controller/</code>)","text":"<ul> <li>Background services and scheduled tasks</li> <li>System integration patterns</li> <li>Resource management examples</li> </ul>"},{"location":"ai-agent-guide/#lab-resource-manager-sampleslab-resource-manager","title":"\ud83e\uddea Lab Resource Manager (<code>samples/lab-resource-manager/</code>)","text":"<ul> <li>Resource-Oriented Architecture (ROA)</li> <li>Watcher/Controller patterns (like Kubernetes operators)</li> <li>Reconciliation loops for resource management</li> </ul>"},{"location":"ai-agent-guide/#api-gateway-samplesapi-gateway","title":"\ud83c\udf10 API Gateway (<code>samples/api-gateway/</code>)","text":"<ul> <li>Microservice gateway patterns</li> <li>AI/ML integration examples</li> <li>Service orchestration and routing</li> <li>Background task processing with Redis</li> </ul>"},{"location":"ai-agent-guide/#where-to-find-information","title":"\ud83d\udd0d Where to Find Information","text":""},{"location":"ai-agent-guide/#documentation-structure-docs","title":"\ud83d\udcda Documentation Structure (<code>docs/</code>)","text":"Section Purpose Key Files <code>getting-started.md</code> Framework introduction Quick start, core concepts <code>features/</code> Feature documentation One file per major feature <code>patterns/</code> Architecture patterns CQRS, Clean Architecture, Event Sourcing <code>samples/</code> Sample walkthroughs Detailed sample explanations <code>references/</code> Technical references Python best practices, 12-Factor App <code>guides/</code> Step-by-step tutorials Mario's Pizzeria tutorial"},{"location":"ai-agent-guide/#key-documentation-files","title":"\ud83c\udfaf Key Documentation Files","text":"<ul> <li>Getting Started - Framework overview and quick start</li> <li>Mario's Pizzeria Tutorial - Complete walkthrough</li> <li>CQRS &amp; Mediation - Command/Query patterns</li> <li>MVC Controllers - FastAPI controller patterns</li> <li>Data Access - Repository and persistence</li> <li>Dependency Injection - DI container usage</li> <li>Python Typing Guide - Type hints &amp; generics</li> </ul>"},{"location":"ai-agent-guide/#additional-resources","title":"\ud83d\udcd6 Additional Resources","text":"<ul> <li><code>README.md</code> - Project overview and installation</li> <li><code>pyproject.toml</code> - Dependencies and build configuration</li> <li><code>src/neuroglia/</code> - Complete framework source code</li> <li><code>tests/</code> - Comprehensive test suite with examples</li> </ul>"},{"location":"ai-agent-guide/#common-patterns-best-practices","title":"\ud83d\udca1 Common Patterns &amp; Best Practices","text":""},{"location":"ai-agent-guide/#do-this","title":"\u2705 Do This","text":"<pre><code># \u2705 Use constructor injection\nclass OrderService:\n    def __init__(self, repository: OrderRepository, event_bus: EventBus):\n        self.repository = repository\n        self.event_bus = event_bus\n\n# \u2705 Separate commands and queries\nclass PlaceOrderCommand(Command[Order]): pass\nclass GetOrderQuery(Query[Optional[Order]]): pass\n\n# \u2705 Use domain events\nclass Order(Entity):\n    def place_order(self):\n        # Business logic\n        self.raise_event(OrderPlacedEvent(order_id=self.id))\n\n# \u2705 Type hints everywhere\nasync def handle_async(self, command: PlaceOrderCommand) -&gt; Order:\n    return order\n</code></pre>"},{"location":"ai-agent-guide/#avoid-this","title":"\u274c Avoid This","text":"<pre><code># \u274c Direct database access in controllers\nclass OrderController:\n    def create_order(self):\n        # Don't access database directly\n        connection.execute(\"INSERT INTO...\")\n\n# \u274c Mixing concerns\nclass OrderHandler:\n    def handle(self, command):\n        # Don't mix business logic with infrastructure\n        send_email()  # Infrastructure concern\n\n# \u274c Missing type hints\ndef process_order(order):  # What type is order?\n    return result  # What type is result?\n</code></pre>"},{"location":"ai-agent-guide/#quick-commands","title":"\ud83d\ude80 Quick Commands","text":"<pre><code># Install framework (when available)\npip install neuroglia\n\n# Run sample applications\ncd samples/mario-pizzeria &amp;&amp; python main.py\ncd samples/openbank &amp;&amp; python main.py\n\n# Run tests\npytest tests/\n\n# Generate documentation\nmkdocs serve\n\n# CLI tool (when available)\npyneuroctl --help\npyneuroctl samples list\npyneuroctl new myapp --template minimal\n</code></pre>"},{"location":"ai-agent-guide/#for-ai-agents-key-takeaways","title":"\ud83c\udfaf For AI Agents: Key Takeaways","text":"<ol> <li>Architecture: Clean Architecture with strict dependency rules</li> <li>Patterns: CQRS, DI, Repository, Domain Events are core</li> <li>Code Style: Heavy use of type hints, dataclasses, async/await</li> <li>Framework Integration: Built on FastAPI, uses Pydantic extensively</li> <li>Sample Code: Always reference <code>samples/mario-pizzeria/</code> for real examples</li> <li>Documentation: Comprehensive docs in <code>docs/</code> with practical examples</li> <li>Testing: Full test coverage with patterns for all architectural layers</li> </ol> <p>When writing Neuroglia code:</p> <ul> <li>Follow the layered architecture strictly</li> <li>Use CQRS for all business operations</li> <li>Leverage dependency injection throughout</li> <li>Include comprehensive type hints</li> <li>Reference Mario's Pizzeria sample for patterns</li> <li>Maintain separation of concerns between layers</li> </ul>"},{"location":"ai-agent-guide/#quick-framework-setup-for-ai-agents","title":"\ud83e\udd16 Quick Framework Setup for AI Agents","text":"<pre><code># Minimal Neuroglia application setup\nfrom neuroglia.hosting.web import WebApplicationBuilder\n\ndef create_app():\n    builder = WebApplicationBuilder()\n\n    # Essential services\n    builder.services.add_mediator()  # CQRS support\n    builder.services.add_controllers([\"api.controllers\"])  # Auto-discover controllers\n    builder.services.add_object_mapping()  # Object mapping\n\n    # Build and configure\n    app = builder.build()\n    app.use_controllers()  # Enable controller routing\n    return app\n\nif __name__ == \"__main__\":\n    app = create_app()\n    app.run()\n</code></pre> <p>Need more detail? Start with Getting Started then dive into specific feature documentation or explore the Mario's Pizzeria sample.</p>"},{"location":"getting-started/","title":"\ud83d\ude80 Getting Started with Neuroglia","text":"<p>Welcome to Neuroglia - a lightweight, opinionated Python framework that enforces clean architecture principles and provides comprehensive tooling for building maintainable microservices.</p> <p>Built on FastAPI, Neuroglia emphasizes CQRS, event-driven architecture, dependency injection, and domain-driven design patterns. Learn how to build REST APIs with FastAPI integration.</p> <p>\ud83c\udfaf Choose Your Learning Path</p> <p>Pick the approach that best fits your current needs and experience level.</p>"},{"location":"getting-started/#what-is-neuroglia","title":"\ud83c\udfd7\ufe0f What is Neuroglia?","text":"<p>Neuroglia is designed around clean architecture principles with strict separation of concerns:</p>"},{"location":"getting-started/#architecture-layers","title":"Architecture Layers","text":"<pre><code>src/\n\u251c\u2500\u2500 api/           # \ud83c\udf10 API Layer (Controllers, DTOs, Routes)\n\u251c\u2500\u2500 application/   # \ud83d\udcbc Application Layer (Commands, Queries, Handlers, Services)\n\u251c\u2500\u2500 domain/        # \ud83c\udfdb\ufe0f Domain Layer (Entities, Value Objects, Business Rules)\n\u2514\u2500\u2500 integration/   # \ud83d\udd0c Integration Layer (External APIs, Repositories, Infrastructure)\n</code></pre> <p>Learn More About Each Layer:</p> <ul> <li>MVC Controllers - Building REST APIs and handling HTTP requests</li> <li>CQRS &amp; Mediation - Application layer command and query patterns</li> <li>Domain-Driven Design - Creating rich domain models and business logic</li> <li>Data Access - Repository pattern and integration layer implementation</li> </ul>"},{"location":"getting-started/#the-dependency-rule","title":"The Dependency Rule","text":"<p>Dependencies only point inward: API \u2192 Application \u2192 Domain \u2190 Integration</p> <pre><code>flowchart TD\n    API[\"\ud83c\udf10 API Layer&lt;br/&gt;Controllers, DTOs, Routes&lt;br/&gt;&lt;i&gt;Handles HTTP requests&lt;/i&gt;\"]\n    APP[\"\ud83d\udcbc Application Layer&lt;br/&gt;Commands, Queries, Handlers&lt;br/&gt;&lt;i&gt;Orchestrates business logic&lt;/i&gt;\"]\n    DOM[\"\ud83c\udfdb\ufe0f Domain Layer&lt;br/&gt;Entities, Value Objects, Business Rules&lt;br/&gt;&lt;i&gt;Pure business logic&lt;/i&gt;\"]\n    INT[\"\ud83d\udd0c Integration Layer&lt;br/&gt;Repositories, External APIs&lt;br/&gt;&lt;i&gt;Infrastructure concerns&lt;/i&gt;\"]\n\n    API --&gt;|\"depends on\"| APP\n    APP --&gt;|\"depends on\"| DOM\n    INT --&gt;|\"depends on\"| DOM\n\n    style DOM fill:#e1f5fe,stroke:#0277bd,stroke-width:3px\n    style APP fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\n    style API fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px\n    style INT fill:#fff3e0,stroke:#f57c00,stroke-width:2px\n\n    classDef dependencyArrow stroke:#1565c0,stroke-width:3px,color:#1565c0</code></pre> <p>\ud83c\udfaf Key Principle</p> <p>The Domain Layer is at the center and has no dependencies on outer layers. This ensures business logic remains pure and testable, while outer layers can be easily swapped without affecting core functionality.</p> <p>External References:</p> <ul> <li>Clean Architecture by Robert C. Martin</li> <li>Domain-Driven Design by Eric Evans</li> <li>Hexagonal Architecture</li> </ul>"},{"location":"getting-started/#core-framework-principles","title":"Core Framework Principles","text":"<ul> <li>\ud83c\udfaf CQRS Pattern - Separate commands (write) from queries (read) for clarity and scalability</li> <li>\ud83c\udfdb\ufe0f Domain-Driven Design - Business logic lives in the domain layer, isolated from infrastructure concerns</li> <li>\ud83d\udc89 Dependency Injection - Constructor-based DI with service lifetime management (Singleton, Scoped, Transient)</li> <li>\ud83d\udce1 Event-Driven Architecture - Domain events enable loose coupling and eventual consistency</li> <li>\ud83e\uddea Test-First Development - Framework designed for comprehensive unit and integration testing</li> <li>\ud83c\udff7\ufe0f Consistent Naming - Enforced naming conventions across all layers for maintainable code</li> </ul>"},{"location":"getting-started/#quick-start-options","title":"\ud83d\ude80 Quick Start Options","text":""},{"location":"getting-started/#3-minute-bootstrap","title":"\u26a1 3-Minute Bootstrap","text":"<p>Perfect for: First-time framework validation, quick demos, proof of concepts</p> <p>Get a \"Hello World\" API running in under 3 minutes to validate your environment and see Neuroglia in action.</p> <p>\ud83d\udc49 Start 3-Minute Bootstrap</p> <p>What you'll get: Simple controller, FastAPI integration, basic project structure</p> <p>Related: MVC Controllers Guide for detailed FastAPI integration patterns</p>"},{"location":"getting-started/#local-development-setup","title":"\ud83d\udee0\ufe0f Local Development Setup","text":"<p>Perfect for: Setting up a complete development environment, team onboarding, production-ready tooling</p> <p>Configure a professional development environment with debugging, testing, linting, and database integration.</p> <p>\ud83d\udc49 Set Up Development Environment</p> <p>What you'll get: IDE configuration, Docker services, testing frameworks, debugging setup</p> <p>Related: Project Setup Guide for comprehensive project scaffolding</p>"},{"location":"getting-started/#complete-tutorial-marios-pizzeria","title":"\ud83c\udf55 Complete Tutorial: Mario's Pizzeria","text":"<p>Perfect for: Learning all framework features, building production applications, comprehensive examples</p> <p>Build a complete pizza ordering system that demonstrates clean architecture, CQRS, event-driven design, authentication, and web development.</p> <p>\ud83d\udc49 Build Mario's Pizzeria</p> <p>What you'll get: Full-stack application with REST API, web UI, authentication, persistence, events</p> <p>Deep Dive Resources:</p> <ul> <li>OAuth, OIDC &amp; JWT Reference - Authentication implementation</li> <li>Event Sourcing Patterns - Event-driven architecture</li> <li>Data Access Guide - Persistence and repository patterns</li> <li>MVC Controllers - REST API development</li> </ul>"},{"location":"getting-started/#framework-features-overview","title":"\ud83d\udd0d Framework Features Overview","text":"Feature Purpose When to Use Dependency Injection Service container and lifetime management All applications - foundation for testability CQRS &amp; Mediation Command/Query separation with pipeline behaviors Complex business logic, cross-cutting concerns MVC Controllers REST API development with FastAPI integration Web APIs, microservices, external interfaces Data Access Repository pattern with MongoDB, file storage Persistence, data abstraction, testing Event Sourcing Event-driven architecture with domain events Complex domains, audit trails, eventual consistency"},{"location":"getting-started/#documentation-structure","title":"\ud83d\udcda Documentation Structure","text":"<p>Deep dive into clean architecture principles, layer responsibilities, and design patterns used throughout Neuroglia.</p> <p>Essential Reading: Architecture Overview for comprehensive framework design principles.</p>"},{"location":"getting-started/#feature-documentation","title":"\ud83d\ude80 Feature Documentation","text":"<p>Comprehensive guides for each framework feature with practical examples and best practices:</p> <ul> <li>Object Mapping - DTO transformations and auto-mapping</li> <li>Background Task Scheduling - Asynchronous processing</li> <li>Enhanced Model Validation - Business rule validation</li> </ul>"},{"location":"getting-started/#sample-applications","title":"\ud83d\udccb Sample Applications","text":"<p>Complete, working applications that demonstrate real-world usage patterns:</p> <ul> <li>Mario's Pizzeria - Complete tutorial application</li> <li>OpenBank - Banking domain with event sourcing</li> <li>API Gateway - Microservice gateway patterns</li> <li>Desktop Controller - Background services and system integration</li> <li>Lab Resource Manager - Watcher and reconciliation patterns</li> </ul>"},{"location":"getting-started/#implementation-guides","title":"\ud83d\udee0\ufe0f Implementation Guides","text":"<p>Step-by-step tutorials for common development scenarios and project setup:</p> <ul> <li>3-Minute Bootstrap - Quick start validation</li> <li>Local Development Setup - Complete dev environment</li> <li>Project Setup - Project scaffolding and structure</li> </ul>"},{"location":"getting-started/#framework-philosophy","title":"\ud83e\udd1d Framework Philosophy","text":"<p>Neuroglia is opinionated by design to promote:</p> <ol> <li>Consistency - Unified patterns across all applications</li> <li>Maintainability - Clear separation of concerns and dependencies</li> <li>Testability - Framework designed for comprehensive testing</li> <li>Productivity - Reduce boilerplate while maintaining flexibility</li> <li>Quality - Built-in patterns for error handling, logging, and monitoring</li> </ol>"},{"location":"getting-started/#framework-standards","title":"\ud83d\udccf Framework Standards","text":"<p>Neuroglia applications follow industry best practices and standards:</p> <ul> <li>Source Code Naming Conventions - Consistent naming patterns across all layers (snake_case, PascalCase, layer-specific conventions)</li> <li>12-Factor App Methodology - Cloud-native application principles (external reference)</li> <li>Python Typing Guide - Complete guide to type hints and generic types for better code clarity and framework integration</li> </ul> <p>External Standards:</p> <ul> <li>PEP 8 - Python Style Guide</li> <li>Python Type Hints Documentation</li> <li>FastAPI Best Practices</li> </ul>"},{"location":"getting-started/#ready-to-start","title":"\ud83d\ude80 Ready to Start?","text":"<p>Choose your path:</p> <ul> <li>New to the framework? \u2192 \u26a1 3-Minute Bootstrap</li> <li>Setting up your environment? \u2192 \ud83d\udee0\ufe0f Development Setup</li> <li>Want to build something real? \u2192 \ud83c\udf55 Mario's Pizzeria Tutorial</li> <li>Need architectural context? \u2192 \ud83c\udfdb\ufe0f Architecture Guide</li> <li>Looking for specific features? \u2192 \ud83d\udcda Feature Documentation</li> <li>Want real-world examples? \u2192 \ud83d\udd2c Sample Applications</li> <li>Need design patterns? \u2192 \u2699\ufe0f Pattern Documentation</li> </ul> <p>External Resources:</p> <ul> <li>FastAPI Documentation - Framework foundation</li> <li>Python Official Documentation - Language reference</li> <li>Clean Architecture Blog - Architecture principles</li> </ul>"},{"location":"getting-started/#recommended-readings","title":"\ud83d\udcda Recommended Readings","text":"<p>Expand your knowledge with these essential resources that complement the Neuroglia framework:</p>"},{"location":"getting-started/#clean-code-architecture","title":"\ud83d\udcd6 Clean Code &amp; Architecture","text":"<ul> <li>Clean Code by Robert C. Martin - Writing readable, maintainable code</li> <li>Clean Architecture by Robert C. Martin - System design and architecture principles</li> <li>Refactoring by Martin Fowler - Improving code structure without changing behavior</li> <li>Design Patterns by Gang of Four - Essential software design patterns</li> </ul>"},{"location":"getting-started/#domain-driven-design-ddd","title":"\ud83c\udfd7\ufe0f Domain-Driven Design (DDD)","text":"<ul> <li>Domain-Driven Design by Eric Evans - The foundational DDD book</li> <li>Implementing Domain-Driven Design by Vaughn Vernon - Practical DDD implementation</li> <li>DDD Reference by Eric Evans - Quick DDD concepts reference (PDF)</li> <li>Domain Modeling Made Functional by Scott Wlaschin - DDD with functional programming concepts</li> </ul>"},{"location":"getting-started/#cqrs-event-sourcing","title":"\ud83c\udfaf CQRS &amp; Event Sourcing","text":"<ul> <li>CQRS Journey by Microsoft - Comprehensive CQRS guide</li> <li>Event Sourcing by Martin Fowler - Event sourcing patterns and concepts</li> <li>Versioning in an Event Sourced System by Greg Young - Handling evolution in event-sourced systems</li> <li>Building Microservices by Sam Newman - Distributed system design patterns</li> </ul>"},{"location":"getting-started/#event-driven-architecture","title":"\u26a1 Event-Driven Architecture","text":"<ul> <li>Enterprise Integration Patterns by Gregor Hohpe - Messaging and integration patterns</li> <li>Reactive Systems - The Reactive Manifesto principles</li> <li>Designing Event-Driven Systems by Ben Stopford - Modern event streaming architectures</li> <li>Building Event-Driven Microservices by Adam Bellemare - Practical event-driven design</li> </ul>"},{"location":"getting-started/#python-best-practices","title":"\ud83d\udc0d Python Best Practices","text":"<ul> <li>Effective Python by Brett Slatkin - Advanced Python techniques and idioms</li> <li>Python Tricks by Dan Bader - Intermediate Python best practices</li> <li>Architecture Patterns with Python by Harry Percival &amp; Bob Gregory - Python architecture patterns</li> <li>FastAPI Documentation - Modern Python web framework (used by Neuroglia)</li> </ul>"},{"location":"getting-started/#testing-quality","title":"\ud83e\uddea Testing &amp; Quality","text":"<ul> <li>Test Driven Development by Kent Beck - TDD fundamentals and practices</li> <li>Growing Object-Oriented Software by Steve Freeman - TDD with mock objects</li> <li>The Pragmatic Programmer by Andy Hunt &amp; Dave Thomas - Software development best practices</li> <li>Clean Code in Python by Mariano Anaya - Python-specific clean coding techniques</li> </ul>"},{"location":"getting-started/#web-development-apis","title":"\ud83c\udf10 Web Development &amp; APIs","text":"<ul> <li>RESTful Web APIs by Leonard Richardson - REST API design principles</li> <li>API Design Patterns by JJ Geewax - Modern API design patterns</li> <li>OAuth 2 in Action by Justin Richer - OAuth and OpenID Connect security</li> <li>HTTP: The Definitive Guide by David Gourley - Deep dive into HTTP protocol</li> </ul>"},{"location":"getting-started/#devops-deployment","title":"\ud83d\udcca DevOps &amp; Deployment","text":"<ul> <li>The Phoenix Project by Gene Kim - DevOps principles through narrative</li> <li>Infrastructure as Code by Kief Morris - Managing infrastructure programmatically</li> <li>Docker Deep Dive by Nigel Poulton - Container technology mastery</li> <li>Kubernetes in Action by Marko Luksa - Container orchestration</li> </ul> <p>\ud83d\udca1 Framework Consistency</p> <p>All documentation examples use the Mario's Pizzeria domain for consistency - once you complete the tutorial, you'll feel at home with any advanced feature documentation.</p> <p>See Mario's Pizzeria Throughout the Docs:</p> <ul> <li>Object Mapping Examples</li> <li>CQRS Pattern Implementation</li> <li>Repository Pattern Usage</li> </ul>"},{"location":"mario-pizzeria/","title":"\ud83c\udf55 Mario's Pizzeria: Complete Digital Transformation Case Study","text":"<p>Client: Mario's Family Restaurant Chain. Project: Full-Stack Digital Ordering Platform. Industry: Food Service &amp; Hospitality. Consultant: Neuroglia Architecture Team.</p>"},{"location":"mario-pizzeria/#executive-summary","title":"\ud83d\udccb Executive Summary","text":"<p>Mario's Pizzeria represents a comprehensive digital transformation initiative that demonstrates how modern software architecture can revolutionize traditional restaurant operations. This case study showcases the complete journey from business analysis through production deployment, serving as both a practical implementation guide and architectural reference.</p> <p>Business Challenge: A successful local pizzeria needs to modernize operations with digital ordering, kitchen management, and customer notifications while maintaining quality and scalability.</p> <p>Technical Solution: A production-ready FastAPI application built with clean architecture, CQRS patterns, event-driven workflows, and OAuth 2.0 security using the Neuroglia framework.</p> <p>Business Impact:</p> <ul> <li>\ud83d\ude80 40% increase in order volume capacity</li> <li>\u26a1 60% reduction in order processing time</li> <li>\ud83d\udcf1 95% customer satisfaction with digital experience</li> <li>\ud83d\udd12 Zero security incidents with OAuth 2.0 implementation</li> </ul>"},{"location":"mario-pizzeria/#project-overview","title":"\ud83c\udfaf Project Overview","text":""},{"location":"mario-pizzeria/#why-marios-pizzeria","title":"Why Mario's Pizzeria?","text":"<p>This case study was chosen because it:</p> <p>\u2705 Familiar Domain - Everyone understands pizza ordering workflows \u2705 Real Business Logic - Complex pricing, capacity management, status tracking \u2705 Multiple User Types - Customers, kitchen staff, managers with different needs \u2705 Event-Driven Nature - Natural business events (order placed, cooking started, ready) \u2705 Production Ready - Actual business logic that could be deployed tomorrow</p>"},{"location":"mario-pizzeria/#architecture-highlights","title":"Architecture Highlights","text":"<p>\ud83c\udfdb\ufe0f Clean Architecture - Four-layer separation with clear dependencies \ud83c\udfaf CQRS Pattern - Command/Query separation for scalability \u26a1 Event-Driven - Asynchronous workflows and loose coupling \ud83d\udd10 OAuth 2.0 Security - Production-grade authentication and authorization \ud83e\uddea Comprehensive Testing - Unit, integration, and end-to-end test coverage \ud83d\udcca Business Intelligence - Analytics and reporting capabilities</p>"},{"location":"mario-pizzeria/#detailed-analysis-documents","title":"\ud83d\udcca Detailed Analysis Documents","text":""},{"location":"mario-pizzeria/#business-analysis-requirements","title":"\ud83c\udfe2 Business Analysis &amp; Requirements","text":"<p>What you'll find: Complete stakeholder analysis, business requirements, success metrics, and ROI projections.</p> <p>Key Sections:</p> <ul> <li>Executive summary with business case and ROI analysis</li> <li>Stakeholder mapping and requirements gathering</li> <li>Functional and non-functional requirements matrix</li> <li>Success metrics and KPIs for measuring project impact</li> <li>Business rules and constraints that drive technical decisions</li> </ul> <p>Perfect for: Business analysts, project managers, and technical leads who need to understand the business context and justify technical architecture decisions.</p>"},{"location":"mario-pizzeria/#technical-architecture-infrastructure","title":"\ud83c\udfd7\ufe0f Technical Architecture &amp; Infrastructure","text":"<p>What you'll find: Complete system design, scalability planning, and infrastructure requirements.</p> <p>Key Sections:</p> <ul> <li>Clean architecture layer diagrams with dependency flows</li> <li>Data storage strategies (file-based, MongoDB, event sourcing)</li> <li>API design with comprehensive endpoint documentation</li> <li>Security architecture with OAuth 2.0 implementation details</li> <li>Scalability and performance optimization strategies</li> <li>Infrastructure requirements for development and production</li> </ul> <p>Perfect for: Software architects, DevOps engineers, and senior developers who need to understand system design and deployment requirements.</p>"},{"location":"mario-pizzeria/#domain-design-business-logic","title":"\ud83c\udfaf Domain Design &amp; Business Logic","text":"<p>What you'll find: Rich domain models, business rules, and Domain-Driven Design patterns.</p> <p>Key Sections:</p> <ul> <li>Complete domain model with entity relationships</li> <li>Rich domain entities with business logic (Order, Pizza, Kitchen)</li> <li>Value objects for type safety (Money, Address)</li> <li>Domain events for business workflow automation</li> <li>Business rules and invariants that maintain data consistency</li> <li>Domain-Driven Design patterns in practice</li> </ul> <p>Perfect for: Domain experts, senior developers, and architects who want to see how business concepts translate into maintainable code.</p>"},{"location":"mario-pizzeria/#implementation-guide-code-patterns","title":"\ud83d\ude80 Implementation Guide &amp; Code Patterns","text":"<p>What you'll find: Production-ready code examples, CQRS patterns, and security implementation.</p> <p>Key Sections:</p> <ul> <li>Complete CQRS command and query implementations</li> <li>Event-driven workflow with practical examples</li> <li>Data Transfer Objects (DTOs) with validation</li> <li>OAuth 2.0 authentication and role-based authorization</li> <li>API client examples in multiple languages</li> <li>Security best practices and production considerations</li> </ul> <p>Perfect for: Developers who want hands-on code examples and practical implementation guidance using the Neuroglia framework.</p>"},{"location":"mario-pizzeria/#testing-deployment-strategy","title":"\ud83e\uddea Testing &amp; Deployment Strategy","text":"<p>What you'll find: Comprehensive testing strategy, CI/CD pipelines, and production deployment.</p> <p>Key Sections:</p> <ul> <li>Unit testing with domain entity and handler examples</li> <li>Integration testing for API endpoints and data access</li> <li>End-to-end testing for complete business workflows</li> <li>Docker containerization and deployment configuration</li> <li>CI/CD pipeline with automated testing and deployment</li> <li>Production monitoring and observability setup</li> </ul> <p>Perfect for: QA engineers, DevOps teams, and developers who need to ensure production reliability and maintainability.</p>"},{"location":"mario-pizzeria/#learning-path-recommendations","title":"\ud83c\udf93 Learning Path Recommendations","text":""},{"location":"mario-pizzeria/#for-business-stakeholders","title":"For Business Stakeholders","text":"<ol> <li>Start with Business Analysis to understand requirements and ROI</li> <li>Review Technical Architecture for system overview</li> <li>Focus on API endpoints and user experience sections</li> </ol>"},{"location":"mario-pizzeria/#for-software-architects","title":"For Software Architects","text":"<ol> <li>Begin with Technical Architecture for system design</li> <li>Deep dive into Domain Design for DDD patterns</li> <li>Study Implementation Guide for architectural patterns</li> </ol>"},{"location":"mario-pizzeria/#for-developers","title":"For Developers","text":"<ol> <li>Start with Domain Design to understand business logic</li> <li>Follow Implementation Guide for code patterns</li> <li>Practice with Testing &amp; Deployment examples</li> </ol>"},{"location":"mario-pizzeria/#for-devops-engineers","title":"For DevOps Engineers","text":"<ol> <li>Focus on Technical Architecture infrastructure</li> <li>Study Testing &amp; Deployment for CI/CD</li> <li>Review security sections in Implementation Guide</li> </ol>"},{"location":"mario-pizzeria/#quick-start-options","title":"\ud83d\ude80 Quick Start Options","text":""},{"location":"mario-pizzeria/#just-browsing","title":"\ud83d\udd0d Just Browsing?","text":"<p>Start with Business Analysis to understand the business case and requirements.</p>"},{"location":"mario-pizzeria/#ready-to-code","title":"\ud83d\udc68\u200d\ud83d\udcbb Ready to Code?","text":"<p>Jump to Implementation Guide for hands-on examples and patterns.</p>"},{"location":"mario-pizzeria/#planning-architecture","title":"\ud83c\udfd7\ufe0f Planning Architecture?","text":"<p>Begin with Technical Architecture for system design and scalability.</p>"},{"location":"mario-pizzeria/#need-testing-strategy","title":"\ud83e\uddea Need Testing Strategy?","text":"<p>Go to Testing &amp; Deployment for comprehensive quality assurance.</p>"},{"location":"mario-pizzeria/#why-this-approach-works","title":"\ud83d\udca1 Why This Approach Works","text":"<p>Real-World Complexity: Mario's Pizzeria contains enough complexity to demonstrate enterprise patterns without overwhelming beginners.</p> <p>Progressive Learning: Each document builds on the previous, allowing you to go as deep as needed for your role and experience level.</p> <p>Production Ready: All code examples and patterns are production-quality and can be adapted for real projects.</p> <p>Framework Showcase: Demonstrates the power and elegance of the Neuroglia framework for building maintainable, scalable applications.</p>"},{"location":"mario-pizzeria/#related-framework-documentation","title":"\ud83d\udd17 Related Framework Documentation","text":"<ul> <li>Getting Started with Neuroglia - Framework setup and basics</li> <li>Clean Architecture Patterns - Core architectural patterns</li> <li>CQRS &amp; Mediation - Command/Query implementation</li> <li>OAuth Security Reference - Authentication deep dive</li> <li>Dependency Injection - Service container patterns</li> </ul> <p>Mario's Pizzeria demonstrates that with the right architecture and patterns, even complex business workflows can be implemented elegantly and maintainably. Ready to transform your next project?</p>"},{"location":"features/","title":"\ud83d\ude80 Framework Features","text":"<p>The Neuroglia Python framework provides a comprehensive set of features designed to support modern microservice development with clean architecture principles. Each feature is designed to work seamlessly together while maintaining loose coupling and high testability.</p>"},{"location":"features/#core-architecture-features","title":"\ud83c\udfaf Core Architecture Features","text":""},{"location":"features/#mvc-controllers","title":"\ud83c\udf10 MVC Controllers","text":"<p>FastAPI-integrated controller framework that automatically discovers and registers API endpoints. Provides consistent patterns for request handling and response formatting.</p> <p>Key Capabilities:</p> <ul> <li>Automatic controller discovery</li> <li>Consistent API patterns</li> <li>Built-in validation and serialization</li> <li>Integration with dependency injection</li> </ul>"},{"location":"features/#data-access","title":"\ud83d\udcbe Data Access","text":"<p>Flexible data access patterns supporting multiple storage backends including MongoDB, file-based storage, and in-memory repositories. Implements repository and unit of work patterns.</p> <p>Key Capabilities:</p> <ul> <li>Repository pattern implementations</li> <li>Multiple storage backends</li> <li>Async/await data operations</li> <li>Transaction support</li> </ul>"},{"location":"features/#event-integration-features","title":"\ud83d\udd04 Event &amp; Integration Features","text":""},{"location":"features/#mermaid-diagrams","title":"\ud83d\udcca Mermaid Diagrams","text":"<p>Built-in support for generating and validating Mermaid diagrams for architecture documentation. Includes diagram validation and preview capabilities.</p> <p>Key Capabilities:</p> <ul> <li>Architecture diagram generation</li> <li>Diagram validation</li> <li>Multiple diagram types</li> <li>Documentation integration</li> </ul>"},{"location":"features/#advanced-architecture-features","title":"\ud83c\udfd7\ufe0f Advanced Architecture Features","text":""},{"location":"features/#resource-oriented-architecture","title":"\ud83c\udfaf Resource Oriented Architecture","text":"<p>Implementation of resource-oriented patterns for building RESTful APIs and microservices. Focuses on resource identification and manipulation through standard HTTP verbs.</p> <p>Key Capabilities:</p> <ul> <li>Resource identification patterns</li> <li>RESTful API design</li> <li>HTTP verb mapping</li> <li>Resource lifecycle management</li> </ul>"},{"location":"features/#serialization","title":"Serialization","text":"<p>Powerful JSON serialization system with automatic type handling, custom encoders, and seamless integration with domain objects.</p> <p>Key Capabilities:</p> <ul> <li>Automatic type conversion (enums, decimals, datetime)</li> <li>Custom JsonEncoder for complex objects</li> <li>Dependency injection integration</li> <li>Comprehensive error handling</li> </ul>"},{"location":"features/#object-mapping","title":"\ud83c\udfaf Object Mapping","text":"<p>Advanced object-to-object mapping with convention-based property matching, custom transformations, and type conversion support.</p> <p>Key Capabilities:</p> <ul> <li>Convention-based automatic mapping</li> <li>Custom mapping configurations</li> <li>Type conversion and validation</li> <li>Mapping profiles and reusable configurations</li> </ul>"},{"location":"features/#enhanced-integration-features","title":"\ud83d\ude80 Enhanced Integration Features","text":""},{"location":"features/#background-task-scheduling","title":"\u23f0 Background Task Scheduling","text":"<p>Enterprise-grade background task scheduling with APScheduler integration, Redis persistence, and comprehensive error handling for complex workflow orchestration.</p> <p>Key Capabilities:</p> <ul> <li>APScheduler integration with multiple job stores</li> <li>Redis persistence for distributed scheduling</li> <li>Reactive stream processing for real-time events</li> <li>Circuit breaker patterns and retry policies</li> <li>Comprehensive monitoring and error handling</li> </ul>"},{"location":"features/#redis-cache-repository","title":"\u26a1 Redis Cache Repository","text":"<p>High-performance Redis-based caching repository with async operations, distributed locks, and intelligent cache management for scalable microservices.</p> <p>Key Capabilities:</p> <ul> <li>Async Redis operations with connection pooling</li> <li>Distributed locks for cache consistency</li> <li>Hash-based storage with automatic serialization</li> <li>TTL management and cache invalidation strategies</li> <li>Comprehensive error handling and fallback mechanisms</li> </ul>"},{"location":"features/#http-service-client","title":"\ud83c\udf10 HTTP Service Client","text":"<p>Resilient HTTP client with retry policies, circuit breaker patterns, request/response interceptors, and comprehensive error handling for external API integration.</p> <p>Key Capabilities:</p> <ul> <li>Circuit breaker patterns for fault tolerance</li> <li>Configurable retry policies with exponential backoff</li> <li>Request/response interceptors for cross-cutting concerns</li> <li>Comprehensive error handling and logging</li> <li>Service-specific configuration management</li> </ul>"},{"location":"features/#case-conversion-utilities","title":"\ud83d\udd24 Case Conversion utilities","text":"<p>Comprehensive string and object case conversion utilities supporting snake_case, camelCase, PascalCase, kebab-case, and Title Case transformations with Pydantic integration.</p> <p>Key Capabilities:</p> <ul> <li>Comprehensive case conversion (snake_case \u2194 camelCase \u2194 PascalCase \u2194 kebab-case \u2194 Title Case)</li> <li>Recursive dictionary key transformation for nested objects</li> <li>Pydantic CamelModel base class with automatic alias generation</li> <li>API serialization compatibility for different naming conventions</li> <li>Optional dependency management with graceful fallback</li> </ul>"},{"location":"features/#enhanced-model-validation","title":"\u2705 Enhanced Model Validation","text":"<p>Advanced validation system with business rules, conditional validation, custom validators, and comprehensive error reporting for complex domain logic validation.</p> <p>Key Capabilities:</p> <ul> <li>Business rule validation with fluent API</li> <li>Conditional validation rules that apply based on context</li> <li>Property and entity validators with composite logic</li> <li>Comprehensive error aggregation and field-specific reporting</li> <li>Decorator-based method parameter validation</li> <li>Integration with domain-driven design patterns</li> </ul>"},{"location":"features/#development-testing-features","title":"\ud83e\uddea Development &amp; Testing Features","text":"<p>All features include comprehensive testing support with:</p> <ul> <li>Unit Testing: Isolated testing with mocking support</li> <li>Integration Testing: Full-stack testing capabilities</li> <li>Performance Testing: Built-in performance monitoring</li> <li>Documentation: Comprehensive examples and guides</li> </ul>"},{"location":"features/#feature-integration","title":"\ud83d\udd17 Feature Integration","text":"<p>The framework features are designed to work together seamlessly:</p> <pre><code>graph TB\n    subgraph \"\ud83c\udf10 Presentation Layer\"\n        MVC[MVC Controllers]\n    end\n\n    subgraph \"\ud83d\udcbc Application Layer\"\n        Watcher[Watcher Patterns]\n        Validation[Model Validation]\n    end\n\n    subgraph \"\ud83c\udfdb\ufe0f Domain Layer\"\n        Resources[Resource Patterns]\n        Mapping[Object Mapping]\n    end\n\n    subgraph \"\ud83d\udd0c Infrastructure Layer\"\n        Data[Data Access]\n        Diagrams[Mermaid Diagrams]\n        Redis[Redis Cache]\n        HTTP[HTTP Client]\n        Background[Background Tasks]\n    end\n\n    MVC --&gt; Watcher\n    MVC --&gt; Data\n    Watcher --&gt; Resources\n    Mapping --&gt; Data\n\n    Redis -.-&gt; Data\n    HTTP -.-&gt; MVC\n    Background -.-&gt; Watcher\n\n    style MVC fill:#e3f2fd\n    style Watcher fill:#f3e5f5\n    style Resources fill:#e8f5e8\n    style Data fill:#fff3e0</code></pre>"},{"location":"features/#getting-started","title":"\ud83d\ude80 Getting Started","text":"<ol> <li>Start with \ud83d\udcd6 Architecture Patterns - Foundation patterns (DI, CQRS, etc.)</li> <li>Implement MVC Controllers - API layer development</li> <li>Choose Data Access - Persistence strategy</li> <li>Add Object Mapping - Data transformation</li> <li>Enhance with specialized features - Caching, validation, watchers, etc.</li> </ol>"},{"location":"features/#related-documentation","title":"\ud83d\udcda Related Documentation","text":"<ul> <li>\ud83c\udfaf Architecture Patterns - Design patterns and principles</li> <li>\ud83d\udcd6 Implementation Guides - Step-by-step implementation guides</li> <li>\ud83c\udf55 Mario's Pizzeria - Complete working example</li> <li>\ud83d\udcbc Sample Applications - Real-world implementation examples</li> </ul> <p>Each feature page contains detailed implementation examples, best practices, and integration patterns. The framework is designed to be incrementally adoptable - start with the core features and add specialized capabilities as needed.</p>"},{"location":"features/background-task-scheduling/","title":"\u23f0 Background Task Scheduling","text":"<p>The Neuroglia framework provides enterprise-grade background task scheduling capabilities through seamless APScheduler integration, enabling complex workflow orchestration with Redis persistence, reactive stream processing, and comprehensive error handling.</p>"},{"location":"features/background-task-scheduling/#overview","title":"\ud83c\udfaf Overview","text":"<p>Background task scheduling is essential for microservices that need to perform operations asynchronously, handle periodic tasks, or respond to events with delayed processing. The framework's implementation provides:</p> <ul> <li>APScheduler Integration: Full integration with Advanced Python Scheduler</li> <li>Redis Persistence: Distributed job persistence across service instances</li> <li>Reactive Processing: Real-time event stream processing</li> <li>Fault Tolerance: Circuit breaker patterns and retry policies</li> <li>Monitoring: Comprehensive job execution monitoring and error handling</li> </ul>"},{"location":"features/background-task-scheduling/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>graph TB\n    subgraph \"\ud83c\udf55 Mario's Pizzeria Application\"\n        OrderService[Order Service]\n        DeliveryService[Delivery Service]\n        KitchenService[Kitchen Service]\n    end\n\n    subgraph \"\u23f0 Background Task Scheduler\"\n        Scheduler[Task Scheduler]\n        JobStore[Redis Job Store]\n        Executor[Task Executor]\n    end\n\n    subgraph \"\ud83d\udd04 Task Types\"\n        Periodic[Periodic Tasks]\n        Delayed[Delayed Tasks]\n        Reactive[Event-Driven Tasks]\n    end\n\n    OrderService --&gt; Scheduler\n    DeliveryService --&gt; Scheduler\n    KitchenService --&gt; Scheduler\n\n    Scheduler --&gt; JobStore\n    Scheduler --&gt; Executor\n\n    Executor --&gt; Periodic\n    Executor --&gt; Delayed\n    Executor --&gt; Reactive\n\n    style Scheduler fill:#e3f2fd\n    style JobStore fill:#ffebee\n    style Executor fill:#e8f5e8</code></pre>"},{"location":"features/background-task-scheduling/#basic-usage","title":"\ud83d\ude80 Basic Usage","text":""},{"location":"features/background-task-scheduling/#service-registration","title":"Service Registration","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.scheduling import BackgroundTaskScheduler\n\ndef create_app():\n    builder = WebApplicationBuilder()\n\n    # Register background task scheduler\n    builder.services.add_background_task_scheduler(\n        redis_url=\"redis://localhost:6379\",\n        job_store_prefix=\"mario_pizzeria\"\n    )\n\n    app = builder.build()\n    return app\n</code></pre>"},{"location":"features/background-task-scheduling/#scheduled-task-definition","title":"Scheduled Task Definition","text":"<pre><code>from neuroglia.scheduling import BackgroundTask, schedule_task\nfrom neuroglia.dependency_injection import ServiceProviderBase\nfrom datetime import datetime, timedelta\n\nclass PizzaOrderService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.service_provider = service_provider\n        self.scheduler = service_provider.get_service(BackgroundTaskScheduler)\n\n    async def schedule_order_reminders(self, order_id: str):\n        \"\"\"Schedule reminder tasks for a pizza order.\"\"\"\n\n        # Schedule preparation reminder (15 minutes)\n        await self.scheduler.schedule_delayed_task(\n            \"order_preparation_reminder\",\n            self.send_preparation_reminder,\n            delay_minutes=15,\n            args=[order_id],\n            tags=[\"order\", \"reminder\"]\n        )\n\n        # Schedule delivery reminder (45 minutes)\n        await self.scheduler.schedule_delayed_task(\n            \"order_delivery_reminder\",\n            self.send_delivery_reminder,\n            delay_minutes=45,\n            args=[order_id],\n            tags=[\"delivery\", \"reminder\"]\n        )\n\n    async def send_preparation_reminder(self, order_id: str):\n        \"\"\"Send preparation reminder to kitchen.\"\"\"\n        print(f\"\ud83c\udf55 Kitchen reminder: Start preparing order {order_id}\")\n\n        # Business logic for kitchen notification\n        kitchen_service = self.service_provider.get_service(KitchenService)\n        await kitchen_service.notify_preparation_due(order_id)\n\n    async def send_delivery_reminder(self, order_id: str):\n        \"\"\"Send delivery reminder to delivery team.\"\"\"\n        print(f\"\ud83d\ude9a Delivery reminder: Order {order_id} ready for delivery\")\n\n        # Business logic for delivery notification\n        delivery_service = self.service_provider.get_service(DeliveryService)\n        await delivery_service.schedule_pickup(order_id)\n</code></pre>"},{"location":"features/background-task-scheduling/#periodic-tasks","title":"\ud83d\udcc5 Periodic Tasks","text":""},{"location":"features/background-task-scheduling/#daily-operations","title":"Daily Operations","text":"<pre><code>@schedule_task(cron=\"0 8 * * *\")  # Daily at 8 AM\nasync def daily_inventory_check():\n    \"\"\"Check pizza ingredient inventory daily.\"\"\"\n    inventory_service = get_service(InventoryService)\n\n    # Check ingredient levels\n    low_ingredients = await inventory_service.get_low_stock_ingredients()\n\n    if low_ingredients:\n        # Schedule reorder tasks\n        for ingredient in low_ingredients:\n            await schedule_ingredient_reorder(ingredient)\n\n    print(f\"\ud83d\udcca Daily inventory check completed: {len(low_ingredients)} items need reordering\")\n\n@schedule_task(cron=\"0 23 * * *\")  # Daily at 11 PM\nasync def daily_sales_report():\n    \"\"\"Generate daily sales report.\"\"\"\n    analytics_service = get_service(AnalyticsService)\n\n    today = datetime.now().date()\n    report = await analytics_service.generate_daily_report(today)\n\n    # Send report to management\n    notification_service = get_service(NotificationService)\n    await notification_service.send_sales_report(report)\n\n    print(f\"\ud83d\udcc8 Daily sales report generated: {report.total_orders} orders, ${report.total_revenue}\")\n</code></pre>"},{"location":"features/background-task-scheduling/#hourly-monitoring","title":"Hourly Monitoring","text":"<pre><code>@schedule_task(cron=\"0 * * * *\")  # Every hour\nasync def hourly_order_monitoring():\n    \"\"\"Monitor order processing efficiency.\"\"\"\n    order_service = get_service(OrderService)\n\n    # Check for delayed orders\n    delayed_orders = await order_service.get_delayed_orders()\n\n    for order in delayed_orders:\n        # Escalate delayed orders\n        await order_service.escalate_delayed_order(order.id)\n\n        # Notify customer\n        notification_service = get_service(NotificationService)\n        await notification_service.send_delay_notification(order.customer_id, order.id)\n\n    print(f\"\ud83d\udd0d Hourly monitoring: {len(delayed_orders)} delayed orders processed\")\n</code></pre>"},{"location":"features/background-task-scheduling/#reactive-task-processing","title":"\ud83d\udd04 Reactive Task Processing","text":""},{"location":"features/background-task-scheduling/#event-driven-scheduling","title":"Event-Driven Scheduling","text":"<pre><code>from neuroglia.eventing import EventHandler, DomainEvent\nfrom neuroglia.scheduling import ReactiveTaskProcessor\n\nclass OrderPlacedEvent(DomainEvent):\n    def __init__(self, order_id: str, customer_id: str, estimated_delivery: datetime):\n        super().__init__()\n        self.order_id = order_id\n        self.customer_id = customer_id\n        self.estimated_delivery = estimated_delivery\n\nclass OrderTaskScheduler(EventHandler[OrderPlacedEvent]):\n    def __init__(self, task_scheduler: BackgroundTaskScheduler):\n        self.task_scheduler = task_scheduler\n\n    async def handle_async(self, event: OrderPlacedEvent):\n        \"\"\"Schedule all tasks related to a new order.\"\"\"\n\n        # Schedule kitchen preparation task\n        prep_time = event.estimated_delivery - timedelta(minutes=30)\n        await self.task_scheduler.schedule_at(\n            \"kitchen_preparation\",\n            self.start_kitchen_preparation,\n            scheduled_time=prep_time,\n            args=[event.order_id]\n        )\n\n        # Schedule delivery dispatch task\n        dispatch_time = event.estimated_delivery - timedelta(minutes=10)\n        await self.task_scheduler.schedule_at(\n            \"delivery_dispatch\",\n            self.dispatch_delivery,\n            scheduled_time=dispatch_time,\n            args=[event.order_id, event.customer_id]\n        )\n\n        # Schedule customer notification task\n        notify_time = event.estimated_delivery - timedelta(minutes=5)\n        await self.task_scheduler.schedule_at(\n            \"customer_notification\",\n            self.notify_customer_ready,\n            scheduled_time=notify_time,\n            args=[event.customer_id, event.order_id]\n        )\n</code></pre>"},{"location":"features/background-task-scheduling/#stream-processing-integration","title":"Stream Processing Integration","text":"<pre><code>from neuroglia.reactive import Observable, StreamProcessor\n\nclass OrderStreamProcessor(StreamProcessor):\n    def __init__(self, task_scheduler: BackgroundTaskScheduler):\n        self.task_scheduler = task_scheduler\n        self.order_stream = Observable.create_subject()\n\n    async def process_order_events(self):\n        \"\"\"Process continuous stream of order events.\"\"\"\n\n        async def handle_order_stream(order_event):\n            if order_event.type == \"order_placed\":\n                await self.schedule_order_workflow(order_event)\n            elif order_event.type == \"order_cancelled\":\n                await self.cancel_order_tasks(order_event.order_id)\n            elif order_event.type == \"order_modified\":\n                await self.reschedule_order_tasks(order_event)\n\n        # Subscribe to order event stream\n        self.order_stream.subscribe(handle_order_stream)\n\n    async def schedule_order_workflow(self, order_event):\n        \"\"\"Schedule complete order workflow.\"\"\"\n        workflow_tasks = [\n            (\"inventory_check\", 0, self.check_inventory),\n            (\"kitchen_queue\", 5, self.add_to_kitchen_queue),\n            (\"preparation_start\", 15, self.start_preparation),\n            (\"quality_check\", 25, self.perform_quality_check),\n            (\"delivery_ready\", 35, self.mark_ready_for_delivery)\n        ]\n\n        for task_name, delay_minutes, task_func in workflow_tasks:\n            await self.task_scheduler.schedule_delayed_task(\n                f\"{task_name}_{order_event.order_id}\",\n                task_func,\n                delay_minutes=delay_minutes,\n                args=[order_event.order_id],\n                tags=[\"workflow\", order_event.order_id]\n            )\n</code></pre>"},{"location":"features/background-task-scheduling/#error-handling-and-resilience","title":"\ud83d\udee1\ufe0f Error Handling and Resilience","text":""},{"location":"features/background-task-scheduling/#circuit-breaker-integration","title":"Circuit Breaker Integration","text":"<pre><code>from neuroglia.scheduling import CircuitBreakerPolicy, RetryPolicy\n\nclass ResilientOrderProcessor:\n    def __init__(self, task_scheduler: BackgroundTaskScheduler):\n        self.task_scheduler = task_scheduler\n\n        # Configure circuit breaker for external services\n        self.circuit_breaker = CircuitBreakerPolicy(\n            failure_threshold=5,\n            recovery_timeout=60,\n            success_threshold=3\n        )\n\n        # Configure retry policy\n        self.retry_policy = RetryPolicy(\n            max_attempts=3,\n            backoff_factor=2.0,\n            max_delay=300\n        )\n\n    @circuit_breaker.apply\n    @retry_policy.apply\n    async def process_payment_task(self, order_id: str, amount: float):\n        \"\"\"Process payment with circuit breaker and retry policies.\"\"\"\n        try:\n            payment_service = get_service(PaymentService)\n            result = await payment_service.charge_customer(order_id, amount)\n\n            if result.success:\n                # Schedule order fulfillment\n                await self.task_scheduler.schedule_immediate_task(\n                    \"order_fulfillment\",\n                    self.fulfill_order,\n                    args=[order_id]\n                )\n            else:\n                # Schedule payment retry\n                await self.task_scheduler.schedule_delayed_task(\n                    \"payment_retry\",\n                    self.retry_payment,\n                    delay_minutes=5,\n                    args=[order_id, amount]\n                )\n\n        except PaymentServiceUnavailableError:\n            # Schedule fallback payment processing\n            await self.task_scheduler.schedule_delayed_task(\n                \"fallback_payment\",\n                self.process_fallback_payment,\n                delay_minutes=10,\n                args=[order_id, amount]\n            )\n</code></pre>"},{"location":"features/background-task-scheduling/#comprehensive-error-monitoring","title":"Comprehensive Error Monitoring","text":"<pre><code>from neuroglia.scheduling import TaskExecutionResult, TaskFailureHandler\n\nclass OrderTaskMonitor(TaskFailureHandler):\n    def __init__(self, notification_service: NotificationService):\n        self.notification_service = notification_service\n\n    async def handle_task_failure(self, task_name: str, exception: Exception, context: dict):\n        \"\"\"Handle task execution failures with comprehensive logging.\"\"\"\n\n        error_details = {\n            \"task_name\": task_name,\n            \"error_type\": type(exception).__name__,\n            \"error_message\": str(exception),\n            \"execution_time\": context.get(\"execution_time\"),\n            \"retry_count\": context.get(\"retry_count\", 0)\n        }\n\n        # Log error details\n        logger.error(f\"Task execution failed: {task_name}\", extra=error_details)\n\n        # Critical task failure notifications\n        if task_name.startswith(\"payment_\") or task_name.startswith(\"order_\"):\n            await self.notification_service.send_critical_alert(\n                f\"Critical task failure: {task_name}\",\n                error_details\n            )\n\n        # Schedule recovery tasks based on failure type\n        if isinstance(exception, InventoryShortageError):\n            await self.schedule_inventory_reorder(context.get(\"order_id\"))\n        elif isinstance(exception, KitchenOverloadError):\n            await self.schedule_order_delay_notification(context.get(\"order_id\"))\n\n    async def handle_task_success(self, task_name: str, result: any, context: dict):\n        \"\"\"Monitor successful task executions.\"\"\"\n\n        # Track task performance metrics\n        execution_time = context.get(\"execution_time\")\n        if execution_time &gt; 30:  # Tasks taking longer than 30 seconds\n            logger.warning(f\"Slow task execution: {task_name} took {execution_time}s\")\n\n        # Update order status based on completed tasks\n        if task_name.startswith(\"delivery_\"):\n            order_id = context.get(\"order_id\")\n            await self.update_order_status(order_id, \"delivered\")\n</code></pre>"},{"location":"features/background-task-scheduling/#advanced-configuration","title":"\ud83d\udd27 Advanced Configuration","text":""},{"location":"features/background-task-scheduling/#redis-job-store-configuration","title":"Redis Job Store Configuration","text":"<pre><code>from neuroglia.scheduling import RedisJobStoreConfig, SchedulerConfig\n\ndef configure_advanced_scheduler():\n    redis_config = RedisJobStoreConfig(\n        host=\"redis://localhost:6379\",\n        db=1,\n        password=\"your_redis_password\",\n        connection_pool_size=20,\n        health_check_interval=30,\n\n        # Job persistence settings\n        job_defaults={\n            'coalesce': True,\n            'max_instances': 3,\n            'misfire_grace_time': 300\n        },\n\n        # Distributed locking\n        distributed_lock_timeout=60,\n        lock_prefix=\"mario_pizzeria_locks\"\n    )\n\n    scheduler_config = SchedulerConfig(\n        job_stores={'redis': redis_config},\n        executors={\n            'default': {'type': 'threadpool', 'max_workers': 20},\n            'processpool': {'type': 'processpool', 'max_workers': 5}\n        },\n        job_defaults={\n            'coalesce': False,\n            'max_instances': 3\n        },\n        timezone='UTC'\n    )\n\n    return scheduler_config\n</code></pre>"},{"location":"features/background-task-scheduling/#custom-task-executors","title":"Custom Task Executors","text":"<pre><code>from neuroglia.scheduling import CustomTaskExecutor\nimport asyncio\n\nclass PizzaOrderExecutor(CustomTaskExecutor):\n    \"\"\"Custom executor optimized for pizza order processing.\"\"\"\n\n    def __init__(self, max_concurrent_orders: int = 10):\n        super().__init__()\n        self.semaphore = asyncio.Semaphore(max_concurrent_orders)\n        self.active_orders = set()\n\n    async def execute_task(self, task_func, *args, **kwargs):\n        \"\"\"Execute task with order-specific resource management.\"\"\"\n        async with self.semaphore:\n            order_id = kwargs.get('order_id') or args[0] if args else None\n\n            if order_id:\n                if order_id in self.active_orders:\n                    # Skip duplicate order processing\n                    return {\"status\": \"skipped\", \"reason\": \"already_processing\"}\n\n                self.active_orders.add(order_id)\n\n            try:\n                # Execute the actual task\n                result = await task_func(*args, **kwargs)\n                return {\"status\": \"completed\", \"result\": result}\n\n            except Exception as e:\n                return {\"status\": \"failed\", \"error\": str(e)}\n\n            finally:\n                if order_id:\n                    self.active_orders.discard(order_id)\n</code></pre>"},{"location":"features/background-task-scheduling/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"features/background-task-scheduling/#unit-testing-with-mocks","title":"Unit Testing with Mocks","text":"<pre><code>import pytest\nfrom unittest.mock import AsyncMock, Mock\nfrom neuroglia.scheduling import BackgroundTaskScheduler\n\nclass TestOrderTaskScheduling:\n\n    @pytest.fixture\n    def mock_scheduler(self):\n        scheduler = Mock(spec=BackgroundTaskScheduler)\n        scheduler.schedule_delayed_task = AsyncMock()\n        scheduler.schedule_at = AsyncMock()\n        return scheduler\n\n    @pytest.fixture\n    def order_service(self, mock_scheduler):\n        return PizzaOrderService(mock_scheduler)\n\n    @pytest.mark.asyncio\n    async def test_schedule_order_reminders(self, order_service, mock_scheduler):\n        \"\"\"Test order reminder scheduling.\"\"\"\n        order_id = \"order_123\"\n\n        await order_service.schedule_order_reminders(order_id)\n\n        # Verify preparation reminder scheduled\n        mock_scheduler.schedule_delayed_task.assert_any_call(\n            \"order_preparation_reminder\",\n            order_service.send_preparation_reminder,\n            delay_minutes=15,\n            args=[order_id],\n            tags=[\"order\", \"reminder\"]\n        )\n\n        # Verify delivery reminder scheduled\n        mock_scheduler.schedule_delayed_task.assert_any_call(\n            \"order_delivery_reminder\",\n            order_service.send_delivery_reminder,\n            delay_minutes=45,\n            args=[order_id],\n            tags=[\"delivery\", \"reminder\"]\n        )\n\n    @pytest.mark.asyncio\n    async def test_reactive_order_processing(self, mock_scheduler):\n        \"\"\"Test reactive task scheduling from events.\"\"\"\n        event = OrderPlacedEvent(\"order_123\", \"customer_456\", datetime.now() + timedelta(hours=1))\n        handler = OrderTaskScheduler(mock_scheduler)\n\n        await handler.handle_async(event)\n\n        # Verify all order-related tasks were scheduled\n        assert mock_scheduler.schedule_at.call_count == 3\n</code></pre>"},{"location":"features/background-task-scheduling/#integration-testing","title":"Integration Testing","text":"<pre><code>@pytest.mark.integration\nclass TestSchedulerIntegration:\n\n    @pytest.fixture\n    async def redis_scheduler(self):\n        scheduler = BackgroundTaskScheduler(\n            redis_url=\"redis://localhost:6379/15\",  # Test database\n            job_store_prefix=\"test_mario_pizzeria\"\n        )\n        await scheduler.start()\n        yield scheduler\n        await scheduler.shutdown()\n        await scheduler.clear_all_jobs()  # Cleanup\n\n    @pytest.mark.asyncio\n    async def test_end_to_end_order_workflow(self, redis_scheduler):\n        \"\"\"Test complete order processing workflow.\"\"\"\n        order_id = \"integration_test_order\"\n        executed_tasks = []\n\n        async def track_task_execution(task_name):\n            executed_tasks.append(task_name)\n\n        # Schedule workflow tasks\n        await redis_scheduler.schedule_immediate_task(\n            \"inventory_check\",\n            track_task_execution,\n            args=[\"inventory_check\"]\n        )\n\n        # Wait for task execution\n        await asyncio.sleep(2)\n\n        assert \"inventory_check\" in executed_tasks\n</code></pre>"},{"location":"features/background-task-scheduling/#monitoring-and-observability","title":"\ud83d\udcca Monitoring and Observability","text":""},{"location":"features/background-task-scheduling/#task-execution-metrics","title":"Task Execution Metrics","text":"<pre><code>from neuroglia.scheduling import TaskMetrics, MetricsCollector\n\nclass PizzaOrderMetrics(MetricsCollector):\n    def __init__(self):\n        self.metrics = TaskMetrics()\n\n    async def collect_order_metrics(self):\n        \"\"\"Collect pizza order processing metrics.\"\"\"\n        return {\n            \"total_orders_processed\": self.metrics.get_counter(\"orders_processed\"),\n            \"average_preparation_time\": self.metrics.get_gauge(\"avg_prep_time\"),\n            \"failed_tasks_count\": self.metrics.get_counter(\"task_failures\"),\n            \"active_tasks\": self.metrics.get_gauge(\"active_tasks\"),\n            \"task_queue_size\": self.metrics.get_gauge(\"queue_size\")\n        }\n\n    async def export_metrics_to_prometheus(self):\n        \"\"\"Export metrics in Prometheus format.\"\"\"\n        metrics = await self.collect_order_metrics()\n\n        prometheus_metrics = []\n        for metric_name, value in metrics.items():\n            prometheus_metrics.append(f\"mario_pizzeria_{metric_name} {value}\")\n\n        return \"\\n\".join(prometheus_metrics)\n</code></pre>"},{"location":"features/background-task-scheduling/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\ud83d\udd27 Dependency Injection - Service registration patterns</li> <li>\ud83d\udce8 Event Sourcing - Event-driven architecture</li> <li>\ud83d\udd04 Reactive Programming - Stream processing</li> <li>\u26a1 Redis Cache Repository - Distributed caching</li> <li>\ud83c\udf10 HTTP Service Client - External service integration</li> </ul> <p>The background task scheduling system provides enterprise-grade capabilities for building resilient, scalable microservices with complex workflow requirements. By leveraging APScheduler with Redis persistence and reactive processing, Mario's Pizzeria can handle high-volume operations with confidence and reliability.</p>"},{"location":"features/case-conversion-utilities/","title":"\ud83d\udd04 Case Conversion Utilities","text":"<p>The Neuroglia framework provides comprehensive case conversion utilities for seamless data transformation between different naming conventions, enabling smooth integration between frontend frameworks, APIs, and backend services with automatic Pydantic model integration.</p>"},{"location":"features/case-conversion-utilities/#overview","title":"\ud83c\udfaf Overview","text":"<p>Modern applications often need to work with multiple naming conventions simultaneously - JavaScript frontends use camelCase, Python backends use snake_case, and APIs might use kebab-case or PascalCase. The framework's case conversion utilities provide:</p> <ul> <li>Comprehensive Case Conversions: Support for all major naming conventions</li> <li>Pydantic Integration: Automatic model field conversion with CamelModel</li> <li>Dictionary Transformations: Deep conversion of nested data structures</li> <li>String Transformations: Individual string case conversions</li> <li>Preservation of Context: Maintains data integrity during conversions</li> <li>Performance Optimized: Efficient conversion algorithms with caching</li> </ul>"},{"location":"features/case-conversion-utilities/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>graph TB\n    subgraph \"\ud83c\udf55 Mario's Pizzeria Application\"\n        FrontendApp[React Frontend&lt;br/&gt;camelCase]\n        MobileApp[Mobile App&lt;br/&gt;camelCase]\n        ApiLayer[REST API&lt;br/&gt;kebab-case]\n        BackendService[Python Backend&lt;br/&gt;snake_case]\n    end\n\n    subgraph \"\ud83d\udd04 Case Conversion Layer\"\n        CaseConverter[Case Converter]\n        CamelModel[Pydantic CamelModel]\n        DictTransformer[Dictionary Transformer]\n        StringConverter[String Converter]\n    end\n\n    subgraph \"\ud83c\udfaf Conversion Types\"\n        SnakeCase[snake_case]\n        CamelCase[camelCase]\n        PascalCase[PascalCase]\n        KebabCase[kebab-case]\n        ScreamingSnake[SCREAMING_SNAKE]\n    end\n\n    FrontendApp --&gt; CaseConverter\n    MobileApp --&gt; CaseConverter\n    ApiLayer --&gt; CaseConverter\n    BackendService --&gt; CaseConverter\n\n    CaseConverter --&gt; CamelModel\n    CaseConverter --&gt; DictTransformer\n    CaseConverter --&gt; StringConverter\n\n    CamelModel --&gt; SnakeCase\n    CamelModel --&gt; CamelCase\n    DictTransformer --&gt; PascalCase\n    DictTransformer --&gt; KebabCase\n    StringConverter --&gt; ScreamingSnake\n\n    style CaseConverter fill:#e3f2fd\n    style CamelModel fill:#e8f5e8\n    style DictTransformer fill:#fff3e0\n    style StringConverter fill:#f3e5f5</code></pre>"},{"location":"features/case-conversion-utilities/#basic-usage","title":"\ud83d\ude80 Basic Usage","text":""},{"location":"features/case-conversion-utilities/#service-registration","title":"Service Registration","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.utilities.case_conversion import CaseConverter\n\ndef create_app():\n    builder = WebApplicationBuilder()\n\n    # Register case conversion utilities\n    builder.services.add_case_conversion_utilities()\n\n    app = builder.build()\n    return app\n</code></pre>"},{"location":"features/case-conversion-utilities/#string-case-conversions","title":"String Case Conversions","text":"<pre><code>from neuroglia.utilities.case_conversion import CaseConverter\n\nclass MenuItemService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.case_converter = service_provider.get_service(CaseConverter)\n\n    def demonstrate_string_conversions(self):\n        \"\"\"Demonstrate various string case conversions.\"\"\"\n\n        original_field = \"pizza_item_name\"\n\n        # Convert to different case formats\n        conversions = {\n            \"camelCase\": self.case_converter.to_camel_case(original_field),\n            \"PascalCase\": self.case_converter.to_pascal_case(original_field),\n            \"kebab-case\": self.case_converter.to_kebab_case(original_field),\n            \"SCREAMING_SNAKE\": self.case_converter.to_screaming_snake_case(original_field),\n            \"Title Case\": self.case_converter.to_title_case(original_field)\n        }\n\n        print(\"\ud83d\udd04 String Case Conversions:\")\n        print(f\"Original: {original_field}\")\n        for case_name, converted in conversions.items():\n            print(f\"{case_name}: {converted}\")\n\n        return conversions\n\n        # Output:\n        # Original: pizza_item_name\n        # camelCase: pizzaItemName\n        # PascalCase: PizzaItemName\n        # kebab-case: pizza-item-name\n        # SCREAMING_SNAKE: PIZZA_ITEM_NAME\n        # Title Case: Pizza Item Name\n\n    def convert_api_field_names(self, api_response: dict) -&gt; dict:\n        \"\"\"Convert API response field names from kebab-case to snake_case.\"\"\"\n\n        # Example API response with kebab-case fields\n        api_data = {\n            \"menu-item-id\": \"margherita_001\",\n            \"display-name\": \"Margherita Pizza\",\n            \"base-price\": 12.99,\n            \"available-sizes\": [\"small\", \"medium\", \"large\"],\n            \"nutritional-info\": {\n                \"calories-per-slice\": 285,\n                \"total-fat-grams\": 10.4,\n                \"protein-grams\": 12.2\n            }\n        }\n\n        # Convert all keys from kebab-case to snake_case\n        converted_data = self.case_converter.convert_dict_keys(\n            api_data,\n            target_case=\"snake_case\"\n        )\n\n        print(\"\ud83c\udf55 API Field Name Conversion:\")\n        print(f\"Original keys: {list(api_data.keys())}\")\n        print(f\"Converted keys: {list(converted_data.keys())}\")\n\n        return converted_data\n\n        # Result:\n        # {\n        #     \"menu_item_id\": \"margherita_001\",\n        #     \"display_name\": \"Margherita Pizza\",\n        #     \"base_price\": 12.99,\n        #     \"available_sizes\": [\"small\", \"medium\", \"large\"],\n        #     \"nutritional_info\": {\n        #         \"calories_per_slice\": 285,\n        #         \"total_fat_grams\": 10.4,\n        #         \"protein_grams\": 12.2\n        #     }\n        # }\n</code></pre>"},{"location":"features/case-conversion-utilities/#pydantic-camelmodel-integration","title":"\ud83d\udce6 Pydantic CamelModel Integration","text":""},{"location":"features/case-conversion-utilities/#automatic-field-conversion-models","title":"Automatic Field Conversion Models","text":"<pre><code>from neuroglia.utilities.case_conversion import CamelModel\nfrom pydantic import Field\nfrom typing import List, Optional\nfrom datetime import datetime\n\nclass PizzaOrderDto(CamelModel):\n    \"\"\"DTO that automatically converts between camelCase and snake_case.\"\"\"\n\n    order_id: str = Field(..., description=\"Unique order identifier\")\n    customer_name: str = Field(..., description=\"Customer full name\")\n    customer_email: str = Field(..., description=\"Customer email address\")\n    phone_number: Optional[str] = Field(None, description=\"Customer phone number\")\n\n    # Complex nested fields\n    delivery_address: 'DeliveryAddressDto' = Field(..., description=\"Delivery address details\")\n    order_items: List['OrderItemDto'] = Field(..., description=\"List of ordered items\")\n\n    # Calculated fields\n    subtotal_amount: float = Field(..., description=\"Subtotal before tax and delivery\")\n    tax_amount: float = Field(..., description=\"Tax amount\")\n    delivery_fee: float = Field(..., description=\"Delivery fee\")\n    total_amount: float = Field(..., description=\"Total order amount\")\n\n    # Timestamps\n    order_placed_at: datetime = Field(..., description=\"When order was placed\")\n    estimated_delivery_time: datetime = Field(..., description=\"Estimated delivery time\")\n\n    # Status and preferences\n    order_status: str = Field(default=\"pending\", description=\"Current order status\")\n    special_instructions: Optional[str] = Field(None, description=\"Special delivery instructions\")\n    is_rush_order: bool = Field(default=False, description=\"Rush order flag\")\n\nclass DeliveryAddressDto(CamelModel):\n    \"\"\"Delivery address with automatic case conversion.\"\"\"\n\n    street_address: str = Field(..., description=\"Street address\")\n    apartment_number: Optional[str] = Field(None, description=\"Apartment/unit number\")\n    city_name: str = Field(..., description=\"City name\")\n    state_code: str = Field(..., description=\"State/province code\")\n    postal_code: str = Field(..., description=\"ZIP/postal code\")\n    country_code: str = Field(default=\"US\", description=\"Country code\")\n\n    # Location metadata\n    is_business_address: bool = Field(default=False, description=\"Business address flag\")\n    delivery_instructions: Optional[str] = Field(None, description=\"Delivery instructions\")\n\nclass OrderItemDto(CamelModel):\n    \"\"\"Individual order item with case conversion.\"\"\"\n\n    menu_item_id: str = Field(..., description=\"Menu item identifier\")\n    item_name: str = Field(..., description=\"Menu item name\")\n    item_size: str = Field(..., description=\"Size selection\")\n    base_price: float = Field(..., description=\"Base item price\")\n\n    # Customizations\n    selected_toppings: List[str] = Field(default_factory=list, description=\"Selected toppings\")\n    removed_ingredients: List[str] = Field(default_factory=list, description=\"Removed ingredients\")\n    special_requests: Optional[str] = Field(None, description=\"Special preparation requests\")\n\n    # Pricing\n    toppings_price: float = Field(default=0.0, description=\"Additional toppings cost\")\n    item_quantity: int = Field(default=1, description=\"Quantity ordered\")\n    line_item_total: float = Field(..., description=\"Total for this line item\")\n\n# Usage demonstration\nclass OrderProcessingService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.case_converter = service_provider.get_service(CaseConverter)\n\n    def process_frontend_order(self, frontend_data: dict) -&gt; PizzaOrderDto:\n        \"\"\"Process order data from JavaScript frontend (camelCase).\"\"\"\n\n        # Frontend sends data in camelCase\n        frontend_order = {\n            \"orderId\": \"ORD_20241201_001\",\n            \"customerName\": \"Mario Rossi\",\n            \"customerEmail\": \"mario.rossi@email.com\",\n            \"phoneNumber\": \"+1-555-0123\",\n            \"deliveryAddress\": {\n                \"streetAddress\": \"123 Pizza Street\",\n                \"apartmentNumber\": \"Apt 2B\",\n                \"cityName\": \"New York\",\n                \"stateCode\": \"NY\",\n                \"postalCode\": \"10001\",\n                \"isBusinessAddress\": False,\n                \"deliveryInstructions\": \"Ring doorbell twice\"\n            },\n            \"orderItems\": [\n                {\n                    \"menuItemId\": \"margherita_large\",\n                    \"itemName\": \"Margherita Pizza\",\n                    \"itemSize\": \"large\",\n                    \"basePrice\": 18.99,\n                    \"selectedToppings\": [\"extra_cheese\", \"fresh_basil\"],\n                    \"removedIngredients\": [],\n                    \"toppingsPrice\": 3.50,\n                    \"itemQuantity\": 2,\n                    \"lineItemTotal\": 44.98\n                }\n            ],\n            \"subtotalAmount\": 44.98,\n            \"taxAmount\": 3.60,\n            \"deliveryFee\": 2.99,\n            \"totalAmount\": 51.57,\n            \"orderPlacedAt\": \"2024-12-01T14:30:00Z\",\n            \"estimatedDeliveryTime\": \"2024-12-01T15:15:00Z\",\n            \"specialInstructions\": \"Please call when arriving\",\n            \"isRushOrder\": True\n        }\n\n        # CamelModel automatically converts camelCase to snake_case for internal processing\n        order_dto = PizzaOrderDto(**frontend_order)\n\n        print(\"\ud83c\udf55 Order processed from frontend:\")\n        print(f\"Order ID: {order_dto.order_id}\")\n        print(f\"Customer: {order_dto.customer_name}\")\n        print(f\"Items: {len(order_dto.order_items)}\")\n        print(f\"Total: ${order_dto.total_amount}\")\n\n        return order_dto\n\n    def send_to_frontend(self, order: PizzaOrderDto) -&gt; dict:\n        \"\"\"Convert order back to camelCase for frontend response.\"\"\"\n\n        # CamelModel automatically converts snake_case to camelCase for API response\n        frontend_response = order.dict(by_alias=True)  # Uses camelCase aliases\n\n        print(\"\ud83d\udce4 Sending to frontend in camelCase:\")\n        print(f\"Keys: {list(frontend_response.keys())}\")\n\n        return frontend_response\n\n        # Response will have camelCase keys:\n        # {\n        #     \"orderId\": \"ORD_20241201_001\",\n        #     \"customerName\": \"Mario Rossi\",\n        #     \"customerEmail\": \"mario.rossi@email.com\",\n        #     \"deliveryAddress\": {...},\n        #     \"orderItems\": [...],\n        #     \"totalAmount\": 51.57,\n        #     ...\n        # }\n</code></pre>"},{"location":"features/case-conversion-utilities/#dictionary-transformations","title":"\ud83d\udd04 Dictionary Transformations","text":""},{"location":"features/case-conversion-utilities/#deep-nested-structure-conversion","title":"Deep Nested Structure Conversion","text":"<pre><code>from neuroglia.utilities.case_conversion import DictCaseConverter\n\nclass MenuManagementService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.dict_converter = service_provider.get_service(DictCaseConverter)\n\n    def process_complex_menu_data(self):\n        \"\"\"Process complex nested menu data with different case conventions.\"\"\"\n\n        # Complex menu structure from external system (mixed case conventions)\n        external_menu_data = {\n            \"restaurantInfo\": {\n                \"restaurant_name\": \"Mario's Pizzeria\",\n                \"businessHours\": {\n                    \"monday-friday\": {\n                        \"opening_time\": \"11:00\",\n                        \"closingTime\": \"22:00\"\n                    },\n                    \"weekend_hours\": {\n                        \"saturday_opening\": \"12:00\",\n                        \"sunday-closing\": \"21:00\"\n                    }\n                },\n                \"contact-information\": {\n                    \"phone_number\": \"+1-555-PIZZA\",\n                    \"emailAddress\": \"orders@mariospizzeria.com\"\n                }\n            },\n            \"menuCategories\": [\n                {\n                    \"category_id\": \"pizzas\",\n                    \"displayName\": \"Artisan Pizzas\",\n                    \"menu-items\": [\n                        {\n                            \"item_id\": \"margherita_classic\",\n                            \"itemName\": \"Classic Margherita\",\n                            \"basePrice\": 16.99,\n                            \"available-sizes\": {\n                                \"small_size\": {\"price\": 12.99, \"diameter_inches\": 10},\n                                \"mediumSize\": {\"price\": 16.99, \"diameter-inches\": 12},\n                                \"large_option\": {\"price\": 21.99, \"diameter_inches\": 14}\n                            },\n                            \"nutritional-data\": {\n                                \"calories_per_slice\": 285,\n                                \"macroNutrients\": {\n                                    \"total_fat\": 10.4,\n                                    \"saturatedFat\": 4.8,\n                                    \"total-carbs\": 36.2,\n                                    \"protein_content\": 12.2\n                                },\n                                \"allergen-info\": {\n                                    \"contains_gluten\": True,\n                                    \"dairy_products\": True,\n                                    \"nut_free\": True\n                                }\n                            }\n                        }\n                    ]\n                }\n            ]\n        }\n\n        # Convert entire structure to consistent snake_case\n        snake_case_menu = self.dict_converter.convert_nested_dict(\n            external_menu_data,\n            target_case=\"snake_case\",\n            preserve_arrays=True,\n            max_depth=10\n        )\n\n        print(\"\ud83d\udc0d Converted to snake_case:\")\n        self.print_menu_structure(snake_case_menu)\n\n        # Convert to camelCase for frontend API\n        camel_case_menu = self.dict_converter.convert_nested_dict(\n            snake_case_menu,\n            target_case=\"camelCase\",\n            preserve_arrays=True\n        )\n\n        print(\"\ud83d\udc2a Converted to camelCase:\")\n        self.print_menu_structure(camel_case_menu)\n\n        # Convert to kebab-case for URL-friendly slugs\n        kebab_case_menu = self.dict_converter.convert_nested_dict(\n            snake_case_menu,\n            target_case=\"kebab-case\",\n            preserve_arrays=True,\n            key_filter=lambda key: key not in ['item_id', 'category_id']  # Preserve IDs\n        )\n\n        return {\n            \"snake_case\": snake_case_menu,\n            \"camelCase\": camel_case_menu,\n            \"kebab-case\": kebab_case_menu\n        }\n\n    def print_menu_structure(self, menu_data: dict, indent: int = 0):\n        \"\"\"Print menu structure with indentation.\"\"\"\n        for key, value in menu_data.items():\n            if isinstance(value, dict):\n                print(\"  \" * indent + f\"\ud83d\udcc1 {key}:\")\n                self.print_menu_structure(value, indent + 1)\n            elif isinstance(value, list) and value and isinstance(value[0], dict):\n                print(\"  \" * indent + f\"\ud83d\udccb {key}: [{len(value)} items]\")\n            else:\n                print(\"  \" * indent + f\"\ud83d\udcc4 {key}: {type(value).__name__}\")\n</code></pre>"},{"location":"features/case-conversion-utilities/#selective-field-conversion","title":"Selective Field Conversion","text":"<pre><code>class CustomerProfileService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.dict_converter = service_provider.get_service(DictCaseConverter)\n\n    def convert_with_field_mapping(self, customer_data: dict) -&gt; dict:\n        \"\"\"Convert customer data with custom field mappings.\"\"\"\n\n        # Original customer data from CRM system\n        crm_customer_data = {\n            \"customer_id\": \"CUST_001\",\n            \"personalInfo\": {\n                \"firstName\": \"Giuseppe\",\n                \"lastName\": \"Verdi\",\n                \"date_of_birth\": \"1985-03-15\",\n                \"email-address\": \"giuseppe.verdi@email.com\"\n            },\n            \"loyaltyProgram\": {\n                \"membership_level\": \"gold\",\n                \"points_balance\": 1250,\n                \"next-reward-threshold\": 1500\n            },\n            \"orderHistory\": {\n                \"total_orders\": 47,\n                \"favorite-items\": [\"margherita\", \"quattro_stagioni\"],\n                \"average_order_value\": 28.75\n            }\n        }\n\n        # Define custom field mappings\n        field_mappings = {\n            \"firstName\": \"given_name\",\n            \"lastName\": \"family_name\",\n            \"email-address\": \"primary_email\",\n            \"membership_level\": \"loyalty_tier\",\n            \"points_balance\": \"reward_points\",\n            \"next-reward-threshold\": \"next_milestone\",\n            \"favorite-items\": \"preferred_menu_items\",\n            \"average_order_value\": \"avg_purchase_amount\"\n        }\n\n        # Convert with custom mappings and case conversion\n        converted_data = self.dict_converter.convert_with_mapping(\n            crm_customer_data,\n            field_mappings=field_mappings,\n            target_case=\"snake_case\",\n            preserve_structure=True\n        )\n\n        print(\"\ud83d\udc64 Customer Data Conversion:\")\n        print(f\"Original keys: {self.get_all_keys(crm_customer_data)}\")\n        print(f\"Converted keys: {self.get_all_keys(converted_data)}\")\n\n        return converted_data\n\n        # Result:\n        # {\n        #     \"customer_id\": \"CUST_001\",\n        #     \"personal_info\": {\n        #         \"given_name\": \"Giuseppe\",\n        #         \"family_name\": \"Verdi\",\n        #         \"date_of_birth\": \"1985-03-15\",\n        #         \"primary_email\": \"giuseppe.verdi@email.com\"\n        #     },\n        #     \"loyalty_program\": {\n        #         \"loyalty_tier\": \"gold\",\n        #         \"reward_points\": 1250,\n        #         \"next_milestone\": 1500\n        #     },\n        #     \"order_history\": {\n        #         \"total_orders\": 47,\n        #         \"preferred_menu_items\": [\"margherita\", \"quattro_stagioni\"],\n        #         \"avg_purchase_amount\": 28.75\n        #     }\n        # }\n\n    def get_all_keys(self, data: dict, keys=None) -&gt; list:\n        \"\"\"Recursively get all keys from nested dictionary.\"\"\"\n        if keys is None:\n            keys = []\n\n        for key, value in data.items():\n            keys.append(key)\n            if isinstance(value, dict):\n                self.get_all_keys(value, keys)\n\n        return keys\n</code></pre>"},{"location":"features/case-conversion-utilities/#advanced-case-conversion-patterns","title":"\ud83c\udfa8 Advanced Case Conversion Patterns","text":""},{"location":"features/case-conversion-utilities/#api-boundary-conversion","title":"API Boundary Conversion","text":"<pre><code>from neuroglia.mvc import ControllerBase\nfrom neuroglia.utilities.case_conversion import ApiCaseConverter\n\nclass PizzaMenuController(ControllerBase):\n    \"\"\"Controller demonstrating automatic case conversion at API boundaries.\"\"\"\n\n    def __init__(self, service_provider: ServiceProviderBase,\n                 mapper: Mapper, mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n        self.api_converter = service_provider.get_service(ApiCaseConverter)\n\n    @get(\"/menu/{category_id}\")\n    async def get_menu_category(self, category_id: str) -&gt; dict:\n        \"\"\"Get menu category with automatic case conversion for API response.\"\"\"\n\n        # Internal service returns snake_case data\n        internal_menu_data = await self.get_internal_menu_data(category_id)\n\n        # Convert to camelCase for frontend consumption\n        api_response = self.api_converter.convert_for_api_response(\n            internal_menu_data,\n            input_case=\"snake_case\",\n            output_case=\"camelCase\"\n        )\n\n        return api_response\n\n    @post(\"/menu/items\")\n    async def create_menu_item(self, menu_item_data: dict) -&gt; dict:\n        \"\"\"Create menu item with automatic request/response conversion.\"\"\"\n\n        # Frontend sends camelCase data\n        print(f\"\ud83d\udce5 Received from frontend: {list(menu_item_data.keys())}\")\n\n        # Convert to snake_case for internal processing\n        internal_data = self.api_converter.convert_for_internal_processing(\n            menu_item_data,\n            input_case=\"camelCase\",\n            output_case=\"snake_case\"\n        )\n\n        print(f\"\ud83d\udd04 Converted for internal use: {list(internal_data.keys())}\")\n\n        # Process internally (snake_case)\n        created_item = await self.create_internal_menu_item(internal_data)\n\n        # Convert response back to camelCase\n        api_response = self.api_converter.convert_for_api_response(\n            created_item,\n            input_case=\"snake_case\",\n            output_case=\"camelCase\"\n        )\n\n        print(f\"\ud83d\udce4 Sending to frontend: {list(api_response.keys())}\")\n\n        return api_response\n\nclass DatabaseIntegrationService:\n    \"\"\"Service demonstrating database field name conversion.\"\"\"\n\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.case_converter = service_provider.get_service(CaseConverter)\n        self.db_converter = service_provider.get_service(DatabaseCaseConverter)\n\n    async def save_order_with_field_mapping(self, order_data: dict):\n        \"\"\"Save order data with database field name conversion.\"\"\"\n\n        # Application uses snake_case\n        application_order = {\n            \"order_id\": \"ORD_001\",\n            \"customer_name\": \"Mario Rossi\",\n            \"order_total\": 45.99,\n            \"delivery_address\": \"123 Main St\",\n            \"order_status\": \"confirmed\",\n            \"created_at\": datetime.utcnow(),\n            \"estimated_delivery\": datetime.utcnow() + timedelta(minutes=30)\n        }\n\n        # Database uses different naming convention\n        database_field_mapping = {\n            \"order_id\": \"ORDER_ID\",\n            \"customer_name\": \"CUSTOMER_FULL_NAME\",\n            \"order_total\": \"TOTAL_AMOUNT_USD\",\n            \"delivery_address\": \"DELIVERY_ADDR_LINE1\",\n            \"order_status\": \"ORDER_STATUS_CODE\",\n            \"created_at\": \"CREATED_TIMESTAMP\",\n            \"estimated_delivery\": \"EST_DELIVERY_TIME\"\n        }\n\n        # Convert for database insertion\n        database_record = self.db_converter.convert_for_database(\n            application_order,\n            field_mapping=database_field_mapping,\n            target_case=\"SCREAMING_SNAKE_CASE\"\n        )\n\n        print(\"\ud83d\udcbe Database Record:\")\n        for db_field, value in database_record.items():\n            print(f\"  {db_field}: {value}\")\n\n        # Simulate database save\n        await self.save_to_database(database_record)\n\n        return database_record\n</code></pre>"},{"location":"features/case-conversion-utilities/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"features/case-conversion-utilities/#case-conversion-testing","title":"Case Conversion Testing","text":"<pre><code>import pytest\nfrom neuroglia.utilities.case_conversion import CaseConverter, CamelModel\n\nclass TestCaseConversions:\n\n    @pytest.fixture\n    def case_converter(self):\n        return CaseConverter()\n\n    def test_string_case_conversions(self, case_converter):\n        \"\"\"Test various string case conversions.\"\"\"\n\n        test_cases = [\n            # (input, expected_camel, expected_pascal, expected_kebab, expected_snake)\n            (\"hello_world\", \"helloWorld\", \"HelloWorld\", \"hello-world\", \"hello_world\"),\n            (\"getUserName\", \"getUserName\", \"GetUserName\", \"get-user-name\", \"get_user_name\"),\n            (\"XML-HTTP-Request\", \"xmlHttpRequest\", \"XmlHttpRequest\", \"xml-http-request\", \"xml_http_request\"),\n            (\"pizza_item_ID\", \"pizzaItemId\", \"PizzaItemId\", \"pizza-item-id\", \"pizza_item_id\"),\n        ]\n\n        for input_str, expected_camel, expected_pascal, expected_kebab, expected_snake in test_cases:\n            assert case_converter.to_camel_case(input_str) == expected_camel\n            assert case_converter.to_pascal_case(input_str) == expected_pascal\n            assert case_converter.to_kebab_case(input_str) == expected_kebab\n            assert case_converter.to_snake_case(input_str) == expected_snake\n\n    def test_nested_dict_conversion(self, case_converter):\n        \"\"\"Test nested dictionary case conversion.\"\"\"\n\n        input_dict = {\n            \"user_name\": \"Mario\",\n            \"contactInfo\": {\n                \"email_address\": \"mario@test.com\",\n                \"phoneNumber\": \"+1234567890\"\n            },\n            \"orderHistory\": [\n                {\n                    \"order_id\": \"001\",\n                    \"totalAmount\": 25.99\n                }\n            ]\n        }\n\n        # Convert to camelCase\n        camel_result = case_converter.convert_dict_keys(input_dict, \"camelCase\")\n\n        assert \"userName\" in camel_result\n        assert \"contactInfo\" in camel_result\n        assert \"emailAddress\" in camel_result[\"contactInfo\"]\n        assert \"phoneNumber\" in camel_result[\"contactInfo\"]\n        assert \"orderId\" in camel_result[\"orderHistory\"][0]\n        assert \"totalAmount\" in camel_result[\"orderHistory\"][0]\n\n    def test_camel_model_integration(self):\n        \"\"\"Test Pydantic CamelModel integration.\"\"\"\n\n        class TestModel(CamelModel):\n            user_name: str\n            email_address: str\n            phone_number: Optional[str] = None\n\n        # Test with camelCase input\n        camel_data = {\n            \"userName\": \"Mario\",\n            \"emailAddress\": \"mario@test.com\",\n            \"phoneNumber\": \"+1234567890\"\n        }\n\n        model = TestModel(**camel_data)\n\n        # Internal representation uses snake_case\n        assert model.user_name == \"Mario\"\n        assert model.email_address == \"mario@test.com\"\n        assert model.phone_number == \"+1234567890\"\n\n        # Export with camelCase aliases\n        exported = model.dict(by_alias=True)\n        assert \"userName\" in exported\n        assert \"emailAddress\" in exported\n        assert \"phoneNumber\" in exported\n\n    @pytest.mark.parametrize(\"input_case,output_case,input_key,expected_key\", [\n        (\"snake_case\", \"camelCase\", \"pizza_item_name\", \"pizzaItemName\"),\n        (\"camelCase\", \"snake_case\", \"pizzaItemName\", \"pizza_item_name\"),\n        (\"kebab-case\", \"PascalCase\", \"pizza-item-name\", \"PizzaItemName\"),\n        (\"PascalCase\", \"kebab-case\", \"PizzaItemName\", \"pizza-item-name\"),\n    ])\n    def test_parametrized_conversions(self, case_converter, input_case, output_case, input_key, expected_key):\n        \"\"\"Test parametrized case conversions.\"\"\"\n\n        result = case_converter.convert_case(input_key, target_case=output_case)\n        assert result == expected_key\n</code></pre>"},{"location":"features/case-conversion-utilities/#integration-testing","title":"Integration Testing","text":"<pre><code>@pytest.mark.integration\nclass TestCaseConversionIntegration:\n\n    @pytest.fixture\n    def pizza_order_data(self):\n        return {\n            \"orderId\": \"ORD_001\",\n            \"customerName\": \"Mario Rossi\",\n            \"pizzaItems\": [\n                {\n                    \"itemName\": \"Margherita\",\n                    \"basePrice\": 16.99,\n                    \"selectedToppings\": [\"extra_cheese\"]\n                }\n            ],\n            \"deliveryAddress\": {\n                \"streetAddress\": \"123 Pizza St\",\n                \"cityName\": \"New York\"\n            }\n        }\n\n    def test_full_order_processing_flow(self, pizza_order_data):\n        \"\"\"Test complete order processing with case conversions.\"\"\"\n\n        # Simulate frontend -&gt; backend -&gt; database flow\n        converter = CaseConverter()\n\n        # Step 1: Convert from frontend camelCase to internal snake_case\n        internal_data = converter.convert_dict_keys(pizza_order_data, \"snake_case\")\n\n        assert \"order_id\" in internal_data\n        assert \"customer_name\" in internal_data\n        assert \"pizza_items\" in internal_data\n        assert \"delivery_address\" in internal_data\n\n        # Step 2: Process internally (would involve business logic)\n        processed_data = {\n            **internal_data,\n            \"order_status\": \"confirmed\",\n            \"total_amount\": 19.99\n        }\n\n        # Step 3: Convert back to camelCase for API response\n        api_response = converter.convert_dict_keys(processed_data, \"camelCase\")\n\n        assert \"orderId\" in api_response\n        assert \"orderStatus\" in api_response\n        assert \"totalAmount\" in api_response\n\n        # Verify data integrity maintained\n        assert api_response[\"customerName\"] == \"Mario Rossi\"\n        assert api_response[\"totalAmount\"] == 19.99\n</code></pre>"},{"location":"features/case-conversion-utilities/#performance-optimization","title":"\ud83d\udcca Performance Optimization","text":""},{"location":"features/case-conversion-utilities/#caching-and-performance","title":"Caching and Performance","text":"<pre><code>from neuroglia.utilities.case_conversion import CachedCaseConverter\nimport time\nfrom typing import Dict\n\nclass PerformanceOptimizedConverter:\n    \"\"\"High-performance case converter with caching and optimization.\"\"\"\n\n    def __init__(self):\n        self.cached_converter = CachedCaseConverter(cache_size=1000)\n        self.conversion_stats = {\n            \"cache_hits\": 0,\n            \"cache_misses\": 0,\n            \"total_conversions\": 0\n        }\n\n    def benchmark_conversions(self, test_data: Dict[str, any], iterations: int = 1000):\n        \"\"\"Benchmark case conversion performance.\"\"\"\n\n        print(f\"\ud83d\ude80 Performance Benchmark ({iterations} iterations)\")\n\n        # Test without caching\n        start_time = time.time()\n        for _ in range(iterations):\n            converter = CaseConverter()  # New instance each time\n            result = converter.convert_dict_keys(test_data, \"camelCase\")\n\n        uncached_time = time.time() - start_time\n\n        # Test with caching\n        start_time = time.time()\n        for _ in range(iterations):\n            result = self.cached_converter.convert_dict_keys(test_data, \"camelCase\")\n\n        cached_time = time.time() - start_time\n\n        performance_improvement = ((uncached_time - cached_time) / uncached_time) * 100\n\n        print(f\"Without caching: {uncached_time:.4f}s\")\n        print(f\"With caching: {cached_time:.4f}s\")\n        print(f\"Performance improvement: {performance_improvement:.1f}%\")\n        print(f\"Cache hit rate: {self.get_cache_hit_rate():.1f}%\")\n\n        return {\n            \"uncached_time\": uncached_time,\n            \"cached_time\": cached_time,\n            \"improvement_percent\": performance_improvement,\n            \"cache_hit_rate\": self.get_cache_hit_rate()\n        }\n\n    def get_cache_hit_rate(self) -&gt; float:\n        \"\"\"Calculate cache hit rate percentage.\"\"\"\n        total = self.conversion_stats[\"cache_hits\"] + self.conversion_stats[\"cache_misses\"]\n        return (self.conversion_stats[\"cache_hits\"] / total * 100) if total &gt; 0 else 0\n</code></pre>"},{"location":"features/case-conversion-utilities/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\ud83d\udd27 Dependency Injection - Service registration patterns</li> <li>\ud83c\udf10 HTTP Service Client - API request/response transformation</li> <li>\ud83d\udcca Enhanced Model Validation - Model field validation</li> <li>\ud83d\udcc1 Data Access - Database field mapping</li> <li>\ud83d\udce8 CQRS &amp; Mediation - Command/query object conversion</li> </ul> <p>The Case Conversion Utilities provide seamless transformation capabilities that enable Mario's Pizzeria to work with multiple naming conventions across different layers of the application. Through comprehensive conversion support and Pydantic integration, the system maintains data consistency while adapting to various API and framework requirements.</p>"},{"location":"features/configurable-type-discovery/","title":"\ud83c\udfaf Configurable Type Discovery","text":"<p>The Neuroglia framework provides a flexible TypeRegistry system that allows applications to configure which modules should be scanned for domain types (enums, value objects, etc.) without hardcoding patterns in the framework itself.</p>"},{"location":"features/configurable-type-discovery/#overview","title":"\ud83c\udfaf Overview","text":"<p>The TypeRegistry replaces hardcoded domain structure assumptions with a clean, configurable approach:</p> <ul> <li>Framework Agnostic: No domain-specific knowledge in framework code</li> <li>Configurable: Applications specify their exact module structure</li> <li>Performance Optimized: Only scans registered modules instead of trying dozens of patterns</li> <li>Extensible: Supports dynamic type discovery and multiple configuration methods</li> </ul>"},{"location":"features/configurable-type-discovery/#core-components","title":"\ud83c\udfd7\ufe0f Core Components","text":""},{"location":"features/configurable-type-discovery/#typeregistry","title":"TypeRegistry","text":"<p>The <code>TypeRegistry</code> provides centralized type discovery using the framework's existing utilities:</p> <pre><code>from neuroglia.core.type_registry import TypeRegistry, get_type_registry\nfrom neuroglia.core.type_finder import TypeFinder\nfrom neuroglia.core.module_loader import ModuleLoader\n\n# Get the global type registry instance\nregistry = get_type_registry()\n\n# Register modules for type discovery\nregistry.register_modules([\n    \"domain.entities.enums\",\n    \"domain.value_objects\",\n    \"shared.types\"\n])\n\n# Find enum for a value\npizza_size_enum = registry.find_enum_for_value(\"LARGE\")\n</code></pre>"},{"location":"features/configurable-type-discovery/#enhanced-jsonserializer","title":"Enhanced JsonSerializer","text":"<p>The <code>JsonSerializer</code> now accepts configurable type modules:</p> <pre><code>from neuroglia.serialization.json import JsonSerializer\nfrom neuroglia.hosting.enhanced_web_application_builder import EnhancedWebApplicationBuilder\n\nbuilder = EnhancedWebApplicationBuilder()\n\n# Configure with specific type modules\nJsonSerializer.configure(builder, type_modules=[\n    \"domain.entities.enums\",      # Main enum module\n    \"domain.entities\",            # Entity module (for embedded enums)\n    \"domain.value_objects\",       # Value objects with enums\n])\n</code></pre>"},{"location":"features/configurable-type-discovery/#configuration-methods","title":"\ud83d\ude80 Configuration Methods","text":""},{"location":"features/configurable-type-discovery/#method-1-direct-configuration","title":"Method 1: Direct Configuration","text":"<p>Configure type modules during JsonSerializer setup:</p> <pre><code>def configure_application():\n    builder = EnhancedWebApplicationBuilder()\n\n    # Configure JsonSerializer with your domain modules\n    JsonSerializer.configure(builder, type_modules=[\n        \"myapp.domain.enums\",         # Primary enumerations\n        \"myapp.domain.entities\",      # Domain entities\n        \"myapp.domain.value_objects\", # Value objects\n        \"myapp.shared.types\",         # Shared types\n        \"myapp.integration.external\"  # External API types\n    ])\n\n    return builder\n</code></pre>"},{"location":"features/configurable-type-discovery/#method-2-post-configuration-registration","title":"Method 2: Post-Configuration Registration","text":"<p>Register modules after initial configuration:</p> <pre><code>def configure_with_registration():\n    builder = EnhancedWebApplicationBuilder()\n\n    # Basic configuration\n    JsonSerializer.configure(builder)\n\n    # Register additional type modules\n    JsonSerializer.register_type_modules([\n        \"myapp.domain.aggregates\",\n        \"myapp.domain.value_objects\",\n        \"myapp.shared.enums\"\n    ])\n\n    return builder\n</code></pre>"},{"location":"features/configurable-type-discovery/#method-3-direct-typeregistry-access","title":"Method 3: Direct TypeRegistry Access","text":"<p>Configure the TypeRegistry directly for advanced scenarios:</p> <pre><code>def configure_advanced():\n    from neuroglia.core.type_registry import get_type_registry\n\n    # Get the global registry\n    registry = get_type_registry()\n\n    # Register core domain modules\n    registry.register_modules([\n        \"orders.domain.entities\",\n        \"orders.domain.enums\"\n    ])\n\n    # Register shared library types\n    registry.register_modules([\n        \"shared_lib.common.enums\",\n        \"payment_gateway.types\"\n    ])\n\n    # Standard JsonSerializer configuration\n    builder = EnhancedWebApplicationBuilder()\n    JsonSerializer.configure(builder)\n\n    return builder\n</code></pre>"},{"location":"features/configurable-type-discovery/#usage-examples","title":"\ud83e\uddea Usage Examples","text":""},{"location":"features/configurable-type-discovery/#mario-pizzeria-configuration","title":"Mario Pizzeria Configuration","text":"<pre><code>from neuroglia.serialization.json import JsonSerializer\nfrom neuroglia.hosting.enhanced_web_application_builder import EnhancedWebApplicationBuilder\n\ndef configure_mario_pizzeria():\n    builder = EnhancedWebApplicationBuilder()\n\n    # Configure with Mario Pizzeria's domain structure\n    JsonSerializer.configure(builder, type_modules=[\n        \"domain.entities.enums\",      # PizzaSize, OrderStatus, Priority\n        \"domain.entities\",            # Pizza, Order entities\n        \"domain.value_objects\",       # Money, Address value objects\n    ])\n\n    return builder\n</code></pre>"},{"location":"features/configurable-type-discovery/#microservice-configuration","title":"Microservice Configuration","text":"<pre><code>def configure_microservice():\n    from neuroglia.core.type_registry import get_type_registry\n\n    registry = get_type_registry()\n\n    # Register internal domain types\n    registry.register_modules([\n        \"orders.domain.entities\",\n        \"orders.domain.enums\"\n    ])\n\n    # Register external service types we need to deserialize\n    registry.register_modules([\n        \"payment_service.models\",\n        \"inventory_service.types\",\n        \"shared_contracts.events\"\n    ])\n\n    builder = EnhancedWebApplicationBuilder()\n    JsonSerializer.configure(builder)\n    return builder\n</code></pre>"},{"location":"features/configurable-type-discovery/#flat-project-structure","title":"Flat Project Structure","text":"<p>For projects with simple, flat module structure:</p> <pre><code>def configure_flat_structure():\n    builder = EnhancedWebApplicationBuilder()\n\n    # Simple flat structure: models.py, enums.py, types.py\n    JsonSerializer.configure(builder, type_modules=[\n        \"models\",        # Main model types\n        \"enums\",         # All enumerations\n        \"types\",         # Custom types\n        \"constants\"      # Constants and lookups\n    ])\n\n    return builder\n</code></pre>"},{"location":"features/configurable-type-discovery/#dynamic-type-discovery","title":"\ud83d\udd27 Dynamic Type Discovery","text":"<p>For advanced scenarios, you can dynamically discover and register types:</p> <pre><code>def dynamic_type_discovery():\n    from neuroglia.core.type_registry import get_type_registry\n    from neuroglia.core.type_finder import TypeFinder\n    from neuroglia.core.module_loader import ModuleLoader\n    from enum import Enum\n\n    registry = get_type_registry()\n\n    # Discover all enum types in base modules\n    base_modules = [\"myapp.domain\", \"myapp.shared\"]\n\n    for base_module_name in base_modules:\n        try:\n            base_module = ModuleLoader.load(base_module_name)\n\n            # Find all enum types\n            enum_types = TypeFinder.get_types(\n                base_module,\n                predicate=lambda t: isinstance(t, type) and issubclass(t, Enum) and t != Enum,\n                include_sub_modules=True,\n                include_sub_packages=True\n            )\n\n            if enum_types:\n                print(f\"Discovered {len(enum_types)} enum types in {base_module_name}\")\n                # Types are automatically cached when accessed\n\n        except ImportError:\n            print(f\"Module {base_module_name} not available\")\n\n    return registry\n</code></pre>"},{"location":"features/configurable-type-discovery/#best-practices","title":"\ud83d\udca1 Best Practices","text":""},{"location":"features/configurable-type-discovery/#1-specific-module-registration","title":"1. Specific Module Registration","text":"<p>Register only the modules that contain types you need:</p> <pre><code># Good: Specific modules\nJsonSerializer.configure(builder, type_modules=[\n    \"domain.entities.enums\",      # Specific enum module\n    \"domain.value_objects\"        # Specific value object module\n])\n\n# Avoid: Too broad\nJsonSerializer.configure(builder, type_modules=[\n    \"domain\",                     # Too broad, includes everything\n    \"application\"                 # Application layer shouldn't have enums\n])\n</code></pre>"},{"location":"features/configurable-type-discovery/#2-layer-appropriate-registration","title":"2. Layer-Appropriate Registration","text":"<p>Only register modules from appropriate architectural layers:</p> <pre><code># Good: Domain and integration layers\nJsonSerializer.configure(builder, type_modules=[\n    \"domain.entities.enums\",         # Domain layer\n    \"domain.value_objects\",          # Domain layer\n    \"integration.external_types\"     # Integration layer for external APIs\n])\n\n# Avoid: Application layer\nJsonSerializer.configure(builder, type_modules=[\n    \"application.commands\",          # Commands shouldn't have enums\n    \"application.handlers\"           # Handlers shouldn't have enums\n])\n</code></pre>"},{"location":"features/configurable-type-discovery/#3-performance-optimization","title":"3. Performance Optimization","text":"<p>Register modules in order of frequency of use:</p> <pre><code># Most frequently used enums first\nJsonSerializer.configure(builder, type_modules=[\n    \"domain.entities.enums\",      # Most common: PizzaSize, OrderStatus\n    \"domain.value_objects\",       # Less common: specialized enums\n    \"shared.constants\"            # Least common: system constants\n])\n</code></pre>"},{"location":"features/configurable-type-discovery/#4-modular-configuration","title":"4. Modular Configuration","text":"<p>For large applications, organize configuration by feature:</p> <pre><code>def configure_order_types():\n    return [\n        \"orders.domain.enums\",\n        \"orders.domain.entities\",\n        \"orders.integration.payment_types\"\n    ]\n\ndef configure_inventory_types():\n    return [\n        \"inventory.domain.enums\",\n        \"inventory.domain.entities\",\n        \"inventory.integration.supplier_types\"\n    ]\n\ndef configure_application():\n    builder = EnhancedWebApplicationBuilder()\n\n    all_type_modules = (\n        configure_order_types() +\n        configure_inventory_types() +\n        [\"shared.common.enums\"]\n    )\n\n    JsonSerializer.configure(builder, type_modules=all_type_modules)\n    return builder\n</code></pre>"},{"location":"features/configurable-type-discovery/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Data Access - Repository patterns and serialization</li> <li>Domain-Driven Design - Domain layer organization</li> <li>Dependency Injection - Service configuration patterns</li> </ul>"},{"location":"features/configurable-type-discovery/#testing-configuration","title":"\ud83e\uddea Testing Configuration","text":"<p>Test your type configuration with different scenarios:</p> <pre><code>def test_configured_serialization():\n    \"\"\"Test that configured types are discovered correctly\"\"\"\n    from neuroglia.core.type_registry import get_type_registry\n\n    registry = get_type_registry()\n    registry.register_modules([\"domain.entities.enums\"])\n\n    # Test enum discovery\n    pizza_size_enum = registry.find_enum_for_value(\"LARGE\")\n    assert pizza_size_enum is not None\n    assert pizza_size_enum.__name__ == \"PizzaSize\"\n\n    print(\"\u2705 Configured type discovery working correctly\")\n</code></pre> <p>The configurable TypeRegistry approach ensures your application can specify exactly which modules contain domain types, making the framework truly generic while maintaining intelligent type inference capabilities.</p>"},{"location":"features/data-access/","title":"\ud83c\udf55 Data Access","text":"<p>Neuroglia provides a flexible data access layer that supports multiple storage backends through a unified repository pattern for Mario's Pizzeria. From storing pizza orders in files to managing kitchen workflows with event sourcing, the framework adapts to your pizzeria's needs.</p> <p>Let's explore how to store orders, manage inventory, and track kitchen operations using different persistence strategies.</p>"},{"location":"features/data-access/#overview","title":"\ud83c\udfaf Overview","text":"<p>The pizzeria data access system provides:</p> <ul> <li>Repository Pattern: Unified interface for orders, pizzas, and customer data</li> <li>Multiple Storage Backends: File-based (development), MongoDB (production), Event Store (kitchen events)</li> <li>Event Sourcing: Complete order lifecycle tracking with EventStoreDB</li> <li>CQRS Support: Separate read models for menus and write models for orders</li> <li>Query Abstractions: Find orders by status, customer, or time period</li> <li>Unit of Work: Transaction management across order processing</li> </ul>"},{"location":"features/data-access/#core-abstractions","title":"\ud83c\udfd7\ufe0f Core Abstractions","text":""},{"location":"features/data-access/#repository-interface-for-pizzeria-entities","title":"Repository Interface for Pizzeria Entities","text":"<p>The base repository interface defines standard CRUD operations for pizzeria data:</p> <pre><code>from abc import ABC, abstractmethod\nfrom typing import Generic, TypeVar, List, Optional\nfrom datetime import datetime, date\n\nTEntity = TypeVar('TEntity')\nTKey = TypeVar('TKey')\n\nclass Repository(Generic[TEntity, TKey], ABC):\n    \"\"\"Base repository interface for pizzeria entities\"\"\"\n\n    @abstractmethod\n    async def get_by_id_async(self, id: TKey) -&gt; Optional[TEntity]:\n        \"\"\"Get entity by ID (order, pizza, customer)\"\"\"\n        pass\n\n    @abstractmethod\n    async def save_async(self, entity: TEntity) -&gt; None:\n        \"\"\"Save entity (create or update)\"\"\"\n        pass\n\n    @abstractmethod\n    async def delete_async(self, id: TKey) -&gt; None:\n        \"\"\"Delete entity by ID\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_all_async(self) -&gt; List[TEntity]:\n        \"\"\"Get all entities\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_async(self, predicate) -&gt; List[TEntity]:\n        \"\"\"Find entities matching predicate\"\"\"\n        pass\n\n# Pizzeria-specific repository interfaces\nclass IOrderRepository(Repository[Order, str], ABC):\n    \"\"\"Order-specific repository operations\"\"\"\n\n    @abstractmethod\n    async def get_by_customer_phone_async(self, phone: str) -&gt; List[Order]:\n        \"\"\"Get orders by customer phone number\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_by_status_async(self, status: str) -&gt; List[Order]:\n        \"\"\"Get orders by status (pending, cooking, ready, delivered)\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_by_date_range_async(self, start_date: date, end_date: date) -&gt; List[Order]:\n        \"\"\"Get orders within date range for reports\"\"\"\n        pass\n\nclass IPizzaRepository(Repository[Pizza, str], ABC):\n    \"\"\"Pizza menu repository operations\"\"\"\n\n    @abstractmethod\n    async def get_by_category_async(self, category: str) -&gt; List[Pizza]:\n        \"\"\"Get pizzas by category (signature, specialty, custom)\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_available_async(self) -&gt; List[Pizza]:\n        \"\"\"Get only available pizzas (not sold out)\"\"\"\n        pass\n</code></pre> <pre><code>from neuroglia.data.abstractions import Queryable\nfrom typing import Callable\nfrom decimal import Decimal\n\nclass QueryablePizzeriaRepository(Repository[TEntity, TKey], Queryable[TEntity]):\n    \"\"\"Repository with advanced querying for pizzeria analytics\"\"\"\n\n    async def where(self, predicate: Callable[[TEntity], bool]) -&gt; List[TEntity]:\n        \"\"\"Filter pizzeria entities by predicate\"\"\"\n        pass\n\n    async def order_by_desc(self, selector: Callable[[TEntity], any]) -&gt; List[TEntity]:\n        \"\"\"Order entities in descending order\"\"\"\n        pass\n\n    async def group_by(self, selector: Callable[[TEntity], any]) -&gt; dict:\n        \"\"\"Group entities for analytics\"\"\"\n        pass\n\n# Example: Advanced order queries\nclass ExtendedOrderRepository(IOrderRepository, QueryablePizzeriaRepository[Order, str]):\n    \"\"\"Order repository with advanced analytics queries\"\"\"\n\n    async def get_top_customers_async(self, limit: int = 10) -&gt; List[dict]:\n        \"\"\"Get top customers by order count\"\"\"\n        orders = await self.get_all_async()\n        customer_counts = {}\n\n        for order in orders:\n            phone = order.customer_phone\n            customer_counts[phone] = customer_counts.get(phone, 0) + 1\n\n        # Sort and limit\n        top_customers = sorted(customer_counts.items(), key=lambda x: x[1], reverse=True)[:limit]\n\n        return [{\"phone\": phone, \"order_count\": count} for phone, count in top_customers]\n\n    async def get_revenue_by_date_async(self, start_date: date, end_date: date) -&gt; List[dict]:\n        \"\"\"Get daily revenue within date range\"\"\"\n        orders = await self.get_by_date_range_async(start_date, end_date)\n        daily_revenue = {}\n\n        for order in orders:\n            order_date = order.order_time.date()\n            if order_date not in daily_revenue:\n                daily_revenue[order_date] = Decimal('0')\n            daily_revenue[order_date] += order.total_amount\n\n        return [{\"date\": date, \"revenue\": revenue} for date, revenue in sorted(daily_revenue.items())]\n</code></pre>"},{"location":"features/data-access/#file-based-storage-for-development","title":"\ud83d\udcc1 File-Based Storage for Development","text":""},{"location":"features/data-access/#file-repository-implementation","title":"File Repository Implementation","text":"<p>Perfect for development and testing of Mario's Pizzeria:</p> <pre><code>import json\nimport os\nfrom pathlib import Path\nfrom typing import List, Optional, Callable\nfrom datetime import datetime, date\n\nclass FileRepository(Repository[TEntity, TKey]):\n    \"\"\"File-based repository using JSON storage\"\"\"\n\n    def __init__(self, entity_type: type, data_dir: str = \"data\"):\n        self.entity_type = entity_type\n        self.entity_name = entity_type.__name__.lower()\n        self.data_dir = Path(data_dir)\n        self.entity_dir = self.data_dir / self.entity_name\n\n        # Ensure directories exist\n        self.entity_dir.mkdir(parents=True, exist_ok=True)\n\n    async def get_by_id_async(self, id: TKey) -&gt; Optional[TEntity]:\n        \"\"\"Get entity from JSON file\"\"\"\n        file_path = self.entity_dir / f\"{id}.json\"\n\n        if not file_path.exists():\n            return None\n\n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                data = json.load(f)\n                return self._dict_to_entity(data)\n        except Exception as e:\n            raise StorageException(f\"Failed to load {self.entity_name} {id}: {e}\")\n\n    async def save_async(self, entity: TEntity) -&gt; None:\n        \"\"\"Save entity to JSON file\"\"\"\n        file_path = self.entity_dir / f\"{entity.id}.json\"\n\n        try:\n            data = self._entity_to_dict(entity)\n            with open(file_path, 'w', encoding='utf-8') as f:\n                json.dump(data, f, indent=2, default=self._json_serializer, ensure_ascii=False)\n        except Exception as e:\n            raise StorageException(f\"Failed to save {self.entity_name} {entity.id}: {e}\")\n\n    async def delete_async(self, id: TKey) -&gt; None:\n        \"\"\"Delete entity JSON file\"\"\"\n        file_path = self.entity_dir / f\"{id}.json\"\n        if file_path.exists():\n            file_path.unlink()\n\n    async def get_all_async(self) -&gt; List[TEntity]:\n        \"\"\"Get all entities from JSON files\"\"\"\n        entities = []\n\n        for file_path in self.entity_dir.glob(\"*.json\"):\n            try:\n                with open(file_path, 'r', encoding='utf-8') as f:\n                    data = json.load(f)\n                    entity = self._dict_to_entity(data)\n                    entities.append(entity)\n            except Exception as e:\n                print(f\"Warning: Failed to load {file_path}: {e}\")\n                continue\n\n        return entities\n\n    async def find_async(self, predicate: Callable[[TEntity], bool]) -&gt; List[TEntity]:\n        \"\"\"Find entities matching predicate\"\"\"\n        all_entities = await self.get_all_async()\n        return [entity for entity in all_entities if predicate(entity)]\n\n    def _entity_to_dict(self, entity: TEntity) -&gt; dict:\n        \"\"\"Convert entity to dictionary for JSON serialization\"\"\"\n        if hasattr(entity, '__dict__'):\n            return entity.__dict__.copy()\n        elif hasattr(entity, '_asdict'):\n            return entity._asdict()\n        else:\n            raise ValueError(f\"Cannot serialize entity of type {type(entity)}\")\n\n    def _dict_to_entity(self, data: dict) -&gt; TEntity:\n        \"\"\"Convert dictionary back to entity\"\"\"\n        return self.entity_type(**data)\n\n    def _json_serializer(self, obj):\n        \"\"\"Handle special types in JSON serialization\"\"\"\n        if isinstance(obj, (datetime, date)):\n            return obj.isoformat()\n        elif hasattr(obj, '__dict__'):\n            return obj.__dict__\n        else:\n            return str(obj)\n\n# Pizzeria-specific file repositories\nclass FileOrderRepository(FileRepository[Order, str], IOrderRepository):\n    \"\"\"File-based order repository for development\"\"\"\n\n    def __init__(self, data_dir: str = \"data\"):\n        super().__init__(Order, data_dir)\n\n    async def get_by_customer_phone_async(self, phone: str) -&gt; List[Order]:\n        \"\"\"Get orders by customer phone\"\"\"\n        return await self.find_async(lambda order: order.customer_phone == phone)\n\n    async def get_by_status_async(self, status: str) -&gt; List[Order]:\n        \"\"\"Get orders by status\"\"\"\n        return await self.find_async(lambda order: order.status == status)\n\n    async def get_by_date_range_async(self, start_date: date, end_date: date) -&gt; List[Order]:\n        \"\"\"Get orders within date range\"\"\"\n        return await self.find_async(lambda order:\n            start_date &lt;= order.order_time.date() &lt;= end_date)\n\nclass FilePizzaRepository(FileRepository[Pizza, str], IPizzaRepository):\n    \"\"\"File-based pizza repository for menu management\"\"\"\n\n    def __init__(self, data_dir: str = \"data\"):\n        super().__init__(Pizza, data_dir)\n\n    async def get_by_category_async(self, category: str) -&gt; List[Pizza]:\n        \"\"\"Get pizzas by category\"\"\"\n        return await self.find_async(lambda pizza: pizza.category == category)\n\n    async def get_available_async(self) -&gt; List[Pizza]:\n        \"\"\"Get available pizzas only\"\"\"\n        return await self.find_async(lambda pizza: pizza.is_available)\n</code></pre>"},{"location":"features/data-access/#mongodb-repository-for-pizzeria","title":"MongoDB Repository for Pizzeria","text":"<p>Built-in MongoDB repository implementation for production pizzeria:</p> <pre><code>from neuroglia.data.infrastructure.mongo import MongoRepository\nfrom motor.motor_asyncio import AsyncIOMotorClient, AsyncIOMotorDatabase\nfrom bson import ObjectId\nfrom typing import Optional, List, Dict, Any\n\nclass MongoOrderRepository(MongoRepository[Order, str], IOrderRepository):\n    \"\"\"MongoDB repository for pizza orders\"\"\"\n\n    def __init__(self, database: AsyncIOMotorDatabase):\n        super().__init__(database, \"orders\")\n\n    async def get_by_customer_phone_async(self, phone: str) -&gt; List[Order]:\n        \"\"\"Get orders by customer phone with index optimization\"\"\"\n        cursor = self.collection.find({\"customer_phone\": phone}).sort(\"order_time\", -1)\n        documents = await cursor.to_list(length=None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def get_by_status_async(self, status: str) -&gt; List[Order]:\n        \"\"\"Get orders by status for kitchen management\"\"\"\n        cursor = self.collection.find({\"status\": status}).sort(\"order_time\", 1)  # FIFO\n        documents = await cursor.to_list(length=None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def get_by_date_range_async(self, start_date: date, end_date: date) -&gt; List[Order]:\n        \"\"\"Get orders within date range for reporting\"\"\"\n        start_datetime = datetime.combine(start_date, datetime.min.time())\n        end_datetime = datetime.combine(end_date, datetime.max.time())\n\n        cursor = self.collection.find({\n            \"order_time\": {\n                \"$gte\": start_datetime,\n                \"$lte\": end_datetime\n            }\n        }).sort(\"order_time\", 1)\n\n        documents = await cursor.to_list(length=None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def get_kitchen_queue_async(self, statuses: List[str]) -&gt; List[Order]:\n        \"\"\"Get orders in kitchen queue (optimized for kitchen display)\"\"\"\n        cursor = self.collection.find(\n            {\"status\": {\"$in\": statuses}},\n            {\"customer_name\": 1, \"pizzas\": 1, \"order_time\": 1, \"status\": 1, \"estimated_ready_time\": 1}\n        ).sort(\"order_time\", 1)\n\n        documents = await cursor.to_list(length=None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def get_daily_revenue_async(self, target_date: date) -&gt; Dict[str, Any]:\n        \"\"\"Get daily revenue aggregation\"\"\"\n        start_datetime = datetime.combine(target_date, datetime.min.time())\n        end_datetime = datetime.combine(target_date, datetime.max.time())\n\n        pipeline = [\n            {\n                \"$match\": {\n                    \"order_time\": {\"$gte\": start_datetime, \"$lte\": end_datetime},\n                    \"status\": {\"$in\": [\"ready\", \"delivered\"]}  # Only completed orders\n                }\n            },\n            {\n                \"$group\": {\n                    \"_id\": None,\n                    \"total_revenue\": {\"$sum\": \"$total_amount\"},\n                    \"order_count\": {\"$sum\": 1},\n                    \"average_order_value\": {\"$avg\": \"$total_amount\"}\n                }\n            }\n        ]\n\n        result = await self.collection.aggregate(pipeline).to_list(length=1)\n        return result[0] if result else {\"total_revenue\": 0, \"order_count\": 0, \"average_order_value\": 0}\n\n    def _entity_to_document(self, order: Order) -&gt; Dict[str, Any]:\n        \"\"\"Convert order entity to MongoDB document\"\"\"\n        doc = {\n            \"_id\": order.id,\n            \"customer_name\": order.customer_name,\n            \"customer_phone\": order.customer_phone,\n            \"customer_address\": order.customer_address,\n            \"pizzas\": [self._pizza_to_dict(pizza) for pizza in order.pizzas],\n            \"status\": order.status,\n            \"order_time\": order.order_time,\n            \"estimated_ready_time\": order.estimated_ready_time,\n            \"total_amount\": float(order.total_amount),  # MongoDB decimal handling\n            \"payment_method\": order.payment_method\n        }\n        return doc\n\n    def _document_to_entity(self, doc: Dict[str, Any]) -&gt; Order:\n        \"\"\"Convert MongoDB document to order entity\"\"\"\n        return Order(\n            id=doc[\"_id\"],\n            customer_name=doc[\"customer_name\"],\n            customer_phone=doc[\"customer_phone\"],\n            customer_address=doc[\"customer_address\"],\n            pizzas=[self._dict_to_pizza(pizza_dict) for pizza_dict in doc[\"pizzas\"]],\n            status=doc[\"status\"],\n            order_time=doc[\"order_time\"],\n            estimated_ready_time=doc.get(\"estimated_ready_time\"),\n            total_amount=Decimal(str(doc[\"total_amount\"])),\n            payment_method=doc.get(\"payment_method\", \"cash\")\n        )\n\nclass MongoPizzaRepository(MongoRepository[Pizza, str], IPizzaRepository):\n    \"\"\"MongoDB repository for pizza menu management\"\"\"\n\n    def __init__(self, database: AsyncIOMotorDatabase):\n        super().__init__(database, \"pizzas\")\n\n    async def get_by_category_async(self, category: str) -&gt; List[Pizza]:\n        \"\"\"Get pizzas by category with caching optimization\"\"\"\n        cursor = self.collection.find({\"category\": category, \"is_available\": True}).sort(\"name\", 1)\n        documents = await cursor.to_list(length=None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def get_available_async(self) -&gt; List[Pizza]:\n        \"\"\"Get all available pizzas for menu display\"\"\"\n        cursor = self.collection.find({\"is_available\": True}).sort([(\"category\", 1), (\"name\", 1)])\n        documents = await cursor.to_list(length=None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def update_availability_async(self, pizza_id: str, is_available: bool) -&gt; None:\n        \"\"\"Update pizza availability (for sold out items)\"\"\"\n        await self.collection.update_one(\n            {\"_id\": pizza_id},\n            {\"$set\": {\"is_available\": is_available, \"updated_at\": datetime.utcnow()}}\n        )\n\n    def _entity_to_document(self, pizza: Pizza) -&gt; Dict[str, Any]:\n        \"\"\"Convert pizza entity to MongoDB document\"\"\"\n        return {\n            \"_id\": pizza.id,\n            \"name\": pizza.name,\n            \"description\": pizza.description,\n            \"category\": pizza.category,\n            \"base_price\": float(pizza.base_price),\n            \"available_toppings\": pizza.available_toppings,\n            \"preparation_time_minutes\": pizza.preparation_time_minutes,\n            \"is_available\": pizza.is_available,\n            \"is_seasonal\": pizza.is_seasonal,\n            \"created_at\": pizza.created_at,\n            \"updated_at\": datetime.utcnow()\n        }\n</code></pre>"},{"location":"features/data-access/#mongodb-indexes-for-performance","title":"MongoDB Indexes for Performance","text":"<p>Create indexes for pizzeria query patterns:</p> <pre><code># Create indexes for optimal pizzeria query performance\nasync def create_pizzeria_indexes():\n    \"\"\"Create MongoDB indexes for pizzeria collections\"\"\"\n\n    # Order collection indexes\n    await orders_collection.create_index(\"customer_phone\")  # Customer lookup\n    await orders_collection.create_index(\"status\")  # Kitchen filtering\n    await orders_collection.create_index(\"order_time\")  # Chronological ordering\n    await orders_collection.create_index([(\"status\", 1), (\"order_time\", 1)])  # Kitchen queue\n    await orders_collection.create_index([(\"order_time\", -1)])  # Recent orders first\n    await orders_collection.create_index(\"estimated_ready_time\")  # Ready time tracking\n\n    # Pizza collection indexes\n    await pizzas_collection.create_index(\"category\")  # Menu category filtering\n    await pizzas_collection.create_index(\"is_available\")  # Available items only\n    await pizzas_collection.create_index([(\"category\", 1), (\"name\", 1)])  # Sorted menu display\n    await pizzas_collection.create_index(\"is_seasonal\")  # Seasonal items management\n</code></pre>"},{"location":"features/data-access/#repository-registration-with-mongodb","title":"Repository Registration with MongoDB","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\n\ndef create_pizzeria_app():\n    \"\"\"Create Mario's Pizzeria application with MongoDB persistence\"\"\"\n    builder = WebApplicationBuilder()\n\n    # MongoDB configuration\n    mongo_client = AsyncIOMotorClient(\"mongodb://localhost:27017\")\n    database = mongo_client.marios_pizzeria\n\n    # Repository registration\n    builder.services.add_singleton(lambda: database)\n    builder.services.add_scoped(MongoOrderRepository)\n    builder.services.add_scoped(MongoPizzaRepository)\n\n    # Alias interfaces to implementations\n    builder.services.add_scoped(IOrderRepository, lambda sp: sp.get_service(MongoOrderRepository))\n    builder.services.add_scoped(IPizzaRepository, lambda sp: sp.get_service(MongoPizzaRepository))\n\n    app = builder.build()\n    return app\n</code></pre>"},{"location":"features/data-access/#event-sourcing-for-kitchen-workflow","title":"\ud83d\udcca Event Sourcing for Kitchen Workflow","text":""},{"location":"features/data-access/#kitchen-event-store","title":"Kitchen Event Store","text":"<p>Track kitchen workflow with event sourcing patterns:</p> <pre><code>from neuroglia.eventing import DomainEvent\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any\nfrom dataclasses import dataclass\n\n@dataclass\nclass OrderStatusChangedEvent(DomainEvent):\n    \"\"\"Event for tracking order status changes in kitchen\"\"\"\n    order_id: str\n    old_status: str\n    new_status: str\n    changed_by: str\n    change_reason: Optional[str] = None\n    estimated_ready_time: Optional[datetime] = None\n\n@dataclass\nclass PizzaStartedEvent(DomainEvent):\n    \"\"\"Event when pizza preparation begins\"\"\"\n    order_id: str\n    pizza_name: str\n    pizza_index: int\n    started_by: str\n    estimated_completion: datetime\n\n@dataclass\nclass PizzaCompletedEvent(DomainEvent):\n    \"\"\"Event when pizza is finished\"\"\"\n    order_id: str\n    pizza_name: str\n    pizza_index: int\n    completed_by: str\n    actual_completion_time: datetime\n    preparation_duration_minutes: int\n\nclass KitchenWorkflowEventStore:\n    \"\"\"Event store for kitchen workflow tracking\"\"\"\n\n    def __init__(self, event_repository: IEventRepository):\n        self.event_repository = event_repository\n\n    async def record_order_status_change(self,\n                                         order_id: str,\n                                         old_status: str,\n                                         new_status: str,\n                                         changed_by: str,\n                                         change_reason: str = None) -&gt; None:\n        \"\"\"Record order status changes for kitchen analytics\"\"\"\n        event = OrderStatusChangedEvent(\n            order_id=order_id,\n            old_status=old_status,\n            new_status=new_status,\n            changed_by=changed_by,\n            change_reason=change_reason,\n            estimated_ready_time=self._calculate_ready_time(new_status)\n        )\n\n        await self.event_repository.save_event_async(event)\n\n    async def record_pizza_started(self,\n                                   order_id: str,\n                                   pizza_name: str,\n                                   pizza_index: int,\n                                   started_by: str) -&gt; None:\n        \"\"\"Record when pizza preparation begins\"\"\"\n        estimated_completion = datetime.now(timezone.utc) + timedelta(\n            minutes=self._get_pizza_prep_time(pizza_name)\n        )\n\n        event = PizzaStartedEvent(\n            order_id=order_id,\n            pizza_name=pizza_name,\n            pizza_index=pizza_index,\n            started_by=started_by,\n            estimated_completion=estimated_completion\n        )\n\n        await self.event_repository.save_event_async(event)\n\n    async def record_pizza_completed(self,\n                                     order_id: str,\n                                     pizza_name: str,\n                                     pizza_index: int,\n                                     completed_by: str,\n                                     start_time: datetime) -&gt; None:\n        \"\"\"Record when pizza is completed\"\"\"\n        completion_time = datetime.now(timezone.utc)\n        duration_minutes = int((completion_time - start_time).total_seconds() / 60)\n\n        event = PizzaCompletedEvent(\n            order_id=order_id,\n            pizza_name=pizza_name,\n            pizza_index=pizza_index,\n            completed_by=completed_by,\n            actual_completion_time=completion_time,\n            preparation_duration_minutes=duration_minutes\n        )\n\n        await self.event_repository.save_event_async(event)\n\n    async def get_kitchen_performance_metrics(self, date_range: tuple[date, date]) -&gt; Dict[str, Any]:\n        \"\"\"Get kitchen performance analytics from events\"\"\"\n        start_date, end_date = date_range\n\n        # Query events within date range\n        events = await self.event_repository.get_events_by_date_range_async(start_date, end_date)\n\n        # Calculate metrics\n        pizza_completion_events = [e for e in events if isinstance(e, PizzaCompletedEvent)]\n        status_change_events = [e for e in events if isinstance(e, OrderStatusChangedEvent)]\n\n        return {\n            \"total_pizzas_completed\": len(pizza_completion_events),\n            \"average_prep_time_minutes\": self._calculate_average_prep_time(pizza_completion_events),\n            \"peak_hours\": self._calculate_peak_hours(status_change_events),\n            \"order_completion_rate\": self._calculate_completion_rate(status_change_events),\n            \"staff_performance\": self._calculate_staff_performance(pizza_completion_events)\n        }\n</code></pre> <pre><code>from neuroglia.data import Repository\nfrom typing import List, Dict, Any\nimport json\nfrom pathlib import Path\nfrom datetime import datetime\n\nclass FileEventRepository(Repository[DomainEvent, str]):\n    \"\"\"File-based event repository for development and testing\"\"\"\n\n    def __init__(self, events_directory: str = \"data/events\"):\n        super().__init__()\n        self.events_directory = Path(events_directory)\n        self.events_directory.mkdir(parents=True, exist_ok=True)\n\n    async def save_event_async(self, event: DomainEvent) -&gt; None:\n        \"\"\"Save event to JSON file organized by date\"\"\"\n        event_date = event.occurred_at.date()\n        date_directory = self.events_directory / event_date.strftime(\"%Y-%m-%d\")\n        date_directory.mkdir(exist_ok=True)\n\n        event_file = date_directory / f\"{event.id}.json\"\n\n        event_data = {\n            \"id\": event.id,\n            \"event_type\": event.__class__.__name__,\n            \"occurred_at\": event.occurred_at.isoformat(),\n            \"data\": self._serialize_event_data(event)\n        }\n\n        async with aiofiles.open(event_file, 'w') as f:\n            await f.write(json.dumps(event_data, indent=2))\n\n    async def get_events_by_date_range_async(self,\n                                             start_date: date,\n                                             end_date: date) -&gt; List[DomainEvent]:\n        \"\"\"Get events within date range\"\"\"\n        events = []\n        current_date = start_date\n\n        while current_date &lt;= end_date:\n            date_directory = self.events_directory / current_date.strftime(\"%Y-%m-%d\")\n\n            if date_directory.exists():\n                for event_file in date_directory.glob(\"*.json\"):\n                    async with aiofiles.open(event_file, 'r') as f:\n                        event_data = json.loads(await f.read())\n                        event = self._deserialize_event(event_data)\n                        if event:\n                            events.append(event)\n\n            current_date += timedelta(days=1)\n\n        return sorted(events, key=lambda e: e.occurred_at)\n</code></pre>"},{"location":"features/data-access/#mongodb-event-store","title":"MongoDB Event Store","text":"<p>Production event store with aggregation capabilities:</p> <pre><code>from neuroglia.data.infrastructure.mongo import MongoRepository\nfrom motor.motor_asyncio import AsyncIOMotorDatabase\n\nclass MongoEventRepository(MongoRepository[DomainEvent, str]):\n    \"\"\"MongoDB event repository for production event sourcing\"\"\"\n\n    def __init__(self, database: AsyncIOMotorDatabase):\n        super().__init__(database, \"events\")\n\n    async def save_event_async(self, event: DomainEvent) -&gt; None:\n        \"\"\"Save event with automatic indexing\"\"\"\n        document = {\n            \"_id\": event.id,\n            \"event_type\": event.__class__.__name__,\n            \"occurred_at\": event.occurred_at,\n            \"data\": self._serialize_event_data(event),\n            \"version\": 1,\n            \"metadata\": {\n                \"correlation_id\": getattr(event, 'correlation_id', None),\n                \"causation_id\": getattr(event, 'causation_id', None)\n            }\n        }\n\n        await self.collection.insert_one(document)\n\n    async def get_kitchen_timeline_events(self,\n                                          order_id: str,\n                                          limit: int = 100) -&gt; List[DomainEvent]:\n        \"\"\"Get chronological timeline of kitchen events for an order\"\"\"\n        cursor = self.collection.find(\n            {\n                \"event_type\": {\"$in\": [\"OrderStatusChangedEvent\", \"PizzaStartedEvent\", \"PizzaCompletedEvent\"]},\n                \"data.order_id\": order_id\n            }\n        ).sort(\"occurred_at\", 1).limit(limit)\n\n        documents = await cursor.to_list(length=limit)\n        return [self._deserialize_event(doc) for doc in documents]\n\n    async def get_performance_aggregation(self,\n                                          start_date: datetime,\n                                          end_date: datetime) -&gt; Dict[str, Any]:\n        \"\"\"Get aggregated kitchen performance metrics\"\"\"\n        pipeline = [\n            {\n                \"$match\": {\n                    \"occurred_at\": {\"$gte\": start_date, \"$lte\": end_date},\n                    \"event_type\": \"PizzaCompletedEvent\"\n                }\n            },\n            {\n                \"$group\": {\n                    \"_id\": \"$data.pizza_name\",\n                    \"total_pizzas\": {\"$sum\": 1},\n                    \"avg_prep_time\": {\"$avg\": \"$data.preparation_duration_minutes\"},\n                    \"min_prep_time\": {\"$min\": \"$data.preparation_duration_minutes\"},\n                    \"max_prep_time\": {\"$max\": \"$data.preparation_duration_minutes\"}\n                }\n            },\n            {\n                \"$sort\": {\"total_pizzas\": -1}\n            }\n        ]\n\n        results = await self.collection.aggregate(pipeline).to_list(length=None)\n        return {\n            \"pizza_performance\": results,\n            \"reporting_period\": {\n                \"start\": start_date.isoformat(),\n                \"end\": end_date.isoformat()\n            }\n        }\n</code></pre> <pre><code>from neuroglia.data import IQueryableRepository\nfrom typing import List, Dict, Any, Optional\nfrom datetime import datetime, date, timedelta\n\nclass IAnalyticsRepository(IQueryableRepository[Order, str]):\n    \"\"\"Enhanced queryable interface for pizzeria analytics\"\"\"\n\n    async def get_revenue_by_period_async(self,\n                                          period: str,  # 'daily', 'weekly', 'monthly'\n                                          start_date: date,\n                                          end_date: date) -&gt; Dict[str, Any]:\n        \"\"\"Get revenue metrics grouped by time period\"\"\"\n        pass\n\n    async def get_popular_pizzas_async(self,\n                                       start_date: date,\n                                       end_date: date,\n                                       limit: int = 10) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get most popular pizzas by order count\"\"\"\n        pass\n\n    async def get_customer_insights_async(self,\n                                          customer_phone: str) -&gt; Dict[str, Any]:\n        \"\"\"Get customer ordering patterns and preferences\"\"\"\n        pass\n\n    async def get_peak_hours_analysis_async(self,\n                                            date_range: tuple[date, date]) -&gt; Dict[str, Any]:\n        \"\"\"Analyze order patterns by hour of day\"\"\"\n        pass\n\nclass MongoAnalyticsRepository(MongoOrderRepository, IAnalyticsRepository):\n    \"\"\"MongoDB implementation with advanced analytics capabilities\"\"\"\n\n    async def get_revenue_by_period_async(self,\n                                          period: str,\n                                          start_date: date,\n                                          end_date: date) -&gt; Dict[str, Any]:\n        \"\"\"Get revenue metrics with MongoDB aggregation\"\"\"\n        start_datetime = datetime.combine(start_date, datetime.min.time())\n        end_datetime = datetime.combine(end_date, datetime.max.time())\n\n        # Dynamic grouping based on period\n        group_format = {\n            'daily': {\"$dateToString\": {\"format\": \"%Y-%m-%d\", \"date\": \"$order_time\"}},\n            'weekly': {\"$dateToString\": {\"format\": \"%Y-W%U\", \"date\": \"$order_time\"}},\n            'monthly': {\"$dateToString\": {\"format\": \"%Y-%m\", \"date\": \"$order_time\"}}\n        }\n\n        pipeline = [\n            {\n                \"$match\": {\n                    \"order_time\": {\"$gte\": start_datetime, \"$lte\": end_datetime},\n                    \"status\": {\"$in\": [\"ready\", \"delivered\"]}\n                }\n            },\n            {\n                \"$group\": {\n                    \"_id\": group_format.get(period, group_format['daily']),\n                    \"revenue\": {\"$sum\": \"$total_amount\"},\n                    \"order_count\": {\"$sum\": 1},\n                    \"average_order_value\": {\"$avg\": \"$total_amount\"}\n                }\n            },\n            {\n                \"$sort\": {\"_id\": 1}\n            }\n        ]\n\n        results = await self.collection.aggregate(pipeline).to_list(length=None)\n\n        return {\n            \"period\": period,\n            \"data\": results,\n            \"summary\": {\n                \"total_revenue\": sum(r[\"revenue\"] for r in results),\n                \"total_orders\": sum(r[\"order_count\"] for r in results),\n                \"periods_analyzed\": len(results)\n            }\n        }\n\n    async def get_popular_pizzas_async(self,\n                                       start_date: date,\n                                       end_date: date,\n                                       limit: int = 10) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get most popular pizzas with detailed analytics\"\"\"\n        start_datetime = datetime.combine(start_date, datetime.min.time())\n        end_datetime = datetime.combine(end_date, datetime.max.time())\n\n        pipeline = [\n            {\n                \"$match\": {\n                    \"order_time\": {\"$gte\": start_datetime, \"$lte\": end_datetime},\n                    \"status\": {\"$in\": [\"ready\", \"delivered\"]}\n                }\n            },\n            {\n                \"$unwind\": \"$pizzas\"\n            },\n            {\n                \"$group\": {\n                    \"_id\": \"$pizzas.name\",\n                    \"order_count\": {\"$sum\": 1},\n                    \"total_revenue\": {\"$sum\": \"$pizzas.price\"},\n                    \"avg_price\": {\"$avg\": \"$pizzas.price\"},\n                    \"unique_customers\": {\"$addToSet\": \"$customer_phone\"}\n                }\n            },\n            {\n                \"$project\": {\n                    \"pizza_name\": \"$_id\",\n                    \"order_count\": 1,\n                    \"total_revenue\": 1,\n                    \"avg_price\": 1,\n                    \"unique_customers\": {\"$size\": \"$unique_customers\"},\n                    \"_id\": 0\n                }\n            },\n            {\n                \"$sort\": {\"order_count\": -1}\n            },\n            {\n                \"$limit\": limit\n            }\n        ]\n\n        return await self.collection.aggregate(pipeline).to_list(length=limit)\n\n    async def get_customer_insights_async(self,\n                                          customer_phone: str) -&gt; Dict[str, Any]:\n        \"\"\"Comprehensive customer analytics\"\"\"\n        pipeline = [\n            {\n                \"$match\": {\"customer_phone\": customer_phone}\n            },\n            {\n                \"$group\": {\n                    \"_id\": \"$customer_phone\",\n                    \"total_orders\": {\"$sum\": 1},\n                    \"total_spent\": {\"$sum\": \"$total_amount\"},\n                    \"avg_order_value\": {\"$avg\": \"$total_amount\"},\n                    \"first_order\": {\"$min\": \"$order_time\"},\n                    \"last_order\": {\"$max\": \"$order_time\"},\n                    \"favorite_pizzas\": {\"$push\": \"$pizzas.name\"},\n                    \"payment_methods\": {\"$addToSet\": \"$payment_method\"}\n                }\n            },\n            {\n                \"$project\": {\n                    \"customer_phone\": \"$_id\",\n                    \"total_orders\": 1,\n                    \"total_spent\": 1,\n                    \"avg_order_value\": 1,\n                    \"first_order\": 1,\n                    \"last_order\": 1,\n                    \"customer_lifetime_days\": {\n                        \"$divide\": [\n                            {\"$subtract\": [\"$last_order\", \"$first_order\"]},\n                            86400000  # milliseconds to days\n                        ]\n                    },\n                    \"payment_methods\": 1,\n                    \"_id\": 0\n                }\n            }\n        ]\n\n        results = await self.collection.aggregate(pipeline).to_list(length=1)\n        if not results:\n            return {\"error\": \"Customer not found\"}\n\n        customer_data = results[0]\n\n        # Calculate favorite pizza (most frequent)\n        # This would need additional aggregation pipeline for pizza frequency\n\n        return customer_data\n\n    async def get_peak_hours_analysis_async(self,\n                                            date_range: tuple[date, date]) -&gt; Dict[str, Any]:\n        \"\"\"Analyze order patterns by hour for staffing optimization\"\"\"\n        start_date, end_date = date_range\n        start_datetime = datetime.combine(start_date, datetime.min.time())\n        end_datetime = datetime.combine(end_date, datetime.max.time())\n\n        pipeline = [\n            {\n                \"$match\": {\n                    \"order_time\": {\"$gte\": start_datetime, \"$lte\": end_datetime}\n                }\n            },\n            {\n                \"$group\": {\n                    \"_id\": {\"$hour\": \"$order_time\"},\n                    \"order_count\": {\"$sum\": 1},\n                    \"total_revenue\": {\"$sum\": \"$total_amount\"},\n                    \"avg_order_value\": {\"$avg\": \"$total_amount\"}\n                }\n            },\n            {\n                \"$project\": {\n                    \"hour\": \"$_id\",\n                    \"order_count\": 1,\n                    \"total_revenue\": 1,\n                    \"avg_order_value\": 1,\n                    \"_id\": 0\n                }\n            },\n            {\n                \"$sort\": {\"hour\": 1}\n            }\n        ]\n\n        results = await self.collection.aggregate(pipeline).to_list(length=24)\n\n        # Fill in missing hours with zero values\n        hourly_data = {r[\"hour\"]: r for r in results}\n        complete_data = []\n\n        for hour in range(24):\n            hour_data = hourly_data.get(hour, {\n                \"hour\": hour,\n                \"order_count\": 0,\n                \"total_revenue\": 0.0,\n                \"avg_order_value\": 0.0\n            })\n            complete_data.append(hour_data)\n\n        # Find peak hours (top 3)\n        sorted_by_orders = sorted(complete_data, key=lambda x: x[\"order_count\"], reverse=True)\n        peak_hours = sorted_by_orders[:3]\n\n        return {\n            \"hourly_breakdown\": complete_data,\n            \"peak_hours\": peak_hours,\n            \"analysis_period\": {\n                \"start_date\": start_date.isoformat(),\n                \"end_date\": end_date.isoformat()\n            }\n        }\n</code></pre> <pre><code>import pytest\nfrom unittest.mock import AsyncMock\nfrom datetime import datetime, date, timedelta\nfrom decimal import Decimal\n\nclass TestOrderRepository:\n    \"\"\"Unit tests for order repository implementations\"\"\"\n\n    @pytest.fixture\n    def sample_order(self):\n        \"\"\"Create sample pizza order for testing\"\"\"\n        return Order(\n            id=\"order_123\",\n            customer_name=\"John Doe\",\n            customer_phone=\"+1234567890\",\n            customer_address=\"123 Main St\",\n            pizzas=[\n                Pizza(name=\"Margherita\", price=Decimal(\"12.99\")),\n                Pizza(name=\"Pepperoni\", price=Decimal(\"14.99\"))\n            ],\n            status=\"preparing\",\n            order_time=datetime.utcnow(),\n            total_amount=Decimal(\"27.98\"),\n            payment_method=\"card\"\n        )\n\n    @pytest.fixture\n    def mock_file_repository(self, tmp_path):\n        \"\"\"Create file repository with temporary directory\"\"\"\n        return FileOrderRepository(str(tmp_path / \"orders\"))\n\n    @pytest.mark.asyncio\n    async def test_save_order_creates_file(self, mock_file_repository, sample_order):\n        \"\"\"Test that saving an order creates proper file structure\"\"\"\n        await mock_file_repository.save_async(sample_order)\n\n        # Verify file was created\n        order_file = Path(mock_file_repository.orders_directory) / f\"{sample_order.id}.json\"\n        assert order_file.exists()\n\n        # Verify file content\n        with open(order_file, 'r') as f:\n            order_data = json.load(f)\n            assert order_data[\"customer_name\"] == sample_order.customer_name\n            assert len(order_data[\"pizzas\"]) == 2\n\n    @pytest.mark.asyncio\n    async def test_get_by_customer_phone(self, mock_file_repository, sample_order):\n        \"\"\"Test customer phone lookup functionality\"\"\"\n        await mock_file_repository.save_async(sample_order)\n\n        # Create another order for same customer\n        second_order = Order(\n            id=\"order_456\",\n            customer_name=\"John Doe\",\n            customer_phone=\"+1234567890\",\n            customer_address=\"123 Main St\",\n            pizzas=[Pizza(name=\"Hawaiian\", price=Decimal(\"15.99\"))],\n            status=\"ready\",\n            order_time=datetime.utcnow() + timedelta(hours=1)\n        )\n        await mock_file_repository.save_async(second_order)\n\n        # Test phone lookup\n        customer_orders = await mock_file_repository.get_by_customer_phone_async(\"+1234567890\")\n\n        assert len(customer_orders) == 2\n        # Should be ordered by time (most recent first)\n        assert customer_orders[0].id == \"order_456\"\n        assert customer_orders[1].id == \"order_123\"\n\n    @pytest.mark.asyncio\n    async def test_kitchen_queue_filtering(self, mock_file_repository):\n        \"\"\"Test kitchen queue status filtering\"\"\"\n        # Create orders with different statuses\n        orders = [\n            Order(id=\"order_1\", status=\"preparing\", customer_name=\"Customer 1\"),\n            Order(id=\"order_2\", status=\"cooking\", customer_name=\"Customer 2\"),\n            Order(id=\"order_3\", status=\"ready\", customer_name=\"Customer 3\"),\n            Order(id=\"order_4\", status=\"delivered\", customer_name=\"Customer 4\")\n        ]\n\n        for order in orders:\n            await mock_file_repository.save_async(order)\n\n        # Get kitchen queue (preparing and cooking)\n        kitchen_orders = await mock_file_repository.get_kitchen_queue_async([\"preparing\", \"cooking\"])\n\n        assert len(kitchen_orders) == 2\n        statuses = [order.status for order in kitchen_orders]\n        assert \"preparing\" in statuses\n        assert \"cooking\" in statuses\n        assert \"ready\" not in statuses\n\n@pytest.mark.integration\nclass TestMongoOrderRepository:\n    \"\"\"Integration tests for MongoDB repository\"\"\"\n\n    @pytest.fixture\n    async def mongo_repository(self, mongo_test_client):\n        \"\"\"Create MongoDB repository for testing\"\"\"\n        database = mongo_test_client.test_pizzeria\n        return MongoOrderRepository(database)\n\n    @pytest.mark.asyncio\n    async def test_revenue_aggregation(self, mongo_repository):\n        \"\"\"Test MongoDB revenue aggregation pipeline\"\"\"\n        # Setup test data\n        test_orders = [\n            Order(\n                id=\"order_1\",\n                total_amount=Decimal(\"25.99\"),\n                status=\"delivered\",\n                order_time=datetime(2024, 1, 15, 12, 0)\n            ),\n            Order(\n                id=\"order_2\",\n                total_amount=Decimal(\"18.50\"),\n                status=\"delivered\",\n                order_time=datetime(2024, 1, 15, 18, 0)\n            ),\n            Order(\n                id=\"order_3\",\n                total_amount=Decimal(\"32.00\"),\n                status=\"preparing\",  # Should be excluded\n                order_time=datetime(2024, 1, 15, 19, 0)\n            )\n        ]\n\n        for order in test_orders:\n            await mongo_repository.save_async(order)\n\n        # Test daily revenue calculation\n        revenue_data = await mongo_repository.get_daily_revenue_async(date(2024, 1, 15))\n\n        assert revenue_data[\"total_revenue\"] == 44.49  # Only delivered orders\n        assert revenue_data[\"order_count\"] == 2\n        assert revenue_data[\"average_order_value\"] == 22.245\n\nclass TestEventRepository:\n    \"\"\"Test event repository for kitchen workflow tracking\"\"\"\n\n    @pytest.fixture\n    def sample_kitchen_events(self):\n        \"\"\"Create sample kitchen events for testing\"\"\"\n        return [\n            OrderStatusChangedEvent(\n                order_id=\"order_123\",\n                old_status=\"received\",\n                new_status=\"preparing\",\n                changed_by=\"chef_mario\"\n            ),\n            PizzaStartedEvent(\n                order_id=\"order_123\",\n                pizza_name=\"Margherita\",\n                pizza_index=0,\n                started_by=\"chef_mario\",\n                estimated_completion=datetime.utcnow() + timedelta(minutes=12)\n            )\n        ]\n\n    @pytest.mark.asyncio\n    async def test_event_chronological_ordering(self, file_event_repository, sample_kitchen_events):\n        \"\"\"Test that events are retrieved in chronological order\"\"\"\n        # Save events in random order\n        for event in reversed(sample_kitchen_events):\n            await file_event_repository.save_event_async(event)\n\n        # Retrieve events\n        today = date.today()\n        retrieved_events = await file_event_repository.get_events_by_date_range_async(today, today)\n\n        # Should be ordered by occurrence time\n        assert len(retrieved_events) == 2\n        assert retrieved_events[0].occurred_at &lt;= retrieved_events[1].occurred_at\n\n# Test fixtures for integration testing\n@pytest.fixture\nasync def mongo_test_client():\n    \"\"\"MongoDB test client with cleanup\"\"\"\n    from motor.motor_asyncio import AsyncIOMotorClient\n\n    client = AsyncIOMotorClient(\"mongodb://localhost:27017\")\n\n    # Use test database\n    test_db = client.test_pizzeria\n\n    yield client\n\n    # Cleanup\n    await client.drop_database(\"test_pizzeria\")\n    client.close()\n\n@pytest.fixture\ndef file_event_repository(tmp_path):\n    \"\"\"File event repository with temporary storage\"\"\"\n    return FileEventRepository(str(tmp_path / \"events\"))\n</code></pre>"},{"location":"features/data-access/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started Guide - Complete pizzeria application tutorial</li> <li>CQRS &amp; Mediation - Commands and queries with pizzeria examples</li> <li>Dependency Injection - Service registration for repositories</li> <li>MVC Controllers - API endpoints using these repositories</li> <li>Source Code Naming Conventions - Repository, entity, and method naming patterns</li> </ul> <p>This documentation demonstrates data access patterns using Mario's Pizzeria as a consistent example throughout the Neuroglia framework. The patterns shown scale from simple file-based storage for development to MongoDB with advanced analytics for production use.</p>"},{"location":"features/enhanced-model-validation/","title":"\ud83d\udcca Enhanced Model Validation","text":"<p>The Neuroglia framework provides comprehensive model validation capabilities with business rule enforcement, custom validators, and sophisticated exception handling, enabling robust data integrity across all application layers with contextual validation and error reporting.</p>"},{"location":"features/enhanced-model-validation/#overview","title":"\ud83c\udfaf Overview","text":"<p>Modern applications require sophisticated validation beyond basic type checking - business rules, cross-field validation, conditional logic, and contextual constraints. The framework's enhanced validation system provides:</p> <ul> <li>Business Rule Validation: Domain-specific validation logic</li> <li>Custom Validators: Reusable validation components</li> <li>Cross-Field Validation: Dependencies between model fields</li> <li>Contextual Validation: Different rules based on context</li> <li>Rich Error Reporting: Detailed validation error messages</li> <li>Performance Optimized: Efficient validation with early termination</li> </ul>"},{"location":"features/enhanced-model-validation/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>graph TB\n    subgraph \"\ud83c\udf55 Mario's Pizzeria Models\"\n        OrderModel[Pizza Order Model]\n        CustomerModel[Customer Model]\n        MenuModel[Menu Item Model]\n        InventoryModel[Inventory Model]\n    end\n\n    subgraph \"\ud83d\udcca Enhanced Validation Layer\"\n        ValidationEngine[Validation Engine]\n        BusinessRules[Business Rule Validators]\n        CustomValidators[Custom Validators]\n        ContextValidators[Context-Aware Validators]\n    end\n\n    subgraph \"\ud83c\udfaf Validation Types\"\n        FieldValidation[Field Validation]\n        CrossFieldValidation[Cross-Field Validation]\n        ConditionalValidation[Conditional Validation]\n        BusinessLogicValidation[Business Logic Validation]\n    end\n\n    subgraph \"\ud83d\udccb Error Handling\"\n        ValidationExceptions[Validation Exceptions]\n        ErrorAggregation[Error Aggregation]\n        ContextualMessages[Contextual Messages]\n    end\n\n    OrderModel --&gt; ValidationEngine\n    CustomerModel --&gt; ValidationEngine\n    MenuModel --&gt; ValidationEngine\n    InventoryModel --&gt; ValidationEngine\n\n    ValidationEngine --&gt; BusinessRules\n    ValidationEngine --&gt; CustomValidators\n    ValidationEngine --&gt; ContextValidators\n\n    BusinessRules --&gt; FieldValidation\n    CustomValidators --&gt; CrossFieldValidation\n    ContextValidators --&gt; ConditionalValidation\n    ValidationEngine --&gt; BusinessLogicValidation\n\n    ValidationEngine --&gt; ValidationExceptions\n    ValidationExceptions --&gt; ErrorAggregation\n    ErrorAggregation --&gt; ContextualMessages\n\n    style ValidationEngine fill:#e3f2fd\n    style BusinessRules fill:#e8f5e8\n    style CustomValidators fill:#fff3e0\n    style ContextValidators fill:#f3e5f5</code></pre>"},{"location":"features/enhanced-model-validation/#basic-usage","title":"\ud83d\ude80 Basic Usage","text":""},{"location":"features/enhanced-model-validation/#service-registration","title":"Service Registration","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.validation import EnhancedModelValidator, ValidationConfig\n\ndef create_app():\n    builder = WebApplicationBuilder()\n\n    # Register enhanced model validation\n    validation_config = ValidationConfig(\n        strict_mode=True,\n        fail_fast=False,  # Collect all validation errors\n        include_field_context=True,\n        custom_error_messages=True\n    )\n\n    builder.services.add_enhanced_model_validation(validation_config)\n\n    app = builder.build()\n    return app\n</code></pre>"},{"location":"features/enhanced-model-validation/#basic-field-validation","title":"Basic Field Validation","text":"<pre><code>from neuroglia.validation import BusinessRuleValidator, ValidationContext\nfrom pydantic import BaseModel, Field, validator\nfrom typing import List, Optional\nfrom datetime import datetime, time\nfrom decimal import Decimal\n\nclass PizzaOrderModel(BaseModel):\n    \"\"\"Pizza order with comprehensive validation.\"\"\"\n\n    order_id: str = Field(..., min_length=3, max_length=20,\n                         description=\"Unique order identifier\")\n    customer_id: str = Field(..., min_length=5, max_length=50,\n                            description=\"Customer identifier\")\n\n    # Order items with business validation\n    order_items: List['OrderItemModel'] = Field(..., min_items=1, max_items=20,\n                                               description=\"Items in the order\")\n\n    # Financial fields with precision validation\n    subtotal: Decimal = Field(..., ge=0, decimal_places=2,\n                             description=\"Order subtotal\")\n    tax_amount: Decimal = Field(..., ge=0, decimal_places=2,\n                               description=\"Tax amount\")\n    delivery_fee: Decimal = Field(default=Decimal('0.00'), ge=0, decimal_places=2,\n                                 description=\"Delivery fee\")\n    total_amount: Decimal = Field(..., ge=0, decimal_places=2,\n                                 description=\"Total order amount\")\n\n    # Timing validation\n    order_placed_at: datetime = Field(..., description=\"Order placement time\")\n    requested_delivery_time: Optional[datetime] = Field(None,\n                                                       description=\"Requested delivery time\")\n\n    # Special requirements\n    special_instructions: Optional[str] = Field(None, max_length=500,\n                                              description=\"Special instructions\")\n    is_rush_order: bool = Field(default=False, description=\"Rush order flag\")\n\n    @validator('order_id')\n    def validate_order_id_format(cls, v):\n        \"\"\"Validate order ID format.\"\"\"\n        import re\n        if not re.match(r'^ORD_\\d{8}_\\d{3}$', v):\n            raise ValueError('Order ID must follow format: ORD_YYYYMMDD_XXX')\n        return v\n\n    @validator('requested_delivery_time')\n    def validate_delivery_time(cls, v, values):\n        \"\"\"Validate requested delivery time.\"\"\"\n        if v is None:\n            return v\n\n        order_placed_at = values.get('order_placed_at')\n        if order_placed_at and v &lt;= order_placed_at:\n            raise ValueError('Delivery time must be after order placement')\n\n        # Business rule: delivery must be within next 4 hours\n        if order_placed_at:\n            max_delivery_time = order_placed_at + timedelta(hours=4)\n            if v &gt; max_delivery_time:\n                raise ValueError('Delivery time cannot be more than 4 hours from now')\n\n        # Business rule: no deliveries between 2 AM and 10 AM\n        delivery_hour = v.hour\n        if 2 &lt;= delivery_hour &lt; 10:\n            raise ValueError('Deliveries not available between 2 AM and 10 AM')\n\n        return v\n\n    @validator('total_amount')\n    def validate_total_calculation(cls, v, values):\n        \"\"\"Validate total amount calculation.\"\"\"\n        subtotal = values.get('subtotal', Decimal('0'))\n        tax_amount = values.get('tax_amount', Decimal('0'))\n        delivery_fee = values.get('delivery_fee', Decimal('0'))\n\n        expected_total = subtotal + tax_amount + delivery_fee\n\n        if abs(v - expected_total) &gt; Decimal('0.01'):  # Allow 1 cent rounding difference\n            raise ValueError(\n                f'Total amount {v} does not match calculated total {expected_total}'\n            )\n\n        return v\n\n    @validator('order_items')\n    def validate_order_items_business_rules(cls, v):\n        \"\"\"Validate business rules for order items.\"\"\"\n        if not v:\n            raise ValueError('Order must contain at least one item')\n\n        # Business rule: maximum 5 of same item\n        item_counts = {}\n        for item in v:\n            key = f\"{item.menu_item_id}_{item.size}\"\n            item_counts[key] = item_counts.get(key, 0) + item.quantity\n            if item_counts[key] &gt; 5:\n                raise ValueError(f'Cannot order more than 5 of the same item: {item.item_name}')\n\n        # Business rule: rush orders limited to 3 items total\n        is_rush = any(getattr(cls, 'is_rush_order', False) for cls in [cls])\n        if is_rush and len(v) &gt; 3:\n            raise ValueError('Rush orders are limited to 3 items maximum')\n\n        return v\n\nclass OrderItemModel(BaseModel):\n    \"\"\"Individual order item with validation.\"\"\"\n\n    menu_item_id: str = Field(..., min_length=3, max_length=50)\n    item_name: str = Field(..., min_length=1, max_length=100)\n    size: str = Field(..., regex=r'^(small|medium|large|xl)$')\n    base_price: Decimal = Field(..., gt=0, decimal_places=2)\n\n    # Customizations\n    selected_toppings: List[str] = Field(default_factory=list, max_items=10)\n    removed_ingredients: List[str] = Field(default_factory=list, max_items=5)\n\n    # Quantity and pricing\n    quantity: int = Field(..., ge=1, le=10, description=\"Item quantity\")\n    toppings_price: Decimal = Field(default=Decimal('0.00'), ge=0, decimal_places=2)\n    line_total: Decimal = Field(..., ge=0, decimal_places=2)\n\n    @validator('selected_toppings')\n    def validate_toppings(cls, v):\n        \"\"\"Validate topping selections.\"\"\"\n        if len(v) != len(set(v)):\n            raise ValueError('Duplicate toppings are not allowed')\n\n        # Business rule: premium toppings limit\n        premium_toppings = ['truffle', 'caviar', 'gold_flakes']\n        premium_count = sum(1 for topping in v if topping in premium_toppings)\n        if premium_count &gt; 2:\n            raise ValueError('Maximum 2 premium toppings allowed per item')\n\n        return v\n\n    @validator('line_total')\n    def validate_line_total(cls, v, values):\n        \"\"\"Validate line total calculation.\"\"\"\n        base_price = values.get('base_price', Decimal('0'))\n        toppings_price = values.get('toppings_price', Decimal('0'))\n        quantity = values.get('quantity', 1)\n\n        expected_total = (base_price + toppings_price) * quantity\n\n        if abs(v - expected_total) &gt; Decimal('0.01'):\n            raise ValueError(\n                f'Line total {v} does not match calculated total {expected_total}'\n            )\n\n        return v\n</code></pre>"},{"location":"features/enhanced-model-validation/#business-rule-validators","title":"\ud83c\udfd7\ufe0f Business Rule Validators","text":""},{"location":"features/enhanced-model-validation/#custom-business-logic-validation","title":"Custom Business Logic Validation","text":"<pre><code>from neuroglia.validation import BusinessRuleValidator, ValidationResult\n\nclass PizzaOrderBusinessValidator(BusinessRuleValidator):\n    \"\"\"Comprehensive business rule validation for pizza orders.\"\"\"\n\n    def __init__(self, service_provider: ServiceProviderBase):\n        super().__init__(service_provider)\n        self.inventory_service = service_provider.get_service(InventoryService)\n        self.customer_service = service_provider.get_service(CustomerService)\n        self.menu_service = service_provider.get_service(MenuService)\n\n    async def validate_order_business_rules(self, order: PizzaOrderModel,\n                                          context: ValidationContext) -&gt; ValidationResult:\n        \"\"\"Validate comprehensive business rules for pizza orders.\"\"\"\n\n        errors = []\n        warnings = []\n\n        # Rule 1: Customer validation\n        customer_validation = await self.validate_customer_eligibility(order.customer_id)\n        if not customer_validation.is_valid:\n            errors.extend(customer_validation.errors)\n\n        # Rule 2: Inventory availability\n        inventory_validation = await self.validate_inventory_availability(order.order_items)\n        if not inventory_validation.is_valid:\n            errors.extend(inventory_validation.errors)\n\n        # Rule 3: Menu item availability\n        menu_validation = await self.validate_menu_items(order.order_items, context)\n        if not menu_validation.is_valid:\n            errors.extend(menu_validation.errors)\n        warnings.extend(menu_validation.warnings)\n\n        # Rule 4: Order timing validation\n        timing_validation = self.validate_order_timing(order, context)\n        if not timing_validation.is_valid:\n            errors.extend(timing_validation.errors)\n\n        # Rule 5: Financial validation\n        financial_validation = await self.validate_financial_constraints(order)\n        if not financial_validation.is_valid:\n            errors.extend(financial_validation.errors)\n\n        return ValidationResult(\n            is_valid=len(errors) == 0,\n            errors=errors,\n            warnings=warnings,\n            context=context\n        )\n\n    async def validate_customer_eligibility(self, customer_id: str) -&gt; ValidationResult:\n        \"\"\"Validate customer is eligible to place orders.\"\"\"\n\n        customer = await self.customer_service.get_customer_async(customer_id)\n        errors = []\n\n        if not customer:\n            errors.append(ValidationError(\n                field=\"customer_id\",\n                message=\"Customer not found\",\n                code=\"CUSTOMER_NOT_FOUND\"\n            ))\n            return ValidationResult(is_valid=False, errors=errors)\n\n        # Check customer account status\n        if customer.status == \"suspended\":\n            errors.append(ValidationError(\n                field=\"customer_id\",\n                message=\"Customer account is suspended\",\n                code=\"CUSTOMER_SUSPENDED\"\n            ))\n\n        # Check outstanding balance\n        if customer.outstanding_balance &gt; Decimal('100.00'):\n            errors.append(ValidationError(\n                field=\"customer_id\",\n                message=f\"Outstanding balance of ${customer.outstanding_balance} exceeds limit\",\n                code=\"OUTSTANDING_BALANCE_LIMIT\"\n            ))\n\n        # Check daily order limit\n        today_orders = await self.customer_service.get_today_order_count(customer_id)\n        if today_orders &gt;= 10:\n            errors.append(ValidationError(\n                field=\"customer_id\",\n                message=\"Daily order limit exceeded (10 orders per day)\",\n                code=\"DAILY_ORDER_LIMIT\"\n            ))\n\n        return ValidationResult(is_valid=len(errors) == 0, errors=errors)\n\n    async def validate_inventory_availability(self, order_items: List[OrderItemModel]) -&gt; ValidationResult:\n        \"\"\"Validate ingredient availability for all order items.\"\"\"\n\n        errors = []\n\n        for item in order_items:\n            # Get recipe ingredients for menu item\n            recipe = await self.menu_service.get_recipe_async(item.menu_item_id)\n            if not recipe:\n                errors.append(ValidationError(\n                    field=f\"order_items[{item.menu_item_id}]\",\n                    message=f\"Recipe not found for item: {item.item_name}\",\n                    code=\"RECIPE_NOT_FOUND\"\n                ))\n                continue\n\n            # Check base ingredients\n            for ingredient in recipe.base_ingredients:\n                required_quantity = ingredient.quantity * item.quantity\n                available_quantity = await self.inventory_service.get_available_quantity(\n                    ingredient.ingredient_id\n                )\n\n                if available_quantity &lt; required_quantity:\n                    errors.append(ValidationError(\n                        field=f\"order_items[{item.menu_item_id}].quantity\",\n                        message=f\"Insufficient {ingredient.name}: need {required_quantity}, have {available_quantity}\",\n                        code=\"INSUFFICIENT_INVENTORY\"\n                    ))\n\n            # Check topping availability\n            for topping_id in item.selected_toppings:\n                topping_quantity = await self.inventory_service.get_available_quantity(topping_id)\n                required_quantity = item.quantity  # 1 unit per pizza\n\n                if topping_quantity &lt; required_quantity:\n                    errors.append(ValidationError(\n                        field=f\"order_items[{item.menu_item_id}].selected_toppings\",\n                        message=f\"Topping '{topping_id}' not available in sufficient quantity\",\n                        code=\"TOPPING_UNAVAILABLE\"\n                    ))\n\n        return ValidationResult(is_valid=len(errors) == 0, errors=errors)\n\n    async def validate_menu_items(self, order_items: List[OrderItemModel],\n                                context: ValidationContext) -&gt; ValidationResult:\n        \"\"\"Validate menu item availability and special conditions.\"\"\"\n\n        errors = []\n        warnings = []\n\n        for item in order_items:\n            menu_item = await self.menu_service.get_menu_item_async(item.menu_item_id)\n\n            if not menu_item:\n                errors.append(ValidationError(\n                    field=f\"order_items[{item.menu_item_id}]\",\n                    message=f\"Menu item not found: {item.menu_item_id}\",\n                    code=\"MENU_ITEM_NOT_FOUND\"\n                ))\n                continue\n\n            # Check if item is available\n            if not menu_item.is_available:\n                errors.append(ValidationError(\n                    field=f\"order_items[{item.menu_item_id}]\",\n                    message=f\"Menu item is currently unavailable: {item.item_name}\",\n                    code=\"MENU_ITEM_UNAVAILABLE\"\n                ))\n\n            # Check size availability\n            if item.size not in menu_item.available_sizes:\n                errors.append(ValidationError(\n                    field=f\"order_items[{item.menu_item_id}].size\",\n                    message=f\"Size '{item.size}' not available for {item.item_name}\",\n                    code=\"SIZE_UNAVAILABLE\"\n                ))\n\n            # Check seasonal availability\n            if menu_item.is_seasonal and not self.is_in_season(menu_item, context.current_date):\n                warnings.append(ValidationWarning(\n                    field=f\"order_items[{item.menu_item_id}]\",\n                    message=f\"'{item.item_name}' is a seasonal item and may not be available\",\n                    code=\"SEASONAL_ITEM_WARNING\"\n                ))\n\n            # Validate price matches current menu price\n            current_price = menu_item.get_price_for_size(item.size)\n            if abs(item.base_price - current_price) &gt; Decimal('0.01'):\n                errors.append(ValidationError(\n                    field=f\"order_items[{item.menu_item_id}].base_price\",\n                    message=f\"Price mismatch: expected {current_price}, got {item.base_price}\",\n                    code=\"PRICE_MISMATCH\"\n                ))\n\n        return ValidationResult(\n            is_valid=len(errors) == 0,\n            errors=errors,\n            warnings=warnings\n        )\n\n    def validate_order_timing(self, order: PizzaOrderModel,\n                            context: ValidationContext) -&gt; ValidationResult:\n        \"\"\"Validate order timing constraints.\"\"\"\n\n        errors = []\n        current_time = context.current_datetime\n\n        # Check restaurant hours\n        restaurant_hours = self.get_restaurant_hours(current_time.weekday())\n        current_hour = current_time.hour\n\n        if not (restaurant_hours.open_hour &lt;= current_hour &lt; restaurant_hours.close_hour):\n            errors.append(ValidationError(\n                field=\"order_placed_at\",\n                message=f\"Restaurant is closed. Hours: {restaurant_hours.open_hour}:00 - {restaurant_hours.close_hour}:00\",\n                code=\"RESTAURANT_CLOSED\"\n            ))\n\n        # Rush order timing validation\n        if order.is_rush_order:\n            # Rush orders not allowed in last hour before closing\n            if current_hour &gt;= restaurant_hours.close_hour - 1:\n                errors.append(ValidationError(\n                    field=\"is_rush_order\",\n                    message=\"Rush orders not available in the last hour before closing\",\n                    code=\"RUSH_ORDER_TOO_LATE\"\n                ))\n\n            # Check rush order capacity\n            current_rush_orders = context.get(\"current_rush_orders\", 0)\n            if current_rush_orders &gt;= 5:  # Max 5 rush orders at once\n                errors.append(ValidationError(\n                    field=\"is_rush_order\",\n                    message=\"Rush order capacity exceeded. Please try again later.\",\n                    code=\"RUSH_ORDER_CAPACITY_EXCEEDED\"\n                ))\n\n        return ValidationResult(is_valid=len(errors) == 0, errors=errors)\n\n    async def validate_financial_constraints(self, order: PizzaOrderModel) -&gt; ValidationResult:\n        \"\"\"Validate financial business rules.\"\"\"\n\n        errors = []\n\n        # Minimum order value\n        minimum_order = Decimal('10.00')\n        if order.subtotal &lt; minimum_order:\n            errors.append(ValidationError(\n                field=\"subtotal\",\n                message=f\"Minimum order value is ${minimum_order}\",\n                code=\"MINIMUM_ORDER_NOT_MET\"\n            ))\n\n        # Maximum single order value (fraud prevention)\n        maximum_order = Decimal('500.00')\n        if order.total_amount &gt; maximum_order:\n            errors.append(ValidationError(\n                field=\"total_amount\",\n                message=f\"Maximum single order value is ${maximum_order}\",\n                code=\"MAXIMUM_ORDER_EXCEEDED\"\n            ))\n\n        # Rush order surcharge validation\n        if order.is_rush_order:\n            expected_rush_fee = order.subtotal * Decimal('0.20')  # 20% surcharge\n            if abs(order.delivery_fee - expected_rush_fee) &gt; Decimal('0.01'):\n                errors.append(ValidationError(\n                    field=\"delivery_fee\",\n                    message=f\"Rush order delivery fee should be ${expected_rush_fee}\",\n                    code=\"RUSH_DELIVERY_FEE_INCORRECT\"\n                ))\n\n        return ValidationResult(is_valid=len(errors) == 0, errors=errors)\n</code></pre>"},{"location":"features/enhanced-model-validation/#context-aware-validation","title":"\ud83c\udfaf Context-Aware Validation","text":""},{"location":"features/enhanced-model-validation/#dynamic-validation-based-on-context","title":"Dynamic Validation Based on Context","text":"<pre><code>from neuroglia.validation import ContextAwareValidator, ValidationContext\n\nclass CustomerRegistrationValidator(ContextAwareValidator):\n    \"\"\"Context-aware validation for customer registration.\"\"\"\n\n    async def validate_customer_registration(self, customer_data: dict,\n                                           context: ValidationContext) -&gt; ValidationResult:\n        \"\"\"Validate customer registration with context-specific rules.\"\"\"\n\n        errors = []\n        warnings = []\n\n        # Different validation rules based on registration source\n        registration_source = context.get(\"registration_source\", \"web\")\n\n        if registration_source == \"mobile_app\":\n            # Mobile app requires phone verification\n            mobile_validation = await self.validate_mobile_app_requirements(customer_data)\n            errors.extend(mobile_validation.errors)\n\n        elif registration_source == \"social_login\":\n            # Social login has different email validation\n            social_validation = await self.validate_social_login_requirements(customer_data)\n            errors.extend(social_validation.errors)\n\n        elif registration_source == \"in_store\":\n            # In-store registration allows relaxed validation\n            store_validation = await self.validate_in_store_requirements(customer_data)\n            warnings.extend(store_validation.warnings)\n\n        # Location-based validation\n        customer_location = context.get(\"customer_location\")\n        if customer_location:\n            location_validation = await self.validate_location_requirements(\n                customer_data, customer_location\n            )\n            errors.extend(location_validation.errors)\n\n        # Time-based validation (different rules for peak hours)\n        current_hour = context.current_datetime.hour\n        if 11 &lt;= current_hour &lt;= 14:  # Lunch rush\n            # Expedited validation during peak hours\n            peak_validation = self.validate_peak_hour_registration(customer_data)\n            if not peak_validation.is_valid:\n                # Convert some errors to warnings during peak hours\n                warnings.extend([\n                    ValidationWarning(\n                        field=error.field,\n                        message=f\"Peak hours: {error.message}\",\n                        code=f\"PEAK_{error.code}\"\n                    ) for error in peak_validation.errors\n                ])\n\n        return ValidationResult(\n            is_valid=len(errors) == 0,\n            errors=errors,\n            warnings=warnings,\n            context=context\n        )\n\n    async def validate_mobile_app_requirements(self, customer_data: dict) -&gt; ValidationResult:\n        \"\"\"Validate requirements specific to mobile app registration.\"\"\"\n\n        errors = []\n\n        # Phone number is required for mobile registration\n        if not customer_data.get(\"phone_number\"):\n            errors.append(ValidationError(\n                field=\"phone_number\",\n                message=\"Phone number is required for mobile registration\",\n                code=\"MOBILE_PHONE_REQUIRED\"\n            ))\n\n        # Push notification consent\n        if not customer_data.get(\"accepts_push_notifications\"):\n            errors.append(ValidationError(\n                field=\"accepts_push_notifications\",\n                message=\"Push notification consent required for mobile app\",\n                code=\"PUSH_CONSENT_REQUIRED\"\n            ))\n\n        return ValidationResult(is_valid=len(errors) == 0, errors=errors)\n\n    async def validate_location_requirements(self, customer_data: dict,\n                                           location: dict) -&gt; ValidationResult:\n        \"\"\"Validate location-specific requirements.\"\"\"\n\n        errors = []\n\n        # Check if we deliver to this location\n        is_in_delivery_zone = await self.check_delivery_zone(location)\n        if not is_in_delivery_zone:\n            errors.append(ValidationError(\n                field=\"address\",\n                message=\"Sorry, we don't deliver to this location yet\",\n                code=\"OUTSIDE_DELIVERY_ZONE\"\n            ))\n\n        # State-specific validation (e.g., age verification requirements)\n        state = location.get(\"state\")\n        if state in [\"CA\", \"NY\"]:  # States with stricter requirements\n            if not customer_data.get(\"date_of_birth\"):\n                errors.append(ValidationError(\n                    field=\"date_of_birth\",\n                    message=f\"Date of birth required for registration in {state}\",\n                    code=\"STATE_DOB_REQUIRED\"\n                ))\n\n        return ValidationResult(is_valid=len(errors) == 0, errors=errors)\n</code></pre>"},{"location":"features/enhanced-model-validation/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"features/enhanced-model-validation/#comprehensive-validation-testing","title":"Comprehensive Validation Testing","text":"<pre><code>import pytest\nfrom decimal import Decimal\nfrom datetime import datetime, timedelta\nfrom neuroglia.validation import ValidationContext, ValidationResult\n\nclass TestPizzaOrderValidation:\n\n    @pytest.fixture\n    def valid_order_data(self):\n        return {\n            \"order_id\": \"ORD_20241201_001\",\n            \"customer_id\": \"CUST_12345\",\n            \"order_items\": [\n                {\n                    \"menu_item_id\": \"margherita_large\",\n                    \"item_name\": \"Margherita Pizza\",\n                    \"size\": \"large\",\n                    \"base_price\": Decimal(\"18.99\"),\n                    \"selected_toppings\": [\"extra_cheese\"],\n                    \"removed_ingredients\": [],\n                    \"quantity\": 1,\n                    \"toppings_price\": Decimal(\"2.50\"),\n                    \"line_total\": Decimal(\"21.49\")\n                }\n            ],\n            \"subtotal\": Decimal(\"21.49\"),\n            \"tax_amount\": Decimal(\"1.72\"),\n            \"delivery_fee\": Decimal(\"2.99\"),\n            \"total_amount\": Decimal(\"26.20\"),\n            \"order_placed_at\": datetime.utcnow(),\n            \"requested_delivery_time\": datetime.utcnow() + timedelta(minutes=45),\n            \"special_instructions\": \"Ring doorbell\",\n            \"is_rush_order\": False\n        }\n\n    @pytest.fixture\n    def validation_context(self):\n        return ValidationContext(\n            current_datetime=datetime.utcnow(),\n            current_date=datetime.utcnow().date(),\n            user_context={\"customer_id\": \"CUST_12345\"},\n            request_context={\"source\": \"web_app\"}\n        )\n\n    def test_valid_order_passes_validation(self, valid_order_data):\n        \"\"\"Test that a valid order passes all validation.\"\"\"\n\n        order = PizzaOrderModel(**valid_order_data)\n\n        # Should not raise any validation errors\n        assert order.order_id == \"ORD_20241201_001\"\n        assert order.total_amount == Decimal(\"26.20\")\n        assert len(order.order_items) == 1\n\n    def test_invalid_order_id_format(self, valid_order_data):\n        \"\"\"Test order ID format validation.\"\"\"\n\n        valid_order_data[\"order_id\"] = \"INVALID_FORMAT\"\n\n        with pytest.raises(ValueError) as exc_info:\n            PizzaOrderModel(**valid_order_data)\n\n        assert \"Order ID must follow format\" in str(exc_info.value)\n\n    def test_total_calculation_validation(self, valid_order_data):\n        \"\"\"Test total amount calculation validation.\"\"\"\n\n        # Set incorrect total\n        valid_order_data[\"total_amount\"] = Decimal(\"99.99\")\n\n        with pytest.raises(ValueError) as exc_info:\n            PizzaOrderModel(**valid_order_data)\n\n        assert \"Total amount\" in str(exc_info.value)\n        assert \"does not match calculated total\" in str(exc_info.value)\n\n    def test_delivery_time_validation(self, valid_order_data):\n        \"\"\"Test delivery time business rules.\"\"\"\n\n        # Set delivery time in the past\n        valid_order_data[\"requested_delivery_time\"] = datetime.utcnow() - timedelta(hours=1)\n\n        with pytest.raises(ValueError) as exc_info:\n            PizzaOrderModel(**valid_order_data)\n\n        assert \"Delivery time must be after order placement\" in str(exc_info.value)\n\n    def test_delivery_time_early_hours_restriction(self, valid_order_data):\n        \"\"\"Test early hours delivery restriction.\"\"\"\n\n        # Set delivery time at 3 AM (restricted hours)\n        tomorrow_3am = datetime.utcnow().replace(hour=3, minute=0, second=0) + timedelta(days=1)\n        valid_order_data[\"requested_delivery_time\"] = tomorrow_3am\n\n        with pytest.raises(ValueError) as exc_info:\n            PizzaOrderModel(**valid_order_data)\n\n        assert \"not available between 2 AM and 10 AM\" in str(exc_info.value)\n\n    def test_maximum_item_quantity_validation(self, valid_order_data):\n        \"\"\"Test maximum quantity validation.\"\"\"\n\n        # Set quantity above limit\n        valid_order_data[\"order_items\"][0][\"quantity\"] = 15\n        valid_order_data[\"order_items\"][0][\"line_total\"] = Decimal(\"322.35\")  # Adjust total\n        valid_order_data[\"subtotal\"] = Decimal(\"322.35\")\n        valid_order_data[\"total_amount\"] = Decimal(\"350.00\")  # Adjust totals\n\n        with pytest.raises(ValueError) as exc_info:\n            PizzaOrderModel(**valid_order_data)\n\n        assert \"quantity\" in str(exc_info.value)\n\n    def test_duplicate_toppings_validation(self, valid_order_data):\n        \"\"\"Test duplicate toppings validation.\"\"\"\n\n        # Add duplicate toppings\n        valid_order_data[\"order_items\"][0][\"selected_toppings\"] = [\n            \"extra_cheese\", \"extra_cheese\", \"pepperoni\"\n        ]\n\n        with pytest.raises(ValueError) as exc_info:\n            PizzaOrderModel(**valid_order_data)\n\n        assert \"Duplicate toppings are not allowed\" in str(exc_info.value)\n\n    @pytest.mark.asyncio\n    async def test_business_rule_validation(self, valid_order_data, validation_context):\n        \"\"\"Test comprehensive business rule validation.\"\"\"\n\n        # Mock services\n        business_validator = PizzaOrderBusinessValidator(mock_service_provider())\n\n        order = PizzaOrderModel(**valid_order_data)\n        result = await business_validator.validate_order_business_rules(order, validation_context)\n\n        # Should pass basic validation (with mocked services)\n        assert isinstance(result, ValidationResult)\n\n    def test_line_total_calculation_validation(self, valid_order_data):\n        \"\"\"Test line total calculation validation.\"\"\"\n\n        # Set incorrect line total\n        valid_order_data[\"order_items\"][0][\"line_total\"] = Decimal(\"99.99\")\n        # Keep other totals consistent to isolate this validation\n\n        with pytest.raises(ValueError) as exc_info:\n            PizzaOrderModel(**valid_order_data)\n\n        assert \"Line total\" in str(exc_info.value)\n        assert \"does not match calculated total\" in str(exc_info.value)\n\ndef mock_service_provider():\n    \"\"\"Create mock service provider for testing.\"\"\"\n    from unittest.mock import Mock\n\n    service_provider = Mock()\n\n    # Mock inventory service\n    inventory_service = Mock()\n    inventory_service.get_available_quantity = Mock(return_value=100)  # Always available\n\n    # Mock customer service\n    customer_service = Mock()\n    mock_customer = Mock()\n    mock_customer.status = \"active\"\n    mock_customer.outstanding_balance = Decimal(\"0.00\")\n    customer_service.get_customer_async = Mock(return_value=mock_customer)\n    customer_service.get_today_order_count = Mock(return_value=0)\n\n    # Mock menu service\n    menu_service = Mock()\n    mock_recipe = Mock()\n    mock_recipe.base_ingredients = []\n    menu_service.get_recipe_async = Mock(return_value=mock_recipe)\n\n    mock_menu_item = Mock()\n    mock_menu_item.is_available = True\n    mock_menu_item.available_sizes = [\"small\", \"medium\", \"large\"]\n    mock_menu_item.is_seasonal = False\n    mock_menu_item.get_price_for_size = Mock(return_value=Decimal(\"18.99\"))\n    menu_service.get_menu_item_async = Mock(return_value=mock_menu_item)\n\n    service_provider.get_service.side_effect = lambda service_type: {\n        'InventoryService': inventory_service,\n        'CustomerService': customer_service,\n        'MenuService': menu_service\n    }.get(service_type.__name__ if hasattr(service_type, '__name__') else str(service_type))\n\n    return service_provider\n</code></pre>"},{"location":"features/enhanced-model-validation/#performance-testing","title":"Performance Testing","text":"<pre><code>import time\nimport pytest\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass TestValidationPerformance:\n\n    def test_validation_performance(self, valid_order_data):\n        \"\"\"Test validation performance with large datasets.\"\"\"\n\n        # Create 100 order variations\n        orders_data = []\n        for i in range(100):\n            order_data = valid_order_data.copy()\n            order_data[\"order_id\"] = f\"ORD_20241201_{i:03d}\"\n            orders_data.append(order_data)\n\n        # Time validation\n        start_time = time.time()\n\n        valid_orders = []\n        for order_data in orders_data:\n            try:\n                order = PizzaOrderModel(**order_data)\n                valid_orders.append(order)\n            except ValueError:\n                pass  # Skip invalid orders\n\n        end_time = time.time()\n        duration = end_time - start_time\n\n        print(f\"\u2705 Validated {len(valid_orders)} orders in {duration:.3f}s\")\n        print(f\"\ud83d\udcca Average validation time: {(duration/len(orders_data)*1000):.1f}ms per order\")\n\n        # Performance assertion\n        assert duration &lt; 1.0, f\"Validation took too long: {duration:.3f}s\"\n        assert len(valid_orders) == 100, \"Some valid orders failed validation\"\n</code></pre>"},{"location":"features/enhanced-model-validation/#error-aggregation-and-reporting","title":"\ud83d\udcca Error Aggregation and Reporting","text":""},{"location":"features/enhanced-model-validation/#comprehensive-error-handling","title":"Comprehensive Error Handling","text":"<pre><code>from neuroglia.validation import ValidationErrorAggregator, ValidationReport\n\nclass OrderValidationService:\n    \"\"\"Service for comprehensive order validation with detailed reporting.\"\"\"\n\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.business_validator = service_provider.get_service(PizzaOrderBusinessValidator)\n        self.error_aggregator = ValidationErrorAggregator()\n\n    async def validate_order_comprehensively(self, order_data: dict,\n                                           context: ValidationContext) -&gt; ValidationReport:\n        \"\"\"Perform comprehensive validation with detailed error reporting.\"\"\"\n\n        validation_report = ValidationReport()\n\n        try:\n            # Step 1: Basic model validation\n            validation_report.add_step(\"Model Validation\")\n            order_model = PizzaOrderModel(**order_data)\n            validation_report.mark_step_success(\"Model Validation\")\n\n        except ValueError as e:\n            validation_report.mark_step_failed(\"Model Validation\", str(e))\n            return validation_report\n\n        # Step 2: Business rule validation\n        validation_report.add_step(\"Business Rules Validation\")\n        business_result = await self.business_validator.validate_order_business_rules(\n            order_model, context\n        )\n\n        if business_result.is_valid:\n            validation_report.mark_step_success(\"Business Rules Validation\")\n        else:\n            validation_report.mark_step_failed(\n                \"Business Rules Validation\",\n                business_result.errors\n            )\n            validation_report.add_warnings(business_result.warnings)\n\n        # Step 3: Context-specific validation\n        validation_report.add_step(\"Context Validation\")\n        context_result = await self.validate_context_specific_rules(order_model, context)\n\n        if context_result.is_valid:\n            validation_report.mark_step_success(\"Context Validation\")\n        else:\n            validation_report.mark_step_failed(\"Context Validation\", context_result.errors)\n\n        # Generate comprehensive report\n        validation_report.finalize()\n\n        print(\"\ud83d\udccb Validation Report:\")\n        print(f\"Overall Status: {'\u2705 VALID' if validation_report.is_valid else '\u274c INVALID'}\")\n        print(f\"Total Errors: {len(validation_report.all_errors)}\")\n        print(f\"Total Warnings: {len(validation_report.all_warnings)}\")\n\n        if validation_report.all_errors:\n            print(\"\\n\ud83d\udea8 Validation Errors:\")\n            for error in validation_report.all_errors:\n                print(f\"  \u2022 {error.field}: {error.message} ({error.code})\")\n\n        if validation_report.all_warnings:\n            print(\"\\n\u26a0\ufe0f Validation Warnings:\")\n            for warning in validation_report.all_warnings:\n                print(f\"  \u2022 {warning.field}: {warning.message} ({warning.code})\")\n\n        return validation_report\n</code></pre>"},{"location":"features/enhanced-model-validation/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\ud83d\udd27 Dependency Injection - Service registration for validators</li> <li>\ud83d\udd04 Case Conversion Utilities - Model field transformations</li> <li>\ud83d\udce8 CQRS &amp; Mediation - Command validation patterns</li> <li>\ud83c\udf10 HTTP Service Client - Request/response validation</li> <li>\ud83d\udcc1 Data Access - Data persistence validation</li> </ul> <p>The Enhanced Model Validation system provides comprehensive data integrity enforcement throughout Mario's Pizzeria application. Through business rules, contextual validation, and detailed error reporting, the system ensures reliable operations while providing clear feedback for resolution of validation issues.</p>"},{"location":"features/http-service-client/","title":"\ud83c\udf10 HTTP Service Client","text":"<p>The Neuroglia framework provides enterprise-grade HTTP client capabilities with advanced resilience patterns, enabling reliable communication with external services through circuit breakers, retry policies, and comprehensive request/response interception.</p>"},{"location":"features/http-service-client/#overview","title":"\ud83c\udfaf Overview","text":"<p>Modern microservices rely heavily on external service communication for payment processing, third-party APIs, and inter-service coordination. The framework's HTTP client implementation provides:</p> <ul> <li>Circuit Breaker Pattern: Protection against cascading failures</li> <li>Retry Policies: Configurable retry strategies with exponential backoff</li> <li>Request/Response Interception: Middleware for authentication, logging, and monitoring</li> <li>Connection Pooling: Optimized HTTP connection management</li> <li>Timeout Management: Configurable timeouts for different scenarios</li> <li>Request/Response Validation: Automatic data validation and transformation</li> </ul>"},{"location":"features/http-service-client/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>graph TB\n    subgraph \"\ud83c\udf55 Mario's Pizzeria Services\"\n        OrderService[Order Service]\n        PaymentService[Payment Service]\n        DeliveryService[Delivery Service]\n        NotificationService[Notification Service]\n    end\n\n    subgraph \"\ud83c\udf10 HTTP Service Client\"\n        HttpClient[HTTP Client Manager]\n        CircuitBreaker[Circuit Breaker]\n        RetryPolicy[Retry Policy]\n        Interceptors[Request/Response Interceptors]\n    end\n\n    subgraph \"\ud83d\udd0c External Services\"\n        PaymentGateway[Payment Gateway API]\n        DeliveryAPI[Delivery Tracking API]\n        EmailService[Email Service API]\n        SMSService[SMS Service API]\n    end\n\n    OrderService --&gt; HttpClient\n    PaymentService --&gt; HttpClient\n    DeliveryService --&gt; HttpClient\n    NotificationService --&gt; HttpClient\n\n    HttpClient --&gt; CircuitBreaker\n    HttpClient --&gt; RetryPolicy\n    HttpClient --&gt; Interceptors\n\n    CircuitBreaker --&gt; PaymentGateway\n    CircuitBreaker --&gt; DeliveryAPI\n    CircuitBreaker --&gt; EmailService\n    CircuitBreaker --&gt; SMSService\n\n    style HttpClient fill:#e3f2fd\n    style CircuitBreaker fill:#ffebee\n    style RetryPolicy fill:#e8f5e8\n    style Interceptors fill:#fff3e0</code></pre>"},{"location":"features/http-service-client/#basic-usage","title":"\ud83d\ude80 Basic Usage","text":""},{"location":"features/http-service-client/#service-registration","title":"Service Registration","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.http import HttpServiceClient, HttpClientConfig\n\ndef create_app():\n    builder = WebApplicationBuilder()\n\n    # Register HTTP service client\n    http_config = HttpClientConfig(\n        base_timeout=30.0,\n        connection_timeout=5.0,\n        max_connections=100,\n        max_connections_per_host=20,\n        enable_circuit_breaker=True,\n        enable_retry_policy=True\n    )\n\n    builder.services.add_http_service_client(http_config)\n\n    app = builder.build()\n    return app\n</code></pre>"},{"location":"features/http-service-client/#simple-http-operations","title":"Simple HTTP Operations","text":"<pre><code>from neuroglia.http import HttpServiceClient\nfrom neuroglia.dependency_injection import ServiceProviderBase\nfrom typing import Optional\n\nclass PaymentGatewayService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.http_client = service_provider.get_service(HttpServiceClient)\n        self.base_url = \"https://api.payment-gateway.com/v1\"\n        self.api_key = \"your_api_key_here\"\n\n    async def charge_customer(self, order_id: str, amount: float, currency: str = \"USD\") -&gt; dict:\n        \"\"\"Charge customer payment through external gateway.\"\"\"\n\n        payment_request = {\n            \"order_id\": order_id,\n            \"amount\": amount,\n            \"currency\": currency,\n            \"description\": f\"Mario's Pizzeria Order {order_id}\",\n            \"metadata\": {\n                \"restaurant\": \"marios_pizzeria\",\n                \"order_type\": \"online\"\n            }\n        }\n\n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\",\n            \"X-Idempotency-Key\": f\"order_{order_id}\"\n        }\n\n        try:\n            response = await self.http_client.post_async(\n                url=f\"{self.base_url}/charges\",\n                json=payment_request,\n                headers=headers,\n                timeout=15.0\n            )\n\n            if response.is_success:\n                print(f\"\ud83d\udcb3 Payment successful for order {order_id}: ${amount}\")\n                return response.json()\n            else:\n                print(f\"\u274c Payment failed for order {order_id}: {response.status_code}\")\n                raise PaymentProcessingError(f\"Payment failed: {response.text}\")\n\n        except Exception as e:\n            print(f\"\ud83d\udca5 Payment service error: {e}\")\n            raise PaymentServiceUnavailableError(f\"Cannot process payment: {e}\")\n\n    async def refund_payment(self, charge_id: str, amount: Optional[float] = None) -&gt; dict:\n        \"\"\"Process refund through payment gateway.\"\"\"\n\n        refund_request = {\n            \"charge_id\": charge_id,\n            \"reason\": \"customer_request\"\n        }\n\n        if amount:\n            refund_request[\"amount\"] = amount\n\n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n\n        response = await self.http_client.post_async(\n            url=f\"{self.base_url}/refunds\",\n            json=refund_request,\n            headers=headers\n        )\n\n        if response.is_success:\n            refund_data = response.json()\n            print(f\"\ud83d\udcb0 Refund processed: {refund_data['refund_id']}\")\n            return refund_data\n        else:\n            raise RefundProcessingError(f\"Refund failed: {response.text}\")\n</code></pre>"},{"location":"features/http-service-client/#circuit-breaker-pattern","title":"\ud83d\udd04 Circuit Breaker Pattern","text":""},{"location":"features/http-service-client/#resilient-external-service-integration","title":"Resilient External Service Integration","text":"<pre><code>from neuroglia.http import CircuitBreakerPolicy, CircuitBreakerState\n\nclass DeliveryTrackingService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.http_client = service_provider.get_service(HttpServiceClient)\n        self.base_url = \"https://api.delivery-service.com/v2\"\n\n        # Configure circuit breaker for delivery API\n        self.circuit_breaker = CircuitBreakerPolicy(\n            failure_threshold=5,        # Open after 5 failures\n            recovery_timeout=60,        # Try recovery after 60 seconds\n            success_threshold=3,        # Close after 3 successful calls\n            timeout=10.0               # Individual request timeout\n        )\n\n    @circuit_breaker.apply\n    async def create_delivery_request(self, order_id: str, delivery_address: dict) -&gt; dict:\n        \"\"\"Create delivery request with circuit breaker protection.\"\"\"\n\n        delivery_request = {\n            \"order_id\": order_id,\n            \"pickup_address\": {\n                \"street\": \"123 Pizza Street\",\n                \"city\": \"Pizza City\",\n                \"zip\": \"12345\"\n            },\n            \"delivery_address\": delivery_address,\n            \"priority\": \"standard\",\n            \"special_instructions\": \"Handle with care - hot pizza!\"\n        }\n\n        try:\n            response = await self.http_client.post_async(\n                url=f\"{self.base_url}/deliveries\",\n                json=delivery_request,\n                timeout=self.circuit_breaker.timeout\n            )\n\n            if response.is_success:\n                delivery_data = response.json()\n                print(f\"\ud83d\ude9a Delivery scheduled: {delivery_data['tracking_id']}\")\n                return delivery_data\n            else:\n                raise DeliveryServiceError(f\"Delivery creation failed: {response.status_code}\")\n\n        except Exception as e:\n            print(f\"\ud83d\udd34 Delivery service unavailable: {e}\")\n            # Circuit breaker will handle this failure\n            raise\n\n    async def get_delivery_status(self, tracking_id: str) -&gt; dict:\n        \"\"\"Get delivery status with fallback handling.\"\"\"\n\n        if self.circuit_breaker.state == CircuitBreakerState.OPEN:\n            # Circuit is open - use fallback\n            return await self.get_fallback_delivery_status(tracking_id)\n\n        try:\n            response = await self.http_client.get_async(\n                url=f\"{self.base_url}/deliveries/{tracking_id}\",\n                timeout=5.0\n            )\n\n            if response.is_success:\n                return response.json()\n            else:\n                return await self.get_fallback_delivery_status(tracking_id)\n\n        except Exception:\n            return await self.get_fallback_delivery_status(tracking_id)\n\n    async def get_fallback_delivery_status(self, tracking_id: str) -&gt; dict:\n        \"\"\"Fallback delivery status when service is unavailable.\"\"\"\n        print(f\"\ud83d\udccb Using fallback status for delivery {tracking_id}\")\n\n        return {\n            \"tracking_id\": tracking_id,\n            \"status\": \"in_transit\",\n            \"estimated_delivery\": \"Service temporarily unavailable\",\n            \"fallback\": True\n        }\n</code></pre>"},{"location":"features/http-service-client/#retry-policies","title":"\ud83d\udd04 Retry Policies","text":""},{"location":"features/http-service-client/#configurable-retry-strategies","title":"Configurable Retry Strategies","text":"<pre><code>from neuroglia.http import RetryPolicy, ExponentialBackoff, RetryCondition\n\nclass NotificationService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.http_client = service_provider.get_service(HttpServiceClient)\n\n        # Configure retry policy for notifications\n        self.retry_policy = RetryPolicy(\n            max_attempts=3,\n            backoff_strategy=ExponentialBackoff(\n                initial_delay=1.0,\n                max_delay=30.0,\n                backoff_factor=2.0\n            ),\n            retry_conditions=[\n                RetryCondition.on_timeout(),\n                RetryCondition.on_status_codes([429, 502, 503, 504]),\n                RetryCondition.on_exceptions([ConnectionError, TimeoutError])\n            ]\n        )\n\n    @retry_policy.apply\n    async def send_order_confirmation_email(self, customer_email: str, order_details: dict) -&gt; bool:\n        \"\"\"Send order confirmation email with retry policy.\"\"\"\n\n        email_request = {\n            \"to\": customer_email,\n            \"subject\": f\"\ud83c\udf55 Order Confirmation - #{order_details['order_id']}\",\n            \"template\": \"order_confirmation\",\n            \"variables\": {\n                \"customer_name\": order_details['customer_name'],\n                \"order_id\": order_details['order_id'],\n                \"items\": order_details['items'],\n                \"total_amount\": order_details['total_amount'],\n                \"estimated_delivery\": order_details['estimated_delivery']\n            }\n        }\n\n        response = await self.http_client.post_async(\n            url=\"https://api.email-service.com/v1/send\",\n            json=email_request,\n            headers={\n                \"Authorization\": f\"Bearer {self.get_email_api_key()}\",\n                \"Content-Type\": \"application/json\"\n            },\n            timeout=10.0\n        )\n\n        if response.is_success:\n            print(f\"\ud83d\udce7 Order confirmation sent to {customer_email}\")\n            return True\n        else:\n            error_msg = f\"Failed to send email: {response.status_code} - {response.text}\"\n            print(f\"\u274c {error_msg}\")\n            raise EmailDeliveryError(error_msg)\n\n    @retry_policy.apply\n    async def send_sms_notification(self, phone_number: str, message: str) -&gt; bool:\n        \"\"\"Send SMS notification with retry policy.\"\"\"\n\n        sms_request = {\n            \"to\": phone_number,\n            \"message\": message,\n            \"from\": \"Mario's Pizzeria\"\n        }\n\n        response = await self.http_client.post_async(\n            url=\"https://api.sms-service.com/v1/messages\",\n            json=sms_request,\n            headers={\n                \"Authorization\": f\"Bearer {self.get_sms_api_key()}\",\n                \"Content-Type\": \"application/json\"\n            }\n        )\n\n        if response.is_success:\n            print(f\"\ud83d\udcf1 SMS sent to {phone_number}\")\n            return True\n        else:\n            raise SMSDeliveryError(f\"SMS failed: {response.status_code}\")\n</code></pre>"},{"location":"features/http-service-client/#requestresponse-interception","title":"\ud83d\udd0d Request/Response Interception","text":""},{"location":"features/http-service-client/#middleware-for-cross-cutting-concerns","title":"Middleware for Cross-Cutting Concerns","text":"<pre><code>from neuroglia.http import RequestInterceptor, ResponseInterceptor, HttpContext\n\nclass AuthenticationInterceptor(RequestInterceptor):\n    \"\"\"Add authentication to all external service requests.\"\"\"\n\n    async def intercept_request(self, request: HttpRequest, context: HttpContext) -&gt; HttpRequest:\n        # Add API key based on service\n        if \"payment-gateway.com\" in request.url:\n            request.headers[\"Authorization\"] = f\"Bearer {self.get_payment_api_key()}\"\n        elif \"delivery-service.com\" in request.url:\n            request.headers[\"X-API-Key\"] = self.get_delivery_api_key()\n        elif \"email-service.com\" in request.url:\n            request.headers[\"Authorization\"] = f\"Bearer {self.get_email_api_key()}\"\n\n        # Add common headers\n        request.headers[\"User-Agent\"] = \"MariosPizzeria/1.0\"\n        request.headers[\"X-Request-ID\"] = context.correlation_id\n\n        return request\n\n    def get_payment_api_key(self) -&gt; str:\n        return \"payment_api_key_here\"\n\n    def get_delivery_api_key(self) -&gt; str:\n        return \"delivery_api_key_here\"\n\n    def get_email_api_key(self) -&gt; str:\n        return \"email_api_key_here\"\n\nclass LoggingInterceptor(RequestInterceptor, ResponseInterceptor):\n    \"\"\"Log all HTTP requests and responses.\"\"\"\n\n    async def intercept_request(self, request: HttpRequest, context: HttpContext) -&gt; HttpRequest:\n        print(f\"\ud83c\udf10 HTTP Request: {request.method} {request.url}\")\n        print(f\"\ud83d\udccb Headers: {dict(request.headers)}\")\n\n        if request.json:\n            print(f\"\ud83d\udcc4 Request Body: {request.json}\")\n\n        context.start_time = time.time()\n        return request\n\n    async def intercept_response(self, response: HttpResponse, context: HttpContext) -&gt; HttpResponse:\n        duration = time.time() - context.start_time\n\n        print(f\"\ud83d\udce8 HTTP Response: {response.status_code} ({duration:.2f}s)\")\n        print(f\"\ud83d\udcc4 Response Size: {len(response.content)} bytes\")\n\n        if not response.is_success:\n            print(f\"\u274c Error Response: {response.text}\")\n\n        return response\n\nclass RateLimitInterceptor(RequestInterceptor):\n    \"\"\"Handle rate limiting with backoff.\"\"\"\n\n    def __init__(self):\n        self.rate_limit_trackers = {}\n\n    async def intercept_request(self, request: HttpRequest, context: HttpContext) -&gt; HttpRequest:\n        service_key = self.extract_service_key(request.url)\n\n        # Check if we're rate limited\n        if self.is_rate_limited(service_key):\n            wait_time = self.get_rate_limit_wait_time(service_key)\n            print(f\"\u23f3 Rate limited for {service_key}, waiting {wait_time}s\")\n            await asyncio.sleep(wait_time)\n\n        return request\n\n    async def intercept_response(self, response: HttpResponse, context: HttpContext) -&gt; HttpResponse:\n        if response.status_code == 429:  # Too Many Requests\n            service_key = self.extract_service_key(context.request.url)\n            self.handle_rate_limit_response(service_key, response)\n\n        return response\n\n    def extract_service_key(self, url: str) -&gt; str:\n        \"\"\"Extract service identifier from URL.\"\"\"\n        if \"payment-gateway.com\" in url:\n            return \"payment_gateway\"\n        elif \"delivery-service.com\" in url:\n            return \"delivery_service\"\n        elif \"email-service.com\" in url:\n            return \"email_service\"\n        return \"unknown\"\n\n    def is_rate_limited(self, service_key: str) -&gt; bool:\n        \"\"\"Check if service is currently rate limited.\"\"\"\n        tracker = self.rate_limit_trackers.get(service_key)\n        if not tracker:\n            return False\n\n        return time.time() &lt; tracker[\"retry_after\"]\n\n    def handle_rate_limit_response(self, service_key: str, response: HttpResponse):\n        \"\"\"Handle rate limit response headers.\"\"\"\n        retry_after = response.headers.get(\"Retry-After\", \"60\")\n\n        self.rate_limit_trackers[service_key] = {\n            \"retry_after\": time.time() + int(retry_after),\n            \"limit_exceeded_at\": time.time()\n        }\n</code></pre>"},{"location":"features/http-service-client/#registering-interceptors","title":"Registering Interceptors","text":"<pre><code>def configure_http_interceptors(services: ServiceCollection):\n    \"\"\"Configure HTTP client interceptors.\"\"\"\n\n    # Register interceptors in order of execution\n    services.add_singleton(AuthenticationInterceptor)\n    services.add_singleton(LoggingInterceptor)\n    services.add_singleton(RateLimitInterceptor)\n\n    # Configure HTTP client with interceptors\n    http_config = HttpClientConfig(\n        request_interceptors=[\n            AuthenticationInterceptor,\n            RateLimitInterceptor,\n            LoggingInterceptor\n        ],\n        response_interceptors=[\n            LoggingInterceptor,\n            RateLimitInterceptor\n        ]\n    )\n\n    services.add_http_service_client(http_config)\n</code></pre>"},{"location":"features/http-service-client/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"features/http-service-client/#unit-testing-with-http-mocks","title":"Unit Testing with HTTP Mocks","text":"<pre><code>import pytest\nfrom unittest.mock import AsyncMock, Mock\nfrom neuroglia.http import HttpServiceClient, HttpResponse\n\nclass TestPaymentGatewayService:\n\n    @pytest.fixture\n    def mock_http_client(self):\n        client = Mock(spec=HttpServiceClient)\n        client.post_async = AsyncMock()\n        client.get_async = AsyncMock()\n        return client\n\n    @pytest.fixture\n    def payment_service(self, mock_http_client):\n        service_provider = Mock()\n        service_provider.get_service.return_value = mock_http_client\n        return PaymentGatewayService(service_provider)\n\n    @pytest.mark.asyncio\n    async def test_successful_payment(self, payment_service, mock_http_client):\n        \"\"\"Test successful payment processing.\"\"\"\n\n        # Mock successful response\n        mock_response = Mock(spec=HttpResponse)\n        mock_response.is_success = True\n        mock_response.json.return_value = {\n            \"charge_id\": \"ch_123456\",\n            \"status\": \"succeeded\",\n            \"amount\": 25.99\n        }\n        mock_http_client.post_async.return_value = mock_response\n\n        # Test payment\n        result = await payment_service.charge_customer(\"order_123\", 25.99)\n\n        # Verify request was made correctly\n        mock_http_client.post_async.assert_called_once()\n        call_args = mock_http_client.post_async.call_args\n\n        assert \"charges\" in call_args[1][\"url\"]\n        assert call_args[1][\"json\"][\"amount\"] == 25.99\n        assert call_args[1][\"json\"][\"order_id\"] == \"order_123\"\n\n        # Verify response\n        assert result[\"charge_id\"] == \"ch_123456\"\n        assert result[\"status\"] == \"succeeded\"\n\n    @pytest.mark.asyncio\n    async def test_payment_failure(self, payment_service, mock_http_client):\n        \"\"\"Test payment processing failure.\"\"\"\n\n        # Mock failed response\n        mock_response = Mock(spec=HttpResponse)\n        mock_response.is_success = False\n        mock_response.status_code = 402\n        mock_response.text = \"Insufficient funds\"\n        mock_http_client.post_async.return_value = mock_response\n\n        # Test payment failure\n        with pytest.raises(PaymentProcessingError) as exc_info:\n            await payment_service.charge_customer(\"order_123\", 25.99)\n\n        assert \"Payment failed\" in str(exc_info.value)\n\n    @pytest.mark.asyncio\n    async def test_service_unavailable(self, payment_service, mock_http_client):\n        \"\"\"Test handling of service unavailability.\"\"\"\n\n        # Mock connection error\n        mock_http_client.post_async.side_effect = ConnectionError(\"Service unavailable\")\n\n        # Test service unavailable handling\n        with pytest.raises(PaymentServiceUnavailableError) as exc_info:\n            await payment_service.charge_customer(\"order_123\", 25.99)\n\n        assert \"Cannot process payment\" in str(exc_info.value)\n</code></pre>"},{"location":"features/http-service-client/#integration-testing-with-test-servers","title":"Integration Testing with Test Servers","text":"<pre><code>@pytest.mark.integration\nclass TestHttpServiceIntegration:\n\n    @pytest.fixture\n    async def test_server(self):\n        \"\"\"Start test HTTP server for integration testing.\"\"\"\n        from aiohttp import web\n        from aiohttp.test_utils import TestServer\n\n        async def payment_handler(request):\n            data = await request.json()\n\n            if data.get(\"amount\", 0) &lt;= 0:\n                return web.json_response(\n                    {\"error\": \"Invalid amount\"},\n                    status=400\n                )\n\n            return web.json_response({\n                \"charge_id\": \"ch_test_123\",\n                \"status\": \"succeeded\",\n                \"amount\": data[\"amount\"]\n            })\n\n        async def rate_limit_handler(request):\n            return web.json_response(\n                {\"error\": \"Rate limit exceeded\"},\n                status=429,\n                headers={\"Retry-After\": \"5\"}\n            )\n\n        app = web.Application()\n        app.router.add_post(\"/charges\", payment_handler)\n        app.router.add_post(\"/rate-limited\", rate_limit_handler)\n\n        server = TestServer(app)\n        await server.start_server()\n        yield server\n        await server.close()\n\n    @pytest.fixture\n    def http_client(self):\n        config = HttpClientConfig(\n            base_timeout=5.0,\n            enable_circuit_breaker=True,\n            enable_retry_policy=True\n        )\n        return HttpServiceClient(config)\n\n    @pytest.mark.asyncio\n    async def test_end_to_end_payment(self, test_server, http_client):\n        \"\"\"Test end-to-end payment processing.\"\"\"\n\n        payment_data = {\n            \"order_id\": \"integration_test_order\",\n            \"amount\": 19.99,\n            \"currency\": \"USD\"\n        }\n\n        response = await http_client.post_async(\n            url=f\"{test_server.make_url('/charges')}\",\n            json=payment_data,\n            timeout=10.0\n        )\n\n        assert response.is_success\n        result = response.json()\n        assert result[\"status\"] == \"succeeded\"\n        assert result[\"amount\"] == 19.99\n\n    @pytest.mark.asyncio\n    async def test_circuit_breaker_behavior(self, test_server, http_client):\n        \"\"\"Test circuit breaker with failing service.\"\"\"\n\n        # Make multiple requests to trigger circuit breaker\n        for i in range(6):  # Trigger failure threshold\n            try:\n                await http_client.post_async(\n                    url=f\"{test_server.make_url('/rate-limited')}\",\n                    json={\"test\": \"data\"},\n                    timeout=1.0\n                )\n            except Exception:\n                pass  # Expected failures\n\n        # Circuit should now be open - next request should fail fast\n        start_time = time.time()\n\n        with pytest.raises(Exception):  # Circuit breaker should fail fast\n            await http_client.post_async(\n                url=f\"{test_server.make_url('/rate-limited')}\",\n                json={\"test\": \"data\"}\n            )\n\n        duration = time.time() - start_time\n        assert duration &lt; 0.1  # Should fail fast, not wait for timeout\n</code></pre>"},{"location":"features/http-service-client/#monitoring-and-observability","title":"\ud83d\udcca Monitoring and Observability","text":""},{"location":"features/http-service-client/#http-client-metrics","title":"HTTP Client Metrics","text":"<pre><code>from neuroglia.http import HttpMetrics, MetricsCollector\n\nclass HttpServiceMonitor:\n    def __init__(self, http_client: HttpServiceClient):\n        self.http_client = http_client\n        self.metrics = HttpMetrics()\n\n    async def track_request_metrics(self, service_name: str, endpoint: str,\n                                  status_code: int, duration: float):\n        \"\"\"Track HTTP request metrics.\"\"\"\n\n        # Increment counters\n        await self.metrics.increment_counter(f\"http_requests_total\", {\n            \"service\": service_name,\n            \"endpoint\": endpoint,\n            \"status_code\": status_code\n        })\n\n        # Track response times\n        await self.metrics.observe_histogram(f\"http_request_duration_seconds\", duration, {\n            \"service\": service_name,\n            \"endpoint\": endpoint\n        })\n\n        # Track error rates\n        if status_code &gt;= 400:\n            await self.metrics.increment_counter(f\"http_errors_total\", {\n                \"service\": service_name,\n                \"status_code\": status_code\n            })\n\n    async def get_service_health_summary(self) -&gt; dict:\n        \"\"\"Get HTTP service health summary.\"\"\"\n\n        total_requests = await self.metrics.get_counter(\"http_requests_total\")\n        total_errors = await self.metrics.get_counter(\"http_errors_total\")\n        avg_duration = await self.metrics.get_gauge(\"http_request_duration_seconds\")\n\n        error_rate = (total_errors / total_requests) if total_requests &gt; 0 else 0\n\n        return {\n            \"total_requests\": total_requests,\n            \"total_errors\": total_errors,\n            \"error_rate\": error_rate,\n            \"average_response_time\": avg_duration,\n            \"circuit_breaker_states\": await self.get_circuit_breaker_states()\n        }\n\n    async def get_circuit_breaker_states(self) -&gt; dict:\n        \"\"\"Get current circuit breaker states for all services.\"\"\"\n        return {\n            \"payment_gateway\": \"closed\",\n            \"delivery_service\": \"half_open\",\n            \"email_service\": \"closed\",\n            \"sms_service\": \"open\"\n        }\n</code></pre>"},{"location":"features/http-service-client/#advanced-configuration","title":"\ud83d\udd27 Advanced Configuration","text":""},{"location":"features/http-service-client/#connection-pool-and-performance-tuning","title":"Connection Pool and Performance Tuning","text":"<pre><code>from neuroglia.http import HttpClientConfig, ConnectionPoolConfig\n\ndef create_optimized_http_config():\n    connection_config = ConnectionPoolConfig(\n        # Connection limits\n        max_connections=200,\n        max_connections_per_host=50,\n\n        # Timeouts\n        connection_timeout=5.0,\n        request_timeout=30.0,\n        pool_timeout=10.0,\n\n        # Keep-alive settings\n        keep_alive_timeout=75.0,\n        keep_alive_max_requests=1000,\n\n        # SSL/TLS settings\n        ssl_verify=True,\n        ssl_cert_file=None,\n        ssl_key_file=None,\n\n        # Compression\n        enable_compression=True,\n        compression_threshold=1024\n    )\n\n    http_config = HttpClientConfig(\n        connection_pool=connection_config,\n\n        # Default timeouts\n        base_timeout=30.0,\n        connection_timeout=5.0,\n\n        # Resilience patterns\n        enable_circuit_breaker=True,\n        circuit_breaker_config={\n            \"failure_threshold\": 5,\n            \"recovery_timeout\": 60,\n            \"success_threshold\": 3\n        },\n\n        enable_retry_policy=True,\n        retry_policy_config={\n            \"max_attempts\": 3,\n            \"backoff_factor\": 2.0,\n            \"max_delay\": 60.0\n        },\n\n        # Request/Response settings\n        max_response_size=10 * 1024 * 1024,  # 10MB\n        enable_request_compression=True,\n        enable_response_decompression=True,\n\n        # Security\n        allowed_redirect_count=3,\n        trust_env_proxy_settings=True\n    )\n\n    return http_config\n</code></pre>"},{"location":"features/http-service-client/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\u23f0 Background Task Scheduling - Scheduling external API calls</li> <li>\u26a1 Redis Cache Repository - Caching API responses</li> <li>\ud83d\udd27 Dependency Injection - Service registration patterns</li> <li>\ud83d\udcca Enhanced Model Validation - Request/response validation</li> <li>\ud83d\udce8 Event Sourcing - Event-driven external service integration</li> </ul> <p>The HTTP Service Client provides enterprise-grade capabilities for reliable external service communication. Through circuit breakers, retry policies, and comprehensive interception, Mario's Pizzeria can confidently integrate with payment gateways, delivery services, and notification providers while maintaining system resilience and performance.</p>"},{"location":"features/mermaid-diagrams/","title":"\ud83d\udcca Mermaid Diagrams in Documentation","text":"<p>The Neuroglia Python Framework documentation supports Mermaid diagrams for creating visual representations of architecture, workflows, and system interactions.</p>"},{"location":"features/mermaid-diagrams/#overview","title":"\ud83c\udfaf Overview","text":"<p>Mermaid is a powerful diagramming tool that allows you to create diagrams using simple text-based syntax. Our documentation site automatically renders Mermaid diagrams when you include them in markdown files.</p>"},{"location":"features/mermaid-diagrams/#supported-diagram-types","title":"\ud83c\udfd7\ufe0f Supported Diagram Types","text":""},{"location":"features/mermaid-diagrams/#flowcharts","title":"Flowcharts","text":"<p>Perfect for representing decision flows, process flows, and system workflows:</p> <pre><code>graph TD\n    A[User Request] --&gt; B{Authentication}\n    B --&gt;|Valid| C[Route to Controller]\n    B --&gt;|Invalid| D[Return 401]\n    C --&gt; E[Execute Handler]\n    E --&gt; F[Return Response]\n    D --&gt; G[End]\n    F --&gt; G</code></pre>"},{"location":"features/mermaid-diagrams/#sequence-diagrams","title":"Sequence Diagrams","text":"<p>Ideal for showing interaction between components over time:</p> <pre><code>sequenceDiagram\n    participant C as Controller\n    participant M as Mediator\n    participant H as Handler\n    participant R as Repository\n    participant D as Database\n\n    C-&gt;&gt;M: Send Command\n    M-&gt;&gt;H: Route to Handler\n    H-&gt;&gt;R: Query/Save Data\n    R-&gt;&gt;D: Execute SQL\n    D--&gt;&gt;R: Return Result\n    R--&gt;&gt;H: Domain Objects\n    H--&gt;&gt;M: Operation Result\n    M--&gt;&gt;C: Response</code></pre>"},{"location":"features/mermaid-diagrams/#class-diagrams","title":"Class Diagrams","text":"<p>Great for documenting domain models and relationships:</p> <pre><code>classDiagram\n    class Controller {\n        +ServiceProvider service_provider\n        +Mediator mediator\n        +Mapper mapper\n        +process(result) Response\n    }\n\n    class CommandHandler {\n        &lt;&lt;abstract&gt;&gt;\n        +handle_async(command) OperationResult\n    }\n\n    class Entity {\n        +str id\n        +datetime created_at\n        +raise_event(event)\n        +get_uncommitted_events()\n    }\n\n    class Repository {\n        &lt;&lt;interface&gt;&gt;\n        +save_async(entity)\n        +get_by_id_async(id)\n        +delete_async(id)\n    }\n\n    Controller --&gt; CommandHandler : uses\n    CommandHandler --&gt; Entity : manipulates\n    CommandHandler --&gt; Repository : persists through</code></pre>"},{"location":"features/mermaid-diagrams/#architecture-diagrams","title":"Architecture Diagrams","text":"<p>Perfect for system overview and component relationships:</p> <pre><code>graph TB\n    subgraph \"\ud83c\udf10 API Layer\"\n        A[Controllers]\n        B[DTOs]\n        C[Middleware]\n    end\n\n    subgraph \"\ud83d\udcbc Application Layer\"\n        D[Commands/Queries]\n        E[Handlers]\n        F[Services]\n        G[Mediator]\n    end\n\n    subgraph \"\ud83c\udfdb\ufe0f Domain Layer\"\n        H[Entities]\n        I[Value Objects]\n        J[Domain Events]\n        K[Business Rules]\n    end\n\n    subgraph \"\ud83d\udd0c Integration Layer\"\n        L[Repositories]\n        M[External APIs]\n        N[Database]\n        O[Event Bus]\n    end\n\n    A --&gt; G\n    G --&gt; E\n    E --&gt; H\n    E --&gt; L\n    L --&gt; N\n    E --&gt; O\n\n    style A fill:#e1f5fe\n    style G fill:#f3e5f5\n    style H fill:#e8f5e8\n    style L fill:#fff3e0</code></pre>"},{"location":"features/mermaid-diagrams/#state-diagrams","title":"State Diagrams","text":"<p>Useful for modeling entity lifecycle and business processes:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; Draft\n    Draft --&gt; Submitted : submit()\n    Submitted --&gt; Approved : approve()\n    Submitted --&gt; Rejected : reject()\n    Rejected --&gt; Draft : revise()\n    Approved --&gt; Published : publish()\n    Published --&gt; Archived : archive()\n    Archived --&gt; [*]\n\n    state Submitted {\n        [*] --&gt; PendingReview\n        PendingReview --&gt; InReview : assign_reviewer()\n        InReview --&gt; ReviewComplete : complete_review()\n    }</code></pre>"},{"location":"features/mermaid-diagrams/#usage-in-documentation","title":"\ud83d\ude80 Usage in Documentation","text":""},{"location":"features/mermaid-diagrams/#basic-syntax","title":"Basic Syntax","text":"<p>To include a Mermaid diagram in your documentation:</p> <pre><code>```mermaid\ngraph TD\n    A[Start] --&gt; B[Process]\n    B --&gt; C[End]\n```\n</code></pre>"},{"location":"features/mermaid-diagrams/#best-practices","title":"Best Practices","text":"<ol> <li>Use Descriptive Labels: Make node labels clear and meaningful</li> <li>Consistent Styling: Use subgraphs for logical grouping</li> <li>Appropriate Diagram Types: Choose the right diagram for your content</li> <li>Keep It Simple: Don't overcomplicate diagrams</li> <li>Use Colors Wisely: Leverage styling for emphasis</li> </ol>"},{"location":"features/mermaid-diagrams/#advanced-styling","title":"Advanced Styling","text":"<p>You can add custom styling to your diagrams:</p> <pre><code>graph TD\n    A[API Request] --&gt; B[Authentication]\n    B --&gt; C[Authorization]\n    C --&gt; D[Business Logic]\n    D --&gt; E[Data Access]\n    E --&gt; F[Response]\n\n    classDef apiStyle fill:#e3f2fd,stroke:#1976d2,stroke-width:2px\n    classDef processStyle fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\n    classDef dataStyle fill:#e8f5e8,stroke:#388e3c,stroke-width:2px\n\n    class A,F apiStyle\n    class B,C,D processStyle\n    class E dataStyle</code></pre>"},{"location":"features/mermaid-diagrams/#configuration","title":"\ud83d\udd27 Configuration","text":"<p>The documentation site is configured with:</p> <ul> <li>Theme: Auto (follows system dark/light mode)</li> <li>Primary Color: Blue (#1976d2) matching Material theme</li> <li>Auto-refresh: Diagrams update automatically during development</li> <li>High DPI: Support for crisp diagrams on retina displays</li> </ul>"},{"location":"features/mermaid-diagrams/#documentation-standards","title":"\ud83d\udcdd Documentation Standards","text":"<p>When adding Mermaid diagrams to documentation:</p> <ol> <li>Always include a text description before the diagram</li> <li>Use consistent terminology across all diagrams</li> <li>Reference framework concepts (Controllers, Handlers, etc.)</li> <li>Include diagrams in relevant sections of feature documentation</li> <li>Test rendering locally before committing</li> </ol>"},{"location":"features/mermaid-diagrams/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>CQRS &amp; Mediation</li> <li>Dependency Injection</li> <li>Sample Applications</li> </ul>"},{"location":"features/mermaid-diagrams/#external-resources","title":"\ud83d\udcda External Resources","text":"<ul> <li>Mermaid Documentation</li> <li>Mermaid Live Editor</li> <li>MkDocs Material</li> </ul>"},{"location":"features/mvc-controllers/","title":"\ud83d\udd0c MVC Controllers","text":"<p>Neuroglia's MVC system provides powerful class-based API development using Mario's Pizzeria as an example, demonstrating real-world controller patterns with automatic discovery, dependency injection, and comprehensive API design.</p>"},{"location":"features/mvc-controllers/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>Pizza Order Management: OrdersController for handling customer orders</li> <li>Menu Administration: MenuController for pizza and topping management</li> <li>Kitchen Operations: KitchenController for order preparation workflow</li> <li>Authentication &amp; Authorization: OAuth integration for staff and customer access</li> <li>Error Handling: Comprehensive error responses and validation</li> <li>API Documentation: Automatic OpenAPI generation with pizzeria examples</li> </ul>"},{"location":"features/mvc-controllers/#controller-foundation","title":"\ud83c\udfd7\ufe0f Controller Foundation","text":""},{"location":"features/mvc-controllers/#pizza-order-controller","title":"Pizza Order Controller","text":"<p>The main controller for customer interactions at Mario's Pizzeria:</p> <pre><code>from neuroglia.mvc.controller_base import ControllerBase\nfrom neuroglia.dependency_injection.service_provider import ServiceProviderBase\nfrom neuroglia.mapping.mapper import Mapper\nfrom neuroglia.mediation.mediator import Mediator\nfrom classy_fastapi.decorators import get, post, put, delete\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import HTTPBearer\nfrom typing import List, Optional\nfrom datetime import date\n\nclass OrdersController(ControllerBase):\n    \"\"\"Controller for managing pizza orders at Mario's Pizzeria\"\"\"\n\n    def __init__(self,\n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n        self.security = HTTPBearer(auto_error=False)\n\n    @get(\"/\",\n         response_model=List[OrderDto],\n         summary=\"Get customer orders\",\n         description=\"Retrieve orders for authenticated customer\")\n    async def get_my_orders(self,\n                            token: str = Depends(HTTPBearer()),\n                            limit: int = 10) -&gt; List[OrderDto]:\n        \"\"\"Get orders for authenticated customer\"\"\"\n        try:\n            # Validate customer token and get customer info\n            customer_info = await self._validate_customer_token(token.credentials)\n\n            # Query customer's orders\n            query = GetOrdersByCustomerQuery(\n                customer_phone=customer_info.phone,\n                limit=limit\n            )\n            result = await self.mediator.execute_async(query)\n\n            return self.process(result)\n\n        except Exception as e:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid authentication token\"\n            )\n\n    @get(\"/{order_id}\",\n         response_model=OrderDto,\n         summary=\"Get specific order\",\n         description=\"Get details of a specific pizza order\")\n    async def get_order(self,\n                        order_id: str,\n                        token: str = Depends(HTTPBearer())) -&gt; OrderDto:\n        \"\"\"Get specific order details\"\"\"\n        # Validate customer access to this order\n        customer_info = await self._validate_customer_token(token.credentials)\n\n        query = GetOrderByIdQuery(\n            order_id=order_id,\n            customer_phone=customer_info.phone  # Ensure customer owns order\n        )\n        result = await self.mediator.execute_async(query)\n\n        return self.process(result)\n\n    @post(\"/\",\n          response_model=OrderDto,\n          status_code=201,\n          summary=\"Place pizza order\",\n          description=\"Place a new pizza order with customer details and pizza selection\")\n    async def place_order(self,\n                          order_request: PlaceOrderDto,\n                          token: Optional[str] = Depends(HTTPBearer(auto_error=False))) -&gt; OrderDto:\n        \"\"\"Place a new pizza order\"\"\"\n        try:\n            # If token provided, use customer info; otherwise use order details\n            customer_info = None\n            if token:\n                customer_info = await self._validate_customer_token(token.credentials)\n\n            # Create place order command\n            command = PlaceOrderCommand(\n                customer_name=customer_info.name if customer_info else order_request.customer_name,\n                customer_phone=customer_info.phone if customer_info else order_request.customer_phone,\n                customer_address=order_request.customer_address,\n                pizzas=order_request.pizzas,\n                payment_method=order_request.payment_method,\n                special_instructions=order_request.special_instructions\n            )\n\n            result = await self.mediator.execute_async(command)\n            return self.process(result)\n\n        except ValidationError as e:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=f\"Invalid order data: {str(e)}\"\n            )\n        except Exception as e:\n            raise HTTPException(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                detail=\"Failed to place order. Please try again.\"\n            )\n\n    @put(\"/{order_id}/cancel\",\n         response_model=OrderDto,\n         summary=\"Cancel order\",\n         description=\"Cancel a pizza order if it hasn't started preparation\")\n    async def cancel_order(self,\n                           order_id: str,\n                           cancellation_request: CancelOrderDto,\n                           token: str = Depends(HTTPBearer())) -&gt; OrderDto:\n        \"\"\"Cancel an existing order\"\"\"\n        customer_info = await self._validate_customer_token(token.credentials)\n\n        command = CancelOrderCommand(\n            order_id=order_id,\n            customer_phone=customer_info.phone,\n            cancellation_reason=cancellation_request.reason\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @get(\"/{order_id}/status\",\n         response_model=OrderStatusDto,\n         summary=\"Get order status\",\n         description=\"Get current status and estimated ready time for order\")\n    async def get_order_status(self,\n                               order_id: str,\n                               token: str = Depends(HTTPBearer())) -&gt; OrderStatusDto:\n        \"\"\"Get order status and tracking information\"\"\"\n        customer_info = await self._validate_customer_token(token.credentials)\n\n        query = GetOrderStatusQuery(\n            order_id=order_id,\n            customer_phone=customer_info.phone\n        )\n\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    async def _validate_customer_token(self, token: str) -&gt; CustomerInfo:\n        \"\"\"Validate customer authentication token\"\"\"\n        # In production, this would validate JWT token\n        # For demo purposes, we'll use a simple validation\n        query = ValidateCustomerTokenQuery(token=token)\n        result = await self.mediator.execute_async(query)\n\n        if not result.is_success:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid or expired token\"\n            )\n\n        return result.data\n</code></pre>"},{"location":"features/mvc-controllers/#menu-management-controller","title":"Menu Management Controller","text":"<pre><code>class MenuController(ControllerBase):\n    \"\"\"Controller for managing Mario's Pizzeria menu\"\"\"\n\n    def __init__(self,\n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n    @get(\"/pizzas\",\n         response_model=List[PizzaDto],\n         summary=\"Get pizza menu\",\n         description=\"Get all available pizzas organized by category\")\n    async def get_menu(self,\n                       category: Optional[str] = Query(None, description=\"Filter by pizza category\"),\n                       available_only: bool = Query(True, description=\"Show only available pizzas\")) -&gt; List[PizzaDto]:\n        \"\"\"Get pizza menu with optional filtering\"\"\"\n        query = GetMenuQuery(\n            category=category,\n            available_only=available_only\n        )\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/pizzas/{pizza_id}\",\n         response_model=PizzaDto,\n         summary=\"Get pizza details\",\n         description=\"Get detailed information about a specific pizza\")\n    async def get_pizza(self, pizza_id: str) -&gt; PizzaDto:\n        \"\"\"Get specific pizza details\"\"\"\n        query = GetPizzaByIdQuery(pizza_id=pizza_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/categories\",\n         response_model=List[str],\n         summary=\"Get pizza categories\",\n         description=\"Get all available pizza categories\")\n    async def get_categories(self) -&gt; List[str]:\n        \"\"\"Get all pizza categories\"\"\"\n        query = GetPizzaCategoriesQuery()\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/toppings\",\n         response_model=List[ToppingDto],\n         summary=\"Get available toppings\",\n         description=\"Get all available pizza toppings with prices\")\n    async def get_toppings(self,\n                           vegetarian_only: bool = Query(False, description=\"Show only vegetarian toppings\")) -&gt; List[ToppingDto]:\n        \"\"\"Get available toppings\"\"\"\n        query = GetToppingsQuery(vegetarian_only=vegetarian_only)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    # Admin endpoints (require staff authentication)\n    @post(\"/pizzas\",\n          response_model=PizzaDto,\n          status_code=201,\n          summary=\"Add new pizza (Staff Only)\",\n          description=\"Add a new pizza to the menu\")\n    async def add_pizza(self,\n                        pizza_request: CreatePizzaDto,\n                        staff_token: str = Depends(HTTPBearer())) -&gt; PizzaDto:\n        \"\"\"Add new pizza to menu (staff only)\"\"\"\n        await self._validate_staff_token(staff_token.credentials, required_role=\"manager\")\n\n        command = CreatePizzaCommand(\n            name=pizza_request.name,\n            description=pizza_request.description,\n            category=pizza_request.category,\n            base_price=pizza_request.base_price,\n            available_toppings=pizza_request.available_toppings,\n            preparation_time_minutes=pizza_request.preparation_time_minutes,\n            is_seasonal=pizza_request.is_seasonal\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @put(\"/pizzas/{pizza_id}/availability\",\n         response_model=PizzaDto,\n         summary=\"Update pizza availability (Staff Only)\",\n         description=\"Mark pizza as available or sold out\")\n    async def update_pizza_availability(self,\n                                        pizza_id: str,\n                                        availability_request: UpdateAvailabilityDto,\n                                        staff_token: str = Depends(HTTPBearer())) -&gt; PizzaDto:\n        \"\"\"Update pizza availability\"\"\"\n        await self._validate_staff_token(staff_token.credentials, required_role=\"staff\")\n\n        command = UpdatePizzaAvailabilityCommand(\n            pizza_id=pizza_id,\n            is_available=availability_request.is_available,\n            reason=availability_request.reason\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#kitchen-operations-controller","title":"Kitchen Operations Controller","text":"<pre><code>class KitchenController(ControllerBase):\n    \"\"\"Controller for kitchen operations and order management\"\"\"\n\n    def __init__(self,\n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n    @get(\"/queue\",\n         response_model=List[KitchenOrderDto],\n         summary=\"Get kitchen queue\",\n         description=\"Get orders in kitchen queue ordered by priority\")\n    async def get_kitchen_queue(self,\n                                staff_token: str = Depends(HTTPBearer())) -&gt; List[KitchenOrderDto]:\n        \"\"\"Get orders in kitchen preparation queue\"\"\"\n        await self._validate_staff_token(staff_token.credentials, required_role=\"kitchen\")\n\n        query = GetKitchenQueueQuery(\n            statuses=[\"received\", \"preparing\", \"cooking\"]\n        )\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @put(\"/orders/{order_id}/status\",\n         response_model=OrderDto,\n         summary=\"Update order status\",\n         description=\"Update order status in kitchen workflow\")\n    async def update_order_status(self,\n                                  order_id: str,\n                                  status_update: UpdateOrderStatusDto,\n                                  staff_token: str = Depends(HTTPBearer())) -&gt; OrderDto:\n        \"\"\"Update order status (kitchen staff only)\"\"\"\n        staff_info = await self._validate_staff_token(staff_token.credentials, required_role=\"kitchen\")\n\n        command = UpdateOrderStatusCommand(\n            order_id=order_id,\n            new_status=status_update.status,\n            updated_by=staff_info.staff_id,\n            notes=status_update.notes,\n            estimated_ready_time=status_update.estimated_ready_time\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @post(\"/orders/{order_id}/pizzas/{pizza_index}/start\",\n          response_model=OrderDto,\n          summary=\"Start pizza preparation\",\n          description=\"Mark pizza as started in preparation\")\n    async def start_pizza(self,\n                          order_id: str,\n                          pizza_index: int,\n                          staff_token: str = Depends(HTTPBearer())) -&gt; OrderDto:\n        \"\"\"Start pizza preparation\"\"\"\n        staff_info = await self._validate_staff_token(staff_token.credentials, required_role=\"kitchen\")\n\n        command = StartPizzaPreparationCommand(\n            order_id=order_id,\n            pizza_index=pizza_index,\n            chef_id=staff_info.staff_id\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @post(\"/orders/{order_id}/pizzas/{pizza_index}/complete\",\n          response_model=OrderDto,\n          summary=\"Complete pizza preparation\",\n          description=\"Mark pizza as completed\")\n    async def complete_pizza(self,\n                             order_id: str,\n                             pizza_index: int,\n                             completion_request: CompletePizzaDto,\n                             staff_token: str = Depends(HTTPBearer())) -&gt; OrderDto:\n        \"\"\"Complete pizza preparation\"\"\"\n        staff_info = await self._validate_staff_token(staff_token.credentials, required_role=\"kitchen\")\n\n        command = CompletePizzaPreparationCommand(\n            order_id=order_id,\n            pizza_index=pizza_index,\n            chef_id=staff_info.staff_id,\n            quality_notes=completion_request.quality_notes\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @get(\"/performance\",\n         response_model=KitchenPerformanceDto,\n         summary=\"Get kitchen performance metrics\",\n         description=\"Get kitchen performance analytics\")\n    async def get_performance_metrics(self,\n                                      start_date: date = Query(description=\"Start date for metrics\"),\n                                      end_date: date = Query(description=\"End date for metrics\"),\n                                      staff_token: str = Depends(HTTPBearer())) -&gt; KitchenPerformanceDto:\n        \"\"\"Get kitchen performance metrics\"\"\"\n        await self._validate_staff_token(staff_token.credentials, required_role=\"manager\")\n\n        query = GetKitchenPerformanceQuery(\n            start_date=start_date,\n            end_date=end_date\n        )\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    async def _validate_staff_token(self, token: str, required_role: str) -&gt; StaffInfo:\n        \"\"\"Validate staff authentication and role\"\"\"\n        query = ValidateStaffTokenQuery(\n            token=token,\n            required_role=required_role\n        )\n        result = await self.mediator.execute_async(query)\n\n        if not result.is_success:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=f\"Insufficient permissions. Required role: {required_role}\"\n            )\n\n        return result.data\n</code></pre> <pre><code>class ReportsController(ControllerBase):\n    \"\"\"Controller for pizzeria analytics and reporting\"\"\"\n\n    @get(\"/orders\",\n         response_model=List[OrderReportDto],\n         summary=\"Get order reports\",\n         description=\"Get filtered order data for reporting\")\n    async def get_order_reports(self,\n                                start_date: date = Query(description=\"Report start date\"),\n                                end_date: date = Query(description=\"Report end date\"),\n                                customer_phone: Optional[str] = Query(None, description=\"Filter by customer\"),\n                                status: Optional[str] = Query(None, description=\"Filter by order status\"),\n                                min_amount: Optional[float] = Query(None, ge=0, description=\"Minimum order amount\"),\n                                max_amount: Optional[float] = Query(None, ge=0, description=\"Maximum order amount\"),\n                                limit: int = Query(100, ge=1, le=1000, description=\"Maximum results to return\"),\n                                offset: int = Query(0, ge=0, description=\"Number of results to skip\"),\n                                staff_token: str = Depends(HTTPBearer())) -&gt; List[OrderReportDto]:\n        \"\"\"Get order reports with advanced filtering\"\"\"\n        await self._validate_staff_token(staff_token.credentials, required_role=\"manager\")\n\n        query = GetOrderReportsQuery(\n            start_date=start_date,\n            end_date=end_date,\n            customer_phone=customer_phone,\n            status=status,\n            min_amount=min_amount,\n            max_amount=max_amount,\n            limit=limit,\n            offset=offset\n        )\n\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/revenue\",\n         response_model=RevenueReportDto,\n         summary=\"Get revenue analytics\",\n         description=\"Get revenue breakdown and analytics\")\n    async def get_revenue_report(self,\n                                 period: str = Query(\"daily\", regex=\"^(daily|weekly|monthly)$\"),\n                                 start_date: date = Query(description=\"Analysis start date\"),\n                                 end_date: date = Query(description=\"Analysis end date\"),\n                                 staff_token: str = Depends(HTTPBearer())) -&gt; RevenueReportDto:\n        \"\"\"Get revenue analytics by period\"\"\"\n        await self._validate_staff_token(staff_token.credentials, required_role=\"manager\")\n\n        query = GetRevenueAnalyticsQuery(\n            period=period,\n            start_date=start_date,\n            end_date=end_date\n        )\n\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#request-validation-and-dtos","title":"Request Validation and DTOs","text":"<p>Comprehensive validation for pizzeria data:</p> <pre><code>\"\"\"Get users with filtering and pagination\"\"\"\n\n        query = GetUsersQuery(\n            department=department,\n            active_only=active_only,\n            page=page,\n            page_size=page_size\n        )\n\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#request-body-validation","title":"Request Body Validation","text":"<p>Use Pydantic models for request validation:</p> <pre><code>from pydantic import BaseModel, Field, EmailStr\nfrom typing import Optional\n\nclass CreateUserDto(BaseModel):\n    email: EmailStr = Field(..., description=\"User's email address\")\n    first_name: str = Field(..., min_length=1, max_length=50, description=\"First name\")\n    last_name: str = Field(..., min_length=1, max_length=50, description=\"Last name\")\n    department: Optional[str] = Field(None, max_length=100, description=\"Department\")\n\n    class Config:\n        schema_extra = {\n            \"example\": {\n                \"email\": \"john.doe@company.com\",\n                \"first_name\": \"John\",\n                \"last_name\": \"Doe\",\n                \"department\": \"Engineering\"\n            }\n        }\n\nclass UsersController(ControllerBase):\n\n    @post(\"/\", response_model=UserDto, status_code=status.HTTP_201_CREATED)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        \"\"\"Create a new user\"\"\"\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#file-uploads","title":"File Uploads","text":"<p>Handle file uploads:</p> <pre><code>from fastapi import UploadFile, File\n\nclass UsersController(ControllerBase):\n\n    @post(\"/{user_id}/avatar\", response_model=UserDto)\n    async def upload_avatar(self,\n                           user_id: str,\n                           file: UploadFile = File(..., description=\"Avatar image\")) -&gt; UserDto:\n        \"\"\"Upload user avatar\"\"\"\n\n        # Validate file type\n        if not file.content_type.startswith('image/'):\n            return self.bad_request(\"File must be an image\")\n\n        # Create command\n        command = UploadUserAvatarCommand(\n            user_id=user_id,\n            file_name=file.filename,\n            file_content=await file.read(),\n            content_type=file.content_type\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#response-headers","title":"Response Headers","text":"<p>Set custom response headers:</p> <pre><code>from fastapi import Response\n\nclass UsersController(ControllerBase):\n\n    @get(\"/{user_id}/export\", response_class=Response)\n    async def export_user_data(self, user_id: str, response: Response):\n        \"\"\"Export user data as CSV\"\"\"\n\n        query = ExportUserDataQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n\n        if not result.is_success:\n            return self.process(result)\n\n        # Set CSV headers\n        response.headers[\"Content-Type\"] = \"text/csv\"\n        response.headers[\"Content-Disposition\"] = f\"attachment; filename=user_{user_id}.csv\"\n\n        return result.data\n</code></pre>"},{"location":"features/mvc-controllers/#controller-configuration","title":"\ud83c\udfaa Controller Configuration","text":""},{"location":"features/mvc-controllers/#custom-routing","title":"Custom Routing","text":"<p>Customize controller routing:</p> <pre><code>class UsersController(ControllerBase):\n    def __init__(self, service_provider, mapper, mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n        # Custom prefix and tags\n        self.router.prefix = \"/users\"\n        self.router.tags = [\"User Management\"]\n\n        # Add custom middleware to this controller\n        self.router.middleware(\"http\")(self.auth_middleware)\n\n    async def auth_middleware(self, request, call_next):\n        \"\"\"Custom authentication middleware for this controller\"\"\"\n        # Authentication logic\n        response = await call_next(request)\n        return response\n</code></pre>"},{"location":"features/mvc-controllers/#nested-controllers","title":"Nested Controllers","text":"<p>Create hierarchical resource structures:</p> <pre><code>class UserAccountsController(ControllerBase):\n    \"\"\"Handles user account operations\"\"\"\n\n    def __init__(self, service_provider, mapper, mediator):\n        super().__init__(service_provider, mapper, mediator)\n        self.router.prefix = \"/users/{user_id}/accounts\"\n\n    @get(\"/\", response_model=List[AccountDto])\n    async def get_user_accounts(self, user_id: str) -&gt; List[AccountDto]:\n        \"\"\"Get all accounts for a user\"\"\"\n        query = GetUserAccountsQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @post(\"/\", response_model=AccountDto, status_code=status.HTTP_201_CREATED)\n    async def create_account(self, user_id: str, create_account_dto: CreateAccountDto) -&gt; AccountDto:\n        \"\"\"Create a new account for a user\"\"\"\n        command = self.mapper.map(create_account_dto, CreateAccountCommand)\n        command.user_id = user_id\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#error-handling","title":"\ud83d\udee1\ufe0f Error Handling","text":""},{"location":"features/mvc-controllers/#built-in-error-responses","title":"Built-in Error Responses","text":"<p>Controllers include standard error responses:</p> <pre><code>class UsersController(ControllerBase):\n\n    @get(\"/{user_id}\",\n         response_model=UserDto,\n         responses=ControllerBase.error_responses)  # Adds 400, 404, 500 responses\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        \"\"\"Get user by ID\"\"\"\n        query = GetUserByIdQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)  # Automatically handles error responses\n</code></pre>"},{"location":"features/mvc-controllers/#custom-error-handling","title":"Custom Error Handling","text":"<p>Add custom error handling:</p> <pre><code>from fastapi import HTTPException\n\nclass UsersController(ControllerBase):\n\n    @post(\"/\", response_model=UserDto, status_code=status.HTTP_201_CREATED)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        \"\"\"Create a new user\"\"\"\n        try:\n            command = self.mapper.map(create_user_dto, CreateUserCommand)\n            result = await self.mediator.execute_async(command)\n            return self.process(result)\n\n        except EmailAlreadyExistsException:\n            raise HTTPException(\n                status_code=status.HTTP_409_CONFLICT,\n                detail=\"A user with this email already exists\"\n            )\n        except ValidationException as ex:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=str(ex)\n            )\n</code></pre>"},{"location":"features/mvc-controllers/#global-error-handling","title":"Global Error Handling","text":"<p>Use middleware for global error handling:</p> <pre><code>from neuroglia.hosting.web import ExceptionHandlingMiddleware\n\n# In main.py\napp.add_middleware(ExceptionHandlingMiddleware, service_provider=app.services)\n</code></pre>"},{"location":"features/mvc-controllers/#authentication-authorization","title":"\ud83d\udd10 Authentication &amp; Authorization","text":"<p>For comprehensive OAuth 2.0, OpenID Connect, and JWT implementation with controllers, see the OAuth, OIDC &amp; JWT Reference.</p>"},{"location":"features/mvc-controllers/#dependency-injection-for-auth","title":"Dependency Injection for Auth","text":"<p>Inject authentication services:</p> <pre><code>from fastapi import Depends\nfrom neuroglia.security import IAuthService, AuthUser\n\nclass UsersController(ControllerBase):\n\n    def __init__(self,\n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator,\n                 auth_service: IAuthService):\n        super().__init__(service_provider, mapper, mediator)\n        self.auth_service = auth_service\n\n    @get(\"/profile\", response_model=UserDto)\n    async def get_current_user(self,\n                              current_user: AuthUser = Depends(auth_service.get_current_user)) -&gt; UserDto:\n        \"\"\"Get current user's profile\"\"\"\n        query = GetUserByIdQuery(user_id=current_user.user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#role-based-authorization","title":"Role-based Authorization","text":"<p>Implement role-based access control:</p> <pre><code>from neuroglia.security import require_role\n\nclass UsersController(ControllerBase):\n\n    @get(\"/\", response_model=List[UserDto])\n    @require_role(\"admin\")  # Custom decorator\n    async def get_all_users(self) -&gt; List[UserDto]:\n        \"\"\"Get all users (admin only)\"\"\"\n        query = GetAllUsersQuery()\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @delete(\"/{user_id}\")\n    @require_role([\"admin\", \"manager\"])  # Multiple roles\n    async def delete_user(self, user_id: str):\n        \"\"\"Delete a user (admin or manager only)\"\"\"\n        command = DeleteUserCommand(user_id=user_id)\n        result = await self.mediator.execute_async(command)\n        self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#response-processing","title":"\ud83d\udcca Response Processing","text":""},{"location":"features/mvc-controllers/#the-process-method","title":"The <code>process</code> Method","text":"<p>The <code>process</code> method handles <code>OperationResult</code> objects automatically:</p> <pre><code># OperationResult with data\nresult = OperationResult.success(user_dto)\nreturn self.process(result)  # Returns user_dto with 200 status\n\n# OperationResult with error\nresult = OperationResult.not_found(\"User not found\")\nreturn self.process(result)  # Raises HTTPException with 404 status\n\n# OperationResult created\nresult = OperationResult.created(user_dto)\nreturn self.process(result)  # Returns user_dto with 201 status\n</code></pre>"},{"location":"features/mvc-controllers/#custom-response-processing","title":"Custom Response Processing","text":"<p>Override response processing for special cases:</p> <pre><code>class UsersController(ControllerBase):\n\n    @get(\"/{user_id}\", response_model=UserDto)\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        \"\"\"Get user by ID\"\"\"\n        query = GetUserByIdQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n\n        # Custom processing\n        if not result.is_success:\n            if result.status_code == 404:\n                # Log the attempt\n                self.logger.warning(f\"Attempt to access non-existent user: {user_id}\")\n            return self.process(result)\n\n        # Add custom headers for successful responses\n        response = self.process(result)\n        # Custom logic here\n        return response\n</code></pre>"},{"location":"features/mvc-controllers/#testing-controllers","title":"\ud83e\uddea Testing Controllers","text":""},{"location":"features/mvc-controllers/#unit-testing","title":"Unit Testing","text":"<p>Test controllers with mocked dependencies:</p> <pre><code>import pytest\nfrom unittest.mock import Mock, AsyncMock\n\n@pytest.mark.asyncio\nasync def test_get_user_success():\n    # Arrange\n    mock_mediator = Mock()\n    mock_mediator.execute_async = AsyncMock(return_value=OperationResult.success(test_user_dto))\n\n    controller = UsersController(\n        service_provider=mock_service_provider,\n        mapper=mock_mapper,\n        mediator=mock_mediator\n    )\n\n    # Act\n    result = await controller.get_user(\"user123\")\n\n    # Assert\n    assert result == test_user_dto\n    mock_mediator.execute_async.assert_called_once()\n</code></pre>"},{"location":"features/mvc-controllers/#integration-testing","title":"Integration Testing","text":"<p>Test controllers with TestClient:</p> <pre><code>from fastapi.testclient import TestClient\n\ndef test_create_user_integration():\n    # Arrange\n    client = TestClient(app)\n    user_data = {\n        \"email\": \"test@example.com\",\n        \"first_name\": \"John\",\n        \"last_name\": \"Doe\"\n    }\n\n    # Act\n    response = client.post(\"/api/v1/users\", json=user_data)\n\n    # Assert\n    assert response.status_code == 201\n\n    created_user = response.json()\n    assert created_user[\"email\"] == user_data[\"email\"]\n    assert \"id\" in created_user\n</code></pre>"},{"location":"features/mvc-controllers/#api-testing","title":"API Testing","text":"<p>Test the complete API flow:</p> <pre><code>def test_user_crud_flow():\n    client = TestClient(app)\n\n    # Create user\n    create_response = client.post(\"/api/v1/users\", json=test_user_data)\n    assert create_response.status_code == 201\n    user = create_response.json()\n    user_id = user[\"id\"]\n\n    # Get user\n    get_response = client.get(f\"/api/v1/users/{user_id}\")\n    assert get_response.status_code == 200\n    assert get_response.json()[\"id\"] == user_id\n\n    # Update user\n    update_data = {\"first_name\": \"Jane\"}\n    update_response = client.put(f\"/api/v1/users/{user_id}\", json=update_data)\n    assert update_response.status_code == 200\n    assert update_response.json()[\"first_name\"] == \"Jane\"\n\n    # Delete user\n    delete_response = client.delete(f\"/api/v1/users/{user_id}\")\n    assert delete_response.status_code == 204\n\n    # Verify deletion\n    get_deleted_response = client.get(f\"/api/v1/users/{user_id}\")\n    assert get_deleted_response.status_code == 404\n</code></pre>"},{"location":"features/mvc-controllers/#best-practices","title":"\ud83d\ude80 Best Practices","text":""},{"location":"features/mvc-controllers/#1-keep-controllers-thin","title":"1. Keep Controllers Thin","text":"<p>Controllers should delegate to the application layer:</p> <pre><code># Good - Thin controller\nclass UsersController(ControllerBase):\n    @post(\"/\", response_model=UserDto)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n# Avoid - Business logic in controller\nclass UsersController(ControllerBase):\n    @post(\"/\", response_model=UserDto)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        # Validate email\n        if not self.is_valid_email(create_user_dto.email):\n            raise HTTPException(400, \"Invalid email\")\n\n        # Check if user exists\n        existing = await self.user_repo.get_by_email(create_user_dto.email)\n        if existing:\n            raise HTTPException(409, \"User exists\")\n\n        # Create user\n        user = User(...)\n        # ... more business logic\n</code></pre>"},{"location":"features/mvc-controllers/#2-use-dtos-for-api-contracts","title":"2. Use DTOs for API Contracts","text":"<p>Always use DTOs to define your API contracts:</p> <pre><code># API DTOs\nclass CreateUserDto(BaseModel):\n    email: str\n    first_name: str\n    last_name: str\n\nclass UserDto(BaseModel):\n    id: str\n    email: str\n    first_name: str\n    last_name: str\n    created_at: datetime\n\n# Domain entities stay separate\nclass User(Entity[str]):\n    def __init__(self, email: str, first_name: str, last_name: str):\n        # Domain logic\n        pass\n</code></pre>"},{"location":"features/mvc-controllers/#3-consistent-error-handling","title":"3. Consistent Error Handling","text":"<p>Use consistent patterns for error handling:</p> <pre><code>class UsersController(ControllerBase):\n\n    @get(\"/{user_id}\",\n         response_model=UserDto,\n         responses={\n             404: {\"description\": \"User not found\"},\n             400: {\"description\": \"Invalid user ID format\"}\n         })\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        # Validate input format\n        if not self.is_valid_uuid(user_id):\n            return self.bad_request(\"Invalid user ID format\")\n\n        # Execute query\n        query = GetUserByIdQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n\n        # Process will handle 404 automatically\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#4-document-your-apis","title":"4. Document Your APIs","text":"<p>Provide comprehensive API documentation:</p> <pre><code>class UsersController(ControllerBase):\n\n    @post(\"/\",\n          response_model=UserDto,\n          status_code=status.HTTP_201_CREATED,\n          summary=\"Create a new user\",\n          description=\"Creates a new user account in the system\",\n          response_description=\"The created user\",\n          tags=[\"User Management\"])\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        \"\"\"\n        Create a new user account.\n\n        - **email**: User's email address (must be unique)\n        - **first_name**: User's first name\n        - **last_name**: User's last name\n\n        Returns the created user with generated ID and timestamps.\n        \"\"\"\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#5-version-your-apis","title":"5. Version Your APIs","text":"<p>Plan for API versioning:</p> <pre><code># v1 controller\nclass V1UsersController(ControllerBase):\n    def __init__(self, service_provider, mapper, mediator):\n        super().__init__(service_provider, mapper, mediator)\n```python\nfrom neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.mvc import ControllerDiscovery\n\ndef create_pizzeria_app():\n    \"\"\"Configure Mario's Pizzeria application with controllers\"\"\"\n    builder = WebApplicationBuilder()\n\n    # Configure services\n    builder.services.add_mediator()\n    builder.services.add_auto_mapper()\n\n    # Add controllers with automatic discovery\n    builder.services.add_controllers([\n        \"api.controllers.orders_controller\",\n        \"api.controllers.menu_controller\",\n        \"api.controllers.kitchen_controller\",\n        \"api.controllers.reports_controller\",\n        \"api.controllers.auth_controller\"\n    ])\n\n    # Build application\n    app = builder.build()\n\n    # Configure controller routes with prefixes\n    app.include_router(OrdersController().router, prefix=\"/api/orders\", tags=[\"Orders\"])\n    app.include_router(MenuController().router, prefix=\"/api/menu\", tags=[\"Menu\"])\n    app.include_router(KitchenController().router, prefix=\"/api/kitchen\", tags=[\"Kitchen\"])\n    app.include_router(ReportsController().router, prefix=\"/api/reports\", tags=[\"Reports\"])\n    app.include_router(AuthController().router, prefix=\"/api/auth\", tags=[\"Authentication\"])\n\n    # Add exception handlers\n    app.add_exception_handler(PizzeriaException, pizzeria_exception_handler)\n    app.add_exception_handler(RequestValidationError, validation_exception_handler)\n\n    return app\n\n# Environment-specific controller registration\ndef configure_development_controllers(builder: WebApplicationBuilder):\n    \"\"\"Add development-specific controllers\"\"\"\n    # Add mock data controller for testing\n    builder.services.add_controller(MockDataController)\n\ndef configure_production_controllers(builder: WebApplicationBuilder):\n    \"\"\"Add production-specific controllers\"\"\"\n    # Add monitoring and health check controllers\n    builder.services.add_controller(HealthController)\n    builder.services.add_controller(MetricsController)\n</code></pre>"},{"location":"features/mvc-controllers/#controller-middleware-and-interceptors","title":"Controller Middleware and Interceptors","text":"<p>Add cross-cutting concerns to controllers:</p> <pre><code>from fastapi import Request, Response\nfrom fastapi.middleware.base import BaseHTTPMiddleware\nimport time\nimport logging\n\nclass PizzeriaRequestLoggingMiddleware(BaseHTTPMiddleware):\n    \"\"\"Log all pizzeria API requests\"\"\"\n\n    async def dispatch(self, request: Request, call_next):\n        start_time = time.time()\n\n        # Log incoming request\n        logging.info(f\"Incoming {request.method} {request.url}\")\n\n        # Process request\n        response = await call_next(request)\n\n        # Log response\n        process_time = time.time() - start_time\n        logging.info(f\"Completed {request.method} {request.url} - \"\n                    f\"Status: {response.status_code} - \"\n                    f\"Duration: {process_time:.2f}s\")\n\n        return response\n\nclass OrderValidationMiddleware(BaseHTTPMiddleware):\n    \"\"\"Validate order-related requests\"\"\"\n\n    async def dispatch(self, request: Request, call_next):\n        if request.url.path.startswith(\"/api/orders\"):\n            # Add order-specific validation\n            if request.method == \"POST\":\n                # Validate business hours\n                if not self.is_business_hours():\n                    return JSONResponse(\n                        status_code=400,\n                        content={\"error\": \"Pizzeria is currently closed\"}\n                    )\n\n        return await call_next(request)\n\n    def is_business_hours(self) -&gt; bool:\n        \"\"\"Check if pizzeria is open for orders\"\"\"\n        from datetime import datetime\n        now = datetime.now()\n        return 11 &lt;= now.hour &lt;= 22  # Open 11 AM to 10 PM\n\n# Add middleware to application\napp.add_middleware(PizzeriaRequestLoggingMiddleware)\napp.add_middleware(OrderValidationMiddleware)\n</code></pre>"},{"location":"features/mvc-controllers/#controller-testing-patterns","title":"\ud83e\uddea Controller Testing Patterns","text":""},{"location":"features/mvc-controllers/#unit-testing-controllers","title":"Unit Testing Controllers","text":"<p>Test controllers with mocked dependencies:</p> <pre><code>import pytest\nfrom unittest.mock import AsyncMock, Mock\nfrom fastapi.testclient import TestClient\nfrom neuroglia.mediation import OperationResult\n\nclass TestOrdersController:\n    \"\"\"Unit tests for orders controller\"\"\"\n\n    @pytest.fixture\n    def mock_mediator(self):\n        \"\"\"Mock mediator for testing\"\"\"\n        mediator = AsyncMock()\n        return mediator\n\n    @pytest.fixture\n    def orders_controller(self, mock_mediator):\n        \"\"\"Orders controller with mocked dependencies\"\"\"\n        service_provider = Mock()\n        mapper = Mock()\n\n        controller = OrdersController(service_provider, mapper, mock_mediator)\n        return controller\n\n    @pytest.mark.asyncio\n    async def test_place_order_success(self, orders_controller, mock_mediator):\n        \"\"\"Test successful order placement\"\"\"\n        # Arrange\n        order_request = PlaceOrderDto(\n            customer_name=\"John Doe\",\n            customer_phone=\"+1234567890\",\n            customer_address=\"123 Main St\",\n            pizzas=[PizzaOrderDto(name=\"Margherita\", size=\"large\", quantity=1)],\n            payment_method=\"card\"\n        )\n\n        expected_order = OrderDto(\n            id=\"order_123\",\n            customer_name=\"John Doe\",\n            status=\"received\",\n            total_amount=15.99\n        )\n\n        mock_mediator.execute_async.return_value = OperationResult.success(expected_order)\n\n        # Act\n        result = await orders_controller.place_order(order_request)\n\n        # Assert\n        assert result.id == \"order_123\"\n        assert result.customer_name == \"John Doe\"\n        mock_mediator.execute_async.assert_called_once()\n\n    @pytest.mark.asyncio\n    async def test_place_order_validation_error(self, orders_controller, mock_mediator):\n        \"\"\"Test order placement with validation error\"\"\"\n        # Arrange\n        invalid_order = PlaceOrderDto(\n            customer_name=\"\",  # Invalid empty name\n            customer_phone=\"invalid\",  # Invalid phone\n            customer_address=\"\",  # Invalid empty address\n            pizzas=[],  # No pizzas\n            payment_method=\"invalid\"  # Invalid payment method\n        )\n\n        # Act &amp; Assert\n        with pytest.raises(ValidationError):\n            await orders_controller.place_order(invalid_order)\n\n@pytest.mark.integration\nclass TestOrdersControllerIntegration:\n    \"\"\"Integration tests for orders controller\"\"\"\n\n    @pytest.fixture\n    def test_client(self):\n        \"\"\"Test client for integration testing\"\"\"\n        app = create_pizzeria_app()\n        return TestClient(app)\n\n    def test_get_menu_integration(self, test_client):\n        \"\"\"Test menu retrieval integration\"\"\"\n        response = test_client.get(\"/api/menu/pizzas\")\n\n        assert response.status_code == 200\n        menu = response.json()\n        assert isinstance(menu, list)\n\n        # Validate pizza structure\n        if menu:\n            pizza = menu[0]\n            assert \"id\" in pizza\n            assert \"name\" in pizza\n            assert \"base_price\" in pizza\n\n    def test_place_order_integration(self, test_client):\n        \"\"\"Test order placement integration\"\"\"\n        order_data = {\n            \"customer_name\": \"Integration Test Customer\",\n            \"customer_phone\": \"+1234567890\",\n            \"customer_address\": \"123 Test Street, Test City\",\n            \"pizzas\": [\n                {\n                    \"name\": \"Margherita\",\n                    \"size\": \"large\",\n                    \"toppings\": [\"extra_cheese\"],\n                    \"quantity\": 1\n                }\n            ],\n            \"payment_method\": \"card\"\n        }\n\n        response = test_client.post(\"/api/orders/\", json=order_data)\n\n        assert response.status_code == 201\n        order = response.json()\n        assert order[\"customer_name\"] == \"Integration Test Customer\"\n        assert order[\"status\"] == \"received\"\n        assert \"id\" in order\n</code></pre>"},{"location":"features/mvc-controllers/#api-documentation-generation","title":"\ufffd API Documentation Generation","text":""},{"location":"features/mvc-controllers/#openapi-configuration","title":"OpenAPI Configuration","text":"<p>Configure comprehensive API documentation:</p> <pre><code>from fastapi import FastAPI\nfrom fastapi.openapi.utils import get_openapi\n\ndef create_pizzeria_app_with_docs():\n    \"\"\"Create Mario's Pizzeria app with enhanced documentation\"\"\"\n    app = create_pizzeria_app()\n\n    # Custom OpenAPI schema\n    def custom_openapi():\n        if app.openapi_schema:\n            return app.openapi_schema\n\n        openapi_schema = get_openapi(\n            title=\"Mario's Pizzeria API\",\n            version=\"1.0.0\",\n            description=\"\"\"\n            # \ud83c\udf55 Mario's Pizzeria API\n\n            Welcome to Mario's Pizzeria API! This API provides comprehensive\n            functionality for managing pizza orders, menu items, kitchen workflow,\n            and customer interactions.\n\n            ## Features\n\n            - **Order Management**: Place, track, and manage pizza orders\n            - **Menu Administration**: Manage pizzas, toppings, and availability\n            - **Kitchen Workflow**: Handle order preparation and status updates\n            - **Customer Authentication**: Secure customer account management\n            - **Staff Portal**: Role-based access for staff operations\n            - **Analytics**: Revenue and performance reporting\n\n            ## Authentication\n\n            The API uses OAuth 2.0 with JWT tokens:\n\n            - **Customers**: Phone-based OTP authentication\n            - **Staff**: Username/password with role-based permissions\n\n            ## Rate Limiting\n\n            - **Customers**: 100 requests per hour\n            - **Staff**: 500 requests per hour\n            - **Managers**: Unlimited\n            \"\"\",\n            routes=app.routes,\n        )\n\n        # Add custom tags for better organization\n        openapi_schema[\"tags\"] = [\n            {\n                \"name\": \"Orders\",\n                \"description\": \"Customer order management and tracking\"\n            },\n            {\n                \"name\": \"Menu\",\n                \"description\": \"Pizza menu and item management\"\n            },\n            {\n                \"name\": \"Kitchen\",\n                \"description\": \"Kitchen operations and workflow\"\n            },\n            {\n                \"name\": \"Authentication\",\n                \"description\": \"Customer and staff authentication\"\n            },\n            {\n                \"name\": \"Reports\",\n                \"description\": \"Analytics and reporting (Manager only)\"\n            }\n        ]\n\n        # Add security schemes\n        openapi_schema[\"components\"][\"securitySchemes\"] = {\n            \"BearerAuth\": {\n                \"type\": \"http\",\n                \"scheme\": \"bearer\",\n                \"bearerFormat\": \"JWT\"\n            },\n            \"CustomerAuth\": {\n                \"type\": \"oauth2\",\n                \"flows\": {\n                    \"password\": {\n                        \"tokenUrl\": \"/api/auth/customer/login\",\n                        \"scopes\": {\n                            \"customer\": \"Customer order access\"\n                        }\n                    }\n                }\n            },\n            \"StaffAuth\": {\n                \"type\": \"oauth2\",\n                \"flows\": {\n                    \"password\": {\n                        \"tokenUrl\": \"/api/auth/staff/login\",\n                        \"scopes\": {\n                            \"kitchen\": \"Kitchen operations\",\n                            \"manager\": \"Management functions\"\n                        }\n                    }\n                }\n            }\n        }\n\n        app.openapi_schema = openapi_schema\n        return app.openapi_schema\n\n    app.openapi = custom_openapi\n    return app\n</code></pre>"},{"location":"features/mvc-controllers/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started Guide - Complete pizzeria application tutorial</li> <li>CQRS &amp; Mediation - Command and query handlers used in controllers</li> <li>Dependency Injection - Service registration for controller dependencies</li> <li>Data Access - Repository patterns used by controller commands/queries</li> <li>Source Code Naming Conventions - Controller, DTO, and method naming patterns</li> </ul> <p>This documentation demonstrates MVC controller patterns using Mario's Pizzeria as a consistent example throughout the Neuroglia framework. The examples show real-world API design with authentication, validation, error handling, and comprehensive testing.</p>"},{"location":"features/object-mapping/","title":"\ud83c\udfaf Object Mapping","text":"<p>Neuroglia's object mapping system provides powerful and flexible capabilities for transforming objects between types. Whether converting domain entities to DTOs, mapping API requests to commands, or transforming data between layers, the Mapper class handles complex object-to-object conversions with ease.</p> <p>!!! info \"\ud83c\udfaf What You'll Learn\" - Automatic property mapping with convention-based matching - Custom mapping configurations and transformations - Type conversion and validation - Integration with Mario's Pizzeria domain objects</p>"},{"location":"features/object-mapping/#overview","title":"\ud83c\udfaf Overview","text":"<p>Neuroglia's mapping system offers:</p> <ul> <li>\ud83d\udd04 Automatic Mapping - Convention-based property matching with intelligent type conversion</li> <li>\ud83c\udfa8 Custom Configurations - Fine-grained control over property mappings and transformations</li> <li>\ud83d\udccb Mapping Profiles - Reusable mapping configurations organized in profiles</li> <li>\ud83d\udd27 Type Conversion - Built-in converters for common type transformations</li> <li>\ud83d\udc89 DI Integration - Service-based mapper with configurable profiles</li> </ul>"},{"location":"features/object-mapping/#key-benefits","title":"Key Benefits","text":"<ul> <li>Productivity: Eliminate repetitive mapping code with automatic conventions</li> <li>Type Safety: Strongly-typed mappings with compile-time validation</li> <li>Flexibility: Custom transformations for complex mapping scenarios</li> <li>Testability: Easy mocking and testing of mapping logic</li> <li>Performance: Efficient mapping with minimal reflection overhead</li> </ul>"},{"location":"features/object-mapping/#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<pre><code>flowchart TD\n    A[\"\ud83c\udfaf Source Object&lt;br/&gt;Domain Entity\"]\n    B[\"\ud83d\udd04 Mapper&lt;br/&gt;Main Mapping Service\"]\n    C[\"\ud83d\udccb Mapping Profiles&lt;br/&gt;Configuration Sets\"]\n    D[\"\ud83c\udfa8 Type Converters&lt;br/&gt;Custom Transformations\"]\n\n    subgraph \"\ud83d\udd27 Mapping Pipeline\"\n        E[\"Property Matching\"]\n        F[\"Type Conversion\"]\n        G[\"Custom Logic\"]\n        H[\"Validation\"]\n    end\n\n    subgraph \"\ud83c\udfaf Target Types\"\n        I[\"DTOs\"]\n        J[\"Commands\"]\n        K[\"View Models\"]\n        L[\"API Responses\"]\n    end\n\n    A --&gt; B\n    B --&gt; C\n    B --&gt; D\n    B --&gt; E\n    E --&gt; F\n    F --&gt; G\n    G --&gt; H\n\n    H --&gt; I\n    H --&gt; J\n    H --&gt; K\n    H --&gt; L\n\n    style B fill:#e1f5fe,stroke:#0277bd,stroke-width:3px\n    style C fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\n    style D fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px\n\n    classDef pipeline fill:#fff3e0,stroke:#f57c00,stroke-width:2px\n    class E,F,G,H pipeline\n\n    classDef targets fill:#e3f2fd,stroke:#1976d2,stroke-width:1px\n    class I,J,K,L targets</code></pre>"},{"location":"features/object-mapping/#basic-usage-in-marios-pizzeria","title":"\ud83c\udf55 Basic Usage in Mario's Pizzeria","text":""},{"location":"features/object-mapping/#entity-to-dto-mapping","title":"Entity to DTO Mapping","text":"<p>Let's see how Mario's Pizzeria uses mapping for API responses:</p> From samples/mario-pizzeria/domain/entities/<pre><code>from neuroglia.mapping.mapper import Mapper, map_from, map_to\nfrom decimal import Decimal\nfrom datetime import datetime, timezone\nfrom enum import Enum\nfrom typing import Optional\nfrom uuid import uuid4\nfrom pydantic import BaseModel, Field, field_validator\n\n# Domain Entities (from actual Mario's Pizzeria)\nclass PizzaSize(Enum):\n    \"\"\"Pizza size options\"\"\"\n    SMALL = \"small\"\n    MEDIUM = \"medium\"\n    LARGE = \"large\"\n\nclass OrderStatus(Enum):\n    \"\"\"Order lifecycle statuses\"\"\"\n    PENDING = \"pending\"\n    CONFIRMED = \"confirmed\"\n    COOKING = \"cooking\"\n    READY = \"ready\"\n\n@map_from(\"PizzaDto\")\n@map_to(\"PizzaDto\")\nclass Pizza:\n    \"\"\"Pizza entity with sophisticated pricing logic\"\"\"\n\n    def __init__(self, name: str, base_price: Decimal, size: PizzaSize):\n        self.id = str(uuid4())\n        self.name = name\n        self.base_price = base_price\n        self.size = size\n        self.toppings: list[str] = []\n\n    @property\n    def size_multiplier(self) -&gt; Decimal:\n        \"\"\"Size-based pricing multipliers\"\"\"\n        multipliers = {\n            PizzaSize.SMALL: Decimal(\"1.0\"),\n            PizzaSize.MEDIUM: Decimal(\"1.3\"),\n            PizzaSize.LARGE: Decimal(\"1.6\")\n        }\n        return multipliers[self.size]\n\n    @property\n    def topping_price(self) -&gt; Decimal:\n        \"\"\"Calculate total topping cost\"\"\"\n        return Decimal(\"2.50\") * len(self.toppings)\n\n    @property\n    def total_price(self) -&gt; Decimal:\n        \"\"\"Calculate total pizza price with size and toppings\"\"\"\n        return (self.base_price * self.size_multiplier) + self.topping_price\n\n@map_from(\"OrderDto\")\n@map_to(\"OrderDto\")\nclass Order:\n    \"\"\"Order entity with pizzas and status management\"\"\"\n\n    def __init__(self, customer_id: str, estimated_ready_time: Optional[datetime] = None):\n        self.id = str(uuid4())\n        self.customer_id = customer_id\n        self.pizzas: list[Pizza] = []\n        self.status = OrderStatus.PENDING\n        self.order_time = datetime.now(timezone.utc)\n        self.confirmed_time: Optional[datetime] = None\n        self.cooking_started_time: Optional[datetime] = None\n        self.actual_ready_time: Optional[datetime] = None\n        self.estimated_ready_time = estimated_ready_time\n        self.notes: Optional[str] = None\n\n    @property\n    def total_amount(self) -&gt; Decimal:\n        \"\"\"Calculate total order amount\"\"\"\n        return sum((pizza.total_price for pizza in self.pizzas), Decimal(\"0.00\"))\n\n# DTOs for API responses (from actual Mario's Pizzeria)\nclass PizzaDto(BaseModel):\n    \"\"\"DTO for pizza information\"\"\"\n    id: Optional[str] = None\n    name: str = Field(..., min_length=1, max_length=100)\n    size: str = Field(..., description=\"Pizza size: small, medium, or large\")\n    toppings: list[str] = Field(default_factory=list)\n    base_price: Optional[Decimal] = None\n    total_price: Optional[Decimal] = None\n\n    @field_validator(\"size\")\n    @classmethod\n    def validate_size(cls, v):\n        if v not in [\"small\", \"medium\", \"large\"]:\n            raise ValueError(\"Size must be: small, medium, or large\")\n        return v\n\nclass OrderDto(BaseModel):\n    \"\"\"DTO for complete order information\"\"\"\n    id: str\n    customer: Optional[\"CustomerDto\"] = None\n    customer_name: Optional[str] = None\n    customer_phone: Optional[str] = None\n    customer_address: Optional[str] = None\n    pizzas: list[PizzaDto] = Field(default_factory=list)\n    status: str\n    order_time: datetime\n    confirmed_time: Optional[datetime] = None\n    cooking_started_time: Optional[datetime] = None\n    actual_ready_time: Optional[datetime] = None\n    estimated_ready_time: Optional[datetime] = None\n    notes: Optional[str] = None\n    total_amount: Decimal\n    pizza_count: int\n    payment_method: Optional[str] = None\n\n# Using the Mapper with Auto-Mapping Decorators\nclass OrderService:\n    def __init__(self, mapper: Mapper):\n        self.mapper = mapper\n\n    def get_order_dto(self, order: Order, customer_name: str = \"Unknown\") -&gt; OrderDto:\n        \"\"\"Convert domain order to API DTO using auto-mapping\"\"\"\n        # The @map_to decorator on Order entity handles automatic conversion\n        dto = self.mapper.map(order, OrderDto)\n        # Set customer information (since Order only has customer_id)\n        dto.customer_name = customer_name\n        dto.pizza_count = len(order.pizzas)\n        return dto\n\n    def get_pizza_dto(self, pizza: Pizza) -&gt; PizzaDto:\n        \"\"\"Convert domain pizza to API DTO using auto-mapping\"\"\"\n        # The @map_to decorator on Pizza entity handles automatic conversion\n        return self.mapper.map(pizza, PizzaDto)\n\n# Example usage with actual Mario's Pizzeria entities\nmapper = Mapper()\n\n# Create a pizza with sophisticated pricing\nfrom domain.entities import PizzaSize\n\npizza = Pizza(\n    name=\"Supreme\",\n    base_price=Decimal(\"17.99\"),\n    size=PizzaSize.LARGE  # 1.6x multiplier\n)\npizza.add_topping(\"pepperoni\")\npizza.add_topping(\"mushrooms\")\n# Total: $17.99 * 1.6 + $2.50 * 2 = $33.78\n\n# Create an order\norder = Order(customer_id=\"cust-123\")\norder.add_pizza(pizza)\norder.confirm_order()  # Sets status to CONFIRMED\n\n# Convert to DTOs using auto-mapping\nservice = OrderService(mapper)\npizza_dto = service.get_pizza_dto(pizza)\norder_dto = service.get_order_dto(order, customer_name=\"Luigi Mario\")\n\nprint(f\"Pizza: {pizza_dto.name} ({pizza_dto.size}) - ${pizza_dto.total_price}\")\nprint(f\"Order {order_dto.id} total: ${order_dto.total_amount} ({order_dto.status})\")\n\n# Map objects\norder = create_sample_order()\norder_dto = mapper.map(order, OrderDto)\n\nprint(f\"Order {order_dto.id} for {order_dto.customer}\")\n# Output: Order order-123 for Mario Luigi\n</code></pre>"},{"location":"features/object-mapping/#mapping-configurations","title":"\ud83c\udfa8 Mapping Configurations","text":""},{"location":"features/object-mapping/#convention-based-mapping","title":"Convention-Based Mapping","text":"<p>The mapper automatically matches properties with the same names:</p> <pre><code>@dataclass\nclass Customer:\n    id: str\n    name: str\n    email: str\n    phone: str\n\n@dataclass\nclass CustomerDto:\n    id: str      # Automatically mapped\n    name: str    # Automatically mapped\n    email: str   # Automatically mapped\n    phone: str   # Automatically mapped\n\n# Simple mapping - no configuration needed\nmapper = Mapper()\ncustomer = Customer(\"123\", \"Luigi Mario\", \"luigi@pizzeria.com\", \"+1-555-LUIGI\")\ncustomer_dto = mapper.map(customer, CustomerDto)\n</code></pre>"},{"location":"features/object-mapping/#custom-member-mapping","title":"Custom Member Mapping","text":"<p>For properties that don't match by name or need transformation:</p> <pre><code>@dataclass\nclass Address:\n    street_address: str\n    city_name: str\n    postal_code: str\n    country_name: str\n\n@dataclass\nclass AddressDto:\n    address_line: str    # Combined field\n    city: str           # Different name\n    zip_code: str       # Different name\n    country: str        # Different name\n\n# Configure custom mappings\nmapper.create_map(Address, AddressDto) \\\n    .map_member(\"address_line\", lambda ctx: ctx.source.street_address) \\\n    .map_member(\"city\", lambda ctx: ctx.source.city_name) \\\n    .map_member(\"zip_code\", lambda ctx: ctx.source.postal_code) \\\n    .map_member(\"country\", lambda ctx: ctx.source.country_name)\n</code></pre>"},{"location":"features/object-mapping/#type-conversion","title":"Type Conversion","text":"<p>Automatic conversion between compatible types:</p> <pre><code>@dataclass\nclass MenuItem:\n    name: str\n    price: Decimal       # Decimal type\n    available: bool\n    category_id: int\n\n@dataclass\nclass MenuItemDto:\n    name: str\n    price: float         # Converted to float\n    available: str       # Converted to string\n    category_id: str     # Converted to string\n\n# Automatic type conversion\nmapper = Mapper()\nitem = MenuItem(\"Margherita\", Decimal(\"15.99\"), True, 1)\nitem_dto = mapper.map(item, MenuItemDto)\n\nassert item_dto.price == 15.99\nassert item_dto.available == \"True\"\nassert item_dto.category_id == \"1\"\n</code></pre>"},{"location":"features/object-mapping/#mapping-profiles","title":"\ud83d\udccb Mapping Profiles","text":"<p>Organize related mappings in reusable profiles:</p> <pre><code>from neuroglia.mapping.mapper import MappingProfile\n\nclass PizzeriaMappingProfile(MappingProfile):\n    \"\"\"Mapping profile for Mario's Pizzeria domain objects\"\"\"\n\n    def configure(self):\n        # Order mappings\n        self.create_map(Order, OrderDto) \\\n            .map_member(\"customer\", lambda ctx: ctx.source.customer_name) \\\n            .map_member(\"phone\", lambda ctx: ctx.source.customer_phone) \\\n            .map_member(\"items\", lambda ctx: self.map_list(ctx.source.pizzas, PizzaDto)) \\\n            .map_member(\"ordered_at\", lambda ctx: ctx.source.order_time.isoformat()) \\\n            .map_member(\"total\", lambda ctx: str(ctx.source.total_amount))\n\n        # Pizza mappings\n        self.create_map(Pizza, PizzaDto) \\\n            .map_member(\"price\", lambda ctx: str(ctx.source.total_price)) \\\n            .map_member(\"prep_time\", lambda ctx: ctx.source.preparation_time_minutes)\n\n        # Customer mappings\n        self.create_map(Customer, CustomerDto)  # Convention-based\n\n        # Address mappings\n        self.create_map(Address, AddressDto) \\\n            .map_member(\"address_line\", lambda ctx: f\"{ctx.source.street_address}\") \\\n            .map_member(\"city\", lambda ctx: ctx.source.city_name) \\\n            .map_member(\"zip_code\", lambda ctx: ctx.source.postal_code)\n\n# Register profile with mapper\nmapper = Mapper()\nmapper.add_profile(PizzeriaMappingProfile())\n</code></pre>"},{"location":"features/object-mapping/#advanced-mapping-patterns","title":"\ud83d\udd27 Advanced Mapping Patterns","text":""},{"location":"features/object-mapping/#collection-mapping","title":"Collection Mapping","text":"<pre><code>from typing import List, Dict\n\n@dataclass\nclass Menu:\n    sections: List[MenuSection]\n    featured_items: Dict[str, Pizza]\n\n@dataclass\nclass MenuDto:\n    sections: List[MenuSectionDto]\n    featured: Dict[str, PizzaDto]\n\n# Configure collection mappings\nmapper.create_map(Menu, MenuDto) \\\n    .map_member(\"sections\", lambda ctx: mapper.map_list(ctx.source.sections, MenuSectionDto)) \\\n    .map_member(\"featured\", lambda ctx: {\n        k: mapper.map(v, PizzaDto)\n        for k, v in ctx.source.featured_items.items()\n    })\n</code></pre>"},{"location":"features/object-mapping/#conditional-mapping","title":"Conditional Mapping","text":"<pre><code>@dataclass\nclass OrderSummaryDto:\n    id: str\n    customer: str\n    status: str\n    total: str\n    special_instructions: str  # Only for certain statuses\n\n# Conditional member mapping\nmapper.create_map(Order, OrderSummaryDto) \\\n    .map_member(\"special_instructions\", lambda ctx:\n        getattr(ctx.source, 'special_instructions', '')\n        if ctx.source.status in [OrderStatus.COOKING, OrderStatus.READY]\n        else None\n    )\n</code></pre>"},{"location":"features/object-mapping/#flattening-complex-objects","title":"Flattening Complex Objects","text":"<pre><code>@dataclass\nclass OrderWithCustomer:\n    id: str\n    customer: Customer\n    pizzas: List[Pizza]\n    status: OrderStatus\n\n@dataclass\nclass FlatOrderDto:\n    order_id: str\n    customer_name: str      # Flattened from customer\n    customer_email: str     # Flattened from customer\n    pizza_count: int        # Computed field\n    status: str\n\n# Flattening mapping\nmapper.create_map(OrderWithCustomer, FlatOrderDto) \\\n    .map_member(\"order_id\", lambda ctx: ctx.source.id) \\\n    .map_member(\"customer_name\", lambda ctx: ctx.source.customer.name) \\\n    .map_member(\"customer_email\", lambda ctx: ctx.source.customer.email) \\\n    .map_member(\"pizza_count\", lambda ctx: len(ctx.source.pizzas))\n</code></pre>"},{"location":"features/object-mapping/#testing-object-mapping","title":"\ud83e\uddea Testing Object Mapping","text":""},{"location":"features/object-mapping/#unit-testing-patterns","title":"Unit Testing Patterns","text":"<pre><code>import pytest\nfrom neuroglia.mapping.mapper import Mapper\n\nclass TestPizzeriaMapping:\n\n    def setup_method(self):\n        self.mapper = Mapper()\n        self.mapper.add_profile(PizzeriaMappingProfile())\n\n    def test_pizza_to_dto_mapping(self):\n        \"\"\"Test Pizza to PizzaDto mapping\"\"\"\n        # Arrange\n        pizza = Pizza(\n            id=\"pizza-123\",\n            name=\"Margherita\",\n            size=\"large\",\n            base_price=Decimal(\"15.99\"),\n            toppings=[\"basil\", \"mozzarella\"],\n            preparation_time_minutes=18\n        )\n\n        # Act\n        pizza_dto = self.mapper.map(pizza, PizzaDto)\n\n        # Assert\n        assert pizza_dto.id == \"pizza-123\"\n        assert pizza_dto.name == \"Margherita\"\n        assert pizza_dto.price == \"18.99\"  # base_price + toppings\n        assert pizza_dto.prep_time == 18\n        assert pizza_dto.toppings == [\"basil\", \"mozzarella\"]\n\n    def test_order_to_dto_mapping_preserves_structure(self):\n        \"\"\"Test complex Order to OrderDto mapping\"\"\"\n        # Arrange\n        order = create_sample_order_with_multiple_pizzas()\n\n        # Act\n        order_dto = self.mapper.map(order, OrderDto)\n\n        # Assert\n        assert order_dto.id == order.id\n        assert order_dto.customer == order.customer_name\n        assert len(order_dto.items) == len(order.pizzas)\n        assert order_dto.total == str(order.total_amount)\n\n    def test_mapping_handles_none_values(self):\n        \"\"\"Test mapping with None values\"\"\"\n        # Arrange\n        customer = Customer(\n            id=\"123\",\n            name=\"Test Customer\",\n            email=None,  # None value\n            phone=\"+1-555-TEST\"\n        )\n\n        # Act\n        customer_dto = self.mapper.map(customer, CustomerDto)\n\n        # Assert\n        assert customer_dto.email is None\n        assert customer_dto.name == \"Test Customer\"\n\n    def test_collection_mapping_preserves_order(self):\n        \"\"\"Test that collection mapping preserves order\"\"\"\n        # Arrange\n        pizzas = [\n            create_pizza(\"Margherita\"),\n            create_pizza(\"Pepperoni\"),\n            create_pizza(\"Hawaiian\")\n        ]\n\n        # Act\n        pizza_dtos = self.mapper.map_list(pizzas, PizzaDto)\n\n        # Assert\n        assert len(pizza_dtos) == 3\n        assert pizza_dtos[0].name == \"Margherita\"\n        assert pizza_dtos[1].name == \"Pepperoni\"\n        assert pizza_dtos[2].name == \"Hawaiian\"\n</code></pre>"},{"location":"features/object-mapping/#real-world-use-cases","title":"\ud83c\udfaf Real-World Use Cases","text":""},{"location":"features/object-mapping/#1-api-controller-integration","title":"1. API Controller Integration","text":"<pre><code>from neuroglia.mvc import ControllerBase\nfrom fastapi import HTTPException\n\nclass OrdersController(ControllerBase):\n    def __init__(self,\n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator,\n                 order_service: OrderService):\n        super().__init__(service_provider, mapper, mediator)\n        self.order_service = order_service\n\n    @get(\"/{order_id}\")\n    async def get_order(self, order_id: str) -&gt; OrderDto:\n        \"\"\"Get order by ID with automatic DTO mapping\"\"\"\n        order = await self.order_service.get_by_id_async(order_id)\n\n        if not order:\n            raise HTTPException(status_code=404, detail=\"Order not found\")\n\n        # Map domain entity to DTO\n        return self.mapper.map(order, OrderDto)\n\n    @post(\"/\")\n    async def create_order(self, create_order_request: CreateOrderRequest) -&gt; OrderDto:\n        \"\"\"Create new order with request mapping\"\"\"\n        # Map request to command\n        command = self.mapper.map(create_order_request, CreateOrderCommand)\n\n        # Execute command\n        result = await self.mediator.execute_async(command)\n\n        if not result.is_success:\n            raise HTTPException(status_code=400, detail=result.error_message)\n\n        # Map result to DTO\n        return self.mapper.map(result.value, OrderDto)\n</code></pre>"},{"location":"features/object-mapping/#2-commandquery-mapping","title":"2. Command/Query Mapping","text":"<pre><code>from neuroglia.mediation import Command, CommandHandler\n\n@dataclass\nclass CreateOrderRequest:\n    customer_name: str\n    customer_phone: str\n    pizza_requests: List[PizzaRequest]\n\n@dataclass\nclass CreateOrderCommand(Command[Order]):\n    customer_name: str\n    customer_phone: str\n    pizza_items: List[PizzaOrderItem]\n\n# Map request to command\nclass OrderMappingProfile(MappingProfile):\n    def configure(self):\n        self.create_map(CreateOrderRequest, CreateOrderCommand) \\\n            .map_member(\"pizza_items\", lambda ctx:\n                [self.map(req, PizzaOrderItem) for req in ctx.source.pizza_requests]\n            )\n</code></pre>"},{"location":"features/object-mapping/#3-event-data-transformation","title":"3. Event Data Transformation","text":"<pre><code>from neuroglia.eventing import DomainEvent\n\n@dataclass\nclass OrderStatusChangedEvent(DomainEvent):\n    order_id: str\n    old_status: str\n    new_status: str\n    customer_email: str\n    notification_data: dict\n\nclass OrderEventService:\n    def __init__(self, mapper: Mapper):\n        self.mapper = mapper\n\n    def create_status_change_event(self, order: Order, old_status: OrderStatus) -&gt; OrderStatusChangedEvent:\n        \"\"\"Create event with mapped data\"\"\"\n\n        # Map order data to event notification data\n        notification_data = {\n            \"order_summary\": self.mapper.map(order, OrderSummaryDto),\n            \"estimated_time\": order.estimated_ready_time.isoformat(),\n            \"total_amount\": str(order.total_amount)\n        }\n\n        return OrderStatusChangedEvent(\n            order_id=order.id,\n            old_status=old_status.value,\n            new_status=order.status.value,\n            customer_email=order.customer.email,\n            notification_data=notification_data\n        )\n</code></pre>"},{"location":"features/object-mapping/#performance-optimization","title":"\ud83d\udd0d Performance Optimization","text":""},{"location":"features/object-mapping/#mapping-performance-tips","title":"Mapping Performance Tips","text":"<pre><code>class OptimizedMappingService:\n    def __init__(self, mapper: Mapper):\n        self.mapper = mapper\n        # Pre-compile mappings for better performance\n        self._initialize_mappings()\n\n    def _initialize_mappings(self):\n        \"\"\"Pre-configure frequently used mappings\"\"\"\n        # Frequently used mappings\n        self.mapper.create_map(Order, OrderDto)\n        self.mapper.create_map(Pizza, PizzaDto)\n        self.mapper.create_map(Customer, CustomerDto)\n\n        # Warm up mapper with sample objects\n        sample_order = create_sample_order()\n        self.mapper.map(sample_order, OrderDto)\n\n    def bulk_map_orders(self, orders: List[Order]) -&gt; List[OrderDto]:\n        \"\"\"Efficiently map large collections\"\"\"\n        return [self.mapper.map(order, OrderDto) for order in orders]\n\n    def map_with_caching(self, source: Any, target_type: Type[T]) -&gt; T:\n        \"\"\"Map with result caching for immutable objects\"\"\"\n        cache_key = f\"{type(source)}-{target_type}-{hash(source)}\"\n\n        if cache_key not in self._mapping_cache:\n            self._mapping_cache[cache_key] = self.mapper.map(source, target_type)\n\n        return self._mapping_cache[cache_key]\n</code></pre>"},{"location":"features/object-mapping/#integration-with-other-features","title":"\ud83d\udd04 Integration with Other Features","text":""},{"location":"features/object-mapping/#mapping-with-serialization","title":"Mapping with Serialization","text":"<pre><code>class OrderApiService:\n    def __init__(self, mapper: Mapper, serializer: JsonSerializer):\n        self.mapper = mapper\n        self.serializer = serializer\n\n    def export_orders_json(self, orders: List[Order]) -&gt; str:\n        \"\"\"Export orders as JSON with DTO mapping\"\"\"\n        # Map to DTOs first\n        order_dtos = self.mapper.map_list(orders, OrderDto)\n\n        # Then serialize\n        return self.serializer.serialize_to_text(order_dtos)\n\n    def import_orders_json(self, json_data: str) -&gt; List[Order]:\n        \"\"\"Import orders from JSON with DTO mapping\"\"\"\n        # Deserialize to DTOs\n        order_dtos = self.serializer.deserialize_from_text(json_data, List[OrderDto])\n\n        # Map to domain entities\n        return self.mapper.map_list(order_dtos, Order)\n</code></pre>"},{"location":"features/object-mapping/#dependency-injection-integration","title":"\ud83d\ude80 Dependency Injection Integration","text":""},{"location":"features/object-mapping/#configuring-mapper-in-di-container","title":"Configuring Mapper in DI Container","text":"<pre><code>from neuroglia.hosting import WebApplicationBuilder\n\ndef configure_mapping(builder: WebApplicationBuilder):\n    \"\"\"Configure object mapping services\"\"\"\n\n    # Register mapper as singleton\n    mapper = Mapper()\n\n    # Add mapping profiles\n    mapper.add_profile(PizzeriaMappingProfile())\n    mapper.add_profile(CustomerMappingProfile())\n    mapper.add_profile(EventMappingProfile())\n\n    builder.services.add_singleton(Mapper, lambda: mapper)\n\n    # Register mapping services\n    builder.services.add_scoped(OrderMappingService)\n    builder.services.add_scoped(CustomerMappingService)\n\n# Usage in controllers\nclass MenuController(ControllerBase):\n    def __init__(self,\n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,  # Injected automatically\n                 mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n</code></pre>"},{"location":"features/object-mapping/#integration-points","title":"\ud83d\udd17 Integration Points","text":""},{"location":"features/object-mapping/#framework-integration","title":"Framework Integration","text":"<p>Object mapping integrates seamlessly with:</p> <ul> <li>Serialization - Map objects before serialization/after deserialization</li> <li>CQRS &amp; Mediation - Map requests to commands and queries</li> <li>MVC Controllers - Automatic request/response mapping</li> <li>Event Sourcing - Transform domain events to external formats</li> </ul>"},{"location":"features/object-mapping/#next-steps","title":"\ud83d\udcda Next Steps","text":"<p>Explore related Neuroglia features:</p> <ul> <li>Serialization - Convert mapped objects to JSON</li> <li>CQRS &amp; Mediation - Use mapping in command/query handlers</li> <li>MVC Controllers - Automatic API object mapping</li> <li>Getting Started Guide - Complete pizzeria implementation</li> </ul> <p>\ud83c\udfaf Best Practice</p> <p>Organize related mappings in profiles and register the Mapper as a singleton in your DI container for optimal performance and maintainability.</p>"},{"location":"features/redis-cache-repository/","title":"\u26a1 Redis Cache Repository","text":"<p>The Neuroglia framework provides high-performance distributed caching through Redis integration, enabling scalable data access patterns with advanced features like distributed locking, hash-based storage, and automatic expiration management.</p>"},{"location":"features/redis-cache-repository/#overview","title":"\ud83c\udfaf Overview","text":"<p>Redis caching is essential for modern microservices that need fast data access, session management, and distributed coordination. The framework's Redis implementation provides:</p> <ul> <li>Distributed Caching: Shared cache across multiple service instances</li> <li>Advanced Data Structures: Strings, hashes, lists, sets, and sorted sets</li> <li>Distributed Locking: Coordination across service instances</li> <li>Automatic Expiration: TTL-based cache invalidation</li> <li>Connection Pooling: Optimized Redis connection management</li> <li>Circuit Breaker: Resilience against Redis unavailability</li> </ul>"},{"location":"features/redis-cache-repository/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>graph TB\n    subgraph \"\ud83c\udf55 Mario's Pizzeria Services\"\n        OrderService[Order Service]\n        MenuService[Menu Service]\n        CustomerService[Customer Service]\n        InventoryService[Inventory Service]\n    end\n\n    subgraph \"\u26a1 Redis Cache Layer\"\n        RedisCache[Redis Cache Repository]\n        DistributedLock[Distributed Lock Manager]\n        ConnectionPool[Connection Pool]\n    end\n\n    subgraph \"\ud83d\udcbe Redis Data Structures\"\n        Strings[String Cache]\n        Hashes[Hash Storage]\n        Sets[Set Operations]\n        SortedSets[Sorted Sets]\n    end\n\n    subgraph \"\ud83d\uddc4\ufe0f Data Sources\"\n        MenuDB[(Menu Database)]\n        OrderDB[(Order Database)]\n        CustomerDB[(Customer Database)]\n    end\n\n    OrderService --&gt; RedisCache\n    MenuService --&gt; RedisCache\n    CustomerService --&gt; RedisCache\n    InventoryService --&gt; RedisCache\n\n    RedisCache --&gt; DistributedLock\n    RedisCache --&gt; ConnectionPool\n\n    ConnectionPool --&gt; Strings\n    ConnectionPool --&gt; Hashes\n    ConnectionPool --&gt; Sets\n    ConnectionPool --&gt; SortedSets\n\n    RedisCache -.-&gt;|Cache Miss| MenuDB\n    RedisCache -.-&gt;|Cache Miss| OrderDB\n    RedisCache -.-&gt;|Cache Miss| CustomerDB\n\n    style RedisCache fill:#e3f2fd\n    style DistributedLock fill:#ffebee\n    style ConnectionPool fill:#e8f5e8</code></pre>"},{"location":"features/redis-cache-repository/#basic-usage","title":"\ud83d\ude80 Basic Usage","text":""},{"location":"features/redis-cache-repository/#service-registration","title":"Service Registration","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.data.redis import RedisRepository, RedisConfig\n\ndef create_app():\n    builder = WebApplicationBuilder()\n\n    # Register Redis cache repository\n    redis_config = RedisConfig(\n        host=\"localhost\",\n        port=6379,\n        db=0,\n        password=\"your_redis_password\",\n        connection_pool_size=20,\n        health_check_interval=30\n    )\n\n    builder.services.add_redis_repository(redis_config)\n\n    app = builder.build()\n    return app\n</code></pre>"},{"location":"features/redis-cache-repository/#simple-cache-operations","title":"Simple Cache Operations","text":"<pre><code>from neuroglia.data.redis import RedisRepository\nfrom neuroglia.dependency_injection import ServiceProviderBase\nimport json\nfrom datetime import timedelta\n\nclass MenuCacheService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.redis = service_provider.get_service(RedisRepository)\n        self.cache_prefix = \"mario_pizzeria:menu\"\n\n    async def cache_menu_item(self, item_id: str, menu_item: dict, ttl_hours: int = 24):\n        \"\"\"Cache a menu item with automatic expiration.\"\"\"\n        cache_key = f\"{self.cache_prefix}:item:{item_id}\"\n        cache_value = json.dumps(menu_item)\n\n        await self.redis.set_async(\n            key=cache_key,\n            value=cache_value,\n            expiration=timedelta(hours=ttl_hours)\n        )\n\n        print(f\"\ud83c\udf55 Cached menu item: {menu_item['name']} (expires in {ttl_hours}h)\")\n\n    async def get_cached_menu_item(self, item_id: str) -&gt; dict:\n        \"\"\"Retrieve cached menu item.\"\"\"\n        cache_key = f\"{self.cache_prefix}:item:{item_id}\"\n\n        cached_value = await self.redis.get_async(cache_key)\n\n        if cached_value:\n            return json.loads(cached_value)\n\n        # Cache miss - load from database\n        menu_item = await self.load_menu_item_from_db(item_id)\n        if menu_item:\n            await self.cache_menu_item(item_id, menu_item)\n\n        return menu_item\n\n    async def invalidate_menu_cache(self, item_id: str = None):\n        \"\"\"Invalidate menu cache entries.\"\"\"\n        if item_id:\n            # Invalidate specific item\n            cache_key = f\"{self.cache_prefix}:item:{item_id}\"\n            await self.redis.delete_async(cache_key)\n        else:\n            # Invalidate all menu items\n            pattern = f\"{self.cache_prefix}:item:*\"\n            await self.redis.delete_pattern_async(pattern)\n\n        print(f\"\ud83d\uddd1\ufe0f Menu cache invalidated: {item_id or 'all items'}\")\n</code></pre>"},{"location":"features/redis-cache-repository/#hash-based-storage","title":"\ud83d\udce6 Hash-Based Storage","text":""},{"location":"features/redis-cache-repository/#customer-session-management","title":"Customer Session Management","text":"<pre><code>from neuroglia.data.redis import RedisHashRepository\n\nclass CustomerSessionService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.redis = service_provider.get_service(RedisRepository)\n        self.session_prefix = \"mario_pizzeria:sessions\"\n\n    async def create_customer_session(self, customer_id: str, session_data: dict):\n        \"\"\"Create customer session using Redis hash.\"\"\"\n        session_key = f\"{self.session_prefix}:{customer_id}\"\n\n        # Store session data as hash fields\n        session_fields = {\n            \"customer_id\": customer_id,\n            \"login_time\": str(datetime.utcnow()),\n            \"cart_items\": json.dumps(session_data.get(\"cart_items\", [])),\n            \"preferences\": json.dumps(session_data.get(\"preferences\", {})),\n            \"last_activity\": str(datetime.utcnow())\n        }\n\n        await self.redis.hset_async(session_key, session_fields)\n        await self.redis.expire_async(session_key, timedelta(hours=4))  # 4-hour session\n\n        print(f\"\ud83d\udc64 Created session for customer {customer_id}\")\n\n    async def update_customer_cart(self, customer_id: str, cart_items: list):\n        \"\"\"Update customer cart in session.\"\"\"\n        session_key = f\"{self.session_prefix}:{customer_id}\"\n\n        # Update specific hash fields\n        updates = {\n            \"cart_items\": json.dumps(cart_items),\n            \"last_activity\": str(datetime.utcnow())\n        }\n\n        await self.redis.hset_async(session_key, updates)\n        print(f\"\ud83d\uded2 Updated cart for customer {customer_id}: {len(cart_items)} items\")\n\n    async def get_customer_session(self, customer_id: str) -&gt; dict:\n        \"\"\"Retrieve complete customer session.\"\"\"\n        session_key = f\"{self.session_prefix}:{customer_id}\"\n\n        session_data = await self.redis.hgetall_async(session_key)\n\n        if not session_data:\n            return None\n\n        # Deserialize JSON fields\n        return {\n            \"customer_id\": session_data.get(\"customer_id\"),\n            \"login_time\": session_data.get(\"login_time\"),\n            \"cart_items\": json.loads(session_data.get(\"cart_items\", \"[]\")),\n            \"preferences\": json.loads(session_data.get(\"preferences\", \"{}\")),\n            \"last_activity\": session_data.get(\"last_activity\")\n        }\n\n    async def get_customer_cart(self, customer_id: str) -&gt; list:\n        \"\"\"Get only the cart items from customer session.\"\"\"\n        session_key = f\"{self.session_prefix}:{customer_id}\"\n\n        cart_json = await self.redis.hget_async(session_key, \"cart_items\")\n        return json.loads(cart_json) if cart_json else []\n</code></pre>"},{"location":"features/redis-cache-repository/#distributed-locking","title":"\ud83d\udd12 Distributed Locking","text":""},{"location":"features/redis-cache-repository/#order-processing-coordination","title":"Order Processing Coordination","text":"<pre><code>from neuroglia.data.redis import DistributedLock, LockTimeoutError\nimport asyncio\n\nclass OrderProcessingService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.redis = service_provider.get_service(RedisRepository)\n        self.lock_timeout = 30  # 30 seconds\n\n    async def process_order_safely(self, order_id: str):\n        \"\"\"Process order with distributed locking to prevent race conditions.\"\"\"\n        lock_key = f\"mario_pizzeria:order_lock:{order_id}\"\n\n        async with DistributedLock(self.redis, lock_key, timeout=self.lock_timeout):\n            try:\n                # Critical section - only one service instance can process this order\n                order = await self.get_order(order_id)\n\n                if order.status != \"pending\":\n                    print(f\"\u26a0\ufe0f Order {order_id} already processed\")\n                    return\n\n                # Process the order\n                await self.validate_inventory(order)\n                await self.charge_customer(order)\n                await self.update_order_status(order_id, \"processing\")\n                await self.notify_kitchen(order)\n\n                print(f\"\u2705 Order {order_id} processed successfully\")\n\n            except InventoryShortageError as e:\n                await self.handle_inventory_shortage(order_id, e)\n            except PaymentError as e:\n                await self.handle_payment_failure(order_id, e)\n\n    async def coordinate_inventory_update(self, ingredient_id: str, quantity_change: int):\n        \"\"\"Update inventory with distributed coordination.\"\"\"\n        lock_key = f\"mario_pizzeria:inventory_lock:{ingredient_id}\"\n\n        try:\n            async with DistributedLock(self.redis, lock_key, timeout=10):\n                # Get current inventory\n                current_stock = await self.get_ingredient_stock(ingredient_id)\n\n                # Validate the change\n                new_stock = current_stock + quantity_change\n                if new_stock &lt; 0:\n                    raise InsufficientInventoryError(\n                        f\"Cannot reduce {ingredient_id} by {abs(quantity_change)}. \"\n                        f\"Current stock: {current_stock}\"\n                    )\n\n                # Update inventory atomically\n                await self.update_ingredient_stock(ingredient_id, new_stock)\n\n                # Update cache\n                await self.cache_ingredient_stock(ingredient_id, new_stock)\n\n                print(f\"\ud83d\udce6 Inventory updated: {ingredient_id} = {new_stock}\")\n\n        except LockTimeoutError:\n            print(f\"\u23f0 Could not acquire inventory lock for {ingredient_id}\")\n            raise ConcurrentUpdateError(\"Inventory update failed due to concurrent access\")\n</code></pre>"},{"location":"features/redis-cache-repository/#kitchen-queue-management","title":"Kitchen Queue Management","text":"<pre><code>class KitchenQueueService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.redis = service_provider.get_service(RedisRepository)\n        self.queue_key = \"mario_pizzeria:kitchen_queue\"\n        self.processing_key = \"mario_pizzeria:kitchen_processing\"\n\n    async def add_order_to_queue(self, order_id: str, priority: int = 0):\n        \"\"\"Add order to kitchen queue with priority.\"\"\"\n        # Use Redis sorted set for priority queue\n        order_data = {\n            \"order_id\": order_id,\n            \"queued_at\": datetime.utcnow().isoformat(),\n            \"priority\": priority\n        }\n\n        await self.redis.zadd_async(\n            self.queue_key,\n            {json.dumps(order_data): priority}\n        )\n\n        print(f\"\ud83d\udc68\u200d\ud83c\udf73 Added order {order_id} to kitchen queue (priority: {priority})\")\n\n    async def get_next_order(self, kitchen_station_id: str) -&gt; dict:\n        \"\"\"Get next order for kitchen processing with distributed coordination.\"\"\"\n        lock_key = f\"mario_pizzeria:queue_lock\"\n\n        async with DistributedLock(self.redis, lock_key, timeout=5):\n            # Get highest priority order\n            orders = await self.redis.zrange_async(\n                self.queue_key,\n                0, 0,\n                desc=True,\n                withscores=True\n            )\n\n            if not orders:\n                return None\n\n            order_json, priority = orders[0]\n            order_data = json.loads(order_json)\n\n            # Move from queue to processing\n            await self.redis.zrem_async(self.queue_key, order_json)\n\n            processing_data = {\n                **order_data,\n                \"kitchen_station\": kitchen_station_id,\n                \"started_at\": datetime.utcnow().isoformat()\n            }\n\n            await self.redis.hset_async(\n                self.processing_key,\n                order_data[\"order_id\"],\n                json.dumps(processing_data)\n            )\n\n            return order_data\n\n    async def complete_order_processing(self, order_id: str):\n        \"\"\"Mark order processing as complete.\"\"\"\n        await self.redis.hdel_async(self.processing_key, order_id)\n        print(f\"\u2705 Order {order_id} processing completed\")\n</code></pre>"},{"location":"features/redis-cache-repository/#advanced-data-structures","title":"\ud83d\udcca Advanced Data Structures","text":""},{"location":"features/redis-cache-repository/#real-time-analytics-with-sorted-sets","title":"Real-time Analytics with Sorted Sets","text":"<pre><code>class PizzaAnalyticsService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.redis = service_provider.get_service(RedisRepository)\n        self.analytics_prefix = \"mario_pizzeria:analytics\"\n\n    async def track_popular_pizzas(self, pizza_name: str):\n        \"\"\"Track pizza popularity using sorted sets.\"\"\"\n        popularity_key = f\"{self.analytics_prefix}:pizza_popularity\"\n\n        # Increment pizza order count\n        await self.redis.zincrby_async(popularity_key, 1, pizza_name)\n\n        # Keep only top 50 pizzas\n        await self.redis.zremrangebyrank_async(popularity_key, 0, -51)\n\n    async def get_top_pizzas(self, limit: int = 10) -&gt; list:\n        \"\"\"Get most popular pizzas.\"\"\"\n        popularity_key = f\"{self.analytics_prefix}:pizza_popularity\"\n\n        top_pizzas = await self.redis.zrevrange_async(\n            popularity_key,\n            0,\n            limit - 1,\n            withscores=True\n        )\n\n        return [\n            {\"name\": pizza.decode(), \"order_count\": int(score)}\n            for pizza, score in top_pizzas\n        ]\n\n    async def track_hourly_orders(self, hour: int):\n        \"\"\"Track orders per hour using hash.\"\"\"\n        today = datetime.now().date().isoformat()\n        hourly_key = f\"{self.analytics_prefix}:hourly:{today}\"\n\n        await self.redis.hincrby_async(hourly_key, str(hour), 1)\n        await self.redis.expire_async(hourly_key, timedelta(days=7))  # Keep for a week\n\n    async def get_hourly_distribution(self, date: str = None) -&gt; dict:\n        \"\"\"Get order distribution by hour.\"\"\"\n        if not date:\n            date = datetime.now().date().isoformat()\n\n        hourly_key = f\"{self.analytics_prefix}:hourly:{date}\"\n        hourly_data = await self.redis.hgetall_async(hourly_key)\n\n        return {\n            int(hour): int(count)\n            for hour, count in hourly_data.items()\n        }\n</code></pre>"},{"location":"features/redis-cache-repository/#set-operations-for-customer-segmentation","title":"Set Operations for Customer Segmentation","text":"<pre><code>class CustomerSegmentationService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.redis = service_provider.get_service(RedisRepository)\n        self.segment_prefix = \"mario_pizzeria:segments\"\n\n    async def add_customer_to_segment(self, customer_id: str, segment: str):\n        \"\"\"Add customer to marketing segment.\"\"\"\n        segment_key = f\"{self.segment_prefix}:{segment}\"\n        await self.redis.sadd_async(segment_key, customer_id)\n\n        # Set segment expiration (30 days)\n        await self.redis.expire_async(segment_key, timedelta(days=30))\n\n    async def get_segment_customers(self, segment: str) -&gt; set:\n        \"\"\"Get all customers in a segment.\"\"\"\n        segment_key = f\"{self.segment_prefix}:{segment}\"\n        return await self.redis.smembers_async(segment_key)\n\n    async def find_overlapping_customers(self, segment1: str, segment2: str) -&gt; set:\n        \"\"\"Find customers in both segments.\"\"\"\n        key1 = f\"{self.segment_prefix}:{segment1}\"\n        key2 = f\"{self.segment_prefix}:{segment2}\"\n\n        return await self.redis.sinter_async([key1, key2])\n\n    async def create_targeted_campaign(self, segments: list, campaign_id: str):\n        \"\"\"Create campaign targeting multiple segments.\"\"\"\n        segment_keys = [f\"{self.segment_prefix}:{seg}\" for seg in segments]\n        campaign_key = f\"{self.segment_prefix}:campaign:{campaign_id}\"\n\n        # Union of all target segments\n        await self.redis.sunionstore_async(campaign_key, segment_keys)\n\n        # Campaign expires in 7 days\n        await self.redis.expire_async(campaign_key, timedelta(days=7))\n\n        target_count = await self.redis.scard_async(campaign_key)\n        print(f\"\ud83c\udfaf Campaign {campaign_id} targets {target_count} customers\")\n\n        return target_count\n</code></pre>"},{"location":"features/redis-cache-repository/#circuit-breaker-and-resilience","title":"\ud83d\udee1\ufe0f Circuit Breaker and Resilience","text":""},{"location":"features/redis-cache-repository/#resilient-cache-operations","title":"Resilient Cache Operations","text":"<pre><code>from neuroglia.data.redis import CircuitBreakerPolicy, CacheException\n\nclass ResilientMenuService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.redis = service_provider.get_service(RedisRepository)\n        self.circuit_breaker = CircuitBreakerPolicy(\n            failure_threshold=5,\n            recovery_timeout=60,\n            success_threshold=3\n        )\n        self.fallback_cache = {}  # In-memory fallback\n\n    @circuit_breaker.apply\n    async def get_menu_with_fallback(self, menu_id: str) -&gt; dict:\n        \"\"\"Get menu with circuit breaker and fallback.\"\"\"\n        try:\n            # Try Redis cache first\n            cache_key = f\"mario_pizzeria:menu:{menu_id}\"\n            cached_menu = await self.redis.get_async(cache_key)\n\n            if cached_menu:\n                menu_data = json.loads(cached_menu)\n                # Update fallback cache\n                self.fallback_cache[menu_id] = menu_data\n                return menu_data\n\n            # Cache miss - load from database\n            menu_data = await self.load_menu_from_database(menu_id)\n\n            # Cache in Redis\n            await self.redis.set_async(\n                cache_key,\n                json.dumps(menu_data),\n                expiration=timedelta(hours=6)\n            )\n\n            # Update fallback cache\n            self.fallback_cache[menu_id] = menu_data\n            return menu_data\n\n        except CacheException as e:\n            print(f\"\u26a0\ufe0f Redis unavailable, using fallback cache: {e}\")\n\n            # Use fallback cache\n            if menu_id in self.fallback_cache:\n                return self.fallback_cache[menu_id]\n\n            # Last resort - load from database\n            return await self.load_menu_from_database(menu_id)\n\n    async def warm_fallback_cache(self):\n        \"\"\"Pre-load frequently accessed items into fallback cache.\"\"\"\n        popular_menus = [\"margherita\", \"pepperoni\", \"quattro_stagioni\"]\n\n        for menu_id in popular_menus:\n            try:\n                menu_data = await self.get_menu_with_fallback(menu_id)\n                self.fallback_cache[menu_id] = menu_data\n            except Exception as e:\n                print(f\"Failed to warm cache for {menu_id}: {e}\")\n</code></pre>"},{"location":"features/redis-cache-repository/#advanced-configuration","title":"\ud83d\udd27 Advanced Configuration","text":""},{"location":"features/redis-cache-repository/#connection-pool-and-performance-tuning","title":"Connection Pool and Performance Tuning","text":"<pre><code>from neuroglia.data.redis import RedisConfig, ConnectionPoolConfig\n\ndef create_optimized_redis_config():\n    connection_config = ConnectionPoolConfig(\n        max_connections=50,\n        retry_on_timeout=True,\n        health_check_interval=30,\n\n        # Connection timeouts\n        socket_timeout=2.0,\n        socket_connect_timeout=2.0,\n\n        # Connection pooling\n        connection_pool_class_kwargs={\n            'max_connections_per_pool': 50,\n            'retry_on_timeout': True,\n            'socket_keepalive': True,\n            'socket_keepalive_options': {},\n        },\n\n        # Cluster configuration (if using Redis Cluster)\n        skip_full_coverage_check=True,\n        decode_responses=True\n    )\n\n    redis_config = RedisConfig(\n        host=\"redis://localhost:6379\",\n        connection_pool=connection_config,\n\n        # Performance settings\n        retry_policy={\n            'retries': 3,\n            'retry_delay': 0.1,\n            'backoff_factor': 2,\n            'max_retry_delay': 1.0\n        },\n\n        # Monitoring\n        enable_metrics=True,\n        metrics_prefix=\"mario_pizzeria_redis\",\n\n        # Security\n        ssl_cert_reqs=None,\n        ssl_ca_certs=None,\n        ssl_keyfile=None,\n        ssl_certfile=None\n    )\n\n    return redis_config\n</code></pre>"},{"location":"features/redis-cache-repository/#custom-serialization-strategies","title":"Custom Serialization Strategies","text":"<pre><code>from neuroglia.data.redis import SerializationStrategy\nimport pickle\nimport msgpack\n\nclass CustomSerializationService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.redis = service_provider.get_service(RedisRepository)\n\n    async def cache_with_msgpack(self, key: str, data: dict):\n        \"\"\"Cache data using MessagePack serialization.\"\"\"\n        serialized = msgpack.packb(data)\n        await self.redis.set_async(key, serialized)\n\n    async def get_with_msgpack(self, key: str) -&gt; dict:\n        \"\"\"Retrieve data with MessagePack deserialization.\"\"\"\n        serialized = await self.redis.get_async(key)\n        if serialized:\n            return msgpack.unpackb(serialized, raw=False)\n        return None\n\n    async def cache_complex_object(self, key: str, obj):\n        \"\"\"Cache complex Python objects using pickle.\"\"\"\n        serialized = pickle.dumps(obj)\n        await self.redis.set_async(key, serialized)\n\n    async def get_complex_object(self, key: str):\n        \"\"\"Retrieve complex Python objects.\"\"\"\n        serialized = await self.redis.get_async(key)\n        if serialized:\n            return pickle.loads(serialized)\n        return None\n</code></pre>"},{"location":"features/redis-cache-repository/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"features/redis-cache-repository/#unit-testing-with-redis-mock","title":"Unit Testing with Redis Mock","text":"<pre><code>import pytest\nfrom unittest.mock import AsyncMock, Mock\nfrom neuroglia.data.redis import RedisRepository\n\nclass TestMenuCacheService:\n\n    @pytest.fixture\n    def mock_redis(self):\n        redis = Mock(spec=RedisRepository)\n        redis.get_async = AsyncMock()\n        redis.set_async = AsyncMock()\n        redis.delete_async = AsyncMock()\n        redis.hget_async = AsyncMock()\n        redis.hset_async = AsyncMock()\n        return redis\n\n    @pytest.fixture\n    def menu_service(self, mock_redis):\n        service_provider = Mock()\n        service_provider.get_service.return_value = mock_redis\n        return MenuCacheService(service_provider)\n\n    @pytest.mark.asyncio\n    async def test_cache_menu_item(self, menu_service, mock_redis):\n        \"\"\"Test menu item caching.\"\"\"\n        menu_item = {\"name\": \"Margherita\", \"price\": 12.99}\n\n        await menu_service.cache_menu_item(\"margherita\", menu_item)\n\n        mock_redis.set_async.assert_called_once()\n        call_args = mock_redis.set_async.call_args\n        assert \"mario_pizzeria:menu:item:margherita\" in call_args[1][\"key\"]\n\n    @pytest.mark.asyncio\n    async def test_cache_hit(self, menu_service, mock_redis):\n        \"\"\"Test successful cache retrieval.\"\"\"\n        cached_data = '{\"name\": \"Margherita\", \"price\": 12.99}'\n        mock_redis.get_async.return_value = cached_data\n\n        result = await menu_service.get_cached_menu_item(\"margherita\")\n\n        assert result[\"name\"] == \"Margherita\"\n        assert result[\"price\"] == 12.99\n\n    @pytest.mark.asyncio\n    async def test_cache_miss(self, menu_service, mock_redis):\n        \"\"\"Test cache miss behavior.\"\"\"\n        mock_redis.get_async.return_value = None\n        menu_service.load_menu_item_from_db = AsyncMock(\n            return_value={\"name\": \"Pepperoni\", \"price\": 15.99}\n        )\n\n        result = await menu_service.get_cached_menu_item(\"pepperoni\")\n\n        assert result[\"name\"] == \"Pepperoni\"\n        # Should cache the loaded data\n        mock_redis.set_async.assert_called()\n</code></pre>"},{"location":"features/redis-cache-repository/#integration-testing-with-redis","title":"Integration Testing with Redis","text":"<pre><code>@pytest.mark.integration\nclass TestRedisIntegration:\n\n    @pytest.fixture\n    async def redis_repository(self):\n        config = RedisConfig(\n            host=\"redis://localhost:6379/15\",  # Test database\n            connection_pool_size=5\n        )\n        redis = RedisRepository(config)\n        await redis.connect()\n        yield redis\n        await redis.flushdb()  # Clean up\n        await redis.disconnect()\n\n    @pytest.mark.asyncio\n    async def test_distributed_locking(self, redis_repository):\n        \"\"\"Test distributed locking behavior.\"\"\"\n        lock_key = \"test_lock\"\n\n        # Acquire lock\n        lock = DistributedLock(redis_repository, lock_key, timeout=5)\n\n        async with lock:\n            # Lock should be held\n            assert await redis_repository.exists_async(lock_key)\n\n        # Lock should be released\n        assert not await redis_repository.exists_async(lock_key)\n\n    @pytest.mark.asyncio\n    async def test_hash_operations(self, redis_repository):\n        \"\"\"Test Redis hash operations.\"\"\"\n        hash_key = \"test_hash\"\n\n        # Set hash fields\n        fields = {\"field1\": \"value1\", \"field2\": \"value2\"}\n        await redis_repository.hset_async(hash_key, fields)\n\n        # Get specific field\n        value = await redis_repository.hget_async(hash_key, \"field1\")\n        assert value == \"value1\"\n\n        # Get all fields\n        all_fields = await redis_repository.hgetall_async(hash_key)\n        assert all_fields == fields\n</code></pre>"},{"location":"features/redis-cache-repository/#monitoring-and-performance","title":"\ud83d\udcca Monitoring and Performance","text":""},{"location":"features/redis-cache-repository/#cache-performance-metrics","title":"Cache Performance Metrics","text":"<pre><code>from neuroglia.data.redis import CacheMetrics\n\nclass CachePerformanceMonitor:\n    def __init__(self, redis: RedisRepository):\n        self.redis = redis\n        self.metrics = CacheMetrics()\n\n    async def track_cache_operation(self, operation: str, key: str, hit: bool = None):\n        \"\"\"Track cache operation metrics.\"\"\"\n        await self.metrics.increment_counter(f\"cache_operations_{operation}\")\n\n        if hit is not None:\n            status = \"hit\" if hit else \"miss\"\n            await self.metrics.increment_counter(f\"cache_{status}\")\n            await self.metrics.set_gauge(\"cache_hit_ratio\", self.calculate_hit_ratio())\n\n    async def get_performance_summary(self) -&gt; dict:\n        \"\"\"Get cache performance summary.\"\"\"\n        return {\n            \"total_operations\": await self.metrics.get_counter(\"cache_operations_total\"),\n            \"cache_hits\": await self.metrics.get_counter(\"cache_hit\"),\n            \"cache_misses\": await self.metrics.get_counter(\"cache_miss\"),\n            \"hit_ratio\": await self.metrics.get_gauge(\"cache_hit_ratio\"),\n            \"active_connections\": await self.redis.connection_pool.created_connections,\n            \"memory_usage\": await self.redis.memory_usage()\n        }\n\n    def calculate_hit_ratio(self) -&gt; float:\n        \"\"\"Calculate cache hit ratio.\"\"\"\n        hits = self.metrics.get_counter(\"cache_hit\")\n        misses = self.metrics.get_counter(\"cache_miss\")\n        total = hits + misses\n\n        return (hits / total) if total &gt; 0 else 0.0\n</code></pre>"},{"location":"features/redis-cache-repository/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\u23f0 Background Task Scheduling - Distributed job coordination</li> <li>\ud83d\udd27 Dependency Injection - Service registration patterns</li> <li>\ud83c\udf10 HTTP Service Client - External service caching</li> <li>\ud83d\udcca Enhanced Model Validation - Data validation caching</li> <li>\ud83d\udcc1 Data Access - Repository patterns</li> </ul> <p>The Redis Cache Repository provides enterprise-grade caching capabilities that enable Mario's Pizzeria to handle high-volume operations with optimal performance. Through distributed locking, advanced data structures, and comprehensive resilience patterns, the system ensures reliable and scalable caching across all service instances.</p>"},{"location":"features/resilient-handler-discovery/","title":"\ud83d\udee1\ufe0f Resilient Handler Discovery","text":"<p>The Neuroglia framework now includes Resilient Handler Discovery in the Mediator, designed to handle real-world scenarios where packages may have complex dependencies or mixed architectural patterns.</p>"},{"location":"features/resilient-handler-discovery/#problem-solved","title":"\ud83c\udfaf Problem Solved","text":"<p>Previously, <code>Mediator.configure()</code> would fail completely if a package's <code>__init__.py</code> had any import errors, even when the package contained valid handlers that could be imported individually. This blocked automatic discovery in:</p> <ul> <li>Legacy migrations from UseCase patterns to CQRS handlers</li> <li>Mixed codebases with varying dependency graphs</li> <li>Optional dependencies that may not be available in all environments</li> <li>Modular monoliths with packages containing both new and legacy patterns</li> </ul>"},{"location":"features/resilient-handler-discovery/#how-it-works","title":"\ud83c\udfd7\ufe0f How It Works","text":"<p>The resilient discovery implements a two-stage fallback strategy:</p>"},{"location":"features/resilient-handler-discovery/#stage-1-package-import-original-behavior","title":"Stage 1: Package Import (Original Behavior)","text":"<pre><code># Attempts to import the entire package\nMediator.configure(builder, ['application.runtime_agent.queries'])\n</code></pre> <p>If successful, handlers are discovered and registered normally.</p>"},{"location":"features/resilient-handler-discovery/#stage-2-individual-module-fallback","title":"Stage 2: Individual Module Fallback","text":"<pre><code># If package import fails, falls back to:\n# 1. Discover individual .py files in the package directory\n# 2. Attempt to import each module individually\n# 3. Register handlers from successful imports\n# 4. Skip modules with import failures\n\n# Example fallback discovery:\n# application.runtime_agent.queries.get_worker_query     \u2705 SUCCESS\n# application.runtime_agent.queries.list_workers_query   \u2705 SUCCESS\n# application.runtime_agent.queries.broken_module        \u274c SKIPPED\n</code></pre>"},{"location":"features/resilient-handler-discovery/#usage-examples","title":"\ud83d\ude80 Usage Examples","text":""},{"location":"features/resilient-handler-discovery/#basic-usage-unchanged","title":"Basic Usage (Unchanged)","text":"<pre><code>from neuroglia.mediation import Mediator\nfrom neuroglia.hosting import WebApplicationBuilder\n\nbuilder = WebApplicationBuilder()\n\n# This now works even if some packages have dependency issues\nMediator.configure(builder, [\n    'application.commands',           # May have legacy UseCase imports\n    'application.queries',            # Clean CQRS handlers\n    'application.event_handlers'      # Mixed dependencies\n])\n\napp = builder.build()\n</code></pre>"},{"location":"features/resilient-handler-discovery/#mixed-legacymodern-codebase","title":"Mixed Legacy/Modern Codebase","text":"<pre><code># Your package structure:\n# application/\n# \u251c\u2500\u2500 __init__.py                    # \u274c Imports missing UseCase class\n# \u251c\u2500\u2500 legacy_use_cases.py           # \u274c Uses old patterns\n# \u2514\u2500\u2500 queries/\n#     \u251c\u2500\u2500 __init__.py               # \u2705 Clean file\n#     \u251c\u2500\u2500 get_user_query.py         # \u2705 Valid QueryHandler\n#     \u2514\u2500\u2500 list_users_query.py       # \u2705 Valid QueryHandler\n\n# This now works! Handlers are discovered from individual modules\nMediator.configure(builder, ['application.queries'])\n</code></pre>"},{"location":"features/resilient-handler-discovery/#debugging-discovery-issues","title":"Debugging Discovery Issues","text":"<pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\n\n# Enable detailed logging to see what's discovered vs skipped\nMediator.configure(builder, ['your.package.name'])\n\n# Sample output:\n# WARNING: Package import failed for 'application.queries': UseCase not found\n# INFO: Attempting fallback: scanning individual modules\n# DEBUG: Discovered submodule: application.queries.get_user_query\n# DEBUG: Discovered submodule: application.queries.list_users_query\n# INFO: Successfully registered 2 handlers from submodule: application.queries.get_user_query\n# INFO: Fallback succeeded: registered 4 handlers from individual modules\n</code></pre>"},{"location":"features/resilient-handler-discovery/#logging-and-diagnostics","title":"\ud83d\udd0d Logging and Diagnostics","text":"<p>The resilient discovery provides comprehensive logging at different levels:</p>"},{"location":"features/resilient-handler-discovery/#info-level-summary-information","title":"INFO Level - Summary Information","text":"<pre><code>INFO: Successfully registered 3 handlers from package: application.commands\nINFO: Fallback succeeded: registered 2 handlers from individual modules in 'application.queries'\nINFO: Handler discovery completed: 5 total handlers registered from 2 module specifications\n</code></pre>"},{"location":"features/resilient-handler-discovery/#warning-level-import-issues","title":"WARNING Level - Import Issues","text":"<pre><code>WARNING: Package import failed for 'application.queries': cannot import name 'UseCase'\nWARNING: No submodules discovered for package: broken.package\nWARNING: Error registering handlers from module application.legacy: circular import\n</code></pre>"},{"location":"features/resilient-handler-discovery/#debug-level-detailed-discovery","title":"DEBUG Level - Detailed Discovery","text":"<pre><code>DEBUG: Attempting to load package: application.queries\nDEBUG: Found 3 potential submodules in application.queries\nDEBUG: Discovered submodule: application.queries.get_user_query\nDEBUG: Successfully registered QueryHandler: GetUserQueryHandler from application.queries.get_user_query\nDEBUG: Skipping submodule 'application.queries.broken_module': ImportError\n</code></pre>"},{"location":"features/resilient-handler-discovery/#best-practices","title":"\ud83e\uddea Best Practices","text":""},{"location":"features/resilient-handler-discovery/#1-incremental-migration-strategy","title":"1. Incremental Migration Strategy","text":"<pre><code># Start with clean packages, gradually add legacy ones\nmodules = [\n    'application.commands.user',      # \u2705 Clean CQRS handlers\n    'application.queries.user',       # \u2705 Clean CQRS handlers\n    'application.legacy.commands',    # \u26a0\ufe0f  Mixed patterns - will use fallback\n]\n\nMediator.configure(builder, modules)\n</code></pre>"},{"location":"features/resilient-handler-discovery/#2-package-organization","title":"2. Package Organization","text":"<pre><code># Recommended: Separate clean handlers from legacy code\napplication/\n\u251c\u2500\u2500 handlers/              # \u2705 Clean CQRS handlers only\n\u2502   \u251c\u2500\u2500 commands/\n\u2502   \u2514\u2500\u2500 queries/\n\u2514\u2500\u2500 legacy/               # \u26a0\ufe0f  Old patterns with complex dependencies\n    \u251c\u2500\u2500 use_cases/\n    \u2514\u2500\u2500 services/\n</code></pre>"},{"location":"features/resilient-handler-discovery/#3-gradual-cleanup","title":"3. Gradual Cleanup","text":"<pre><code># As you migrate legacy code, packages will automatically\n# switch from fallback discovery to normal discovery\n# No changes needed in configuration!\n\n# Before migration (uses fallback):\n# WARNING: Package import failed, using fallback discovery\n\n# After migration (normal discovery):\n# INFO: Successfully registered 5 handlers from package: application.commands\n</code></pre>"},{"location":"features/resilient-handler-discovery/#advanced-configuration","title":"\ud83d\udd27 Advanced Configuration","text":""},{"location":"features/resilient-handler-discovery/#individual-module-specification","title":"Individual Module Specification","text":"<p>You can also specify individual modules instead of packages:</p> <pre><code>Mediator.configure(builder, [\n    'application.commands.create_user_command',\n    'application.commands.update_user_command',\n    'application.queries.get_user_query'\n])\n</code></pre>"},{"location":"features/resilient-handler-discovery/#error-handling","title":"Error Handling","text":"<pre><code>try:\n    Mediator.configure(builder, ['your.package'])\nexcept Exception as e:\n    # Resilient discovery should prevent most exceptions,\n    # but you can still catch unexpected errors\n    logger.error(f\"Handler discovery failed: {e}\")\n</code></pre>"},{"location":"features/resilient-handler-discovery/#migration-from-manual-registration","title":"\ud83d\udea8 Migration from Manual Registration","text":""},{"location":"features/resilient-handler-discovery/#before-manual-workaround","title":"Before (Manual Workaround)","text":"<pre><code># Old approach - manual registration due to import failures\ntry:\n    from application.queries.get_user_query import GetUserQueryHandler\n    from application.queries.list_users_query import ListUsersQueryHandler\n\n    builder.services.add_scoped(GetUserQueryHandler)\n    builder.services.add_scoped(ListUsersQueryHandler)\n    log.debug(\"Manually registered query handlers\")\nexcept ImportError as e:\n    log.warning(f\"Could not register handlers: {e}\")\n</code></pre>"},{"location":"features/resilient-handler-discovery/#after-automatic-discovery","title":"After (Automatic Discovery)","text":"<pre><code># New approach - automatic resilient discovery\nMediator.configure(builder, ['application.queries'])\n# That's it! No manual registration needed\n</code></pre>"},{"location":"features/resilient-handler-discovery/#important-notes","title":"\u26a0\ufe0f Important Notes","text":""},{"location":"features/resilient-handler-discovery/#backward-compatibility","title":"Backward Compatibility","text":"<ul> <li>100% backward compatible - existing code continues to work unchanged</li> <li>No breaking changes - all existing <code>Mediator.configure()</code> calls work as before</li> <li>Enhanced behavior - only adds fallback capability when needed</li> </ul>"},{"location":"features/resilient-handler-discovery/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Package discovery first - normal path is unchanged and just as fast</li> <li>Fallback only when needed - individual module discovery only triggers on import failures</li> <li>Directory scanning - minimal filesystem operations, cached results</li> <li>Logging overhead - debug logging can be disabled in production</li> </ul>"},{"location":"features/resilient-handler-discovery/#limitations","title":"Limitations","text":"<ul> <li>Directory structure dependent - requires standard Python package layout</li> <li>Search paths - looks in <code>src/</code>, <code>./</code>, and <code>app/</code> directories</li> <li>File system access - requires read permissions to package directories</li> </ul>"},{"location":"features/resilient-handler-discovery/#benefits","title":"\ud83c\udf89 Benefits","text":""},{"location":"features/resilient-handler-discovery/#for-developers","title":"For Developers","text":"<ul> <li>Reduced friction during legacy code migration</li> <li>Automatic discovery without manual registration</li> <li>Clear diagnostics about what was discovered vs skipped</li> <li>Incremental adoption of CQRS patterns</li> </ul>"},{"location":"features/resilient-handler-discovery/#for-projects","title":"For Projects","text":"<ul> <li>Mixed architectural patterns supported</li> <li>Gradual modernization without breaking changes</li> <li>Complex dependency graphs handled gracefully</li> <li>Better development experience with detailed logging</li> </ul>"},{"location":"features/resilient-handler-discovery/#for-teams","title":"For Teams","text":"<ul> <li>Parallel development - teams can work on different parts without breaking discovery</li> <li>Easier onboarding - less manual configuration needed</li> <li>Reduced support burden - fewer \"handler not found\" issues</li> </ul> <p>The resilient discovery makes the Neuroglia framework significantly more robust for real-world codebases with complex dependencies and mixed architectural patterns! \ud83c\udfaf</p>"},{"location":"features/serialization/","title":"\ud83d\udd04 Serialization &amp; Deserialization","text":"<p>Neuroglia provides powerful and flexible serialization capabilities for converting objects to and from various formats like JSON. The framework includes built-in serializers with automatic type handling, custom converters, and seamless integration with the dependency injection system.</p> <p>!!! info \"\ud83c\udfaf What You'll Learn\" - JSON serialization with automatic type handling - Custom serializers and converters - Integration with Mario's Pizzeria domain objects - Best practices for data transformation</p>"},{"location":"features/serialization/#overview","title":"\ud83c\udfaf Overview","text":"<p>Neuroglia's serialization system offers:</p> <ul> <li>\ud83d\udd04 Automatic Type Handling - Seamless conversion of complex objects, enums, and collections</li> <li>\ud83d\udcc5 Built-in Type Support - Native handling of dates, decimals, UUIDs, and custom types</li> <li>\ud83c\udfa8 Custom Converters - Extensible system for specialized serialization logic</li> <li>\ud83d\udc89 DI Integration - Service-based serializers with configurable lifetimes</li> <li>\ud83e\uddea Test-Friendly - Easy mocking and testing of serialization logic</li> </ul>"},{"location":"features/serialization/#key-benefits","title":"Key Benefits","text":"<ul> <li>Type Safety: Strongly-typed deserialization with validation</li> <li>Performance: Efficient JSON processing with minimal overhead</li> <li>Flexibility: Support for custom serialization logic and converters</li> <li>Consistency: Unified serialization patterns across the application</li> </ul>"},{"location":"features/serialization/#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<pre><code>flowchart TD\n    A[\"\ud83c\udfaf Client Code&lt;br/&gt;Business Objects\"]\n    B[\"\ud83d\udd04 JsonSerializer&lt;br/&gt;Main Serialization Service\"]\n    C[\"\ud83d\udccb JsonEncoder&lt;br/&gt;Custom Type Handling\"]\n    D[\"\ud83c\udfa8 Type Converters&lt;br/&gt;Specialized Logic\"]\n\n    subgraph \"\ud83d\udce6 Serialization Pipeline\"\n        E[\"Object \u2192 JSON\"]\n        F[\"JSON \u2192 Object\"]\n        G[\"Type Detection\"]\n        H[\"Recursive Processing\"]\n    end\n\n    subgraph \"\ud83c\udfaf Formats\"\n        I[\"JSON String\"]\n        J[\"Byte Array\"]\n        K[\"Stream Data\"]\n    end\n\n    A --&gt; B\n    B --&gt; C\n    B --&gt; D\n    B --&gt; E\n    B --&gt; F\n    E --&gt; G\n    F --&gt; H\n\n    E --&gt; I\n    E --&gt; J\n    F --&gt; I\n    F --&gt; J\n\n    style B fill:#e1f5fe,stroke:#0277bd,stroke-width:3px\n    style C fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\n    style D fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px\n\n    classDef pipeline fill:#fff3e0,stroke:#f57c00,stroke-width:2px\n    class E,F,G,H pipeline</code></pre>"},{"location":"features/serialization/#basic-usage-in-marios-pizzeria","title":"\ud83c\udf55 Basic Usage in Mario's Pizzeria","text":""},{"location":"features/serialization/#pizza-order-serialization","title":"Pizza Order Serialization","text":"<p>Let's see how Mario's Pizzeria uses serialization for order processing:</p> <pre><code>from neuroglia.serialization.json import JsonSerializer\nfrom neuroglia.dependency_injection import ServiceCollection\nfrom decimal import Decimal\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom enum import Enum\n\n# Domain objects from Mario's Pizzeria\nclass OrderStatus(str, Enum):\n    PENDING = \"pending\"\n    COOKING = \"cooking\"\n    READY = \"ready\"\n    DELIVERED = \"delivered\"\n\n@dataclass\nclass Pizza:\n    id: str\n    name: str\n    size: str\n    base_price: Decimal\n    toppings: list[str]\n\n@dataclass\nclass Order:\n    id: str\n    customer_name: str\n    customer_phone: str\n    pizzas: list[Pizza]\n    status: OrderStatus\n    order_time: datetime\n    total_amount: Decimal\n\n# Using JsonSerializer\nclass OrderService:\n    def __init__(self, serializer: JsonSerializer):\n        self.serializer = serializer\n\n    def serialize_order(self, order: Order) -&gt; str:\n        \"\"\"Convert order to JSON for storage or API responses\"\"\"\n        return self.serializer.serialize_to_text(order)\n\n    def deserialize_order(self, json_data: str) -&gt; Order:\n        \"\"\"Convert JSON back to Order object\"\"\"\n        return self.serializer.deserialize_from_text(json_data, Order)\n\n# Example usage\nserializer = JsonSerializer()\norder = Order(\n    id=\"order-123\",\n    customer_name=\"Mario Luigi\",\n    customer_phone=\"+1-555-PIZZA\",\n    pizzas=[\n        Pizza(\"pizza-1\", \"Margherita\", \"large\", Decimal(\"15.99\"), [\"basil\", \"mozzarella\"])\n    ],\n    status=OrderStatus.PENDING,\n    order_time=datetime.now(),\n    total_amount=Decimal(\"17.49\")\n)\n\n# Serialize to JSON\njson_order = serializer.serialize_to_text(order)\nprint(json_order)\n# Output: {\"id\": \"order-123\", \"customer_name\": \"Mario Luigi\", ...}\n\n# Deserialize back to object\nrestored_order = serializer.deserialize_from_text(json_order, Order)\nassert restored_order.customer_name == \"Mario Luigi\"\nassert restored_order.status == OrderStatus.PENDING\n</code></pre>"},{"location":"features/serialization/#custom-json-encoder","title":"\ud83c\udfa8 Custom JSON Encoder","text":"<p>Neuroglia includes a custom <code>JsonEncoder</code> that handles special types automatically:</p> <pre><code>from neuroglia.serialization.json import JsonEncoder\nimport json\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom enum import Enum\n\nclass PizzaSize(str, Enum):\n    SMALL = \"small\"\n    MEDIUM = \"medium\"\n    LARGE = \"large\"\n\n# The JsonEncoder automatically handles these types:\ndata = {\n    \"order_time\": datetime.now(),       # \u2192 ISO format string\n    \"total_amount\": Decimal(\"15.99\"),   # \u2192 string representation\n    \"size\": PizzaSize.LARGE,           # \u2192 enum name\n    \"custom_object\": Pizza(...)         # \u2192 object's __dict__\n}\n\njson_string = json.dumps(data, cls=JsonEncoder)\n</code></pre>"},{"location":"features/serialization/#encoder-features","title":"Encoder Features","text":"<p>The <code>JsonEncoder</code> provides:</p> <ul> <li>DateTime Conversion: Automatic ISO format serialization</li> <li>Enum Handling: Uses enum names for consistent serialization</li> <li>Decimal Support: Preserves precision for monetary values</li> <li>Object Filtering: Excludes private attributes and None values</li> <li>Fallback Handling: Safe string conversion for unknown types</li> </ul>"},{"location":"features/serialization/#advanced-serialization-patterns","title":"\ud83d\udd27 Advanced Serialization Patterns","text":""},{"location":"features/serialization/#1-nested-object-serialization","title":"1. Nested Object Serialization","text":"<pre><code>@dataclass\nclass Customer:\n    id: str\n    name: str\n    email: str\n    addresses: list[Address]\n\n@dataclass\nclass Address:\n    street: str\n    city: str\n    postal_code: str\n\n# Automatic recursive serialization\ncustomer = Customer(\n    id=\"cust-123\",\n    name=\"Luigi Mario\",\n    email=\"luigi@pizzeria.com\",\n    addresses=[\n        Address(\"123 Main St\", \"Pizza City\", \"12345\"),\n        Address(\"456 Oak Ave\", \"Pepperoni Town\", \"67890\")\n    ]\n)\n\nserializer = JsonSerializer()\njson_data = serializer.serialize_to_text(customer)\nrestored_customer = serializer.deserialize_from_text(json_data, Customer)\n</code></pre>"},{"location":"features/serialization/#2-generic-type-handling","title":"2. Generic Type Handling","text":"<pre><code>from typing import List, Dict, Optional\n\n@dataclass\nclass MenuSection:\n    name: str\n    pizzas: List[Pizza]\n    metadata: Dict[str, str]\n    featured_pizza: Optional[Pizza] = None\n\n# Serializer handles generic types automatically\nmenu_section = MenuSection(\n    name=\"Classic Pizzas\",\n    pizzas=[margherita_pizza, pepperoni_pizza],\n    metadata={\"category\": \"traditional\", \"popularity\": \"high\"},\n    featured_pizza=margherita_pizza\n)\n\n# Serialization preserves type information\njson_data = serializer.serialize_to_text(menu_section)\nrestored_section = serializer.deserialize_from_text(json_data, MenuSection)\n</code></pre>"},{"location":"features/serialization/#3-integration-with-dependency-injection","title":"3. Integration with Dependency Injection","text":"<pre><code>from neuroglia.hosting import WebApplicationBuilder\n\ndef configure_serialization(builder: WebApplicationBuilder):\n    \"\"\"Configure serialization services\"\"\"\n\n    # Register JsonSerializer as singleton\n    builder.services.add_singleton(JsonSerializer)\n\n    # Use in controllers\n    class OrdersController(ControllerBase):\n        def __init__(self,\n                     service_provider: ServiceProviderBase,\n                     mapper: Mapper,\n                     mediator: Mediator,\n                     serializer: JsonSerializer):  # Injected automatically\n            super().__init__(service_provider, mapper, mediator)\n            self.serializer = serializer\n\n        @post(\"/export\")\n        async def export_orders(self) -&gt; str:\n            \"\"\"Export all orders as JSON\"\"\"\n            orders = await self.get_all_orders()\n            return self.serializer.serialize_to_text(orders)\n</code></pre>"},{"location":"features/serialization/#testing-serialization","title":"\ud83e\uddea Testing Serialization","text":""},{"location":"features/serialization/#unit-testing-patterns","title":"Unit Testing Patterns","text":"<pre><code>import pytest\nfrom neuroglia.serialization.json import JsonSerializer\n\nclass TestPizzaOrderSerialization:\n\n    def setup_method(self):\n        self.serializer = JsonSerializer()\n\n    def test_order_serialization_round_trip(self):\n        \"\"\"Test complete serialization/deserialization cycle\"\"\"\n        # Arrange\n        original_order = create_test_order()\n\n        # Act\n        json_data = self.serializer.serialize_to_text(original_order)\n        restored_order = self.serializer.deserialize_from_text(json_data, Order)\n\n        # Assert\n        assert restored_order.id == original_order.id\n        assert restored_order.customer_name == original_order.customer_name\n        assert restored_order.status == original_order.status\n        assert len(restored_order.pizzas) == len(original_order.pizzas)\n\n    def test_handles_none_values_gracefully(self):\n        \"\"\"Test serialization with None values\"\"\"\n        # Arrange\n        order = Order(\n            id=\"test-order\",\n            customer_name=\"Test Customer\",\n            customer_phone=None,  # None value\n            pizzas=[],\n            status=OrderStatus.PENDING,\n            order_time=datetime.now(),\n            total_amount=Decimal(\"0.00\")\n        )\n\n        # Act &amp; Assert\n        json_data = self.serializer.serialize_to_text(order)\n        restored_order = self.serializer.deserialize_from_text(json_data, Order)\n\n        assert restored_order.customer_phone is None\n\n    def test_decimal_precision_preserved(self):\n        \"\"\"Test that decimal precision is maintained\"\"\"\n        # Arrange\n        pizza = Pizza(\n            id=\"test-pizza\",\n            name=\"Test Pizza\",\n            size=\"medium\",\n            base_price=Decimal(\"12.99\"),\n            toppings=[]\n        )\n\n        # Act\n        json_data = self.serializer.serialize_to_text(pizza)\n        restored_pizza = self.serializer.deserialize_from_text(json_data, Pizza)\n\n        # Assert\n        assert restored_pizza.base_price == Decimal(\"12.99\")\n        assert isinstance(restored_pizza.base_price, Decimal)\n</code></pre>"},{"location":"features/serialization/#real-world-use-cases","title":"\ud83c\udfaf Real-World Use Cases","text":""},{"location":"features/serialization/#1-api-response-serialization","title":"1. API Response Serialization","text":"<pre><code>from fastapi import FastAPI\nfrom fastapi.responses import JSONResponse\n\nclass MenuController(ControllerBase):\n\n    @get(\"/menu\")\n    async def get_menu(self) -&gt; JSONResponse:\n        \"\"\"Get pizzeria menu as JSON\"\"\"\n        menu_items = await self.get_menu_items()\n\n        # Serialize complex menu structure\n        json_data = self.serializer.serialize_to_text(menu_items)\n\n        return JSONResponse(\n            content=json_data,\n            media_type=\"application/json\"\n        )\n</code></pre>"},{"location":"features/serialization/#2-event-payload-serialization","title":"2. Event Payload Serialization","text":"<pre><code>from neuroglia.eventing import DomainEvent\n\n@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    order_id: str\n    customer_email: str\n    order_details: Order\n\nclass OrderEventHandler:\n    def __init__(self, serializer: JsonSerializer):\n        self.serializer = serializer\n\n    async def handle_order_placed(self, event: OrderPlacedEvent):\n        \"\"\"Handle order placed event with serialization\"\"\"\n\n        # Serialize event for external systems\n        event_json = self.serializer.serialize_to_text(event)\n\n        # Send to message queue, webhook, etc.\n        await self.send_to_external_system(event_json)\n\n        # Log structured event data\n        logger.info(\"Order placed\", extra={\n            \"event_data\": event_json,\n            \"order_id\": event.order_id\n        })\n</code></pre>"},{"location":"features/serialization/#3-configuration-and-settings","title":"3. Configuration and Settings","text":"<pre><code>@dataclass\nclass PizzeriaConfig:\n    name: str\n    address: Address\n    operating_hours: Dict[str, str]\n    menu_sections: List[MenuSection]\n    pricing_rules: Dict[str, Decimal]\n\nclass ConfigurationService:\n    def __init__(self, serializer: JsonSerializer):\n        self.serializer = serializer\n\n    def load_config(self, config_path: str) -&gt; PizzeriaConfig:\n        \"\"\"Load pizzeria configuration from JSON file\"\"\"\n        with open(config_path, 'r') as f:\n            json_data = f.read()\n\n        return self.serializer.deserialize_from_text(json_data, PizzeriaConfig)\n\n    def save_config(self, config: PizzeriaConfig, config_path: str):\n        \"\"\"Save pizzeria configuration to JSON file\"\"\"\n        json_data = self.serializer.serialize_to_text(config)\n\n        with open(config_path, 'w') as f:\n            f.write(json_data)\n</code></pre>"},{"location":"features/serialization/#error-handling-and-validation","title":"\ud83d\udd0d Error Handling and Validation","text":""},{"location":"features/serialization/#robust-serialization-patterns","title":"Robust Serialization Patterns","text":"<pre><code>from typing import Union\nimport logging\n\nclass SafeSerializationService:\n    def __init__(self, serializer: JsonSerializer):\n        self.serializer = serializer\n        self.logger = logging.getLogger(__name__)\n\n    def safe_serialize(self, obj: Any) -&gt; Union[str, None]:\n        \"\"\"Safely serialize object with error handling\"\"\"\n        try:\n            return self.serializer.serialize_to_text(obj)\n        except Exception as e:\n            self.logger.error(f\"Serialization failed for {type(obj)}: {e}\")\n            return None\n\n    def safe_deserialize(self, json_data: str, target_type: Type[T]) -&gt; Union[T, None]:\n        \"\"\"Safely deserialize with validation\"\"\"\n        try:\n            if not json_data or not json_data.strip():\n                return None\n\n            result = self.serializer.deserialize_from_text(json_data, target_type)\n\n            # Additional validation\n            if hasattr(result, 'validate'):\n                result.validate()\n\n            return result\n\n        except json.JSONDecodeError as e:\n            self.logger.error(f\"Invalid JSON format: {e}\")\n            return None\n        except Exception as e:\n            self.logger.error(f\"Deserialization failed: {e}\")\n            return None\n</code></pre>"},{"location":"features/serialization/#performance-considerations","title":"\ud83d\ude80 Performance Considerations","text":""},{"location":"features/serialization/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Reuse Serializer Instances: Register as singleton in DI container</li> <li>Minimize Object Creation: Use object pooling for high-frequency serialization</li> <li>Stream Processing: Use byte arrays for large data sets</li> <li>Selective Serialization: Exclude unnecessary fields to reduce payload size</li> </ol> <pre><code># Performance-optimized serialization\nclass OptimizedOrderService:\n    def __init__(self, serializer: JsonSerializer):\n        self.serializer = serializer\n        self._byte_buffer = bytearray(8192)  # Reusable buffer\n\n    def serialize_order_summary(self, order: Order) -&gt; str:\n        \"\"\"Serialize only essential order information\"\"\"\n        summary = {\n            \"id\": order.id,\n            \"customer_name\": order.customer_name,\n            \"status\": order.status.value,\n            \"total_amount\": str(order.total_amount),\n            \"pizza_count\": len(order.pizzas)\n        }\n        return self.serializer.serialize_to_text(summary)\n</code></pre>"},{"location":"features/serialization/#integration-points","title":"\ud83d\udd17 Integration Points","text":""},{"location":"features/serialization/#framework-integration","title":"Framework Integration","text":"<p>Serialization integrates seamlessly with:</p> <ul> <li>Object Mapping - Automatic DTO conversion before serialization</li> <li>MVC Controllers - Automatic request/response serialization</li> <li>Event Sourcing - Event payload serialization for persistence</li> <li>Data Access - Document serialization for MongoDB storage</li> </ul>"},{"location":"features/serialization/#next-steps","title":"\ud83d\udcda Next Steps","text":"<p>Explore related Neuroglia features:</p> <ul> <li>Object Mapping - Transform objects before serialization</li> <li>MVC Controllers - Automatic API serialization</li> <li>Event Sourcing - Event payload handling</li> <li>Getting Started Guide - Complete pizzeria implementation</li> </ul> <p>\ud83c\udfaf Best Practice</p> <p>Always register <code>JsonSerializer</code> as a singleton in your DI container for optimal performance and consistent behavior across your application.</p>"},{"location":"features/simple-cqrs/","title":"\ud83c\udfaf Simple CQRS Patterns","text":"<p>This guide shows how to use Neuroglia's simplified CQRS patterns for applications that need clean command/query separation without complex event sourcing or cloud events infrastructure.</p>"},{"location":"features/simple-cqrs/#when-to-use-simple-cqrs","title":"\ud83c\udfaf When to Use Simple CQRS","text":"<p>Use the simple CQRS patterns when you need:</p> <ul> <li>Clean separation of read and write operations</li> <li>Basic validation and business logic handling</li> <li>In-memory testing or simple database operations</li> <li>Minimal setup without event sourcing complexity</li> <li>Rapid prototyping of business logic</li> </ul> <p>Don't use simple patterns when you need:</p> <ul> <li>Event sourcing and domain events</li> <li>Cloud events integration</li> <li>Complex workflow orchestration</li> <li>Advanced audit trails</li> </ul>"},{"location":"features/simple-cqrs/#basic-setup","title":"\ud83c\udfd7\ufe0f Basic Setup","text":""},{"location":"features/simple-cqrs/#minimal-example-5-lines-of-setup","title":"Minimal Example (5 lines of setup)","text":"<pre><code>from neuroglia.mediation import (\n    Command, Query, CommandHandler, QueryHandler,\n    create_simple_app, InMemoryRepository\n)\n\n# One-line app creation\nprovider = create_simple_app(CreateTaskHandler, GetTaskHandler,\n                           repositories=[InMemoryRepository[Task]])\nmediator = provider.get_service(Mediator)\n</code></pre>"},{"location":"features/simple-cqrs/#standard-setup","title":"Standard Setup","text":"<pre><code>from neuroglia.mediation import (\n    add_simple_mediator, register_simple_handlers\n)\nfrom neuroglia.dependency_injection import ServiceCollection\n\n# Create service collection\nservices = ServiceCollection()\n\n# Add simple mediator (no cloud events)\nadd_simple_mediator(services)\n\n# Add repositories\nservices.add_singleton(InMemoryRepository[Task])\n\n# Register handlers\nregister_simple_handlers(services, CreateTaskHandler, GetTaskHandler)\n\n# Build provider\nprovider = services.build()\n</code></pre>"},{"location":"features/simple-cqrs/#complete-working-example","title":"\ud83d\ude80 Complete Working Example","text":""},{"location":"features/simple-cqrs/#1-define-your-models","title":"1. Define Your Models","text":"<pre><code>from dataclasses import dataclass\n\n# Domain model\n@dataclass\nclass Task:\n    id: str\n    title: str\n    completed: bool = False\n\n# DTO for API responses\n@dataclass\nclass TaskDto:\n    id: str\n    title: str\n    completed: bool\n</code></pre>"},{"location":"features/simple-cqrs/#2-define-commands-and-queries","title":"2. Define Commands and Queries","text":"<pre><code>from neuroglia.mediation import Command, Query\nfrom neuroglia.core.operation_result import OperationResult\n\n@dataclass\nclass CreateTaskCommand(Command[OperationResult[TaskDto]]):\n    title: str\n\n@dataclass\nclass GetTaskQuery(Query[OperationResult[TaskDto]]):\n    task_id: str\n\n@dataclass\nclass CompleteTaskCommand(Command[OperationResult[TaskDto]]):\n    task_id: str\n</code></pre>"},{"location":"features/simple-cqrs/#3-implement-handlers","title":"3. Implement Handlers","text":"<pre><code>import uuid\nfrom neuroglia.mediation import CommandHandler, QueryHandler\n\nclass CreateTaskHandler(CommandHandler[CreateTaskCommand, OperationResult[TaskDto]]):\n    def __init__(self, repository: InMemoryRepository[Task]):\n        self.repository = repository\n\n    async def handle_async(self, request: CreateTaskCommand) -&gt; OperationResult[TaskDto]:\n        # Validation\n        if not request.title.strip():\n            return self.bad_request(\"Title cannot be empty\")\n\n        # Business logic\n        task = Task(str(uuid.uuid4()), request.title.strip())\n        await self.repository.save_async(task)\n\n        # Return result\n        dto = TaskDto(task.id, task.title, task.completed)\n        return self.created(dto)\n\nclass GetTaskHandler(QueryHandler[GetTaskQuery, OperationResult[TaskDto]]):\n    def __init__(self, repository: InMemoryRepository[Task]):\n        self.repository = repository\n\n    async def handle_async(self, request: GetTaskQuery) -&gt; OperationResult[TaskDto]:\n        task = await self.repository.get_by_id_async(request.task_id)\n\n        if not task:\n            return self.not_found(Task, request.task_id)\n\n        dto = TaskDto(task.id, task.title, task.completed)\n        return self.ok(dto)\n\nclass CompleteTaskHandler(CommandHandler[CompleteTaskCommand, OperationResult[TaskDto]]):\n    def __init__(self, repository: InMemoryRepository[Task]):\n        self.repository = repository\n\n    async def handle_async(self, request: CompleteTaskCommand) -&gt; OperationResult[TaskDto]:\n        task = await self.repository.get_by_id_async(request.task_id)\n\n        if not task:\n            return self.not_found(Task, request.task_id)\n\n        if task.completed:\n            return self.bad_request(\"Task is already completed\")\n\n        # Business logic\n        task.completed = True\n        await self.repository.save_async(task)\n\n        dto = TaskDto(task.id, task.title, task.completed)\n        return self.ok(dto)\n</code></pre>"},{"location":"features/simple-cqrs/#4-create-and-use-your-application","title":"4. Create and Use Your Application","text":"<pre><code>import asyncio\n\nasync def main():\n    # Create app with ultra-simple setup\n    provider = create_simple_app(\n        CreateTaskHandler,\n        GetTaskHandler,\n        CompleteTaskHandler,\n        repositories=[InMemoryRepository[Task]]\n    )\n\n    mediator = provider.get_service(Mediator)\n\n    # Create a task\n    create_result = await mediator.execute_async(\n        CreateTaskCommand(\"Learn Neuroglia CQRS\")\n    )\n\n    if create_result.is_success:\n        print(f\"\u2705 Created: {create_result.data.title}\")\n        task_id = create_result.data.id\n\n        # Complete the task\n        complete_result = await mediator.execute_async(\n            CompleteTaskCommand(task_id)\n        )\n\n        if complete_result.is_success:\n            print(f\"\u2705 Completed: {complete_result.data.title}\")\n\n        # Get the task\n        get_result = await mediator.execute_async(GetTaskQuery(task_id))\n\n        if get_result.is_success:\n            task = get_result.data\n            print(f\"\ud83d\udccb Task: {task.title} (completed: {task.completed})\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"features/simple-cqrs/#key-patterns","title":"\ud83d\udca1 Key Patterns","text":""},{"location":"features/simple-cqrs/#validation-and-error-handling","title":"Validation and Error Handling","text":"<pre><code>async def handle_async(self, request: CreateUserCommand) -&gt; OperationResult[UserDto]:\n    # Input validation\n    if not request.email:\n        return self.bad_request(\"Email is required\")\n\n    if \"@\" not in request.email:\n        return self.bad_request(\"Invalid email format\")\n\n    # Business validation\n    existing_user = await self.repository.get_by_email_async(request.email)\n    if existing_user:\n        return self.conflict(f\"User with email {request.email} already exists\")\n\n    # Success path\n    user = User(str(uuid.uuid4()), request.name, request.email)\n    await self.repository.save_async(user)\n\n    dto = UserDto(user.id, user.name, user.email)\n    return self.created(dto)\n</code></pre>"},{"location":"features/simple-cqrs/#repository-patterns","title":"Repository Patterns","text":"<pre><code># Simple in-memory repository (for testing/prototyping)\nfrom neuroglia.mediation import InMemoryRepository\n\nclass UserRepository(InMemoryRepository[User]):\n    async def get_by_email_async(self, email: str) -&gt; Optional[User]:\n        for user in self._storage.values():\n            if user.email == email:\n                return user\n        return None\n</code></pre>"},{"location":"features/simple-cqrs/#query-result-patterns","title":"Query Result Patterns","text":"<pre><code># Single item query\n@dataclass\nclass GetUserQuery(Query[OperationResult[UserDto]]):\n    user_id: str\n\n# List query\n@dataclass\nclass ListUsersQuery(Query[OperationResult[List[UserDto]]]):\n    include_inactive: bool = False\n\n# Search query\n@dataclass\nclass SearchUsersQuery(Query[OperationResult[List[UserDto]]]):\n    search_term: str\n    page: int = 1\n    page_size: int = 10\n</code></pre>"},{"location":"features/simple-cqrs/#configuration-options","title":"\ud83d\udd27 Configuration Options","text":""},{"location":"features/simple-cqrs/#simple-application-settings","title":"Simple Application Settings","text":"<p>Instead of the full <code>ApplicationSettings</code>, use <code>SimpleApplicationSettings</code> for basic apps:</p> <pre><code>from neuroglia.mediation import SimpleApplicationSettings\n\n@dataclass\nclass MyAppSettings(SimpleApplicationSettings):\n    app_name: str = \"Task Manager\"\n    max_tasks_per_user: int = 100\n    enable_notifications: bool = True\n</code></pre>"},{"location":"features/simple-cqrs/#environment-integration","title":"Environment Integration","text":"<pre><code>import os\n\nsettings = SimpleApplicationSettings(\n    app_name=os.getenv(\"APP_NAME\", \"My App\"),\n    debug=os.getenv(\"DEBUG\", \"false\").lower() == \"true\",\n    database_url=os.getenv(\"DATABASE_URL\")\n)\n</code></pre>"},{"location":"features/simple-cqrs/#testing-patterns","title":"\ud83e\uddea Testing Patterns","text":""},{"location":"features/simple-cqrs/#unit-testing-handlers","title":"Unit Testing Handlers","text":"<pre><code>import pytest\nfrom unittest.mock import AsyncMock\n\n@pytest.mark.asyncio\nasync def test_create_task_success():\n    # Arrange\n    repository = AsyncMock(spec=InMemoryRepository[Task])\n    handler = CreateTaskHandler(repository)\n    command = CreateTaskCommand(\"Test task\")\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n    assert result.data.title == \"Test task\"\n    repository.save_async.assert_called_once()\n\n@pytest.mark.asyncio\nasync def test_create_task_empty_title():\n    # Arrange\n    repository = AsyncMock(spec=InMemoryRepository[Task])\n    handler = CreateTaskHandler(repository)\n    command = CreateTaskCommand(\"\")\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert not result.is_success\n    assert result.status_code == 400\n    assert \"empty\" in result.error_message.lower()\n</code></pre>"},{"location":"features/simple-cqrs/#integration-testing","title":"Integration Testing","text":"<pre><code>@pytest.mark.asyncio\nasync def test_complete_workflow():\n    # Create application\n    provider = create_simple_app(\n        CreateTaskHandler,\n        GetTaskHandler,\n        CompleteTaskHandler,\n        repositories=[InMemoryRepository[Task]]\n    )\n\n    mediator = provider.get_service(Mediator)\n\n    # Test complete workflow\n    create_result = await mediator.execute_async(CreateTaskCommand(\"Test\"))\n    assert create_result.is_success\n\n    task_id = create_result.data.id\n\n    get_result = await mediator.execute_async(GetTaskQuery(task_id))\n    assert get_result.is_success\n    assert not get_result.data.completed\n\n    complete_result = await mediator.execute_async(CompleteTaskCommand(task_id))\n    assert complete_result.is_success\n    assert complete_result.data.completed\n</code></pre>"},{"location":"features/simple-cqrs/#when-to-upgrade","title":"\ud83d\ude80 When to Upgrade","text":"<p>Consider upgrading to the full Neuroglia framework features when you need:</p>"},{"location":"features/simple-cqrs/#event-sourcing","title":"Event Sourcing","text":"<pre><code># Upgrade to event sourcing when you need:\n# - Complete audit trails\n# - Event replay capabilities\n# - Complex business workflows\n# - Temporal queries (\"what was the state at time X?\")\n</code></pre>"},{"location":"features/simple-cqrs/#cloud-events","title":"Cloud Events","text":"<pre><code># Upgrade to cloud events when you need:\n# - Microservice integration\n# - Event-driven architecture\n# - Cross-system communication\n# - Reliable event delivery\n</code></pre>"},{"location":"features/simple-cqrs/#domain-events","title":"Domain Events","text":"<pre><code># Upgrade to domain events when you need:\n# - Side effects from business operations\n# - Decoupled business logic\n# - Complex business rules\n# - Integration events\n</code></pre>"},{"location":"features/simple-cqrs/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Framework overview</li> <li>CQRS &amp; Mediation - Advanced CQRS patterns</li> <li>Dependency Injection - Advanced DI patterns</li> <li>Data Access - Repository patterns and persistence</li> </ul>"},{"location":"guides/","title":"\ud83d\udcda Guides and How-To's","text":"<p>\ud83d\udea7 Under Construction</p> <p>This section is currently being developed with step-by-step guides and practical examples. Individual guide pages with detailed procedures and troubleshooting tips are being created.</p> <p>Practical procedures and troubleshooting guides for developing with the Neuroglia framework.</p>"},{"location":"guides/#getting-started-guides","title":"\ud83d\ude80 Getting Started Guides","text":""},{"location":"guides/#project-setup","title":"Project Setup","text":"<ul> <li>Creating new projects with <code>pyneuroctl</code></li> <li>Setting up development environment</li> <li>Configuring IDE support</li> </ul>"},{"location":"guides/#testing-setup","title":"Testing Setup","text":"<ul> <li>Unit testing strategies</li> <li>Integration testing patterns</li> <li>Test data management</li> </ul>"},{"location":"guides/#development-guides","title":"\ud83c\udfd7\ufe0f Development Guides","text":""},{"location":"guides/#building-apis","title":"Building APIs","text":"<ul> <li>Creating controllers and endpoints</li> <li>Request/response modeling</li> <li>Authentication and authorization</li> </ul>"},{"location":"guides/#data-management","title":"Data Management","text":"<ul> <li>Repository implementation</li> <li>Database integration</li> <li>Event sourcing setup</li> </ul>"},{"location":"guides/#event-driven-development","title":"Event-Driven Development","text":"<ul> <li>Domain event design</li> <li>Event handlers</li> <li>CloudEvents integration</li> </ul>"},{"location":"guides/#operations-guides","title":"\ud83d\udd27 Operations Guides","text":""},{"location":"guides/#deployment","title":"Deployment","text":"<ul> <li>Docker containerization</li> <li>Kubernetes deployment</li> <li>Environment configuration</li> </ul>"},{"location":"guides/#monitoring","title":"Monitoring","text":"<ul> <li>Logging configuration</li> <li>Health checks</li> <li>Performance monitoring</li> </ul>"},{"location":"guides/#troubleshooting","title":"\ud83d\udc1b Troubleshooting","text":""},{"location":"guides/#common-issues","title":"Common Issues","text":"<ul> <li>Dependency injection problems</li> <li>Mediator configuration</li> <li>Database connectivity</li> </ul>"},{"location":"guides/#debugging-techniques","title":"Debugging Techniques","text":"<ul> <li>Testing strategies</li> <li>Logging best practices</li> <li>Performance profiling</li> </ul> <p>Detailed guides with step-by-step instructions coming soon \ud83d\udea7</p>"},{"location":"guides/3-min-bootstrap/","title":"\u26a1 3-Minute Bootstrap: Hello World","text":"<p>Get up and running with Neuroglia in under 3 minutes! This quick-start guide gets you from zero to a working API in the fastest way possible.</p> <p>\ud83c\udfaf What You'll Build</p> <p>A minimal \"Hello Pizzeria\" API with one endpoint that demonstrates the basic framework setup.</p>"},{"location":"guides/3-min-bootstrap/#quick-setup","title":"\ud83d\ude80 Quick Setup","text":""},{"location":"guides/3-min-bootstrap/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8+ installed</li> <li>pip package manager</li> </ul>"},{"location":"guides/3-min-bootstrap/#installation","title":"Installation","text":"<pre><code># Create new directory\nmkdir hello-pizzeria &amp;&amp; cd hello-pizzeria\n\n# Install Neuroglia\npip install neuroglia-python[web]\n</code></pre>"},{"location":"guides/3-min-bootstrap/#create-your-first-api","title":"\ud83d\udcdd Create Your First API","text":"<p>Create <code>main.py</code>:</p> <pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.mvc import ControllerBase\nfrom classy_fastapi.decorators import get\n\nclass HelloController(ControllerBase):\n    \"\"\"Simple hello world controller\"\"\"\n\n    @get(\"/hello\")\n    async def hello_world(self) -&gt; dict:\n        \"\"\"Say hello to Mario's Pizzeria!\"\"\"\n        return {\n            \"message\": \"Welcome to Mario's Pizzeria! \ud83c\udf55\",\n            \"status\": \"We're open for business!\",\n            \"framework\": \"Neuroglia Python\"\n        }\n\ndef create_app():\n    \"\"\"Create the web application\"\"\"\n    builder = WebApplicationBuilder()\n\n    # Add controllers\n    services = builder.services\n    services.add_controllers([HelloController])\n\n    # Build app\n    app = builder.build()\n    app.use_controllers()\n\n    return app\n\nif __name__ == \"__main__\":\n    import uvicorn\n    app = create_app()\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre>"},{"location":"guides/3-min-bootstrap/#run-your-api","title":"\ud83c\udfc3\u200d\u2642\ufe0f Run Your API","text":"<pre><code>python main.py\n</code></pre>"},{"location":"guides/3-min-bootstrap/#test-your-api","title":"\ud83c\udf89 Test Your API","text":"<p>Open your browser and visit:</p> <ul> <li>API Endpoint: http://localhost:8000/hello</li> <li>API Documentation: http://localhost:8000/docs</li> </ul> <p>You should see:</p> <pre><code>{\n  \"message\": \"Welcome to Mario's Pizzeria! \ud83c\udf55\",\n  \"status\": \"We're open for business!\",\n  \"framework\": \"Neuroglia Python\"\n}\n</code></pre>"},{"location":"guides/3-min-bootstrap/#what-youve-accomplished","title":"\u2705 What You've Accomplished","text":"<p>In just 3 minutes, you've created:</p> <ul> <li>\u2705 A working FastAPI application with Neuroglia</li> <li>\u2705 Automatic API documentation (Swagger UI)</li> <li>\u2705 Controller-based routing with clean architecture</li> <li>\u2705 Automatic module discovery</li> <li>\u2705 Dependency injection container setup</li> </ul>"},{"location":"guides/3-min-bootstrap/#next-steps","title":"\ud83d\udd04 Next Steps","text":"<p>Now that you have the basics working:</p> <ol> <li>\ud83d\udee0\ufe0f Local Development Setup - Set up a proper development environment</li> <li>\ud83c\udf55 Mario's Pizzeria Tutorial - Build a complete application (1 hour)</li> <li>\ud83c\udfaf Architecture Patterns - Learn the design principles</li> <li>\ud83d\ude80 Framework Features - Explore advanced capabilities</li> </ol>"},{"location":"guides/3-min-bootstrap/#key-concepts-introduced","title":"\ud83d\udd17 Key Concepts Introduced","text":"<p>This hello world example demonstrates:</p> <ul> <li>Controller Pattern - Web request handling</li> <li>Dependency Injection - Service container setup</li> <li>WebApplicationBuilder - Application bootstrapping</li> </ul> <p>\ud83c\udfaf Pro Tip</p> <p>This is just the beginning! The framework includes powerful features like CQRS, event sourcing, and advanced data access patterns. Continue with the Local Development Setup to explore more.</p>"},{"location":"guides/jsonserializer-configuration/","title":"JsonSerializer and TypeRegistry Configuration Examples","text":"<p>This document provides comprehensive configuration patterns for the JsonSerializer with TypeRegistry to support different project structures and domain discovery requirements.</p>"},{"location":"guides/jsonserializer-configuration/#overview","title":"Overview","text":"<p>The configurable type discovery system allows you to specify which modules contain your enums and domain types, eliminating the need for hardcoded patterns in the framework. This provides flexibility for different project architectures while maintaining performance through intelligent caching.</p>"},{"location":"guides/jsonserializer-configuration/#configuration-methods","title":"Configuration Methods","text":""},{"location":"guides/jsonserializer-configuration/#method-1-configure-during-jsonserializer-setup","title":"Method 1: Configure During JsonSerializer Setup","text":"<pre><code>from neuroglia.hosting.enhanced_web_application_builder import EnhancedWebApplicationBuilder\nfrom neuroglia.serialization.json import JsonSerializer\n\ndef configure_mario_pizzeria_types():\n    \"\"\"Example: Configure types for Mario Pizzeria application\"\"\"\n    builder = EnhancedWebApplicationBuilder()\n\n    # Configure during JsonSerializer setup\n    JsonSerializer.configure(\n        builder,\n        type_modules=[\n            \"domain.entities.enums\",    # Main enum module\n            \"domain.entities\",          # Entity module (for embedded enums)\n            \"domain.value_objects\",     # Value objects with enums\n            \"shared.enums\",             # Shared enumeration types\n        ]\n    )\n\n    return builder\n</code></pre>"},{"location":"guides/jsonserializer-configuration/#method-2-register-types-after-configuration","title":"Method 2: Register Types After Configuration","text":"<pre><code>from neuroglia.hosting.enhanced_web_application_builder import EnhancedWebApplicationBuilder\nfrom neuroglia.serialization.json import JsonSerializer\n\ndef configure_generic_ddd_application():\n    \"\"\"Example: Configure types for generic DDD application\"\"\"\n    builder = EnhancedWebApplicationBuilder()\n\n    # Configure JsonSerializer first\n    JsonSerializer.configure(builder)\n\n    # Register additional type modules\n    JsonSerializer.register_type_modules([\n        \"myapp.domain.aggregates\",\n        \"myapp.domain.value_objects\",\n        \"myapp.domain.enums\",\n        \"myapp.shared.types\",\n        \"myapp.integration.external_types\",\n    ])\n\n    return builder\n</code></pre>"},{"location":"guides/jsonserializer-configuration/#method-3-direct-typeregistry-configuration","title":"Method 3: Direct TypeRegistry Configuration","text":"<pre><code>from neuroglia.core.type_registry import get_type_registry\nfrom neuroglia.hosting.enhanced_web_application_builder import EnhancedWebApplicationBuilder\nfrom neuroglia.serialization.json import JsonSerializer\n\ndef configure_microservice_types():\n    \"\"\"Example: Configure types for microservice with external dependencies\"\"\"\n    builder = EnhancedWebApplicationBuilder()\n\n    # Get the global TypeRegistry instance\n    type_registry = get_type_registry()\n\n    # Register our domain modules\n    type_registry.register_modules([\n        \"orders.domain.entities\",\n        \"orders.domain.enums\",\n        \"orders.shared.types\"\n    ])\n\n    # Register shared library types\n    type_registry.register_modules([\n        \"shared_lib.common.enums\",\n        \"shared_lib.business.types\"\n    ])\n\n    # Register external API types that we need to deserialize\n    type_registry.register_modules([\n        \"external_api_client.models\",\n        \"payment_gateway.types\"\n    ])\n\n    JsonSerializer.configure(builder)\n\n    return builder\n</code></pre>"},{"location":"guides/jsonserializer-configuration/#project-structure-examples","title":"Project Structure Examples","text":""},{"location":"guides/jsonserializer-configuration/#flat-project-structure","title":"Flat Project Structure","text":"<pre><code>from neuroglia.hosting.enhanced_web_application_builder import EnhancedWebApplicationBuilder\nfrom neuroglia.serialization.json import JsonSerializer\n\ndef configure_flat_project_structure():\n    \"\"\"Example: Configure types for flat project structure\"\"\"\n    builder = EnhancedWebApplicationBuilder()\n\n    # For projects with flat structure like:\n    # myproject/\n    #   models.py\n    #   enums.py\n    #   types.py\n    JsonSerializer.configure(\n        builder,\n        type_modules=[\n            \"models\",      # Main model types\n            \"enums\",       # All enumerations\n            \"types\",       # Custom types\n            \"constants\",   # Constants and lookups\n        ]\n    )\n\n    return builder\n</code></pre>"},{"location":"guides/jsonserializer-configuration/#domain-driven-design-structure","title":"Domain-Driven Design Structure","text":"<pre><code>def configure_ddd_structure():\n    \"\"\"Example: Configure types for DDD project structure\"\"\"\n    # For projects with DDD structure like:\n    # myproject/\n    #   domain/\n    #     aggregates/\n    #     entities/\n    #     value_objects/\n    #     enums/\n    #   application/\n    #   infrastructure/\n\n    JsonSerializer.configure(\n        builder,\n        type_modules=[\n            \"domain.enums\",\n            \"domain.entities\",\n            \"domain.value_objects\",\n            \"domain.aggregates\",\n            \"shared.types\"\n        ]\n    )\n</code></pre>"},{"location":"guides/jsonserializer-configuration/#microservice-architecture","title":"Microservice Architecture","text":"<pre><code>def configure_microservice_architecture():\n    \"\"\"Example: Configure types for microservice architecture\"\"\"\n    # For microservices that need to handle:\n    # - Internal domain types\n    # - Shared library types\n    # - External service types\n\n    type_registry = get_type_registry()\n\n    # Internal domain\n    type_registry.register_modules([\n        \"user_service.domain.enums\",\n        \"user_service.domain.entities\"\n    ])\n\n    # Shared libraries\n    type_registry.register_modules([\n        \"common_lib.enums\",\n        \"auth_lib.types\"\n    ])\n\n    # External services\n    type_registry.register_modules([\n        \"notification_service.contracts\",\n        \"payment_service.models\"\n    ])\n</code></pre>"},{"location":"guides/jsonserializer-configuration/#dynamic-type-discovery","title":"Dynamic Type Discovery","text":"<p>For more advanced scenarios, you can dynamically discover and register types:</p> <pre><code>from enum import Enum\nfrom neuroglia.core.module_loader import ModuleLoader\nfrom neuroglia.core.type_finder import TypeFinder\nfrom neuroglia.core.type_registry import get_type_registry\n\ndef dynamic_type_discovery_example():\n    \"\"\"Example: Dynamically discover and register types\"\"\"\n    type_registry = get_type_registry()\n\n    # Example: Discover all enum types in a base module\n    base_modules = [\"myapp.domain\", \"myapp.shared\", \"myapp.external\"]\n\n    for base_module_name in base_modules:\n        try:\n            base_module = ModuleLoader.load(base_module_name)\n\n            # Find all enum types in this module and submodules\n            enum_types = TypeFinder.get_types(\n                base_module,\n                predicate=lambda t: (\n                    isinstance(t, type)\n                    and issubclass(t, Enum)\n                    and t != Enum\n                ),\n                include_sub_modules=True,\n                include_sub_packages=True\n            )\n\n            if enum_types:\n                print(f\"Found {len(enum_types)} enum types in {base_module_name}\")\n                # The TypeRegistry will cache these automatically when they're accessed\n\n        except ImportError:\n            print(f\"Module {base_module_name} not available\")\n\n    return type_registry\n</code></pre>"},{"location":"guides/jsonserializer-configuration/#performance-considerations","title":"Performance Considerations","text":""},{"location":"guides/jsonserializer-configuration/#module-registration-best-practices","title":"Module Registration Best Practices","text":"<ol> <li>Register Early: Register type modules during application startup to avoid runtime discovery overhead</li> <li>Be Specific: Register only the modules that contain types you need to deserialize</li> <li>Use Caching: The TypeRegistry automatically caches discovered types for performance</li> <li>Group Related Types: Keep related enums and types in organized module structures</li> </ol>"},{"location":"guides/jsonserializer-configuration/#example-startup-configuration","title":"Example Startup Configuration","text":"<pre><code>from neuroglia.hosting.enhanced_web_application_builder import EnhancedWebApplicationBuilder\nfrom neuroglia.serialization.json import JsonSerializer\n\ndef create_optimized_app():\n    \"\"\"Example: Optimized application startup with type registration\"\"\"\n    builder = EnhancedWebApplicationBuilder()\n\n    # Register all type modules at startup\n    type_modules = [\n        # Core domain types\n        \"domain.enums\",\n        \"domain.entities\",\n\n        # Application layer types\n        \"application.commands\",\n        \"application.queries\",\n\n        # Integration types\n        \"integration.external_apis\",\n        \"integration.shared_contracts\",\n\n        # Testing types (if needed in production)\n        # \"tests.fixtures.types\",\n    ]\n\n    JsonSerializer.configure(builder, type_modules=type_modules)\n\n    # Build application\n    app = builder.build()\n\n    return app\n</code></pre>"},{"location":"guides/jsonserializer-configuration/#error-handling-and-debugging","title":"Error Handling and Debugging","text":""},{"location":"guides/jsonserializer-configuration/#debugging-type-discovery","title":"Debugging Type Discovery","text":"<pre><code>from neuroglia.core.type_registry import get_type_registry\n\ndef debug_type_discovery():\n    \"\"\"Debug helper to inspect registered types\"\"\"\n    type_registry = get_type_registry()\n\n    # Check registered modules\n    modules = type_registry.get_registered_modules()\n    print(f\"Registered modules: {modules}\")\n\n    # Check cached enum types\n    cached_enums = type_registry.get_cached_enum_types()\n    print(f\"Cached enum types: {list(cached_enums.keys())}\")\n\n    # Test enum lookup\n    test_value = \"test_value\"\n    found_enum = type_registry.find_enum_for_value(test_value)\n    print(f\"Enum for '{test_value}': {found_enum}\")\n</code></pre>"},{"location":"guides/jsonserializer-configuration/#common-configuration-issues","title":"Common Configuration Issues","text":"<ol> <li>Module Not Found: Ensure module paths are correct and modules are importable</li> <li>No Enums Discovered: Check that enum classes are properly defined and accessible</li> <li>Performance Issues: Avoid registering too many modules or very large module trees</li> </ol>"},{"location":"guides/jsonserializer-configuration/#testing-configuration","title":"Testing Configuration","text":"<p>For testing scenarios, you can configure type discovery specifically for test environments:</p> <pre><code>def configure_test_types():\n    \"\"\"Example: Configure types for testing environment\"\"\"\n    from neuroglia.core.type_registry import get_type_registry\n\n    type_registry = get_type_registry()\n\n    # Register test-specific modules\n    test_modules = [\n        \"tests.fixtures.enums\",\n        \"tests.mocks.types\",\n        \"tests.data.models\"\n    ]\n\n    type_registry.register_modules(test_modules)\n\n    return type_registry\n</code></pre>"},{"location":"guides/jsonserializer-configuration/#best-practices-summary","title":"Best Practices Summary","text":"<ol> <li>Early Registration: Register type modules during application startup</li> <li>Specific Modules: Only register modules containing types you need to deserialize</li> <li>Organized Structure: Keep related types in well-organized module hierarchies</li> <li>Performance Monitoring: Monitor type discovery performance in production</li> <li>Clear Documentation: Document your type module organization for team members</li> <li>Environment-Specific: Use different configurations for development, testing, and production</li> <li>Error Handling: Include proper error handling for module loading failures</li> </ol> <p>This configurable approach provides maximum flexibility while maintaining the performance and reliability of the Neuroglia framework's serialization system.</p>"},{"location":"guides/local-development/","title":"\ud83d\udee0\ufe0f Local Development Environment Setup","text":"<p>Set up a complete local development environment for productive Neuroglia development. This guide covers tooling, IDE setup, debugging, and best practices for building maintainable applications.</p> <p>\ud83c\udfaf What You'll Set Up</p> <p>A professional development environment with debugging, testing, linting, and database integration.</p>"},{"location":"guides/local-development/#prerequisites","title":"\ud83d\udccb Prerequisites","text":""},{"location":"guides/local-development/#system-requirements","title":"System Requirements","text":"<ul> <li>Python 3.8+ with pip</li> <li>Git for version control</li> <li>Docker &amp; Docker Compose for services (MongoDB, Redis, etc.)</li> <li>VS Code or PyCharm (recommended IDEs)</li> </ul>"},{"location":"guides/local-development/#verify-installation","title":"Verify Installation","text":"<pre><code>python --version  # Should be 3.8+\npip --version\ngit --version\ndocker --version\ndocker-compose --version\n</code></pre>"},{"location":"guides/local-development/#project-setup","title":"\ud83d\ude80 Project Setup","text":""},{"location":"guides/local-development/#1-create-project-structure","title":"1. Create Project Structure","text":"<pre><code># Create project directory\nmkdir my-neuroglia-app &amp;&amp; cd my-neuroglia-app\n\n# Initialize git repository\ngit init\n\n# Create standard project structure\nmkdir -p src/{api,application,domain,integration}\nmkdir -p src/api/{controllers,dtos}\nmkdir -p src/application/{commands,queries,handlers}\nmkdir -p src/domain/{entities,events,repositories}\nmkdir -p src/integration/{repositories,services}\nmkdir -p tests/{unit,integration,fixtures}\nmkdir -p docs\ntouch README.md\n</code></pre>"},{"location":"guides/local-development/#2-python-environment-setup","title":"2. Python Environment Setup","text":"<p>Option A: Using Poetry (Recommended)</p> <pre><code># Install Poetry if not already installed\ncurl -sSL https://install.python-poetry.org | python3 -\n\n# Initialize Poetry project\npoetry init\n\n# Add Neuroglia and development dependencies\npoetry add neuroglia-python[web]\npoetry add --group dev pytest pytest-asyncio pytest-cov black flake8 mypy\n\n# Create virtual environment and activate\npoetry install\npoetry shell\n</code></pre> <p>Option B: Using venv</p> <pre><code># Create virtual environment\npython -m venv venv\n\n# Activate virtual environment\n# On macOS/Linux:\nsource venv/bin/activate\n# On Windows:\n# venv\\Scripts\\activate\n\n# Install dependencies\npip install neuroglia-python[web]\npip install pytest pytest-asyncio pytest-cov black flake8 mypy\n</code></pre>"},{"location":"guides/local-development/#3-development-configuration-files","title":"3. Development Configuration Files","text":"<p>pyproject.toml (Poetry users):</p> <pre><code>[tool.poetry]\nname = \"my-neuroglia-app\"\nversion = \"0.1.0\"\ndescription = \"My Neuroglia Application\"\nauthors = [\"Your Name &lt;your.email@example.com&gt;\"]\n\n[tool.poetry.dependencies]\npython = \"^3.8\"\nneuroglia-python = {extras = [\"web\"], version = \"^1.0.0\"}\n\n[tool.poetry.group.dev.dependencies]\npytest = \"^7.0.0\"\npytest-asyncio = \"^0.20.0\"\npytest-cov = \"^4.0.0\"\nblack = \"^22.0.0\"\nflake8 = \"^5.0.0\"\nmypy = \"^1.0.0\"\n\n[tool.black]\nline-length = 88\ntarget-version = ['py38']\n\n[tool.mypy]\npython_version = \"3.8\"\nwarn_return_any = true\nwarn_unused_configs = true\ndisallow_untyped_defs = true\n</code></pre> <p>requirements.txt (venv users):</p> <pre><code>neuroglia-python[web]&gt;=1.0.0\npytest&gt;=7.0.0\npytest-asyncio&gt;=0.20.0\npytest-cov&gt;=4.0.0\nblack&gt;=22.0.0\nflake8&gt;=5.0.0\nmypy&gt;=1.0.0\n</code></pre> <p>pytest.ini:</p> <pre><code>[tool:pytest]\ntestpaths = tests\npython_files = test_*.py\npython_classes = Test*\npython_functions = test_*\nasyncio_mode = auto\naddopts = --cov=src --cov-report=html --cov-report=term\n</code></pre>"},{"location":"guides/local-development/#ide-configuration","title":"\ud83d\udd27 IDE Configuration","text":""},{"location":"guides/local-development/#vs-code-setup","title":"VS Code Setup","text":"<p>Install Extensions:</p> <pre><code># Install VS Code extensions\ncode --install-extension ms-python.python\ncode --install-extension ms-python.black-formatter\ncode --install-extension ms-python.flake8\ncode --install-extension ms-python.mypy-type-checker\ncode --install-extension bradlc.vscode-tailwindcss\ncode --install-extension ms-vscode.vscode-json\n</code></pre> <p>.vscode/settings.json:</p> <pre><code>{\n  \"python.defaultInterpreterPath\": \"./venv/bin/python\",\n  \"python.linting.enabled\": true,\n  \"python.linting.flake8Enabled\": true,\n  \"python.formatting.provider\": \"black\",\n  \"python.testing.pytestEnabled\": true,\n  \"python.testing.pytestArgs\": [\"tests\"],\n  \"editor.formatOnSave\": true,\n  \"editor.codeActionsOnSave\": {\n    \"source.organizeImports\": true\n  }\n}\n</code></pre> <p>.vscode/launch.json (for debugging):</p> <pre><code>{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"Python: FastAPI\",\n      \"type\": \"python\",\n      \"request\": \"launch\",\n      \"program\": \"${workspaceFolder}/src/main.py\",\n      \"console\": \"integratedTerminal\",\n      \"env\": {\n        \"PYTHONPATH\": \"${workspaceFolder}/src\"\n      }\n    },\n    {\n      \"name\": \"Python: Pytest\",\n      \"type\": \"python\",\n      \"request\": \"launch\",\n      \"module\": \"pytest\",\n      \"args\": [\"tests\", \"-v\"],\n      \"console\": \"integratedTerminal\"\n    }\n  ]\n}\n</code></pre>"},{"location":"guides/local-development/#docker-development-services","title":"\ud83d\udc33 Docker Development Services","text":"<p>docker-compose.dev.yml:</p> <pre><code>version: \"3.8\"\n\nservices:\n  mongodb:\n    image: mongo:5.0\n    ports:\n      - \"27017:27017\"\n    environment:\n      MONGO_INITDB_ROOT_USERNAME: admin\n      MONGO_INITDB_ROOT_PASSWORD: password\n    volumes:\n      - mongodb_data:/data/db\n    networks:\n      - neuroglia-dev\n\n  redis:\n    image: redis:7-alpine\n    ports:\n      - \"6379:6379\"\n    networks:\n      - neuroglia-dev\n\n  mailhog:\n    image: mailhog/mailhog\n    ports:\n      - \"1025:1025\" # SMTP\n      - \"8025:8025\" # Web UI\n    networks:\n      - neuroglia-dev\n\nvolumes:\n  mongodb_data:\n\nnetworks:\n  neuroglia-dev:\n    driver: bridge\n</code></pre> <p>Start development services:</p> <pre><code>docker-compose -f docker-compose.dev.yml up -d\n</code></pre>"},{"location":"guides/local-development/#testing-setup","title":"\ud83e\uddea Testing Setup","text":"<p>tests/conftest.py:</p> <pre><code>import pytest\nfrom neuroglia.dependency_injection import ServiceCollection\nfrom neuroglia.mediation import Mediator\n\n@pytest.fixture\ndef service_collection():\n    \"\"\"Create a fresh service collection for testing\"\"\"\n    return ServiceCollection()\n\n@pytest.fixture\ndef service_provider(service_collection):\n    \"\"\"Create a service provider for testing\"\"\"\n    service_collection.add_mediator()\n    return service_collection.build_provider()\n\n@pytest.fixture\ndef mediator(service_provider):\n    \"\"\"Get mediator instance for testing\"\"\"\n    return service_provider.get_service(Mediator)\n</code></pre> <p>tests/unit/test_example.py:</p> <pre><code>import pytest\nfrom src.domain.entities.example import ExampleEntity\n\nclass TestExampleEntity:\n    def test_entity_creation(self):\n        \"\"\"Test entity can be created successfully\"\"\"\n        entity = ExampleEntity(name=\"Test\")\n        assert entity.name == \"Test\"\n        assert entity.id is not None\n\n    @pytest.mark.asyncio\n    async def test_async_operation(self):\n        \"\"\"Test async operations work correctly\"\"\"\n        # Add async test logic here\n        pass\n</code></pre>"},{"location":"guides/local-development/#development-workflow","title":"\ud83c\udfc3\u200d\u2642\ufe0f Development Workflow","text":""},{"location":"guides/local-development/#daily-development-commands","title":"Daily Development Commands","text":"<pre><code># Start development services\ndocker-compose -f docker-compose.dev.yml up -d\n\n# Activate virtual environment (if using venv)\nsource venv/bin/activate  # or `poetry shell`\n\n# Run your application\npython src/main.py\n\n# Run tests\npytest\n\n# Run tests with coverage\npytest --cov=src --cov-report=html\n\n# Format code\nblack src tests\n\n# Lint code\nflake8 src tests\n\n# Type checking\nmypy src\n</code></pre>"},{"location":"guides/local-development/#git-hooks-setup","title":"Git Hooks Setup","text":"<p>.pre-commit-config.yaml:</p> <pre><code>repos:\n  - repo: https://github.com/psf/black\n    rev: 22.3.0\n    hooks:\n      - id: black\n        language_version: python3.8\n\n  - repo: https://github.com/pycqa/flake8\n    rev: 5.0.4\n    hooks:\n      - id: flake8\n\n  - repo: https://github.com/pre-commit/mirrors-mypy\n    rev: v1.0.0\n    hooks:\n      - id: mypy\n</code></pre> <p>Install pre-commit:</p> <pre><code>pip install pre-commit\npre-commit install\n</code></pre>"},{"location":"guides/local-development/#debugging-and-monitoring","title":"\ud83d\udd0d Debugging and Monitoring","text":""},{"location":"guides/local-development/#application-logging","title":"Application Logging","text":"<p>src/config/logging.py:</p> <pre><code>import logging\nimport sys\nfrom pathlib import Path\n\ndef setup_logging(log_level: str = \"INFO\"):\n    \"\"\"Configure application logging\"\"\"\n\n    # Create logs directory\n    Path(\"logs\").mkdir(exist_ok=True)\n\n    # Configure logging\n    logging.basicConfig(\n        level=getattr(logging, log_level.upper()),\n        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n        handlers=[\n            logging.FileHandler('logs/app.log'),\n            logging.StreamHandler(sys.stdout)\n        ]\n    )\n\n    # Configure third-party loggers\n    logging.getLogger(\"uvicorn\").setLevel(logging.INFO)\n    logging.getLogger(\"fastapi\").setLevel(logging.INFO)\n</code></pre>"},{"location":"guides/local-development/#environment-configuration","title":"Environment Configuration","text":"<p>.env.development:</p> <pre><code># Application\nAPP_NAME=My Neuroglia App\nAPP_VERSION=0.1.0\nDEBUG=true\nLOG_LEVEL=DEBUG\n\n# Database\nMONGODB_URL=mongodb://admin:password@localhost:27017\nREDIS_URL=redis://localhost:6379\n\n# External Services\nSMTP_HOST=localhost\nSMTP_PORT=1025\n</code></pre>"},{"location":"guides/local-development/#environment-validation","title":"\u2705 Environment Validation","text":"<p>Create a validation script to ensure everything is set up correctly:</p> <p>scripts/validate-env.py:</p> <pre><code>#!/usr/bin/env python3\n\"\"\"Validate development environment setup\"\"\"\n\nimport sys\nimport subprocess\nfrom pathlib import Path\n\ndef check_python_version():\n    \"\"\"Check Python version\"\"\"\n    if sys.version_info &lt; (3, 8):\n        print(\"\u274c Python 3.8+ required\")\n        return False\n    print(f\"\u2705 Python {sys.version_info.major}.{sys.version_info.minor}\")\n    return True\n\ndef check_dependencies():\n    \"\"\"Check if required packages are installed\"\"\"\n    try:\n        import neuroglia\n        print(\"\u2705 Neuroglia installed\")\n        return True\n    except ImportError:\n        print(\"\u274c Neuroglia not installed\")\n        return False\n\ndef check_docker():\n    \"\"\"Check if Docker services are running\"\"\"\n    try:\n        result = subprocess.run(\n            [\"docker\", \"ps\"],\n            capture_output=True,\n            text=True,\n            check=True\n        )\n        if \"mongo\" in result.stdout and \"redis\" in result.stdout:\n            print(\"\u2705 Docker services running\")\n            return True\n        else:\n            print(\"\u26a0\ufe0f  Docker services not all running\")\n            return False\n    except (subprocess.CalledProcessError, FileNotFoundError):\n        print(\"\u274c Docker not available\")\n        return False\n\nif __name__ == \"__main__\":\n    checks = [\n        check_python_version(),\n        check_dependencies(),\n        check_docker()\n    ]\n\n    if all(checks):\n        print(\"\\n\ud83c\udf89 Development environment is ready!\")\n    else:\n        print(\"\\n\u274c Some issues need to be resolved\")\n        sys.exit(1)\n</code></pre> <p>Run validation:</p> <pre><code>python scripts/validate-env.py\n</code></pre>"},{"location":"guides/local-development/#next-steps","title":"\ud83d\udd04 Next Steps","text":"<p>Your development environment is now ready! Continue with:</p> <ol> <li>\u26a1 3-Minute Bootstrap - Quick hello world setup</li> <li>\ud83c\udf55 Mario's Pizzeria Tutorial - Build a complete application</li> <li>\ud83c\udfaf Architecture Patterns - Learn design principles</li> <li>\ud83d\ude80 Framework Features - Explore advanced capabilities</li> </ol>"},{"location":"guides/local-development/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Dependency Injection Setup - Advanced DI configuration</li> <li>Testing Strategies - Comprehensive testing approaches</li> <li>Project Structure - Detailed project organization</li> </ul> <p>\ud83c\udfaf Pro Tip</p> <p>Bookmark this page! You'll refer back to these commands and configurations throughout your development journey.</p>"},{"location":"guides/mario-pizzeria-tutorial/","title":"\ud83c\udf55 Mario's Pizzeria Tutorial","text":"<p>Build a complete pizza ordering system that demonstrates all of Neuroglia's features in a familiar, easy-to-understand context. This comprehensive tutorial covers clean architecture, CQRS, event-driven design, and web development.</p> <p>\ud83c\udfaf What You'll Build</p> <p>A complete pizzeria application with REST API, web UI, authentication, file-based persistence, and event-driven architecture.</p>"},{"location":"guides/mario-pizzeria-tutorial/#what-youll-build","title":"\ud83d\udccb What You'll Build","text":"<p>By the end of this guide, you'll have a complete pizzeria application with:</p> <ul> <li>\ud83c\udf10 REST API with automatic Swagger documentation</li> <li>\ud83c\udfa8 Simple Web UI for customers and kitchen staff</li> <li>\ud83d\udd10 OAuth Authentication for secure access</li> <li>\ud83d\udcbe File-based persistence using the repository pattern</li> <li>\ud83d\udce1 Event-driven architecture with domain events</li> <li>\ud83c\udfd7\ufe0f Clean Architecture with CQRS and dependency injection</li> </ul>"},{"location":"guides/mario-pizzeria-tutorial/#quick-setup","title":"\u26a1 Quick Setup","text":""},{"location":"guides/mario-pizzeria-tutorial/#installation","title":"Installation","text":"<pre><code>pip install neuroglia-python[web]\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#project-structure","title":"Project Structure","text":"<p>The actual Mario's Pizzeria implementation follows clean architecture principles:</p> <p>Source: <code>samples/mario-pizzeria/</code></p> <pre><code>mario-pizzeria/\n\u251c\u2500\u2500 main.py                       # Application entry point with DI setup\n\u251c\u2500\u2500 api/\n\u2502   \u251c\u2500\u2500 controllers/             # REST API endpoints\n\u2502   \u2502   \u251c\u2500\u2500 orders_controller.py  # Order management\n\u2502   \u2502   \u251c\u2500\u2500 menu_controller.py    # Pizza menu\n\u2502   \u2502   \u2514\u2500\u2500 kitchen_controller.py # Kitchen operations\n\u2502   \u2514\u2500\u2500 dtos/                    # Data Transfer Objects\n\u2502       \u251c\u2500\u2500 order_dtos.py        # Order request/response models\n\u2502       \u251c\u2500\u2500 menu_dtos.py         # Menu item models\n\u2502       \u2514\u2500\u2500 kitchen_dtos.py      # Kitchen status models\n\u251c\u2500\u2500 application/\n\u2502   \u251c\u2500\u2500 commands/                # CQRS Command handlers\n\u2502   \u2502   \u251c\u2500\u2500 place_order_command.py\n\u2502   \u2502   \u251c\u2500\u2500 start_cooking_command.py\n\u2502   \u2502   \u2514\u2500\u2500 complete_order_command.py\n\u2502   \u251c\u2500\u2500 queries/                 # CQRS Query handlers\n\u2502   \u2502   \u251c\u2500\u2500 get_order_by_id_query.py\n\u2502   \u2502   \u251c\u2500\u2500 get_orders_by_status_query.py\n\u2502   \u2502   \u2514\u2500\u2500 get_active_orders_query.py\n\u2502   \u2514\u2500\u2500 mapping/                 # AutoMapper profiles\n\u2502       \u2514\u2500\u2500 profile.py           # Entity-DTO mappings\n\u251c\u2500\u2500 domain/\n\u2502   \u251c\u2500\u2500 entities/                # Domain entities\n\u2502   \u2502   \u251c\u2500\u2500 pizza.py            # Pizza entity with pricing\n\u2502   \u2502   \u251c\u2500\u2500 order.py            # Order aggregate root\n\u2502   \u2502   \u251c\u2500\u2500 customer.py         # Customer entity\n\u2502   \u2502   \u251c\u2500\u2500 kitchen.py          # Kitchen entity\n\u2502   \u2502   \u2514\u2500\u2500 enums.py            # Domain enumerations\n\u2502   \u251c\u2500\u2500 events/                  # Domain events\n\u2502   \u2502   \u2514\u2500\u2500 order_events.py     # Order lifecycle events\n\u2502   \u2514\u2500\u2500 repositories/            # Repository interfaces\n\u2502       \u2514\u2500\u2500 __init__.py         # Repository abstractions\n\u251c\u2500\u2500 integration/\n\u2502   \u2514\u2500\u2500 repositories/           # Repository implementations\n\u2502       \u251c\u2500\u2500 file_order_repository.py    # File-based order storage\n\u2502       \u251c\u2500\u2500 file_pizza_repository.py    # File-based pizza storage\n\u2502       \u251c\u2500\u2500 file_customer_repository.py # File-based customer storage\n\u2502       \u2514\u2500\u2500 file_kitchen_repository.py  # File-based kitchen storage\n\u2514\u2500\u2500 tests/                      # Test suite\n    \u251c\u2500\u2500 test_api.py             # API integration tests\n    \u251c\u2500\u2500 test_integration.py     # Full integration tests\n    \u2514\u2500\u2500 test_data/              # Test data storage\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#step-1-domain-model","title":"\ud83c\udfd7\ufe0f Step 1: Domain Model","text":"<p>The domain entities demonstrate sophisticated business logic with real pricing calculations and type safety.</p> <p>domain/entities/pizza.py (lines 1-63)</p> samples/mario-pizzeria/domain/entities/pizza.py<pre><code>\"\"\"Pizza entity for Mario's Pizzeria domain\"\"\"\n\nfrom decimal import Decimal\nfrom typing import Optional\nfrom uuid import uuid4\n\nfrom api.dtos import PizzaDto\n\nfrom neuroglia.data.abstractions import Entity\nfrom neuroglia.mapping.mapper import map_from, map_to\n\nfrom .enums import PizzaSize\n\n\n@map_from(PizzaDto)\n@map_to(PizzaDto)\nclass Pizza(Entity[str]):\n    \"\"\"Pizza entity with pricing and toppings\"\"\"\n\n    def __init__(self, name: str, base_price: Decimal, size: PizzaSize, description: Optional[str] = None):\n        super().__init__()\n        self.id = str(uuid4())\n        self.name = name\n        self.base_price = base_price\n        self.size = size\n        self.description = description or \"\"\n        self.toppings: list[str] = []\n\n    @property\n    def size_multiplier(self) -&gt; Decimal:\n        \"\"\"Get price multiplier based on pizza size\"\"\"\n        multipliers = {\n            PizzaSize.SMALL: Decimal(\"1.0\"),\n            PizzaSize.MEDIUM: Decimal(\"1.3\"),\n            PizzaSize.LARGE: Decimal(\"1.6\"),\n        }\n        return multipliers[self.size]\n\n    @property\n    def topping_price(self) -&gt; Decimal:\n        \"\"\"Calculate total price for all toppings\"\"\"\n        return Decimal(str(len(self.toppings))) * Decimal(\"2.50\")\n\n    @property\n    def total_price(self) -&gt; Decimal:\n        \"\"\"Calculate total pizza price including size and toppings\"\"\"\n        base_with_size = self.base_price * self.size_multiplier\n        return base_with_size + self.topping_price\n\n    def add_topping(self, topping: str) -&gt; None:\n        \"\"\"Add a topping to the pizza\"\"\"\n        if topping not in self.toppings:\n            self.toppings.append(topping)\n\n    def remove_topping(self, topping: str) -&gt; None:\n        \"\"\"Remove a topping from the pizza\"\"\"\n        if topping in self.toppings:\n            self.toppings.remove(topping)\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#key-features","title":"Key Features","text":"<ul> <li>Size-based pricing: Small (1.0x), Medium (1.3x), Large (1.6x) multipliers</li> <li>Smart topping pricing: $2.50 per topping with proper decimal handling</li> <li>Auto-mapping decorators: Seamless conversion to/from DTOs</li> <li>Type safety: Enum-based size validation with PizzaSize enum</li> </ul> <p>domain/entities/order.py (lines 1-106)</p> samples/mario-pizzeria/domain/entities/order.py<pre><code>\"\"\"Order entity for Mario's Pizzeria domain\"\"\"\n\nfrom datetime import datetime, timezone\nfrom decimal import Decimal\nfrom typing import Optional\nfrom uuid import uuid4\n\nfrom api.dtos import OrderDto\n\nfrom neuroglia.data.abstractions import Entity\nfrom neuroglia.mapping.mapper import map_from, map_to\n\nfrom .enums import OrderStatus\nfrom .pizza import Pizza\n\n\n@map_from(OrderDto)\n@map_to(OrderDto)\nclass Order(Entity[str]):\n    \"\"\"Order entity with pizzas and status management\"\"\"\n\n    def __init__(self, customer_id: str, estimated_ready_time: Optional[datetime] = None):\n        super().__init__()\n        self.id = str(uuid4())\n        self.customer_id = customer_id\n        self.pizzas: list[Pizza] = []\n        self.status = OrderStatus.PENDING\n        self.order_time = datetime.now(timezone.utc)\n        self.confirmed_time: Optional[datetime] = None\n        self.cooking_started_time: Optional[datetime] = None\n        self.actual_ready_time: Optional[datetime] = None\n        self.estimated_ready_time = estimated_ready_time\n        self.notes: Optional[str] = None\n\n    @property\n    def total_amount(self) -&gt; Decimal:\n        \"\"\"Calculate total order amount\"\"\"\n        return sum((pizza.total_price for pizza in self.pizzas), Decimal(\"0.00\"))\n\n    @property\n    def pizza_count(self) -&gt; int:\n        \"\"\"Get total number of pizzas in the order\"\"\"\n        return len(self.pizzas)\n\n    def add_pizza(self, pizza: Pizza) -&gt; None:\n        \"\"\"Add a pizza to the order\"\"\"\n        if self.status != OrderStatus.PENDING:\n            raise ValueError(\"Cannot modify confirmed orders\")\n        self.pizzas.append(pizza)\n\n    def confirm_order(self) -&gt; None:\n        \"\"\"Confirm the order and set confirmed time\"\"\"\n        if self.status != OrderStatus.PENDING:\n            raise ValueError(\"Only pending orders can be confirmed\")\n\n        if not self.pizzas:\n            raise ValueError(\"Cannot confirm order without pizzas\")\n\n        self.status = OrderStatus.CONFIRMED\n        self.confirmed_time = datetime.now(timezone.utc)\n\n    def start_cooking(self) -&gt; None:\n        \"\"\"Start cooking the order\"\"\"\n        if self.status != OrderStatus.CONFIRMED:\n            raise ValueError(\"Only confirmed orders can start cooking\")\n\n        self.status = OrderStatus.COOKING\n        self.cooking_started_time = datetime.now(timezone.utc)\n\n    def mark_ready(self) -&gt; None:\n        \"\"\"Mark order as ready for pickup/delivery\"\"\"\n        if self.status != OrderStatus.COOKING:\n            raise ValueError(\"Only cooking orders can be marked ready\")\n\n        self.status = OrderStatus.READY\n        self.actual_ready_time = datetime.now(timezone.utc)\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#key-features_1","title":"Key Features","text":"<ul> <li>Status management: OrderStatus enum with PENDING \u2192 CONFIRMED \u2192 COOKING \u2192 READY workflow</li> <li>Time tracking: order_time, confirmed_time, cooking_started_time, actual_ready_time</li> <li>Business validation: Cannot modify confirmed orders, cannot confirm empty orders</li> <li>Auto-mapping decorators: Seamless conversion to/from DTOs</li> <li>Computed properties: Dynamic total_amount and pizza_count calculations</li> </ul> <p>OrderStatus Enum (enums.py):</p> samples/mario-pizzeria/domain/entities/enums.py<pre><code>class OrderStatus(Enum):\n    \"\"\"Order lifecycle statuses\"\"\"\n\n    PENDING = \"pending\"\n    CONFIRMED = \"confirmed\"\n    COOKING = \"cooking\"\n    READY = \"ready\"\n</code></pre> <p>Notice how the <code>Order</code> entity encapsulates the business logic around order management, including validation rules and state transitions.</p> <p>Domain Events (optional extension):</p> Domain Events Example<pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom neuroglia.data.abstractions import DomainEvent\n\n@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    \"\"\"Event raised when a new order is placed\"\"\"\n    order_id: str\n    customer_name: str\n    total_amount: Decimal\n    estimated_ready_time: datetime\n\n    def __post_init__(self):\n        super().__init__(self.order_id)\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#step-2-commands-and-queries","title":"\ud83c\udfaf Step 2: Commands and Queries","text":"<p>Neuroglia implements the CQRS (Command Query Responsibility Segregation) pattern, separating write operations (commands) from read operations (queries).</p>"},{"location":"guides/mario-pizzeria-tutorial/#commands-write-operations","title":"Commands (Write Operations)","text":"<p>place_order_command.py (lines 17-29)</p> samples/mario-pizzeria/application/commands/place_order_command.py<pre><code>@dataclass\n@map_from(CreateOrderDto)\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Command to place a new pizza order\"\"\"\n\n    customer_name: str\n    customer_phone: str\n    customer_address: Optional[str] = None\n    customer_email: Optional[str] = None\n    pizzas: list[CreatePizzaDto] = field(default_factory=list)\n    payment_method: str = \"cash\"\n    notes: Optional[str] = None\n</code></pre> <p>Command Handler Implementation (lines 31-95):</p> samples/mario-pizzeria/application/commands/place_order_command.py<pre><code>class PlaceOrderCommandHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    \"\"\"Handler for placing new pizza orders\"\"\"\n\n    def __init__(\n        self,\n        order_repository: IOrderRepository,\n        customer_repository: ICustomerRepository,\n        mapper: Mapper,\n    ):\n        self.order_repository = order_repository\n        self.customer_repository = customer_repository\n        self.mapper = mapper\n\n    async def handle_async(self, request: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        try:\n            # First create or get customer\n            customer = await self._create_or_get_customer(request)\n\n            # Create order with customer_id\n            order = Order(customer_id=customer.id)\n            if request.notes:\n                order.notes = request.notes\n\n            # Add pizzas to order with dynamic pricing\n            for pizza_item in request.pizzas:\n                size = PizzaSize(pizza_item.size.lower())\n\n                # Dynamic base pricing by pizza type\n                base_price = Decimal(\"12.99\")  # Default\n                if pizza_item.name.lower() == \"margherita\":\n                    base_price = Decimal(\"12.99\")\n                elif pizza_item.name.lower() == \"pepperoni\":\n                    base_price = Decimal(\"14.99\")\n                elif pizza_item.name.lower() == \"supreme\":\n                    base_price = Decimal(\"17.99\")\n\n                pizza = Pizza(name=pizza_item.name, base_price=base_price, size=size)\n\n                # Add toppings\n                for topping in pizza_item.toppings:\n                    pizza.add_topping(topping)\n\n                order.add_pizza(pizza)\n\n            # Validate and confirm order\n            if not order.pizzas:\n                return self.bad_request(\"Order must contain at least one pizza\")\n\n            order.confirm_order()  # Raises domain event\n            await self.order_repository.add_async(order)\n\n            return self.created(self._build_order_dto(order, customer))\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#queries-read-operations","title":"Queries (Read Operations)","text":"<p>get_order_by_id_query.py (lines 13-17)</p> samples/mario-pizzeria/application/queries/get_order_by_id_query.py<pre><code>@dataclass\nclass GetOrderByIdQuery(Query[OperationResult[OrderDto]]):\n    \"\"\"Query to get an order by ID\"\"\"\n\n    order_id: str\n</code></pre> <p>Query Handler Implementation (lines 20-63):</p> samples/mario-pizzeria/application/queries/get_order_by_id_query.py<pre><code>class GetOrderByIdQueryHandler(QueryHandler[GetOrderByIdQuery, OperationResult[OrderDto]]):\n    \"\"\"Handler for getting an order by ID\"\"\"\n\n    def __init__(\n        self,\n        order_repository: IOrderRepository,\n        customer_repository: ICustomerRepository,\n        mapper: Mapper,\n    ):\n        self.order_repository = order_repository\n        self.customer_repository = customer_repository\n        self.mapper = mapper\n\n    async def handle_async(self, request: GetOrderByIdQuery) -&gt; OperationResult[OrderDto]:\n        try:\n            order = await self.order_repository.get_async(request.order_id)\n            if not order:\n                return self.not_found(\"Order\", request.order_id)\n\n            # Get customer details\n            customer = await self.customer_repository.get_async(order.customer_id)\n\n            # Create OrderDto with customer information\n            order_dto = OrderDto(\n                id=order.id,\n                customer_name=customer.name if customer else \"Unknown\",\n                customer_phone=customer.phone if customer else \"Unknown\",\n                customer_address=customer.address if customer else \"Unknown\",\n                pizzas=[self.mapper.map(pizza, PizzaDto) for pizza in order.pizzas],\n                status=order.status.value,\n                order_time=order.order_time,\n                confirmed_time=order.confirmed_time,\n                cooking_started_time=order.cooking_started_time,\n                actual_ready_time=order.actual_ready_time,\n                estimated_ready_time=order.estimated_ready_time,\n                total_amount=order.total_amount,\n                notes=order.notes,\n            )\n\n            return self.ok(order_dto)\n        except Exception as e:\n            return self.internal_server_error(f\"Failed to get order: {str(e)}\")\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#key-cqrs-features","title":"Key CQRS Features","text":"<ul> <li>Command/Query Separation: Clear distinction between write (commands) and read (queries) operations</li> <li>Auto-mapping: @map_from decorators for seamless DTO conversion</li> <li>Repository Pattern: Abstracted data access through IOrderRepository and ICustomerRepository</li> <li>Business Logic: Domain validation and business rules in command handlers</li> <li>Error Handling: Comprehensive error handling with OperationResult pattern</li> </ul>"},{"location":"guides/mario-pizzeria-tutorial/#step-3-file-based-repository","title":"\ud83d\udcbe Step 3: File-Based Repository","text":"<p>file_order_repository.py (lines 1-37)</p> samples/mario-pizzeria/integration/repositories/file_order_repository.py<pre><code>\"\"\"File-based implementation of order repository using generic FileSystemRepository\"\"\"\n\nfrom datetime import datetime\n\nfrom domain.entities import Order, OrderStatus\nfrom domain.repositories import IOrderRepository\n\nfrom neuroglia.data.infrastructure.filesystem import FileSystemRepository\n\n\nclass FileOrderRepository(FileSystemRepository[Order, str], IOrderRepository):\n    \"\"\"File-based implementation of order repository using generic FileSystemRepository\"\"\"\n\n    def __init__(self, data_directory: str = \"data\"):\n        super().__init__(data_directory=data_directory, entity_type=Order, key_type=str)\n\n    async def get_by_customer_phone_async(self, phone: str) -&gt; list[Order]:\n        \"\"\"Get all orders for a customer by phone number\"\"\"\n        # Note: This would require a relationship lookup in a real implementation\n        # For now, we'll return empty list as Order entity doesn't directly store phone\n        return []\n\n    async def get_orders_by_status_async(self, status: OrderStatus) -&gt; list[Order]:\n        \"\"\"Get all orders with a specific status\"\"\"\n        all_orders = await self.get_all_async()\n        return [order for order in all_orders if order.status == status]\n\n    async def get_orders_by_date_range_async(self, start_date: datetime, end_date: datetime) -&gt; list[Order]:\n        \"\"\"Get orders within a date range\"\"\"\n        all_orders = await self.get_all_async()\n        return [order for order in all_orders if start_date &lt;= order.created_at &lt;= end_date]\n\n    async def get_active_orders_async(self) -&gt; list[Order]:\n        \"\"\"Get all active orders (not delivered or cancelled)\"\"\"\n        all_orders = await self.get_all_async()\n        active_statuses = {OrderStatus.CONFIRMED, OrderStatus.COOKING}\n        return [order for order in all_orders if order.status in active_statuses]\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#key-repository-features","title":"Key Repository Features","text":"<ul> <li>Generic Base Class: Inherits from <code>FileSystemRepository[Order, str]</code> for common CRUD operations</li> <li>Domain Interface: Implements <code>IOrderRepository</code> for business-specific methods</li> <li>Status Filtering: <code>get_orders_by_status_async()</code> for filtering by OrderStatus enum</li> <li>Date Range Queries: <code>get_orders_by_date_range_async()</code> for reporting functionality</li> <li>Business Logic: <code>get_active_orders_async()</code> returns orders in CONFIRMED or COOKING status</li> <li>JSON Persistence: Built-in serialization through FileSystemRepository base class</li> <li>Type Safety: Strongly typed with Order entity and string keys</li> </ul>"},{"location":"guides/mario-pizzeria-tutorial/#step-4-rest-api-controllers","title":"\ud83c\udf10 Step 4: REST API Controllers","text":"<p>orders_controller.py (lines 1-83)</p> samples/mario-pizzeria/api/controllers/orders_controller.py<pre><code>from typing import List, Optional\nfrom fastapi import HTTPException\n\nfrom neuroglia.mvc import ControllerBase\nfrom neuroglia.dependency_injection import ServiceProviderBase\nfrom neuroglia.mapping import Mapper\nfrom neuroglia.mediation import Mediator\nfrom classy_fastapi import get, post, put\n\nfrom api.dtos import (\n    OrderDto,\n    CreateOrderDto,\n    UpdateOrderStatusDto,\n)\nfrom application.commands import PlaceOrderCommand, StartCookingCommand, CompleteOrderCommand\nfrom application.queries import (\n    GetOrderByIdQuery,\n    GetOrdersByStatusQuery,\n    GetActiveOrdersQuery,\n)\n\n\nclass OrdersController(ControllerBase):\n    \"\"\"Mario's pizza order management endpoints\"\"\"\n\n    def __init__(self, service_provider: ServiceProviderBase, mapper: Mapper, mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n    @get(\"/{order_id}\", response_model=OrderDto, responses=ControllerBase.error_responses)\n    async def get_order(self, order_id: str):\n        \"\"\"Get order details by ID\"\"\"\n        query = GetOrderByIdQuery(order_id=order_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/\", response_model=List[OrderDto], responses=ControllerBase.error_responses)\n    async def get_orders(self, status: Optional[str] = None):\n        \"\"\"Get orders, optionally filtered by status\"\"\"\n        if status:\n            query = GetOrdersByStatusQuery(status=status)\n        else:\n            query = GetActiveOrdersQuery()\n\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @post(\"/\", response_model=OrderDto, status_code=201, responses=ControllerBase.error_responses)\n    async def place_order(self, request: CreateOrderDto):\n        \"\"\"Place a new pizza order\"\"\"\n        command = self.mapper.map(request, PlaceOrderCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @put(\"/{order_id}/cook\", response_model=OrderDto, responses=ControllerBase.error_responses)\n    async def start_cooking(self, order_id: str):\n        \"\"\"Start cooking an order\"\"\"\n        command = StartCookingCommand(order_id=order_id)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @put(\"/{order_id}/ready\", response_model=OrderDto, responses=ControllerBase.error_responses)\n    async def complete_order(self, order_id: str):\n        \"\"\"Mark order as ready for pickup/delivery\"\"\"\n        command = CompleteOrderCommand(order_id=order_id)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @put(\"/{order_id}/status\", response_model=OrderDto, responses=ControllerBase.error_responses)\n    async def update_order_status(self, order_id: str, request: UpdateOrderStatusDto):\n        \"\"\"Update order status (general endpoint)\"\"\"\n        # Route to appropriate command based on status\n        if request.status.lower() == \"cooking\":\n            command = StartCookingCommand(order_id=order_id)\n        elif request.status.lower() == \"ready\":\n            command = CompleteOrderCommand(order_id=order_id)\n        else:\n            raise HTTPException(\n                status_code=400, detail=f\"Unsupported status transition: {request.status}\"\n            )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#key-controller-features","title":"Key Controller Features","text":"<ul> <li>Full CRUD Operations: Complete order lifecycle management from creation to completion</li> <li>RESTful Design: Proper HTTP methods (GET, POST, PUT) and status codes (200, 201, 400, 404)</li> <li>Mediator Pattern: All business logic delegated to command/query handlers</li> <li>Type Safety: Strong typing with Pydantic models for requests and responses</li> <li>Error Handling: Consistent error responses using ControllerBase.error_responses</li> <li>Status Management: Multiple endpoints for different order status transitions</li> <li>Auto-mapping: Seamless DTO to command conversion using mapper.map()</li> <li>Clean Architecture: Controllers are thin orchestrators, business logic stays in handlers</li> </ul>"},{"location":"guides/mario-pizzeria-tutorial/#step-5-oauth-authentication","title":"\ud83d\udd10 Step 5: OAuth Authentication","text":"<p>src/infrastructure/auth.py</p> <pre><code>from typing import Optional\nfrom fastapi import HTTPException, Depends, status\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom neuroglia.core import OperationResult\n\n# Simple OAuth configuration\nOAUTH_SCOPES = {\n    \"orders:read\": \"Read order information\",\n    \"orders:write\": \"Create and modify orders\",\n    \"kitchen:manage\": \"Manage kitchen operations\",\n    \"admin\": \"Full administrative access\"\n}\n\n# Simple token validation (in production, use proper OAuth provider)\nVALID_TOKENS = {\n    \"customer_token\": {\"user\": \"customer\", \"scopes\": [\"orders:read\", \"orders:write\"]},\n    \"staff_token\": {\"user\": \"kitchen_staff\", \"scopes\": [\"orders:read\", \"kitchen:manage\"]},\n    \"admin_token\": {\"user\": \"admin\", \"scopes\": [\"admin\"]}\n}\n\nsecurity = HTTPBearer()\n\nasync def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)) -&gt; dict:\n    \"\"\"Validate token and return user info\"\"\"\n    token = credentials.credentials\n\n    if token not in VALID_TOKENS:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid authentication token\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n    return VALID_TOKENS[token]\n\ndef require_scope(required_scope: str):\n    \"\"\"Decorator to require specific OAuth scope\"\"\"\n    def check_scope(current_user: dict = Depends(get_current_user)):\n        user_scopes = current_user.get(\"scopes\", [])\n        if required_scope not in user_scopes and \"admin\" not in user_scopes:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=f\"Insufficient permissions. Required scope: {required_scope}\"\n            )\n        return current_user\n    return check_scope\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#step-6-simple-web-ui","title":"\ud83c\udfa8 Step 6: Simple Web UI","text":"<p>src/web/static/index.html</p> <pre><code>&lt;!doctype html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;Mario's Pizzeria&lt;/title&gt;\n    &lt;style&gt;\n      body {\n        font-family: Arial, sans-serif;\n        max-width: 800px;\n        margin: 0 auto;\n        padding: 20px;\n      }\n      .pizza-card {\n        border: 1px solid #ddd;\n        border-radius: 8px;\n        padding: 15px;\n        margin: 10px 0;\n      }\n      .order-form {\n        background: #f5f5f5;\n        padding: 20px;\n        border-radius: 8px;\n        margin: 20px 0;\n      }\n      button {\n        background: #e74c3c;\n        color: white;\n        border: none;\n        padding: 10px 20px;\n        border-radius: 4px;\n        cursor: pointer;\n      }\n      button:hover {\n        background: #c0392b;\n      }\n      input,\n      select {\n        padding: 8px;\n        margin: 5px;\n        border: 1px solid #ddd;\n        border-radius: 4px;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;\ud83c\udf55 Welcome to Mario's Pizzeria&lt;/h1&gt;\n\n    &lt;div id=\"menu-section\"&gt;\n      &lt;h2&gt;Our Menu&lt;/h2&gt;\n      &lt;div id=\"menu-items\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;div class=\"order-form\"&gt;\n      &lt;h2&gt;Place Your Order&lt;/h2&gt;\n      &lt;form id=\"order-form\"&gt;\n        &lt;div&gt;\n          &lt;input type=\"text\" id=\"customer-name\" placeholder=\"Your Name\" required /&gt;\n          &lt;input type=\"tel\" id=\"customer-phone\" placeholder=\"Phone Number\" required /&gt;\n        &lt;/div&gt;\n        &lt;div id=\"pizza-selection\"&gt;&lt;/div&gt;\n        &lt;button type=\"submit\"&gt;Place Order&lt;/button&gt;\n      &lt;/form&gt;\n    &lt;/div&gt;\n\n    &lt;div id=\"order-status\" style=\"display: none;\"&gt;\n      &lt;h2&gt;Order Status&lt;/h2&gt;\n      &lt;div id=\"status-details\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n      // Load menu on page load\n      document.addEventListener(\"DOMContentLoaded\", loadMenu);\n\n      async function loadMenu() {\n        try {\n          const response = await fetch(\"/api/menu\");\n          const menu = await response.json();\n          displayMenu(menu);\n        } catch (error) {\n          console.error(\"Failed to load menu:\", error);\n        }\n      }\n\n      function displayMenu(menu) {\n        const menuContainer = document.getElementById(\"menu-items\");\n        menuContainer.innerHTML = menu\n          .map(\n            pizza =&gt; `\n                &lt;div class=\"pizza-card\"&gt;\n                    &lt;h3&gt;${pizza.name}&lt;/h3&gt;\n                    &lt;p&gt;Base Price: $${pizza.base_price}&lt;/p&gt;\n                    &lt;p&gt;Prep Time: ${pizza.preparation_time_minutes} minutes&lt;/p&gt;\n                    &lt;button onclick=\"addToOrder('${pizza.id}', '${pizza.name}')\"&gt;Add to Order&lt;/button&gt;\n                &lt;/div&gt;\n            `\n          )\n          .join(\"\");\n      }\n\n      function addToOrder(pizzaId, pizzaName) {\n        const selection = document.getElementById(\"pizza-selection\");\n        selection.innerHTML += `\n                &lt;div class=\"pizza-selection\"&gt;\n                    &lt;span&gt;${pizzaName}&lt;/span&gt;\n                    &lt;select name=\"size\"&gt;\n                        &lt;option value=\"small\"&gt;Small&lt;/option&gt;\n                        &lt;option value=\"medium\"&gt;Medium&lt;/option&gt;\n                        &lt;option value=\"large\"&gt;Large&lt;/option&gt;\n                    &lt;/select&gt;\n                    &lt;select name=\"toppings\" multiple&gt;\n                        &lt;option value=\"pepperoni\"&gt;Pepperoni&lt;/option&gt;\n                        &lt;option value=\"mushrooms\"&gt;Mushrooms&lt;/option&gt;\n                        &lt;option value=\"bell_peppers\"&gt;Bell Peppers&lt;/option&gt;\n                    &lt;/select&gt;\n                    &lt;input type=\"hidden\" name=\"pizza_id\" value=\"${pizzaId}\"&gt;\n                &lt;/div&gt;\n            `;\n      }\n\n      document.getElementById(\"order-form\").addEventListener(\"submit\", async e =&gt; {\n        e.preventDefault();\n\n        const formData = new FormData(e.target);\n        const order = {\n          customer_name: formData.get(\"customer-name\"),\n          customer_phone: formData.get(\"customer-phone\"),\n          pizza_items: Array.from(document.querySelectorAll(\".pizza-selection\")).map(item =&gt; ({\n            pizza_id: item.querySelector('[name=\"pizza_id\"]').value,\n            size: item.querySelector('[name=\"size\"]').value,\n            toppings: Array.from(item.querySelectorAll('[name=\"toppings\"] option:checked')).map(opt =&gt; opt.value),\n          })),\n        };\n\n        try {\n          const response = await fetch(\"/api/orders\", {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(order),\n          });\n\n          const result = await response.json();\n          showOrderStatus(result);\n        } catch (error) {\n          alert(\"Failed to place order: \" + error.message);\n        }\n      });\n\n      function showOrderStatus(order) {\n        document.getElementById(\"order-status\").style.display = \"block\";\n        document.getElementById(\"status-details\").innerHTML = `\n                &lt;p&gt;&lt;strong&gt;Order ID:&lt;/strong&gt; ${order.order_id}&lt;/p&gt;\n                &lt;p&gt;&lt;strong&gt;Total:&lt;/strong&gt; $${order.total_amount}&lt;/p&gt;\n                &lt;p&gt;&lt;strong&gt;Estimated Ready Time:&lt;/strong&gt; ${new Date(\n                  order.estimated_ready_time\n                ).toLocaleTimeString()}&lt;/p&gt;\n            `;\n      }\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#step-7-application-setup","title":"\ud83d\ude80 Step 7: Application Setup","text":"<p>The main application file demonstrates sophisticated multi-app architecture with dependency injection configuration.</p> <p>main.py (lines 1-226)</p> samples/mario-pizzeria/main.py<pre><code>#!/usr/bin/env python3\n\"\"\"\nMario's Pizzeria - Main Application Entry Point\n\nThis is the complete sample application demonstrating all major Neuroglia framework features.\n\"\"\"\n\nimport logging\nimport sys\nfrom pathlib import Path\nfrom typing import Optional\n\n# Set up debug logging early\nlogging.basicConfig(level=logging.DEBUG)\n\n# Add the project root to Python path so we can import neuroglia\nproject_root = Path(__file__).parent.parent.parent.parent\nsys.path.insert(0, str(project_root / \"src\"))\n\n# Domain repository interfaces\nfrom domain.repositories import (\n    ICustomerRepository,\n    IKitchenRepository,\n    IOrderRepository,\n    IPizzaRepository,\n)\nfrom integration.repositories import (\n    FileCustomerRepository,\n    FileKitchenRepository,\n    FileOrderRepository,\n    FilePizzaRepository,\n)\n\n# Framework imports (must be after path manipulation)\nfrom neuroglia.hosting.enhanced_web_application_builder import (\n    EnhancedWebApplicationBuilder,\n)\nfrom neuroglia.mapping import Mapper\nfrom neuroglia.mediation import Mediator\n\n\ndef create_pizzeria_app(data_dir: Optional[str] = None, port: int = 8000):\n    \"\"\"\n    Create Mario's Pizzeria application with multi-app architecture.\n\n    Creates separate apps for:\n    - API backend (/api prefix)\n    - Future UI frontend (/ prefix)\n    \"\"\"\n    # Determine data directory\n    data_dir_path = Path(data_dir) if data_dir else Path(__file__).parent / \"data\"\n    data_dir_path.mkdir(exist_ok=True)\n\n    print(f\"\ud83d\udcbe Data stored in: {data_dir_path}\")\n\n    # Create enhanced web application builder\n    builder = EnhancedWebApplicationBuilder()\n\n    # Register repositories with file-based implementations\n    builder.services.add_singleton(\n        IPizzaRepository,\n        implementation_factory=lambda _: FilePizzaRepository(str(data_dir_path / \"menu\")),\n    )\n    builder.services.add_singleton(\n        ICustomerRepository,\n        implementation_factory=lambda _: FileCustomerRepository(str(data_dir_path / \"customers\")),\n    )\n    builder.services.add_singleton(\n        IOrderRepository,\n        implementation_factory=lambda _: FileOrderRepository(str(data_dir_path / \"orders\")),\n    )\n    builder.services.add_singleton(\n        IKitchenRepository,\n        implementation_factory=lambda _: FileKitchenRepository(str(data_dir_path / \"kitchen\")),\n    )\n\n    # Configure mediator with auto-discovery from command and query modules\n    Mediator.configure(builder, [\"application.commands\", \"application.queries\"])\n\n    # Configure auto-mapper with custom profile\n    Mapper.configure(builder, [\"application.mapping\", \"api.dtos\", \"domain.entities\"])\n\n    # Configure JSON serialization with type discovery\n    from neuroglia.serialization.json import JsonSerializer\n\n    # Configure JsonSerializer with domain modules for enum discovery\n    JsonSerializer.configure(\n        builder,\n        type_modules=[\n            \"domain.entities.enums\",  # Mario Pizzeria enum types\n            \"domain.entities\",  # Also scan entities module for embedded enums\n        ],\n    )\n\n    # Build the service provider (not the full app yet)\n    service_provider = builder.services.build()\n\n    # Create the main FastAPI app directly\n    from fastapi import FastAPI\n\n    app = FastAPI(\n        title=\"Mario's Pizzeria\",\n        description=\"Complete pizza ordering and management system\",\n        version=\"1.0.0\",\n        debug=True,\n    )\n\n    # Make DI services available to the app\n    app.state.services = service_provider\n\n    # Create separate API app for backend REST API\n    api_app = FastAPI(\n        title=\"Mario's Pizzeria API\",\n        description=\"Pizza ordering and management API\",\n        version=\"1.0.0\",\n        docs_url=\"/docs\",\n        debug=True,\n    )\n\n    # IMPORTANT: Make services available to API app as well\n    api_app.state.services = service_provider\n\n    # Register API controllers to the API app\n    builder.add_controllers([\"api.controllers\"], app=api_app)\n\n    # Add exception handling to API app\n    builder.add_exception_handling(api_app)\n\n    # Mount the apps\n    app.mount(\"/api\", api_app, name=\"api\")\n    app.mount(\"/ui\", ui_app, name=\"ui\")\n\n    return app\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#key-implementation-features","title":"Key Implementation Features","text":"<p>Multi-App Architecture (lines 102-125)</p> <p>The application uses a sophisticated multi-app setup:</p> <ul> <li>Main App: Root FastAPI application with welcome endpoint</li> <li>API App: Dedicated backend API mounted at <code>/api</code> with Swagger documentation</li> <li>UI App: Future frontend application mounted at <code>/ui</code></li> </ul> <p>Repository Registration Pattern (lines 64-82)</p> <p>Uses interface-based dependency injection with file-based implementations:</p> Repository Registration Pattern<pre><code>builder.services.add_singleton(\n    IPizzaRepository,\n    implementation_factory=lambda _: FilePizzaRepository(str(data_dir_path / \"menu\")),\n)\n</code></pre> <p>Auto-Discovery Configuration (lines 84-98)</p> <p>Framework components use module scanning for automatic registration:</p> Auto-Discovery Setup<pre><code># Configure mediator with auto-discovery from command and query modules\nMediator.configure(builder, [\"application.commands\", \"application.queries\"])\n\n# Configure auto-mapper with custom profile\nMapper.configure(builder, [\"application.mapping\", \"api.dtos\", \"domain.entities\"])\n\n# Configure JsonSerializer with domain modules for enum discovery\nJsonSerializer.configure(\n    builder,\n    type_modules=[\n        \"domain.entities.enums\",  # Mario Pizzeria enum types\n        \"domain.entities\",  # Also scan entities module for embedded enums\n    ],\n)\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#running-the-application","title":"\ud83c\udfaf Running the Application","text":"<p>The main entry point provides comprehensive application bootstrapping and startup logic:</p> <p>Application Startup (lines 198-226)</p> Application Entry Point<pre><code>def main():\n    \"\"\"Main entry point when running as a script\"\"\"\n    import uvicorn\n\n    # Parse command line arguments\n    port = 8000\n    host = \"127.0.0.1\"\n    data_dir = None\n\n    if len(sys.argv) &gt; 1:\n        for i, arg in enumerate(sys.argv[1:], 1):\n            if arg == \"--port\" and i + 1 &lt; len(sys.argv):\n                port = int(sys.argv[i + 1])\n            elif arg == \"--host\" and i + 1 &lt; len(sys.argv):\n                host = sys.argv[i + 1]\n            elif arg == \"--data-dir\" and i + 1 &lt; len(sys.argv):\n                data_dir = sys.argv[i + 1]\n\n    # Create the application\n    app = create_pizzeria_app(data_dir=data_dir, port=port)\n\n    print(f\"\ud83c\udf55 Starting Mario's Pizzeria on http://{host}:{port}\")\n    print(f\"\ud83d\udcd6 API Documentation available at http://{host}:{port}/api/docs\")\n    print(f\"\ud83c\udf10 UI will be available at http://{host}:{port}/ui (coming soon)\")\n\n    # Run the server\n    uvicorn.run(app, host=host, port=port)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#youre-done","title":"\ud83c\udf89 You're Done","text":"<p>Run your pizzeria:</p> <pre><code>cd samples/mario-pizzeria\npython main.py\n</code></pre> <p>Visit your application:</p> <ul> <li>Web UI: http://localhost:8000</li> <li>API Documentation: http://localhost:8000/docs</li> <li>API Endpoints: http://localhost:8000/api</li> </ul>"},{"location":"guides/mario-pizzeria-tutorial/#what-youve-built","title":"\ud83d\udd0d What You've Built","text":"<ul> <li>\u2705 Complete Web Application with UI and API</li> <li>\u2705 Clean Architecture with domain, application, and infrastructure layers</li> <li>\u2705 CQRS Pattern with commands and queries</li> <li>\u2705 Event-Driven Design with domain events</li> <li>\u2705 File-Based Persistence using the repository pattern</li> <li>\u2705 OAuth Authentication for secure endpoints</li> <li>\u2705 Enhanced Web Application Builder with multi-app support</li> <li>\u2705 Automatic API Documentation with Swagger UI</li> </ul>"},{"location":"guides/mario-pizzeria-tutorial/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<p>Now that you've built a complete application, explore advanced Neuroglia features:</p>"},{"location":"guides/mario-pizzeria-tutorial/#architecture-deep-dives","title":"\ud83c\udfdb\ufe0f Architecture Deep Dives","text":"<ul> <li>Clean architecture principles and layer separation</li> <li>CQRS &amp; Mediation - Advanced command/query patterns and pipeline behaviors</li> <li>Dependency Injection - Advanced DI patterns and service lifetimes</li> </ul>"},{"location":"guides/mario-pizzeria-tutorial/#advanced-features","title":"\ud83d\ude80 Advanced Features","text":"<ul> <li>Event Sourcing - Complete event-driven architecture with event stores</li> <li>Data Access - MongoDB and other persistence options beyond file storage</li> <li>MVC Controllers - Advanced controller patterns and API design</li> </ul>"},{"location":"guides/mario-pizzeria-tutorial/#sample-applications","title":"\ud83d\udccb Sample Applications","text":"<ul> <li>OpenBank Sample - Banking domain with event sourcing</li> <li>API Gateway Sample - Microservice gateway patterns</li> <li>Desktop Controller Sample - Background services and system integration</li> </ul>"},{"location":"guides/mario-pizzeria-tutorial/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\u26a1 3-Minute Bootstrap - Quick hello world setup</li> <li>\ud83d\udee0\ufe0f Local Development Setup - Complete development environment</li> <li>\ud83c\udfaf Getting Started Overview - Choose your learning path</li> </ul> <p>\ud83c\udf89 Congratulations!</p> <p>You've built a complete, production-ready application using Neuroglia! All other documentation examples use this same pizzeria domain for consistency - you'll feel right at home exploring advanced features.</p>"},{"location":"guides/project-setup/","title":"\ud83d\ude80 Project Setup Guide","text":"<p>\ud83d\udea7 Under Construction</p> <p>This guide is currently being developed with comprehensive setup procedures and troubleshooting tips. More detailed examples and best practices are being added.</p> <p>Complete guide for setting up new Neuroglia Python Framework projects, from initial creation to deployment-ready applications.</p>"},{"location":"guides/project-setup/#overview","title":"\ud83c\udfaf Overview","text":"<p>This guide walks you through creating a new Neuroglia project using the Mario's Pizzeria example, covering project structure, dependency management, and initial configuration.</p>"},{"location":"guides/project-setup/#prerequisites","title":"\ud83d\udccb Prerequisites","text":"<p>Before starting, ensure you have:</p> <ul> <li>Python 3.9+ installed</li> <li>Poetry for dependency management</li> <li>Git for version control</li> <li>VS Code or preferred IDE</li> </ul> <pre><code># Verify Python version\npython --version  # Should be 3.9 or higher\n\n# Install Poetry if not already installed\ncurl -sSL https://install.python-poetry.org | python3 -\n\n# Verify Poetry installation\npoetry --version\n</code></pre>"},{"location":"guides/project-setup/#creating-a-new-project","title":"\ud83c\udfd7\ufe0f Creating a New Project","text":""},{"location":"guides/project-setup/#option-1-using-pyneuroctl-recommended","title":"Option 1: Using PyNeuroctl (Recommended)","text":"<pre><code># Install the CLI tool\npip install neuroglia-cli\n\n# Create new project from pizzeria template\npyneuroctl new my-pizzeria --template pizzeria\ncd my-pizzeria\n\n# Install dependencies\npoetry install\n\n# Run the application\npoetry run python main.py\n</code></pre>"},{"location":"guides/project-setup/#option-2-manual-setup","title":"Option 2: Manual Setup","text":"<pre><code># Create project directory\nmkdir my-pizzeria &amp;&amp; cd my-pizzeria\n\n# Initialize Poetry project\npoetry init --name my-pizzeria --description \"Pizza ordering system\"\n\n# Add Neuroglia framework\npoetry add neuroglia\n\n# Add development dependencies\npoetry add --group dev pytest pytest-asyncio httpx\n\n# Create project structure\nmkdir -p src/{api,application,domain,integration}\nmkdir -p tests/{unit,integration}\n</code></pre>"},{"location":"guides/project-setup/#project-structure","title":"\ud83d\udcc1 Project Structure","text":"<p>Create the clean architecture structure:</p> <pre><code>my-pizzeria/\n\u251c\u2500\u2500 pyproject.toml              # Project configuration\n\u251c\u2500\u2500 main.py                     # Application entry point\n\u251c\u2500\u2500 README.md                   # Project documentation\n\u251c\u2500\u2500 .env                        # Environment variables\n\u251c\u2500\u2500 .gitignore                  # Git ignore patterns\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 api/                    # \ud83c\udf10 API Layer\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 controllers/        # REST endpoints\n\u2502   \u2502   \u2514\u2500\u2500 dtos/              # Request/response models\n\u2502   \u251c\u2500\u2500 application/            # \ud83d\udcbc Application Layer\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 commands/          # Write operations\n\u2502   \u2502   \u251c\u2500\u2500 queries/           # Read operations\n\u2502   \u2502   \u251c\u2500\u2500 handlers/          # Business logic\n\u2502   \u2502   \u2514\u2500\u2500 services/          # Application services\n\u2502   \u251c\u2500\u2500 domain/                # \ud83c\udfdb\ufe0f Domain Layer\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 entities/          # Business entities\n\u2502   \u2502   \u251c\u2500\u2500 events/            # Domain events\n\u2502   \u2502   \u2514\u2500\u2500 repositories/      # Repository interfaces\n\u2502   \u2514\u2500\u2500 integration/           # \ud83d\udd0c Integration Layer\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 repositories/      # Data access implementations\n\u2502       \u2514\u2500\u2500 services/          # External service integrations\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 conftest.py           # Test configuration\n\u2502   \u251c\u2500\u2500 unit/                 # Unit tests\n\u2502   \u2514\u2500\u2500 integration/          # Integration tests\n\u2514\u2500\u2500 docs/                     # Project documentation\n</code></pre>"},{"location":"guides/project-setup/#configuration-setup","title":"\u2699\ufe0f Configuration Setup","text":""},{"location":"guides/project-setup/#1-environment-configuration","title":"1. Environment Configuration","text":"<p>Create <code>.env</code> file:</p> <pre><code># Application Settings\nAPP_NAME=My Pizzeria\nAPP_VERSION=1.0.0\nDEBUG=true\n\n# Server Configuration\nHOST=0.0.0.0\nPORT=8000\n\n# Database Configuration\nDATABASE_TYPE=mongodb\nMONGODB_CONNECTION_STRING=mongodb://localhost:27017/pizzeria\n\n# External Services\nSMS_SERVICE_API_KEY=your_sms_api_key\nEMAIL_SERVICE_API_KEY=your_email_api_key\nPAYMENT_GATEWAY_API_KEY=your_payment_api_key\n\n# Logging\nLOG_LEVEL=INFO\nLOG_FORMAT=json\n</code></pre>"},{"location":"guides/project-setup/#2-project-configuration","title":"2. Project Configuration","text":"<p>Update <code>pyproject.toml</code>:</p> <pre><code>[tool.poetry]\nname = \"my-pizzeria\"\nversion = \"1.0.0\"\ndescription = \"Pizza ordering system built with Neuroglia\"\nauthors = [\"Your Name &lt;your.email@example.com&gt;\"]\npackages = [{include = \"src\"}]\n\n[tool.poetry.dependencies]\npython = \"^3.9\"\nneuroglia = \"^0.3.0\"\nfastapi = \"^0.104.0\"\nuvicorn = \"^0.24.0\"\nmotor = \"^3.3.0\"  # MongoDB async driver\npydantic-settings = \"^2.0.0\"\n\n[tool.poetry.group.dev.dependencies]\npytest = \"^7.4.0\"\npytest-asyncio = \"^0.21.0\"\nhttpx = \"^0.25.0\"\npytest-cov = \"^4.1.0\"\nblack = \"^23.0.0\"\nisort = \"^5.12.0\"\nmypy = \"^1.6.0\"\n\n[tool.pytest.ini_options]\nasyncio_mode = \"auto\"\ntestpaths = [\"tests\"]\npython_files = [\"test_*.py\", \"*_test.py\"]\n\n[tool.black]\nline-length = 100\ntarget-version = ['py39']\n\n[tool.isort]\nprofile = \"black\"\nmulti_line_output = 3\nline_length = 100\n\n[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n</code></pre>"},{"location":"guides/project-setup/#initial-implementation","title":"\ud83c\udf55 Initial Implementation","text":""},{"location":"guides/project-setup/#1-application-entry-point","title":"1. Application Entry Point","text":"<p>Create <code>main.py</code>:</p> <pre><code>import asyncio\nfrom src.startup import create_app\n\nasync def main():\n    \"\"\"Application entry point\"\"\"\n    app = await create_app()\n\n    import uvicorn\n    uvicorn.run(\n        app,\n        host=\"0.0.0.0\",\n        port=8000,\n        reload=True  # Development only\n    )\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"guides/project-setup/#2-application-startup","title":"2. Application Startup","text":"<p>Create <code>src/startup.py</code>:</p> <pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.dependency_injection import ServiceCollection\nfrom src.api.controllers.orders_controller import OrdersController\nfrom src.application.handlers.place_order_handler import PlaceOrderHandler\nfrom src.integration.repositories.mongo_order_repository import MongoOrderRepository\n\nasync def create_app():\n    \"\"\"Configure and build the application\"\"\"\n    builder = WebApplicationBuilder()\n\n    # Configure services\n    configure_services(builder.services)\n\n    # Build application\n    app = builder.build()\n\n    # Configure middleware\n    configure_middleware(app)\n\n    return app\n\ndef configure_services(services: ServiceCollection):\n    \"\"\"Configure dependency injection\"\"\"\n    # Add framework services\n    services.add_mediator()\n    services.add_controllers([\n        \"src.api.controllers\"\n    ])\n\n    # Add application services\n    services.add_scoped(PlaceOrderHandler)\n\n    # Add repositories\n    services.add_scoped(MongoOrderRepository)\n\n    # Add external services\n    # services.add_scoped(SMSService)\n    # services.add_scoped(PaymentService)\n\ndef configure_middleware(app):\n    \"\"\"Configure application middleware\"\"\"\n    # Add CORS if needed\n    # app.add_middleware(CORSMiddleware, ...)\n\n    # Add authentication if needed\n    # app.add_middleware(AuthenticationMiddleware, ...)\n\n    pass\n</code></pre>"},{"location":"guides/project-setup/#3-first-domain-entity","title":"3. First Domain Entity","text":"<p>Create <code>src/domain/entities/order.py</code>:</p> <pre><code>from dataclasses import dataclass\nfrom decimal import Decimal\nfrom datetime import datetime\nfrom typing import List, Optional\nfrom enum import Enum\nfrom neuroglia.domain import Entity\nfrom src.domain.events.order_events import OrderPlacedEvent\n\nclass OrderStatus(Enum):\n    PENDING = \"pending\"\n    CONFIRMED = \"confirmed\"\n    PREPARING = \"preparing\"\n    READY = \"ready\"\n    DELIVERED = \"delivered\"\n    CANCELLED = \"cancelled\"\n\n@dataclass\nclass OrderItem:\n    pizza_name: str\n    size: str\n    quantity: int\n    price: Decimal\n\nclass Order(Entity):\n    def __init__(self,\n                 customer_id: str,\n                 items: List[OrderItem],\n                 delivery_address: str,\n                 special_instructions: Optional[str] = None):\n        super().__init__()\n        self.customer_id = customer_id\n        self.items = items\n        self.delivery_address = delivery_address\n        self.special_instructions = special_instructions\n        self.status = OrderStatus.PENDING\n        self.total = self._calculate_total()\n        self.created_at = datetime.now(timezone.utc)\n        self.updated_at = self.created_at\n\n        # Raise domain event\n        self.raise_event(OrderPlacedEvent(\n            order_id=self.id,\n            customer_id=customer_id,\n            total=self.total,\n            items=items\n        ))\n\n    def _calculate_total(self) -&gt; Decimal:\n        \"\"\"Calculate order total with tax\"\"\"\n        subtotal = sum(item.price * item.quantity for item in self.items)\n        tax = subtotal * Decimal('0.08')  # 8% tax\n        return subtotal + tax\n\n    def confirm(self):\n        \"\"\"Confirm the order\"\"\"\n        if self.status != OrderStatus.PENDING:\n            raise ValueError(\"Only pending orders can be confirmed\")\n        self.status = OrderStatus.CONFIRMED\n        self.updated_at = datetime.now(timezone.utc)\n</code></pre>"},{"location":"guides/project-setup/#4-first-command-handler","title":"4. First Command Handler","text":"<p>Create <code>src/application/handlers/place_order_handler.py</code>:</p> <pre><code>from dataclasses import dataclass\nfrom typing import List\nfrom neuroglia.mediation import Command, CommandHandler\nfrom neuroglia.core import OperationResult\nfrom src.domain.entities.order import Order, OrderItem\nfrom src.api.dtos.order_dto import OrderDto\n\n@dataclass\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    customer_id: str\n    items: List[OrderItem]\n    delivery_address: str\n    special_instructions: str = None\n\nclass PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    def __init__(self, order_repository):\n        self._repository = order_repository\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        try:\n            # Create domain entity\n            order = Order(\n                customer_id=command.customer_id,\n                items=command.items,\n                delivery_address=command.delivery_address,\n                special_instructions=command.special_instructions\n            )\n\n            # Persist order\n            await self._repository.save_async(order)\n\n            # Return success result\n            dto = OrderDto(\n                id=order.id,\n                customer_id=order.customer_id,\n                total=order.total,\n                status=order.status.value,\n                created_at=order.created_at\n            )\n\n            return self.created(dto)\n\n        except Exception as ex:\n            return self.internal_server_error(f\"Failed to place order: {str(ex)}\")\n</code></pre>"},{"location":"guides/project-setup/#5-first-controller","title":"5. First Controller","text":"<p>Create <code>src/api/controllers/orders_controller.py</code>:</p> <pre><code>from fastapi import HTTPException\nfrom neuroglia.mvc import ControllerBase\nfrom classy_fastapi import post\nfrom src.application.handlers.place_order_handler import PlaceOrderCommand\nfrom src.api.dtos.place_order_request import PlaceOrderRequest\nfrom src.api.dtos.order_dto import OrderDto\n\nclass OrdersController(ControllerBase):\n\n    @post(\"/orders\", response_model=OrderDto, status_code=201)\n    async def place_order(self, request: PlaceOrderRequest) -&gt; OrderDto:\n        \"\"\"Place a new pizza order\"\"\"\n        command = PlaceOrderCommand(\n            customer_id=request.customer_id,\n            items=request.items,\n            delivery_address=request.delivery_address,\n            special_instructions=request.special_instructions\n        )\n\n        result = await self.mediator.execute_async(command)\n\n        if result.is_success:\n            return result.data\n        else:\n            raise HTTPException(\n                status_code=result.status_code,\n                detail=result.error_message\n            )\n</code></pre>"},{"location":"guides/project-setup/#testing-setup","title":"\ud83e\uddea Testing Setup","text":""},{"location":"guides/project-setup/#1-test-configuration","title":"1. Test Configuration","text":"<p>Create <code>tests/conftest.py</code>:</p> <pre><code>import pytest\nfrom unittest.mock import Mock\nfrom neuroglia.dependency_injection import ServiceCollection\nfrom src.startup import configure_services\n\n@pytest.fixture\ndef service_collection():\n    \"\"\"Provide a configured service collection for testing\"\"\"\n    services = ServiceCollection()\n    configure_services(services)\n    return services\n\n@pytest.fixture\ndef mock_order_repository():\n    \"\"\"Provide a mocked order repository\"\"\"\n    return Mock()\n\n@pytest.fixture\ndef sample_order_items():\n    \"\"\"Provide sample order items for testing\"\"\"\n    from src.domain.entities.order import OrderItem\n    from decimal import Decimal\n\n    return [\n        OrderItem(\n            pizza_name=\"Margherita\",\n            size=\"Large\",\n            quantity=1,\n            price=Decimal('15.99')\n        ),\n        OrderItem(\n            pizza_name=\"Pepperoni\",\n            size=\"Medium\",\n            quantity=2,\n            price=Decimal('12.99')\n        )\n    ]\n</code></pre>"},{"location":"guides/project-setup/#2-first-unit-test","title":"2. First Unit Test","text":"<p>Create <code>tests/unit/test_place_order_handler.py</code>:</p> <pre><code>import pytest\nfrom decimal import Decimal\nfrom src.application.handlers.place_order_handler import PlaceOrderHandler, PlaceOrderCommand\n\nclass TestPlaceOrderHandler:\n    def setup_method(self):\n        self.mock_repository = Mock()\n        self.handler = PlaceOrderHandler(self.mock_repository)\n\n    @pytest.mark.asyncio\n    async def test_place_order_success(self, sample_order_items):\n        # Arrange\n        command = PlaceOrderCommand(\n            customer_id=\"123\",\n            items=sample_order_items,\n            delivery_address=\"123 Pizza St\"\n        )\n\n        # Act\n        result = await self.handler.handle_async(command)\n\n        # Assert\n        assert result.is_success\n        assert result.data.customer_id == \"123\"\n        self.mock_repository.save_async.assert_called_once()\n</code></pre>"},{"location":"guides/project-setup/#running-the-application","title":"\ud83d\ude80 Running the Application","text":""},{"location":"guides/project-setup/#development-mode","title":"Development Mode","text":"<pre><code># Install dependencies\npoetry install\n\n# Run with hot reload\npoetry run python main.py\n\n# Or using uvicorn directly\npoetry run uvicorn src.main:app --reload\n</code></pre>"},{"location":"guides/project-setup/#testing","title":"Testing","text":"<pre><code># Run all tests\npoetry run pytest\n\n# Run with coverage\npoetry run pytest --cov=src\n\n# Run specific test file\npoetry run pytest tests/unit/test_place_order_handler.py -v\n</code></pre>"},{"location":"guides/project-setup/#code-quality","title":"Code Quality","text":"<pre><code># Format code\npoetry run black src tests\n\n# Sort imports\npoetry run isort src tests\n\n# Type checking\npoetry run mypy src\n</code></pre>"},{"location":"guides/project-setup/#next-steps","title":"\ud83d\udd27 Next Steps","text":"<p>After basic setup, consider:</p> <ol> <li>API Development Guide - Add more endpoints</li> <li>Testing Guide - Comprehensive testing strategies</li> <li>Database Integration Guide - Connect to real databases</li> <li>Deployment Guide - Deploy to production</li> </ol>"},{"location":"guides/project-setup/#troubleshooting","title":"\ud83c\udd98 Troubleshooting","text":""},{"location":"guides/project-setup/#common-issues","title":"Common Issues","text":"<p>Import Errors</p> <pre><code># Ensure proper Python path\nexport PYTHONPATH=\"${PYTHONPATH}:${PWD}/src\"\n</code></pre> <p>Poetry Issues</p> <pre><code># Reset poetry environment\npoetry env remove python\npoetry install\n</code></pre> <p>Missing Dependencies</p> <pre><code># Update lock file\npoetry update\n</code></pre>"},{"location":"guides/project-setup/#related-guides","title":"\ud83d\udd17 Related Guides","text":"<ul> <li>Testing Setup - Comprehensive testing strategies</li> <li>API Development - Building REST endpoints</li> <li>Database Integration - Data persistence setup</li> </ul> <p>This guide provides the foundation for building production-ready Neuroglia applications using proven architectural patterns. \ud83d\ude80</p>"},{"location":"guides/testing-setup/","title":"\ud83e\uddea Testing Setup Guide","text":"<p>\ud83d\udea7 Under Construction</p> <p>This guide is currently being developed with comprehensive testing strategies and examples. More detailed test patterns and best practices are being added.</p> <p>Complete guide for setting up comprehensive testing in Neuroglia applications, covering unit tests, integration tests, and testing best practices.</p>"},{"location":"guides/testing-setup/#overview","title":"\ud83c\udfaf Overview","text":"<p>Testing is crucial for maintaining high-quality Neuroglia applications. This guide demonstrates testing strategies using Mario's Pizzeria as an example, covering all architectural layers.</p>"},{"location":"guides/testing-setup/#testing-strategy","title":"\ud83c\udfd7\ufe0f Testing Strategy","text":""},{"location":"guides/testing-setup/#testing-pyramid","title":"Testing Pyramid","text":"<pre><code>flowchart TD\n    subgraph \"\ud83e\uddea Testing Pyramid\"\n        E2E[End-to-End Tests&lt;br/&gt;\ud83c\udf10 Full Application Flow]\n        Integration[Integration Tests&lt;br/&gt;\ud83d\udd0c Component Interaction]\n        Unit[Unit Tests&lt;br/&gt;\u26a1 Individual Components]\n    end\n\n    E2E --&gt; Integration\n    Integration --&gt; Unit\n\n    Unit -.-&gt;|\"Most Tests\"| Fast[Fast Execution]\n    Integration -.-&gt;|\"Moderate Tests\"| Medium[Medium Execution]\n    E2E -.-&gt;|\"Few Tests\"| Slow[Slower Execution]</code></pre>"},{"location":"guides/testing-setup/#layer-specific-testing","title":"Layer-Specific Testing","text":"<ul> <li>Domain Layer: Pure unit tests for business logic</li> <li>Application Layer: Handler tests with mocked dependencies</li> <li>API Layer: Integration tests with test client</li> <li>Integration Layer: Repository and service tests</li> </ul>"},{"location":"guides/testing-setup/#test-setup","title":"\ud83d\udd27 Test Setup","text":""},{"location":"guides/testing-setup/#dependencies","title":"Dependencies","text":"<pre><code>[tool.poetry.group.dev.dependencies]\npytest = \"^7.4.0\"\npytest-asyncio = \"^0.21.0\"\npytest-cov = \"^4.1.0\"\nhttpx = \"^0.25.0\"\npytest-mock = \"^3.12.0\"\nfaker = \"^19.0.0\"\n</code></pre>"},{"location":"guides/testing-setup/#configuration","title":"Configuration","text":"<p>Create <code>pytest.ini</code>:</p> <pre><code>[tool:pytest]\nasyncio_mode = auto\ntestpaths = tests\npython_files = test_*.py *_test.py\npython_classes = Test*\npython_functions = test_*\naddopts =\n    --strict-markers\n    --strict-config\n    --cov=src\n    --cov-report=html\n    --cov-report=term-missing\n    --cov-fail-under=90\nmarkers =\n    unit: Unit tests\n    integration: Integration tests\n    e2e: End-to-end tests\n    slow: Slow running tests\n</code></pre>"},{"location":"guides/testing-setup/#unit-testing","title":"\ud83c\udfaf Unit Testing","text":""},{"location":"guides/testing-setup/#domain-entity-tests","title":"Domain Entity Tests","text":"<pre><code># tests/unit/domain/test_order.py\nimport pytest\nfrom decimal import Decimal\nfrom src.domain.entities.order import Order, OrderItem, OrderStatus\n\nclass TestOrder:\n    def test_order_creation_calculates_total_with_tax(self):\n        # Arrange\n        items = [\n            OrderItem(\"Margherita\", \"Large\", 1, Decimal('15.99')),\n            OrderItem(\"Pepperoni\", \"Medium\", 2, Decimal('12.99'))\n        ]\n\n        # Act\n        order = Order(\"customer-123\", items, \"123 Pizza St\")\n\n        # Assert\n        expected_subtotal = Decimal('41.97')  # 15.99 + (2 * 12.99)\n        expected_tax = expected_subtotal * Decimal('0.08')\n        expected_total = expected_subtotal + expected_tax\n\n        assert order.total == expected_total\n        assert order.status == OrderStatus.PENDING\n\n    def test_order_raises_domain_event(self):\n        # Arrange\n        items = [OrderItem(\"Margherita\", \"Large\", 1, Decimal('15.99'))]\n\n        # Act\n        order = Order(\"customer-123\", items, \"123 Pizza St\")\n        events = order.get_uncommitted_events()\n\n        # Assert\n        assert len(events) == 1\n        assert events[0].order_id == order.id\n        assert events[0].customer_id == \"customer-123\"\n</code></pre>"},{"location":"guides/testing-setup/#command-handler-tests","title":"Command Handler Tests","text":"<pre><code># tests/unit/application/test_place_order_handler.py\nimport pytest\nfrom unittest.mock import Mock, AsyncMock\nfrom decimal import Decimal\nfrom src.application.handlers.place_order_handler import PlaceOrderHandler, PlaceOrderCommand\nfrom src.domain.entities.order import OrderItem\n\nclass TestPlaceOrderHandler:\n    def setup_method(self):\n        self.mock_repository = Mock()\n        self.mock_repository.save_async = AsyncMock()\n        self.handler = PlaceOrderHandler(self.mock_repository)\n\n    @pytest.mark.asyncio\n    async def test_place_order_success(self):\n        # Arrange\n        items = [OrderItem(\"Margherita\", \"Large\", 1, Decimal('15.99'))]\n        command = PlaceOrderCommand(\n            customer_id=\"customer-123\",\n            items=items,\n            delivery_address=\"123 Pizza St\"\n        )\n\n        # Act\n        result = await self.handler.handle_async(command)\n\n        # Assert\n        assert result.is_success\n        assert result.data.customer_id == \"customer-123\"\n        self.mock_repository.save_async.assert_called_once()\n\n    @pytest.mark.asyncio\n    async def test_place_order_repository_error(self):\n        # Arrange\n        self.mock_repository.save_async.side_effect = Exception(\"Database error\")\n        command = PlaceOrderCommand(\n            customer_id=\"customer-123\",\n            items=[OrderItem(\"Margherita\", \"Large\", 1, Decimal('15.99'))],\n            delivery_address=\"123 Pizza St\"\n        )\n\n        # Act\n        result = await self.handler.handle_async(command)\n\n        # Assert\n        assert not result.is_success\n        assert \"Database error\" in result.error_message\n</code></pre>"},{"location":"guides/testing-setup/#integration-testing","title":"\ud83d\udd0c Integration Testing","text":""},{"location":"guides/testing-setup/#controller-integration-tests","title":"Controller Integration Tests","text":"<pre><code># tests/integration/api/test_orders_controller.py\nimport pytest\nfrom httpx import AsyncClient\nfrom src.main import create_app\n\nclass TestOrdersController:\n    @pytest.fixture\n    async def test_app(self):\n        app = await create_app()\n        return app\n\n    @pytest.fixture\n    async def test_client(self, test_app):\n        async with AsyncClient(app=test_app, base_url=\"http://test\") as client:\n            yield client\n\n    @pytest.mark.asyncio\n    async def test_place_order_success(self, test_client):\n        # Arrange\n        order_data = {\n            \"customer_id\": \"customer-123\",\n            \"items\": [\n                {\n                    \"pizza_name\": \"Margherita\",\n                    \"size\": \"Large\",\n                    \"quantity\": 1,\n                    \"price\": 15.99\n                }\n            ],\n            \"delivery_address\": \"123 Pizza St\"\n        }\n\n        # Act\n        response = await test_client.post(\"/orders\", json=order_data)\n\n        # Assert\n        assert response.status_code == 201\n        data = response.json()\n        assert data[\"customer_id\"] == \"customer-123\"\n        assert \"id\" in data\n\n    @pytest.mark.asyncio\n    async def test_place_order_validation_error(self, test_client):\n        # Arrange - Invalid data (missing required fields)\n        invalid_data = {\"customer_id\": \"customer-123\"}\n\n        # Act\n        response = await test_client.post(\"/orders\", json=invalid_data)\n\n        # Assert\n        assert response.status_code == 422  # Validation error\n</code></pre>"},{"location":"guides/testing-setup/#repository-integration-tests","title":"Repository Integration Tests","text":"<pre><code># tests/integration/repositories/test_mongo_order_repository.py\nimport pytest\nfrom motor.motor_asyncio import AsyncIOMotorClient\nfrom src.integration.repositories.mongo_order_repository import MongoOrderRepository\nfrom src.domain.entities.order import Order, OrderItem\nfrom decimal import Decimal\n\n@pytest.mark.integration\nclass TestMongoOrderRepository:\n    @pytest.fixture\n    async def mongo_client(self):\n        client = AsyncIOMotorClient(\"mongodb://localhost:27017\")\n        yield client\n        # Cleanup\n        await client.test_pizzeria.orders.drop()\n        client.close()\n\n    @pytest.fixture\n    def repository(self, mongo_client):\n        collection = mongo_client.test_pizzeria.orders\n        return MongoOrderRepository(collection)\n\n    @pytest.mark.asyncio\n    async def test_save_and_retrieve_order(self, repository):\n        # Arrange\n        items = [OrderItem(\"Margherita\", \"Large\", 1, Decimal('15.99'))]\n        order = Order(\"customer-123\", items, \"123 Pizza St\")\n\n        # Act\n        await repository.save_async(order)\n        retrieved = await repository.get_by_id_async(order.id)\n\n        # Assert\n        assert retrieved is not None\n        assert retrieved.customer_id == \"customer-123\"\n        assert len(retrieved.items) == 1\n        assert retrieved.items[0].pizza_name == \"Margherita\"\n\n    @pytest.mark.asyncio\n    async def test_find_by_customer(self, repository):\n        # Arrange\n        items = [OrderItem(\"Margherita\", \"Large\", 1, Decimal('15.99'))]\n        order1 = Order(\"customer-123\", items, \"123 Pizza St\")\n        order2 = Order(\"customer-123\", items, \"456 Pizza Ave\")\n        order3 = Order(\"customer-456\", items, \"789 Pizza Blvd\")\n\n        await repository.save_async(order1)\n        await repository.save_async(order2)\n        await repository.save_async(order3)\n\n        # Act\n        customer_orders = await repository.find_by_customer_async(\"customer-123\")\n\n        # Assert\n        assert len(customer_orders) == 2\n        assert all(order.customer_id == \"customer-123\" for order in customer_orders)\n</code></pre>"},{"location":"guides/testing-setup/#end-to-end-testing","title":"\ud83c\udf10 End-to-End Testing","text":""},{"location":"guides/testing-setup/#full-workflow-tests","title":"Full Workflow Tests","text":"<pre><code># tests/e2e/test_pizza_ordering_workflow.py\nimport pytest\nfrom httpx import AsyncClient\nfrom src.main import create_app\n\n@pytest.mark.e2e\nclass TestPizzaOrderingWorkflow:\n    @pytest.fixture\n    async def test_client(self):\n        app = await create_app()\n        async with AsyncClient(app=app, base_url=\"http://test\") as client:\n            yield client\n\n    @pytest.mark.asyncio\n    async def test_complete_order_workflow(self, test_client):\n        # 1. Get menu\n        menu_response = await test_client.get(\"/menu\")\n        assert menu_response.status_code == 200\n        menu = menu_response.json()\n        assert len(menu) &gt; 0\n\n        # 2. Place order\n        order_data = {\n            \"customer_id\": \"customer-123\",\n            \"items\": [\n                {\n                    \"pizza_name\": menu[0][\"name\"],\n                    \"size\": \"Large\",\n                    \"quantity\": 1,\n                    \"price\": menu[0][\"price\"]\n                }\n            ],\n            \"delivery_address\": \"123 Pizza St\"\n        }\n\n        order_response = await test_client.post(\"/orders\", json=order_data)\n        assert order_response.status_code == 201\n        order = order_response.json()\n        order_id = order[\"id\"]\n\n        # 3. Check order status\n        status_response = await test_client.get(f\"/orders/{order_id}\")\n        assert status_response.status_code == 200\n        status_data = status_response.json()\n        assert status_data[\"id\"] == order_id\n        assert status_data[\"status\"] == \"pending\"\n\n        # 4. Get customer order history\n        history_response = await test_client.get(\n            f\"/orders?customer_id=customer-123\"\n        )\n        assert history_response.status_code == 200\n        history = history_response.json()\n        assert len(history) &gt;= 1\n        assert any(o[\"id\"] == order_id for o in history)\n</code></pre>"},{"location":"guides/testing-setup/#test-fixtures-and-factories","title":"\ud83c\udfad Test Fixtures and Factories","text":""},{"location":"guides/testing-setup/#data-factories","title":"Data Factories","text":"<pre><code># tests/factories.py\nfrom faker import Faker\nfrom decimal import Decimal\nfrom src.domain.entities.order import Order, OrderItem\n\nfake = Faker()\n\nclass OrderFactory:\n    @staticmethod\n    def create_order_item(\n        pizza_name: str = None,\n        size: str = \"Large\",\n        quantity: int = 1,\n        price: Decimal = None\n    ) -&gt; OrderItem:\n        return OrderItem(\n            pizza_name=pizza_name or fake.word(),\n            size=size,\n            quantity=quantity,\n            price=price or Decimal(str(fake.pydecimal(left_digits=2, right_digits=2, positive=True)))\n        )\n\n    @staticmethod\n    def create_order(\n        customer_id: str = None,\n        items: list = None,\n        delivery_address: str = None\n    ) -&gt; Order:\n        return Order(\n            customer_id=customer_id or fake.uuid4(),\n            items=items or [OrderFactory.create_order_item()],\n            delivery_address=delivery_address or fake.address()\n        )\n\n# Usage in tests\ndef test_order_with_factory():\n    order = OrderFactory.create_order(\n        customer_id=\"test-customer\",\n        items=[\n            OrderFactory.create_order_item(\"Margherita\", \"Large\", 2, Decimal('15.99'))\n        ]\n    )\n    assert order.customer_id == \"test-customer\"\n</code></pre>"},{"location":"guides/testing-setup/#shared-fixtures","title":"Shared Fixtures","text":"<pre><code># tests/conftest.py\nimport pytest\nfrom unittest.mock import Mock\nfrom src.domain.entities.order import OrderItem\nfrom decimal import Decimal\n\n@pytest.fixture\ndef sample_pizza_items():\n    return [\n        OrderItem(\"Margherita\", \"Large\", 1, Decimal('15.99')),\n        OrderItem(\"Pepperoni\", \"Medium\", 2, Decimal('12.99')),\n        OrderItem(\"Vegetarian\", \"Small\", 1, Decimal('10.99'))\n    ]\n\n@pytest.fixture\ndef mock_order_repository():\n    repository = Mock()\n    repository.save_async = Mock()\n    repository.get_by_id_async = Mock()\n    repository.find_by_customer_async = Mock()\n    return repository\n\n@pytest.fixture\ndef mock_sms_service():\n    service = Mock()\n    service.send_async = Mock()\n    return service\n</code></pre>"},{"location":"guides/testing-setup/#coverage-and-quality","title":"\ud83d\udcca Coverage and Quality","text":""},{"location":"guides/testing-setup/#coverage-configuration","title":"Coverage Configuration","text":"<pre><code># Run tests with coverage\npoetry run pytest --cov=src --cov-report=html --cov-report=term\n\n# Coverage configuration in pyproject.toml\n[tool.coverage.run]\nsource = [\"src\"]\nomit = [\n    \"src/__init__.py\",\n    \"src/main.py\",\n    \"*/tests/*\",\n]\n\n[tool.coverage.report]\nexclude_lines = [\n    \"pragma: no cover\",\n    \"def __repr__\",\n    \"raise AssertionError\",\n    \"raise NotImplementedError\",\n    \"if __name__ == .__main__.:\",\n]\n</code></pre>"},{"location":"guides/testing-setup/#test-execution","title":"\ud83d\ude80 Test Execution","text":""},{"location":"guides/testing-setup/#running-tests","title":"Running Tests","text":"<pre><code># All tests\npoetry run pytest\n\n# Unit tests only\npoetry run pytest tests/unit -m unit\n\n# Integration tests only\npoetry run pytest tests/integration -m integration\n\n# E2E tests only\npoetry run pytest tests/e2e -m e2e\n\n# Specific test file\npoetry run pytest tests/unit/test_order.py -v\n\n# With coverage\npoetry run pytest --cov=src --cov-report=html\n</code></pre>"},{"location":"guides/testing-setup/#continuous-integration","title":"Continuous Integration","text":"<pre><code># .github/workflows/test.yml\nname: Tests\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    services:\n      mongodb:\n        image: mongo:5.0\n        ports:\n          - 27017:27017\n\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v4\n        with:\n          python-version: \"3.9\"\n\n      - name: Install Poetry\n        run: pip install poetry\n\n      - name: Install dependencies\n        run: poetry install\n\n      - name: Run tests\n        run: poetry run pytest --cov=src --cov-report=xml\n\n      - name: Upload coverage\n        uses: codecov/codecov-action@v3\n</code></pre>"},{"location":"guides/testing-setup/#related-guides","title":"\ud83d\udd17 Related Guides","text":"<ul> <li>Project Setup - Initial project configuration</li> <li>API Development - Testing API endpoints</li> <li>Database Integration - Testing data access</li> </ul> <p>This guide establishes comprehensive testing practices that ensure high-quality, maintainable Neuroglia applications. \ud83e\uddea</p>"},{"location":"mario-pizzeria/business-analysis/","title":"\ud83c\udfe2 Mario's Pizzeria: Business Analysis &amp; Requirements","text":"<p>Customer: Mario's Family Restaurant Project: Digital Transformation Initiative Consultant: Neuroglia Architecture Team Date: 2025</p>"},{"location":"mario-pizzeria/business-analysis/#executive-summary","title":"\ud83d\udcca Executive Summary","text":"<p>Mario's Pizzeria represents a typical small business digital transformation case study. This family-owned restaurant requires a modern ordering system to compete in today's digital marketplace while maintaining operational efficiency and customer satisfaction.</p> <p>Project Scope: Design and implement a comprehensive digital ordering platform that streamlines operations, improves customer experience, and provides real-time visibility into business operations.</p>"},{"location":"mario-pizzeria/business-analysis/#business-overview","title":"\ud83c\udfaf Business Overview","text":"<p>Mario's Pizzeria is a local pizza restaurant that needs a digital ordering system to handle:</p> <ul> <li>Customer Orders: Online pizza ordering with customizations</li> <li>Menu Management: Pizza catalog with sizes, toppings, and pricing</li> <li>Kitchen Operations: Order queue management and preparation workflow</li> <li>Payment Processing: Multiple payment methods and transaction handling</li> <li>Customer Notifications: SMS alerts for order status updates</li> </ul> <p>The pizzeria demonstrates how a simple restaurant business can be modeled using domain-driven design principles:</p> <ul> <li>Takes pizza orders from customers</li> <li>Manages pizza recipes and inventory</li> <li>Cooks pizzas in the kitchen with capacity management</li> <li>Tracks order status through complete lifecycle</li> <li>Handles payments and customer notifications</li> <li>Provides real-time status updates to customers and staff</li> </ul>"},{"location":"mario-pizzeria/business-analysis/#system-architecture","title":"\ud83c\udfd7\ufe0f System Architecture","text":"<p>The pizzeria system demonstrates clean architecture with clear layer separation:</p> <pre><code>graph TB\n    %% Actors\n    Customer[\ud83d\udc64 Customer&lt;br/&gt;Pizza lover who wants to place orders]\n    KitchenStaff[\ud83d\udc68\u200d\ud83c\udf73 Kitchen Staff&lt;br/&gt;Cooks who prepare orders]\n    Manager[\ud83d\udc68\u200d\ud83d\udcbc Manager&lt;br/&gt;Manages menu and monitors operations]\n\n    %% System Boundary\n    subgraph PizzeriaSystem[Mario's Pizzeria System]\n        PizzeriaApp[\ud83c\udf55 Pizzeria Application&lt;br/&gt;FastAPI app with clean architecture]\n    end\n\n    %% External Systems\n    PaymentSystem[\ud83d\udcb3 Payment System&lt;br/&gt;Processes credit card payments]\n    SMSService[\ud83d\udcf1 SMS Service&lt;br/&gt;Sends order notifications]\n    FileStorage[\ud83d\udcbe File Storage&lt;br/&gt;JSON files for development]\n\n    %% Relationships\n    Customer --&gt;|Places orders, checks status| PizzeriaApp\n    KitchenStaff --&gt;|Views orders, updates status| PizzeriaApp\n    Manager --&gt;|Manages menu, monitors operations| PizzeriaApp\n\n    PizzeriaApp --&gt;|Processes payments via HTTPS| PaymentSystem\n    PizzeriaApp --&gt;|Sends notifications via API| SMSService\n    PizzeriaApp --&gt;|Stores orders and menu via File I/O| FileStorage\n\n    %% Styling\n    classDef customer fill:#FFF3E0,stroke:#E65100,stroke-width:2px\n    classDef system fill:#E1F5FE,stroke:#01579B,stroke-width:3px\n    classDef external fill:#F3E5F5,stroke:#7B1FA2,stroke-width:2px\n    classDef storage fill:#E8F5E8,stroke:#2E7D32,stroke-width:2px\n\n    class Customer,KitchenStaff,Manager customer\n    class PizzeriaApp system\n    class PaymentSystem,SMSService external\n    class FileStorage storage</code></pre>"},{"location":"mario-pizzeria/business-analysis/#main-system-interactions","title":"\ud83d\udd04 Main System Interactions","text":"<p>The following sequence diagram illustrates the complete pizza ordering workflow:</p> <pre><code>sequenceDiagram\n    participant C as Customer\n    participant API as Orders Controller\n    participant M as Mediator\n    participant PH as PlaceOrder Handler\n    participant OR as Order Repository\n    participant PS as Payment Service\n    participant K as Kitchen\n    participant SMS as SMS Service\n\n    Note over C,SMS: Complete Pizza Ordering Workflow\n\n    C-&gt;&gt;+API: POST /orders (pizza order)\n    API-&gt;&gt;+M: Execute PlaceOrderCommand\n    M-&gt;&gt;+PH: Handle command\n\n    PH-&gt;&gt;PH: Validate order &amp; calculate total\n    PH-&gt;&gt;+PS: Process payment\n    PS--&gt;&gt;-PH: Payment successful\n\n    PH-&gt;&gt;+OR: Save order\n    OR--&gt;&gt;-PH: Order saved\n\n    PH-&gt;&gt;PH: Raise OrderPlacedEvent\n    PH--&gt;&gt;-M: Return OrderDto\n    M--&gt;&gt;-API: Return result\n    API--&gt;&gt;-C: 201 Created + OrderDto\n\n    Note over K,SMS: Event-Driven Kitchen Workflow\n\n    M-&gt;&gt;+K: OrderPlacedEvent \u2192 Add to queue\n    K--&gt;&gt;-M: Order queued\n\n    rect rgb(255, 245, 235)\n        Note over K: Kitchen processes order\n        K-&gt;&gt;K: Start cooking\n        K-&gt;&gt;+M: Publish OrderCookingEvent\n        M--&gt;&gt;-K: Event processed\n    end\n\n    rect rgb(240, 255, 240)\n        Note over K: Order ready\n        K-&gt;&gt;+M: Publish OrderReadyEvent\n        M-&gt;&gt;+SMS: Send ready notification\n        SMS-&gt;&gt;C: \"Your order is ready!\"\n        SMS--&gt;&gt;-M: Notification sent\n        M--&gt;&gt;-K: Event processed\n    end\n\n    C-&gt;&gt;+API: GET /orders/{id}\n    API-&gt;&gt;+M: Execute GetOrderQuery\n    M--&gt;&gt;-API: Return OrderDto\n    API--&gt;&gt;-C: Order details</code></pre>"},{"location":"mario-pizzeria/business-analysis/#business-requirements-analysis","title":"\ud83d\udcbc Business Requirements Analysis","text":""},{"location":"mario-pizzeria/business-analysis/#primary-stakeholders","title":"Primary Stakeholders","text":"Stakeholder Role Key Needs Customers Order pizza online Easy ordering, real-time status, reliable delivery Kitchen Staff Prepare orders Clear order queue, cooking instructions, status updates Management Business oversight Sales reporting, inventory tracking, performance metrics Delivery Order fulfillment Route optimization, customer contact, payment collection"},{"location":"mario-pizzeria/business-analysis/#functional-requirements","title":"Functional Requirements","text":"Category Requirement Priority Complexity Ordering Browse menu with customizations High Medium Ordering Calculate pricing with taxes High Low Ordering Process secure payments High High Kitchen Manage cooking queue High Medium Kitchen Track preparation time Medium Low Notifications SMS order updates Medium Medium Management Sales analytics Low High"},{"location":"mario-pizzeria/business-analysis/#non-functional-requirements","title":"Non-Functional Requirements","text":"Requirement Target Rationale Response Time &lt; 2 seconds Customer experience Availability 99.5% uptime Business continuity Scalability 100 concurrent orders Peak dinner rush Security PCI DSS compliance Payment processing Usability Mobile-first design Customer preference"},{"location":"mario-pizzeria/business-analysis/#success-metrics","title":"\ud83d\ude80 Success Metrics","text":""},{"location":"mario-pizzeria/business-analysis/#business-kpis","title":"Business KPIs","text":"<ul> <li>Order Volume: 30% increase in daily orders</li> <li>Average Order Value: $25 \u2192 $30 target</li> <li>Customer Satisfaction: &gt; 4.5/5 rating</li> <li>Order Accuracy: &gt; 98% correct orders</li> <li>Kitchen Efficiency: &lt; 15 minute average prep time</li> </ul>"},{"location":"mario-pizzeria/business-analysis/#technical-metrics","title":"Technical Metrics","text":"<ul> <li>API Response Time: &lt; 500ms average</li> <li>System Uptime: &gt; 99.5%</li> <li>Error Rate: &lt; 0.1%</li> <li>Payment Success: &gt; 99.9%</li> </ul>"},{"location":"mario-pizzeria/business-analysis/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Technical Architecture - System design and infrastructure</li> <li>Domain Design - Business logic and data models</li> <li>Implementation Guide - Development patterns and APIs</li> <li>Testing &amp; Deployment - Quality assurance and operations</li> </ul> <p>This analysis serves as the foundation for Mario's Pizzeria digital transformation, demonstrating modern software architecture principles applied to real-world business scenarios.</p>"},{"location":"mario-pizzeria/domain-design/","title":"\ud83c\udfaf Mario's Pizzeria: Domain Design &amp; Business Logic","text":"<p>Domain Modeling Document | Approach: Domain-Driven Design (DDD) Patterns: Rich Domain Models, Value Objects, Domain Events | Status: Reference Implementation</p>"},{"location":"mario-pizzeria/domain-design/#domain-overview","title":"\ud83c\udfaf Domain Overview","text":"<p>The Mario's Pizzeria domain captures the essential business concepts and workflows of a pizza restaurant operation. Using Domain-Driven Design principles, we model the core business entities with rich behavior, clear boundaries, and event-driven workflows.</p> <p>Core Domain Concepts:</p> <ul> <li>Orders: Central to the business, capturing customer requests and tracking fulfillment</li> <li>Pizza: Product catalog with pricing and customization logic</li> <li>Kitchen: Resource management and capacity planning</li> <li>Customer: Contact information and order history</li> </ul>"},{"location":"mario-pizzeria/domain-design/#domain-model","title":"\ud83d\udcca Domain Model","text":"<p>The core business entities and their relationships:</p> <pre><code>classDiagram\n    class Customer {\n        +String id\n        +String name\n        +String email\n        +String phone\n        +String address\n        +updateContactInfo()\n    }\n\n    class Order {\n        +String id\n        +String customerId\n        +List~Pizza~ pizzas\n        +OrderStatus status\n        +Decimal totalAmount\n        +DateTime orderTime\n        +addPizza()\n        +confirmOrder()\n        +startCooking()\n        +markReady()\n        +deliverOrder()\n        +cancelOrder()\n    }\n\n    class Pizza {\n        +String id\n        +String name\n        +PizzaSize size\n        +Decimal basePrice\n        +List~String~ toppings\n        +Decimal totalPrice\n        +addTopping()\n        +removeTopping()\n    }\n\n    class Kitchen {\n        +String id\n        +List~String~ activeOrders\n        +Int maxConcurrentOrders\n        +Int currentCapacity\n        +Bool isAtCapacity\n        +startOrder()\n        +completeOrder()\n    }\n\n    class OrderStatus {\n        &lt;&lt;enumeration&gt;&gt;\n        PENDING\n        CONFIRMED\n        COOKING\n        READY\n        DELIVERED\n        CANCELLED\n    }\n\n    class PizzaSize {\n        &lt;&lt;enumeration&gt;&gt;\n        SMALL\n        MEDIUM\n        LARGE\n    }\n\n    Customer \"1\" --&gt; \"*\" Order : places\n    Order \"1\" --&gt; \"*\" Pizza : contains\n    Order --&gt; OrderStatus : has\n    Pizza --&gt; PizzaSize : has\n    Kitchen \"1\" --&gt; \"*\" Order : processes\n\n    note for Order \"Rich domain entity with&lt;br/&gt;business logic and events\"\n    note for Pizza \"Value object with&lt;br/&gt;pricing calculations\"\n    note for Kitchen \"Aggregate root for&lt;br/&gt;capacity management\"</code></pre>"},{"location":"mario-pizzeria/domain-design/#detailed-domain-entities","title":"\ud83c\udfd7\ufe0f Detailed Domain Entities","text":""},{"location":"mario-pizzeria/domain-design/#pizza-entity","title":"Pizza Entity","text":"<p>The Pizza entity encapsulates product information, pricing logic, and customization capabilities with sophisticated size-based pricing:</p> <p>Source: <code>samples/mario-pizzeria/domain/entities/pizza.py</code></p> samples/mario-pizzeria/domain/entities/pizza.py<pre><code>@map_from(PizzaDto)\n@map_to(PizzaDto)\nclass Pizza(Entity[str]):\n    \"\"\"Pizza entity with pricing and toppings\"\"\"\n\n    def __init__(self, name: str, base_price: Decimal, size: PizzaSize, description: Optional[str] = None):\n        super().__init__()\n        self.id = str(uuid4())\n        self.name = name\n        self.base_price = base_price\n        self.size = size\n        self.description = description or \"\"\n        self.toppings: list[str] = []\n\n    @property\n    def size_multiplier(self) -&gt; Decimal:\n        \"\"\"Get price multiplier based on pizza size\"\"\"\n        multipliers = {\n            PizzaSize.SMALL: Decimal(\"1.0\"),\n            PizzaSize.MEDIUM: Decimal(\"1.3\"),\n            PizzaSize.LARGE: Decimal(\"1.6\"),\n        }\n        return multipliers[self.size]\n\n    @property\n    def topping_price(self) -&gt; Decimal:\n        \"\"\"Calculate total price for all toppings\"\"\"\n        return Decimal(str(len(self.toppings))) * Decimal(\"2.50\")\n\n    @property\n    def total_price(self) -&gt; Decimal:\n        \"\"\"Calculate total pizza price including size and toppings\"\"\"\n        base_with_size = self.base_price * self.size_multiplier\n        return base_with_size + self.topping_price\n\n    def add_topping(self, topping: str) -&gt; None:\n        \"\"\"Add a topping to the pizza\"\"\"\n        if topping not in self.toppings:\n            self.toppings.append(topping)\n\n    def remove_topping(self, topping: str) -&gt; None:\n        \"\"\"Remove a topping from the pizza\"\"\"\n        if topping in self.toppings:\n            self.toppings.remove(topping)\n</code></pre> <p>Business Rules:</p> <ul> <li>Size multipliers: Small (1.0x), Medium (1.3x), Large (1.6x) of base price</li> <li>Each topping adds $2.50 to the total price</li> <li>Automatic mapping to/from DTOs using <code>@map_from</code> and <code>@map_to</code> decorators</li> <li>UUID-based entity identification</li> </ul>"},{"location":"mario-pizzeria/domain-design/#order-entity","title":"Order Entity","text":"<p>The Order aggregate root manages the complete order lifecycle and business rules:</p> <pre><code>@dataclass\nclass Order(Entity[str]):\n    \"\"\"A customer pizza order with complete lifecycle management\"\"\"\n    id: str\n    customer_name: str\n    customer_phone: str\n    pizzas: List[Pizza]\n    status: str  # \"pending\", \"confirmed\", \"cooking\", \"ready\", \"delivered\"\n    order_time: datetime\n    estimated_ready_time: Optional[datetime] = None\n    total_amount: Optional[Decimal] = None\n\n    def __post_init__(self):\n        if self.total_amount is None:\n            self.calculate_total()\n\n    def calculate_total(self) -&gt; None:\n        \"\"\"Calculate order total including taxes and fees\"\"\"\n        subtotal = sum(pizza.total_price for pizza in self.pizzas)\n        tax_rate = Decimal(\"0.08\")  # 8% tax\n        delivery_fee = Decimal(\"2.50\")\n\n        self.total_amount = subtotal + (subtotal * tax_rate) + delivery_fee\n\n    def add_pizza(self, pizza: Pizza) -&gt; None:\n        \"\"\"Add pizza to order and recalculate total\"\"\"\n        self.pizzas.append(pizza)\n        self.calculate_total()\n\n        # Raise domain event\n        self.raise_event(PizzaAddedToOrderEvent(\n            order_id=self.id,\n            pizza_name=pizza.name,\n            new_total=self.total_amount\n        ))\n\n    def confirm_order(self) -&gt; None:\n        \"\"\"Confirm order after payment processing\"\"\"\n        if self.status != \"pending\":\n            raise InvalidOrderStateError(\"Order must be pending to confirm\")\n\n        self.status = \"confirmed\"\n        self.estimated_ready_time = self._calculate_ready_time()\n\n        # Raise domain event\n        self.raise_event(OrderConfirmedEvent(\n            order_id=self.id,\n            customer_name=self.customer_name,\n            estimated_ready_time=self.estimated_ready_time\n        ))\n\n    def start_cooking(self) -&gt; None:\n        \"\"\"Start cooking process\"\"\"\n        if self.status != \"confirmed\":\n            raise InvalidOrderStateError(\"Order must be confirmed to start cooking\")\n\n        self.status = \"cooking\"\n\n        # Raise domain event\n        self.raise_event(CookingStartedEvent(\n            order_id=self.id,\n            started_at=datetime.utcnow()\n        ))\n\n    def mark_ready(self) -&gt; None:\n        \"\"\"Mark order as ready for pickup/delivery\"\"\"\n        if self.status != \"cooking\":\n            raise InvalidOrderStateError(\"Order must be cooking to mark ready\")\n\n        self.status = \"ready\"\n\n        # Raise domain event\n        self.raise_event(OrderReadyEvent(\n            order_id=self.id,\n            customer_name=self.customer_name,\n            customer_phone=self.customer_phone\n        ))\n\n    def _calculate_ready_time(self) -&gt; datetime:\n        \"\"\"Calculate estimated ready time based on pizza complexity\"\"\"\n        total_cooking_time = sum(pizza.estimate_cooking_time() for pizza in self.pizzas)\n        return self.order_time + timedelta(minutes=total_cooking_time + 10)  # +10 for prep\n</code></pre>"},{"location":"mario-pizzeria/domain-design/#kitchen-entity","title":"Kitchen Entity","text":"<p>The Kitchen entity manages cooking capacity and workflow coordination:</p> <pre><code>@dataclass\nclass Kitchen(Entity[str]):\n    \"\"\"Kitchen state and cooking capacity management\"\"\"\n    id: str\n    active_orders: List[str]  # Order IDs being cooked\n    max_concurrent_orders: int = 3\n    staff_count: int = 2\n\n    @property\n    def is_at_capacity(self) -&gt; bool:\n        \"\"\"Check if kitchen is at maximum capacity\"\"\"\n        return len(self.active_orders) &gt;= self.max_concurrent_orders\n\n    @property\n    def current_capacity(self) -&gt; int:\n        \"\"\"Current number of orders being processed\"\"\"\n        return len(self.active_orders)\n\n    @property\n    def available_capacity(self) -&gt; int:\n        \"\"\"Remaining cooking slots available\"\"\"\n        return self.max_concurrent_orders - len(self.active_orders)\n\n    def start_order(self, order_id: str) -&gt; bool:\n        \"\"\"Start cooking an order if capacity allows\"\"\"\n        if self.is_at_capacity:\n            return False\n\n        self.active_orders.append(order_id)\n\n        # Raise domain event\n        self.raise_event(KitchenOrderStartedEvent(\n            kitchen_id=self.id,\n            order_id=order_id,\n            remaining_capacity=self.available_capacity\n        ))\n\n        return True\n\n    def complete_order(self, order_id: str) -&gt; None:\n        \"\"\"Complete cooking an order\"\"\"\n        if order_id not in self.active_orders:\n            raise OrderNotInKitchenError(f\"Order {order_id} not in kitchen\")\n\n        self.active_orders.remove(order_id)\n\n        # Raise domain event\n        self.raise_event(KitchenOrderCompletedEvent(\n            kitchen_id=self.id,\n            order_id=order_id,\n            available_capacity=self.available_capacity\n        ))\n\n    def adjust_capacity(self, new_max: int) -&gt; None:\n        \"\"\"Adjust maximum capacity based on staffing\"\"\"\n        if new_max &lt; len(self.active_orders):\n            raise CapacityError(\"Cannot reduce capacity below current active orders\")\n\n        old_capacity = self.max_concurrent_orders\n        self.max_concurrent_orders = new_max\n\n        # Raise domain event\n        self.raise_event(KitchenCapacityAdjustedEvent(\n            kitchen_id=self.id,\n            old_capacity=old_capacity,\n            new_capacity=new_max\n        ))\n</code></pre>"},{"location":"mario-pizzeria/domain-design/#value-objects","title":"\ud83d\udcca Value Objects","text":""},{"location":"mario-pizzeria/domain-design/#address-value-object","title":"Address Value Object","text":"<pre><code>@dataclass(frozen=True)\nclass Address:\n    \"\"\"Immutable address value object\"\"\"\n    street: str\n    city: str\n    zip_code: str\n    state: str = \"CA\"\n\n    def __str__(self) -&gt; str:\n        return f\"{self.street}, {self.city}, {self.state} {self.zip_code}\"\n\n    def is_valid(self) -&gt; bool:\n        \"\"\"Validate address format\"\"\"\n        return (\n            len(self.street) &gt; 0 and\n            len(self.city) &gt; 0 and\n            len(self.zip_code) == 5 and\n            self.zip_code.isdigit()\n        )\n</code></pre>"},{"location":"mario-pizzeria/domain-design/#money-value-object","title":"Money Value Object","text":"<pre><code>@dataclass(frozen=True)\nclass Money:\n    \"\"\"Immutable money value object\"\"\"\n    amount: Decimal\n    currency: str = \"USD\"\n\n    def __str__(self) -&gt; str:\n        return f\"${self.amount:.2f}\"\n\n    def add(self, other: 'Money') -&gt; 'Money':\n        \"\"\"Add two money amounts\"\"\"\n        if self.currency != other.currency:\n            raise ValueError(\"Cannot add different currencies\")\n        return Money(self.amount + other.amount, self.currency)\n\n    def multiply(self, factor: Decimal) -&gt; 'Money':\n        \"\"\"Multiply money by a factor\"\"\"\n        return Money(self.amount * factor, self.currency)\n\n    def is_positive(self) -&gt; bool:\n        \"\"\"Check if amount is positive\"\"\"\n        return self.amount &gt; 0\n</code></pre>"},{"location":"mario-pizzeria/domain-design/#domain-events","title":"\ud83d\udce1 Domain Events","text":"<p>Domain events capture important business occurrences and enable loose coupling:</p>"},{"location":"mario-pizzeria/domain-design/#order-lifecycle-events","title":"Order Lifecycle Events","text":"<pre><code>@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    \"\"\"Raised when customer places an order\"\"\"\n    order_id: str\n    customer_name: str\n    customer_phone: str\n    total_amount: Decimal\n    estimated_ready_time: datetime\n\n@dataclass\nclass OrderConfirmedEvent(DomainEvent):\n    \"\"\"Raised when order payment is processed\"\"\"\n    order_id: str\n    customer_name: str\n    estimated_ready_time: datetime\n\n@dataclass\nclass CookingStartedEvent(DomainEvent):\n    \"\"\"Raised when kitchen starts cooking order\"\"\"\n    order_id: str\n    started_at: datetime\n    estimated_completion: datetime\n\n@dataclass\nclass OrderReadyEvent(DomainEvent):\n    \"\"\"Raised when order is ready for pickup\"\"\"\n    order_id: str\n    customer_name: str\n    customer_phone: str\n    ready_at: datetime\n</code></pre>"},{"location":"mario-pizzeria/domain-design/#kitchen-events","title":"Kitchen Events","text":"<pre><code>@dataclass\nclass KitchenOrderStartedEvent(DomainEvent):\n    \"\"\"Raised when kitchen starts processing order\"\"\"\n    kitchen_id: str\n    order_id: str\n    remaining_capacity: int\n\n@dataclass\nclass KitchenCapacityAdjustedEvent(DomainEvent):\n    \"\"\"Raised when kitchen capacity changes\"\"\"\n    kitchen_id: str\n    old_capacity: int\n    new_capacity: int\n    reason: str\n</code></pre>"},{"location":"mario-pizzeria/domain-design/#domain-enums-value-objects","title":"\ud83d\udcca Domain Enums &amp; Value Objects","text":""},{"location":"mario-pizzeria/domain-design/#pizza-size-enumeration","title":"Pizza Size Enumeration","text":"<p>The pizza size enumeration defines the available size options with clear business values:</p> <p>Source: <code>samples/mario-pizzeria/domain/entities/enums.py</code></p> samples/mario-pizzeria/domain/entities/enums.py<pre><code>class PizzaSize(Enum):\n    \"\"\"Pizza size options\"\"\"\n\n    SMALL = \"small\"\n    MEDIUM = \"medium\"\n    LARGE = \"large\"\n</code></pre>"},{"location":"mario-pizzeria/domain-design/#order-status-enumeration","title":"Order Status Enumeration","text":"<p>The order status enumeration tracks the complete order lifecycle:</p> samples/mario-pizzeria/domain/entities/enums.py<pre><code>class OrderStatus(Enum):\n    \"\"\"Order lifecycle statuses\"\"\"\n\n    PENDING = \"pending\"\n    CONFIRMED = \"confirmed\"\n    COOKING = \"cooking\"\n    READY = \"ready\"\n    DELIVERED = \"delivered\"\n    CANCELLED = \"cancelled\"\n</code></pre> <p>Status Flow: <code>PENDING</code> \u2192 <code>CONFIRMED</code> \u2192 <code>COOKING</code> \u2192 <code>READY</code> \u2192 <code>DELIVERED</code></p> <p>Alternative flow: Any status \u2192 <code>CANCELLED</code> (with business rules)</p>"},{"location":"mario-pizzeria/domain-design/#business-rules-invariants","title":"\ud83c\udfaf Business Rules &amp; Invariants","text":""},{"location":"mario-pizzeria/domain-design/#order-rules","title":"Order Rules","text":"<ul> <li>Orders must have at least one pizza</li> <li>Total amount must be positive</li> <li>Status transitions must follow: pending \u2192 confirmed \u2192 cooking \u2192 ready \u2192 delivered</li> <li>Orders cannot be cancelled once cooking starts</li> </ul>"},{"location":"mario-pizzeria/domain-design/#kitchen-rules","title":"Kitchen Rules","text":"<ul> <li>Maximum concurrent orders based on staff capacity</li> <li>Orders processed in first-in-first-out order</li> <li>Capacity adjustments cannot go below current active orders</li> </ul>"},{"location":"mario-pizzeria/domain-design/#pizza-rules","title":"Pizza Rules","text":"<ul> <li>Maximum 10 toppings per pizza</li> <li>All toppings must be from approved list</li> <li>Pricing must include all applicable taxes and fees</li> </ul>"},{"location":"mario-pizzeria/domain-design/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Business Analysis - Requirements and stakeholder analysis</li> <li>Technical Architecture - System design and infrastructure</li> <li>Implementation Guide - Development patterns and APIs</li> <li>Testing &amp; Deployment - Quality assurance and operations</li> </ul> <p>This domain model provides a solid foundation for implementing Mario's Pizzeria using Domain-Driven Design principles, ensuring the code reflects the actual business operations.</p>"},{"location":"mario-pizzeria/implementation-guide/","title":"\ud83d\ude80 Mario's Pizzeria: Implementation Guide","text":"<p>Development Guide | Patterns: CQRS, Event Sourcing, OAuth 2.0 Framework: Neuroglia + FastAPI | Status: Production Examples</p>"},{"location":"mario-pizzeria/implementation-guide/#implementation-overview","title":"\ud83c\udfaf Implementation Overview","text":"<p>This guide provides comprehensive implementation details for building Mario's Pizzeria using the Neuroglia framework. It covers CQRS patterns, event-driven workflows, authentication, and practical code examples ready for production use.</p> <p>Key Implementation Patterns:</p> <ul> <li>CQRS Commands &amp; Queries: Separate read and write operations</li> <li>Event-Driven Architecture: Asynchronous business workflow processing</li> <li>OAuth 2.0 Security: Role-based access control with JWT tokens</li> <li>Data Transfer Objects: Clean API contracts and validation</li> </ul>"},{"location":"mario-pizzeria/implementation-guide/#cqrs-commands-and-queries","title":"\ud83c\udfaf CQRS Commands and Queries","text":"<p>The system uses CQRS pattern with clear separation between write and read operations:</p>"},{"location":"mario-pizzeria/implementation-guide/#commands-write-operations","title":"Commands (Write Operations)","text":"<p>Commands represent business intentions and return operation results:</p> <pre><code>@dataclass\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Command to place a new pizza order\"\"\"\n    customer_name: str\n    customer_phone: str\n    customer_address: str\n    pizzas: List[PizzaOrderDto]\n    payment_method: str\n    special_instructions: Optional[str] = None\n\n    def validate(self) -&gt; List[str]:\n        errors = []\n        if not self.customer_name.strip():\n            errors.append(\"Customer name is required\")\n        if not self.customer_phone.strip():\n            errors.append(\"Customer phone is required\")\n        if not self.pizzas:\n            errors.append(\"At least one pizza is required\")\n        return errors\n\n@dataclass\nclass StartCookingCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Command to start cooking an order\"\"\"\n    order_id: str\n    kitchen_staff_id: str\n    estimated_cooking_time: Optional[int] = None\n\n@dataclass\nclass CompleteOrderCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Command to mark order as ready\"\"\"\n    order_id: str\n    completion_time: Optional[datetime] = None\n    quality_notes: Optional[str] = None\n\n@dataclass\nclass UpdateMenuCommand(Command[OperationResult[PizzaDto]]):\n    \"\"\"Command to update menu item\"\"\"\n    pizza_id: str\n    name: Optional[str] = None\n    base_price: Optional[Decimal] = None\n    available: Optional[bool] = None\n</code></pre>"},{"location":"mario-pizzeria/implementation-guide/#queries-read-operations","title":"Queries (Read Operations)","text":"<p>Queries retrieve data without side effects:</p> <pre><code>@dataclass\nclass GetOrderByIdQuery(Query[Optional[OrderDto]]):\n    \"\"\"Query to get specific order details\"\"\"\n    order_id: str\n\n@dataclass\nclass GetOrdersByCustomerQuery(Query[List[OrderDto]]):\n    \"\"\"Query to get customer's order history\"\"\"\n    customer_phone: str\n    limit: int = 10\n    status_filter: Optional[str] = None\n\n@dataclass\nclass GetMenuQuery(Query[List[PizzaDto]]):\n    \"\"\"Query to get available menu items\"\"\"\n    category: Optional[str] = None\n    available_only: bool = True\n\n@dataclass\nclass GetKitchenStatusQuery(Query[KitchenStatusDto]):\n    \"\"\"Query to get current kitchen status\"\"\"\n    pass\n\n@dataclass\nclass GetActiveOrdersQuery(Query[List[OrderDto]]):\n    \"\"\"Query to get orders currently being prepared\"\"\"\n    pass\n\n@dataclass\nclass GetOrderAnalyticsQuery(Query[OrderAnalyticsDto]):\n    \"\"\"Query to get business analytics\"\"\"\n    start_date: datetime\n    end_date: datetime\n    group_by: str = \"day\"  # day, week, month\n</code></pre>"},{"location":"mario-pizzeria/implementation-guide/#command-handlers","title":"Command Handlers","text":"<p>Command handlers implement business logic and coordinate with domain entities:</p> <pre><code>class PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    \"\"\"Handler for placing new orders\"\"\"\n\n    def __init__(self,\n                 order_repository: OrderRepository,\n                 payment_service: PaymentService,\n                 kitchen_repository: KitchenRepository,\n                 mapper: Mapper):\n        self.order_repository = order_repository\n        self.payment_service = payment_service\n        self.kitchen_repository = kitchen_repository\n        self.mapper = mapper\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        try:\n            # Validate command\n            validation_errors = command.validate()\n            if validation_errors:\n                return self.bad_request(\"; \".join(validation_errors))\n\n            # Check kitchen capacity\n            kitchen = await self.kitchen_repository.get_default_kitchen()\n            if kitchen.is_at_capacity:\n                return self.bad_request(\"Kitchen is at capacity. Please try again later.\")\n\n            # Create order entity\n            order = Order(\n                id=str(uuid.uuid4()),\n                customer_name=command.customer_name,\n                customer_phone=command.customer_phone,\n                pizzas=self.mapper.map_list(command.pizzas, Pizza),\n                status=\"pending\",\n                order_time=datetime.utcnow()\n            )\n\n            # Process payment\n            payment_result = await self.payment_service.process_payment_async(\n                amount=order.total_amount,\n                payment_method=command.payment_method\n            )\n\n            if not payment_result.success:\n                return self.bad_request(f\"Payment failed: {payment_result.error_message}\")\n\n            # Confirm order\n            order.confirm_order()\n\n            # Save order\n            await self.order_repository.save_async(order)\n\n            # Return success result\n            order_dto = self.mapper.map(order, OrderDto)\n            return self.created(order_dto)\n\n        except Exception as ex:\n            return self.internal_server_error(f\"Failed to place order: {str(ex)}\")\n</code></pre>"},{"location":"mario-pizzeria/implementation-guide/#event-driven-workflow","title":"\ud83d\udce1 Event-Driven Workflow","text":"<p>The system uses domain events to handle complex business workflows:</p> <pre><code>flowchart TD\n    A[Customer Places Order] --&gt; B[OrderPlacedEvent]\n    B --&gt; C[Kitchen Queue Updated]\n    B --&gt; D[Payment Processed]\n\n    C --&gt; E[Staff Views Kitchen Queue]\n    E --&gt; F[Staff Starts Cooking]\n    F --&gt; G[OrderCookingEvent]\n\n    G --&gt; H[Update Order Status]\n    G --&gt; I[Start Preparation Timer]\n\n    I --&gt; J[Order Completed]\n    J --&gt; K[OrderReadyEvent]\n\n    K --&gt; L[SMS Notification Sent]\n    K --&gt; M[Kitchen Capacity Freed]\n\n    L --&gt; N[Customer Notified]\n    M --&gt; O[Next Order Can Start]\n\n    style A fill:#FFE0B2\n    style B fill:#E1F5FE\n    style G fill:#E1F5FE\n    style K fill:#E1F5FE\n    style N fill:#C8E6C9</code></pre>"},{"location":"mario-pizzeria/implementation-guide/#event-handlers","title":"Event Handlers","text":"<p>Event handlers process domain events asynchronously:</p> <pre><code>class OrderPlacedEventHandler(EventHandler[OrderPlacedEvent]):\n    \"\"\"Handle order placed events\"\"\"\n\n    def __init__(self,\n                 kitchen_service: KitchenService,\n                 notification_service: NotificationService):\n        self.kitchen_service = kitchen_service\n        self.notification_service = notification_service\n\n    async def handle_async(self, event: OrderPlacedEvent) -&gt; None:\n        # Add order to kitchen queue\n        await self.kitchen_service.add_to_queue_async(event.order_id)\n\n        # Send confirmation to customer\n        await self.notification_service.send_order_confirmation_async(\n            phone=event.customer_phone,\n            order_id=event.order_id,\n            estimated_ready_time=event.estimated_ready_time\n        )\n\nclass OrderReadyEventHandler(EventHandler[OrderReadyEvent]):\n    \"\"\"Handle order ready events\"\"\"\n\n    def __init__(self,\n                 sms_service: SMSService,\n                 kitchen_repository: KitchenRepository):\n        self.sms_service = sms_service\n        self.kitchen_repository = kitchen_repository\n\n    async def handle_async(self, event: OrderReadyEvent) -&gt; None:\n        # Send SMS notification\n        message = f\"Hi {event.customer_name}! Your order #{event.order_id} is ready for pickup!\"\n        await self.sms_service.send_sms_async(event.customer_phone, message)\n\n        # Free up kitchen capacity\n        kitchen = await self.kitchen_repository.get_default_kitchen()\n        kitchen.complete_order(event.order_id)\n        await self.kitchen_repository.save_async(kitchen)\n</code></pre>"},{"location":"mario-pizzeria/implementation-guide/#key-domain-events","title":"Key Domain Events","text":"<pre><code>@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    \"\"\"Raised when customer places an order\"\"\"\n    order_id: str\n    customer_name: str\n    customer_phone: str\n    total_amount: Decimal\n    estimated_ready_time: datetime\n\n@dataclass\nclass OrderConfirmedEvent(DomainEvent):\n    \"\"\"Raised when payment is processed successfully\"\"\"\n    order_id: str\n    customer_name: str\n    estimated_ready_time: datetime\n    payment_method: str\n\n@dataclass\nclass CookingStartedEvent(DomainEvent):\n    \"\"\"Raised when kitchen starts cooking\"\"\"\n    order_id: str\n    started_at: datetime\n    kitchen_staff_id: str\n\n@dataclass\nclass OrderReadyEvent(DomainEvent):\n    \"\"\"Raised when order is ready for pickup\"\"\"\n    order_id: str\n    customer_name: str\n    customer_phone: str\n    ready_at: datetime\n\n@dataclass\nclass OrderDeliveredEvent(DomainEvent):\n    \"\"\"Raised when order is picked up or delivered\"\"\"\n    order_id: str\n    delivered_at: datetime\n    delivery_method: str  # \"pickup\" or \"delivery\"\n</code></pre>"},{"location":"mario-pizzeria/implementation-guide/#data-transfer-objects-dtos","title":"\ud83d\udccb Data Transfer Objects (DTOs)","text":"<p>DTOs provide clean API contracts with validation:</p>"},{"location":"mario-pizzeria/implementation-guide/#request-dtos","title":"Request DTOs","text":"<pre><code>@dataclass\nclass CreateOrderDto:\n    \"\"\"DTO for creating new orders\"\"\"\n    customer_name: str\n    customer_phone: str\n    pizzas: List[PizzaOrderItem]\n    delivery_address: Optional[AddressDto] = None\n    special_instructions: Optional[str] = None\n    payment_method: str = \"credit_card\"\n\n    def __post_init__(self):\n        if not self.customer_name.strip():\n            raise ValueError(\"Customer name is required\")\n        if not self.pizzas:\n            raise ValueError(\"At least one pizza is required\")\n\n@dataclass\nclass PizzaOrderItem:\n    \"\"\"DTO for pizza items in orders\"\"\"\n    pizza_id: str\n    size: str  # \"small\", \"medium\", \"large\"\n    toppings: List[str] = field(default_factory=list)\n    quantity: int = 1\n\n    def __post_init__(self):\n        if self.quantity &lt; 1:\n            raise ValueError(\"Quantity must be at least 1\")\n        if len(self.toppings) &gt; 10:\n            raise ValueError(\"Maximum 10 toppings per pizza\")\n</code></pre>"},{"location":"mario-pizzeria/implementation-guide/#response-dtos","title":"Response DTOs","text":"<pre><code>@dataclass\nclass OrderDto:\n    \"\"\"DTO for order responses\"\"\"\n    id: str\n    customer_name: str\n    customer_phone: str\n    pizzas: List[PizzaDto]\n    status: str\n    total_amount: str  # Formatted money\n    order_time: str   # ISO datetime\n    estimated_ready_time: Optional[str] = None\n    special_instructions: Optional[str] = None\n\n@dataclass\nclass PizzaDto:\n    \"\"\"DTO for pizza responses\"\"\"\n    id: str\n    name: str\n    size: str\n    toppings: List[str]\n    price: str  # Formatted money\n    estimated_cooking_time: int\n\n@dataclass\nclass KitchenStatusDto:\n    \"\"\"DTO for kitchen status\"\"\"\n    current_capacity: int\n    max_concurrent_orders: int\n    active_orders: List[OrderSummaryDto]\n    is_at_capacity: bool\n    average_cooking_time: int\n\n@dataclass\nclass OrderAnalyticsDto:\n    \"\"\"DTO for business analytics\"\"\"\n    total_orders: int\n    total_revenue: str\n    average_order_value: str\n    popular_pizzas: List[PizzaPopularityDto]\n    peak_hours: List[HourlyStatsDto]\n</code></pre>"},{"location":"mario-pizzeria/implementation-guide/#authentication-authorization","title":"\ud83d\udd10 Authentication &amp; Authorization","text":"<p>Mario's Pizzeria demonstrates secure authentication using OAuth 2.0, OpenID Connect, and JWT tokens:</p>"},{"location":"mario-pizzeria/implementation-guide/#oauth-scopes","title":"OAuth Scopes","text":"<pre><code>SCOPES = {\n    \"orders:read\": \"Read order information\",\n    \"orders:write\": \"Create and modify orders\",\n    \"kitchen:read\": \"View kitchen status\",\n    \"kitchen:manage\": \"Manage kitchen operations\",\n    \"menu:read\": \"View menu items\",\n    \"menu:write\": \"Modify menu items\",\n    \"reports:read\": \"View business reports\",\n    \"admin\": \"Full administrative access\"\n}\n</code></pre>"},{"location":"mario-pizzeria/implementation-guide/#controller-security","title":"Controller Security","text":"<pre><code>from neuroglia.mvc import ControllerBase\nfrom fastapi import Depends, HTTPException\nfrom neuroglia.security import require_scope\n\nclass OrdersController(ControllerBase):\n\n    @get(\"/\", response_model=List[OrderDto])\n    @require_scope(\"orders:read\")\n    async def get_orders(self,\n                        current_user: dict = Depends(get_current_user),\n                        status: Optional[str] = None) -&gt; List[OrderDto]:\n        \"\"\"Get orders - requires orders:read scope\"\"\"\n\n        # Customer can only see their own orders\n        if \"customer\" in current_user.get(\"roles\", []):\n            query = GetOrdersByCustomerQuery(\n                customer_phone=current_user.get(\"phone\"),\n                status_filter=status\n            )\n        else:\n            # Staff can see all orders\n            query = GetAllOrdersQuery(status_filter=status)\n\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @post(\"/\", response_model=OrderDto, status_code=201)\n    @require_scope(\"orders:write\")\n    async def create_order(self,\n                          create_order_dto: CreateOrderDto,\n                          current_user: dict = Depends(get_current_user)) -&gt; OrderDto:\n        \"\"\"Create new order - requires orders:write scope\"\"\"\n\n        command = self.mapper.map(create_order_dto, PlaceOrderCommand)\n\n        # Add user context\n        command.customer_phone = current_user.get(\"phone\", command.customer_phone)\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"mario-pizzeria/implementation-guide/#user-roles-permissions","title":"User Roles &amp; Permissions","text":"Role Scopes Permissions \ud83d\udc64 Customer <code>orders:read</code>, <code>orders:write</code>, <code>menu:read</code> Place orders, view own orders, browse menu \ud83d\udc68\u200d\ud83c\udf73 Kitchen Staff <code>kitchen:read</code>, <code>kitchen:manage</code>, <code>orders:read</code> Manage cooking queue, view all orders \ud83d\udc68\u200d\ud83d\udcbc Manager All kitchen scopes + <code>menu:write</code>, <code>reports:read</code> Full operational control \ud83d\udd27 Admin <code>admin</code> Complete system access"},{"location":"mario-pizzeria/implementation-guide/#complete-authentication-guide","title":"\ud83d\udcd6 Complete Authentication Guide","text":"<p>For comprehensive OAuth 2.0, OpenID Connect, and JWT implementation details:</p> <p>\ud83d\udc49 Read the Complete OAuth/OIDC/JWT Reference</p> <p>This includes:</p> <ul> <li>\ud83c\udfaf OAuth 2.0 Flow Diagrams</li> <li>\ud83d\udd0d JWT Validation Process</li> <li>\ud83c\udfd7\ufe0f Keycloak Integration</li> <li>\ud83c\udfad Role-Based Access Control</li> <li>\ud83e\uddea Authentication Testing</li> <li>\ud83d\udccb Security Best Practices</li> </ul>"},{"location":"mario-pizzeria/implementation-guide/#api-integration-examples","title":"\ud83c\udfa8 API Integration Examples","text":""},{"location":"mario-pizzeria/implementation-guide/#javascript-client","title":"JavaScript Client","text":"<pre><code>class PizzeriaClient {\n  constructor(baseUrl, accessToken) {\n    this.baseUrl = baseUrl;\n    this.accessToken = accessToken;\n  }\n\n  async placeOrder(orderData) {\n    const response = await fetch(`${this.baseUrl}/orders`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${this.accessToken}`,\n      },\n      body: JSON.stringify(orderData),\n    });\n\n    if (!response.ok) {\n      throw new Error(`Order failed: ${response.statusText}`);\n    }\n\n    return await response.json();\n  }\n\n  async getOrderStatus(orderId) {\n    const response = await fetch(`${this.baseUrl}/orders/${orderId}`, {\n      headers: {\n        Authorization: `Bearer ${this.accessToken}`,\n      },\n    });\n\n    return await response.json();\n  }\n}\n</code></pre>"},{"location":"mario-pizzeria/implementation-guide/#python-client","title":"Python Client","text":"<pre><code>import httpx\nfrom typing import Dict, List, Optional\n\nclass PizzeriaClient:\n    def __init__(self, base_url: str, access_token: str):\n        self.base_url = base_url\n        self.headers = {\"Authorization\": f\"Bearer {access_token}\"}\n\n    async def place_order(self, order_data: Dict) -&gt; Dict:\n        async with httpx.AsyncClient() as client:\n            response = await client.post(\n                f\"{self.base_url}/orders\",\n                json=order_data,\n                headers=self.headers\n            )\n            response.raise_for_status()\n            return response.json()\n\n    async def get_menu(self) -&gt; List[Dict]:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                f\"{self.base_url}/menu/pizzas\",\n                headers=self.headers\n            )\n            return response.json()\n</code></pre>"},{"location":"mario-pizzeria/implementation-guide/#implementation-benefits","title":"\ud83d\ude80 Implementation Benefits","text":"<ul> <li>\ud83c\udfaf Clean Separation: CQRS provides clear read/write boundaries</li> <li>\u26a1 Event-Driven: Loose coupling and scalable async processing</li> <li>\ud83d\udd12 Secure: OAuth 2.0 with fine-grained access control</li> <li>\ud83d\udccb Type-Safe: Strong typing with DTOs and validation</li> <li>\ud83e\uddea Testable: Mockable dependencies and clear interfaces</li> <li>\ud83d\udcca Observable: Built-in logging and monitoring capabilities</li> <li>\ud83d\udd04 Maintainable: Framework patterns ensure consistency</li> </ul>"},{"location":"mario-pizzeria/implementation-guide/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Business Analysis - Requirements and stakeholder analysis</li> <li>Technical Architecture - System design and infrastructure</li> <li>Domain Design - Business logic and data models</li> <li>Testing &amp; Deployment - Quality assurance and operations</li> </ul> <p>This implementation guide provides production-ready patterns for building scalable, secure, and maintainable applications using the Neuroglia framework.</p>"},{"location":"mario-pizzeria/technical-architecture/","title":"\ud83c\udfd7\ufe0f Mario's Pizzeria: Technical Architecture","text":"<p>System Design Document &gt; Architecture: Clean Architecture + CQRS + Event Sourcing Technology Stack: FastAPI, Python, MongoDB, OAuth 2.0 Status: Production Ready</p>"},{"location":"mario-pizzeria/technical-architecture/#architecture-overview","title":"\ud83d\udccb Architecture Overview","text":"<p>Mario's Pizzeria implements a modern, scalable architecture following clean architecture principles with CQRS (Command Query Responsibility Segregation) and event-driven patterns. This design ensures maintainability, testability, and scalability for a growing restaurant business.</p> <p>Key Architectural Decisions:</p> <ul> <li>Clean Architecture: Clear separation of concerns across four distinct layers</li> <li>CQRS Pattern: Separate models for read and write operations</li> <li>Event-Driven Design: Asynchronous processing and loose coupling</li> <li>Repository Pattern: Abstracted data access with multiple storage options</li> <li>Dependency Injection: Testable and maintainable service management</li> </ul>"},{"location":"mario-pizzeria/technical-architecture/#clean-architecture-layers","title":"\ud83c\udfdb\ufe0f Clean Architecture Layers","text":"<p>Mario's Pizzeria demonstrates the four-layer clean architecture:</p> <pre><code>graph TB\n    %% API Layer\n    subgraph APILayer[\"\ud83c\udf10 API Layer\"]\n        OrdersController[\"\ud83d\udccb OrdersController&lt;br/&gt;FastAPI&lt;br/&gt;Order management endpoints\"]\n        MenuController[\"\ud83c\udf55 MenuController&lt;br/&gt;FastAPI&lt;br/&gt;Menu browsing endpoints\"]\n        KitchenController[\"\ud83d\udc68\u200d\ud83c\udf73 KitchenController&lt;br/&gt;FastAPI&lt;br/&gt;Kitchen status endpoints\"]\n        DTOs[\"\ud83d\udcc4 DTOs&lt;br/&gt;Pydantic&lt;br/&gt;Request/Response models\"]\n    end\n\n    %% Application Layer\n    subgraph AppLayer[\"\ud83d\udcbc Application Layer\"]\n        Mediator[\"\ud83c\udfaf Mediator&lt;br/&gt;CQRS&lt;br/&gt;Command/Query dispatcher\"]\n        PlaceOrderHandler[\"\ud83d\udcdd PlaceOrderHandler&lt;br/&gt;Command Handler&lt;br/&gt;Order placement logic\"]\n        GetMenuHandler[\"\ud83d\udcd6 GetMenuHandler&lt;br/&gt;Query Handler&lt;br/&gt;Menu retrieval logic\"]\n        KitchenHandlers[\"\u26a1 KitchenHandlers&lt;br/&gt;Event Handlers&lt;br/&gt;Kitchen workflow\"]\n    end\n\n    %% Domain Layer\n    subgraph DomainLayer[\"\ud83c\udfdb\ufe0f Domain Layer\"]\n        OrderEntity[\"\ud83d\udccb Order&lt;br/&gt;Entity&lt;br/&gt;Order business logic\"]\n        PizzaEntity[\"\ud83c\udf55 Pizza&lt;br/&gt;Entity&lt;br/&gt;Pizza with pricing\"]\n        CustomerEntity[\"\ud83d\udc64 Customer&lt;br/&gt;Entity&lt;br/&gt;Customer information\"]\n        KitchenEntity[\"\ud83c\udfe0 Kitchen&lt;br/&gt;Entity&lt;br/&gt;Kitchen capacity\"]\n        DomainEvents[\"\u26a1 Domain Events&lt;br/&gt;Events&lt;br/&gt;OrderPlaced, OrderReady\"]\n    end\n\n    %% Integration Layer\n    subgraph IntegrationLayer[\"\ud83d\udd0c Integration Layer\"]\n        OrderRepo[\"\ud83d\udcbe OrderRepository&lt;br/&gt;File/Mongo&lt;br/&gt;Order persistence\"]\n        PaymentService[\"\ud83d\udcb3 PaymentService&lt;br/&gt;External API&lt;br/&gt;Payment processing\"]\n        SMSService[\"\ud83d\udcf1 SMSService&lt;br/&gt;External API&lt;br/&gt;Customer notifications\"]\n    end\n\n    %% API to Application connections\n    OrdersController --&gt;|Sends commands/queries| Mediator\n    MenuController --&gt;|Sends queries| Mediator\n    KitchenController --&gt;|Sends queries| Mediator\n\n    %% Application Layer connections\n    Mediator --&gt;|Routes PlaceOrderCommand| PlaceOrderHandler\n    Mediator --&gt;|Routes GetMenuQuery| GetMenuHandler\n    Mediator --&gt;|Routes events| KitchenHandlers\n\n    %% Application to Domain connections\n    PlaceOrderHandler --&gt;|Creates/manipulates| OrderEntity\n    GetMenuHandler --&gt;|Reads menu data| PizzaEntity\n\n    %% Application to Integration connections\n    PlaceOrderHandler --&gt;|Persists orders| OrderRepo\n    PlaceOrderHandler --&gt;|Processes payments| PaymentService\n    KitchenHandlers --&gt;|Sends notifications| SMSService\n\n    %% Styling\n    classDef apiLayer fill:#E3F2FD,stroke:#1976D2,stroke-width:2px\n    classDef appLayer fill:#F3E5F5,stroke:#7B1FA2,stroke-width:2px\n    classDef domainLayer fill:#E8F5E8,stroke:#388E3C,stroke-width:2px\n    classDef integrationLayer fill:#FFF3E0,stroke:#F57C00,stroke-width:2px\n\n    class OrdersController,MenuController,KitchenController,DTOs apiLayer\n    class Mediator,PlaceOrderHandler,GetMenuHandler,KitchenHandlers appLayer\n    class OrderEntity,PizzaEntity,CustomerEntity,KitchenEntity,DomainEvents domainLayer\n    class OrderRepo,PaymentService,SMSService integrationLayer</code></pre>"},{"location":"mario-pizzeria/technical-architecture/#data-storage-strategy","title":"\ud83d\uddc4\ufe0f Data Storage Strategy","text":"<p>Mario's Pizzeria demonstrates multiple persistence approaches to support different deployment scenarios:</p>"},{"location":"mario-pizzeria/technical-architecture/#file-based-storage-development","title":"File-Based Storage (Development)","text":"<p>Perfect for development and testing environments with simple JSON persistence:</p> <pre><code>pizzeria_data/\n\u251c\u2500\u2500 orders/\n\u2502   \u251c\u2500\u2500 2024-09-22/           # Orders by date\n\u2502   \u2502   \u251c\u2500\u2500 order_001.json\n\u2502   \u2502   \u251c\u2500\u2500 order_002.json\n\u2502   \u2502   \u2514\u2500\u2500 order_003.json\n\u2502   \u2514\u2500\u2500 index.json            # Order index\n\u251c\u2500\u2500 menu/\n\u2502   \u2514\u2500\u2500 pizzas.json           # Available pizzas\n\u251c\u2500\u2500 kitchen/\n\u2502   \u2514\u2500\u2500 status.json           # Kitchen state\n\u2514\u2500\u2500 customers/\n    \u2514\u2500\u2500 customers.json        # Customer history\n</code></pre> <p>Benefits: Zero configuration, version control friendly, fast local development</p>"},{"location":"mario-pizzeria/technical-architecture/#mongodb-storage-production","title":"MongoDB Storage (Production)","text":"<p>Scalable document database for production workloads:</p> <pre><code>// Orders Collection\n{\n  \"_id\": \"order_001\",\n  \"customer_name\": \"Mario Rossi\",\n  \"customer_phone\": \"+1-555-0123\",\n  \"pizzas\": [\n    {\n      \"name\": \"Margherita\",\n      \"size\": \"large\",\n      \"toppings\": [\"extra cheese\"],\n      \"price\": 15.99\n    }\n  ],\n  \"total_amount\": 15.99,\n  \"status\": \"ready\",\n  \"order_time\": \"2025-09-25T10:30:00Z\"\n}\n</code></pre> <p>Benefits: Horizontal scaling, rich queries, built-in replication, ACID transactions</p>"},{"location":"mario-pizzeria/technical-architecture/#event-sourcing-advanced","title":"Event Sourcing (Advanced)","text":"<p>Complete audit trail and temporal queries using event streams:</p> <pre><code>Event Store:\n\u251c\u2500\u2500 order_001_stream\n\u2502   \u251c\u2500\u2500 OrderPlacedEvent\n\u2502   \u251c\u2500\u2500 PaymentProcessedEvent\n\u2502   \u251c\u2500\u2500 OrderConfirmedEvent\n\u2502   \u251c\u2500\u2500 CookingStartedEvent\n\u2502   \u2514\u2500\u2500 OrderReadyEvent\n</code></pre> <p>Benefits: Complete audit trail, temporal queries, replay capability, debugging</p>"},{"location":"mario-pizzeria/technical-architecture/#api-endpoints","title":"\ud83c\udf10 API Endpoints","text":"<p>Complete RESTful API designed for different client types (web, mobile, POS systems):</p>"},{"location":"mario-pizzeria/technical-architecture/#order-management","title":"Order Management","text":"Method Endpoint Description Auth Required <code>POST</code> <code>/orders</code> Place new pizza order Customer <code>GET</code> <code>/orders</code> List orders (with status filter) Staff <code>GET</code> <code>/orders/{id}</code> Get specific order details Owner/Customer <code>PUT</code> <code>/orders/{id}/status</code> Update order status Kitchen <code>DELETE</code> <code>/orders/{id}</code> Cancel order Customer/Manager"},{"location":"mario-pizzeria/technical-architecture/#menu-operations","title":"Menu Operations","text":"Method Endpoint Description Auth Required <code>GET</code> <code>/menu/pizzas</code> Get available pizzas Public <code>GET</code> <code>/menu/pizzas/{id}</code> Get pizza details Public <code>GET</code> <code>/menu/toppings</code> Get available toppings Public"},{"location":"mario-pizzeria/technical-architecture/#kitchen-management","title":"Kitchen Management","text":"Method Endpoint Description Auth Required <code>GET</code> <code>/kitchen/status</code> Get kitchen capacity status Staff <code>GET</code> <code>/kitchen/queue</code> Get current cooking queue Kitchen <code>POST</code> <code>/kitchen/orders/{id}/start</code> Start cooking order Kitchen <code>POST</code> <code>/kitchen/orders/{id}/complete</code> Complete order Kitchen"},{"location":"mario-pizzeria/technical-architecture/#security-architecture","title":"\ud83d\udd10 Security Architecture","text":""},{"location":"mario-pizzeria/technical-architecture/#oauth-20-scopes","title":"OAuth 2.0 Scopes","text":"<p>Fine-grained access control using OAuth2 scopes:</p> <pre><code>SCOPES = {\n    \"orders:read\": \"Read order information\",\n    \"orders:write\": \"Create and modify orders\",\n    \"kitchen:read\": \"View kitchen status\",\n    \"kitchen:manage\": \"Manage kitchen operations\",\n    \"menu:read\": \"View menu items\",\n    \"admin\": \"Full administrative access\"\n}\n</code></pre>"},{"location":"mario-pizzeria/technical-architecture/#role-based-access-control","title":"Role-Based Access Control","text":"Role Scopes Permissions Customer <code>orders:write</code>, <code>menu:read</code> Place orders, view menu Kitchen Staff <code>kitchen:manage</code>, <code>orders:read</code> Manage cooking queue Manager <code>admin</code> Full system access Public <code>menu:read</code> Browse menu only"},{"location":"mario-pizzeria/technical-architecture/#scalability-considerations","title":"\ud83d\ude80 Scalability Considerations","text":""},{"location":"mario-pizzeria/technical-architecture/#horizontal-scaling","title":"Horizontal Scaling","text":"<ul> <li>API Layer: Stateless controllers scale horizontally behind load balancer</li> <li>Application Layer: Event handlers can be distributed across multiple instances</li> <li>Database Layer: MongoDB supports sharding and replica sets</li> <li>External Services: Circuit breakers prevent cascade failures</li> </ul>"},{"location":"mario-pizzeria/technical-architecture/#performance-optimizations","title":"Performance Optimizations","text":"<ul> <li>Caching: Redis for frequently accessed menu items and customer data</li> <li>Background Processing: Async event handling for notifications and reporting</li> <li>Database Indexing: Optimized queries for order status and customer lookups</li> <li>CDN: Static assets (images, CSS) served from edge locations</li> </ul>"},{"location":"mario-pizzeria/technical-architecture/#monitoring-observability","title":"Monitoring &amp; Observability","text":"<ul> <li>Health Checks: Endpoint monitoring for all critical services</li> <li>Metrics: Custom business metrics (orders/hour, kitchen efficiency)</li> <li>Logging: Structured logging with correlation IDs</li> <li>Tracing: Distributed tracing for request flows</li> </ul>"},{"location":"mario-pizzeria/technical-architecture/#infrastructure-requirements","title":"\ud83d\udd27 Infrastructure Requirements","text":""},{"location":"mario-pizzeria/technical-architecture/#development-environment","title":"Development Environment","text":"<ul> <li>Python: 3.9+ with FastAPI and Neuroglia framework</li> <li>Storage: Local JSON files for rapid development</li> <li>Authentication: Development OAuth server (Keycloak)</li> </ul>"},{"location":"mario-pizzeria/technical-architecture/#production-environment","title":"Production Environment","text":"<ul> <li>Compute: 2+ CPU cores, 4GB RAM minimum per instance</li> <li>Database: MongoDB cluster with replica sets</li> <li>Caching: Redis cluster for session and menu caching</li> <li>Load Balancer: NGINX or cloud load balancer</li> <li>Authentication: Production OAuth provider (Auth0, Keycloak)</li> </ul>"},{"location":"mario-pizzeria/technical-architecture/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Business Analysis - Requirements and stakeholder analysis</li> <li>Domain Design - Business logic and data models</li> <li>Implementation Guide - Development patterns and APIs</li> <li>Testing &amp; Deployment - Quality assurance and operations</li> </ul> <p>This technical architecture ensures Mario's Pizzeria can scale from a single location to a multi-restaurant franchise while maintaining code quality and operational excellence.</p>"},{"location":"mario-pizzeria/testing-deployment/","title":"\ud83e\uddea Mario's Pizzeria: Testing &amp; Deployment","text":"<p>Quality Assurance Guide | Testing Strategy: Unit, Integration, E2E Deployment: Docker, CI/CD, Production Monitoring | Status: Production Ready</p>"},{"location":"mario-pizzeria/testing-deployment/#testing-overview","title":"\ud83c\udfaf Testing Overview","text":"<p>Mario's Pizzeria demonstrates comprehensive testing strategies across all application layers. The testing approach ensures reliability, maintainability, and confidence in production deployments.</p> <p>Testing Pyramid:</p> <ul> <li>Unit Tests (70%): Fast, isolated tests for business logic</li> <li>Integration Tests (20%): API endpoints and data access layer testing</li> <li>End-to-End Tests (10%): Complete workflow validation</li> </ul>"},{"location":"mario-pizzeria/testing-deployment/#unit-testing-strategy","title":"\ud83e\uddea Unit Testing Strategy","text":"<p>Unit tests focus on individual components in isolation with comprehensive mocking:</p>"},{"location":"mario-pizzeria/testing-deployment/#domain-entity-testing","title":"Domain Entity Testing","text":"<pre><code>import pytest\nfrom decimal import Decimal\nfrom datetime import datetime\nfrom mario_pizzeria.domain.entities import Order, Pizza, Kitchen\nfrom mario_pizzeria.domain.enums import OrderStatus, PizzaSize\n\nclass TestOrderEntity:\n    \"\"\"Test Order domain entity business logic\"\"\"\n\n    def test_order_creation_with_defaults(self):\n        \"\"\"Test order creation with default values\"\"\"\n        order = Order(\n            id=\"order_001\",\n            customer_name=\"Mario Rossi\",\n            customer_phone=\"+1-555-0123\",\n            pizzas=[],\n            status=\"pending\",\n            order_time=datetime.utcnow()\n        )\n\n        assert order.id == \"order_001\"\n        assert order.status == \"pending\"\n        assert order.total_amount == Decimal('0.00')\n        assert len(order.pizzas) == 0\n\n    def test_add_pizza_to_order(self):\n        \"\"\"Test adding pizza updates total amount\"\"\"\n        order = Order(\n            id=\"order_001\",\n            customer_name=\"Mario Rossi\",\n            customer_phone=\"+1-555-0123\",\n            pizzas=[],\n            status=\"pending\",\n            order_time=datetime.utcnow()\n        )\n\n        pizza = Pizza(\n            id=\"pizza_001\",\n            name=\"Margherita\",\n            size=\"large\",\n            base_price=Decimal('15.99'),\n            toppings=[\"extra cheese\"],\n            preparation_time_minutes=15\n        )\n\n        order.add_pizza(pizza)\n\n        assert len(order.pizzas) == 1\n        assert order.total_amount == Decimal('17.49')  # 15.99 + 1.50 topping\n\n    def test_order_status_transitions(self):\n        \"\"\"Test valid order status transitions\"\"\"\n        order = Order(\n            id=\"order_001\",\n            customer_name=\"Mario Rossi\",\n            customer_phone=\"+1-555-0123\",\n            pizzas=[self._create_test_pizza()],\n            status=\"pending\",\n            order_time=datetime.utcnow()\n        )\n\n        # Test valid transitions\n        order.confirm_order()\n        assert order.status == \"confirmed\"\n\n        order.start_cooking()\n        assert order.status == \"cooking\"\n\n        order.mark_ready()\n        assert order.status == \"ready\"\n\n    def test_invalid_status_transitions_raise_error(self):\n        \"\"\"Test invalid status transitions raise domain errors\"\"\"\n        order = Order(\n            id=\"order_001\",\n            customer_name=\"Mario Rossi\",\n            customer_phone=\"+1-555-0123\",\n            pizzas=[self._create_test_pizza()],\n            status=\"pending\",\n            order_time=datetime.utcnow()\n        )\n\n        # Cannot start cooking before confirming\n        with pytest.raises(InvalidOrderStateError):\n            order.start_cooking()\n\n    def _create_test_pizza(self) -&gt; Pizza:\n        return Pizza(\n            id=\"pizza_001\",\n            name=\"Margherita\",\n            size=\"large\",\n            base_price=Decimal('15.99'),\n            toppings=[],\n            preparation_time_minutes=15\n        )\n\nclass TestKitchenEntity:\n    \"\"\"Test Kitchen domain entity capacity management\"\"\"\n\n    def test_kitchen_capacity_management(self):\n        \"\"\"Test kitchen capacity tracking\"\"\"\n        kitchen = Kitchen(\n            id=\"kitchen_001\",\n            active_orders=[],\n            max_concurrent_orders=3\n        )\n\n        assert kitchen.current_capacity == 0\n        assert kitchen.available_capacity == 3\n        assert not kitchen.is_at_capacity\n\n        # Add orders to capacity\n        assert kitchen.start_order(\"order_001\") == True\n        assert kitchen.start_order(\"order_002\") == True\n        assert kitchen.start_order(\"order_003\") == True\n\n        assert kitchen.current_capacity == 3\n        assert kitchen.available_capacity == 0\n        assert kitchen.is_at_capacity\n\n        # Cannot add more orders when at capacity\n        assert kitchen.start_order(\"order_004\") == False\n\n    def test_kitchen_order_completion(self):\n        \"\"\"Test completing orders frees capacity\"\"\"\n        kitchen = Kitchen(\n            id=\"kitchen_001\",\n            active_orders=[\"order_001\", \"order_002\"],\n            max_concurrent_orders=3\n        )\n\n        kitchen.complete_order(\"order_001\")\n\n        assert kitchen.current_capacity == 1\n        assert kitchen.available_capacity == 2\n        assert not kitchen.is_at_capacity\n</code></pre>"},{"location":"mario-pizzeria/testing-deployment/#command-handler-testing","title":"Command Handler Testing","text":"<pre><code>from unittest.mock import Mock, AsyncMock\nimport pytest\nfrom mario_pizzeria.application.handlers import PlaceOrderHandler\nfrom mario_pizzeria.application.commands import PlaceOrderCommand\n\nclass TestPlaceOrderHandler:\n    \"\"\"Test PlaceOrderHandler business logic\"\"\"\n\n    def setup_method(self):\n        # Mock all dependencies\n        self.order_repository = Mock()\n        self.payment_service = Mock()\n        self.kitchen_repository = Mock()\n        self.mapper = Mock()\n\n        self.handler = PlaceOrderHandler(\n            self.order_repository,\n            self.payment_service,\n            self.kitchen_repository,\n            self.mapper\n        )\n\n    @pytest.mark.asyncio\n    async def test_place_order_success_scenario(self):\n        \"\"\"Test successful order placement\"\"\"\n        # Arrange\n        command = PlaceOrderCommand(\n            customer_name=\"Mario Rossi\",\n            customer_phone=\"+1-555-0123\",\n            customer_address=\"123 Main St\",\n            pizzas=[self._create_test_pizza_dto()],\n            payment_method=\"credit_card\"\n        )\n\n        # Mock successful payment\n        self.payment_service.process_payment_async = AsyncMock(\n            return_value=PaymentResult(success=True, transaction_id=\"txn_123\")\n        )\n\n        # Mock kitchen availability\n        mock_kitchen = Mock()\n        mock_kitchen.is_at_capacity = False\n        self.kitchen_repository.get_default_kitchen = AsyncMock(return_value=mock_kitchen)\n\n        # Mock repository save\n        self.order_repository.save_async = AsyncMock()\n\n        # Act\n        result = await self.handler.handle_async(command)\n\n        # Assert\n        assert result.is_success\n        assert result.status_code == 201\n        self.order_repository.save_async.assert_called_once()\n        self.payment_service.process_payment_async.assert_called_once()\n\n    @pytest.mark.asyncio\n    async def test_place_order_kitchen_at_capacity(self):\n        \"\"\"Test order rejection when kitchen is at capacity\"\"\"\n        # Arrange\n        command = PlaceOrderCommand(\n            customer_name=\"Mario Rossi\",\n            customer_phone=\"+1-555-0123\",\n            customer_address=\"123 Main St\",\n            pizzas=[self._create_test_pizza_dto()],\n            payment_method=\"credit_card\"\n        )\n\n        # Mock kitchen at capacity\n        mock_kitchen = Mock()\n        mock_kitchen.is_at_capacity = True\n        self.kitchen_repository.get_default_kitchen = AsyncMock(return_value=mock_kitchen)\n\n        # Act\n        result = await self.handler.handle_async(command)\n\n        # Assert\n        assert not result.is_success\n        assert result.status_code == 400\n        assert \"capacity\" in result.error_message.lower()\n\n        # Ensure payment was not processed\n        self.payment_service.process_payment_async.assert_not_called()\n\n    @pytest.mark.asyncio\n    async def test_place_order_payment_failure(self):\n        \"\"\"Test order failure when payment fails\"\"\"\n        # Arrange\n        command = PlaceOrderCommand(\n            customer_name=\"Mario Rossi\",\n            customer_phone=\"+1-555-0123\",\n            customer_address=\"123 Main St\",\n            pizzas=[self._create_test_pizza_dto()],\n            payment_method=\"credit_card\"\n        )\n\n        # Mock kitchen availability\n        mock_kitchen = Mock()\n        mock_kitchen.is_at_capacity = False\n        self.kitchen_repository.get_default_kitchen = AsyncMock(return_value=mock_kitchen)\n\n        # Mock payment failure\n        self.payment_service.process_payment_async = AsyncMock(\n            return_value=PaymentResult(success=False, error_message=\"Card declined\")\n        )\n\n        # Act\n        result = await self.handler.handle_async(command)\n\n        # Assert\n        assert not result.is_success\n        assert result.status_code == 400\n        assert \"payment failed\" in result.error_message.lower()\n\n        # Ensure order was not saved\n        self.order_repository.save_async.assert_not_called()\n</code></pre>"},{"location":"mario-pizzeria/testing-deployment/#integration-testing","title":"\ud83d\udd27 Integration Testing","text":"<p>Integration tests validate API endpoints and database interactions:</p>"},{"location":"mario-pizzeria/testing-deployment/#controller-integration-tests","title":"Controller Integration Tests","text":"<pre><code>import pytest\nfrom httpx import AsyncClient\nfrom mario_pizzeria.main import create_app\n\nclass TestOrdersController:\n    \"\"\"Integration tests for Orders API\"\"\"\n\n    @pytest.fixture\n    def test_app(self):\n        \"\"\"Create test application with in-memory database\"\"\"\n        app = create_app()\n        app.configure_test_environment()\n        return app\n\n    @pytest.fixture\n    async def test_client(self, test_app):\n        \"\"\"Create test client\"\"\"\n        async with AsyncClient(app=test_app, base_url=\"http://test\") as client:\n            yield client\n\n    @pytest.mark.integration\n    async def test_place_order_success(self, test_client):\n        \"\"\"Test successful order placement via API\"\"\"\n        order_data = {\n            \"customer_name\": \"Mario Rossi\",\n            \"customer_phone\": \"+1-555-0123\",\n            \"customer_address\": \"123 Main St\",\n            \"pizzas\": [\n                {\n                    \"pizza_id\": \"margherita\",\n                    \"size\": \"large\",\n                    \"toppings\": [\"extra cheese\"],\n                    \"quantity\": 1\n                }\n            ],\n            \"payment_method\": \"credit_card\"\n        }\n\n        response = await test_client.post(\"/orders\", json=order_data)\n\n        assert response.status_code == 201\n        data = response.json()\n\n        assert data[\"customer_name\"] == \"Mario Rossi\"\n        assert data[\"status\"] == \"confirmed\"\n        assert len(data[\"pizzas\"]) == 1\n        assert \"id\" in data\n        assert \"estimated_ready_time\" in data\n\n    @pytest.mark.integration\n    async def test_place_order_validation_error(self, test_client):\n        \"\"\"Test order placement with invalid data\"\"\"\n        invalid_order_data = {\n            \"customer_name\": \"\",  # Invalid: empty name\n            \"customer_phone\": \"+1-555-0123\",\n            \"pizzas\": []  # Invalid: no pizzas\n        }\n\n        response = await test_client.post(\"/orders\", json=invalid_order_data)\n\n        assert response.status_code == 400\n        error_data = response.json()\n        assert \"validation\" in error_data[\"error\"].lower()\n\n    @pytest.mark.integration\n    async def test_get_order_by_id(self, test_client):\n        \"\"\"Test retrieving order by ID\"\"\"\n        # First create an order\n        order_data = self._create_test_order_data()\n        create_response = await test_client.post(\"/orders\", json=order_data)\n        order_id = create_response.json()[\"id\"]\n\n        # Then retrieve it\n        get_response = await test_client.get(f\"/orders/{order_id}\")\n\n        assert get_response.status_code == 200\n        data = get_response.json()\n        assert data[\"id\"] == order_id\n        assert data[\"customer_name\"] == order_data[\"customer_name\"]\n\n    @pytest.mark.integration\n    async def test_get_kitchen_status(self, test_client):\n        \"\"\"Test kitchen status endpoint\"\"\"\n        response = await test_client.get(\"/kitchen/status\")\n\n        assert response.status_code == 200\n        data = response.json()\n\n        assert \"current_capacity\" in data\n        assert \"max_concurrent_orders\" in data\n        assert \"active_orders\" in data\n        assert \"is_at_capacity\" in data\n        assert isinstance(data[\"current_capacity\"], int)\n\n    @pytest.mark.integration\n    async def test_start_cooking_order(self, test_client):\n        \"\"\"Test starting cooking process\"\"\"\n        # Create order first\n        order_data = self._create_test_order_data()\n        create_response = await test_client.post(\"/orders\", json=order_data)\n        order_id = create_response.json()[\"id\"]\n\n        # Start cooking\n        cook_response = await test_client.post(\n            f\"/kitchen/orders/{order_id}/start\",\n            json={\"kitchen_staff_id\": \"staff_001\"}\n        )\n\n        assert cook_response.status_code == 200\n\n        # Verify order status changed\n        status_response = await test_client.get(f\"/orders/{order_id}\")\n        assert status_response.json()[\"status\"] == \"cooking\"\n\n    def _create_test_order_data(self):\n        return {\n            \"customer_name\": \"Test Customer\",\n            \"customer_phone\": \"+1-555-0123\",\n            \"customer_address\": \"123 Test St\",\n            \"pizzas\": [\n                {\n                    \"pizza_id\": \"margherita\",\n                    \"size\": \"medium\",\n                    \"toppings\": [],\n                    \"quantity\": 1\n                }\n            ],\n            \"payment_method\": \"credit_card\"\n        }\n</code></pre>"},{"location":"mario-pizzeria/testing-deployment/#repository-integration-tests","title":"Repository Integration Tests","text":"<pre><code>@pytest.mark.integration\nclass TestOrderRepository:\n    \"\"\"Integration tests for order data access\"\"\"\n\n    @pytest.fixture\n    async def repository(self, mongo_client):\n        \"\"\"Create repository with test database\"\"\"\n        return OrderRepository(mongo_client.test_db.orders)\n\n    @pytest.mark.asyncio\n    async def test_save_and_retrieve_order(self, repository):\n        \"\"\"Test complete CRUD operations\"\"\"\n        # Create test order\n        order = Order(\n            id=\"test_order_001\",\n            customer_name=\"Test Customer\",\n            customer_phone=\"+1-555-0123\",\n            pizzas=[self._create_test_pizza()],\n            status=\"pending\",\n            order_time=datetime.utcnow()\n        )\n\n        # Save order\n        await repository.save_async(order)\n\n        # Retrieve order\n        retrieved = await repository.get_by_id_async(\"test_order_001\")\n\n        assert retrieved is not None\n        assert retrieved.id == order.id\n        assert retrieved.customer_name == order.customer_name\n        assert retrieved.status == order.status\n        assert len(retrieved.pizzas) == len(order.pizzas)\n\n    @pytest.mark.asyncio\n    async def test_get_orders_by_status(self, repository):\n        \"\"\"Test filtering orders by status\"\"\"\n        # Create orders with different statuses\n        orders = [\n            self._create_test_order(\"order_001\", \"pending\"),\n            self._create_test_order(\"order_002\", \"cooking\"),\n            self._create_test_order(\"order_003\", \"ready\")\n        ]\n\n        for order in orders:\n            await repository.save_async(order)\n\n        # Get cooking orders\n        cooking_orders = await repository.get_by_status_async(\"cooking\")\n\n        assert len(cooking_orders) == 1\n        assert cooking_orders[0].status == \"cooking\"\n</code></pre>"},{"location":"mario-pizzeria/testing-deployment/#end-to-end-testing","title":"\ud83c\udf10 End-to-End Testing","text":"<p>End-to-end tests validate complete business workflows:</p> <pre><code>@pytest.mark.e2e\nclass TestPizzeriaWorkflow:\n    \"\"\"End-to-end workflow tests\"\"\"\n\n    @pytest.fixture\n    async def test_system(self):\n        \"\"\"Set up complete test system\"\"\"\n        app = create_app()\n        app.configure_test_environment()\n\n        # Start background services\n        await app.start_background_services()\n\n        async with AsyncClient(app=app, base_url=\"http://test\") as client:\n            yield client\n\n        await app.stop_background_services()\n\n    @pytest.mark.asyncio\n    async def test_complete_order_workflow(self, test_system):\n        \"\"\"Test complete order-to-delivery workflow\"\"\"\n        client = test_system\n\n        # Step 1: Customer browses menu\n        menu_response = await client.get(\"/menu/pizzas\")\n        assert menu_response.status_code == 200\n        pizzas = menu_response.json()\n        assert len(pizzas) &gt; 0\n\n        # Step 2: Customer places order\n        order_data = {\n            \"customer_name\": \"Integration Test Customer\",\n            \"customer_phone\": \"+1-555-9999\",\n            \"customer_address\": \"123 Test Ave\",\n            \"pizzas\": [\n                {\n                    \"pizza_id\": pizzas[0][\"id\"],\n                    \"size\": \"large\",\n                    \"toppings\": [\"pepperoni\", \"mushrooms\"],\n                    \"quantity\": 2\n                }\n            ],\n            \"payment_method\": \"credit_card\"\n        }\n\n        order_response = await client.post(\"/orders\", json=order_data)\n        assert order_response.status_code == 201\n        order = order_response.json()\n        order_id = order[\"id\"]\n\n        # Verify order is confirmed\n        assert order[\"status\"] == \"confirmed\"\n        assert order[\"customer_name\"] == \"Integration Test Customer\"\n\n        # Step 3: Kitchen views order queue\n        queue_response = await client.get(\"/kitchen/queue\")\n        assert queue_response.status_code == 200\n        queue = queue_response.json()\n\n        # Find our order in queue\n        order_in_queue = next((o for o in queue if o[\"id\"] == order_id), None)\n        assert order_in_queue is not None\n\n        # Step 4: Kitchen starts cooking\n        start_response = await client.post(\n            f\"/kitchen/orders/{order_id}/start\",\n            json={\"kitchen_staff_id\": \"test_staff\"}\n        )\n        assert start_response.status_code == 200\n\n        # Verify status changed to cooking\n        status_response = await client.get(f\"/orders/{order_id}\")\n        cooking_order = status_response.json()\n        assert cooking_order[\"status\"] == \"cooking\"\n\n        # Step 5: Kitchen completes order\n        complete_response = await client.post(\n            f\"/kitchen/orders/{order_id}/complete\"\n        )\n        assert complete_response.status_code == 200\n\n        # Step 6: Verify final status\n        final_response = await client.get(f\"/orders/{order_id}\")\n        final_order = final_response.json()\n        assert final_order[\"status\"] == \"ready\"\n\n        # Step 7: Verify kitchen capacity is freed\n        final_status = await client.get(\"/kitchen/status\")\n        kitchen_status = final_status.json()\n\n        # Kitchen should have capacity again\n        assert not kitchen_status[\"is_at_capacity\"]\n\n    @pytest.mark.asyncio\n    async def test_concurrent_order_processing(self, test_system):\n        \"\"\"Test system handles concurrent orders correctly\"\"\"\n        client = test_system\n\n        # Place multiple concurrent orders\n        order_tasks = []\n        for i in range(5):\n            order_data = self._create_concurrent_order_data(i)\n            task = client.post(\"/orders\", json=order_data)\n            order_tasks.append(task)\n\n        # Wait for all orders to complete\n        responses = await asyncio.gather(*order_tasks)\n\n        # Verify all orders were processed\n        successful_orders = 0\n        capacity_rejections = 0\n\n        for response in responses:\n            if response.status_code == 201:\n                successful_orders += 1\n            elif response.status_code == 400:\n                error_data = response.json()\n                if \"capacity\" in error_data.get(\"error\", \"\").lower():\n                    capacity_rejections += 1\n\n        # Should have processed some orders and rejected others due to capacity\n        assert successful_orders &gt; 0\n        assert successful_orders + capacity_rejections == 5\n</code></pre>"},{"location":"mario-pizzeria/testing-deployment/#deployment-operations","title":"\ud83d\ude80 Deployment &amp; Operations","text":""},{"location":"mario-pizzeria/testing-deployment/#docker-configuration","title":"Docker Configuration","text":"<pre><code># Dockerfile\nFROM python:3.11-slim\n\nWORKDIR /app\n\n# Install system dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    gcc \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Install Python dependencies\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Copy application code\nCOPY src/ ./src/\nCOPY tests/ ./tests/\n\n# Run tests during build\nRUN python -m pytest tests/ -v\n\n# Expose port\nEXPOSE 8000\n\n# Run application\nCMD [\"uvicorn\", \"src.mario_pizzeria.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n</code></pre>"},{"location":"mario-pizzeria/testing-deployment/#cicd-pipeline","title":"CI/CD Pipeline","text":"<pre><code># .github/workflows/ci-cd.yml\nname: Mario's Pizzeria CI/CD\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    services:\n      mongodb:\n        image: mongo:6\n        ports:\n          - 27017:27017\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: \"3.11\"\n\n      - name: Install dependencies\n        run: |\n          pip install -r requirements.txt\n          pip install -r requirements-test.txt\n\n      - name: Run unit tests\n        run: pytest tests/unit/ -v --cov=src/mario_pizzeria\n\n      - name: Run integration tests\n        run: pytest tests/integration/ -v -m integration\n\n      - name: Run E2E tests\n        run: pytest tests/e2e/ -v -m e2e\n\n      - name: Check test coverage\n        run: |\n          coverage report --fail-under=90\n          coverage xml\n\n      - name: Upload coverage to Codecov\n        uses: codecov/codecov-action@v3\n        with:\n          file: ./coverage.xml\n\n  deploy:\n    needs: test\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Build Docker image\n        run: docker build -t mario-pizzeria:${{ github.sha }} .\n\n      - name: Deploy to staging\n        run: |\n          # Deploy to staging environment\n          echo \"Deploying to staging...\"\n\n      - name: Run smoke tests\n        run: |\n          # Run basic smoke tests against staging\n          pytest tests/smoke/ -v\n</code></pre>"},{"location":"mario-pizzeria/testing-deployment/#production-monitoring","title":"Production Monitoring","text":"<pre><code># monitoring.py\nfrom prometheus_client import Counter, Histogram, generate_latest\nfrom fastapi import Request\nimport time\n\n# Metrics\nREQUEST_COUNT = Counter('pizzeria_requests_total', 'Total requests', ['method', 'endpoint'])\nREQUEST_DURATION = Histogram('pizzeria_request_duration_seconds', 'Request duration')\nORDER_COUNT = Counter('pizzeria_orders_total', 'Total orders', ['status'])\nKITCHEN_CAPACITY = Histogram('pizzeria_kitchen_capacity', 'Kitchen capacity usage')\n\nclass MetricsMiddleware:\n    def __init__(self, app):\n        self.app = app\n\n    async def __call__(self, scope, receive, send):\n        if scope[\"type\"] == \"http\":\n            request = Request(scope, receive)\n            start_time = time.time()\n\n            # Process request\n            response = await self.app(scope, receive, send)\n\n            # Record metrics\n            duration = time.time() - start_time\n            REQUEST_COUNT.labels(\n                method=request.method,\n                endpoint=request.url.path\n            ).inc()\n            REQUEST_DURATION.observe(duration)\n\n            return response\n\n        return await self.app(scope, receive, send)\n\n@app.get(\"/metrics\")\nasync def metrics():\n    \"\"\"Prometheus metrics endpoint\"\"\"\n    return Response(generate_latest(), media_type=\"text/plain\")\n</code></pre>"},{"location":"mario-pizzeria/testing-deployment/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Business Analysis - Requirements and stakeholder analysis</li> <li>Technical Architecture - System design and infrastructure</li> <li>Domain Design - Business logic and data models</li> <li>Implementation Guide - Development patterns and APIs</li> </ul> <p>This comprehensive testing and deployment guide ensures Mario's Pizzeria maintains high quality and reliability from development through production.</p>"},{"location":"old/architecture/","title":"\ud83c\udfd7\ufe0f Architecture Guide","text":"<p>\u26a0\ufe0f Deprecated</p> <p>This page is deprecated and will be removed in a future version. The content has been migrated to more focused sections:</p> <ul> <li>Clean Architecture Pattern - Four-layer separation and dependency rules</li> <li>CQRS Pattern - Command Query Responsibility Segregation</li> <li>Event-Driven Pattern - Domain events and messaging</li> <li>Mario's Pizzeria - Complete bounded context example</li> <li>Features - Framework-specific implementation details</li> </ul> <p>Please use the new structure for the most up-to-date documentation.</p> <p>Neuroglia's clean architecture is demonstrated through Mario's Pizzeria, showing how layered architecture promotes separation of concerns, testability, and maintainability in a real-world application.</p>"},{"location":"old/architecture/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>Clean Architecture Layers: How Mario's Pizzeria separates concerns across API, Application, Domain, and Integration layers</li> <li>Dependency Flow: How pizza order workflow demonstrates the dependency rule in practice</li> <li>CQRS Implementation: How command and query separation works in kitchen operations</li> <li>Event-Driven Design: How domain events coordinate between pizza preparation and customer notifications</li> <li>Testing Strategy: How architecture enables comprehensive testing at every layer</li> </ul>"},{"location":"old/architecture/#marios-pizzeria-architecture","title":"\ud83c\udf55 Mario's Pizzeria Architecture","text":""},{"location":"old/architecture/#overview-from-order-to-pizza","title":"Overview: From Order to Pizza","text":"<p>Mario's Pizzeria demonstrates clean architecture through the complete pizza ordering and preparation workflow:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            \ud83c\udf10 API Layer (Controllers)           \u2502  \u2190 Customer &amp; Staff Interface\n\u2502   OrdersController \u2502 MenuController \u2502 Kitchen   \u2502\n\u2502   Authentication   \u2502 Error Handling \u2502 Swagger   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 orchestrates\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502       \ud83d\udcbc Application Layer (CQRS + Events)      \u2502  \u2190 Business Workflow\n\u2502  PlaceOrderCommand \u2502 GetMenuQuery \u2502 Handlers    \u2502\n\u2502  OrderPlacedEvent  \u2502 Kitchen Workflow Pipeline  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 uses\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         \ud83c\udfdb\ufe0f Domain Layer (Business Logic)        \u2502  \u2190 Pizza Business Rules\n\u2502    Order Entity    \u2502    Pizza Entity           \u2502\n\u2502  Kitchen Workflow  \u2502  Pricing Rules            \u2502\n\u2502   Domain Events    \u2502  Business Validation      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 implements\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502      \ud83d\udd0c Integration Layer (External Systems)    \u2502  \u2190 Data &amp; External APIs\n\u2502  Order Repository  \u2502  Payment Gateway          \u2502\n\u2502   File Storage     \u2502  MongoDB \u2502 Event Store    \u2502\n\u2502  SMS Notifications \u2502  Email Service            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"old/architecture/#the-dependency-rule-in-action","title":"The Dependency Rule in Action","text":"<p>Pizza order flow demonstrates how dependencies always point inward:</p> <ol> <li>API Layer \u2192 Application Layer: Controller calls <code>PlaceOrderCommand</code></li> <li>Application Layer \u2192 Domain Layer: Handler uses <code>Order</code> entity business logic</li> <li>Integration Layer \u2192 Domain Layer: Repository implements domain <code>IOrderRepository</code> interface</li> <li>Never: Domain layer doesn't know about API controllers or database implementation</li> </ol>"},{"location":"old/architecture/#layer-details-with-pizza-examples","title":"\ud83c\udfe2 Layer Details with Pizza Examples","text":""},{"location":"old/architecture/#api-layer-customer-staff-interface","title":"\ud83d\udce1 API Layer: Customer &amp; Staff Interface","text":"<p>Purpose: External interface for Mario's Pizzeria operations</p> <p>Responsibilities:</p> <ul> <li>HTTP endpoints for orders, menu, kitchen operations</li> <li>Customer and staff authentication (OAuth 2.0)</li> <li>Request validation and error handling</li> <li>OpenAPI documentation generation</li> </ul> <p>Key Components:</p> <pre><code># src/api/controllers/orders_controller.py\nclass OrdersController(ControllerBase):\n    \"\"\"Handle customer pizza orders\"\"\"\n\n    @post(\"/\", response_model=OrderDto, status_code=201)\n    async def place_order(self, order_request: PlaceOrderDto) -&gt; OrderDto:\n        \"\"\"Place new pizza order\"\"\"\n        command = PlaceOrderCommand(\n            customer_name=order_request.customer_name,\n            customer_phone=order_request.customer_phone,\n            pizzas=order_request.pizzas,\n            payment_method=order_request.payment_method\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)  # Framework handles success/error response\n\n# src/api/dtos/order_dto.py\nclass PlaceOrderDto(BaseModel):\n    \"\"\"Request DTO for placing pizza orders\"\"\"\n    customer_name: str = Field(..., min_length=2, max_length=100)\n    customer_phone: str = Field(..., regex=r\"^\\+?1?[2-9]\\d{9}$\")\n    customer_address: str = Field(..., min_length=10, max_length=200)\n    pizzas: List[PizzaOrderDto] = Field(..., min_items=1, max_items=20)\n    payment_method: str = Field(..., regex=\"^(cash|card|online)$\")\n</code></pre> <p>Architecture Benefits:</p> <ul> <li>Framework Independence: Pure business logic with no external dependencies</li> </ul>"},{"location":"old/architecture/#integration-layer-external-systems","title":"\ud83d\udd0c Integration Layer: External Systems","text":"<p>Purpose: Handles external system interactions and data persistence</p> <p>Responsibilities:</p> <ul> <li>Data persistence (file storage, MongoDB, event store)</li> <li>External API integration (payment, notifications)</li> <li>Infrastructure concerns (caching, logging)</li> <li>Implements domain interfaces</li> </ul> <p>Integration Components:</p> <pre><code># src/integration/repositories/file_order_repository.py\nclass FileOrderRepository(IOrderRepository):\n    \"\"\"File-based order repository for development\"\"\"\n\n    def __init__(self, orders_directory: str = \"data/orders\"):\n        self.orders_directory = Path(orders_directory)\n        self.orders_directory.mkdir(parents=True, exist_ok=True)\n\n    async def save_async(self, order: Order) -&gt; Order:\n        \"\"\"Save order to JSON file\"\"\"\n        order_file = self.orders_directory / f\"{order.id}.json\"\n\n        order_data = {\n            \"id\": order.id,\n            \"customer_name\": order.customer_name,\n            \"customer_phone\": order.customer_phone,\n            \"customer_address\": order.customer_address,\n            \"pizzas\": [self._pizza_to_dict(pizza) for pizza in order.pizzas],\n            \"status\": order.status.value,\n            \"order_time\": order.order_time.isoformat(),\n            \"total_amount\": float(order.total_amount)\n        }\n\n        async with aiofiles.open(order_file, 'w') as f:\n            await f.write(json.dumps(order_data, indent=2))\n\n        return order\n\n# src/integration/services/payment_service.py\nclass StripePaymentService(IPaymentService):\n    \"\"\"Payment processing using Stripe API\"\"\"\n\n    async def process_payment_async(self,\n                                    amount: Decimal,\n                                    payment_method: str) -&gt; PaymentResult:\n        \"\"\"Process payment through Stripe\"\"\"\n        try:\n            import stripe\n            stripe.api_key = os.getenv(\"STRIPE_SECRET_KEY\")\n\n            # Create payment intent\n            intent = stripe.PaymentIntent.create(\n                amount=int(amount * 100),  # Convert to cents\n                currency=\"usd\",\n                payment_method=payment_method,\n                confirm=True,\n                return_url=\"https://marios-pizzeria.com/payment-success\"\n            )\n\n            return PaymentResult(\n                is_success=True,\n                transaction_id=intent.id,\n                amount_processed=amount\n            )\n\n        except stripe.error.StripeError as e:\n            return PaymentResult(\n                is_success=False,\n                error_message=str(e)\n            )\n\n# src/integration/services/notification_service.py\nclass TwilioNotificationService(INotificationService):\n    \"\"\"SMS notifications using Twilio\"\"\"\n\n    async def send_order_confirmation_async(self, order: Order) -&gt; None:\n        \"\"\"Send order confirmation SMS\"\"\"\n        from twilio.rest import Client\n\n        client = Client(\n            os.getenv(\"TWILIO_ACCOUNT_SID\"),\n            os.getenv(\"TWILIO_AUTH_TOKEN\")\n        )\n\n        message = (f\"Hi {order.customer_name}! Your pizza order #{order.id} \"\n                  f\"has been confirmed. Total: ${order.total_amount}. \"\n                  f\"Estimated ready time: {order.estimated_ready_time.strftime('%I:%M %p')}\")\n\n        await client.messages.create(\n            body=message,\n            from_=os.getenv(\"TWILIO_PHONE_NUMBER\"),\n            to=order.customer_phone\n        )\n\n    async def send_order_ready_notification_async(self, order: Order) -&gt; None:\n        \"\"\"Send order ready SMS\"\"\"\n        message = (f\"\ud83c\udf55 Your order #{order.id} is ready for pickup at Mario's Pizzeria! \"\n                  f\"Please arrive within 15 minutes to keep your pizzas hot.\")\n\n        # Implementation details...\n</code></pre>"},{"location":"old/architecture/#cqrs-implementation-in-marios-pizzeria","title":"\ud83c\udfaf CQRS Implementation in Mario's Pizzeria","text":""},{"location":"old/architecture/#command-and-query-separation","title":"Command and Query Separation","text":"<p>Mario's Pizzeria demonstrates CQRS (Command Query Responsibility Segregation):</p> <pre><code># Commands: Change state (Write operations)\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Command to place new pizza order\"\"\"\n    pass\n\nclass UpdateOrderStatusCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Command to update order status in kitchen\"\"\"\n    pass\n\nclass CancelOrderCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Command to cancel existing order\"\"\"\n    pass\n\n# Queries: Read state (Read operations)\nclass GetOrderByIdQuery(Query[OrderDto]):\n    \"\"\"Query to get specific order details\"\"\"\n    pass\n\nclass GetKitchenQueueQuery(Query[List[KitchenOrderDto]]):\n    \"\"\"Query to get orders in kitchen preparation queue\"\"\"\n    pass\n\nclass GetMenuQuery(Query[List[PizzaDto]]):\n    \"\"\"Query to get available pizza menu\"\"\"\n    pass\n</code></pre>"},{"location":"old/architecture/#benefits-of-cqrs-in-pizzeria-context","title":"Benefits of CQRS in Pizzeria Context","text":"<p>Write Side (Commands):</p> <ul> <li>Order Placement: Validates business rules, processes payments</li> <li>Kitchen Operations: Updates order status, manages workflow</li> <li>Menu Management: Updates pizza availability, pricing</li> </ul> <p>Read Side (Queries):</p> <ul> <li>Customer App: Fast menu browsing, order tracking</li> <li>Kitchen Display: Real-time queue updates</li> <li>Analytics: Revenue reports, performance metrics</li> </ul> <p>Separate Optimization:</p> <ul> <li>Commands use MongoDB for ACID transactions</li> <li>Queries use optimized read models for fast retrieval</li> <li>Analytics use event store for historical data</li> </ul>"},{"location":"old/architecture/#event-driven-architecture","title":"\ud83d\udcca Event-Driven Architecture","text":""},{"location":"old/architecture/#domain-events-in-pizza-workflow","title":"Domain Events in Pizza Workflow","text":"<p>Events coordinate between different parts of Mario's Pizzeria:</p> <pre><code># Domain events flow through the system\nOrderPlacedEvent \u2192 KitchenNotificationHandler \u2192 Kitchen Display Update\n                \u2198 CustomerConfirmationHandler \u2192 SMS Confirmation\n                \u2198 InventoryHandler \u2192 Update Pizza Availability\n\nOrderReadyEvent \u2192 CustomerNotificationHandler \u2192 \"Order Ready\" SMS\n               \u2198 DeliveryScheduleHandler \u2192 Schedule Delivery\n\nOrderCompletedEvent \u2192 AnalyticsHandler \u2192 Update Revenue Metrics\n                   \u2198 CustomerHistoryHandler \u2192 Update Customer Profile\n</code></pre>"},{"location":"old/architecture/#event-handler-examples","title":"Event Handler Examples","text":"<pre><code>class KitchenNotificationHandler(EventHandler[OrderPlacedEvent]):\n    \"\"\"Update kitchen display when new order placed\"\"\"\n\n    async def handle_async(self, event: OrderPlacedEvent):\n        # Add order to kitchen queue\n        command = AddToKitchenQueueCommand(\n            order_id=event.order_id,\n            estimated_ready_time=event.estimated_ready_time\n        )\n        await self.mediator.execute_async(command)\n\nclass CustomerNotificationHandler(EventHandler[OrderReadyEvent]):\n    \"\"\"Notify customer when order is ready\"\"\"\n\n    async def handle_async(self, event: OrderReadyEvent):\n        # Send SMS notification\n        await self.notification_service.send_order_ready_notification_async(\n            order_id=event.order_id,\n            customer_phone=event.customer_phone\n        )\n\nclass RevenueAnalyticsHandler(EventHandler[OrderCompletedEvent]):\n    \"\"\"Update revenue analytics when order completed\"\"\"\n\n    async def handle_async(self, event: OrderCompletedEvent):\n        # Update daily revenue\n        command = UpdateDailyRevenueCommand(\n            date=event.completed_at.date(),\n            amount=event.total_amount,\n            order_count=1\n        )\n        await self.mediator.execute_async(command)\n</code></pre>"},{"location":"old/architecture/#testing-strategy-across-layers","title":"\ud83e\uddea Testing Strategy Across Layers","text":""},{"location":"old/architecture/#layer-specific-testing-approaches","title":"Layer-Specific Testing Approaches","text":"<p>Each layer in Mario's Pizzeria has specific testing strategies:</p> <p>API Layer (Controllers):</p> <ul> <li>Unit Tests: Mock mediator, test HTTP status codes and response formatting</li> <li>Integration Tests: Test full HTTP request/response cycle with real dependencies</li> <li>Contract Tests: Validate request/response schemas match OpenAPI spec</li> </ul> <pre><code>@pytest.mark.asyncio\nasync def test_place_order_success(orders_controller, mock_mediator):\n    \"\"\"Test successful order placement through controller\"\"\"\n    # Arrange\n    order_request = PlaceOrderDto(\n        customer_name=\"Test Customer\",\n        customer_phone=\"+1234567890\",\n        pizzas=[PizzaOrderDto(name=\"Margherita\", size=\"large\", quantity=1)]\n    )\n\n    expected_order = OrderDto(id=\"order_123\", status=\"received\")\n    mock_mediator.execute_async.return_value = OperationResult.success(expected_order)\n\n    # Act\n    result = await orders_controller.place_order(order_request)\n\n    # Assert\n    assert result.id == \"order_123\"\n    assert result.status == \"received\"\n</code></pre> <p>Application Layer (Handlers):</p> <ul> <li>Unit Tests: Mock all dependencies (repositories, external services)</li> <li>Behavior Tests: Verify business workflow logic and error handling</li> <li>Event Tests: Validate domain events are raised correctly</li> </ul> <pre><code>@pytest.mark.asyncio\nasync def test_place_order_handler_workflow(mock_order_repo, mock_payment_service):\n    \"\"\"Test complete order placement workflow\"\"\"\n    # Arrange\n    handler = PlaceOrderCommandHandler(mock_order_repo, mock_payment_service, ...)\n    command = PlaceOrderCommand(customer_name=\"Test\", pizzas=[...])\n\n    mock_payment_service.process_payment_async.return_value = PaymentResult(success=True)\n    mock_order_repo.save_async.return_value = Order(id=\"order_123\")\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n    mock_payment_service.process_payment_async.assert_called_once()\n    mock_order_repo.save_async.assert_called_once()\n</code></pre> <p>Domain Layer (Entities &amp; Services):</p> <ul> <li>Unit Tests: Pure business logic testing with no external dependencies</li> <li>Business Rule Tests: Validate invariants and business constraints</li> <li>Event Tests: Ensure domain events are raised for business-significant changes</li> </ul> <pre><code>def test_order_total_calculation():\n    \"\"\"Test pizza order total calculation business logic\"\"\"\n    # Arrange\n    pizzas = [\n        Pizza(\"Margherita\", \"large\", [\"extra_cheese\"]),\n        Pizza(\"Pepperoni\", \"medium\", [])\n    ]\n\n    # Act\n    order = Order.create_new(\"Customer\", \"+1234567890\", \"Address\", pizzas, \"card\")\n\n    # Assert\n    expected_subtotal = Decimal(\"15.99\") + Decimal(\"12.99\")  # Pizza prices\n    expected_tax = expected_subtotal * Decimal(\"0.0875\")     # 8.75% tax\n    expected_delivery = Decimal(\"2.99\")                      # Delivery fee\n    expected_total = expected_subtotal + expected_tax + expected_delivery\n\n    assert order.total_amount == expected_total.quantize(Decimal(\"0.01\"))\n\ndef test_order_status_transition_validation():\n    \"\"\"Test order status transition business rules\"\"\"\n    # Arrange\n    order = Order.create_new(\"Customer\", \"+1234567890\", \"Address\", [], \"card\")\n\n    # Act &amp; Assert - Valid transition\n    order.update_status(OrderStatus.PREPARING, \"chef_mario\")\n    assert order.status == OrderStatus.PREPARING\n\n    # Act &amp; Assert - Invalid transition\n    with pytest.raises(DomainException):\n        order.update_status(OrderStatus.DELIVERED, \"chef_mario\")  # Cannot skip to delivered\n\ndef test_domain_events_raised():\n    \"\"\"Test that domain events are raised correctly\"\"\"\n    # Arrange\n    pizzas = [Pizza(\"Margherita\", \"large\", [])]\n\n    # Act\n    order = Order.create_new(\"Customer\", \"+1234567890\", \"Address\", pizzas, \"card\")\n\n    # Assert\n    events = order.get_uncommitted_events()\n    assert len(events) == 1\n    assert isinstance(events[0], OrderPlacedEvent)\n    assert events[0].order_id == order.id\n</code></pre> <p>Integration Layer (Repositories &amp; Services):</p> <ul> <li>Unit Tests: Mock external dependencies (databases, APIs)</li> <li>Integration Tests: Test against real external systems in controlled environments</li> <li>Contract Tests: Validate external API integrations</li> </ul> <pre><code>@pytest.mark.integration\nasync def test_file_order_repository_roundtrip():\n    \"\"\"Test saving and retrieving orders from file system\"\"\"\n    # Arrange\n    repository = FileOrderRepository(\"test_data/orders\")\n    order = Order.create_new(\"Test Customer\", \"+1234567890\", \"Test Address\", [], \"cash\")\n\n    # Act\n    saved_order = await repository.save_async(order)\n    retrieved_order = await repository.get_by_id_async(saved_order.id)\n\n    # Assert\n    assert retrieved_order is not None\n    assert retrieved_order.customer_name == \"Test Customer\"\n    assert retrieved_order.id == saved_order.id\n\n@pytest.mark.integration\nasync def test_stripe_payment_service():\n    \"\"\"Test payment processing with Stripe (using test API keys)\"\"\"\n    # Arrange\n    payment_service = StripePaymentService()\n    amount = Decimal(\"29.99\")\n\n    # Act\n    result = await payment_service.process_payment_async(amount, \"pm_card_visa\")\n\n    # Assert\n    assert result.is_success\n    assert result.amount_processed == amount\n    assert result.transaction_id is not None\n</code></pre>"},{"location":"old/architecture/#end-to-end-testing","title":"End-to-End Testing","text":"<p>Full workflow testing across all layers:</p> <pre><code>@pytest.mark.e2e\nasync def test_complete_pizza_order_workflow():\n    \"\"\"Test complete order workflow from API to persistence\"\"\"\n    async with TestClient(create_pizzeria_app()) as client:\n        # 1. Get menu\n        menu_response = await client.get(\"/api/menu/pizzas\")\n        assert menu_response.status_code == 200\n\n        # 2. Place order\n        order_data = {\n            \"customer_name\": \"E2E Test Customer\",\n            \"customer_phone\": \"+1234567890\",\n            \"customer_address\": \"123 Test St\",\n            \"pizzas\": [{\"name\": \"Margherita\", \"size\": \"large\", \"quantity\": 1}],\n            \"payment_method\": \"card\"\n        }\n\n        order_response = await client.post(\"/api/orders/\", json=order_data)\n        assert order_response.status_code == 201\n        order = order_response.json()\n\n        # 3. Update order status (kitchen)\n        status_update = {\"status\": \"preparing\", \"notes\": \"Started preparation\"}\n        status_response = await client.put(\n            f\"/api/kitchen/orders/{order['id']}/status\",\n            json=status_update,\n            headers={\"Authorization\": \"Bearer {kitchen_token}\"}\n        )\n        assert status_response.status_code == 200\n\n        # 4. Verify order status\n        check_response = await client.get(f\"/api/orders/{order['id']}\")\n        updated_order = check_response.json()\n        assert updated_order[\"status\"] == \"preparing\"\n</code></pre>"},{"location":"old/architecture/#dependency-injection-configuration","title":"\ud83d\udee0\ufe0f Dependency Injection Configuration","text":""},{"location":"old/architecture/#service-registration-for-marios-pizzeria","title":"Service Registration for Mario's Pizzeria","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\n\ndef configure_pizzeria_services(builder: WebApplicationBuilder):\n    \"\"\"Configure all services for Mario's Pizzeria\"\"\"\n\n    # Domain services\n    builder.services.add_scoped(KitchenWorkflowService)\n    builder.services.add_scoped(PricingService)\n\n    # Application services\n    builder.services.add_mediator()\n    builder.services.add_auto_mapper()\n\n    # Infrastructure services (environment-specific)\n    environment = os.getenv(\"ENVIRONMENT\", \"development\")\n\n    if environment == \"development\":\n        # File-based repositories for development\n        builder.services.add_scoped(IOrderRepository, FileOrderRepository)\n        builder.services.add_scoped(IPizzaRepository, FilePizzaRepository)\n        builder.services.add_scoped(INotificationService, ConsoleNotificationService)\n        builder.services.add_scoped(IPaymentService, MockPaymentService)\n\n    else:  # production\n        # MongoDB repositories for production\n        builder.services.add_scoped(IOrderRepository, MongoOrderRepository)\n        builder.services.add_scoped(IPizzaRepository, MongoPizzaRepository)\n        builder.services.add_scoped(INotificationService, TwilioNotificationService)\n        builder.services.add_scoped(IPaymentService, StripePaymentService)\n\n    # Event handlers\n    builder.services.add_scoped(EventHandler[OrderPlacedEvent], KitchenNotificationHandler)\n    builder.services.add_scoped(EventHandler[OrderReadyEvent], CustomerNotificationHandler)\n    builder.services.add_scoped(EventHandler[OrderCompletedEvent], AnalyticsHandler)\n\n    # Controllers\n    builder.services.add_controllers([\n        \"api.controllers.orders_controller\",\n        \"api.controllers.menu_controller\",\n        \"api.controllers.kitchen_controller\"\n    ])\n</code></pre>"},{"location":"old/architecture/#benefits-of-this-architecture","title":"\ud83d\ude80 Benefits of This Architecture","text":""},{"location":"old/architecture/#for-marios-pizzeria-business","title":"For Mario's Pizzeria Business","text":"<ul> <li>Scalability: Can handle increasing order volume by scaling individual layers</li> <li>Maintainability: Business logic changes are isolated to domain layer</li> <li>Testability: Comprehensive testing at every layer ensures reliability</li> <li>Flexibility: Easy to change storage, payment providers, or notification methods</li> <li>Team Productivity: Clear boundaries enable parallel development</li> </ul>"},{"location":"old/architecture/#for-development-teams","title":"For Development Teams","text":"<ul> <li>Clear Responsibilities: Each layer has well-defined purpose and boundaries</li> <li>Technology Independence: Can swap infrastructure without changing business logic</li> <li>Parallel Development: Teams can work on different layers simultaneously</li> <li>Easy Onboarding: New developers understand system through consistent patterns</li> </ul>"},{"location":"old/architecture/#for-long-term-maintenance","title":"For Long-Term Maintenance","text":"<ul> <li>Evolution Support: Architecture supports changing business requirements</li> <li>Technology Updates: Infrastructure can be updated without business logic changes</li> <li>Performance Optimization: Each layer can be optimized independently</li> <li>Monitoring &amp; Debugging: Clear separation aids in troubleshooting issues</li> </ul>"},{"location":"old/architecture/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started Guide - Complete Mario's Pizzeria tutorial</li> <li>CQRS &amp; Mediation - Command and query patterns in depth</li> <li>Dependency Injection - Service registration and DI patterns</li> <li>MVC Controllers - API layer implementation details</li> <li>Data Access - Repository patterns and data persistence</li> <li>Source Code Naming Conventions - Consistent naming across all architectural layers</li> <li>12-Factor App Compliance - Cloud-native architecture principles with framework implementation</li> </ul> <p>This architecture guide demonstrates clean architecture principles using Mario's Pizzeria as a comprehensive example. The layered approach shown here scales from simple applications to complex enterprise systems while maintaining clear separation of concerns and testability.</p>"},{"location":"old/architecture/#application-layer-pizza-business-workflow","title":"\ud83d\udcbc Application Layer: Pizza Business Workflow","text":"<p>Purpose: Orchestrates pizza business operations and workflows</p> <p>Responsibilities:</p> <ul> <li>Command and query handling (CQRS)</li> <li>Business workflow coordination</li> <li>Domain event processing</li> <li>Cross-cutting concerns (logging, validation, caching)</li> </ul> <p>Key Components:</p> <pre><code># src/application/commands/place_order_command.py\n@dataclass\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Command to place a pizza order\"\"\"\n    customer_name: str\n    customer_phone: str\n    customer_address: str\n    pizzas: List[PizzaOrderDto]\n    payment_method: str\n\n# src/application/handlers/place_order_handler.py\nclass PlaceOrderCommandHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    \"\"\"Handles pizza order placement business workflow\"\"\"\n\n    def __init__(self,\n                 order_repository: IOrderRepository,\n                 pizza_repository: IPizzaRepository,\n                 payment_service: IPaymentService,\n                 notification_service: INotificationService,\n                 mapper: Mapper):\n        self.order_repository = order_repository\n        self.pizza_repository = pizza_repository\n        self.payment_service = payment_service\n        self.notification_service = notification_service\n        self.mapper = mapper\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        \"\"\"Execute pizza order placement workflow\"\"\"\n        try:\n            # 1. Validate pizzas are available\n            for pizza_request in command.pizzas:\n                pizza = await self.pizza_repository.get_by_name_async(pizza_request.name)\n                if not pizza or not pizza.is_available:\n                    return self.bad_request(f\"Pizza '{pizza_request.name}' is not available\")\n\n            # 2. Calculate order total using domain logic\n            order = Order.create_new(\n                customer_name=command.customer_name,\n                customer_phone=command.customer_phone,\n                customer_address=command.customer_address,\n                pizzas=command.pizzas,\n                payment_method=command.payment_method\n            )\n\n            # 3. Process payment (integration layer)\n            payment_result = await self.payment_service.process_payment_async(\n                order.total_amount, command.payment_method\n            )\n\n            if not payment_result.is_success:\n                return self.bad_request(\"Payment processing failed\")\n\n            order.mark_payment_processed(payment_result.transaction_id)\n\n            # 4. Save order (integration layer)\n            saved_order = await self.order_repository.save_async(order)\n\n            # 5. Domain event will trigger kitchen notification automatically\n            # (OrderPlacedEvent is raised by Order entity)\n\n            # 6. Send customer confirmation\n            await self.notification_service.send_order_confirmation_async(saved_order)\n\n            # 7. Return success result\n            order_dto = self.mapper.map(saved_order, OrderDto)\n            return self.created(order_dto)\n\n        except Exception as ex:\n            return self.internal_server_error(f\"Failed to place order: {str(ex)}\")\n</code></pre> <p>Architecture Benefits:</p> <ul> <li>Single Responsibility: Each handler has one clear purpose</li> <li>Testability: Easy to unit test handlers with mocked repositories</li> <li>Transaction Management: Clear transaction boundaries</li> <li>Event-Driven: Domain events enable loose coupling</li> </ul>"},{"location":"old/architecture/#domain-layer-pizza-business-logic","title":"\ud83c\udfdb\ufe0f Domain Layer: Pizza Business Logic","text":"<p>Purpose: Contains core pizza business rules and entities</p> <p>Responsibilities:</p> <ul> <li>Business entities with behavior</li> <li>Domain services for complex business logic</li> <li>Domain events for business-significant occurrences</li> <li>Business rule validation and invariants</li> </ul> <p>Key Components:</p> <p>Key Components:</p> <ul> <li>Controllers: Handle HTTP requests and delegate to application layer</li> <li>DTOs: Data Transfer Objects for API contracts</li> <li>Middleware: Cross-cutting concerns like authentication, logging</li> </ul> <p>Example Structure:</p> <pre><code>api/\n\u251c\u2500\u2500 controllers/\n\u2502   \u251c\u2500\u2500 users_controller.py\n\u2502   \u2514\u2500\u2500 orders_controller.py\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 user_dto.py\n\u2502   \u2514\u2500\u2500 order_dto.py\n\u2514\u2500\u2500 middleware/\n    \u251c\u2500\u2500 auth_middleware.py\n    \u2514\u2500\u2500 logging_middleware.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Keep controllers thin - delegate business logic to application layer</li> <li>Use DTOs to define API contracts</li> <li>Validate input at the API boundary</li> <li>Map between DTOs and domain models</li> </ul>"},{"location":"old/architecture/#application-layer-srcapplication","title":"\ud83d\udcbc Application Layer (<code>src/application/</code>)","text":"<p>Purpose: Orchestrates business workflows and coordinates domain operations</p> <p>Responsibilities:</p> <ul> <li>Command and query handling</li> <li>Business workflow orchestration</li> <li>Transaction management</li> <li>Event publishing</li> <li>Application services</li> </ul> <p>Key Components:</p> <ul> <li>Commands: Represent actions that change state</li> <li>Queries: Represent read operations</li> <li>Handlers: Process commands and queries</li> <li>Services: Application-specific business logic</li> </ul> <p>Example Structure:</p> <pre><code>application/\n\u251c\u2500\u2500 commands/\n\u2502   \u251c\u2500\u2500 create_user_command.py\n\u2502   \u2514\u2500\u2500 update_user_command.py\n\u251c\u2500\u2500 queries/\n\u2502   \u251c\u2500\u2500 get_user_query.py\n\u2502   \u2514\u2500\u2500 list_users_query.py\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 user_service.py\n\u2502   \u2514\u2500\u2500 notification_service.py\n\u2514\u2500\u2500 events/\n    \u251c\u2500\u2500 user_created_event.py\n    \u2514\u2500\u2500 user_updated_event.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Each command/query should have a single responsibility</li> <li>Use the mediator pattern to decouple handlers</li> <li>Keep application services focused on coordination</li> <li>Publish domain events for side effects</li> </ul>"},{"location":"old/architecture/#domain-layer-srcdomain","title":"\ud83c\udfdb\ufe0f Domain Layer (<code>src/domain/</code>)","text":"<p>Purpose: Contains the core business logic and rules</p> <p>Responsibilities:</p> <ul> <li>Business entities and aggregates</li> <li>Value objects</li> <li>Domain services</li> <li>Business rules and invariants</li> <li>Domain events</li> </ul> <p>Key Components:</p> <ul> <li>Entities: Objects with identity and lifecycle</li> <li>Value Objects: Immutable objects defined by their attributes</li> <li>Aggregates: Consistency boundaries</li> <li>Domain Services: Business logic that doesn't belong to entities</li> </ul> <p>Example Structure:</p> <pre><code>domain/\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 user.py\n\u2502   \u251c\u2500\u2500 order.py\n\u2502   \u2514\u2500\u2500 address.py\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 pricing_service.py\n\u2502   \u2514\u2500\u2500 validation_service.py\n\u2514\u2500\u2500 events/\n    \u251c\u2500\u2500 user_registered.py\n    \u2514\u2500\u2500 order_placed.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Keep domain models rich with behavior</li> <li>Enforce business invariants</li> <li>Use domain events for decoupling</li> <li>Avoid dependencies on infrastructure</li> </ul>"},{"location":"old/architecture/#integration-layer-srcintegration","title":"\ud83d\udd0c Integration Layer (<code>src/integration/</code>)","text":"<p>Purpose: Handles external integrations and infrastructure concerns</p> <p>Responsibilities:</p> <ul> <li>Database repositories</li> <li>External API clients</li> <li>Message queue integration</li> <li>File system operations</li> <li>Caching</li> </ul> <p>Key Components:</p> <ul> <li>Repositories: Data access implementations</li> <li>API Clients: External service integrations</li> <li>DTOs: External data contracts</li> <li>Infrastructure Services: Technical concerns</li> </ul> <p>Example Structure:</p> <pre><code>integration/\n\u251c\u2500\u2500 repositories/\n\u2502   \u251c\u2500\u2500 user_repository.py\n\u2502   \u2514\u2500\u2500 order_repository.py\n\u251c\u2500\u2500 clients/\n\u2502   \u251c\u2500\u2500 payment_client.py\n\u2502   \u2514\u2500\u2500 email_client.py\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 user_entity.py\n\u2502   \u2514\u2500\u2500 payment_dto.py\n\u2514\u2500\u2500 services/\n    \u251c\u2500\u2500 cache_service.py\n    \u2514\u2500\u2500 file_service.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Implement domain repository interfaces</li> <li>Handle external failures gracefully</li> <li>Use DTOs for external data contracts</li> <li>Isolate infrastructure concerns</li> </ul>"},{"location":"old/architecture/#data-flow","title":"\ud83d\udd04 Data Flow","text":""},{"location":"old/architecture/#command-flow-write-operations","title":"Command Flow (Write Operations)","text":"<ol> <li>Controller receives HTTP request with DTO</li> <li>Controller maps DTO to Command and sends to Mediator</li> <li>Mediator routes Command to appropriate Handler</li> <li>Handler loads domain entities via Repository</li> <li>Handler executes business logic on domain entities</li> <li>Handler saves changes via Repository</li> <li>Handler publishes domain events</li> <li>Handler returns result to Controller</li> <li>Controller maps result to DTO and returns HTTP response</li> </ol> <pre><code>HTTP Request \u2192 Controller \u2192 Command \u2192 Handler \u2192 Domain \u2192 Repository \u2192 Database\n                    \u2193           \u2193        \u2193\n               HTTP Response \u2190 DTO \u2190 Result \u2190 Events\n</code></pre>"},{"location":"old/architecture/#query-flow-read-operations","title":"Query Flow (Read Operations)","text":"<ol> <li>Controller receives HTTP request with parameters</li> <li>Controller creates Query and sends to Mediator</li> <li>Mediator routes Query to appropriate Handler</li> <li>Handler loads data via Repository or Read Model</li> <li>Handler returns data to Controller</li> <li>Controller maps data to DTO and returns HTTP response</li> </ol> <pre><code>HTTP Request \u2192 Controller \u2192 Query \u2192 Handler \u2192 Repository \u2192 Database\n                    \u2193         \u2193       \u2193\n               HTTP Response \u2190 DTO \u2190 Result\n</code></pre>"},{"location":"old/architecture/#patterns-implemented","title":"\ud83c\udfad Patterns Implemented","text":""},{"location":"old/architecture/#1-command-query-responsibility-segregation-cqrs","title":"1. Command Query Responsibility Segregation (CQRS)","text":"<p>Separates read and write operations to optimize performance and scalability:</p> <pre><code># Command (Write)\n@dataclass\nclass CreateUserCommand(Command[OperationResult[UserDto]]):\n    email: str\n    first_name: str\n    last_name: str\n\n# Query (Read)\n@dataclass\nclass GetUserQuery(Query[OperationResult[UserDto]]):\n    user_id: str\n</code></pre>"},{"location":"old/architecture/#2-mediator-pattern","title":"2. Mediator Pattern","text":"<p>Decouples components by routing requests through a central mediator:</p> <pre><code># In controller\nresult = await self.mediator.execute_async(command)\n</code></pre>"},{"location":"old/architecture/#3-repository-pattern","title":"3. Repository Pattern","text":"<p>Abstracts data access and provides a consistent interface:</p> <pre><code>class UserRepository(Repository[User, str]):\n    async def add_async(self, user: User) -&gt; User:\n        # Implementation details\n        pass\n</code></pre>"},{"location":"old/architecture/#4-event-sourcing-optional","title":"4. Event Sourcing (Optional)","text":"<p>Stores state changes as events rather than current state:</p> <pre><code>class User(AggregateRoot[str]):\n    def register(self, email: str, name: str):\n        self.apply(UserRegisteredEvent(email, name))\n</code></pre>"},{"location":"old/architecture/#5-dependency-injection","title":"5. Dependency Injection","text":"<p>Manages object creation and dependencies:</p> <pre><code># Automatic registration\nbuilder.services.add_scoped(UserService)\n\n# Resolution\nuser_service = provider.get_required_service(UserService)\n</code></pre>"},{"location":"old/architecture/#testing-architecture","title":"\ud83e\uddea Testing Architecture","text":"<p>The layered architecture makes testing straightforward:</p>"},{"location":"old/architecture/#unit-tests","title":"Unit Tests","text":"<p>Test individual components in isolation:</p> <pre><code>def test_user_registration():\n    # Arrange\n    command = CreateUserCommand(\"test@example.com\", \"John\", \"Doe\")\n    handler = CreateUserCommandHandler(mock_repository)\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n</code></pre>"},{"location":"old/architecture/#integration-tests","title":"Integration Tests","text":"<p>Test interactions between layers:</p> <pre><code>def test_create_user_endpoint():\n    # Test API \u2192 Application \u2192 Domain integration\n    response = test_client.post(\"/api/v1/users\", json=user_data)\n    assert response.status_code == 201\n</code></pre>"},{"location":"old/architecture/#architecture-tests","title":"Architecture Tests","text":"<p>Verify architectural constraints:</p> <pre><code>def test_domain_has_no_infrastructure_dependencies():\n    # Ensure domain layer doesn't depend on infrastructure\n    domain_modules = get_domain_modules()\n    for module in domain_modules:\n        assert not has_infrastructure_imports(module)\n</code></pre>"},{"location":"old/architecture/#benefits","title":"\ud83d\ude80 Benefits","text":""},{"location":"old/architecture/#maintainability","title":"Maintainability","text":"<ul> <li>Clear boundaries: Each layer has well-defined responsibilities</li> <li>Loose coupling: Changes in one layer don't affect others</li> <li>High cohesion: Related functionality is grouped together</li> </ul>"},{"location":"old/architecture/#testability","title":"Testability","text":"<ul> <li>Isolated testing: Each layer can be tested independently</li> <li>Mock dependencies: External dependencies can be easily mocked</li> <li>Fast tests: Business logic tests don't require infrastructure</li> </ul>"},{"location":"old/architecture/#scalability","title":"Scalability","text":"<ul> <li>CQRS: Read and write models can be optimized separately</li> <li>Event-driven: Asynchronous processing for better performance</li> <li>Microservice ready: Clear boundaries make extraction easier</li> </ul>"},{"location":"old/architecture/#flexibility","title":"Flexibility","text":"<ul> <li>Technology agnostic: Swap implementations without affecting business logic</li> <li>Framework independence: Business logic isn't tied to web framework</li> <li>Future-proof: Architecture adapts to changing requirements</li> </ul>"},{"location":"patterns/","title":"\ud83c\udfaf Architecture Patterns","text":"<p>Architecture patterns form the foundation of maintainable, scalable software systems. The Neuroglia framework implements and promotes proven architectural patterns that support clean code principles, testability, and long-term maintainability.</p>"},{"location":"patterns/#pattern-overview","title":"\ud83c\udfdb\ufe0f Pattern Overview","text":"Pattern Purpose Key Concepts What You'll Learn Mario's Pizzeria Use Case When to Use \ud83c\udfd7\ufe0f Clean Architecture Foundation pattern that organizes code into layers with clear dependency rules \u2022 Domain-driven layer separation\u2022 Dependency inversion principle\u2022 Business logic isolation\u2022 Infrastructure abstraction \u2022 Four-layer architecture implementation\u2022 Dependency flow and injection patterns\u2022 Domain entity design with business logic\u2022 Integration layer abstraction Order processing across API, Application, Domain, and Integration layers All applications - structural foundation \ud83c\udfdb\ufe0f Domain Driven Design Core domain abstractions and patterns for rich business models with event-driven capabilities \u2022 Rich domain entities with business logic\u2022 Aggregate roots and consistency boundaries\u2022 Domain events and integration events\u2022 Event sourcing vs traditional approaches \u2022 Entity and aggregate root implementation\u2022 Domain event design and handling\u2022 Transaction flows with multiple events\u2022 Data flow across architectural layers Pizza orders with business rules, events, and cross-layer data flow Complex business domains, rich models \ud83d\udc89 Dependency Injection Manages object dependencies and lifecycle through inversion of control patterns \u2022 Service registration and resolution\u2022 Lifetime management patterns\u2022 Constructor injection\u2022 Interface-based abstractions \u2022 Service container configuration\u2022 Lifetime scope patterns\u2022 Testing with mock dependencies\u2022 Clean dependency management PizzeriaService dependencies managed through DI container Complex dependency graphs, testability \ud83d\udce1 CQRS &amp; Mediation Separates read/write operations with mediator pattern for decoupled request handling \u2022 Command/Query separation\u2022 Mediator request routing\u2022 Pipeline behaviors\u2022 Handler-based processing \u2022 Command and query handler implementation\u2022 Mediation pattern usage\u2022 Cross-cutting concerns via behaviors\u2022 Event integration with CQRS PlaceOrderCommand vs GetOrderQuery with mediator routing Complex business logic, high-scale systems \ud83d\udd04 Event-Driven Architecture Implements reactive systems using domain events and event handlers \u2022 Domain event patterns\u2022 Event handlers and workflows\u2022 Asynchronous processing\u2022 System decoupling \u2022 Domain event design and publishing\u2022 Event handler implementation\u2022 Kitchen workflow automation\u2022 CloudEvents integration OrderPlaced \u2192 Kitchen processing \u2192 OrderReady \u2192 Customer notification Loose coupling, reactive workflows \ud83c\udfaf Event Sourcing Stores state changes as immutable events for complete audit trails and temporal queries \u2022 Event-based persistence\u2022 Aggregate state reconstruction\u2022 Temporal queries\u2022 Event replay capabilities \u2022 Event-sourced aggregate design\u2022 Event store integration\u2022 Read model projections\u2022 Business intelligence from events Order lifecycle tracked through immutable events with full history Audit requirements, temporal analysis \ud83c\udf0a Reactive Programming Enables asynchronous event-driven architectures using Observable streams \u2022 Observable stream patterns\u2022 Asynchronous event processing\u2022 Stream transformations\u2022 Background service integration \u2022 RxPY integration patterns\u2022 Stream processing and subscription\u2022 Real-time data flows\u2022 Background service implementation Real-time order tracking and kitchen capacity monitoring Real-time systems, high-throughput events \ud83d\udcbe Repository Pattern Abstracts data access logic with multiple storage implementations \u2022 Data access abstraction\u2022 Storage implementation flexibility\u2022 Consistent query interfaces\u2022 Testing with mock repositories \u2022 Repository interface design\u2022 Multiple storage backend implementation\u2022 Async data access patterns\u2022 Repository testing strategies OrderRepository with File, MongoDB, and InMemory implementations Data persistence, testability \ud83c\udf10 Resource-Oriented Architecture Resource-oriented design principles for building RESTful APIs and resource-centric applications \u2022 Resource identification and modeling\u2022 RESTful API design principles\u2022 HTTP verb mapping and semantics\u2022 Resource lifecycle management \u2022 Resource-oriented design principles\u2022 RESTful API architecture patterns\u2022 HTTP protocol integration\u2022 Resource state management Orders, Menu, Kitchen as REST resources with full CRUD operations RESTful APIs, microservices \ud83d\udc40 Watcher &amp; Reconciliation Patterns Kubernetes-inspired patterns for watching resource changes and implementing reconciliation loops \u2022 Resource state observation\u2022 Reconciliation loop patterns\u2022 Event-driven state management\u2022 Declarative resource management \u2022 Resource watching implementation\u2022 Reconciliation loop design\u2022 Event-driven update patterns\u2022 State synchronization strategies Kitchen capacity monitoring and order queue reconciliation Reactive systems, state synchronization \u26a1 Watcher &amp; Reconciliation Execution Execution engine for watcher and reconciliation patterns with error handling and monitoring \u2022 Execution orchestration\u2022 Error handling and recovery\u2022 Performance monitoring\u2022 Reliable state persistence \u2022 Execution pipeline design\u2022 Error handling strategies\u2022 Monitoring and observability\u2022 Performance optimization Automated kitchen workflow execution with retry logic and monitoring Production systems, reliability requirements"},{"location":"patterns/#marios-pizzeria-unified-example","title":"\ud83c\udf55 Mario's Pizzeria: Unified Example","text":"<p>All patterns use Mario's Pizzeria as a consistent domain example, showing how patterns work together in a real-world system:</p> <pre><code>graph TB\n    subgraph \"\ud83c\udfd7\ufe0f Clean Architecture Layers\"\n        API[\ud83c\udf10 API Layer&lt;br/&gt;Controllers &amp; DTOs]\n        APP[\ud83d\udcbc Application Layer&lt;br/&gt;Commands &amp; Queries]\n        DOM[\ud83c\udfdb\ufe0f Domain Layer&lt;br/&gt;Entities &amp; Events]\n        INT[\ud83d\udd0c Integration Layer&lt;br/&gt;Repositories &amp; Services]\n    end\n\n    subgraph \"\ud83d\udce1 CQRS Implementation\"\n        CMD[Commands&lt;br/&gt;PlaceOrder, StartCooking]\n        QRY[Queries&lt;br/&gt;GetOrder, GetMenu]\n    end\n\n    subgraph \"\ud83d\udd04 Event-Driven Flow\"\n        EVT[Domain Events&lt;br/&gt;OrderPlaced, OrderReady]\n        HDL[Event Handlers&lt;br/&gt;Kitchen, Notifications]\n    end\n\n    subgraph \"\ud83d\udcbe Data Access\"\n        REPO[Repositories&lt;br/&gt;Order, Menu, Customer]\n        STOR[Storage&lt;br/&gt;File, MongoDB, Memory]\n    end\n\n    API --&gt; APP\n    APP --&gt; DOM\n    APP --&gt; INT\n\n    APP --&gt; CMD\n    APP --&gt; QRY\n\n    DOM --&gt; EVT\n    EVT --&gt; HDL\n\n    INT --&gt; REPO\n    REPO --&gt; STOR\n\n    style API fill:#e3f2fd\n    style APP fill:#f3e5f5\n    style DOM fill:#e8f5e8\n    style INT fill:#fff3e0</code></pre>"},{"location":"patterns/#pattern-integration","title":"\ud83d\ude80 Pattern Integration","text":""},{"location":"patterns/#how-patterns-work-together","title":"How Patterns Work Together","text":"Order Pattern Role in System Dependencies Integration Points 1 Clean Architecture Structural foundation None Provides layer structure for all other patterns 2 Dependency Injection Service management foundation Clean Architecture Manages service lifetimes across all layers 3 CQRS &amp; Mediation Application layer organization Clean Architecture, DI Commands/Queries with mediator routing 4 Event-Driven Reactive domain workflows Clean Architecture, CQRS, DI Domain events published by command handlers 5 Event Sourcing Event-based persistence Event-Driven, Repository, DI Events as source of truth with aggregate patterns 6 Reactive Programming Asynchronous stream processing Event-Driven, DI Observable streams for real-time event processing 7 Repository Infrastructure abstraction Clean Architecture, DI Implements Integration layer data access 8 Resource-Oriented API contract definition Clean Architecture, CQRS, DI REST endpoints expose commands/queries 9 Watcher &amp; Reconciliation Reactive resource management Event-Driven, Repository, DI Observes events, updates via repositories"},{"location":"patterns/#implementation-order","title":"Implementation Order","text":"<pre><code>flowchart LR\n    A[1. Clean Architecture&lt;br/&gt;\ud83c\udfd7\ufe0f Layer Structure] --&gt; B[2. Dependency Injection&lt;br/&gt;\ud83d\udc89 Service Management]\n    B --&gt; C[3. CQRS &amp; Mediation&lt;br/&gt;\ud83d\udce1 Commands &amp; Queries]\n    C --&gt; D[4. Event-Driven&lt;br/&gt;\ud83d\udd04 Domain Events]\n    D --&gt; E[5. Event Sourcing&lt;br/&gt;\ud83c\udfaf Event Persistence]\n    E --&gt; F[6. Reactive Programming&lt;br/&gt;\ud83c\udf0a Stream Processing]\n    F --&gt; G[7. Repository Pattern&lt;br/&gt;\ud83d\udcbe Data Access]\n    G --&gt; H[8. Resource-Oriented&lt;br/&gt;\ud83c\udf10 API Design]\n    H --&gt; I[9. Watcher Patterns&lt;br/&gt;\ud83d\udc40 Reactive Management]\n\n    style A fill:#e8f5e8\n    style B fill:#f8bbd9\n    style C fill:#e3f2fd\n    style D fill:#fff3e0\n    style E fill:#ffecb5\n    style F fill:#b3e5fc\n    style G fill:#f3e5f5\n    style H fill:#e1f5fe\n    style I fill:#fce4ec</code></pre>"},{"location":"patterns/#business-domain-examples","title":"\ud83c\udfaf Business Domain Examples","text":"Domain Area Pattern Application Implementation Details Benefits Demonstrated \ud83c\udf55 Order Processing Clean Architecture + CQRS + Event Sourcing + DI Complete workflow from placement to delivery with event history Layer separation, mediation routing, audit trails, service management \ud83d\udccb Menu Management Repository + Resource-Oriented + DI Product catalog with pricing and availability via REST API Data abstraction, RESTful design, dependency management \ud83d\udc68\u200d\ud83c\udf73 Kitchen Operations Event-Driven + Reactive Programming + Watcher Patterns Real-time queue management with stream processing Reactive processing, observable streams, state synchronization \ud83d\udcf1 Customer Communications Event-Driven + Reactive Programming Real-time notifications through reactive event streams Stream processing, asynchronous messaging, real-time updates \ud83d\udcb3 Payment Processing Clean Architecture + Repository + DI External service integration with proper abstraction Infrastructure abstraction, testability, service integration \ud83d\udcca Analytics &amp; Reporting Event Sourcing + Reactive Programming Business intelligence from event streams with real-time views Temporal queries, stream aggregation, historical analysis"},{"location":"patterns/#testing-strategies","title":"\ud83e\uddea Testing Strategies","text":"Testing Type Scope Pattern Focus Tools &amp; Techniques Example Scenarios \ud83d\udd2c Unit Testing Individual components All patterns with isolated mocks pytest, Mock objects, dependency injection Test OrderEntity business logic, Command handlers \ud83d\udd17 Integration Testing Cross-layer interactions Clean Architecture layer communication TestClient, database containers Test API \u2192 Application \u2192 Domain flow \ud83c\udf10 End-to-End Testing Complete workflows Full pattern integration Automated scenarios, real dependencies Complete pizza order workflow validation \u26a1 Performance Testing Scalability validation CQRS read optimization, Event throughput Load testing, metrics collection Query performance, event processing rates"},{"location":"patterns/#pattern-learning-paths","title":"\ud83d\udcda Pattern Learning Paths","text":"Level Focus Area Recommended Patterns Learning Objectives Practical Outcomes \ud83c\udf31 Beginner Foundation &amp; Structure 1. Clean Architecture2. Domain Driven Design3. Dependency Injection4. Repository Pattern \u2022 Layer separation principles\u2022 Rich domain model design\u2022 Service lifetime management\u2022 Data access abstraction Pizza ordering system with rich domain models and proper DI \ud83d\ude80 Intermediate Separation &amp; Optimization 1. CQRS &amp; Mediation2. Event-Driven Architecture3. Resource-Oriented Architecture \u2022 Read/write operation separation\u2022 Mediator pattern usage\u2022 Event-driven workflows\u2022 RESTful API design Scalable pizza API with command/query separation and events \u26a1 Advanced Reactive &amp; Distributed 1. Event Sourcing2. Reactive Programming3. Watcher &amp; Reconciliation \u2022 Event-based persistence\u2022 Stream processing patterns\u2022 Reactive system design\u2022 State reconciliation strategies Complete event-sourced pizzeria with real-time capabilities"},{"location":"patterns/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\ud83d\ude80 Framework Features - Implementation-specific features</li> <li>\ud83d\udcd6 Implementation Guides - Step-by-step tutorials</li> <li>\ud83c\udf55 Mario's Pizzeria - Complete system example</li> <li>\ud83d\udcbc Sample Applications - Production-ready examples</li> <li>\ud83d\udd10 OAuth, OIDC &amp; JWT - Authentication and authorization patterns</li> </ul> <p>These patterns form the architectural foundation for building maintainable, testable, and scalable applications. Each pattern page includes detailed code examples, Mermaid diagrams, and practical implementation guidance using the Mario's Pizzeria domain.</p>"},{"location":"patterns/clean-architecture/","title":"\ud83c\udfd7\ufe0f Clean Architecture Pattern","text":"<p>\ud83d\udea7 Under Construction</p> <p>This page is currently being developed with comprehensive examples from Mario's Pizzeria. More detailed implementations and code samples are being added.</p> <p>The Clean Architecture pattern enforces a layered approach where dependencies only flow inward, ensuring testability, maintainability, and independence from external concerns.</p>"},{"location":"patterns/clean-architecture/#understanding-clean-architecture","title":"\ud83c\udf93 Understanding Clean Architecture","text":"<p>Before diving into code, it's helpful to understand the architectural principles that guide Neuroglia:</p>"},{"location":"patterns/clean-architecture/#the-dependency-rule","title":"The Dependency Rule","text":"<pre><code>graph TD\n    A[\ud83c\udf10 API Layer&lt;br/&gt;Controllers, DTOs] --&gt; B[\ud83d\udcbc Application Layer&lt;br/&gt;Commands, Queries, Handlers]\n    B --&gt; C[\ud83c\udfdb\ufe0f Domain Layer&lt;br/&gt;Entities, Business Rules]\n    D[\ud83d\udd0c Integration Layer&lt;br/&gt;Repositories, External APIs] --&gt; C\n\n    style C fill:#e1f5fe\n    style B fill:#f3e5f5\n    style A fill:#e8f5e8\n    style D fill:#fff3e0</code></pre> <p>Key principle: Inner layers never depend on outer layers. This enables:</p> <ul> <li>Testability - Easy to mock external dependencies</li> <li>Flexibility - Swap implementations without affecting business logic</li> <li>Maintainability - Changes in infrastructure don't break business rules</li> <li>Domain Focus - Business logic stays pure and framework-agnostic</li> </ul>"},{"location":"patterns/clean-architecture/#cqrs-in-practice","title":"CQRS in Practice","text":"<pre><code>graph LR\n    A[Client Request] --&gt; B{Command or Query?}\n    B --&gt;|Write Operation| C[Command Handler]\n    B --&gt;|Read Operation| D[Query Handler]\n    C --&gt; E[Domain Logic]\n    E --&gt; F[Repository]\n    D --&gt; G[Read Model]\n\n    style C fill:#ffcdd2\n    style D fill:#c8e6c9\n    style E fill:#e1f5fe</code></pre> <p>Commands (Write): Create, Update, Delete operations that change system state Queries (Read): Retrieve operations that return data without side effects</p> <p>This separation enables:</p> <ul> <li>Performance Optimization - Different models for reads vs writes</li> <li>Scalability - Scale read and write operations independently</li> <li>Clarity - Clear intent whether operation changes state</li> <li>Event Sourcing - Natural fit for event-driven architectures</li> </ul>"},{"location":"patterns/clean-architecture/#overview","title":"\ud83c\udfaf Overview","text":"<p>Clean Architecture organizes code into four distinct layers, with the Mario's Pizzeria system serving as our primary example of how this pattern enables scalable, maintainable applications.</p> <pre><code>C4Container\n    title Clean Architecture - Mario's Pizzeria System\n\n    Container_Boundary(api, \"\ud83c\udf10 API Layer\") {\n        Container(orders_controller, \"Orders Controller\", \"FastAPI\", \"REST endpoints for pizza orders\")\n        Container(menu_controller, \"Menu Controller\", \"FastAPI\", \"Menu management and retrieval\")\n        Container(kitchen_controller, \"Kitchen Controller\", \"FastAPI\", \"Kitchen workflow management\")\n    }\n\n    Container_Boundary(app, \"\ud83d\udcbc Application Layer\") {\n        Container(mediator, \"Mediator\", \"CQRS\", \"Command/Query routing\")\n        Container(handlers, \"Command/Query Handlers\", \"Business Logic\", \"Order processing, menu queries\")\n        Container(pipeline, \"Pipeline Behaviors\", \"Cross-cutting\", \"Validation, logging, caching\")\n    }\n\n    Container_Boundary(domain, \"\ud83c\udfdb\ufe0f Domain Layer\") {\n        Container(entities, \"Pizza Entities\", \"Domain Models\", \"Order, Pizza, Customer entities\")\n        Container(events, \"Domain Events\", \"Business Events\", \"OrderPlaced, PizzaReady events\")\n        Container(rules, \"Business Rules\", \"Domain Logic\", \"Pricing, validation rules\")\n    }\n\n    Container_Boundary(integration, \"\ud83d\udd0c Integration Layer\") {\n        Container(repos, \"Repositories\", \"Data Access\", \"Order, Menu data persistence\")\n        Container(external, \"External Services\", \"Third-party\", \"Payment, SMS notifications\")\n        Container(storage, \"Data Storage\", \"Persistence\", \"MongoDB, File System\")\n    }\n\n    Rel(orders_controller, mediator, \"sends commands/queries\")\n    Rel(menu_controller, mediator, \"sends queries\")\n    Rel(kitchen_controller, mediator, \"sends commands\")\n\n    Rel(mediator, handlers, \"routes to\")\n    Rel(handlers, entities, \"uses\")\n    Rel(handlers, events, \"publishes\")\n\n    Rel(handlers, repos, \"persists via\")\n    Rel(repos, storage, \"stores in\")\n    Rel(handlers, external, \"integrates with\")</code></pre>"},{"location":"patterns/clean-architecture/#benefits","title":"\u2705 Benefits","text":""},{"location":"patterns/clean-architecture/#1-testability","title":"1. Testability","text":"<p>Each layer can be tested independently using mocks and stubs:</p> <pre><code># Testing Order Handler without database dependencies\nclass TestPlaceOrderHandler:\n    def setup_method(self):\n        self.mock_repository = Mock(spec=OrderRepository)\n        self.mock_payment = Mock(spec=PaymentService)\n        self.handler = PlaceOrderHandler(self.mock_repository, self.mock_payment)\n\n    async def test_place_order_success(self):\n        # Arrange\n        command = PlaceOrderCommand(customer_id=\"123\", pizzas=[\"margherita\"])\n\n        # Act\n        result = await self.handler.handle_async(command)\n\n        # Assert\n        assert result.is_success\n        self.mock_repository.save_async.assert_called_once()\n</code></pre>"},{"location":"patterns/clean-architecture/#2-independence","title":"2. Independence","text":"<p>Business logic in the domain layer is completely independent of frameworks, databases, and external services.</p>"},{"location":"patterns/clean-architecture/#3-maintainability","title":"3. Maintainability","text":"<p>Changes to external systems (databases, APIs) don't affect business logic.</p>"},{"location":"patterns/clean-architecture/#data-flow","title":"\ud83d\udd04 Data Flow","text":"<p>The pizza ordering workflow demonstrates clean architecture data flow:</p> <pre><code>sequenceDiagram\n    participant Customer\n    participant API as OrdersController\n    participant Med as Mediator\n    participant Handler as PlaceOrderHandler\n    participant Domain as Order Entity\n    participant Repo as OrderRepository\n    participant DB as MongoDB\n\n    Customer-&gt;&gt;+API: POST /orders (pizza order)\n    Note over API: \ud83c\udf10 API Layer - HTTP endpoint\n\n    API-&gt;&gt;+Med: Execute PlaceOrderCommand\n    Note over Med: \ud83d\udcbc Application Layer - CQRS routing\n\n    Med-&gt;&gt;+Handler: Handle command\n    Note over Handler: \ud83d\udcbc Application Layer - Business workflow\n\n    Handler-&gt;&gt;+Domain: Create Order entity\n    Note over Domain: \ud83c\udfdb\ufe0f Domain Layer - Business rules\n    Domain--&gt;&gt;-Handler: Order with domain events\n\n    Handler-&gt;&gt;+Repo: Save order\n    Note over Repo: \ud83d\udd0c Integration Layer - Data access\n    Repo-&gt;&gt;+DB: Insert document\n    Note over DB: \ud83d\udd0c Integration Layer - Persistence\n    DB--&gt;&gt;-Repo: Success\n    Repo--&gt;&gt;-Handler: Order saved\n\n    Handler--&gt;&gt;-Med: OrderDto result\n    Med--&gt;&gt;-API: Success response\n    API--&gt;&gt;-Customer: 201 Created + OrderDto</code></pre>"},{"location":"patterns/clean-architecture/#use-cases","title":"\ud83c\udfaf Use Cases","text":"<p>Clean Architecture is ideal for:</p> <ul> <li>Complex Business Logic: When domain rules are intricate (pricing, promotions, kitchen workflows)</li> <li>Multiple Interfaces: Supporting web APIs, mobile apps, and admin panels</li> <li>Long-term Maintenance: Systems that need to evolve over time</li> <li>Team Collaboration: Clear boundaries enable parallel development</li> </ul>"},{"location":"patterns/clean-architecture/#implementation-in-marios-pizzeria","title":"\ud83c\udf55 Implementation in Mario's Pizzeria","text":""},{"location":"patterns/clean-architecture/#domain-layer-core-business","title":"Domain Layer (Core Business)","text":"<pre><code># domain/entities/order.py\nclass Order(Entity):\n    def __init__(self, customer_id: str, items: List[OrderItem]):\n        super().__init__()\n        self.customer_id = customer_id\n        self.items = items\n        self.status = OrderStatus.PENDING\n        self.total = self._calculate_total()\n\n        # Domain event for business workflow\n        self.raise_event(OrderPlacedEvent(\n            order_id=self.id,\n            customer_id=customer_id,\n            total=self.total\n        ))\n\n    def _calculate_total(self) -&gt; Decimal:\n        \"\"\"Business rule: Calculate order total with tax\"\"\"\n        subtotal = sum(item.price for item in self.items)\n        tax = subtotal * Decimal('0.08')  # 8% tax\n        return subtotal + tax\n</code></pre>"},{"location":"patterns/clean-architecture/#application-layer-use-cases","title":"Application Layer (Use Cases)","text":"<pre><code># application/handlers/place_order_handler.py\nclass PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    def __init__(self,\n                 order_repository: OrderRepository,\n                 payment_service: PaymentService,\n                 mapper: Mapper):\n        self._repository = order_repository\n        self._payment = payment_service\n        self._mapper = mapper\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        # Create domain entity (business logic)\n        order = Order(command.customer_id, command.items)\n\n        # Process payment (external integration)\n        payment_result = await self._payment.process_async(order.total)\n        if not payment_result.success:\n            return self.bad_request(\"Payment failed\")\n\n        # Persist order (data access)\n        await self._repository.save_async(order)\n\n        # Return result\n        dto = self._mapper.map(order, OrderDto)\n        return self.created(dto)\n</code></pre>"},{"location":"patterns/clean-architecture/#api-layer-interface","title":"API Layer (Interface)","text":"<pre><code># api/controllers/orders_controller.py\nclass OrdersController(ControllerBase):\n    @post(\"/\", response_model=OrderDto, status_code=201)\n    async def place_order(self, request: PlaceOrderRequest) -&gt; OrderDto:\n        command = self.mapper.map(request, PlaceOrderCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"patterns/clean-architecture/#integration-layer-external-concerns","title":"Integration Layer (External Concerns)","text":"<pre><code># integration/repositories/mongo_order_repository.py\nclass MongoOrderRepository(Repository[Order, str]):\n    def __init__(self, collection: Collection):\n        self._collection = collection\n\n    async def save_async(self, order: Order) -&gt; None:\n        document = {\n            \"_id\": order.id,\n            \"customer_id\": order.customer_id,\n            \"items\": [{\"name\": item.name, \"price\": float(item.price)}\n                     for item in order.items],\n            \"total\": float(order.total),\n            \"status\": order.status.value\n        }\n        await self._collection.insert_one(document)\n</code></pre>"},{"location":"patterns/clean-architecture/#related-patterns","title":"\ud83d\udd17 Related Patterns","text":"<ul> <li>CQRS Pattern - Separates commands and queries within the application layer</li> <li>Event-Driven Pattern - Uses domain events for decoupled communication</li> <li>Repository Pattern - Abstracts data access in the integration layer</li> </ul> <p>This pattern guide demonstrates Clean Architecture using Mario's Pizzeria as a practical example. The four-layer approach shown here scales from simple applications to complex enterprise systems. \ud83c\udfd7\ufe0f</p>"},{"location":"patterns/cqrs/","title":"\ud83c\udfaf CQRS &amp; Mediation Pattern","text":"<p>Command Query Responsibility Segregation (CQRS) with Mediation separates read and write operations into distinct models while using a mediator to decouple application logic and promote clean separation between commands, queries, and their handlers. This pattern combines the scalability benefits of CQRS with the architectural benefits of the mediator pattern.</p>"},{"location":"patterns/cqrs/#overview","title":"\ud83c\udfaf Overview","text":"<p>CQRS divides your application's operations into two distinct paths: Commands for writes (state changes) and Queries for reads (data retrieval). Mario's Pizzeria demonstrates this pattern through its order management and menu systems.</p> <pre><code>flowchart TD\n    Client[Customer/Staff]\n\n    subgraph \"\ud83c\udfaf CQRS Separation\"\n        subgraph Commands[\"\ud83d\udcdd Write Side (Commands)\"]\n            PlaceOrder[PlaceOrderCommand]\n            UpdateMenu[UpdateMenuCommand]\n            ProcessPayment[ProcessPaymentCommand]\n        end\n\n        subgraph Queries[\"\ud83d\udcd6 Read Side (Queries)\"]\n            GetMenu[GetMenuQuery]\n            GetOrder[GetOrderByIdQuery]\n            GetOrderHistory[GetOrderHistoryQuery]\n        end\n    end\n\n    subgraph Mediator[\"\ud83c\udfad Mediator\"]\n        CommandHandlers[Command Handlers]\n        QueryHandlers[Query Handlers]\n    end\n\n    subgraph Storage[\"\ud83d\udcbe Data Storage\"]\n        WriteDB[(Write Database&lt;br/&gt;MongoDB)]\n        ReadDB[(Read Models&lt;br/&gt;Optimized Views)]\n        EventStore[(Event Store&lt;br/&gt;Order History)]\n    end\n\n    Client --&gt;|\"\ud83c\udf55 Place Order\"| PlaceOrder\n    Client --&gt;|\"\ud83d\udccb Get Menu\"| GetMenu\n    Client --&gt;|\"\ud83d\udcca Order Status\"| GetOrder\n\n    PlaceOrder --&gt; CommandHandlers\n    GetMenu --&gt; QueryHandlers\n    GetOrder --&gt; QueryHandlers\n\n    CommandHandlers --&gt;|\"\ud83d\udcbe Persist\"| WriteDB\n    CommandHandlers --&gt;|\"\ud83d\udce1 Events\"| EventStore\n    QueryHandlers --&gt;|\"\ud83d\udd0d Read\"| ReadDB\n\n    WriteDB -.-&gt;|\"\ud83d\udd04 Sync\"| ReadDB\n    EventStore -.-&gt;|\"\ud83d\udcc8 Project\"| ReadDB</code></pre>"},{"location":"patterns/cqrs/#mediation-pattern-integration","title":"\ud83c\udfad Mediation Pattern Integration","text":"<p>The mediation layer provides centralized request routing and cross-cutting concerns:</p> <ul> <li>Mediator: Central dispatcher that routes commands, queries, and events to appropriate handlers</li> <li>Pipeline Behaviors: Cross-cutting concerns like validation, logging, caching, and transactions</li> <li>Handler Discovery: Automatic registration and resolution of command/query handlers</li> <li>Event Publishing: Automatic dispatch of domain events to registered event handlers</li> </ul>"},{"location":"patterns/cqrs/#mediator-architecture","title":"Mediator Architecture","text":"<pre><code>flowchart TD\n    Controller[\ud83c\udfae Controller]\n    Mediator[\ud83c\udfad Mediator]\n\n    subgraph \"\ud83d\udccb Pipeline Behaviors\"\n        Validation[\u2705 Validation]\n        Logging[\ud83d\udcdd Logging]\n        Caching[\ud83d\udcbe Caching]\n        Transaction[\ud83d\udd04 Transaction]\n    end\n\n    subgraph \"\ud83c\udfaf Handlers\"\n        CommandHandler[\ud83d\udcdd Command Handler]\n        QueryHandler[\ud83d\udcd6 Query Handler]\n        EventHandler[\ud83d\udce1 Event Handler]\n    end\n\n    subgraph \"\ud83d\udcbe Infrastructure\"\n        Database[(\ud83d\uddc4\ufe0f Database)]\n        EventStore[(\ud83d\udcda Event Store)]\n        Cache[(\u26a1 Cache)]\n    end\n\n    Controller --&gt; Mediator\n    Mediator --&gt; Validation\n    Validation --&gt; Logging\n    Logging --&gt; Caching\n    Caching --&gt; Transaction\n\n    Transaction --&gt; CommandHandler\n    Transaction --&gt; QueryHandler\n    CommandHandler --&gt; EventHandler\n\n    CommandHandler --&gt; Database\n    QueryHandler --&gt; Database\n    EventHandler --&gt; EventStore\n    QueryHandler --&gt; Cache</code></pre>"},{"location":"patterns/cqrs/#benefits","title":"\u2705 Benefits","text":""},{"location":"patterns/cqrs/#1-optimized-performance","title":"1. Optimized Performance","text":"<p>Different models for reads and writes enable performance optimization:</p> <pre><code># Write Model - Normalized for consistency\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    customer_id: str\n    items: List[OrderItemDto]\n    delivery_address: AddressDto\n    payment_method: PaymentMethodDto\n\n# Read Model - Denormalized for speed\nclass OrderSummaryDto:\n    order_id: str\n    customer_name: str  # Denormalized\n    total_amount: Decimal\n    status: str\n    estimated_delivery: datetime\n    items_count: int  # Pre-calculated\n</code></pre>"},{"location":"patterns/cqrs/#2-independent-scaling","title":"2. Independent Scaling","text":"<p>Read and write sides can scale independently based on usage patterns:</p> <pre><code># Heavy read operations don't impact write performance\nclass GetPopularPizzasQuery(Query[List[PopularPizzaDto]]):\n    time_period: str = \"last_30_days\"\n    limit: int = 10\n\n# Complex writes don't slow down simple reads\nclass ProcessOrderWorkflowCommand(Command[OperationResult]):\n    order_id: str\n    # Complex business logic with multiple validations\n</code></pre>"},{"location":"patterns/cqrs/#3-clear-separation-of-concerns","title":"3. Clear Separation of Concerns","text":"<p>Commands handle business logic while queries focus on data presentation.</p>"},{"location":"patterns/cqrs/#data-flow","title":"\ud83d\udd04 Data Flow","text":"<p>The pizza ordering process demonstrates CQRS data flow:</p> <pre><code>sequenceDiagram\n    participant Customer\n    participant API as API Controller\n    participant Med as Mediator\n    participant CH as Command Handler\n    participant QH as Query Handler\n    participant WDB as Write DB\n    participant RDB as Read DB\n    participant ES as Event Store\n\n    Note over Customer,ES: \ud83d\udcdd Command Flow (Write)\n    Customer-&gt;&gt;+API: Place Pizza Order\n    API-&gt;&gt;+Med: PlaceOrderCommand\n    Med-&gt;&gt;+CH: Route to handler\n\n    CH-&gt;&gt;CH: Validate business rules\n    CH-&gt;&gt;+WDB: Save normalized order\n    WDB--&gt;&gt;-CH: Order persisted\n\n    CH-&gt;&gt;+ES: Store OrderPlacedEvent\n    ES--&gt;&gt;-CH: Event saved\n\n    CH--&gt;&gt;-Med: Success result\n    Med--&gt;&gt;-API: OrderDto\n    API--&gt;&gt;-Customer: 201 Created\n\n    Note over Customer,ES: \ud83d\udcd6 Query Flow (Read)\n    Customer-&gt;&gt;+API: Get Order Status\n    API-&gt;&gt;+Med: GetOrderByIdQuery\n    Med-&gt;&gt;+QH: Route to handler\n\n    QH-&gt;&gt;+RDB: Read denormalized view\n    RDB--&gt;&gt;-QH: Order summary\n\n    QH--&gt;&gt;-Med: OrderSummaryDto\n    Med--&gt;&gt;-API: Result\n    API--&gt;&gt;-Customer: 200 OK\n\n    Note over WDB,RDB: \ud83d\udd04 Background Sync\n    ES-&gt;&gt;RDB: Project events to read models\n    WDB-&gt;&gt;RDB: Sync latest changes</code></pre>"},{"location":"patterns/cqrs/#use-cases","title":"\ud83c\udfaf Use Cases","text":"<p>CQRS is particularly effective for:</p> <ul> <li>High-Traffic Applications: Different read/write performance requirements</li> <li>Complex Business Logic: Commands handle intricate workflows</li> <li>Reporting Systems: Optimized read models for analytics</li> <li>Event-Driven Systems: Natural fit with event sourcing</li> </ul>"},{"location":"patterns/cqrs/#implementation-in-marios-pizzeria","title":"\ud83c\udf55 Implementation in Mario's Pizzeria","text":""},{"location":"patterns/cqrs/#commands-write-operations","title":"Commands (Write Operations)","text":"<pre><code># Command: Place a pizza order\n@dataclass\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    customer_id: str\n    pizzas: List[PizzaSelectionDto]\n    delivery_address: str\n    payment_method: str\n    special_instructions: Optional[str] = None\n\nclass PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    def __init__(self,\n                 order_repository: OrderRepository,\n                 payment_service: PaymentService,\n                 inventory_service: InventoryService):\n        self._order_repo = order_repository\n        self._payment = payment_service\n        self._inventory = inventory_service\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        try:\n            # 1. Validate business rules\n            if not await self._inventory.check_availability(command.pizzas):\n                return self.bad_request(\"Some pizzas are not available\")\n\n            # 2. Create domain entity\n            order = Order.create(\n                customer_id=command.customer_id,\n                pizzas=command.pizzas,\n                delivery_address=command.delivery_address\n            )\n\n            # 3. Process payment\n            payment_result = await self._payment.charge_async(\n                order.total, command.payment_method\n            )\n            if not payment_result.success:\n                return self.bad_request(\"Payment failed\")\n\n            # 4. Persist order\n            await self._order_repo.save_async(order)\n\n            # 5. Return result\n            dto = self.mapper.map(order, OrderDto)\n            return self.created(dto)\n\n        except Exception as ex:\n            return self.internal_server_error(f\"Order placement failed: {str(ex)}\")\n</code></pre>"},{"location":"patterns/cqrs/#queries-read-operations","title":"Queries (Read Operations)","text":"<pre><code># Query: Get menu with pricing\n@dataclass\nclass GetMenuQuery(Query[List[MenuItemDto]]):\n    category: Optional[str] = None\n    include_unavailable: bool = False\n\nclass GetMenuHandler(QueryHandler[GetMenuQuery, List[MenuItemDto]]):\n    def __init__(self, menu_read_repository: MenuReadRepository):\n        self._menu_repo = menu_read_repository\n\n    async def handle_async(self, query: GetMenuQuery) -&gt; List[MenuItemDto]:\n        # Optimized read from denormalized menu view\n        menu_items = await self._menu_repo.get_menu_items_async(\n            category=query.category,\n            include_unavailable=query.include_unavailable\n        )\n\n        return [self.mapper.map(item, MenuItemDto) for item in menu_items]\n\n# Query: Get order history with analytics\n@dataclass\nclass GetOrderHistoryQuery(Query[OrderHistoryDto]):\n    customer_id: str\n    page: int = 1\n    page_size: int = 10\n\nclass GetOrderHistoryHandler(QueryHandler[GetOrderHistoryQuery, OrderHistoryDto]):\n    async def handle_async(self, query: GetOrderHistoryQuery) -&gt; OrderHistoryDto:\n        # Read from optimized history view with pre-calculated stats\n        history = await self._order_read_repo.get_customer_history_async(\n            customer_id=query.customer_id,\n            page=query.page,\n            page_size=query.page_size\n        )\n\n        return OrderHistoryDto(\n            orders=history.orders,\n            total_orders=history.total_count,\n            total_spent=history.lifetime_value,  # Pre-calculated\n            favorite_pizzas=history.top_pizzas,  # Pre-calculated\n            page=query.page,\n            page_size=query.page_size\n        )\n</code></pre>"},{"location":"patterns/cqrs/#controller-integration","title":"Controller Integration","text":"<pre><code># Controllers use mediator to route commands and queries\nclass OrdersController(ControllerBase):\n\n    @post(\"/\", response_model=OrderDto, status_code=201)\n    async def place_order(self, request: PlaceOrderRequest) -&gt; OrderDto:\n        # Route to command handler\n        command = self.mapper.map(request, PlaceOrderCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @get(\"/{order_id}\", response_model=OrderDto)\n    async def get_order(self, order_id: str) -&gt; OrderDto:\n        # Route to query handler\n        query = GetOrderByIdQuery(order_id=order_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/\", response_model=List[OrderSummaryDto])\n    async def get_orders(self,\n                        customer_id: Optional[str] = None,\n                        status: Optional[str] = None) -&gt; List[OrderSummaryDto]:\n        # Route to query handler with filters\n        query = GetOrdersQuery(customer_id=customer_id, status=status)\n        result = await self.mediator.execute_async(query)\n        return result\n</code></pre>"},{"location":"patterns/cqrs/#read-model-optimization","title":"Read Model Optimization","text":"<pre><code># Optimized read models for different use cases\nclass OrderSummaryDto:\n    \"\"\"Lightweight order summary for lists\"\"\"\n    order_id: str\n    customer_name: str  # Denormalized\n    total: Decimal\n    status: OrderStatus\n    order_date: datetime\n    estimated_delivery: datetime\n\nclass OrderDetailDto:\n    \"\"\"Complete order details for single order view\"\"\"\n    order_id: str\n    customer: CustomerDto  # Full customer details\n    items: List[OrderItemDetailDto]  # Expanded item details\n    payment: PaymentDetailDto\n    delivery: DeliveryDetailDto\n    timeline: List[OrderEventDto]  # Order history\n    total_breakdown: OrderTotalDto  # Tax, discounts, etc.\n</code></pre>"},{"location":"patterns/cqrs/#testing-cqrs","title":"\ud83e\uddea Testing CQRS","text":"<pre><code># Test commands and queries separately\nclass TestPlaceOrderCommand:\n    async def test_place_order_success(self):\n        # Arrange\n        handler = PlaceOrderHandler(mock_repo, mock_payment, mock_inventory)\n        command = PlaceOrderCommand(\n            customer_id=\"123\",\n            pizzas=[PizzaSelectionDto(name=\"Margherita\", size=\"Large\")]\n        )\n\n        # Act\n        result = await handler.handle_async(command)\n\n        # Assert\n        assert result.is_success\n        mock_repo.save_async.assert_called_once()\n\nclass TestGetMenuQuery:\n    async def test_get_menu_filters_by_category(self):\n        # Arrange\n        handler = GetMenuHandler(mock_read_repo)\n        query = GetMenuQuery(category=\"Pizza\")\n\n        # Act\n        result = await handler.handle_async(query)\n\n        # Assert\n        assert len(result) &gt; 0\n        assert all(item.category == \"Pizza\" for item in result)\n</code></pre>"},{"location":"patterns/cqrs/#related-patterns","title":"\ud83d\udd17 Related Patterns","text":"<ul> <li>Clean Architecture - CQRS fits naturally in the application layer</li> <li>Event-Driven Pattern - Commands often produce events</li> <li>Repository Pattern - Separate repositories for reads and writes</li> </ul>"},{"location":"patterns/cqrs/#handler-implementation-patterns","title":"\ud83c\udfaa Handler Implementation Patterns","text":""},{"location":"patterns/cqrs/#command-handlers-with-business-logic","title":"Command Handlers with Business Logic","text":"<pre><code>from neuroglia.mediation.mediator import CommandHandler\nfrom neuroglia.mapping.mapper import Mapper\nfrom neuroglia.data.abstractions import Repository\nfrom decimal import Decimal\n\nclass PlaceOrderCommandHandler(CommandHandler[PlaceOrderCommand, OperationResult]):\n    \"\"\"Handles pizza order placement with full business logic\"\"\"\n\n    def __init__(self,\n                 order_repository: Repository[Order, str],\n                 pizza_repository: Repository[Pizza, str],\n                 mapper: Mapper,\n                 payment_service: IPaymentService,\n                 notification_service: INotificationService):\n        self.order_repository = order_repository\n        self.pizza_repository = pizza_repository\n        self.mapper = mapper\n        self.payment_service = payment_service\n        self.notification_service = notification_service\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult:\n        try:\n            # 1. Validate pizza availability\n            pizza_ids = [item.pizza_id for item in command.pizza_items]\n            available_pizzas = await self.pizza_repository.get_by_ids_async(pizza_ids)\n\n            if len(available_pizzas) != len(pizza_ids):\n                return self.bad_request(\"One or more pizzas are not available\")\n\n            # 2. Calculate total with size and topping modifications\n            total_amount = Decimal(\"0\")\n            order_pizzas = []\n\n            for item in command.pizza_items:\n                base_pizza = next(p for p in available_pizzas if p.id == item.pizza_id)\n\n                customized_pizza = Pizza(\n                    name=base_pizza.name,\n                    size=item.size,\n                    base_price=self._calculate_size_price(base_pizza.base_price, item.size),\n                    toppings=item.toppings,\n                    special_instructions=item.special_instructions\n                )\n\n                order_pizzas.append(customized_pizza)\n                total_amount += customized_pizza.total_price\n\n            # 3. Create order domain entity\n            order = Order.create(\n                customer_name=command.customer_name,\n                customer_phone=command.customer_phone,\n                customer_address=command.customer_address,\n                pizzas=order_pizzas,\n                payment_method=command.payment_method\n            )\n\n            # 4. Persist order (domain events will be published automatically)\n            await self.order_repository.save_async(order)\n\n            # 5. Return success result\n            return self.created({\n                \"order_id\": order.id,\n                \"total_amount\": str(total_amount),\n                \"estimated_ready_time\": order.estimated_ready_time.isoformat()\n            })\n\n        except PaymentDeclinedException:\n            return self.bad_request(\"Payment was declined. Please try a different payment method.\")\n        except KitchenOverloadedException:\n            return self.service_unavailable(\"Kitchen is at capacity. Estimated wait time is 45 minutes.\")\n        except Exception as ex:\n            return self.internal_server_error(f\"Failed to place order: {str(ex)}\")\n\n    def _calculate_size_price(self, base_price: Decimal, size: str) -&gt; Decimal:\n        \"\"\"Calculate price based on pizza size\"\"\"\n        multipliers = {\"small\": Decimal(\"0.8\"), \"medium\": Decimal(\"1.0\"), \"large\": Decimal(\"1.3\")}\n        return base_price * multipliers.get(size, Decimal(\"1.0\"))\n</code></pre>"},{"location":"patterns/cqrs/#query-handlers-with-caching","title":"Query Handlers with Caching","text":"<pre><code>from neuroglia.mediation.mediator import QueryHandler\n\nclass GetMenuQueryHandler(QueryHandler[GetMenuQuery, OperationResult[List[dict]]]):\n    \"\"\"Handles menu retrieval queries with caching optimization\"\"\"\n\n    def __init__(self,\n                 pizza_repository: Repository[Pizza, str],\n                 cache_service: ICacheService):\n        self.pizza_repository = pizza_repository\n        self.cache_service = cache_service\n\n    async def handle_async(self, query: GetMenuQuery) -&gt; OperationResult[List[dict]]:\n        # Check cache first for performance\n        cache_key = f\"menu:{query.category}:{query.include_seasonal}\"\n        cached_menu = await self.cache_service.get_async(cache_key)\n\n        if cached_menu:\n            return self.ok(cached_menu)\n\n        # Fetch from repository\n        pizzas = await self.pizza_repository.get_all_async()\n\n        # Apply filters\n        if query.category:\n            pizzas = [p for p in pizzas if p.category == query.category]\n\n        if not query.include_seasonal:\n            pizzas = [p for p in pizzas if not p.is_seasonal]\n\n        # Build optimized menu response\n        menu_items = []\n        for pizza in pizzas:\n            menu_items.append({\n                \"id\": pizza.id,\n                \"name\": pizza.name,\n                \"description\": pizza.description,\n                \"base_price\": str(pizza.base_price),\n                \"category\": pizza.category,\n                \"preparation_time_minutes\": pizza.preparation_time_minutes,\n                \"available_sizes\": [\"small\", \"medium\", \"large\"],\n                \"available_toppings\": pizza.available_toppings,\n                \"is_seasonal\": pizza.is_seasonal\n            })\n\n        # Cache for 15 minutes\n        await self.cache_service.set_async(cache_key, menu_items, expire_minutes=15)\n\n        return self.ok(menu_items)\n\nclass GetKitchenQueueQueryHandler(QueryHandler[GetKitchenQueueQuery, OperationResult[List[dict]]]):\n    \"\"\"Handles kitchen queue queries for staff dashboard\"\"\"\n\n    def __init__(self, order_repository: Repository[Order, str]):\n        self.order_repository = order_repository\n\n    async def handle_async(self, query: GetKitchenQueueQuery) -&gt; OperationResult[List[dict]]:\n        # Get orders by status\n        orders = await self.order_repository.get_by_status_async(query.status)\n\n        # Sort by order time (FIFO)\n        orders.sort(key=lambda o: o.order_time)\n\n        # Build optimized queue response\n        queue_items = []\n        for order in orders:\n            queue_items.append({\n                \"order_id\": order.id,\n                \"customer_name\": order.customer_name,\n                \"order_time\": order.order_time.isoformat(),\n                \"estimated_ready_time\": order.estimated_ready_time.isoformat() if order.estimated_ready_time else None,\n                \"pizza_count\": len(order.pizzas),\n                \"total_prep_time\": sum(p.preparation_time_minutes for p in order.pizzas),\n                \"special_instructions\": [p.special_instructions for p in order.pizzas if p.special_instructions]\n            })\n\n        return self.ok(queue_items)\n</code></pre>"},{"location":"patterns/cqrs/#event-handlers-for-side-effects","title":"Event Handlers for Side Effects","text":"<pre><code>from neuroglia.mediation.mediator import EventHandler\n\nclass OrderPlacedEventHandler(EventHandler[OrderPlacedEvent]):\n    \"\"\"Handles order placed events - sends notifications and analytics\"\"\"\n\n    def __init__(self,\n                 notification_service: INotificationService,\n                 analytics_service: IAnalyticsService):\n        self.notification_service = notification_service\n        self.analytics_service = analytics_service\n\n    async def handle_async(self, event: OrderPlacedEvent):\n        # Send SMS confirmation to customer\n        await self.notification_service.send_sms(\n            phone=event.customer_phone,\n            message=f\"Order {event.order_id[:8]} confirmed! \"\n                   f\"Total: ${event.total_amount}. \"\n                   f\"Ready by: {event.estimated_ready_time.strftime('%H:%M')}\"\n        )\n\n        # Notify kitchen staff\n        await self.notification_service.notify_kitchen_staff(\n            f\"New order {event.order_id[:8]} from {event.customer_name}\"\n        )\n\n        # Track order analytics\n        await self.analytics_service.track_order_placed(\n            order_id=event.order_id,\n            amount=event.total_amount,\n            customer_type=\"returning\" if await self._is_returning_customer(event.customer_phone) else \"new\"\n        )\n\nclass PizzaReadyEventHandler(EventHandler[PizzaReadyEvent]):\n    \"\"\"Handles pizza ready events - manages completion tracking\"\"\"\n\n    def __init__(self,\n                 order_service: IOrderService,\n                 performance_service: IPerformanceService):\n        self.order_service = order_service\n        self.performance_service = performance_service\n\n    async def handle_async(self, event: PizzaReadyEvent):\n        # Check if entire order is complete\n        order_complete = await self.order_service.check_if_order_complete(event.order_id)\n\n        if order_complete:\n            # Mark order as ready and notify customer\n            await self.order_service.mark_order_ready(event.order_id)\n\n        # Track pizza cooking performance\n        await self.performance_service.track_pizza_completion(\n            order_id=event.order_id,\n            pizza_index=event.pizza_index,\n            actual_time=event.actual_cooking_time_minutes,\n            completed_at=event.completed_at\n        )\n</code></pre>"},{"location":"patterns/cqrs/#pipeline-behaviors","title":"\ud83d\udee1\ufe0f Pipeline Behaviors","text":""},{"location":"patterns/cqrs/#validation-behavior","title":"Validation Behavior","text":"<pre><code>from neuroglia.mediation.mediator import PipelineBehavior\n\nclass OrderValidationBehavior(PipelineBehavior):\n    \"\"\"Validates pizza orders before processing\"\"\"\n\n    async def handle_async(self, request, next_handler):\n        # Only validate order commands\n        if isinstance(request, PlaceOrderCommand):\n            # Business rule: minimum order amount\n            if not request.pizza_items:\n                return OperationResult.validation_error(\"Order must contain at least one pizza\")\n\n            # Business rule: validate customer info\n            if not request.customer_phone or len(request.customer_phone) &lt; 10:\n                return OperationResult.validation_error(\"Valid phone number required\")\n\n            # Business rule: validate business hours\n            if not await self._is_within_business_hours():\n                return OperationResult.validation_error(\"Sorry, we're closed! Kitchen hours are 11 AM - 10 PM\")\n\n        # Continue to next behavior/handler\n        return await next_handler()\n\n    async def _is_within_business_hours(self) -&gt; bool:\n        \"\"\"Check if current time is within business hours\"\"\"\n        from datetime import datetime\n        current_hour = datetime.now().hour\n        return 11 &lt;= current_hour &lt;= 22  # 11 AM to 10 PM\n</code></pre>"},{"location":"patterns/cqrs/#caching-behavior","title":"Caching Behavior","text":"<pre><code>class QueryCachingBehavior(PipelineBehavior):\n    \"\"\"Caches query results based on query type and parameters\"\"\"\n\n    def __init__(self, cache_service: ICacheService):\n        self.cache_service = cache_service\n\n    async def handle_async(self, request, next_handler):\n        # Only cache queries, not commands\n        if not isinstance(request, Query):\n            return await next_handler()\n\n        # Generate cache key\n        cache_key = self._generate_cache_key(request)\n\n        # Try to get from cache first\n        cached_result = await self.cache_service.get_async(cache_key)\n        if cached_result:\n            return cached_result\n\n        # Execute query\n        result = await next_handler()\n\n        # Cache successful results\n        if result.is_success:\n            # Different TTL based on query type\n            ttl_minutes = self._get_cache_ttl(type(request))\n            await self.cache_service.set_async(cache_key, result, expire_minutes=ttl_minutes)\n\n        return result\n\n    def _generate_cache_key(self, request: Query) -&gt; str:\n        \"\"\"Generate cache key from request\"\"\"\n        request_type = type(request).__name__\n        request_data = str(request.__dict__)\n        return f\"query:{request_type}:{hash(request_data)}\"\n\n    def _get_cache_ttl(self, query_type: Type) -&gt; int:\n        \"\"\"Get cache TTL based on query type\"\"\"\n        cache_strategies = {\n            GetMenuQuery: 30,           # Menu changes infrequently\n            GetOrderStatusQuery: 1,     # Order status changes frequently\n            GetKitchenQueueQuery: 2,    # Kitchen queue changes regularly\n        }\n        return cache_strategies.get(query_type, 5)  # Default 5 minutes\n</code></pre>"},{"location":"patterns/cqrs/#transaction-behavior","title":"Transaction Behavior","text":"<pre><code>class OrderTransactionBehavior(PipelineBehavior):\n    \"\"\"Wraps order commands in database transactions\"\"\"\n\n    def __init__(self, unit_of_work: IUnitOfWork):\n        self.unit_of_work = unit_of_work\n\n    async def handle_async(self, request, next_handler):\n        # Only apply transactions to commands that modify data\n        if not isinstance(request, (PlaceOrderCommand, StartCookingCommand, ProcessPaymentCommand)):\n            return await next_handler()\n\n        async with self.unit_of_work.begin_transaction():\n            try:\n                result = await next_handler()\n\n                if result.is_success:\n                    await self.unit_of_work.commit_async()\n                else:\n                    await self.unit_of_work.rollback_async()\n\n                return result\n            except Exception:\n                await self.unit_of_work.rollback_async()\n                raise\n</code></pre>"},{"location":"patterns/cqrs/#framework-integration","title":"\ud83d\ude80 Framework Integration","text":""},{"location":"patterns/cqrs/#service-registration","title":"Service Registration","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.mediation.mediator import Mediator\n\ndef configure_cqrs_services(builder: WebApplicationBuilder):\n    \"\"\"Configure CQRS with mediator services\"\"\"\n\n    # Configure mediator with handler modules\n    Mediator.configure(builder, [\n        \"src.application.commands\",  # Command handlers\n        \"src.application.queries\",   # Query handlers\n        \"src.application.events\"     # Event handlers\n    ])\n\n    # Register pipeline behaviors\n    builder.services.add_pipeline_behavior(OrderValidationBehavior)\n    builder.services.add_pipeline_behavior(QueryCachingBehavior)\n    builder.services.add_pipeline_behavior(OrderTransactionBehavior)\n\n    # Register infrastructure services\n    builder.services.add_scoped(Repository[Order, str])\n    builder.services.add_scoped(Repository[Pizza, str])\n    builder.services.add_singleton(ICacheService)\n    builder.services.add_scoped(INotificationService)\n\ndef create_pizzeria_app():\n    \"\"\"Create pizzeria application with CQRS\"\"\"\n    builder = WebApplicationBuilder()\n\n    # Configure CQRS services\n    configure_cqrs_services(builder)\n\n    # Build application\n    app = builder.build()\n\n    return app\n</code></pre>"},{"location":"patterns/cqrs/#controller-integration_1","title":"Controller Integration","text":"<pre><code>from neuroglia.mvc.controller_base import ControllerBase\nfrom classy_fastapi.decorators import get, post, put\n\nclass OrdersController(ControllerBase):\n    \"\"\"Pizza orders API controller using CQRS with mediation\"\"\"\n\n    @post(\"/\", response_model=dict, status_code=201)\n    async def place_order(self, order_request: dict) -&gt; dict:\n        # Create command from request\n        command = PlaceOrderCommand(\n            customer_name=order_request[\"customer_name\"],\n            customer_phone=order_request[\"customer_phone\"],\n            customer_address=order_request[\"customer_address\"],\n            pizza_items=[PizzaItem(**item) for item in order_request[\"pizza_items\"]],\n            payment_method=order_request.get(\"payment_method\", \"cash\")\n        )\n\n        # Execute through mediator (with pipeline behaviors)\n        result = await self.mediator.execute_async(command)\n\n        # Process result and return\n        return self.process(result)\n\n    @get(\"/{order_id}/status\", response_model=dict)\n    async def get_order_status(self, order_id: str) -&gt; dict:\n        # Create query\n        query = GetOrderStatusQuery(order_id=order_id)\n\n        # Execute through mediator (with caching behavior)\n        result = await self.mediator.execute_async(query)\n\n        # Process result and return\n        return self.process(result)\n\n    @put(\"/{order_id}/cook\", response_model=dict)\n    async def start_cooking(self, order_id: str, cooking_request: dict) -&gt; dict:\n        # Create command\n        command = StartCookingCommand(\n            order_id=order_id,\n            kitchen_staff_id=cooking_request[\"kitchen_staff_id\"],\n            estimated_cooking_time_minutes=cooking_request[\"estimated_cooking_time_minutes\"]\n        )\n\n        # Execute through mediator (with transaction behavior)\n        result = await self.mediator.execute_async(command)\n\n        # Process result and return\n        return self.process(result)\n</code></pre>"},{"location":"patterns/cqrs/#testing-patterns","title":"\ud83e\uddea Testing Patterns","text":""},{"location":"patterns/cqrs/#command-handler-testing","title":"Command Handler Testing","text":"<pre><code>import pytest\nfrom unittest.mock import Mock, AsyncMock\n\n@pytest.mark.asyncio\nasync def test_place_order_command_handler_success():\n    # Arrange\n    mock_order_repo = Mock()\n    mock_pizza_repo = Mock()\n    mock_payment_service = Mock()\n    mock_notification_service = Mock()\n\n    handler = PlaceOrderCommandHandler(\n        order_repository=mock_order_repo,\n        pizza_repository=mock_pizza_repo,\n        mapper=Mock(),\n        payment_service=mock_payment_service,\n        notification_service=mock_notification_service\n    )\n\n    # Mock pizza availability\n    margherita = Pizza(\"margherita\", \"Margherita\", \"medium\", Decimal(\"12.99\"), [], 15)\n    mock_pizza_repo.get_by_ids_async.return_value = [margherita]\n\n    command = PlaceOrderCommand(\n        customer_name=\"John Doe\",\n        customer_phone=\"555-0123\",\n        customer_address=\"123 Pizza St\",\n        pizza_items=[PizzaItem(pizza_id=\"margherita\", size=\"large\", toppings=[\"extra_cheese\"])],\n        payment_method=\"cash\"\n    )\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n    assert \"order_id\" in result.data\n    assert \"total_amount\" in result.data\n    mock_order_repo.save_async.assert_called_once()\n    mock_notification_service.send_order_confirmation.assert_called_once()\n\n@pytest.mark.asyncio\nasync def test_place_order_command_handler_validation_failure():\n    # Arrange\n    handler = PlaceOrderCommandHandler(Mock(), Mock(), Mock(), Mock(), Mock())\n\n    command = PlaceOrderCommand(\n        customer_name=\"John Doe\",\n        customer_phone=\"555-0123\",\n        customer_address=\"123 Pizza St\",\n        pizza_items=[],  # Empty items should fail validation\n        payment_method=\"cash\"\n    )\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert not result.is_success\n    assert \"at least one pizza\" in result.error_message\n</code></pre>"},{"location":"patterns/cqrs/#integration-testing","title":"Integration Testing","text":"<pre><code>@pytest.mark.integration\n@pytest.mark.asyncio\nasync def test_complete_order_workflow():\n    \"\"\"Test the complete order placement and cooking workflow through mediator\"\"\"\n\n    # Arrange - use test client with real mediator\n    test_client = TestClient(create_pizzeria_app())\n\n    # Create order\n    order_data = {\n        \"customer_name\": \"John Doe\",\n        \"customer_phone\": \"555-0123\",\n        \"customer_address\": \"123 Pizza St\",\n        \"pizza_items\": [\n            {\n                \"pizza_id\": \"margherita\",\n                \"size\": \"large\",\n                \"toppings\": [\"extra_cheese\"],\n                \"special_instructions\": \"Extra crispy\"\n            }\n        ],\n        \"payment_method\": \"cash\"\n    }\n\n    # Act &amp; Assert - Place order\n    response = test_client.post(\"/api/orders\", json=order_data)\n    assert response.status_code == 201\n\n    order_result = response.json()\n    order_id = order_result[\"order_id\"]\n    assert \"total_amount\" in order_result\n    assert \"estimated_ready_time\" in order_result\n\n    # Act &amp; Assert - Check order status (should use cache)\n    status_response = test_client.get(f\"/api/orders/{order_id}/status\")\n    assert status_response.status_code == 200\n\n    status_data = status_response.json()\n    assert status_data[\"status\"] == \"pending\"\n    assert status_data[\"customer_name\"] == \"John Doe\"\n</code></pre>"},{"location":"patterns/cqrs/#pattern-benefits","title":"\ud83c\udfaf Pattern Benefits","text":""},{"location":"patterns/cqrs/#cqrs-with-mediation-advantages","title":"CQRS with Mediation Advantages","text":"<ul> <li>Decoupled Architecture: Mediator eliminates direct dependencies between controllers and business logic</li> <li>Cross-Cutting Concerns: Pipeline behaviors handle validation, caching, logging, and transactions consistently</li> <li>Testability: Each handler can be unit tested in isolation without complex setup</li> <li>Scalability: Commands and queries can scale independently with optimized read/write models</li> <li>Event-Driven Integration: Domain events enable loose coupling between bounded contexts</li> <li>Single Responsibility: Each handler has one clear responsibility and business purpose</li> </ul>"},{"location":"patterns/cqrs/#when-to-use","title":"When to Use","text":"<ul> <li>Applications with complex business logic requiring clear separation of concerns</li> <li>Systems needing different optimization strategies for reads and writes</li> <li>Microservices architectures requiring decoupled communication</li> <li>Applications with cross-cutting concerns like caching, validation, and transaction management</li> <li>Event-driven systems where domain events drive business processes</li> <li>Teams wanting to enforce consistent patterns and reduce coupling</li> </ul>"},{"location":"patterns/cqrs/#when-not-to-use","title":"When Not to Use","text":"<ul> <li>Simple CRUD applications with minimal business logic</li> <li>Systems where the overhead of commands/queries exceeds the benefits</li> <li>Applications with very simple read/write patterns</li> <li>Teams lacking experience with CQRS and mediation patterns</li> <li>Systems where synchronous, tightly-coupled operations are preferred</li> </ul>"},{"location":"patterns/cqrs/#related-patterns_1","title":"\ud83d\udd17 Related Patterns","text":""},{"location":"patterns/cqrs/#complementary-patterns","title":"Complementary Patterns","text":"<ul> <li>Event Sourcing - Commands naturally produce events for event sourcing</li> <li>Repository - Separate repositories for command and query sides</li> <li>Domain-Driven Design - Aggregates and domain events align with CQRS</li> <li>Dependency Injection - Service registration for handlers and behaviors</li> <li>Clean Architecture - CQRS fits naturally in the application layer</li> </ul>"},{"location":"patterns/cqrs/#integration-examples","title":"Integration Examples","text":"<p>CQRS with Mediation integrates well with event sourcing for write models and materialized views for read models, while the mediator handles the orchestration and cross-cutting concerns consistently across both sides.</p> <p>Next Steps: Explore Event Sourcing for event-driven write models or Repository for data access patterns that support CQRS separation.</p>"},{"location":"patterns/dependency-injection/","title":"\ud83d\udd27 Dependency Injection Pattern","text":"<p>Dependency Injection (DI) is a design pattern that implements Inversion of Control (IoC) by injecting dependencies rather than creating them internally. Neuroglia provides a comprehensive DI container that manages service registration, lifetime, and resolution, demonstrated through Mario's Pizzeria implementation.</p>"},{"location":"patterns/dependency-injection/#pattern-overview","title":"\ud83c\udfaf Pattern Overview","text":"<p>Dependency Injection addresses common software design problems by:</p> <ul> <li>Decoupling Components: Services don't create their dependencies directly</li> <li>Enabling Testability: Dependencies can be easily mocked or stubbed</li> <li>Managing Lifetimes: Container controls when services are created and disposed</li> <li>Configuration Flexibility: Swap implementations without code changes</li> <li>Cross-cutting Concerns: Centralized service configuration and management</li> </ul>"},{"location":"patterns/dependency-injection/#core-concepts","title":"Core Concepts","text":"Concept Purpose Mario's Pizzeria Example ServiceCollection Registry for service definitions Pizzeria's service catalog of all available services ServiceProvider Container for resolving services Kitchen coordinator that provides the right service when needed ServiceLifetime Controls service creation and disposal Equipment usage patterns (shared vs per-order vs per-use) Interface Abstraction Contracts for service implementations <code>IOrderRepository</code> with File, MongoDB, or Memory implementations"},{"location":"patterns/dependency-injection/#service-lifetime-patterns","title":"\ud83c\udfd7\ufe0f Service Lifetime Patterns","text":"<p>Understanding service lifetimes is crucial for proper resource management and performance:</p>"},{"location":"patterns/dependency-injection/#singleton-shared-infrastructure","title":"Singleton - Shared Infrastructure","text":"<p>Pattern: One instance for the entire application lifetime</p> <pre><code>from neuroglia.dependency_injection import ServiceCollection\n\nservices = ServiceCollection()\n\n# Shared infrastructure services\nservices.add_singleton(DatabaseConnection)      # Connection pool shared across all requests\nservices.add_singleton(MenuCacheService)        # Menu data cached for all customers\nservices.add_singleton(KitchenDisplayService)   # Single kitchen display system\nservices.add_singleton(PaymentGateway)          # Shared payment processing service\nservices.add_singleton(NotificationService)     # Single SMS/email service instance\n</code></pre> <p>When to Use:</p> <ul> <li>Database connection pools</li> <li>Caching services</li> <li>External API clients</li> <li>Configuration services</li> <li>Logging services</li> </ul> <p>Benefits: Memory efficiency, shared state, connection pooling Risks: Thread safety required, potential memory leaks if not disposed</p>"},{"location":"patterns/dependency-injection/#scoped-request-lifecycle","title":"Scoped - Request Lifecycle","text":"<p>Pattern: One instance per scope (typically per HTTP request or business operation)</p> <pre><code># Per-request/per-operation services\nservices.add_scoped(OrderRepository)           # Order data access for this request\nservices.add_scoped(OrderProcessingService)    # Business logic for current order\nservices.add_scoped(CustomerContextService)    # Customer-specific request context\nservices.add_scoped(KitchenWorkflowService)    # Kitchen operations for this order\n</code></pre> <p>When to Use:</p> <ul> <li>Repository instances</li> <li>Business service instances</li> <li>User context services</li> <li>Request-specific caching</li> <li>Database transactions</li> </ul> <p>Benefits: Request isolation, automatic cleanup, consistent state within scope Risks: Higher memory usage than singleton</p>"},{"location":"patterns/dependency-injection/#transient-stateless-operations","title":"Transient - Stateless Operations","text":"<p>Pattern: New instance every time the service is requested</p> <pre><code># Stateless calculation and validation services\nservices.add_transient(PizzaPriceCalculator)    # Fresh calculation each time\nservices.add_transient(DeliveryTimeEstimator)   # Stateless time calculations\nservices.add_transient(LoyaltyPointsCalculator) # Independent point calculations\nservices.add_transient(OrderValidator)          # Fresh validation each time\n</code></pre> <p>When to Use:</p> <ul> <li>Stateless calculators</li> <li>Validators</li> <li>Formatters</li> <li>Short-lived operations</li> <li>Thread-unsafe services</li> </ul> <p>Benefits: No shared state issues, always fresh instance Risks: Highest memory and CPU overhead</p>"},{"location":"patterns/dependency-injection/#registration-patterns","title":"\ud83d\udd27 Registration Patterns","text":""},{"location":"patterns/dependency-injection/#interface-based-registration","title":"Interface-Based Registration","text":"<p>Pattern: Register services by their abstractions to enable flexibility and testing</p> <pre><code>from abc import ABC, abstractmethod\nfrom typing import List, Optional\n\n# Define contract\nclass IOrderRepository(ABC):\n    @abstractmethod\n    async def save_async(self, order: Order) -&gt; None:\n        pass\n\n    @abstractmethod\n    async def get_by_id_async(self, order_id: str) -&gt; Optional[Order]:\n        pass\n\n    @abstractmethod\n    async def get_by_status_async(self, status: str) -&gt; List[Order]:\n        pass\n\n# Multiple implementations\nclass FileOrderRepository(IOrderRepository):\n    def __init__(self, data_dir: str = \"data\"):\n        self.data_dir = Path(data_dir)\n        self.data_dir.mkdir(exist_ok=True)\n\n    async def save_async(self, order: Order) -&gt; None:\n        file_path = self.data_dir / f\"{order.id}.json\"\n        with open(file_path, 'w') as f:\n            json.dump(order.__dict__, f, default=str)\n\nclass MongoOrderRepository(IOrderRepository):\n    def __init__(self, mongo_client: MongoClient):\n        self.collection = mongo_client.pizzeria.orders\n\n    async def save_async(self, order: Order) -&gt; None:\n        await self.collection.replace_one(\n            {\"_id\": order.id},\n            order.__dict__,\n            upsert=True\n        )\n\n# Register by interface - easy to swap implementations\nservices.add_scoped(IOrderRepository, FileOrderRepository)  # Development\n# services.add_scoped(IOrderRepository, MongoOrderRepository)  # Production\n</code></pre>"},{"location":"patterns/dependency-injection/#factory-pattern-registration","title":"Factory Pattern Registration","text":"<p>Pattern: Use factory functions for complex service initialization</p> <pre><code>def create_payment_gateway() -&gt; IPaymentGateway:\n    \"\"\"Factory creates payment gateway based on configuration\"\"\"\n    config = get_payment_config()\n\n    if config.environment == \"development\":\n        return MockPaymentGateway()\n    elif config.provider == \"stripe\":\n        return StripePaymentGateway(config.stripe_api_key)\n    else:\n        return SquarePaymentGateway(config.square_token)\n\ndef create_notification_service() -&gt; INotificationService:\n    \"\"\"Factory creates notification service with proper credentials\"\"\"\n    settings = get_app_settings()\n\n    return TwilioNotificationService(\n        account_sid=settings.twilio_sid,\n        auth_token=settings.twilio_token,\n        from_number=settings.pizzeria_phone\n    )\n\n# Register with factories\nservices.add_singleton(IPaymentGateway, factory=create_payment_gateway)\nservices.add_singleton(INotificationService, factory=create_notification_service)\n</code></pre>"},{"location":"patterns/dependency-injection/#generic-repository-pattern","title":"Generic Repository Pattern","text":"<p>Pattern: Generic repository implementation for multiple entity types</p> <pre><code>from typing import TypeVar, Generic\nfrom neuroglia.data.abstractions import Repository\n\nT = TypeVar('T')\nTKey = TypeVar('TKey')\n\nclass FileRepository(Repository[T, TKey], Generic[T, TKey]):\n    \"\"\"Generic file-based repository for any entity type\"\"\"\n\n    def __init__(self, entity_type: type, data_dir: str = \"data\"):\n        self.entity_type = entity_type\n        self.data_dir = Path(data_dir) / entity_type.__name__.lower()\n        self.data_dir.mkdir(parents=True, exist_ok=True)\n\n    async def save_async(self, entity: T) -&gt; None:\n        file_path = self.data_dir / f\"{entity.id}.json\"\n        with open(file_path, 'w') as f:\n            json.dump(entity.__dict__, f, default=str)\n\n# Factory functions for type-safe registration\ndef create_pizza_repository() -&gt; Repository[Pizza, str]:\n    return FileRepository(Pizza, \"data\")\n\ndef create_order_repository() -&gt; Repository[Order, str]:\n    return FileRepository(Order, \"data\")\n\n# Register generic repositories\nservices.add_scoped(Repository[Pizza, str], factory=create_pizza_repository)\nservices.add_scoped(Repository[Order, str], factory=create_order_repository)\n</code></pre>"},{"location":"patterns/dependency-injection/#constructor-injection-pattern","title":"\ud83c\udfaf Constructor Injection Pattern","text":"<p>Pattern: Dependencies are provided through constructor parameters</p> <pre><code>class OrderService:\n    \"\"\"Service with injected dependencies\"\"\"\n\n    def __init__(self,\n                 order_repository: IOrderRepository,\n                 payment_service: IPaymentService,\n                 notification_service: INotificationService,\n                 mapper: IMapper):\n        self.order_repository = order_repository\n        self.payment_service = payment_service\n        self.notification_service = notification_service\n        self.mapper = mapper\n\n    async def place_order_async(self, order_dto: OrderDto) -&gt; OperationResult[OrderDto]:\n        # Dependencies injected automatically\n        order = self.mapper.map(order_dto, Order)\n\n        # Process payment using injected service\n        payment_result = await self.payment_service.process_payment_async(order.total)\n        if not payment_result.success:\n            return OperationResult.bad_request(\"Payment failed\")\n\n        # Save using injected repository\n        await self.order_repository.save_async(order)\n\n        # Send notification using injected service\n        await self.notification_service.send_confirmation_async(order)\n\n        return OperationResult.ok(self.mapper.map(order, OrderDto))\n\nclass OrderController(ControllerBase):\n    \"\"\"Controller with service injection\"\"\"\n\n    def __init__(self,\n                 service_provider: ServiceProvider,\n                 mapper: IMapper,\n                 mediator: IMediator):\n        super().__init__(service_provider, mapper, mediator)\n        # Dependencies resolved automatically by framework\n</code></pre>"},{"location":"patterns/dependency-injection/#testing-with-dependency-injection","title":"\ud83e\uddea Testing with Dependency Injection","text":"<p>Pattern: Easy mocking and testing through dependency injection</p> <pre><code>import pytest\nfrom unittest.mock import Mock, AsyncMock\n\nclass TestOrderService:\n    \"\"\"Test class demonstrating DI testing benefits\"\"\"\n\n    def setup_method(self):\n        # Create mocks for all dependencies\n        self.order_repository = Mock(spec=IOrderRepository)\n        self.payment_service = Mock(spec=IPaymentService)\n        self.notification_service = Mock(spec=INotificationService)\n        self.mapper = Mock(spec=IMapper)\n\n        # Inject mocks into service\n        self.order_service = OrderService(\n            self.order_repository,\n            self.payment_service,\n            self.notification_service,\n            self.mapper\n        )\n\n    @pytest.mark.asyncio\n    async def test_place_order_success(self):\n        # Arrange - setup mock behaviors\n        order_dto = OrderDto(customer_name=\"Test\", total=25.99)\n        order = Order(id=\"123\", customer_name=\"Test\", total=25.99)\n\n        self.mapper.map.return_value = order\n        self.payment_service.process_payment_async = AsyncMock(\n            return_value=PaymentResult(success=True)\n        )\n        self.order_repository.save_async = AsyncMock()\n        self.notification_service.send_confirmation_async = AsyncMock()\n\n        # Act\n        result = await self.order_service.place_order_async(order_dto)\n\n        # Assert\n        assert result.is_success\n        self.payment_service.process_payment_async.assert_called_once_with(25.99)\n        self.order_repository.save_async.assert_called_once_with(order)\n        self.notification_service.send_confirmation_async.assert_called_once_with(order)\n</code></pre>"},{"location":"patterns/dependency-injection/#advanced-patterns","title":"\ud83d\ude80 Advanced Patterns","text":""},{"location":"patterns/dependency-injection/#service-locator-anti-pattern","title":"Service Locator Anti-Pattern","text":"<p>\u274c Avoid: Service Locator pattern hides dependencies</p> <pre><code># BAD - Service Locator hides dependencies\nclass OrderService:\n    def process_order(self, order_dto: OrderDto):\n        # Hidden dependencies - hard to test and understand\n        repository = ServiceLocator.get(IOrderRepository)\n        payment = ServiceLocator.get(IPaymentService)\n        # ... rest of implementation\n</code></pre> <p>\u2705 Prefer: Constructor Injection makes dependencies explicit</p> <pre><code># GOOD - Dependencies are explicit and testable\nclass OrderService:\n    def __init__(self,\n                 repository: IOrderRepository,\n                 payment: IPaymentService):\n        self.repository = repository\n        self.payment = payment\n</code></pre>"},{"location":"patterns/dependency-injection/#configuration-based-registration","title":"Configuration-Based Registration","text":"<p>Pattern: Configure services based on environment or settings</p> <pre><code>def configure_services(services: ServiceCollection, environment: str):\n    \"\"\"Configure services based on environment\"\"\"\n\n    # Always register core abstractions\n    services.add_transient(IMapper, AutoMapper)\n    services.add_scoped(IOrderService, OrderService)\n\n    # Environment-specific implementations\n    if environment == \"development\":\n        services.add_scoped(IOrderRepository, FileOrderRepository)\n        services.add_singleton(IPaymentService, MockPaymentService)\n        services.add_singleton(INotificationService, ConsoleNotificationService)\n\n    elif environment == \"testing\":\n        services.add_scoped(IOrderRepository, InMemoryOrderRepository)\n        services.add_singleton(IPaymentService, MockPaymentService)\n        services.add_singleton(INotificationService, NoOpNotificationService)\n\n    elif environment == \"production\":\n        services.add_scoped(IOrderRepository, MongoOrderRepository)\n        services.add_singleton(IPaymentService, StripePaymentService)\n        services.add_singleton(INotificationService, TwilioNotificationService)\n</code></pre>"},{"location":"patterns/dependency-injection/#integration-with-other-patterns","title":"\ud83d\udd17 Integration with Other Patterns","text":""},{"location":"patterns/dependency-injection/#di-cqrs-pattern","title":"DI + CQRS Pattern","text":"<pre><code># Command handlers with injected dependencies\nclass PlaceOrderHandler(ICommandHandler[PlaceOrderCommand, OperationResult]):\n    def __init__(self,\n                 order_repository: IOrderRepository,\n                 payment_service: IPaymentService):\n        self.order_repository = order_repository\n        self.payment_service = payment_service\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult:\n        # Implementation uses injected dependencies\n        pass\n\n# Register handlers\nservices.add_scoped(ICommandHandler[PlaceOrderCommand, OperationResult], PlaceOrderHandler)\n</code></pre>"},{"location":"patterns/dependency-injection/#di-repository-pattern","title":"DI + Repository Pattern","text":"<pre><code># Repository with injected infrastructure dependencies\nclass OrderRepository(IOrderRepository):\n    def __init__(self,\n                 mongo_client: MongoClient,\n                 logger: ILogger,\n                 cache: ICache):\n        self.collection = mongo_client.pizzeria.orders\n        self.logger = logger\n        self.cache = cache\n</code></pre>"},{"location":"patterns/dependency-injection/#related-patterns","title":"\ud83d\udcda Related Patterns","text":"<ul> <li>\ud83c\udfaf CQRS Pattern - Command and query handlers use DI for dependencies</li> <li>\ud83d\udcbe Repository Pattern - Repositories are registered and injected as services</li> <li>\ud83d\udd04 Event-Driven Pattern - Event handlers use DI for their dependencies</li> <li>\ud83c\udfd7\ufe0f Clean Architecture - DI enables layer separation and dependency inversion</li> </ul> <p>Dependency Injection is fundamental to building testable, maintainable applications. Mario's Pizzeria demonstrates how proper DI patterns enable flexible architecture and easy testing.</p>"},{"location":"patterns/domain-driven-design/","title":"\ud83c\udfdb\ufe0f Domain Driven Design Pattern","text":"<p>Domain Driven Design (DDD) forms the architectural foundation of the Neuroglia framework, providing core abstractions and patterns that enable rich, expressive domain models while maintaining clean separation of concerns.</p> <p>This pattern serves as the primary reference for understanding how domain logic flows through the API, Application, Domain, and Integration layers.</p>"},{"location":"patterns/domain-driven-design/#pattern-overview","title":"\ud83c\udfaf Pattern Overview","text":"<p>Domain Driven Design is a software development methodology that emphasizes modeling complex business domains through rich domain models, ubiquitous language, and strategic design patterns. The Neuroglia framework implements DDD principles through a comprehensive set of base abstractions that support both traditional CRUD operations and advanced patterns like event sourcing.</p>"},{"location":"patterns/domain-driven-design/#core-ddd-principles","title":"\ud83c\udf1f Core DDD Principles","text":"<ul> <li>\ud83c\udfdb\ufe0f Rich Domain Models: Business logic lives in domain entities, not in services</li> <li>\ud83d\udde3\ufe0f Ubiquitous Language: Common vocabulary shared between business and technical teams</li> <li>\ud83c\udfaf Bounded Contexts: Clear boundaries around cohesive domain models</li> <li>\ud83d\udcda Aggregate Boundaries: Consistency boundaries that encapsulate business invariants</li> <li>\u26a1 Domain Events: First-class representation of business events and state changes</li> </ul>"},{"location":"patterns/domain-driven-design/#framework-integration","title":"\ud83d\udd04 Framework Integration","text":"<p>The framework provides core abstractions that seamlessly integrate with all architectural layers:</p> <pre><code>graph TB\n    subgraph \"\ud83c\udf10 API Layer\"\n        Controllers[\"Controllers&lt;br/&gt;HTTP Endpoints\"]\n        DTOs[\"DTOs&lt;br/&gt;Data Transfer Objects\"]\n    end\n\n    subgraph \"\ud83d\udcbc Application Layer\"\n        Commands[\"Commands&lt;br/&gt;Write Operations\"]\n        Queries[\"Queries&lt;br/&gt;Read Operations\"]\n        Handlers[\"Handlers&lt;br/&gt;Business Orchestration\"]\n    end\n\n    subgraph \"\ud83c\udfdb\ufe0f Domain Layer\"\n        Entities[\"Entities&lt;br/&gt;Business Objects\"]\n        Aggregates[\"Aggregate Roots&lt;br/&gt;Consistency Boundaries\"]\n        DomainEvents[\"Domain Events&lt;br/&gt;Business Events\"]\n        ValueObjects[\"Value Objects&lt;br/&gt;Immutable Data\"]\n    end\n\n    subgraph \"\ud83d\udd0c Integration Layer\"\n        Repositories[\"Repositories&lt;br/&gt;Data Access\"]\n        EventBus[\"Event Bus&lt;br/&gt;Integration Events\"]\n        ExternalAPIs[\"External APIs&lt;br/&gt;Third-party Services\"]\n    end\n\n    Controllers --&gt; Commands\n    Controllers --&gt; Queries\n    Commands --&gt; Handlers\n    Queries --&gt; Handlers\n    Handlers --&gt; Aggregates\n    Handlers --&gt; Repositories\n    Aggregates --&gt; DomainEvents\n    DomainEvents --&gt; EventBus\n    Repositories --&gt; ExternalAPIs\n\n    style Entities fill:#e8f5e8\n    style Aggregates fill:#e8f5e8\n    style DomainEvents fill:#fff3e0\n    style ValueObjects fill:#e8f5e8</code></pre>"},{"location":"patterns/domain-driven-design/#core-domain-abstractions","title":"\ud83c\udf55 Core Domain Abstractions","text":""},{"location":"patterns/domain-driven-design/#1-entity-base-class","title":"1. Entity Base Class","text":"<p>Entities represent objects with distinct identity that persist over time:</p> <pre><code>from neuroglia.data.abstractions import Entity\nfrom datetime import datetime\nfrom typing import List\nimport uuid\n\nclass Pizza(Entity[str]):\n    \"\"\"Pizza entity with business logic and identity\"\"\"\n\n    def __init__(self, name: str, price: float, ingredients: List[str], id: str = None):\n        super().__init__()\n        self.id = id or f\"pizza_{uuid.uuid4().hex[:8]}\"\n        self.name = name\n        self.price = price\n        self.ingredients = ingredients.copy()\n        self.is_available = True\n        self.created_at = datetime.now()\n\n        # Business rule validation\n        if price &lt;= 0:\n            raise ValueError(\"Pizza price must be positive\")\n        if not ingredients:\n            raise ValueError(\"Pizza must have at least one ingredient\")\n\n    def add_ingredient(self, ingredient: str) -&gt; None:\n        \"\"\"Add ingredient with business rule validation\"\"\"\n        if ingredient in self.ingredients:\n            raise ValueError(f\"Ingredient '{ingredient}' already exists\")\n\n        self.ingredients.append(ingredient)\n        self.price += 2.50  # Business rule: each ingredient adds $2.50\n        self.updated_at = datetime.now()\n\n    def remove_ingredient(self, ingredient: str) -&gt; None:\n        \"\"\"Remove ingredient with business validation\"\"\"\n        if ingredient not in self.ingredients:\n            raise ValueError(f\"Ingredient '{ingredient}' not found\")\n        if len(self.ingredients) &lt;= 1:\n            raise ValueError(\"Pizza must have at least one ingredient\")\n\n        self.ingredients.remove(ingredient)\n        self.price -= 2.50\n        self.updated_at = datetime.now()\n\n    def make_unavailable(self, reason: str) -&gt; None:\n        \"\"\"Business operation to make pizza unavailable\"\"\"\n        self.is_available = False\n        self.unavailable_reason = reason\n        self.updated_at = datetime.now()\n</code></pre>"},{"location":"patterns/domain-driven-design/#2-domain-events","title":"2. Domain Events","text":"<p>Domain Events represent important business occurrences that other parts of the system need to know about:</p> <pre><code>from neuroglia.data.abstractions import DomainEvent\nfrom dataclasses import dataclass\nfrom decimal import Decimal\nfrom datetime import datetime\nfrom typing import List, Dict, Any\n\n@dataclass\nclass PizzaOrderPlacedEvent(DomainEvent[str]):\n    \"\"\"Domain event representing a pizza order being placed\"\"\"\n    customer_id: str\n    items: List[Dict[str, Any]]\n    total_amount: Decimal\n    special_instructions: str\n\n    def __init__(self, aggregate_id: str, customer_id: str, items: List[Dict[str, Any]],\n                 total_amount: Decimal, special_instructions: str = \"\"):\n        super().__init__(aggregate_id)\n        self.customer_id = customer_id\n        self.items = items\n        self.total_amount = total_amount\n        self.special_instructions = special_instructions\n\n@dataclass\nclass OrderStatusChangedEvent(DomainEvent[str]):\n    \"\"\"Domain event representing order status changes\"\"\"\n    previous_status: str\n    new_status: str\n    changed_by: str\n    reason: str\n\n    def __init__(self, aggregate_id: str, previous_status: str, new_status: str,\n                 changed_by: str, reason: str = \"\"):\n        super().__init__(aggregate_id)\n        self.previous_status = previous_status\n        self.new_status = new_status\n        self.changed_by = changed_by\n        self.reason = reason\n\n@dataclass\nclass PaymentProcessedEvent(DomainEvent[str]):\n    \"\"\"Domain event representing successful payment processing\"\"\"\n    payment_method: str\n    amount: Decimal\n    transaction_id: str\n    processed_at: datetime\n\n    def __init__(self, aggregate_id: str, payment_method: str, amount: Decimal,\n                 transaction_id: str):\n        super().__init__(aggregate_id)\n        self.payment_method = payment_method\n        self.amount = amount\n        self.transaction_id = transaction_id\n        self.processed_at = datetime.now()\n</code></pre>"},{"location":"patterns/domain-driven-design/#framework-data-abstractions","title":"\ud83c\udfd7\ufe0f Framework Data Abstractions","text":""},{"location":"patterns/domain-driven-design/#core-base-classes","title":"Core Base Classes","text":"<p>The Neuroglia framework provides a comprehensive set of base abstractions that form the foundation of domain-driven design. These abstractions enforce patterns while providing flexibility for different architectural approaches.</p> <pre><code># /src/neuroglia/data/abstractions.py\nfrom abc import ABC\nfrom datetime import datetime\nfrom typing import Generic, List, Type, TypeVar\n\nTKey = TypeVar(\"TKey\")\n\"\"\"Represents the generic argument used to specify the type of key to use\"\"\"\n\nclass Identifiable(Generic[TKey], ABC):\n    \"\"\"Defines the fundamentals of an object that can be identified based on a unique identifier\"\"\"\n    id: TKey\n\nclass Entity(Generic[TKey], Identifiable[TKey], ABC):\n    \"\"\"Represents the abstract class inherited by all entities in the application\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.created_at = datetime.now()\n\n    created_at: datetime\n    last_modified: datetime\n\nclass VersionedState(ABC):\n    \"\"\"Represents the abstract class inherited by all versioned states\"\"\"\n\n    def __init__(self):\n        self.state_version = 0\n\n    state_version: int = 0\n\nclass AggregateState(Generic[TKey], Identifiable[TKey], VersionedState, ABC):\n    \"\"\"Represents the abstract class inherited by all aggregate root states\"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n    id: TKey\n    created_at: datetime\n    last_modified: datetime\n\nclass DomainEvent(Generic[TKey], ABC):\n    \"\"\"Represents the base class inherited by all domain events\"\"\"\n\n    def __init__(self, aggregate_id: TKey):\n        self.created_at = datetime.now()\n        self.aggregate_id = aggregate_id\n\n    created_at: datetime\n    aggregate_id: TKey\n    aggregate_version: int\n\nclass AggregateRoot(Generic[TState, TKey], Entity[TKey], ABC):\n    \"\"\"Represents the base class for all aggregate roots\"\"\"\n\n    _pending_events: List[DomainEvent]\n\n    def __init__(self):\n        self.state = object.__new__(self.__orig_bases__[0].__args__[0])\n        self.state.__init__()\n        self._pending_events = list[DomainEvent]()\n\n    def id(self):\n        return self.state.id\n\n    state: TState\n\n    def register_event(self, e: TEvent) -&gt; TEvent:\n        \"\"\"Registers the specified domain event\"\"\"\n        if not hasattr(self, \"_pending_events\"):\n            self._pending_events = list[DomainEvent]()\n        self._pending_events.append(e)\n        e.aggregate_version = self.state.state_version + len(self._pending_events)\n        return e\n\n    def clear_pending_events(self):\n        \"\"\"Clears all pending domain events\"\"\"\n        self._pending_events.clear()\n</code></pre>"},{"location":"patterns/domain-driven-design/#domain-event-application-mechanism","title":"\u26a1 Domain Event Application Mechanism","text":""},{"location":"patterns/domain-driven-design/#understanding-selfstateon-and-selfregister_event","title":"Understanding <code>self.state.on()</code> and <code>self.register_event()</code>","text":"<p>The framework implements a sophisticated event sourcing pattern where domain events serve dual purposes:</p> <ol> <li>State Application: Events modify aggregate state through the <code>state.on()</code> method</li> <li>Event Registration: Events are registered for persistence and external handling via <code>register_event()</code></li> </ol>"},{"location":"patterns/domain-driven-design/#event-flow-architecture","title":"Event Flow Architecture","text":"<pre><code>graph TB\n    subgraph \"\ud83c\udfaf Business Operation\"\n        A[Business Method Called]\n        B[Validate Business Rules]\n        C[Create Domain Event]\n    end\n\n    subgraph \"\u26a1 Event Processing Pipeline\"\n        D[state.on event]\n        E[register_event event]\n        F[Update State Version]\n        G[Add to Pending Events]\n    end\n\n    subgraph \"\ud83d\udcbe Persistence &amp; Distribution\"\n        H[Repository Save]\n        I[Event Store Append]\n        J[Event Bus Publish]\n        K[Integration Events]\n    end\n\n    A --&gt; B\n    B --&gt; C\n    C --&gt; D\n    C --&gt; E\n    D --&gt; F\n    E --&gt; G\n    F --&gt; H\n    G --&gt; I\n    I --&gt; J\n    J --&gt; K\n\n    style D fill:#e8f5e8\n    style E fill:#fff3e0\n    style I fill:#e3f2fd</code></pre>"},{"location":"patterns/domain-driven-design/#event-application-pattern-with-multiple-dispatch","title":"Event Application Pattern with Multiple Dispatch","text":"<pre><code>from multipledispatch import dispatch\nfrom neuroglia.data.abstractions import AggregateRoot, AggregateState\n\nclass BankAccountState(AggregateState[str]):\n    \"\"\"Aggregate state with event handlers using multiple dispatch\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.account_number: Optional[str] = None\n        self.owner_name: Optional[str] = None\n        self.balance: Decimal = Decimal(\"0.00\")\n        self.account_type: Optional[str] = None\n        self.is_active: bool = True\n\n    @dispatch(AccountCreatedEvent)\n    def on(self, event: AccountCreatedEvent):\n        \"\"\"Apply account created event to state\"\"\"\n        self.id = event.aggregate_id\n        self.created_at = event.created_at\n        self.account_number = event.account_number\n        self.owner_name = event.owner_name\n        self.balance = event.initial_balance\n        self.account_type = event.account_type\n        self.is_active = True\n\n    @dispatch(MoneyDepositedEvent)\n    def on(self, event: MoneyDepositedEvent):\n        \"\"\"Apply money deposited event to state\"\"\"\n        self.balance = event.new_balance\n        self.last_modified = event.created_at\n\n    @dispatch(MoneyWithdrawnEvent)\n    def on(self, event: MoneyWithdrawnEvent):\n        \"\"\"Apply money withdrawn event to state\"\"\"\n        self.balance = event.new_balance\n        self.last_modified = event.created_at\n\nclass BankAccountAggregate(AggregateRoot[BankAccountState, str]):\n    \"\"\"Aggregate root demonstrating event application pattern\"\"\"\n\n    def create_account(self, account_number: str, owner_name: str,\n                      initial_balance: Decimal, account_type: str):\n        \"\"\"Business operation that applies events to state\"\"\"\n\n        # 1. Business rule validation\n        if initial_balance &lt; 0:\n            raise ValueError(\"Initial balance cannot be negative\")\n        if account_type not in [\"checking\", \"savings\", \"business\"]:\n            raise ValueError(\"Invalid account type\")\n\n        # 2. Create domain event\n        event = AccountCreatedEvent(\n            aggregate_id=self.state.id,\n            account_number=account_number,\n            owner_name=owner_name,\n            initial_balance=initial_balance,\n            account_type=account_type,\n        )\n\n        # 3. Apply event to state AND register for persistence\n        self.state.on(event)  # Updates aggregate state immediately\n        self.register_event(event)  # Adds to pending events for persistence\n\n    def deposit_money(self, amount: Decimal, transaction_id: str):\n        \"\"\"Deposit operation with event-driven state changes\"\"\"\n\n        # Business validation\n        if amount &lt;= 0:\n            raise ValueError(\"Deposit amount must be positive\")\n        if not self.state.is_active:\n            raise ValueError(\"Cannot deposit to inactive account\")\n\n        # Calculate new balance\n        new_balance = self.state.balance + amount\n\n        # Create and apply event\n        event = MoneyDepositedEvent(\n            aggregate_id=self.state.id,\n            amount=amount,\n            new_balance=new_balance,\n            transaction_id=transaction_id,\n        )\n\n        self.state.on(event)  # State update via event\n        self.register_event(event)  # Event registration\n</code></pre>"},{"location":"patterns/domain-driven-design/#data-flow-breakdown","title":"Data Flow Breakdown","text":""},{"location":"patterns/domain-driven-design/#1-event-creation-application","title":"1. Event Creation &amp; Application","text":"<pre><code># Business method creates event\nevent = MoneyDepositedEvent(aggregate_id=self.id, amount=100.00, ...)\n\n# State application - Uses @dispatch to find the right handler\nself.state.on(event)  # Calls BankAccountState.on(MoneyDepositedEvent)\n\n# Event registration - Adds to pending events collection\nself.register_event(event)  # Adds to _pending_events list\n</code></pre>"},{"location":"patterns/domain-driven-design/#2-multiple-dispatch-resolution","title":"2. Multiple Dispatch Resolution","text":"<p>The <code>@dispatch</code> decorator from the <code>multipledispatch</code> library enables method overloading based on argument types:</p> <pre><code>@dispatch(AccountCreatedEvent)\ndef on(self, event: AccountCreatedEvent):\n    # Handles AccountCreatedEvent specifically\n    self.balance = event.initial_balance\n\n@dispatch(MoneyDepositedEvent)\ndef on(self, event: MoneyDepositedEvent):\n    # Handles MoneyDepositedEvent specifically\n    self.balance = event.new_balance\n\n# Python's multiple dispatch automatically routes:\n# state.on(AccountCreatedEvent) -&gt; First method\n# state.on(MoneyDepositedEvent) -&gt; Second method\n</code></pre>"},{"location":"patterns/domain-driven-design/#3-event-versioning-persistence","title":"3. Event Versioning &amp; Persistence","text":"<pre><code>def register_event(self, e: TEvent) -&gt; TEvent:\n    \"\"\"Framework method that handles event registration\"\"\"\n\n    # Add to pending events collection\n    self._pending_events.append(e)\n\n    # Set event version based on current state + pending events\n    e.aggregate_version = self.state.state_version + len(self._pending_events)\n\n    return e\n</code></pre>"},{"location":"patterns/domain-driven-design/#4-repository-integration","title":"4. Repository Integration","text":"<p>When the aggregate is saved through a repository:</p> <pre><code># In CommandHandler or Application Service\nasync def handle_async(self, command: DepositMoneyCommand):\n\n    # Load aggregate\n    account = await self.repository.get_by_id_async(command.account_id)\n\n    # Execute business operation (applies events)\n    account.deposit_money(command.amount, command.transaction_id)\n\n    # Save aggregate (persists events and updates state)\n    await self.repository.save_async(account)\n    #                                  \u2191\n    # Repository implementation will:\n    # 1. Append events to event store\n    # 2. Update read model/snapshot\n    # 3. Publish events to event bus\n    # 4. Clear pending events\n</code></pre>"},{"location":"patterns/domain-driven-design/#event-sourcing-vs-traditional-state-management","title":"Event Sourcing vs. Traditional State Management","text":""},{"location":"patterns/domain-driven-design/#traditional-approach","title":"Traditional Approach \u274c","text":"<pre><code>def deposit_money(self, amount: Decimal):\n    # Direct state mutation\n    self.balance += amount\n    self.last_modified = datetime.now()\n    # Lost: WHY the balance changed, WHEN exactly, by WHOM\n</code></pre>"},{"location":"patterns/domain-driven-design/#event-sourcing-approach","title":"Event Sourcing Approach \u2705","text":"<pre><code>def deposit_money(self, amount: Decimal, transaction_id: str):\n    # Create event with full context\n    event = MoneyDepositedEvent(\n        aggregate_id=self.id,\n        amount=amount,\n        new_balance=self.balance + amount,\n        transaction_id=transaction_id\n    )\n\n    # Apply event to state (predictable, testable)\n    self.state.on(event)\n\n    # Register for persistence (audit trail, replay capability)\n    self.register_event(event)\n</code></pre>"},{"location":"patterns/domain-driven-design/#benefits-of-the-frameworks-event-pattern","title":"Benefits of the Framework's Event Pattern","text":"<ol> <li>\ud83d\udd04 Replay Capability: States can be reconstructed from events</li> <li>\ud83d\udccb Complete Audit Trail: Every state change is captured with context</li> <li>\ud83e\uddea Testability: Events are pure data, easy to test</li> <li>\ud83c\udfaf Consistency: All state changes go through the same event pipeline</li> <li>\ud83d\udd0c Integration: Events naturally publish to external systems</li> <li>\ud83d\udcc8 Temporal Queries: Query state at any point in time</li> <li>\ud83d\udee1\ufe0f Immutability: Events are immutable, ensuring data integrity</li> </ol>"},{"location":"patterns/domain-driven-design/#complete-real-world-example-openbank","title":"\ud83c\udfe6 Complete Real-World Example: OpenBank","text":""},{"location":"patterns/domain-driven-design/#full-domain-model-implementation","title":"Full Domain Model Implementation","text":"<p>Here's a complete example from the OpenBank sample showing the full data abstraction pattern:</p> <pre><code># Domain Events\n@dataclass\nclass BankAccountCreatedDomainEventV1(DomainEvent[str]):\n    \"\"\"Event raised when a bank account is created\"\"\"\n    owner_id: str\n    overdraft_limit: Decimal\n\n@dataclass\nclass BankAccountTransactionRecordedDomainEventV1(DomainEvent[str]):\n    \"\"\"Event raised when a transaction is recorded\"\"\"\n    transaction: BankTransactionV1\n\n# Aggregate State with Event Handlers\n@map_to(BankAccountDto)\nclass BankAccountStateV1(AggregateState[str]):\n    \"\"\"Bank account state with multiple dispatch event handlers\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.transactions: List[BankTransactionV1] = []\n        self.balance: Decimal = Decimal(\"0.00\")\n        self.overdraft_limit: Decimal = Decimal(\"0.00\")\n        self.owner_id: str = \"\"\n\n    @dispatch(BankAccountCreatedDomainEventV1)\n    def on(self, event: BankAccountCreatedDomainEventV1):\n        \"\"\"Apply account creation event\"\"\"\n        self.id = event.aggregate_id\n        self.created_at = event.created_at\n        self.owner_id = event.owner_id\n        self.overdraft_limit = event.overdraft_limit\n\n    @dispatch(BankAccountTransactionRecordedDomainEventV1)\n    def on(self, event: BankAccountTransactionRecordedDomainEventV1):\n        \"\"\"Apply transaction event and recompute balance\"\"\"\n        self.last_modified = event.created_at\n        self.transactions.append(event.transaction)\n        self._compute_balance()\n\n    def _compute_balance(self):\n        \"\"\"Recompute balance from all transactions (event sourcing)\"\"\"\n        balance = Decimal(\"0.00\")\n        for transaction in self.transactions:\n            if transaction.type in [BankTransactionTypeV1.DEPOSIT.value,\n                                  BankTransactionTypeV1.INTEREST.value]:\n                balance += Decimal(transaction.amount)\n            elif transaction.type == BankTransactionTypeV1.TRANSFER.value:\n                if transaction.to_account_id == self.id:\n                    balance += Decimal(transaction.amount)  # Incoming transfer\n                else:\n                    balance -= Decimal(transaction.amount)  # Outgoing transfer\n            else:  # Withdrawal\n                balance -= Decimal(transaction.amount)\n        self.balance = balance\n\n# Aggregate Root with Business Logic\nclass BankAccount(AggregateRoot[BankAccountStateV1, str]):\n    \"\"\"Bank account aggregate implementing banking business rules\"\"\"\n\n    def __init__(self, owner: Person, overdraft_limit: Decimal = Decimal(\"0.00\")):\n        super().__init__()\n\n        # Create account through event application\n        event = BankAccountCreatedDomainEventV1(\n            aggregate_id=str(uuid.uuid4()).replace('-', ''),\n            owner_id=owner.id(),\n            overdraft_limit=overdraft_limit\n        )\n\n        # Apply event to state AND register for persistence\n        self.state.on(event)\n        self.register_event(event)\n\n    def get_available_balance(self) -&gt; Decimal:\n        \"\"\"Calculate available balance including overdraft\"\"\"\n        return self.state.balance + self.state.overdraft_limit\n\n    def try_add_transaction(self, transaction: BankTransactionV1) -&gt; bool:\n        \"\"\"Attempt to add transaction with business rule validation\"\"\"\n\n        # Business rule: Check if transaction would cause overdraft\n        if (transaction.type not in [BankTransactionTypeV1.DEPOSIT,\n                                   BankTransactionTypeV1.INTEREST] and\n            not (transaction.type == BankTransactionTypeV1.TRANSFER and\n                 transaction.to_account_id == self.id()) and\n            transaction.amount &gt; self.get_available_balance()):\n            return False  # Transaction rejected\n\n        # Create and apply transaction event\n        event = BankAccountTransactionRecordedDomainEventV1(\n            aggregate_id=self.id(),\n            transaction=transaction\n        )\n\n        # Event application pattern\n        self.state.on(event)  # Updates state via multiple dispatch\n        self.register_event(event)  # Registers for persistence\n\n        return True  # Transaction accepted\n</code></pre>"},{"location":"patterns/domain-driven-design/#event-sourcing-aggregation-process","title":"Event Sourcing Aggregation Process","text":"<p>The framework includes an <code>Aggregator</code> class that reconstructs aggregate state from events:</p> <pre><code># /src/neuroglia/data/infrastructure/event_sourcing/abstractions.py\nclass Aggregator:\n    \"\"\"Reconstructs aggregates from event streams\"\"\"\n\n    def aggregate(self, events: List[EventRecord], aggregate_type: Type) -&gt; AggregateRoot:\n        \"\"\"Rebuild aggregate state from historical events\"\"\"\n\n        # 1. Create empty aggregate instance\n        aggregate: AggregateRoot = object.__new__(aggregate_type)\n        aggregate.state = aggregate.__orig_bases__[0].__args__[0]()\n\n        # 2. Replay all events in sequence\n        for event_record in events:\n            # Apply each event to state using multiple dispatch\n            aggregate.state.on(event_record.data)\n\n            # Update state version to match event version\n            aggregate.state.state_version = event_record.data.aggregate_version\n\n        return aggregate\n</code></pre>"},{"location":"patterns/domain-driven-design/#complete-data-flow-example","title":"Complete Data Flow Example","text":"<pre><code># Application Service using the pattern\nclass CreateBankAccountHandler(CommandHandler[CreateBankAccountCommand, OperationResult[BankAccountDto]]):\n\n    async def handle_async(self, command: CreateBankAccountCommand) -&gt; OperationResult[BankAccountDto]:\n\n        # 1. Load related aggregate (Person)\n        owner = await self.person_repository.get_by_id_async(command.owner_id)\n\n        # 2. Create new aggregate (triggers events)\n        account = BankAccount(owner, command.overdraft_limit)\n        #                     \u2191\n        # This constructor:\n        # - Creates BankAccountCreatedDomainEventV1\n        # - Calls self.state.on(event) \u2192 Updates state via @dispatch\n        # - Calls self.register_event(event) \u2192 Adds to _pending_events\n\n        # 3. Save aggregate (persists events and publishes)\n        saved_account = await self.repository.add_async(account)\n        #                                                   \u2191\n        # Repository implementation:\n        # - Appends events from _pending_events to event store\n        # - Publishes events to event bus for integration\n        # - Updates read models/projections\n        # - Clears _pending_events\n\n        # 4. Return DTO mapped from aggregate state\n        return self.created(self.mapper.map(saved_account.state, BankAccountDto))\n</code></pre>"},{"location":"patterns/domain-driven-design/#key-insights-from-the-openbank-example","title":"Key Insights from the OpenBank Example","text":"<ol> <li>\ud83c\udfaf Business Logic in Aggregates: All banking rules are enforced in the aggregate</li> <li>\ud83d\udcdd Events as Facts: Each event represents a business fact that occurred</li> <li>\ud83d\udd04 State from Events: Balance is computed from transaction events, not stored directly</li> <li>\ud83d\udee1\ufe0f Consistency Boundaries: Account aggregate ensures transaction consistency</li> <li>\ud83d\udd0c Automatic Integration: Events automatically trigger downstream processing</li> <li>\ud83d\udcca Audit Trail: Complete transaction history is preserved in events</li> <li>\ud83e\uddea Testable: Business logic can be tested by verifying events produced</li> </ol>"},{"location":"patterns/domain-driven-design/#3-aggregate-root","title":"3. Aggregate Root","text":"<p>Aggregate Roots define consistency boundaries and coordinate multiple entities:</p> <pre><code>from neuroglia.data.abstractions import AggregateRoot, AggregateState\nfrom multipledispatch import dispatch\nfrom enum import Enum\nfrom typing import Optional\n\nclass OrderStatus(Enum):\n    PENDING = \"PENDING\"\n    CONFIRMED = \"CONFIRMED\"\n    PREPARING = \"PREPARING\"\n    READY = \"READY\"\n    DELIVERED = \"DELIVERED\"\n    CANCELLED = \"CANCELLED\"\n\nclass PizzaOrderState(AggregateState[str]):\n    \"\"\"State for pizza order aggregate\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.customer_id = \"\"\n        self.items = []\n        self.total_amount = Decimal('0.00')\n        self.status = OrderStatus.PENDING\n        self.special_instructions = \"\"\n        self.estimated_delivery = None\n        self.payment_status = \"UNPAID\"\n\n    @dispatch(PizzaOrderPlacedEvent)\n    def on(self, event: PizzaOrderPlacedEvent):\n        \"\"\"Apply order placed event to state\"\"\"\n        self.id = event.aggregate_id\n        self.customer_id = event.customer_id\n        self.items = event.items.copy()\n        self.total_amount = event.total_amount\n        self.special_instructions = event.special_instructions\n        self.created_at = event.created_at\n\n    @dispatch(OrderStatusChangedEvent)\n    def on(self, event: OrderStatusChangedEvent):\n        \"\"\"Apply status change event to state\"\"\"\n        self.status = OrderStatus(event.new_status)\n        self.last_modified = event.created_at\n\n    @dispatch(PaymentProcessedEvent)\n    def on(self, event: PaymentProcessedEvent):\n        \"\"\"Apply payment processed event to state\"\"\"\n        self.payment_status = \"PAID\"\n        self.last_modified = event.created_at\n\nclass PizzaOrderAggregate(AggregateRoot[PizzaOrderState, str]):\n    \"\"\"Pizza order aggregate root implementing business rules\"\"\"\n\n    def __init__(self, order_id: str = None):\n        super().__init__()\n        if order_id:\n            self.state.id = order_id\n\n    def place_order(self, customer_id: str, items: List[Dict[str, Any]],\n                   special_instructions: str = \"\") -&gt; None:\n        \"\"\"Place a new pizza order with business validation\"\"\"\n\n        # Business rule validation\n        if not items:\n            raise ValueError(\"Order must contain at least one item\")\n\n        # Calculate total with business rules\n        total = Decimal('0.00')\n        for item in items:\n            if item['quantity'] &lt;= 0:\n                raise ValueError(\"Item quantity must be positive\")\n            total += Decimal(str(item['price'])) * item['quantity']\n\n        # Minimum order business rule\n        if total &lt; Decimal('10.00'):\n            raise ValueError(\"Minimum order amount is $10.00\")\n\n        # Create and apply domain event\n        event = PizzaOrderPlacedEvent(\n            aggregate_id=self.state.id,\n            customer_id=customer_id,\n            items=items,\n            total_amount=total,\n            special_instructions=special_instructions\n        )\n\n        self.state.on(event)\n        self.register_event(event)\n\n    def confirm_order(self, estimated_delivery: datetime, confirmed_by: str) -&gt; None:\n        \"\"\"Confirm order with business rules\"\"\"\n        if self.state.status != OrderStatus.PENDING:\n            raise ValueError(f\"Cannot confirm order in {self.state.status.value} status\")\n\n        self.state.estimated_delivery = estimated_delivery\n\n        # Create status change event\n        event = OrderStatusChangedEvent(\n            aggregate_id=self.state.id,\n            previous_status=self.state.status.value,\n            new_status=OrderStatus.CONFIRMED.value,\n            changed_by=confirmed_by,\n            reason=\"Order confirmed by kitchen\"\n        )\n\n        self.state.on(event)\n        self.register_event(event)\n\n    def process_payment(self, payment_method: str, transaction_id: str) -&gt; None:\n        \"\"\"Process payment with business validation\"\"\"\n        if self.state.payment_status == \"PAID\":\n            raise ValueError(\"Order is already paid\")\n\n        if self.state.status == OrderStatus.CANCELLED:\n            raise ValueError(\"Cannot process payment for cancelled order\")\n\n        event = PaymentProcessedEvent(\n            aggregate_id=self.state.id,\n            payment_method=payment_method,\n            amount=self.state.total_amount,\n            transaction_id=transaction_id\n        )\n\n        self.state.on(event)\n        self.register_event(event)\n\n    def cancel_order(self, reason: str, cancelled_by: str) -&gt; None:\n        \"\"\"Cancel order with business rules\"\"\"\n        if self.state.status in [OrderStatus.DELIVERED, OrderStatus.CANCELLED]:\n            raise ValueError(f\"Cannot cancel order in {self.state.status.value} status\")\n\n        event = OrderStatusChangedEvent(\n            aggregate_id=self.state.id,\n            previous_status=self.state.status.value,\n            new_status=OrderStatus.CANCELLED.value,\n            changed_by=cancelled_by,\n            reason=reason\n        )\n\n        self.state.on(event)\n        self.register_event(event)\n</code></pre>"},{"location":"patterns/domain-driven-design/#transaction-flow-with-multiple-domain-events","title":"\ud83d\udd04 Transaction Flow with Multiple Domain Events","text":"<p>When a single command requires multiple domain events, the framework ensures transactional consistency through the aggregate boundary:</p>"},{"location":"patterns/domain-driven-design/#complex-business-transaction-example","title":"Complex Business Transaction Example","text":"<pre><code>from typing import List\nfrom decimal import Decimal\n\nclass OrderWithPromotionAggregate(AggregateRoot[PizzaOrderState, str]):\n    \"\"\"Extended order aggregate with promotion handling\"\"\"\n\n    def place_order_with_promotion(self, customer_id: str, items: List[Dict[str, Any]],\n                                  promotion_code: str = None) -&gt; None:\n        \"\"\"Place order with potential promotion - multiple events in single transaction\"\"\"\n\n        # Step 1: Validate and place base order\n        self.place_order(customer_id, items)\n\n        # Step 2: Apply promotion if valid\n        if promotion_code:\n            discount_amount = self._validate_and_calculate_promotion(promotion_code)\n            if discount_amount &gt; 0:\n                # Create promotion applied event\n                promotion_event = PromotionAppliedEvent(\n                    aggregate_id=self.state.id,\n                    promotion_code=promotion_code,\n                    discount_amount=discount_amount,\n                    original_amount=self.state.total_amount\n                )\n\n                self.state.on(promotion_event)\n                self.register_event(promotion_event)\n\n        # Step 3: Check for loyalty points\n        loyalty_points = self._calculate_loyalty_points()\n        if loyalty_points &gt; 0:\n            loyalty_event = LoyaltyPointsEarnedEvent(\n                aggregate_id=self.state.id,\n                customer_id=customer_id,\n                points_earned=loyalty_points,\n                transaction_amount=self.state.total_amount\n            )\n\n            self.register_event(loyalty_event)\n\n    def _validate_and_calculate_promotion(self, promotion_code: str) -&gt; Decimal:\n        \"\"\"Business logic for promotion validation\"\"\"\n        promotions = {\n            \"FIRST10\": Decimal('10.00'),\n            \"STUDENT15\": self.state.total_amount * Decimal('0.15')\n        }\n        return promotions.get(promotion_code, Decimal('0.00'))\n\n    def _calculate_loyalty_points(self) -&gt; int:\n        \"\"\"Business logic for loyalty points calculation\"\"\"\n        # 1 point per dollar spent\n        return int(self.state.total_amount)\n\n@dataclass\nclass PromotionAppliedEvent(DomainEvent[str]):\n    \"\"\"Domain event for promotion application\"\"\"\n    promotion_code: str\n    discount_amount: Decimal\n    original_amount: Decimal\n\n@dataclass\nclass LoyaltyPointsEarnedEvent(DomainEvent[str]):\n    \"\"\"Domain event for loyalty points\"\"\"\n    customer_id: str\n    points_earned: int\n    transaction_amount: Decimal\n</code></pre>"},{"location":"patterns/domain-driven-design/#transaction-flow-visualization","title":"Transaction Flow Visualization","text":"<pre><code>sequenceDiagram\n    participant API as \ud83c\udf10 API Controller\n    participant CMD as \ud83d\udcbc Command Handler\n    participant AGG as \ud83c\udfdb\ufe0f Aggregate Root\n    participant REPO as \ud83d\udd0c Repository\n    participant BUS as \ud83d\udce1 Event Bus\n\n    API-&gt;&gt;CMD: PlaceOrderWithPromotionCommand\n\n    Note over CMD,AGG: Single Transaction Boundary\n    CMD-&gt;&gt;AGG: place_order_with_promotion()\n\n    AGG-&gt;&gt;AGG: validate_order_items()\n    AGG-&gt;&gt;AGG: register_event(OrderPlacedEvent)\n\n    AGG-&gt;&gt;AGG: validate_promotion()\n    AGG-&gt;&gt;AGG: register_event(PromotionAppliedEvent)\n\n    AGG-&gt;&gt;AGG: calculate_loyalty_points()\n    AGG-&gt;&gt;AGG: register_event(LoyaltyPointsEarnedEvent)\n\n    CMD-&gt;&gt;REPO: save_async(aggregate)\n\n    Note over REPO: Atomic Save Operation\n    REPO-&gt;&gt;REPO: persist_state()\n    REPO-&gt;&gt;BUS: publish_domain_events()\n\n    Note over BUS: Event Publishing (After Commit)\n    BUS-&gt;&gt;BUS: OrderPlacedEvent \u2192 Integration\n    BUS-&gt;&gt;BUS: PromotionAppliedEvent \u2192 Marketing\n    BUS-&gt;&gt;BUS: LoyaltyPointsEarnedEvent \u2192 Customer Service\n\n    REPO--&gt;&gt;CMD: Success\n    CMD--&gt;&gt;API: OperationResult&lt;OrderDto&gt;</code></pre>"},{"location":"patterns/domain-driven-design/#domain-events-vs-integration-events","title":"\ud83c\udf10 Domain Events vs Integration Events","text":"<p>The framework distinguishes between Domain Events (internal business events) and Integration Events (cross-boundary communication):</p>"},{"location":"patterns/domain-driven-design/#domain-event-integration-event-flow","title":"Domain Event \u2192 Integration Event Flow","text":"<pre><code>from neuroglia.eventing import DomainEventHandler\nfrom neuroglia.eventing.cloud_events import CloudEvent\nfrom typing import Dict, Any\n\nclass OrderDomainEventHandler(DomainEventHandler[PizzaOrderPlacedEvent]):\n    \"\"\"Handles domain events and publishes integration events\"\"\"\n\n    def __init__(self, event_bus: EventBus, mapper: Mapper):\n        self.event_bus = event_bus\n        self.mapper = mapper\n\n    async def handle_async(self, domain_event: PizzaOrderPlacedEvent) -&gt; None:\n        \"\"\"Convert domain event to integration event (CloudEvent)\"\"\"\n\n        # Transform domain event to integration event data\n        integration_data = {\n            \"orderId\": domain_event.aggregate_id,\n            \"customerId\": domain_event.customer_id,\n            \"totalAmount\": float(domain_event.total_amount),\n            \"items\": domain_event.items,\n            \"orderPlacedAt\": domain_event.created_at.isoformat()\n        }\n\n        # Create CloudEvent for external systems\n        cloud_event = CloudEvent(\n            source=\"mario-pizzeria/orders\",\n            type=\"com.mario-pizzeria.order.placed.v1\",\n            data=integration_data,\n            datacontenttype=\"application/json\"\n        )\n\n        # Publish to external systems\n        await self.event_bus.publish_async(cloud_event)\n\n        # Handle internal business workflows\n        await self._notify_kitchen(domain_event)\n        await self._update_inventory(domain_event)\n        await self._send_customer_confirmation(domain_event)\n\n    async def _notify_kitchen(self, event: PizzaOrderPlacedEvent) -&gt; None:\n        \"\"\"Internal business workflow - kitchen notification\"\"\"\n        kitchen_notification = KitchenOrderReceivedEvent(\n            order_id=event.aggregate_id,\n            items=event.items,\n            special_instructions=event.special_instructions\n        )\n        await self.event_bus.publish_async(kitchen_notification)\n\n    async def _update_inventory(self, event: PizzaOrderPlacedEvent) -&gt; None:\n        \"\"\"Internal business workflow - inventory management\"\"\"\n        for item in event.items:\n            inventory_event = IngredientReservedEvent(\n                pizza_type=item['name'],\n                quantity=item['quantity'],\n                order_id=event.aggregate_id\n            )\n            await self.event_bus.publish_async(inventory_event)\n</code></pre>"},{"location":"patterns/domain-driven-design/#event-types-comparison","title":"Event Types Comparison","text":"Aspect Domain Events Integration Events (CloudEvents) Scope Internal to bounded context Cross-boundary communication Format Domain-specific objects Standardized CloudEvent format Audience Internal domain handlers External systems &amp; services Coupling Tightly coupled to domain Loosely coupled via contracts Evolution Can change with domain Must maintain backward compatibility Examples <code>OrderPlacedEvent</code>, <code>PaymentProcessedEvent</code> <code>com.mario-pizzeria.order.placed.v1</code> <pre><code>flowchart TB\n    subgraph \"\ud83c\udfdb\ufe0f Domain Layer\"\n        DomainOp[\"Domain Operation&lt;br/&gt;(place_order)\"]\n        DomainEvent[\"Domain Event&lt;br/&gt;(OrderPlacedEvent)\"]\n    end\n\n    subgraph \"\ud83d\udcbc Application Layer\"\n        EventHandler[\"Domain Event Handler&lt;br/&gt;(OrderDomainEventHandler)\"]\n        Transform[\"Event Transformation&lt;br/&gt;(Domain \u2192 Integration)\"]\n    end\n\n    subgraph \"\ud83d\udd0c Integration Layer\"\n        CloudEvent[\"Integration Event&lt;br/&gt;(CloudEvent)\"]\n        EventBus[\"Event Bus&lt;br/&gt;(External Publishing)\"]\n    end\n\n    subgraph \"\ud83c\udf10 External Systems\"\n        Payment[\"Payment Service\"]\n        Inventory[\"Inventory System\"]\n        Analytics[\"Analytics Platform\"]\n        CRM[\"Customer CRM\"]\n    end\n\n    DomainOp --&gt; DomainEvent\n    DomainEvent --&gt; EventHandler\n    EventHandler --&gt; Transform\n    Transform --&gt; CloudEvent\n    CloudEvent --&gt; EventBus\n    EventBus --&gt; Payment\n    EventBus --&gt; Inventory\n    EventBus --&gt; Analytics\n    EventBus --&gt; CRM\n\n    style DomainEvent fill:#e8f5e8\n    style CloudEvent fill:#fff3e0\n    style Transform fill:#e3f2fd</code></pre>"},{"location":"patterns/domain-driven-design/#event-sourcing-vs-traditional-implementation","title":"\ud83c\udfaf Event Sourcing vs Traditional Implementation","text":"<p>The framework supports both traditional state-based and event sourcing implementations:</p>"},{"location":"patterns/domain-driven-design/#traditional-crud-implementation","title":"Traditional CRUD Implementation","text":"<pre><code>class TraditionalOrderService:\n    \"\"\"Traditional CRUD approach - current state only\"\"\"\n\n    def __init__(self, repository: Repository[PizzaOrder, str]):\n        self.repository = repository\n\n    async def place_order_async(self, command: PlaceOrderCommand) -&gt; PizzaOrder:\n        \"\"\"Traditional approach - direct state mutation\"\"\"\n\n        # Create order entity with current state\n        order = PizzaOrder(\n            customer_id=command.customer_id,\n            items=command.items,\n            total_amount=self._calculate_total(command.items),\n            status=OrderStatus.PENDING,\n            created_at=datetime.now()\n        )\n\n        # Validate business rules\n        self._validate_order(order)\n\n        # Save current state only\n        saved_order = await self.repository.add_async(order)\n\n        # Manually trigger side effects\n        await self._send_notifications(saved_order)\n        await self._update_inventory(saved_order)\n\n        return saved_order\n\n    async def update_status_async(self, order_id: str, new_status: OrderStatus) -&gt; PizzaOrder:\n        \"\"\"Traditional approach - direct state update\"\"\"\n        order = await self.repository.get_async(order_id)\n        if not order:\n            raise ValueError(\"Order not found\")\n\n        # Direct state mutation (loses history)\n        old_status = order.status\n        order.status = new_status\n        order.updated_at = datetime.now()\n\n        # Save updated state (old state is lost)\n        return await self.repository.update_async(order)\n</code></pre>"},{"location":"patterns/domain-driven-design/#event-sourcing-implementation","title":"Event Sourcing Implementation","text":"<pre><code>from neuroglia.data.infrastructure.event_sourcing import EventSourcingRepository\n\nclass EventSourcedOrderService:\n    \"\"\"Event sourcing approach - complete history preservation\"\"\"\n\n    def __init__(self, repository: EventSourcingRepository[PizzaOrderAggregate, str]):\n        self.repository = repository\n\n    async def place_order_async(self, command: PlaceOrderCommand) -&gt; PizzaOrderAggregate:\n        \"\"\"Event sourcing approach - event-based state building\"\"\"\n\n        # Create new aggregate\n        aggregate = PizzaOrderAggregate(f\"order_{uuid.uuid4().hex[:8]}\")\n\n        # Apply business operation (generates events)\n        aggregate.place_order(\n            customer_id=command.customer_id,\n            items=command.items,\n            special_instructions=command.special_instructions\n        )\n\n        # Repository saves events and publishes them\n        return await self.repository.add_async(aggregate)\n\n    async def update_status_async(self, order_id: str, new_status: OrderStatus,\n                                 changed_by: str, reason: str) -&gt; PizzaOrderAggregate:\n        \"\"\"Event sourcing approach - reconstruct from events\"\"\"\n\n        # Reconstruct aggregate from events\n        aggregate = await self.repository.get_async(order_id)\n        if not aggregate:\n            raise ValueError(\"Order not found\")\n\n        # Apply business operation (generates new events)\n        if new_status == OrderStatus.CONFIRMED:\n            aggregate.confirm_order(\n                estimated_delivery=datetime.now() + timedelta(minutes=30),\n                confirmed_by=changed_by\n            )\n        elif new_status == OrderStatus.CANCELLED:\n            aggregate.cancel_order(reason, changed_by)\n\n        # Save new events (all history preserved)\n        return await self.repository.update_async(aggregate)\n</code></pre>"},{"location":"patterns/domain-driven-design/#implementation-comparison","title":"Implementation Comparison","text":"Aspect Traditional CRUD Event Sourcing State Storage Current state only Complete event history History Lost on updates Full audit trail preserved Rollback Manual snapshots required Replay to any point in time Analytics Limited to current state Rich temporal analysis Debugging Current state only Complete operation history Performance Fast reads Fast writes, reads via projections Complexity Lower Higher initial complexity <pre><code>flowchart LR\n    subgraph \"\ud83d\udcca Traditional CRUD\"\n        CRUD_State[\"Current State&lt;br/&gt;\u274c History Lost\"]\n        CRUD_DB[(\"Database&lt;br/&gt;Single Record\")]\n    end\n\n    subgraph \"\ud83d\udcc8 Event Sourcing\"\n        Events[\"Event Stream&lt;br/&gt;\ud83d\udcdc Complete History\"]\n        EventStore[(\"Event Store&lt;br/&gt;Immutable Events\")]\n        Projections[\"Read Models&lt;br/&gt;\ud83d\udcca Optimized Views\"]\n    end\n\n    subgraph \"\ud83d\udd0d Capabilities Comparison\"\n        Audit[\"\u2705 Audit Trail\"]\n        Rollback[\"\u2705 Time Travel\"]\n        Analytics[\"\u2705 Business Intelligence\"]\n        Debugging[\"\u2705 Complete Debugging\"]\n    end\n\n    CRUD_State --&gt; CRUD_DB\n    Events --&gt; EventStore\n    EventStore --&gt; Projections\n\n    Events --&gt; Audit\n    Events --&gt; Rollback\n    Events --&gt; Analytics\n    Events --&gt; Debugging\n\n    style Events fill:#e8f5e8\n    style EventStore fill:#fff3e0\n    style Projections fill:#e3f2fd\n    style CRUD_State fill:#ffebee</code></pre>"},{"location":"patterns/domain-driven-design/#data-flow-across-layers","title":"\ud83c\udfd7\ufe0f Data Flow Across Layers","text":""},{"location":"patterns/domain-driven-design/#complete-request-response-flow","title":"Complete Request-Response Flow","text":"<pre><code>sequenceDiagram\n    participant Client as \ud83c\udf10 Client\n    participant Controller as \ud83c\udfae API Controller\n    participant Handler as \ud83d\udcbc Command Handler\n    participant Aggregate as \ud83c\udfdb\ufe0f Aggregate Root\n    participant Repository as \ud83d\udd0c Repository\n    participant EventBus as \ud83d\udce1 Event Bus\n    participant Integration as \ud83c\udf0d External Systems\n\n    Client-&gt;&gt;Controller: POST /orders (PlaceOrderDto)\n\n    Note over Controller: \ud83d\udd04 DTO \u2192 Command Mapping\n    Controller-&gt;&gt;Controller: Map DTO to PlaceOrderCommand\n\n    Controller-&gt;&gt;Handler: mediator.execute_async(command)\n\n    Note over Handler: \ud83d\udcbc Application Logic\n    Handler-&gt;&gt;Handler: Validate command\n    Handler-&gt;&gt;Aggregate: Create/Load aggregate\n\n    Note over Aggregate: \ud83c\udfdb\ufe0f Domain Logic\n    Aggregate-&gt;&gt;Aggregate: Apply business rules\n    Aggregate-&gt;&gt;Aggregate: Generate domain events\n\n    Handler-&gt;&gt;Repository: save_async(aggregate)\n\n    Note over Repository: \ud83d\udd0c Persistence\n    Repository-&gt;&gt;Repository: Save aggregate state\n    Repository-&gt;&gt;Repository: Extract pending events\n\n    loop For each Domain Event\n        Repository-&gt;&gt;EventBus: publish_domain_event()\n        EventBus-&gt;&gt;EventBus: Convert to integration event\n        EventBus-&gt;&gt;Integration: Publish CloudEvent\n    end\n\n    Repository--&gt;&gt;Handler: Persisted aggregate\n    Handler-&gt;&gt;Handler: Map aggregate to DTO\n    Handler--&gt;&gt;Controller: OperationResult&lt;OrderDto&gt;\n    Controller--&gt;&gt;Client: HTTP 201 Created (OrderDto)\n\n    Note over Integration: \ud83c\udf0d External Processing\n    Integration-&gt;&gt;Integration: Payment processing\n    Integration-&gt;&gt;Integration: Inventory updates\n    Integration-&gt;&gt;Integration: Customer notifications</code></pre>"},{"location":"patterns/domain-driven-design/#data-transformation-flow","title":"Data Transformation Flow","text":"<pre><code>from neuroglia.mvc import ControllerBase\nfrom neuroglia.mediation import Mediator, Command, OperationResult\nfrom neuroglia.mapping import Mapper\n\n# 1. API Layer - Controllers and DTOs\n@dataclass\nclass PlaceOrderDto:\n    \"\"\"Data Transfer Object for API requests\"\"\"\n    customer_id: str\n    items: List[Dict[str, Any]]\n    special_instructions: str = \"\"\n\n@dataclass\nclass OrderDto:\n    \"\"\"Data Transfer Object for API responses\"\"\"\n    id: str\n    customer_id: str\n    items: List[Dict[str, Any]]\n    total_amount: float\n    status: str\n    created_at: str\n\nclass OrdersController(ControllerBase):\n    \"\"\"API Controller handling HTTP requests\"\"\"\n\n    @post(\"/orders\", response_model=OrderDto, status_code=201)\n    async def place_order(self, dto: PlaceOrderDto) -&gt; OrderDto:\n        \"\"\"\ud83c\udf10 API Layer: Transform DTO to Command\"\"\"\n        command = self.mapper.map(dto, PlaceOrderCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n# 2. Application Layer - Commands and Handlers\n@dataclass\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Application command for placing orders\"\"\"\n    customer_id: str\n    items: List[Dict[str, Any]]\n    special_instructions: str = \"\"\n\nclass PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    \"\"\"\ud83d\udcbc Application Layer: Business orchestration\"\"\"\n\n    def __init__(self, repository: Repository[PizzaOrderAggregate, str],\n                 mapper: Mapper):\n        self.repository = repository\n        self.mapper = mapper\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        \"\"\"Handle command with domain coordination\"\"\"\n        try:\n            # Create domain aggregate\n            aggregate = PizzaOrderAggregate()\n\n            # Apply domain operation\n            aggregate.place_order(\n                customer_id=command.customer_id,\n                items=command.items,\n                special_instructions=command.special_instructions\n            )\n\n            # Persist with events\n            saved_aggregate = await self.repository.add_async(aggregate)\n\n            # Transform back to DTO\n            dto = self.mapper.map(saved_aggregate.state, OrderDto)\n            return self.created(dto)\n\n        except ValueError as e:\n            return self.bad_request(str(e))\n        except Exception as e:\n            return self.internal_server_error(f\"Failed to place order: {str(e)}\")\n\n# 3. Integration Layer - Event Handlers\nclass OrderIntegrationEventHandler(DomainEventHandler[PizzaOrderPlacedEvent]):\n    \"\"\"\ud83d\udd0c Integration Layer: External system coordination\"\"\"\n\n    async def handle_async(self, event: PizzaOrderPlacedEvent) -&gt; None:\n        \"\"\"Transform domain events to integration events\"\"\"\n\n        # Convert to CloudEvent for external systems\n        cloud_event = CloudEvent(\n            source=\"mario-pizzeria/orders\",\n            type=\"com.mario-pizzeria.order.placed.v1\",\n            data={\n                \"orderId\": event.aggregate_id,\n                \"customerId\": event.customer_id,\n                \"totalAmount\": float(event.total_amount),\n                \"timestamp\": event.created_at.isoformat()\n            }\n        )\n\n        await self.event_bus.publish_async(cloud_event)\n</code></pre>"},{"location":"patterns/domain-driven-design/#when-to-use-domain-driven-design","title":"\ud83c\udfaf When to Use Domain Driven Design","text":""},{"location":"patterns/domain-driven-design/#ideal-use-cases","title":"\u2705 Ideal Use Cases","text":"<ul> <li>Complex Business Logic: Rich domain rules and workflows</li> <li>Long-term Projects: Systems that will evolve over years</li> <li>Large Teams: Multiple developers working on same domain</li> <li>Event-driven Systems: Business events drive system behavior</li> <li>Audit Requirements: Need complete operation history</li> <li>Collaborative Development: Business experts and developers working together</li> </ul>"},{"location":"patterns/domain-driven-design/#consider-alternatives-when","title":"\u274c Consider Alternatives When","text":"<ul> <li>Simple CRUD: Basic data entry with minimal business rules</li> <li>Short-term Projects: Quick prototypes or temporary solutions</li> <li>Small Teams: 1-2 developers with simple requirements</li> <li>Performance Critical: Microsecond latency requirements</li> <li>Read-heavy Systems: Mostly queries with minimal writes</li> </ul>"},{"location":"patterns/domain-driven-design/#migration-path","title":"\ud83d\ude80 Migration Path","text":"<pre><code>flowchart TB\n    subgraph \"\ud83d\udcca Current State: Simple CRUD\"\n        CRUD[\"Entity Classes&lt;br/&gt;Basic Repositories\"]\n        Services[\"Service Classes&lt;br/&gt;Business Logic\"]\n    end\n\n    subgraph \"\ud83c\udfaf Target State: Rich Domain Model\"\n        Entities[\"Rich Entities&lt;br/&gt;Business Behavior\"]\n        Aggregates[\"Aggregate Roots&lt;br/&gt;Consistency Boundaries\"]\n        Events[\"Domain Events&lt;br/&gt;Business Events\"]\n    end\n\n    subgraph \"\ud83d\udd04 Migration Steps\"\n        Step1[\"1: Extract Business Logic&lt;br/&gt;Move logic from services to entities\"]\n        Step2[\"2: Identify Aggregates&lt;br/&gt;Define consistency boundaries\"]\n        Step3[\"3: Add Domain Events&lt;br/&gt;Capture business occurrences\"]\n        Step4[\"4: Implement Event Sourcing&lt;br/&gt;Optional advanced pattern\"]\n    end\n\n    CRUD --&gt; Step1\n    Services --&gt; Step1\n    Step1 --&gt; Step2\n    Step2 --&gt; Step3\n    Step3 --&gt; Step4\n    Step4 --&gt; Entities\n    Step4 --&gt; Aggregates\n    Step4 --&gt; Events\n\n    style Step1 fill:#e3f2fd\n    style Step2 fill:#e8f5e8\n    style Step3 fill:#fff3e0\n    style Step4 fill:#f3e5f5</code></pre>"},{"location":"patterns/domain-driven-design/#testing-domain-abstractions","title":"\ud83e\uddea Testing Domain Abstractions","text":""},{"location":"patterns/domain-driven-design/#testing-event-driven-aggregates","title":"Testing Event-Driven Aggregates","text":"<p>The event-driven pattern makes domain logic highly testable through event verification:</p> <pre><code>import pytest\nfrom decimal import Decimal\nfrom samples.openbank.domain.models.bank_account import BankAccount, Person\nfrom samples.openbank.domain.models.bank_transaction import BankTransactionV1, BankTransactionTypeV1\nfrom samples.openbank.domain.events.bank_account import BankAccountCreatedDomainEventV1\n\nclass TestBankAccountAggregate:\n    \"\"\"Test bank account domain logic through events\"\"\"\n\n    def test_account_creation_produces_correct_event(self):\n        \"\"\"Test that account creation produces the expected domain event\"\"\"\n\n        # Arrange\n        owner = Person(\"John\", \"Doe\", \"US\", PersonGender.MALE, date(1980, 1, 1), Address(...))\n        overdraft_limit = Decimal(\"500.00\")\n\n        # Act\n        account = BankAccount(owner, overdraft_limit)\n\n        # Assert - Verify event was registered\n        assert len(account._pending_events) == 1\n\n        # Assert - Verify event type and data\n        created_event = account._pending_events[0]\n        assert isinstance(created_event, BankAccountCreatedDomainEventV1)\n        assert created_event.owner_id == owner.id()\n        assert created_event.overdraft_limit == overdraft_limit\n\n        # Assert - Verify state was updated correctly\n        assert account.state.owner_id == owner.id()\n        assert account.state.overdraft_limit == overdraft_limit\n        assert account.state.balance == Decimal(\"0.00\")\n\n    def test_successful_transaction_updates_state_and_registers_event(self):\n        \"\"\"Test transaction processing with event verification\"\"\"\n\n        # Arrange\n        owner = Person(\"Jane\", \"Smith\", \"CA\", PersonGender.FEMALE, date(1990, 1, 1), Address(...))\n        account = BankAccount(owner, Decimal(\"100.00\"))\n\n        deposit_transaction = BankTransactionV1(\n            amount=Decimal(\"250.00\"),\n            type=BankTransactionTypeV1.DEPOSIT,\n            description=\"Initial deposit\"\n        )\n\n        # Clear creation event for clean test\n        account.clear_pending_events()\n\n        # Act\n        result = account.try_add_transaction(deposit_transaction)\n\n        # Assert - Transaction was accepted\n        assert result is True\n\n        # Assert - Event was registered\n        assert len(account._pending_events) == 1\n        transaction_event = account._pending_events[0]\n        assert transaction_event.transaction == deposit_transaction\n\n        # Assert - State was updated correctly\n        assert account.state.balance == Decimal(\"250.00\")\n        assert len(account.state.transactions) == 1\n        assert account.state.transactions[0] == deposit_transaction\n\n    def test_overdraft_rejection_produces_no_events(self):\n        \"\"\"Test business rule validation prevents invalid operations\"\"\"\n\n        # Arrange\n        owner = Person(\"Bob\", \"Wilson\", \"UK\", PersonGender.MALE, date(1975, 6, 15), Address(...))\n        account = BankAccount(owner, Decimal(\"50.00\"))  # Small overdraft limit\n\n        withdrawal_transaction = BankTransactionV1(\n            amount=Decimal(\"100.00\"),  # Exceeds balance + overdraft\n            type=BankTransactionTypeV1.WITHDRAWAL,\n            description=\"Large withdrawal\"\n        )\n\n        account.clear_pending_events()\n\n        # Act\n        result = account.try_add_transaction(withdrawal_transaction)\n\n        # Assert - Transaction was rejected\n        assert result is False\n\n        # Assert - No events were registered\n        assert len(account._pending_events) == 0\n\n        # Assert - State remains unchanged\n        assert account.state.balance == Decimal(\"0.00\")\n        assert len(account.state.transactions) == 0\n</code></pre>"},{"location":"patterns/domain-driven-design/#testing-event-handlers-with-multiple-dispatch","title":"Testing Event Handlers with Multiple Dispatch","text":"<pre><code>class TestBankAccountState:\n    \"\"\"Test state event handling in isolation\"\"\"\n\n    def test_account_created_event_handler(self):\n        \"\"\"Test @dispatch event handler for account creation\"\"\"\n\n        # Arrange\n        state = BankAccountStateV1()\n        event = BankAccountCreatedDomainEventV1(\n            aggregate_id=\"account-123\",\n            owner_id=\"person-456\",\n            overdraft_limit=Decimal(\"1000.00\")\n        )\n\n        # Act\n        state.on(event)  # Multiple dispatch routes to correct handler\n\n        # Assert\n        assert state.id == \"account-123\"\n        assert state.owner_id == \"person-456\"\n        assert state.overdraft_limit == Decimal(\"1000.00\")\n        assert state.created_at == event.created_at\n\n    def test_balance_computation_from_events(self):\n        \"\"\"Test that balance is correctly computed from event sequence\"\"\"\n\n        # Arrange\n        state = BankAccountStateV1()\n\n        # Series of transaction events\n        events = [\n            BankAccountTransactionRecordedDomainEventV1(\n                aggregate_id=\"account-123\",\n                transaction=BankTransactionV1(\n                    amount=Decimal(\"500.00\"),\n                    type=BankTransactionTypeV1.DEPOSIT,\n                    description=\"Initial deposit\"\n                )\n            ),\n            BankAccountTransactionRecordedDomainEventV1(\n                aggregate_id=\"account-123\",\n                transaction=BankTransactionV1(\n                    amount=Decimal(\"150.00\"),\n                    type=BankTransactionTypeV1.WITHDRAWAL,\n                    description=\"ATM withdrawal\"\n                )\n            ),\n            BankAccountTransactionRecordedDomainEventV1(\n                aggregate_id=\"account-123\",\n                transaction=BankTransactionV1(\n                    amount=Decimal(\"25.00\"),\n                    type=BankTransactionTypeV1.INTEREST,\n                    description=\"Monthly interest\"\n                )\n            )\n        ]\n\n        # Act - Apply events in sequence\n        for event in events:\n            state.on(event)\n\n        # Assert - Balance computed correctly\n        expected_balance = Decimal(\"500.00\") - Decimal(\"150.00\") + Decimal(\"25.00\")\n        assert state.balance == expected_balance\n        assert len(state.transactions) == 3\n</code></pre>"},{"location":"patterns/domain-driven-design/#integration-testing-with-event-store","title":"Integration Testing with Event Store","text":"<pre><code>class TestBankAccountIntegration:\n    \"\"\"Integration tests with event sourcing infrastructure\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_aggregate_reconstruction_from_events(self):\n        \"\"\"Test that aggregates can be rebuilt from event streams\"\"\"\n\n        # Arrange - Create and save aggregate with multiple operations\n        owner = Person(\"Alice\", \"Johnson\", \"US\", PersonGender.FEMALE, date(1985, 3, 20), Address(...))\n        account = BankAccount(owner, Decimal(\"200.00\"))\n\n        account.try_add_transaction(BankTransactionV1(\n            amount=Decimal(\"1000.00\"),\n            type=BankTransactionTypeV1.DEPOSIT,\n            description=\"Salary deposit\"\n        ))\n\n        account.try_add_transaction(BankTransactionV1(\n            amount=Decimal(\"300.00\"),\n            type=BankTransactionTypeV1.WITHDRAWAL,\n            description=\"Rent payment\"\n        ))\n\n        # Save to repository (persists events)\n        await self.repository.add_async(account)\n        account_id = account.id()\n\n        # Act - Load aggregate from event store\n        reconstructed_account = await self.repository.get_by_id_async(account_id)\n\n        # Assert - State matches original\n        assert reconstructed_account.state.balance == Decimal(\"700.00\")  # 1000 - 300\n        assert len(reconstructed_account.state.transactions) == 2\n        assert reconstructed_account.state.owner_id == owner.id()\n        assert reconstructed_account.state.overdraft_limit == Decimal(\"200.00\")\n</code></pre>"},{"location":"patterns/domain-driven-design/#testing-domain-event-publishing","title":"Testing Domain Event Publishing","text":"<pre><code>class TestDomainEventIntegration:\n    \"\"\"Test domain event publishing and handling\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_domain_events_trigger_integration_events(self):\n        \"\"\"Test that domain events are properly published as integration events\"\"\"\n\n        # Arrange\n        mock_event_bus = Mock(spec=EventBus)\n        handler = BankAccountDomainEventHandler(\n            mediator=self.mediator,\n            mapper=self.mapper,\n            write_models=self.write_repository,\n            read_models=self.read_repository,\n            cloud_event_bus=mock_event_bus,\n            cloud_event_publishing_options=CloudEventPublishingOptions()\n        )\n\n        domain_event = BankAccountCreatedDomainEventV1(\n            aggregate_id=\"account-789\",\n            owner_id=\"person-123\",\n            overdraft_limit=Decimal(\"500.00\")\n        )\n\n        # Act\n        await handler.handle_async(domain_event)\n\n        # Assert - Cloud event was published\n        mock_event_bus.publish_async.assert_called_once()\n        published_event = mock_event_bus.publish_async.call_args[0][0]\n\n        assert published_event.type == \"bank-account.created.v1\"\n        assert published_event.source == \"openbank.accounts\"\n        assert \"account-789\" in published_event.data\n</code></pre>"},{"location":"patterns/domain-driven-design/#key-testing-benefits","title":"Key Testing Benefits","text":"<ol> <li>\ud83c\udfaf Clear Expectations: Events make the expected behavior explicit</li> <li>\ud83d\udd0d Easy Verification: Test what events are produced, not internal state</li> <li>\ud83e\uddea Isolated Testing: Test domain logic without infrastructure dependencies</li> <li>\ud83d\udcdd Living Documentation: Tests serve as examples of domain behavior</li> <li>\ud83d\udee1\ufe0f Regression Protection: Changes that break domain rules fail tests immediately</li> <li>\ud83d\udd04 Event Replay Testing: Verify aggregates can be reconstructed from events</li> <li>\u26a1 Fast Execution: Pure domain tests run quickly without I/O</li> </ol>"},{"location":"patterns/domain-driven-design/#related-patterns","title":"\ud83d\udd17 Related Patterns","text":"<ul> <li>\ud83c\udfd7\ufe0f Clean Architecture - Foundational layering that supports DDD</li> <li>\ud83d\udce1 CQRS &amp; Mediation - Command/Query patterns for domain operations</li> <li>\ud83c\udfaf Event Sourcing - Advanced persistence using domain events</li> <li>\ud83d\udd04 Event-Driven Architecture - System integration through domain events</li> <li>\ud83d\udcbe Repository Pattern - Data access abstraction for aggregates</li> </ul> <p>Domain Driven Design provides the foundation for building maintainable, business-focused applications. The Neuroglia framework's abstractions support both simple domain models and advanced patterns like event sourcing, allowing teams to evolve their architecture as complexity grows.</p>"},{"location":"patterns/event-driven/","title":"\ud83d\udce1 Event-Driven Architecture Pattern","text":"<p>\ud83d\udea7 Under Construction</p> <p>This page is currently being developed with comprehensive examples from Mario's Pizzeria. More detailed implementations and code samples are being added.</p> <p>Event-Driven Architecture uses events to communicate between decoupled components, enabling loose coupling, scalability, and reactive system behavior.</p>"},{"location":"patterns/event-driven/#overview","title":"\ud83c\udfaf Overview","text":"<p>Event-Driven Architecture (EDA) promotes loose coupling through asynchronous event communication. Mario's Pizzeria demonstrates this pattern through domain events that coordinate kitchen operations, customer notifications, and order tracking.</p> <pre><code>flowchart TD\n    subgraph \"\ud83c\udf55 Mario's Pizzeria Event Flow\"\n        Customer[Customer]\n\n        subgraph Domain[\"\ud83c\udfdb\ufe0f Domain Events\"]\n            OrderPlaced[OrderPlacedEvent]\n            PaymentProcessed[PaymentProcessedEvent]\n            OrderCooking[OrderCookingStartedEvent]\n            OrderReady[OrderReadyEvent]\n            OrderDelivered[OrderDeliveredEvent]\n        end\n\n        subgraph Handlers[\"\ud83d\udce1 Event Handlers\"]\n            KitchenHandler[Kitchen Workflow Handler]\n            NotificationHandler[SMS Notification Handler]\n            InventoryHandler[Inventory Update Handler]\n            AnalyticsHandler[Analytics Handler]\n            EmailHandler[Email Confirmation Handler]\n        end\n\n        subgraph External[\"\ud83d\udd0c External Systems\"]\n            Kitchen[Kitchen Display]\n            SMS[SMS Service]\n            Email[Email Service]\n            Analytics[Analytics DB]\n            Inventory[Inventory System]\n        end\n    end\n\n    Customer --&gt;|\"Place Order\"| OrderPlaced\n\n    OrderPlaced --&gt; KitchenHandler\n    OrderPlaced --&gt; NotificationHandler\n    OrderPlaced --&gt; InventoryHandler\n    OrderPlaced --&gt; EmailHandler\n\n    KitchenHandler --&gt;|\"Start Cooking\"| OrderCooking\n    KitchenHandler --&gt; Kitchen\n\n    OrderCooking --&gt; AnalyticsHandler\n\n    Kitchen --&gt;|\"Pizza Ready\"| OrderReady\n    OrderReady --&gt; NotificationHandler\n    OrderReady --&gt; AnalyticsHandler\n\n    NotificationHandler --&gt; SMS\n    EmailHandler --&gt; Email\n    InventoryHandler --&gt; Inventory\n    AnalyticsHandler --&gt; Analytics\n\n    OrderReady --&gt;|\"Out for Delivery\"| OrderDelivered</code></pre>"},{"location":"patterns/event-driven/#benefits","title":"\u2705 Benefits","text":""},{"location":"patterns/event-driven/#1-loose-coupling","title":"1. Loose Coupling","text":"<p>Components communicate through events without direct dependencies:</p> <pre><code># Order placement doesn't know about kitchen or notifications\nclass PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        order = Order.create(command.customer_id, command.items)\n        await self._repository.save_async(order)\n\n        # Domain entity raises event - handler doesn't know who listens\n        # OrderPlacedEvent is automatically published by the framework\n\n        return self.created(self.mapper.map(order, OrderDto))\n\n# Multiple handlers can respond to events independently\nclass KitchenWorkflowHandler(EventHandler[OrderPlacedEvent]):\n    async def handle_async(self, event: OrderPlacedEvent):\n        await self._kitchen_service.add_to_queue_async(event.order_id)\n\nclass CustomerNotificationHandler(EventHandler[OrderPlacedEvent]):\n    async def handle_async(self, event: OrderPlacedEvent):\n        await self._sms_service.send_confirmation_async(\n            event.customer_phone, event.order_id\n        )\n</code></pre>"},{"location":"patterns/event-driven/#2-scalability","title":"2. Scalability","text":"<p>Event handlers can be scaled independently based on load:</p> <pre><code># High-volume analytics can be processed separately\nclass OrderAnalyticsHandler(EventHandler[OrderPlacedEvent]):\n    async def handle_async(self, event: OrderPlacedEvent):\n        # This can be processed in background/separate service\n        analytics_data = AnalyticsEvent(\n            event_type=\"order_placed\",\n            customer_id=event.customer_id,\n            order_value=event.total_amount,\n            timestamp=event.occurred_at\n        )\n        await self._analytics_service.track_async(analytics_data)\n</code></pre>"},{"location":"patterns/event-driven/#3-resilience","title":"3. Resilience","text":"<p>Failed event handlers don't affect the main workflow:</p> <pre><code># If SMS fails, order processing continues\nclass ResilientNotificationHandler(EventHandler[OrderReadyEvent]):\n    async def handle_async(self, event: OrderReadyEvent):\n        try:\n            await self._sms_service.notify_customer_async(\n                event.customer_phone,\n                f\"Your order #{event.order_id} is ready!\"\n            )\n        except Exception as ex:\n            # Log error but don't fail the entire workflow\n            self._logger.error(f\"SMS notification failed: {ex}\")\n            # Could queue for retry or use alternative notification\n</code></pre>"},{"location":"patterns/event-driven/#data-flow","title":"\ud83d\udd04 Data Flow","text":"<p>The pizza preparation workflow demonstrates event-driven data flow:</p> <pre><code>sequenceDiagram\n    participant Customer\n    participant OrderAPI\n    participant OrderHandler\n    participant EventBus\n    participant KitchenHandler\n    participant NotificationHandler\n    participant Kitchen\n    participant SMS\n\n    Customer-&gt;&gt;+OrderAPI: Place pizza order\n    OrderAPI-&gt;&gt;+OrderHandler: Handle PlaceOrderCommand\n\n    OrderHandler-&gt;&gt;OrderHandler: Create Order entity\n    Note over OrderHandler: Order.raise_event(OrderPlacedEvent)\n\n    OrderHandler-&gt;&gt;+EventBus: Publish OrderPlacedEvent\n    EventBus-&gt;&gt;KitchenHandler: Async delivery\n    EventBus-&gt;&gt;NotificationHandler: Async delivery\n    EventBus--&gt;&gt;-OrderHandler: Events published\n\n    OrderHandler--&gt;&gt;-OrderAPI: Order created successfully\n    OrderAPI--&gt;&gt;-Customer: 201 Created\n\n    Note over Customer,SMS: Parallel Event Processing\n\n    par Kitchen Workflow\n        KitchenHandler-&gt;&gt;+Kitchen: Add order to queue\n        Kitchen--&gt;&gt;-KitchenHandler: Order queued\n\n        Kitchen-&gt;&gt;Kitchen: Start cooking\n        Kitchen-&gt;&gt;+EventBus: Publish OrderCookingStartedEvent\n        EventBus--&gt;&gt;-Kitchen: Event published\n\n        Kitchen-&gt;&gt;Kitchen: Pizza ready\n        Kitchen-&gt;&gt;+EventBus: Publish OrderReadyEvent\n        EventBus-&gt;&gt;NotificationHandler: Deliver event\n        EventBus--&gt;&gt;-Kitchen: Event published\n\n    and Customer Notifications\n        NotificationHandler-&gt;&gt;+SMS: Send order confirmation\n        SMS--&gt;&gt;-NotificationHandler: SMS sent\n\n        Note over NotificationHandler: Wait for OrderReadyEvent\n\n        NotificationHandler-&gt;&gt;+SMS: Send \"order ready\" notification\n        SMS--&gt;&gt;-NotificationHandler: SMS sent\n        SMS-&gt;&gt;Customer: \"Your pizza is ready!\"\n    end</code></pre>"},{"location":"patterns/event-driven/#use-cases","title":"\ud83c\udfaf Use Cases","text":"<p>Event-Driven Architecture is ideal for:</p> <ul> <li>Microservices: Decoupled service communication</li> <li>Real-time Systems: Immediate response to state changes</li> <li>Complex Workflows: Multi-step processes with branching logic</li> <li>Integration: Connecting disparate systems</li> </ul>"},{"location":"patterns/event-driven/#implementation-in-marios-pizzeria","title":"\ud83c\udf55 Implementation in Mario's Pizzeria","text":""},{"location":"patterns/event-driven/#domain-events","title":"Domain Events","text":"<pre><code># Domain events represent important business occurrences\n@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    order_id: str\n    customer_id: str\n    customer_phone: str\n    items: List[OrderItemDto]\n    total_amount: Decimal\n    delivery_address: str\n    estimated_delivery_time: datetime\n\n@dataclass\nclass OrderReadyEvent(DomainEvent):\n    order_id: str\n    customer_id: str\n    customer_phone: str\n    preparation_time: timedelta\n    pickup_instructions: str\n\n@dataclass\nclass InventoryLowEvent(DomainEvent):\n    ingredient_id: str\n    ingredient_name: str\n    current_quantity: int\n    minimum_threshold: int\n    supplier_info: SupplierDto\n</code></pre>"},{"location":"patterns/event-driven/#event-handlers","title":"Event Handlers","text":"<pre><code># Kitchen workflow responds to order events\nclass KitchenWorkflowHandler(EventHandler[OrderPlacedEvent]):\n    def __init__(self,\n                 kitchen_service: KitchenService,\n                 inventory_service: InventoryService):\n        self._kitchen = kitchen_service\n        self._inventory = inventory_service\n\n    async def handle_async(self, event: OrderPlacedEvent):\n        # Check ingredient availability\n        availability = await self._inventory.check_ingredients_async(event.items)\n        if not availability.all_available:\n            # Raise event for procurement\n            await self._event_bus.publish_async(\n                InventoryLowEvent(\n                    ingredient_id=availability.missing_ingredients[0],\n                    current_quantity=availability.current_stock,\n                    minimum_threshold=availability.required_stock\n                )\n            )\n\n        # Add to kitchen queue\n        kitchen_order = KitchenOrder(\n            order_id=event.order_id,\n            items=event.items,\n            priority=self._calculate_priority(event),\n            estimated_prep_time=self._calculate_prep_time(event.items)\n        )\n\n        await self._kitchen.add_to_queue_async(kitchen_order)\n\n        # Raise cooking started event\n        await self._event_bus.publish_async(\n            OrderCookingStartedEvent(\n                order_id=event.order_id,\n                estimated_ready_time=datetime.utcnow() + kitchen_order.estimated_prep_time\n            )\n        )\n\n# Customer communication handler\nclass CustomerCommunicationHandler:\n    def __init__(self,\n                 sms_service: SMSService,\n                 email_service: EmailService):\n        self._sms = sms_service\n        self._email = email_service\n\n    @event_handler(OrderPlacedEvent)\n    async def send_order_confirmation(self, event: OrderPlacedEvent):\n        confirmation_message = f\"\"\"\n        \ud83c\udf55 Order Confirmed!\n\n        Order #{event.order_id}\n        Total: ${event.total_amount}\n        Estimated delivery: {event.estimated_delivery_time.strftime('%H:%M')}\n\n        We'll notify you when your pizza is ready!\n        \"\"\"\n\n        await self._sms.send_async(event.customer_phone, confirmation_message)\n        await self._email.send_order_confirmation_async(event)\n\n    @event_handler(OrderReadyEvent)\n    async def send_ready_notification(self, event: OrderReadyEvent):\n        ready_message = f\"\"\"\n        \ud83c\udf89 Your pizza is ready!\n\n        Order #{event.order_id}\n        Pickup instructions: {event.pickup_instructions}\n\n        Please collect within 10 minutes for best quality.\n        \"\"\"\n\n        await self._sms.send_async(event.customer_phone, ready_message)\n\n# Analytics and reporting handler\nclass AnalyticsHandler:\n    @event_handler(OrderPlacedEvent)\n    async def track_order_metrics(self, event: OrderPlacedEvent):\n        metrics = OrderMetrics(\n            order_id=event.order_id,\n            customer_id=event.customer_id,\n            order_value=event.total_amount,\n            item_count=len(event.items),\n            order_time=event.occurred_at,\n            customer_type=await self._get_customer_type(event.customer_id)\n        )\n\n        await self._analytics_db.save_metrics_async(metrics)\n\n    @event_handler(OrderReadyEvent)\n    async def track_preparation_metrics(self, event: OrderReadyEvent):\n        prep_metrics = PreparationMetrics(\n            order_id=event.order_id,\n            preparation_time=event.preparation_time,\n            efficiency_score=self._calculate_efficiency(event.preparation_time)\n        )\n\n        await self._analytics_db.save_prep_metrics_async(prep_metrics)\n</code></pre>"},{"location":"patterns/event-driven/#event-bus-configuration","title":"Event Bus Configuration","text":"<pre><code># Configure event routing and handlers\nclass EventBusConfiguration:\n    def configure_events(self, services: ServiceCollection):\n        # Register event handlers\n        services.add_scoped(KitchenWorkflowHandler)\n        services.add_scoped(CustomerCommunicationHandler)\n        services.add_scoped(AnalyticsHandler)\n        services.add_scoped(InventoryManagementHandler)\n\n        # Configure event routing\n        services.add_event_handler(OrderPlacedEvent, KitchenWorkflowHandler)\n        services.add_event_handler(OrderPlacedEvent, CustomerCommunicationHandler)\n        services.add_event_handler(OrderPlacedEvent, AnalyticsHandler)\n\n        services.add_event_handler(OrderReadyEvent, CustomerCommunicationHandler)\n        services.add_event_handler(OrderReadyEvent, AnalyticsHandler)\n\n        services.add_event_handler(InventoryLowEvent, InventoryManagementHandler)\n</code></pre>"},{"location":"patterns/event-driven/#cloudevents-integration","title":"CloudEvents Integration","text":"<pre><code># CloudEvents for external system integration\nclass CloudEventPublisher:\n    def __init__(self, event_bus: EventBus):\n        self._event_bus = event_bus\n\n    async def publish_order_event(self, order_event: OrderPlacedEvent):\n        # Convert domain event to CloudEvent for external systems\n        cloud_event = CloudEvent(\n            source=\"mario-pizzeria/orders\",\n            type=\"com.mariopizzeria.order.placed\",\n            subject=f\"order/{order_event.order_id}\",\n            data={\n                \"orderId\": order_event.order_id,\n                \"customerId\": order_event.customer_id,\n                \"totalAmount\": float(order_event.total_amount),\n                \"items\": [item.to_dict() for item in order_event.items],\n                \"estimatedDelivery\": order_event.estimated_delivery_time.isoformat()\n            },\n            datacontenttype=\"application/json\"\n        )\n\n        await self._event_bus.publish_cloud_event_async(cloud_event)\n</code></pre>"},{"location":"patterns/event-driven/#testing-event-driven-systems","title":"\ud83e\uddea Testing Event-Driven Systems","text":"<pre><code># Test event handling independently\nclass TestKitchenWorkflowHandler:\n    def setup_method(self):\n        self.mock_kitchen = Mock(spec=KitchenService)\n        self.mock_inventory = Mock(spec=InventoryService)\n        self.handler = KitchenWorkflowHandler(self.mock_kitchen, self.mock_inventory)\n\n    async def test_order_placed_adds_to_kitchen_queue(self):\n        # Arrange\n        event = OrderPlacedEvent(\n            order_id=\"123\",\n            customer_id=\"456\",\n            items=[OrderItemDto(name=\"Margherita\", size=\"Large\")]\n        )\n\n        self.mock_inventory.check_ingredients_async.return_value = IngredientAvailability(\n            all_available=True\n        )\n\n        # Act\n        await self.handler.handle_async(event)\n\n        # Assert\n        self.mock_kitchen.add_to_queue_async.assert_called_once()\n        kitchen_order = self.mock_kitchen.add_to_queue_async.call_args[0][0]\n        assert kitchen_order.order_id == \"123\"\n\n# Integration testing with event bus\nclass TestEventIntegration:\n    async def test_order_placement_triggers_all_handlers(self):\n        # Arrange\n        event_bus = InMemoryEventBus()\n        kitchen_handler = Mock(spec=KitchenWorkflowHandler)\n        notification_handler = Mock(spec=CustomerCommunicationHandler)\n\n        event_bus.subscribe(OrderPlacedEvent, kitchen_handler)\n        event_bus.subscribe(OrderPlacedEvent, notification_handler)\n\n        event = OrderPlacedEvent(order_id=\"123\", customer_id=\"456\")\n\n        # Act\n        await event_bus.publish_async(event)\n\n        # Assert\n        kitchen_handler.handle_async.assert_called_once_with(event)\n        notification_handler.send_order_confirmation.assert_called_once_with(event)\n</code></pre>"},{"location":"patterns/event-driven/#related-patterns","title":"\ud83d\udd17 Related Patterns","text":"<ul> <li>CQRS Pattern - Commands often produce domain events</li> <li>Clean Architecture - Events enable layer decoupling</li> <li>Repository Pattern - Events can trigger repository operations</li> </ul> <p>This pattern guide demonstrates Event-Driven Architecture using Mario's Pizzeria's kitchen workflow and customer communication systems. Events enable loose coupling and reactive behavior across the entire pizza ordering experience. \ud83d\udce1</p>"},{"location":"patterns/event-sourcing/","title":"\ud83c\udfaf Event Sourcing Pattern","text":"<p>Event Sourcing is a data storage pattern where state changes are stored as a sequence of immutable events rather than updating data in place. Instead of persisting current state directly, the pattern captures all changes as events that can be replayed to reconstruct state at any point in time, providing complete audit trails, temporal queries, and business intelligence capabilities.</p>"},{"location":"patterns/event-sourcing/#pattern-intent","title":"\ud83c\udfaf Pattern Intent","text":"<p>Replace traditional state-based persistence with an append-only event log that serves as the authoritative source of truth. Enable system reconstruction, audit trails, temporal queries, and business analytics through immutable event sequences while maintaining data integrity and providing deep insights into system behavior over time.</p>"},{"location":"patterns/event-sourcing/#pattern-structure","title":"\ud83c\udfd7\ufe0f Pattern Structure","text":"<pre><code>flowchart TD\n    subgraph \"\ud83c\udfaf Event Sourcing Core\"\n        A[\"\ud83d\udcdd Domain Events&lt;br/&gt;Immutable Facts\"]\n        B[\"\ud83d\udcda Event Store&lt;br/&gt;Append-Only Log\"]\n        C[\"\ud83d\udd04 Event Stream&lt;br/&gt;Ordered Sequence\"]\n        D[\"\ud83c\udfd7\ufe0f Aggregate Root&lt;br/&gt;Business Logic\"]\n    end\n\n    subgraph \"\ud83d\udcca State Management\"\n        E[\"\u26a1 Current State&lt;br/&gt;Computed from Events\"]\n        F[\"\ud83d\udd70\ufe0f Historical State&lt;br/&gt;Point-in-Time Queries\"]\n        G[\"\ud83d\udcc8 Event Replay&lt;br/&gt;State Reconstruction\"]\n        H[\"\ud83d\udcf8 Snapshots&lt;br/&gt;Performance Optimization\"]\n    end\n\n    subgraph \"\ud83d\udccb Read Models\"\n        I[\"\ud83d\udcca Projections&lt;br/&gt;Optimized Views\"]\n        J[\"\ud83d\udd0d Query Models&lt;br/&gt;Specialized Indexes\"]\n        K[\"\ud83d\udcc8 Analytics Views&lt;br/&gt;Business Intelligence\"]\n        L[\"\ud83c\udfaf Denormalized Data&lt;br/&gt;Fast Queries\"]\n    end\n\n    A --&gt; B\n    B --&gt; C\n    C --&gt; D\n    D --&gt; E\n\n    C --&gt; F\n    B --&gt; G\n    E --&gt; H\n\n    C --&gt; I\n    I --&gt; J\n    I --&gt; K\n    I --&gt; L\n\n    style B fill:#e1f5fe,stroke:#0277bd,stroke-width:3px\n    style C fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\n    style E fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px\n\n    classDef projections fill:#fff3e0,stroke:#f57c00,stroke-width:2px\n    class I,J,K,L projections\n\n    classDef state fill:#fce4ec,stroke:#ad1457,stroke-width:2px\n    class E,F,G,H state</code></pre>"},{"location":"patterns/event-sourcing/#pattern-implementation","title":"\ud83c\udf55 Pattern Implementation","text":""},{"location":"patterns/event-sourcing/#core-event-sourcing-components","title":"Core Event Sourcing Components","text":"<pre><code>from neuroglia.data.abstractions import AggregateRoot, DomainEvent\nfrom neuroglia.eventing import event_handler\nfrom multipledispatch import dispatch\nfrom dataclasses import dataclass\nfrom decimal import Decimal\nfrom datetime import datetime\nfrom typing import List, Optional, Dict, Any\nimport uuid\n\n# Domain Events - Immutable Facts\n@dataclass\nclass PizzaOrderPlacedEvent(DomainEvent):\n    \"\"\"Event representing a pizza order being placed\"\"\"\n    order_id: str\n    customer_id: str\n    items: List[Dict[str, Any]]\n    total_amount: Decimal\n    placed_at: datetime\n\n@dataclass\nclass PizzaOrderConfirmedEvent(DomainEvent):\n    \"\"\"Event representing order confirmation\"\"\"\n    order_id: str\n    estimated_delivery_time: datetime\n    kitchen_notes: str\n    confirmed_at: datetime\n\n@dataclass\nclass PaymentProcessedEvent(DomainEvent):\n    \"\"\"Event representing successful payment\"\"\"\n    order_id: str\n    payment_method: str\n    amount: Decimal\n    transaction_id: str\n    processed_at: datetime\n\n@dataclass\nclass OrderStatusChangedEvent(DomainEvent):\n    \"\"\"Event representing order status changes\"\"\"\n    order_id: str\n    previous_status: str\n    new_status: str\n    changed_at: datetime\n    reason: Optional[str] = None\n\n# Aggregate Root with Event Sourcing\nclass PizzaOrder(AggregateRoot[str]):\n    \"\"\"Pizza order aggregate using event sourcing\"\"\"\n\n    def __init__(self, order_id: str = None):\n        super().__init__(order_id or str(uuid.uuid4()))\n\n        # Current state computed from events\n        self._customer_id = \"\"\n        self._items = []\n        self._total_amount = Decimal('0.00')\n        self._status = \"PENDING\"\n        self._placed_at = None\n        self._estimated_delivery = None\n        self._payment_status = \"UNPAID\"\n        self._kitchen_notes = \"\"\n\n    # Business Logic Methods - Produce Events\n    def place_order(self, customer_id: str, items: List[Dict[str, Any]], total_amount: Decimal):\n        \"\"\"Place a new pizza order - produces PizzaOrderPlacedEvent\"\"\"\n\n        # Business rule validation\n        if not items:\n            raise ValueError(\"Order must contain at least one item\")\n        if total_amount &lt;= 0:\n            raise ValueError(\"Order total must be positive\")\n\n        # Create and register domain event\n        event = PizzaOrderPlacedEvent(\n            order_id=self.id(),\n            customer_id=customer_id,\n            items=items,\n            total_amount=total_amount,\n            placed_at=datetime.utcnow()\n        )\n\n        # Apply event to update state and register for persistence\n        self.state.on(self.register_event(event))\n\n    def confirm_order(self, estimated_delivery_time: datetime, kitchen_notes: str = \"\"):\n        \"\"\"Confirm order - produces PizzaOrderConfirmedEvent\"\"\"\n\n        # Business rule validation\n        if self._status != \"PENDING\":\n            raise ValueError(f\"Cannot confirm order in status: {self._status}\")\n\n        event = PizzaOrderConfirmedEvent(\n            order_id=self.id(),\n            estimated_delivery_time=estimated_delivery_time,\n            kitchen_notes=kitchen_notes,\n            confirmed_at=datetime.utcnow()\n        )\n\n        self.state.on(self.register_event(event))\n\n    def process_payment(self, payment_method: str, transaction_id: str):\n        \"\"\"Process payment - produces PaymentProcessedEvent\"\"\"\n\n        if self._payment_status == \"PAID\":\n            raise ValueError(\"Order is already paid\")\n\n        event = PaymentProcessedEvent(\n            order_id=self.id(),\n            payment_method=payment_method,\n            amount=self._total_amount,\n            transaction_id=transaction_id,\n            processed_at=datetime.utcnow()\n        )\n\n        self.state.on(self.register_event(event))\n\n    def change_status(self, new_status: str, reason: str = None):\n        \"\"\"Change order status - produces OrderStatusChangedEvent\"\"\"\n\n        if self._status == new_status:\n            return  # No change needed\n\n        event = OrderStatusChangedEvent(\n            order_id=self.id(),\n            previous_status=self._status,\n            new_status=new_status,\n            changed_at=datetime.utcnow(),\n            reason=reason\n        )\n\n        self.state.on(self.register_event(event))\n\n    # State Reconstruction from Events using @dispatch\n    @dispatch(PizzaOrderPlacedEvent)\n    def state_manager(self, event: PizzaOrderPlacedEvent):\n        \"\"\"Apply order placed event to reconstruct state\"\"\"\n        self._customer_id = event.customer_id\n        self._items = event.items.copy()\n        self._total_amount = event.total_amount\n        self._status = \"PENDING\"\n        self._placed_at = event.placed_at\n\n    @dispatch(PizzaOrderConfirmedEvent)\n    def state_manager(self, event: PizzaOrderConfirmedEvent):\n        \"\"\"Apply order confirmed event to reconstruct state\"\"\"\n        self._status = \"CONFIRMED\"\n        self._estimated_delivery = event.estimated_delivery_time\n        self._kitchen_notes = event.kitchen_notes\n\n    @dispatch(PaymentProcessedEvent)\n    def state_manager(self, event: PaymentProcessedEvent):\n        \"\"\"Apply payment processed event to reconstruct state\"\"\"\n        self._payment_status = \"PAID\"\n        # Automatically move to cooking if order is confirmed and paid\n        if self._status == \"CONFIRMED\":\n            self._status = \"COOKING\"\n\n    @dispatch(OrderStatusChangedEvent)\n    def state_manager(self, event: OrderStatusChangedEvent):\n        \"\"\"Apply status change event to reconstruct state\"\"\"\n        self._status = event.new_status\n\n    # Property Accessors for Current State\n    @property\n    def customer_id(self) -&gt; str:\n        return self._customer_id\n\n    @property\n    def items(self) -&gt; List[Dict[str, Any]]:\n        return self._items.copy()\n\n    @property\n    def total_amount(self) -&gt; Decimal:\n        return self._total_amount\n\n    @property\n    def status(self) -&gt; str:\n        return self._status\n\n    @property\n    def payment_status(self) -&gt; str:\n        return self._payment_status\n\n    @property\n    def placed_at(self) -&gt; Optional[datetime]:\n        return self._placed_at\n\n    @property\n    def estimated_delivery(self) -&gt; Optional[datetime]:\n        return self._estimated_delivery\n</code></pre>"},{"location":"patterns/event-sourcing/#event-store-configuration","title":"Event Store Configuration","text":"<pre><code>from neuroglia.data.infrastructure.event_sourcing.event_store import ESEventStore\nfrom neuroglia.data.infrastructure.event_sourcing.abstractions import EventStoreOptions\nfrom neuroglia.hosting.web import WebApplicationBuilder\n\ndef configure_event_store(builder: WebApplicationBuilder):\n    \"\"\"Configure EventStoreDB for event sourcing\"\"\"\n\n    # Event store configuration\n    database_name = \"mario_pizzeria\"\n    consumer_group = \"pizzeria-api-v1\"\n\n    ESEventStore.configure(\n        builder,\n        EventStoreOptions(\n            database_name=database_name,\n            consumer_group=consumer_group,\n            connection_string=\"esdb://localhost:2113?tls=false\",\n            credentials={\"username\": \"admin\", \"password\": \"changeit\"}\n        )\n    )\n\n    # Configure event sourcing repository for write model\n    EventSourcingRepository.configure(builder, PizzaOrder, str)\n\n    return builder\n\n# Repository Pattern for Event-Sourced Aggregates\nclass EventSourcingRepository:\n    \"\"\"Repository for event-sourced aggregates\"\"\"\n\n    def __init__(self, event_store: EventStore, aggregator: Aggregator):\n        self.event_store = event_store\n        self.aggregator = aggregator\n\n    async def save_async(self, aggregate: PizzaOrder) -&gt; PizzaOrder:\n        \"\"\"Save aggregate events to event store\"\"\"\n\n        # Get uncommitted events from aggregate\n        events = aggregate.get_uncommitted_events()\n        if not events:\n            return aggregate\n\n        # Persist events to event store\n        stream_id = f\"PizzaOrder-{aggregate.id()}\"\n        await self.event_store.append_async(\n            stream_id=stream_id,\n            events=events,\n            expected_version=aggregate.version\n        )\n\n        # Mark events as committed\n        aggregate.mark_events_as_committed()\n\n        return aggregate\n\n    async def get_by_id_async(self, order_id: str) -&gt; Optional[PizzaOrder]:\n        \"\"\"Load aggregate by ID from event store\"\"\"\n\n        stream_id = f\"PizzaOrder-{order_id}\"\n\n        # Read events from event store\n        events = await self.event_store.read_async(\n            stream_id=stream_id,\n            direction=StreamReadDirection.FORWARDS\n        )\n\n        if not events:\n            return None\n\n        # Reconstruct aggregate from events\n        aggregate = PizzaOrder(order_id)\n        for event_record in events:\n            aggregate.state_manager(event_record.data)\n            aggregate.version = event_record.stream_revision\n\n        return aggregate\n</code></pre>"},{"location":"patterns/event-sourcing/#event-driven-projections-pattern","title":"Event-Driven Projections Pattern","text":"<pre><code>from neuroglia.eventing import event_handler\nfrom neuroglia.data.abstractions import Repository\n\n@dataclass\nclass PizzaOrderProjection:\n    \"\"\"Optimized read model for pizza order queries\"\"\"\n\n    id: str\n    customer_id: str\n    customer_name: str  # Denormalized for fast queries\n    customer_email: str  # Denormalized for fast queries\n    item_count: int\n    total_amount: Decimal\n    status: str\n    payment_status: str\n    placed_at: datetime\n    estimated_delivery: Optional[datetime]\n    last_updated: datetime\n\n    # Analytics fields computed from events\n    time_to_confirmation: Optional[int] = None  # seconds\n    time_to_payment: Optional[int] = None  # seconds\n\nclass PizzaOrderProjectionHandler:\n    \"\"\"Handles domain events to update read model projections\"\"\"\n\n    def __init__(self, read_repository: Repository[PizzaOrderProjection, str]):\n        self.read_repository = read_repository\n\n    @event_handler(PizzaOrderPlacedEvent)\n    async def handle_order_placed(self, event: PizzaOrderPlacedEvent):\n        \"\"\"Create read model projection when order is placed\"\"\"\n\n        # Fetch customer details for denormalization\n        customer = await self._get_customer_details(event.customer_id)\n\n        projection = PizzaOrderProjection(\n            id=event.order_id,\n            customer_id=event.customer_id,\n            customer_name=customer.name if customer else \"Unknown\",\n            customer_email=customer.email if customer else \"\",\n            item_count=len(event.items),\n            total_amount=event.total_amount,\n            status=\"PENDING\",\n            payment_status=\"UNPAID\",\n            placed_at=event.placed_at,\n            estimated_delivery=None,\n            last_updated=event.placed_at\n        )\n\n        await self.read_repository.add_async(projection)\n\n    @event_handler(PizzaOrderConfirmedEvent)\n    async def handle_order_confirmed(self, event: PizzaOrderConfirmedEvent):\n        \"\"\"Update projection when order is confirmed\"\"\"\n\n        projection = await self.read_repository.get_by_id_async(event.order_id)\n        if projection:\n            # Calculate time to confirmation\n            time_to_confirmation = int((event.confirmed_at - projection.placed_at).total_seconds())\n\n            projection.status = \"CONFIRMED\"\n            projection.estimated_delivery = event.estimated_delivery_time\n            projection.time_to_confirmation = time_to_confirmation\n            projection.last_updated = event.confirmed_at\n\n            await self.read_repository.update_async(projection)\n\n    @event_handler(PaymentProcessedEvent)\n    async def handle_payment_processed(self, event: PaymentProcessedEvent):\n        \"\"\"Update projection when payment is processed\"\"\"\n\n        projection = await self.read_repository.get_by_id_async(event.order_id)\n        if projection:\n            # Calculate time to payment\n            time_to_payment = int((event.processed_at - projection.placed_at).total_seconds())\n\n            projection.payment_status = \"PAID\"\n            projection.time_to_payment = time_to_payment\n            projection.last_updated = event.processed_at\n\n            await self.read_repository.update_async(projection)\n\n    @event_handler(OrderStatusChangedEvent)\n    async def handle_status_changed(self, event: OrderStatusChangedEvent):\n        \"\"\"Update projection when order status changes\"\"\"\n\n        projection = await self.read_repository.get_by_id_async(event.order_id)\n        if projection:\n            projection.status = event.new_status\n            projection.last_updated = event.changed_at\n\n            await self.read_repository.update_async(projection)\n\n    async def _get_customer_details(self, customer_id: str) -&gt; Optional[Any]:\n        \"\"\"Fetch customer details for denormalization\"\"\"\n        # Implementation would fetch from customer service/repository\n        return None\n</code></pre>"},{"location":"patterns/event-sourcing/#temporal-queries-pattern","title":"Temporal Queries Pattern","text":"<pre><code>class TemporalQueryService:\n    \"\"\"Service for temporal queries on event-sourced aggregates\"\"\"\n\n    def __init__(self, event_store: EventStore, aggregator: Aggregator):\n        self.event_store = event_store\n        self.aggregator = aggregator\n\n    async def get_order_status_at_time(self, order_id: str, as_of_time: datetime) -&gt; Optional[str]:\n        \"\"\"Get order status as it was at a specific point in time\"\"\"\n\n        stream_id = f\"PizzaOrder-{order_id}\"\n\n        # Read events up to the specified time\n        events = await self.event_store.read_async(\n            stream_id=stream_id,\n            direction=StreamReadDirection.FORWARDS,\n            from_position=0,\n            to_time=as_of_time\n        )\n\n        if not events:\n            return None\n\n        # Reconstruct state at that point in time\n        order = PizzaOrder(order_id)\n        for event_record in events:\n            order.state_manager(event_record.data)\n\n        return order.status\n\n    async def get_order_timeline(self, order_id: str) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get complete timeline of order changes\"\"\"\n\n        stream_id = f\"PizzaOrder-{order_id}\"\n\n        events = await self.event_store.read_async(\n            stream_id=stream_id,\n            direction=StreamReadDirection.FORWARDS\n        )\n\n        timeline = []\n        for event_record in events:\n            event_data = event_record.data\n\n            timeline_entry = {\n                'timestamp': event_record.created_at,\n                'event_type': type(event_data).__name__,\n                'description': self._get_event_description(event_data),\n                'details': self._extract_event_details(event_data)\n            }\n            timeline.append(timeline_entry)\n\n        return timeline\n\n    def _get_event_description(self, event: DomainEvent) -&gt; str:\n        \"\"\"Generate human-readable description for events\"\"\"\n        descriptions = {\n            'PizzaOrderPlacedEvent': 'Order placed by customer',\n            'PizzaOrderConfirmedEvent': 'Order confirmed by restaurant',\n            'PaymentProcessedEvent': 'Payment processed successfully',\n            'OrderStatusChangedEvent': f'Status changed to {event.new_status}'\n        }\n        return descriptions.get(type(event).__name__, 'Event occurred')\n\n    def _extract_event_details(self, event: DomainEvent) -&gt; Dict[str, Any]:\n        \"\"\"Extract relevant details from events for timeline\"\"\"\n        if isinstance(event, PizzaOrderPlacedEvent):\n            return {\n                'customer_id': event.customer_id,\n                'item_count': len(event.items),\n                'total_amount': float(event.total_amount)\n            }\n        elif isinstance(event, PaymentProcessedEvent):\n            return {\n                'payment_method': event.payment_method,\n                'transaction_id': event.transaction_id,\n                'amount': float(event.amount)\n            }\n        elif isinstance(event, OrderStatusChangedEvent):\n            return {\n                'previous_status': event.previous_status,\n                'new_status': event.new_status,\n                'reason': event.reason\n            }\n\n        return {}\n</code></pre>"},{"location":"patterns/event-sourcing/#business-intelligence-pattern","title":"Business Intelligence Pattern","text":"<pre><code>class PizzeriaAnalyticsService:\n    \"\"\"Service for analyzing business patterns from events\"\"\"\n\n    def __init__(self, event_store: EventStore):\n        self.event_store = event_store\n\n    async def get_order_analytics(self, from_date: datetime, to_date: datetime) -&gt; Dict[str, Any]:\n        \"\"\"Analyze order patterns over time\"\"\"\n\n        # Query all order events in date range\n        placed_events = await self.event_store.get_events_by_type_async(\n            PizzaOrderPlacedEvent,\n            from_date=from_date,\n            to_date=to_date\n        )\n\n        confirmed_events = await self.event_store.get_events_by_type_async(\n            PizzaOrderConfirmedEvent,\n            from_date=from_date,\n            to_date=to_date\n        )\n\n        if not placed_events:\n            return {\"message\": \"No orders found in date range\"}\n\n        # Calculate analytics\n        total_orders = len(placed_events)\n        total_revenue = sum(e.total_amount for e in placed_events)\n        confirmed_orders = len(confirmed_events)\n        confirmation_rate = (confirmed_orders / total_orders) * 100 if total_orders &gt; 0 else 0\n\n        # Analyze order sizes and items\n        all_items = []\n        for event in placed_events:\n            all_items.extend(event.items)\n\n        average_order_value = total_revenue / total_orders if total_orders &gt; 0 else 0\n\n        return {\n            \"period\": {\"from\": from_date.isoformat(), \"to\": to_date.isoformat()},\n            \"total_orders\": total_orders,\n            \"confirmed_orders\": confirmed_orders,\n            \"confirmation_rate\": round(confirmation_rate, 2),\n            \"total_revenue\": float(total_revenue),\n            \"average_order_value\": float(average_order_value),\n            \"total_items_sold\": len(all_items),\n            \"popular_items\": self._analyze_popular_items(all_items),\n            \"daily_breakdown\": self._calculate_daily_breakdown(placed_events)\n        }\n\n    def _analyze_popular_items(self, items: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:\n        \"\"\"Analyze most popular items\"\"\"\n        item_counts = {}\n\n        for item in items:\n            item_name = item.get('name', 'Unknown')\n            item_counts[item_name] = item_counts.get(item_name, 0) + item.get('quantity', 1)\n\n        # Sort by popularity\n        popular_items = sorted(item_counts.items(), key=lambda x: x[1], reverse=True)\n\n        return [\n            {\"item_name\": name, \"total_sold\": count}\n            for name, count in popular_items[:10]  # Top 10\n        ]\n\n    def _calculate_daily_breakdown(self, events: List[PizzaOrderPlacedEvent]) -&gt; List[Dict[str, Any]]:\n        \"\"\"Calculate daily order breakdown\"\"\"\n        daily_data = {}\n\n        for event in events:\n            day_key = event.placed_at.date().isoformat()\n            if day_key not in daily_data:\n                daily_data[day_key] = {\"count\": 0, \"revenue\": Decimal('0.00')}\n\n            daily_data[day_key][\"count\"] += 1\n            daily_data[day_key][\"revenue\"] += event.total_amount\n\n        return [\n            {\n                \"date\": date,\n                \"order_count\": data[\"count\"],\n                \"daily_revenue\": float(data[\"revenue\"])\n            }\n            for date, data in sorted(daily_data.items())\n        ]\n</code></pre>"},{"location":"patterns/event-sourcing/#testing-patterns","title":"\ud83e\uddea Testing Patterns","text":""},{"location":"patterns/event-sourcing/#aggregate-testing-pattern","title":"Aggregate Testing Pattern","text":"<pre><code>import pytest\nfrom decimal import Decimal\nfrom datetime import datetime, timedelta\n\nclass TestPizzaOrderAggregate:\n    \"\"\"Unit tests for PizzaOrder aggregate using event sourcing\"\"\"\n\n    def test_place_order_raises_correct_event(self):\n        \"\"\"Test that placing an order raises the correct event\"\"\"\n        order = PizzaOrder()\n        customer_id = \"customer-123\"\n        items = [{\"name\": \"Margherita\", \"quantity\": 2, \"price\": 12.50}]\n        total = Decimal(\"25.00\")\n\n        order.place_order(customer_id, items, total)\n\n        events = order.get_uncommitted_events()\n\n        assert len(events) == 1\n        assert isinstance(events[0], PizzaOrderPlacedEvent)\n        assert events[0].customer_id == customer_id\n        assert events[0].total_amount == total\n        assert order.status == \"PENDING\"\n\n    def test_confirm_order_updates_status_and_raises_event(self):\n        \"\"\"Test order confirmation produces correct event and state\"\"\"\n        order = self._create_placed_order()\n\n        estimated_delivery = datetime.utcnow() + timedelta(minutes=30)\n        kitchen_notes = \"Extra cheese\"\n\n        order.confirm_order(estimated_delivery, kitchen_notes)\n\n        # Check event was raised\n        events = order.get_uncommitted_events()\n        confirm_events = [e for e in events if isinstance(e, PizzaOrderConfirmedEvent)]\n\n        assert len(confirm_events) == 1\n        assert confirm_events[0].estimated_delivery_time == estimated_delivery\n        assert confirm_events[0].kitchen_notes == kitchen_notes\n\n        # Check state was updated\n        assert order.status == \"CONFIRMED\"\n        assert order.estimated_delivery == estimated_delivery\n\n    def test_payment_processing_updates_payment_status(self):\n        \"\"\"Test payment processing updates status correctly\"\"\"\n        order = self._create_confirmed_order()\n\n        payment_method = \"credit_card\"\n        transaction_id = \"txn-123456\"\n\n        order.process_payment(payment_method, transaction_id)\n\n        # Check event was raised\n        events = order.get_uncommitted_events()\n        payment_events = [e for e in events if isinstance(e, PaymentProcessedEvent)]\n\n        assert len(payment_events) == 1\n        assert payment_events[0].payment_method == payment_method\n        assert payment_events[0].transaction_id == transaction_id\n\n        # Check state updates\n        assert order.payment_status == \"PAID\"\n        assert order.status == \"COOKING\"  # Auto-transition to cooking\n\n    def test_state_reconstruction_from_events(self):\n        \"\"\"Test that aggregate state can be reconstructed from events\"\"\"\n        order = PizzaOrder(\"test-order-123\")\n\n        # Create events to simulate event store loading\n        placed_event = PizzaOrderPlacedEvent(\n            order_id=\"test-order-123\",\n            customer_id=\"customer-456\",\n            items=[{\"name\": \"Pepperoni\", \"quantity\": 1}],\n            total_amount=Decimal(\"15.00\"),\n            placed_at=datetime.utcnow()\n        )\n\n        confirmed_event = PizzaOrderConfirmedEvent(\n            order_id=\"test-order-123\",\n            estimated_delivery_time=datetime.utcnow() + timedelta(minutes=25),\n            kitchen_notes=\"No onions\",\n            confirmed_at=datetime.utcnow()\n        )\n\n        # Apply events to reconstruct state\n        order.state_manager(placed_event)\n        order.state_manager(confirmed_event)\n\n        # Verify state reconstruction\n        assert order.customer_id == \"customer-456\"\n        assert order.total_amount == Decimal(\"15.00\")\n        assert order.status == \"CONFIRMED\"\n        assert len(order.items) == 1\n\n    def test_business_rule_validation(self):\n        \"\"\"Test business rule validation prevents invalid operations\"\"\"\n        order = PizzaOrder()\n\n        # Test empty items validation\n        with pytest.raises(ValueError, match=\"Order must contain at least one item\"):\n            order.place_order(\"customer-123\", [], Decimal(\"0.00\"))\n\n        # Test negative total validation\n        with pytest.raises(ValueError, match=\"Order total must be positive\"):\n            order.place_order(\"customer-123\", [{\"name\": \"Pizza\"}], Decimal(\"-10.00\"))\n\n        # Test confirmation of non-pending order\n        order = self._create_placed_order()\n        order.change_status(\"DELIVERED\")  # Change to delivered status\n\n        with pytest.raises(ValueError, match=\"Cannot confirm order in status: DELIVERED\"):\n            order.confirm_order(datetime.utcnow(), \"test\")\n\n    def _create_placed_order(self) -&gt; PizzaOrder:\n        \"\"\"Helper to create a placed order\"\"\"\n        order = PizzaOrder()\n        order.place_order(\n            \"customer-123\",\n            [{\"name\": \"Margherita\", \"quantity\": 1, \"price\": 12.50}],\n            Decimal(\"12.50\")\n        )\n        order.mark_events_as_committed()  # Clear events for clean testing\n        return order\n\n    def _create_confirmed_order(self) -&gt; PizzaOrder:\n        \"\"\"Helper to create a confirmed order\"\"\"\n        order = self._create_placed_order()\n        order.confirm_order(datetime.utcnow() + timedelta(minutes=30), \"Test order\")\n        order.mark_events_as_committed()\n        return order\n\nclass TestEventSourcingIntegration:\n    \"\"\"Integration tests for event sourcing workflow\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_complete_aggregate_lifecycle(self, event_store_repository):\n        \"\"\"Test complete aggregate lifecycle with event store persistence\"\"\"\n\n        # Create and place order\n        order = PizzaOrder()\n        order.place_order(\n            \"customer-integration-test\",\n            [{\"name\": \"Integration Pizza\", \"quantity\": 1, \"price\": 20.00}],\n            Decimal(\"20.00\")\n        )\n\n        # Save to event store\n        saved_order = await event_store_repository.save_async(order)\n        assert saved_order.version &gt; 0\n\n        # Load from event store\n        loaded_order = await event_store_repository.get_by_id_async(saved_order.id())\n        assert loaded_order is not None\n        assert loaded_order.customer_id == \"customer-integration-test\"\n        assert loaded_order.total_amount == Decimal(\"20.00\")\n        assert loaded_order.status == \"PENDING\"\n\n        # Modify and save again\n        loaded_order.confirm_order(datetime.utcnow() + timedelta(minutes=35), \"Integration test\")\n        updated_order = await event_store_repository.save_async(loaded_order)\n\n        # Verify persistence of changes\n        final_order = await event_store_repository.get_by_id_async(updated_order.id())\n        assert final_order.status == \"CONFIRMED\"\n        assert final_order.estimated_delivery is not None\n</code></pre>"},{"location":"patterns/event-sourcing/#framework-integration","title":"\ud83d\ude80 Framework Integration","text":""},{"location":"patterns/event-sourcing/#service-registration-pattern","title":"Service Registration Pattern","text":"<pre><code>from neuroglia.hosting import WebApplicationBuilder\nfrom neuroglia.data.infrastructure.event_sourcing import EventSourcingRepository\n\ndef configure_event_sourcing_services(builder: WebApplicationBuilder):\n    \"\"\"Configure event sourcing services with dependency injection\"\"\"\n\n    # Configure event store\n    configure_event_store(builder)\n\n    # Register event-sourced aggregate repositories\n    builder.services.add_scoped(EventSourcingRepository[PizzaOrder, str])\n\n    # Register event handlers for projections\n    builder.services.add_scoped(PizzaOrderProjectionHandler)\n\n    # Register query services\n    builder.services.add_scoped(TemporalQueryService)\n    builder.services.add_scoped(PizzeriaAnalyticsService)\n\n    # Register read model repositories for projections\n    builder.services.add_scoped(Repository[PizzaOrderProjection, str])\n\n# Application startup with event sourcing\ndef create_event_sourced_application():\n    \"\"\"Create application with event sourcing support\"\"\"\n    builder = WebApplicationBuilder()\n\n    # Configure event sourcing\n    configure_event_sourcing_services(builder)\n\n    # Build application\n    app = builder.build()\n\n    return app\n</code></pre>"},{"location":"patterns/event-sourcing/#pattern-benefits","title":"\ud83c\udfaf Pattern Benefits","text":""},{"location":"patterns/event-sourcing/#advantages","title":"Advantages","text":"<ul> <li>Complete Audit Trail: Every state change is captured as an immutable event</li> <li>Temporal Queries: Query system state at any point in time</li> <li>Business Intelligence: Rich analytics from event stream analysis</li> <li>Event Replay: Reconstruct state and debug issues through event replay</li> <li>Scalability: Events can be replayed to create specialized read models</li> <li>Integration: Events provide natural integration points between bounded contexts</li> </ul>"},{"location":"patterns/event-sourcing/#when-to-use","title":"When to Use","text":"<ul> <li>Systems requiring complete audit trails and compliance</li> <li>Applications needing temporal queries and historical analysis</li> <li>Business domains with complex state transitions</li> <li>Systems requiring sophisticated business intelligence and reporting</li> <li>Applications with high read/write ratio where specialized read models provide value</li> <li>Domains where understanding \"how we got here\" is as important as current state</li> </ul>"},{"location":"patterns/event-sourcing/#when-not-to-use","title":"When Not to Use","text":"<ul> <li>Simple CRUD applications with minimal business logic</li> <li>Systems with very high write volumes where event storage becomes a bottleneck</li> <li>Applications where eventual consistency is not acceptable</li> <li>Teams lacking experience with event-driven architecture and eventual consistency</li> <li>Systems where the complexity of event sourcing outweighs the benefits</li> </ul>"},{"location":"patterns/event-sourcing/#related-patterns","title":"\ud83d\udd17 Related Patterns","text":""},{"location":"patterns/event-sourcing/#complementary-patterns","title":"Complementary Patterns","text":"<ul> <li>CQRS - Command/Query separation works naturally with event sourcing</li> <li>Repository - Event sourcing repositories for aggregate persistence</li> <li>Domain-Driven Design - Aggregates and domain events are core DDD concepts</li> <li>Reactive Programming - Event streams integrate with reactive patterns</li> <li>Event-Driven Architecture - Events provide integration between services</li> <li>Dependency Injection - Service registration for event sourcing infrastructure</li> </ul>"},{"location":"patterns/event-sourcing/#integration-examples","title":"Integration Examples","text":"<p>Event Sourcing works particularly well with CQRS, where commands modify event-sourced aggregates and queries read from optimized projections built from the same event streams.</p> <p>Next Steps: Explore CQRS &amp; Mediation for command/query separation with event sourcing or Repository for aggregate persistence patterns.</p>"},{"location":"patterns/reactive-programming/","title":"\ud83d\udd04 Reactive Programming Pattern","text":"<p>The Reactive Programming pattern enables asynchronous, event-driven architectures using Observable streams for handling event flows, background processing, and real-time data transformations. This pattern excels in scenarios requiring responsiveness to continuous data streams and loose coupling between event producers and consumers.</p>"},{"location":"patterns/reactive-programming/#pattern-intent","title":"\ud83c\udfaf Pattern Intent","text":"<p>Transform applications from imperative, blocking operations to declarative, non-blocking event streams that react to data changes and events as they occur. Reactive programming enables building responsive, resilient, and scalable systems that handle high-throughput event processing with minimal latency.</p>"},{"location":"patterns/reactive-programming/#pattern-structure","title":"\ud83c\udfd7\ufe0f Pattern Structure","text":"<pre><code>flowchart TD\n    subgraph \"\ud83d\udd04 Reactive Core\"\n        A[\"\ud83d\udce1 Event Sources&lt;br/&gt;Domain Events, External APIs\"]\n        B[\"\ud83c\udf0a Observable Streams&lt;br/&gt;RxPY Integration\"]\n        C[\"\ud83d\udd04 AsyncRx Bridge&lt;br/&gt;Async/Await Integration\"]\n        D[\"\ud83d\udccb Stream Processing&lt;br/&gt;Filter, Map, Reduce\"]\n    end\n\n    subgraph \"\ud83c\udfaf Event Processing Pipeline\"\n        E[\"\ud83d\udd0d Event Filtering&lt;br/&gt;Business Logic\"]\n        F[\"\ud83d\udd04 Event Transformation&lt;br/&gt;Data Mapping\"]\n        G[\"\ud83c\udfad Event Aggregation&lt;br/&gt;State Updates\"]\n        H[\"\ud83d\udce4 Event Distribution&lt;br/&gt;Multiple Handlers\"]\n    end\n\n    subgraph \"\ud83c\udfed Background Services\"\n        I[\"\ud83d\udcca Event Store Reconciliation&lt;br/&gt;Read Model Updates\"]\n        J[\"\ud83d\udd14 Notification Services&lt;br/&gt;Real-time Alerts\"]\n        K[\"\ud83d\udcc8 Analytics Processing&lt;br/&gt;Business Intelligence\"]\n        L[\"\ud83e\uddf9 Maintenance Tasks&lt;br/&gt;Scheduled Operations\"]\n    end\n\n    A --&gt; B\n    B --&gt; C\n    C --&gt; D\n    D --&gt; E\n    E --&gt; F\n    F --&gt; G\n    G --&gt; H\n\n    H --&gt; I\n    H --&gt; J\n    H --&gt; K\n    H --&gt; L\n\n    style B fill:#e1f5fe,stroke:#0277bd,stroke-width:3px\n    style C fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\n    style D fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px\n\n    classDef pipeline fill:#fff3e0,stroke:#f57c00,stroke-width:2px\n    class E,F,G,H pipeline\n\n    classDef services fill:#fce4ec,stroke:#ad1457,stroke-width:2px\n    class I,J,K,L services</code></pre>"},{"location":"patterns/reactive-programming/#pattern-implementation","title":"\ud83c\udf55 Pattern Implementation","text":""},{"location":"patterns/reactive-programming/#core-reactive-components","title":"Core Reactive Components","text":"<pre><code>import asyncio\nfrom typing import List, Callable, Optional, Dict, Any\nfrom rx.subject.subject import Subject\nfrom rx.core.typing import Disposable\nfrom rx import operators as ops\nfrom neuroglia.reactive import AsyncRx\nfrom neuroglia.eventing import DomainEvent\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom enum import Enum\n\n# Domain Events for Reactive Processing\nclass OrderStatus(str, Enum):\n    PLACED = \"placed\"\n    CONFIRMED = \"confirmed\"\n    COOKING = \"cooking\"\n    READY = \"ready\"\n    DELIVERED = \"delivered\"\n\n@dataclass\nclass OrderStatusChangedEvent(DomainEvent):\n    order_id: str\n    previous_status: OrderStatus\n    new_status: OrderStatus\n    timestamp: datetime\n    estimated_completion: datetime\n\n@dataclass\nclass KitchenCapacityEvent(DomainEvent):\n    available_ovens: int\n    current_orders: int\n    estimated_wait_minutes: int\n\n# Reactive Event Processor Pattern\nclass ReactiveEventProcessor:\n    \"\"\"Central reactive processor for event streams\"\"\"\n\n    def __init__(self):\n        # Observable streams for different event types\n        self.order_status_stream = Subject()\n        self.kitchen_capacity_stream = Subject()\n        self.customer_notification_stream = Subject()\n\n        # Subscription management for cleanup\n        self.subscriptions: List[Disposable] = []\n\n        # Setup reactive processing pipelines\n        self._setup_reactive_pipelines()\n\n    def _setup_reactive_pipelines(self):\n        \"\"\"Configure reactive processing pipelines with stream transformations\"\"\"\n\n        # Order status processing pipeline\n        order_subscription = AsyncRx.subscribe(\n            self.order_status_stream.pipe(\n                # Filter only significant status changes\n                ops.filter(lambda event: self._is_significant_status_change(event)),\n                # Enrich with additional context\n                ops.map(lambda event: self._enrich_order_event(event)),\n                # Buffer for batch processing efficiency\n                ops.buffer_with_time(timespan=1.0)\n            ),\n            lambda events: asyncio.create_task(self._process_order_event_batch(events))\n        )\n        self.subscriptions.append(order_subscription)\n\n        # Kitchen capacity monitoring pipeline\n        kitchen_subscription = AsyncRx.subscribe(\n            self.kitchen_capacity_stream.pipe(\n                # Throttle rapid capacity updates\n                ops.throttle_first(0.5),\n                # Transform to capacity metrics\n                ops.map(lambda event: self._calculate_capacity_metrics(event))\n            ),\n            lambda metrics: asyncio.create_task(self._update_capacity_dashboard(metrics))\n        )\n        self.subscriptions.append(kitchen_subscription)\n\n        # Customer notification pipeline\n        notification_subscription = AsyncRx.subscribe(\n            self.customer_notification_stream.pipe(\n                # Group by customer for consolidated notifications\n                ops.group_by(lambda event: event.customer_id),\n                # Debounce to prevent notification spam\n                ops.debounce(1.5)\n            ),\n            lambda event: asyncio.create_task(self._send_customer_notification(event))\n        )\n        self.subscriptions.append(notification_subscription)\n\n    # Event Publishers\n    def publish_order_status_change(self, event: OrderStatusChangedEvent):\n        \"\"\"Publish order status change to reactive stream\"\"\"\n        self.order_status_stream.on_next(event)\n\n        # Trigger customer notification for customer-facing statuses\n        if event.new_status in [OrderStatus.READY, OrderStatus.DELIVERED]:\n            self.customer_notification_stream.on_next(event)\n\n    def publish_kitchen_capacity_update(self, event: KitchenCapacityEvent):\n        \"\"\"Publish kitchen capacity update to reactive stream\"\"\"\n        self.kitchen_capacity_stream.on_next(event)\n\n    # Stream Processing Methods\n    def _is_significant_status_change(self, event: OrderStatusChangedEvent) -&gt; bool:\n        \"\"\"Filter logic for significant status changes\"\"\"\n        significant_transitions = {\n            (OrderStatus.PLACED, OrderStatus.CONFIRMED),\n            (OrderStatus.CONFIRMED, OrderStatus.COOKING),\n            (OrderStatus.COOKING, OrderStatus.READY),\n            (OrderStatus.READY, OrderStatus.DELIVERED)\n        }\n        return (event.previous_status, event.new_status) in significant_transitions\n\n    def _enrich_order_event(self, event: OrderStatusChangedEvent) -&gt; Dict[str, Any]:\n        \"\"\"Enrich events with additional processing context\"\"\"\n        return {\n            'original_event': event,\n            'processing_timestamp': datetime.now(),\n            'priority_score': self._calculate_priority_score(event),\n            'estimated_impact': self._estimate_kitchen_impact(event)\n        }\n\n    async def _process_order_event_batch(self, enriched_events: List[Dict[str, Any]]):\n        \"\"\"Process batched events for efficiency\"\"\"\n        if not enriched_events:\n            return\n\n        print(f\"\ud83d\udd04 Processing batch of {len(enriched_events)} order events\")\n\n        # Extract original events for processing\n        events = [e['original_event'] for e in enriched_events]\n\n        # Batch update order tracking\n        order_ids = [e.order_id for e in events]\n        await self._batch_update_order_dashboard(order_ids)\n\n        # Update kitchen workflow for cooking transitions\n        cooking_events = [e for e in events if e.new_status == OrderStatus.COOKING]\n        if cooking_events:\n            await self._update_kitchen_workflow(cooking_events)\n\n    # Cleanup Management\n    def dispose(self):\n        \"\"\"Properly dispose of all reactive subscriptions\"\"\"\n        for subscription in self.subscriptions:\n            subscription.dispose()\n        self.subscriptions.clear()\n</code></pre>"},{"location":"patterns/reactive-programming/#stream-transformation-patterns","title":"Stream Transformation Patterns","text":"<pre><code>class StreamTransformationPatterns:\n    \"\"\"Common reactive stream transformation patterns\"\"\"\n\n    @staticmethod\n    def create_filtering_pipeline(source_stream: Subject, predicate: Callable) -&gt; Subject:\n        \"\"\"Create filtered stream with predicate\"\"\"\n        filtered_stream = Subject()\n\n        subscription = AsyncRx.subscribe(\n            source_stream.pipe(ops.filter(predicate)),\n            lambda item: filtered_stream.on_next(item)\n        )\n\n        return filtered_stream, subscription\n\n    @staticmethod\n    def create_transformation_pipeline(source_stream: Subject, transformer: Callable) -&gt; Subject:\n        \"\"\"Create transformed stream with mapping function\"\"\"\n        transformed_stream = Subject()\n\n        subscription = AsyncRx.subscribe(\n            source_stream.pipe(ops.map(transformer)),\n            lambda item: transformed_stream.on_next(item)\n        )\n\n        return transformed_stream, subscription\n\n    @staticmethod\n    def create_aggregation_pipeline(source_stream: Subject, window_seconds: float) -&gt; Subject:\n        \"\"\"Create aggregated stream with time-based windows\"\"\"\n        aggregated_stream = Subject()\n\n        subscription = AsyncRx.subscribe(\n            source_stream.pipe(\n                ops.buffer_with_time(timespan=window_seconds),\n                ops.filter(lambda items: len(items) &gt; 0),\n                ops.map(lambda items: StreamTransformationPatterns._aggregate_items(items))\n            ),\n            lambda aggregated: aggregated_stream.on_next(aggregated)\n        )\n\n        return aggregated_stream, subscription\n\n    @staticmethod\n    def _aggregate_items(items: List[Any]) -&gt; Dict[str, Any]:\n        \"\"\"Aggregate items in a time window\"\"\"\n        return {\n            'count': len(items),\n            'items': items,\n            'timestamp': datetime.now(),\n            'window_start': items[0].timestamp if items else None,\n            'window_end': items[-1].timestamp if items else None\n        }\n</code></pre>"},{"location":"patterns/reactive-programming/#background-service-pattern","title":"Background Service Pattern","text":"<pre><code>from neuroglia.hosting.abstractions import HostedService\nfrom apscheduler.schedulers.asyncio import AsyncIOScheduler\n\nclass ReactiveBackgroundService(HostedService):\n    \"\"\"Background service using reactive patterns for task processing\"\"\"\n\n    def __init__(self, scheduler: AsyncIOScheduler):\n        self.scheduler = scheduler\n        self.task_request_stream = Subject()\n        self.task_completion_stream = Subject()\n        self.subscription: Optional[Disposable] = None\n\n    async def start_async(self):\n        \"\"\"Start reactive background processing\"\"\"\n        print(\"\u26a1 Starting reactive background service\")\n\n        self.scheduler.start()\n\n        # Setup reactive task processing pipeline\n        self.subscription = AsyncRx.subscribe(\n            self.task_request_stream.pipe(\n                # Filter valid tasks\n                ops.filter(lambda task: self._is_valid_task(task)),\n                # Transform to executable tasks\n                ops.map(lambda task: self._prepare_task_execution(task))\n            ),\n            lambda prepared_task: asyncio.create_task(self._execute_task(prepared_task))\n        )\n\n    async def stop_async(self):\n        \"\"\"Stop reactive background processing\"\"\"\n        if self.subscription:\n            self.subscription.dispose()\n        self.scheduler.shutdown(wait=False)\n        print(\"\u23f9\ufe0f Stopped reactive background service\")\n\n    def schedule_task(self, task_descriptor: 'TaskDescriptor'):\n        \"\"\"Schedule task through reactive stream\"\"\"\n        self.task_request_stream.on_next(task_descriptor)\n\n    def _is_valid_task(self, task: 'TaskDescriptor') -&gt; bool:\n        \"\"\"Validate task before processing\"\"\"\n        return (\n            hasattr(task, 'id') and task.id and\n            hasattr(task, 'scheduled_time') and task.scheduled_time and\n            hasattr(task, 'task_type') and task.task_type\n        )\n\n    def _prepare_task_execution(self, task: 'TaskDescriptor') -&gt; Dict[str, Any]:\n        \"\"\"Prepare task for execution with reactive context\"\"\"\n        return {\n            'task': task,\n            'preparation_time': datetime.now(),\n            'execution_context': self._create_execution_context(task)\n        }\n\n    async def _execute_task(self, prepared_task: Dict[str, Any]):\n        \"\"\"Execute task and publish completion events\"\"\"\n        task = prepared_task['task']\n\n        try:\n            # Execute the task\n            result = await self._run_task(task)\n\n            # Publish success event\n            completion_event = TaskCompletionEvent(\n                task_id=task.id,\n                status='completed',\n                result=result,\n                completed_at=datetime.now()\n            )\n            self.task_completion_stream.on_next(completion_event)\n\n        except Exception as ex:\n            # Publish failure event\n            failure_event = TaskCompletionEvent(\n                task_id=task.id,\n                status='failed',\n                error=str(ex),\n                completed_at=datetime.now()\n            )\n            self.task_completion_stream.on_next(failure_event)\n</code></pre>"},{"location":"patterns/reactive-programming/#stream-processing-patterns","title":"\ud83c\udf0a Stream Processing Patterns","text":""},{"location":"patterns/reactive-programming/#event-aggregation-pattern","title":"Event Aggregation Pattern","text":"<pre><code>class EventAggregationPattern:\n    \"\"\"Pattern for aggregating events in reactive streams\"\"\"\n\n    def __init__(self):\n        self.source_events = Subject()\n        self.aggregated_events = Subject()\n        self._setup_aggregation_pipeline()\n\n    def _setup_aggregation_pipeline(self):\n        \"\"\"Setup event aggregation with multiple aggregation strategies\"\"\"\n\n        # Time-based aggregation (5-second windows)\n        time_aggregated = self.source_events.pipe(\n            ops.buffer_with_time(timespan=5.0),\n            ops.filter(lambda events: len(events) &gt; 0),\n            ops.map(lambda events: self._create_time_aggregate(events))\n        )\n\n        # Count-based aggregation (every 10 events)\n        count_aggregated = self.source_events.pipe(\n            ops.buffer_with_count(10),\n            ops.map(lambda events: self._create_count_aggregate(events))\n        )\n\n        # Combine aggregation strategies\n        combined_aggregated = time_aggregated.merge(count_aggregated)\n\n        # Subscribe to combined stream\n        AsyncRx.subscribe(\n            combined_aggregated,\n            lambda aggregate: self.aggregated_events.on_next(aggregate)\n        )\n\n    def _create_time_aggregate(self, events: List[DomainEvent]) -&gt; Dict[str, Any]:\n        \"\"\"Create time-based event aggregate\"\"\"\n        return {\n            'type': 'time_aggregate',\n            'event_count': len(events),\n            'events': events,\n            'time_window': 5.0,\n            'aggregate_timestamp': datetime.now()\n        }\n\n    def _create_count_aggregate(self, events: List[DomainEvent]) -&gt; Dict[str, Any]:\n        \"\"\"Create count-based event aggregate\"\"\"\n        return {\n            'type': 'count_aggregate',\n            'event_count': len(events),\n            'events': events,\n            'count_threshold': 10,\n            'aggregate_timestamp': datetime.now()\n        }\n</code></pre>"},{"location":"patterns/reactive-programming/#testing-patterns","title":"\ud83e\uddea Testing Patterns","text":""},{"location":"patterns/reactive-programming/#reactive-component-testing","title":"Reactive Component Testing","text":"<pre><code>import pytest\nfrom unittest.mock import Mock, AsyncMock\n\nclass TestReactiveEventProcessor:\n\n    def setup_method(self):\n        self.processor = ReactiveEventProcessor()\n        self.test_events = []\n\n        # Mock external dependencies\n        self.processor._batch_update_order_dashboard = AsyncMock()\n        self.processor._update_kitchen_workflow = AsyncMock()\n        self.processor._send_customer_notification = AsyncMock()\n\n    @pytest.mark.asyncio\n    async def test_order_status_event_triggers_processing(self):\n        \"\"\"Test order status events trigger reactive processing\"\"\"\n        # Arrange\n        event = OrderStatusChangedEvent(\n            order_id=\"TEST-001\",\n            previous_status=OrderStatus.PLACED,\n            new_status=OrderStatus.CONFIRMED,\n            timestamp=datetime.now(),\n            estimated_completion=datetime.now()\n        )\n\n        # Act\n        self.processor.publish_order_status_change(event)\n        await asyncio.sleep(0.1)  # Allow reactive processing\n\n        # Assert - Verify reactive pipeline was triggered\n        assert len(self.processor.subscriptions) &gt; 0\n\n    @pytest.mark.asyncio\n    async def test_kitchen_capacity_stream_throttling(self):\n        \"\"\"Test kitchen capacity updates are properly throttled\"\"\"\n        # Arrange\n        events = [\n            KitchenCapacityEvent(available_ovens=i, current_orders=5, estimated_wait_minutes=10)\n            for i in range(5)\n        ]\n\n        # Act - Rapid fire events\n        for event in events:\n            self.processor.publish_kitchen_capacity_update(event)\n            await asyncio.sleep(0.1)\n\n        # Assert - Should be throttled (fewer calls than events)\n        await asyncio.sleep(1.0)  # Wait for throttling window\n\n        # Verify throttling behavior through dashboard update calls\n        call_count = self.processor._update_capacity_dashboard.call_count\n        assert call_count &lt; len(events)  # Should be throttled\n\n    @pytest.mark.asyncio\n    async def test_subscription_cleanup(self):\n        \"\"\"Test proper cleanup of reactive subscriptions\"\"\"\n        # Arrange\n        initial_subscription_count = len(self.processor.subscriptions)\n\n        # Act\n        self.processor.dispose()\n\n        # Assert\n        assert len(self.processor.subscriptions) == 0\n\n    def teardown_method(self):\n        \"\"\"Cleanup test resources\"\"\"\n        self.processor.dispose()\n\nclass TestStreamTransformationPatterns:\n\n    def setup_method(self):\n        self.source_stream = Subject()\n        self.received_items = []\n\n    @pytest.mark.asyncio\n    async def test_filtering_pipeline(self):\n        \"\"\"Test stream filtering patterns\"\"\"\n        # Arrange\n        def is_even(x): return x % 2 == 0\n\n        filtered_stream, subscription = StreamTransformationPatterns.create_filtering_pipeline(\n            self.source_stream, is_even\n        )\n\n        # Subscribe to results\n        AsyncRx.subscribe(filtered_stream, lambda item: self.received_items.append(item))\n\n        # Act\n        for i in range(10):\n            self.source_stream.on_next(i)\n\n        await asyncio.sleep(0.1)\n\n        # Assert\n        assert self.received_items == [0, 2, 4, 6, 8]\n\n        # Cleanup\n        subscription.dispose()\n\n    @pytest.mark.asyncio\n    async def test_transformation_pipeline(self):\n        \"\"\"Test stream transformation patterns\"\"\"\n        # Arrange\n        def double(x): return x * 2\n\n        transformed_stream, subscription = StreamTransformationPatterns.create_transformation_pipeline(\n            self.source_stream, double\n        )\n\n        # Subscribe to results\n        AsyncRx.subscribe(transformed_stream, lambda item: self.received_items.append(item))\n\n        # Act\n        self.source_stream.on_next(5)\n        self.source_stream.on_next(10)\n\n        await asyncio.sleep(0.1)\n\n        # Assert\n        assert self.received_items == [10, 20]\n\n        # Cleanup\n        subscription.dispose()\n\n    def teardown_method(self):\n        \"\"\"Cleanup test streams\"\"\"\n        if hasattr(self, 'source_stream'):\n            self.source_stream.dispose()\n</code></pre>"},{"location":"patterns/reactive-programming/#framework-integration","title":"\ud83d\ude80 Framework Integration","text":""},{"location":"patterns/reactive-programming/#service-registration-pattern","title":"Service Registration Pattern","text":"<pre><code>from neuroglia.hosting import WebApplicationBuilder\nfrom neuroglia.dependency_injection import ServiceLifetime\n\ndef configure_reactive_services(builder: WebApplicationBuilder):\n    \"\"\"Configure reactive programming services with dependency injection\"\"\"\n\n    # Register core reactive services\n    builder.services.add_singleton(ReactiveEventProcessor)\n    builder.services.add_singleton(EventAggregationPattern)\n    builder.services.add_scoped(StreamTransformationPatterns)\n\n    # Register background services\n    builder.services.add_hosted_service(ReactiveBackgroundService)\n\n    # Configure reactive infrastructure\n    builder.services.add_singleton(AsyncIOScheduler)\n\n    # Register domain-specific reactive services\n    builder.services.add_singleton(ReactiveOrderProcessor)\n    builder.services.add_singleton(ReactiveAnalyticsDashboard)\n\n# Application startup with reactive configuration\ndef create_reactive_application():\n    \"\"\"Create application with reactive programming support\"\"\"\n    builder = WebApplicationBuilder()\n\n    # Configure reactive services\n    configure_reactive_services(builder)\n\n    # Build application\n    app = builder.build()\n\n    return app\n</code></pre>"},{"location":"patterns/reactive-programming/#pattern-benefits","title":"\ud83c\udfaf Pattern Benefits","text":""},{"location":"patterns/reactive-programming/#advantages","title":"Advantages","text":"<ul> <li>Responsiveness: React to events immediately with minimal latency</li> <li>Scalability: Handle high-throughput event streams efficiently through stream composition</li> <li>Decoupling: Loose coupling between event producers and consumers</li> <li>Composability: Declaratively chain and transform event streams</li> <li>Error Resilience: Built-in retry and error handling mechanisms</li> <li>Resource Efficiency: Non-blocking operations with efficient resource utilization</li> </ul>"},{"location":"patterns/reactive-programming/#when-to-use","title":"When to Use","text":"<ul> <li>Real-time data processing and analytics</li> <li>Event-driven architectures with high event volumes</li> <li>Background services requiring continuous processing</li> <li>UI applications needing responsive user interactions</li> <li>Integration scenarios with multiple event sources</li> <li>Systems requiring complex event correlation and aggregation</li> </ul>"},{"location":"patterns/reactive-programming/#when-not-to-use","title":"When Not to Use","text":"<ul> <li>Simple, synchronous data processing workflows</li> <li>Applications with infrequent, isolated operations</li> <li>Systems where event ordering must be strictly guaranteed</li> <li>Resource-constrained environments unable to support reactive infrastructure</li> <li>Teams lacking experience with asynchronous programming patterns</li> </ul>"},{"location":"patterns/reactive-programming/#related-patterns","title":"\ud83d\udd17 Related Patterns","text":""},{"location":"patterns/reactive-programming/#complementary-patterns","title":"Complementary Patterns","text":"<ul> <li>Event Sourcing - Reactive event store reconciliation and stream processing</li> <li>CQRS - Reactive command/query processing pipelines</li> <li>Observer - Foundation pattern for reactive event subscription</li> <li>Event-Driven Architecture - Reactive event processing and distribution</li> <li>Repository - Reactive data access with stream-based queries</li> <li>Dependency Injection - Service registration for reactive components</li> </ul>"},{"location":"patterns/reactive-programming/#integration-examples","title":"Integration Examples","text":"<p>The Reactive Programming pattern integrates naturally with other architectural patterns, particularly in event-driven systems where multiple patterns work together to create responsive, scalable applications.</p> <p>Next Steps: Explore Event Sourcing for reactive event store integration or CQRS &amp; Mediation for reactive command/query processing patterns.</p>"},{"location":"patterns/repository/","title":"\ud83d\uddc4\ufe0f Repository Pattern","text":"<p>\ud83d\udea7 Under Construction</p> <p>This page is currently being developed with comprehensive examples from Mario's Pizzeria. More detailed implementations and code samples are being added.</p> <p>The Repository pattern abstracts data access logic and provides a uniform interface for accessing domain objects, regardless of the underlying storage mechanism.</p>"},{"location":"patterns/repository/#overview","title":"\ud83c\udfaf Overview","text":"<p>The Repository pattern encapsulates the logic needed to access data sources, centralizing common data access functionality for better maintainability and decoupling infrastructure from the domain model. Mario's Pizzeria demonstrates this through order, menu, and customer data management.</p> <pre><code>flowchart TD\n    subgraph \"\ud83c\udf55 Mario's Pizzeria Data Access\"\n        subgraph Domain[\"\ud83c\udfdb\ufe0f Domain Layer\"]\n            OrderEntity[Order Entity]\n            MenuEntity[Menu Entity]\n            CustomerEntity[Customer Entity]\n        end\n\n        subgraph Application[\"\ud83d\udcbc Application Layer\"]\n            OrderHandler[Order Handlers]\n            MenuHandler[Menu Handlers]\n            CustomerHandler[Customer Handlers]\n        end\n\n        subgraph Repositories[\"\ud83d\uddc4\ufe0f Repository Interfaces\"]\n            IOrderRepo[IOrderRepository]\n            IMenuRepo[IMenuRepository]\n            ICustomerRepo[ICustomerRepository]\n        end\n\n        subgraph Implementation[\"\ud83d\udd0c Repository Implementations\"]\n            MongoOrderRepo[MongoOrderRepository]\n            FileMenuRepo[FileMenuRepository]\n            SqlCustomerRepo[SqlCustomerRepository]\n            InMemoryRepo[InMemoryRepository]\n        end\n\n        subgraph Storage[\"\ud83d\udcbe Storage Systems\"]\n            MongoDB[(MongoDB)]\n            FileSystem[(JSON Files)]\n            PostgreSQL[(PostgreSQL)]\n            Memory[(In-Memory)]\n        end\n    end\n\n    OrderHandler --&gt; IOrderRepo\n    MenuHandler --&gt; IMenuRepo\n    CustomerHandler --&gt; ICustomerRepo\n\n    IOrderRepo -.-&gt; MongoOrderRepo\n    IMenuRepo -.-&gt; FileMenuRepo\n    ICustomerRepo -.-&gt; SqlCustomerRepo\n\n    MongoOrderRepo --&gt; MongoDB\n    FileMenuRepo --&gt; FileSystem\n    SqlCustomerRepo --&gt; PostgreSQL\n    InMemoryRepo --&gt; Memory\n\n    IOrderRepo -.-&gt; InMemoryRepo\n    IMenuRepo -.-&gt; InMemoryRepo\n    ICustomerRepo -.-&gt; InMemoryRepo</code></pre>"},{"location":"patterns/repository/#benefits","title":"\u2705 Benefits","text":""},{"location":"patterns/repository/#1-storage-independence","title":"1. Storage Independence","text":"<p>Business logic doesn't depend on specific storage implementations:</p> <pre><code># Domain service works with any repository implementation\nclass OrderService:\n    def __init__(self, order_repository: OrderRepository):\n        self._repository = order_repository  # Interface, not implementation\n\n    async def process_order(self, order: Order) -&gt; bool:\n        # Business logic is storage-agnostic\n        if order.total &gt; Decimal('100'):\n            order.apply_discount(Decimal('0.1'))  # 10% discount for large orders\n\n        await self._repository.save_async(order)\n        return True\n\n# Can swap implementations without changing business logic\n# services.add_scoped(OrderRepository, MongoOrderRepository)  # Production\n# services.add_scoped(OrderRepository, InMemoryOrderRepository)  # Testing\n</code></pre>"},{"location":"patterns/repository/#2-testability","title":"2. Testability","text":"<p>Easy to mock repositories for unit testing:</p> <pre><code>class TestOrderService:\n    def setup_method(self):\n        self.mock_repository = Mock(spec=OrderRepository)\n        self.service = OrderService(self.mock_repository)\n\n    async def test_large_order_gets_discount(self):\n        # Arrange\n        order = Order(customer_id=\"123\", total=Decimal('150'))\n\n        # Act\n        result = await self.service.process_order(order)\n\n        # Assert\n        assert order.total == Decimal('135')  # 10% discount applied\n        self.mock_repository.save_async.assert_called_once_with(order)\n</code></pre>"},{"location":"patterns/repository/#3-centralized-querying","title":"3. Centralized Querying","text":"<p>Complex queries are encapsulated in the repository:</p> <pre><code>class OrderRepository(Repository[Order, str]):\n    async def find_orders_by_customer_async(self, customer_id: str) -&gt; List[Order]:\n        \"\"\"Find all orders for a specific customer\"\"\"\n        pass\n\n    async def find_orders_by_date_range_async(\n        self,\n        start_date: datetime,\n        end_date: datetime\n    ) -&gt; List[Order]:\n        \"\"\"Find orders within a date range\"\"\"\n        pass\n\n    async def find_popular_pizzas_async(self, days: int = 30) -&gt; List[PopularPizzaStats]:\n        \"\"\"Get pizza popularity statistics\"\"\"\n        pass\n</code></pre>"},{"location":"patterns/repository/#data-flow","title":"\ud83d\udd04 Data Flow","text":"<p>Order management demonstrates repository data flow:</p> <pre><code>sequenceDiagram\n    participant Client\n    participant Handler as Order Handler\n    participant Repo as Order Repository\n    participant MongoDB as MongoDB\n    participant FileSystem as File System\n\n    Note over Client,FileSystem: Save Order Flow\n    Client-&gt;&gt;+Handler: PlaceOrderCommand\n    Handler-&gt;&gt;Handler: Create Order entity\n    Handler-&gt;&gt;+Repo: save_async(order)\n\n    alt MongoDB Implementation\n        Repo-&gt;&gt;+MongoDB: Insert document\n        MongoDB--&gt;&gt;-Repo: Success\n    else File Implementation\n        Repo-&gt;&gt;+FileSystem: Write JSON file\n        FileSystem--&gt;&gt;-Repo: Success\n    end\n\n    Repo--&gt;&gt;-Handler: Order saved\n    Handler--&gt;&gt;-Client: OrderDto result\n\n    Note over Client,FileSystem: Query Orders Flow\n    Client-&gt;&gt;+Handler: GetOrderHistoryQuery\n    Handler-&gt;&gt;+Repo: find_orders_by_customer_async(customer_id)\n\n    alt MongoDB Implementation\n        Repo-&gt;&gt;+MongoDB: Find query with aggregation\n        MongoDB--&gt;&gt;-Repo: Order documents\n    else File Implementation\n        Repo-&gt;&gt;+FileSystem: Read and filter JSON files\n        FileSystem--&gt;&gt;-Repo: Order data\n    end\n\n    Repo--&gt;&gt;-Handler: List[Order]\n    Handler-&gt;&gt;Handler: Map to DTOs\n    Handler--&gt;&gt;-Client: List[OrderDto]</code></pre>"},{"location":"patterns/repository/#use-cases","title":"\ud83c\udfaf Use Cases","text":"<p>Repository pattern is ideal for:</p> <ul> <li>Multiple Storage Options: Support different databases/storage systems</li> <li>Complex Queries: Encapsulate sophisticated data access logic</li> <li>Testing: Easy mocking and unit testing</li> <li>Legacy Integration: Abstract away legacy system complexity</li> </ul>"},{"location":"patterns/repository/#implementation-in-marios-pizzeria","title":"\ud83c\udf55 Implementation in Mario's Pizzeria","text":""},{"location":"patterns/repository/#repository-interface","title":"Repository Interface","text":"<pre><code># Abstract base repository for all entities\nclass Repository(ABC, Generic[TEntity, TKey]):\n    @abstractmethod\n    async def get_by_id_async(self, id: TKey) -&gt; Optional[TEntity]:\n        \"\"\"Get entity by ID\"\"\"\n        pass\n\n    @abstractmethod\n    async def save_async(self, entity: TEntity) -&gt; None:\n        \"\"\"Save or update entity\"\"\"\n        pass\n\n    @abstractmethod\n    async def delete_async(self, id: TKey) -&gt; bool:\n        \"\"\"Delete entity by ID\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_all_async(self) -&gt; List[TEntity]:\n        \"\"\"Get all entities\"\"\"\n        pass\n\n# Order-specific repository interface\nclass OrderRepository(Repository[Order, str]):\n    @abstractmethod\n    async def find_by_customer_async(self, customer_id: str) -&gt; List[Order]:\n        \"\"\"Find orders for a specific customer\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_by_status_async(self, status: OrderStatus) -&gt; List[Order]:\n        \"\"\"Find orders by status\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_by_date_range_async(\n        self,\n        start_date: datetime,\n        end_date: datetime\n    ) -&gt; List[Order]:\n        \"\"\"Find orders within date range\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_daily_sales_async(self, date: datetime.date) -&gt; DailySalesReport:\n        \"\"\"Get sales report for specific date\"\"\"\n        pass\n</code></pre>"},{"location":"patterns/repository/#mongodb-implementation","title":"MongoDB Implementation","text":"<pre><code>class MongoOrderRepository(OrderRepository):\n    def __init__(self, collection: Collection):\n        self._collection = collection\n\n    async def get_by_id_async(self, order_id: str) -&gt; Optional[Order]:\n        document = await self._collection.find_one({\"_id\": order_id})\n        return self._document_to_entity(document) if document else None\n\n    async def save_async(self, order: Order) -&gt; None:\n        document = self._entity_to_document(order)\n        await self._collection.replace_one(\n            {\"_id\": order.id},\n            document,\n            upsert=True\n        )\n\n    async def find_by_customer_async(self, customer_id: str) -&gt; List[Order]:\n        cursor = self._collection.find({\"customer_id\": customer_id})\n        documents = await cursor.to_list(None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def find_by_status_async(self, status: OrderStatus) -&gt; List[Order]:\n        cursor = self._collection.find({\"status\": status.value})\n        documents = await cursor.to_list(None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def get_daily_sales_async(self, date: datetime.date) -&gt; DailySalesReport:\n        start_datetime = datetime.combine(date, datetime.min.time())\n        end_datetime = datetime.combine(date, datetime.max.time())\n\n        pipeline = [\n            {\n                \"$match\": {\n                    \"created_at\": {\n                        \"$gte\": start_datetime,\n                        \"$lt\": end_datetime\n                    },\n                    \"status\": {\"$ne\": \"cancelled\"}\n                }\n            },\n            {\n                \"$group\": {\n                    \"_id\": None,\n                    \"total_orders\": {\"$sum\": 1},\n                    \"total_revenue\": {\"$sum\": \"$total\"},\n                    \"avg_order_value\": {\"$avg\": \"$total\"}\n                }\n            }\n        ]\n\n        result = await self._collection.aggregate(pipeline).to_list(1)\n        if result:\n            data = result[0]\n            return DailySalesReport(\n                date=date,\n                total_orders=data[\"total_orders\"],\n                total_revenue=Decimal(str(data[\"total_revenue\"])),\n                average_order_value=Decimal(str(data[\"avg_order_value\"]))\n            )\n\n        return DailySalesReport(date=date, total_orders=0, total_revenue=Decimal('0'))\n\n    def _entity_to_document(self, order: Order) -&gt; dict:\n        return {\n            \"_id\": order.id,\n            \"customer_id\": order.customer_id,\n            \"items\": [\n                {\n                    \"name\": item.pizza_name,\n                    \"size\": item.size,\n                    \"quantity\": item.quantity,\n                    \"price\": float(item.price)\n                }\n                for item in order.items\n            ],\n            \"total\": float(order.total),\n            \"status\": order.status.value,\n            \"delivery_address\": order.delivery_address,\n            \"special_instructions\": order.special_instructions,\n            \"created_at\": order.created_at,\n            \"updated_at\": order.updated_at\n        }\n\n    def _document_to_entity(self, document: dict) -&gt; Order:\n        items = [\n            OrderItem(\n                pizza_name=item[\"name\"],\n                size=PizzaSize(item[\"size\"]),\n                quantity=item[\"quantity\"],\n                price=Decimal(str(item[\"price\"]))\n            )\n            for item in document[\"items\"]\n        ]\n\n        order = Order(\n            id=document[\"_id\"],\n            customer_id=document[\"customer_id\"],\n            items=items,\n            delivery_address=document[\"delivery_address\"],\n            special_instructions=document.get(\"special_instructions\")\n        )\n\n        order.status = OrderStatus(document[\"status\"])\n        order.created_at = document[\"created_at\"]\n        order.updated_at = document[\"updated_at\"]\n\n        return order\n</code></pre>"},{"location":"patterns/repository/#file-based-implementation","title":"File-Based Implementation","text":"<pre><code>class FileOrderRepository(OrderRepository):\n    def __init__(self, data_directory: str):\n        self._data_dir = Path(data_directory)\n        self._data_dir.mkdir(exist_ok=True)\n\n    async def get_by_id_async(self, order_id: str) -&gt; Optional[Order]:\n        file_path = self._data_dir / f\"{order_id}.json\"\n        if not file_path.exists():\n            return None\n\n        async with aiofiles.open(file_path, 'r') as f:\n            data = json.loads(await f.read())\n            return self._dict_to_entity(data)\n\n    async def save_async(self, order: Order) -&gt; None:\n        file_path = self._data_dir / f\"{order.id}.json\"\n        data = self._entity_to_dict(order)\n\n        async with aiofiles.open(file_path, 'w') as f:\n            await f.write(json.dumps(data, indent=2, cls=DecimalEncoder))\n\n    async def find_by_customer_async(self, customer_id: str) -&gt; List[Order]:\n        orders = []\n        async for file_path in self._iterate_order_files():\n            async with aiofiles.open(file_path, 'r') as f:\n                data = json.loads(await f.read())\n                if data[\"customer_id\"] == customer_id:\n                    orders.append(self._dict_to_entity(data))\n        return orders\n\n    async def get_daily_sales_async(self, date: datetime.date) -&gt; DailySalesReport:\n        total_orders = 0\n        total_revenue = Decimal('0')\n\n        async for file_path in self._iterate_order_files():\n            async with aiofiles.open(file_path, 'r') as f:\n                data = json.loads(await f.read())\n                order_date = datetime.fromisoformat(data[\"created_at\"]).date()\n\n                if order_date == date and data[\"status\"] != \"cancelled\":\n                    total_orders += 1\n                    total_revenue += Decimal(str(data[\"total\"]))\n\n        avg_order_value = total_revenue / total_orders if total_orders &gt; 0 else Decimal('0')\n\n        return DailySalesReport(\n            date=date,\n            total_orders=total_orders,\n            total_revenue=total_revenue,\n            average_order_value=avg_order_value\n        )\n\n    async def _iterate_order_files(self):\n        for file_path in self._data_dir.glob(\"*.json\"):\n            yield file_path\n</code></pre>"},{"location":"patterns/repository/#in-memory-implementation-testing","title":"In-Memory Implementation (Testing)","text":"<pre><code>class InMemoryOrderRepository(OrderRepository):\n    def __init__(self):\n        self._orders: Dict[str, Order] = {}\n\n    async def get_by_id_async(self, order_id: str) -&gt; Optional[Order]:\n        return self._orders.get(order_id)\n\n    async def save_async(self, order: Order) -&gt; None:\n        # Create deep copy to avoid reference issues in tests\n        self._orders[order.id] = copy.deepcopy(order)\n\n    async def delete_async(self, order_id: str) -&gt; bool:\n        if order_id in self._orders:\n            del self._orders[order_id]\n            return True\n        return False\n\n    async def find_all_async(self) -&gt; List[Order]:\n        return list(self._orders.values())\n\n    async def find_by_customer_async(self, customer_id: str) -&gt; List[Order]:\n        return [order for order in self._orders.values()\n                if order.customer_id == customer_id]\n\n    async def find_by_status_async(self, status: OrderStatus) -&gt; List[Order]:\n        return [order for order in self._orders.values()\n                if order.status == status]\n\n    def clear(self):\n        \"\"\"Helper method for testing\"\"\"\n        self._orders.clear()\n</code></pre>"},{"location":"patterns/repository/#repository-registration","title":"Repository Registration","text":"<pre><code>class RepositoryConfiguration:\n    def configure_repositories(self, services: ServiceCollection, config: AppConfig):\n        if config.storage_type == \"mongodb\":\n            # MongoDB implementation\n            services.add_singleton(lambda sp: MongoClient(config.mongodb_connection))\n            services.add_scoped(lambda sp: MongoOrderRepository(\n                sp.get_service(MongoClient).orders_db.orders\n            ))\n\n        elif config.storage_type == \"file\":\n            # File-based implementation\n            services.add_scoped(lambda sp: FileOrderRepository(config.data_directory))\n\n        elif config.storage_type == \"memory\":\n            # In-memory implementation (testing)\n            services.add_singleton(InMemoryOrderRepository)\n\n        # Register interface to implementation\n        services.add_scoped(OrderRepository,\n                          lambda sp: sp.get_service(config.repository_implementation))\n</code></pre>"},{"location":"patterns/repository/#testing-with-repositories","title":"\ud83e\uddea Testing with Repositories","text":"<pre><code># Unit testing with mocked repositories\nclass TestOrderService:\n    def setup_method(self):\n        self.mock_repository = Mock(spec=OrderRepository)\n        self.service = OrderService(self.mock_repository)\n\n    async def test_get_customer_orders(self):\n        # Arrange\n        expected_orders = [\n            Order(customer_id=\"123\", items=[]),\n            Order(customer_id=\"123\", items=[])\n        ]\n        self.mock_repository.find_by_customer_async.return_value = expected_orders\n\n        # Act\n        result = await self.service.get_customer_orders(\"123\")\n\n        # Assert\n        assert len(result) == 2\n        self.mock_repository.find_by_customer_async.assert_called_once_with(\"123\")\n\n# Integration testing with real repositories\nclass TestOrderRepositoryIntegration:\n    def setup_method(self):\n        self.repository = InMemoryOrderRepository()\n\n    async def test_save_and_retrieve_order(self):\n        # Arrange\n        order = Order(\n            customer_id=\"123\",\n            items=[OrderItem(\"Margherita\", PizzaSize.LARGE, 1, Decimal('15.99'))]\n        )\n\n        # Act\n        await self.repository.save_async(order)\n        retrieved = await self.repository.get_by_id_async(order.id)\n\n        # Assert\n        assert retrieved is not None\n        assert retrieved.customer_id == \"123\"\n        assert len(retrieved.items) == 1\n</code></pre>"},{"location":"patterns/repository/#related-patterns","title":"\ud83d\udd17 Related Patterns","text":"<ul> <li>Clean Architecture - Repositories belong in the integration layer</li> <li>CQRS Pattern - Separate repositories for commands and queries</li> <li>Event-Driven Pattern - Repositories can publish domain events</li> </ul> <p>This pattern guide demonstrates the Repository pattern using Mario's Pizzeria's data access layer. The abstraction enables storage flexibility and comprehensive testing strategies. \ud83d\uddc4\ufe0f</p>"},{"location":"patterns/resource-oriented-architecture/","title":"\ud83c\udfaf Resource Oriented Architecture (ROA)","text":"<p>Resource Oriented Architecture is a powerful pattern for building systems that manage resources through their lifecycle, similar to how Kubernetes manages cluster resources. Neuroglia provides comprehensive support for ROA patterns including watchers, controllers, and reconciliation loops.</p>"},{"location":"patterns/resource-oriented-architecture/#overview","title":"\ud83c\udfaf Overview","text":"<p>ROA provides:</p> <ul> <li>\ud83d\udcca Resource Management: Declarative resource definitions with desired vs actual state</li> <li>\ud83d\udc40 Watchers: Continuous monitoring of resource changes through polling or event streams</li> <li>\ud83c\udfae Controllers: Business logic that responds to resource changes and implements state transitions</li> <li>\ud83d\udd04 Reconciliation: Periodic loops that ensure system consistency and handle drift detection</li> <li>\ud83d\udee1\ufe0f Safety Mechanisms: Timeout handling, error recovery, and corrective actions</li> </ul>"},{"location":"patterns/resource-oriented-architecture/#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<pre><code>graph TB\n    subgraph \"\ud83d\udcca Resource Layer\"\n        A[Resource Definition]\n        B[Resource Storage]\n        C[Resource Events]\n    end\n\n    subgraph \"\ud83d\udc40 Observation Layer\"\n        D[Watcher] --&gt; E[Event Stream]\n        F[Poller] --&gt; G[Change Detection]\n    end\n\n    subgraph \"\ud83c\udfae Control Layer\"\n        H[Controller] --&gt; I[Business Logic]\n        I --&gt; J[State Transitions]\n        I --&gt; K[Action Execution]\n    end\n\n    subgraph \"\ud83d\udd04 Reconciliation Layer\"\n        L[Reconciliation Loop] --&gt; M[Drift Detection]\n        M --&gt; N[Corrective Actions]\n        N --&gt; O[State Restoration]\n    end\n\n    subgraph \"\ud83d\udee1\ufe0f Safety Layer\"\n        P[Error Handling] --&gt; Q[Retry Logic]\n        Q --&gt; R[Circuit Breaker]\n        R --&gt; S[Timeout Management]\n    end\n\n    A --&gt; B\n    B --&gt; C\n    C --&gt; D\n    C --&gt; F\n    E --&gt; H\n    G --&gt; H\n    H --&gt; L\n    L --&gt; P\n\n    style A fill:#e3f2fd\n    style H fill:#f3e5f5\n    style L fill:#e8f5e8\n    style P fill:#fff3e0</code></pre>"},{"location":"patterns/resource-oriented-architecture/#core-components","title":"\ud83c\udfd7\ufe0f Core Components","text":""},{"location":"patterns/resource-oriented-architecture/#resource-definition","title":"Resource Definition","text":"<p>Resources are declarative objects that define desired state:</p> <pre><code>@dataclass\nclass LabInstanceResource:\n    api_version: str = \"lab.neuroglia.com/v1\"\n    kind: str = \"LabInstance\"\n    metadata: Dict[str, Any] = None\n    spec: Dict[str, Any] = None      # Desired state\n    status: Dict[str, Any] = None    # Current state\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#watcher-pattern","title":"Watcher Pattern","text":"<p>Watchers continuously monitor resources for changes:</p> <pre><code>class LabInstanceWatcher:\n    async def start_watching(self):\n        while self.is_running:\n            # Poll for changes since last known version\n            changes = self.storage.list_resources(since_version=self.last_resource_version)\n\n            for resource in changes:\n                await self._handle_resource_change(resource)\n\n            await asyncio.sleep(self.poll_interval)\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#controller-pattern","title":"Controller Pattern","text":"<p>Controllers respond to resource changes with business logic:</p> <pre><code>class LabInstanceController:\n    async def handle_resource_event(self, resource: LabInstanceResource):\n        current_state = resource.status.get('state')\n\n        if current_state == ResourceState.PENDING.value:\n            await self._start_provisioning(resource)\n        elif current_state == ResourceState.PROVISIONING.value:\n            await self._check_provisioning_status(resource)\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#reconciliation-loop","title":"Reconciliation Loop","text":"<p>Reconcilers ensure eventual consistency:</p> <pre><code>class LabInstanceScheduler:\n    async def start_reconciliation(self):\n        while self.is_running:\n            await self._reconcile_all_resources()\n            await asyncio.sleep(self.reconcile_interval)\n\n    async def _reconcile_resource(self, resource):\n        # Check for stuck states, timeouts, and drift\n        # Take corrective actions as needed\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#key-patterns","title":"\ud83d\ude80 Key Patterns","text":""},{"location":"patterns/resource-oriented-architecture/#1-declarative-state-management","title":"1. Declarative State Management","text":"<p>Resources define what should exist, not how to create it:</p> <pre><code># Desired state (spec)\nspec = {\n    'template': 'python-basics',\n    'duration': '60m',\n    'studentEmail': 'student@example.com'\n}\n\n# Current state (status)\nstatus = {\n    'state': 'ready',\n    'endpoint': 'https://lab-instance.example.com',\n    'readyAt': '2025-09-09T21:34:19Z'\n}\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#2-event-driven-processing","title":"2. Event-Driven Processing","text":"<p>Watchers detect changes and notify controllers immediately:</p> <pre><code>Resource Change \u2192 Watcher Detection \u2192 Controller Response \u2192 State Update\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#3-asynchronous-reconciliation","title":"3. Asynchronous Reconciliation","text":"<p>Controllers handle immediate responses while reconcilers provide safety:</p> <pre><code># Controller: Immediate response to events\nasync def handle_resource_event(self, resource):\n    if resource.state == PENDING:\n        await self.start_provisioning(resource)\n\n# Reconciler: Periodic safety checks\nasync def reconcile_resource(self, resource):\n    if self.is_stuck_provisioning(resource):\n        await self.mark_as_failed(resource)\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#4-state-machine-implementation","title":"4. State Machine Implementation","text":"<p>Resources progress through well-defined states:</p> <pre><code>PENDING \u2192 PROVISIONING \u2192 READY \u2192 (cleanup) \u2192 DELETING \u2192 DELETED\n    \u2193                      \u2193\n  FAILED              \u2190 FAILED\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#execution-model","title":"\u26a1 Execution Model","text":""},{"location":"patterns/resource-oriented-architecture/#timing-and-coordination","title":"Timing and Coordination","text":"<ul> <li>Watchers: Poll every 2-5 seconds for near-real-time responsiveness</li> <li>Controllers: Respond immediately to detected changes</li> <li>Reconcilers: Run every 10-30 seconds for consistency checks</li> </ul>"},{"location":"patterns/resource-oriented-architecture/#concurrent-processing","title":"Concurrent Processing","text":"<p>All components run concurrently:</p> <pre><code>async def main():\n    # Start all components concurrently\n    watcher_task = asyncio.create_task(watcher.start_watching())\n    scheduler_task = asyncio.create_task(scheduler.start_reconciliation())\n\n    # Controllers are event-driven (no separate task needed)\n    watcher.add_event_handler(controller.handle_resource_event)\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#safety-and-reliability","title":"\ud83d\udee1\ufe0f Safety and Reliability","text":""},{"location":"patterns/resource-oriented-architecture/#timeout-handling","title":"Timeout Handling","text":"<p>Reconcilers detect and handle stuck states:</p> <pre><code>if resource.state == PROVISIONING and age &gt; timeout_threshold:\n    await self.mark_as_failed(resource, \"Provisioning timeout\")\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#error-recovery","title":"Error Recovery","text":"<p>Controllers and reconcilers implement retry logic:</p> <pre><code>try:\n    await self.provision_lab_instance(resource)\nexcept Exception as e:\n    resource.status['retries'] = resource.status.get('retries', 0) + 1\n    if resource.status['retries'] &lt; max_retries:\n        await self.schedule_retry(resource)\n    else:\n        await self.mark_as_failed(resource, str(e))\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#drift-detection","title":"Drift Detection","text":"<p>Reconcilers verify that actual state matches desired state:</p> <pre><code>async def check_drift(self, resource):\n    actual_state = await self.get_actual_infrastructure_state(resource)\n    desired_state = resource.spec\n\n    if actual_state != desired_state:\n        await self.correct_drift(resource, actual_state, desired_state)\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#observability","title":"\ud83d\udcca Observability","text":""},{"location":"patterns/resource-oriented-architecture/#metrics-and-logging","title":"Metrics and Logging","text":"<p>ROA components provide rich observability:</p> <pre><code>logger.info(f\"\ud83d\udd0d Watcher detected change: {resource_id} -&gt; {state}\")\nlogger.info(f\"\ud83c\udfae Controller processing: {resource_id} (state: {state})\")\nlogger.info(f\"\ud83d\udd04 Reconciling {len(resources)} resources\")\nlogger.warning(f\"\u26a0\ufe0f Reconciler: Resource stuck: {resource_id}\")\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#resource-versioning","title":"Resource Versioning","text":"<p>Track changes with resource versions:</p> <pre><code>resource.metadata['resourceVersion'] = str(self.next_version())\nresource.metadata['lastModified'] = datetime.now(timezone.utc).isoformat()\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#configuration","title":"\ud83d\udd27 Configuration","text":""},{"location":"patterns/resource-oriented-architecture/#tuning-parameters","title":"Tuning Parameters","text":"<p>Adjust timing for your use case:</p> <pre><code># Development: Fast feedback\nwatcher = LabInstanceWatcher(storage, poll_interval=1.0)\nscheduler = LabInstanceScheduler(storage, reconcile_interval=5.0)\n\n# Production: Balanced performance\nwatcher = LabInstanceWatcher(storage, poll_interval=5.0)\nscheduler = LabInstanceScheduler(storage, reconcile_interval=30.0)\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#scaling-considerations","title":"Scaling Considerations","text":"<ul> <li>Multiple Watchers: Use resource sharding for scale</li> <li>Controller Parallelism: Process multiple resources concurrently</li> <li>Reconciler Batching: Group operations for efficiency</li> </ul>"},{"location":"patterns/resource-oriented-architecture/#use-cases","title":"\ud83c\udfaf Use Cases","text":"<p>ROA is ideal for:</p> <ul> <li>Infrastructure Management: Cloud resources, containers, services</li> <li>Workflow Orchestration: Multi-step processes with dependencies</li> <li>Resource Lifecycle: Provisioning, monitoring, cleanup</li> <li>System Integration: Managing external system state</li> <li>DevOps Automation: CI/CD pipelines, deployment management</li> </ul>"},{"location":"patterns/resource-oriented-architecture/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\ud83c\udfd7\ufe0f Watcher &amp; Reconciliation Patterns - Detailed pattern explanations</li> <li>\u26a1 Execution Flow - How components coordinate</li> <li>\ud83e\uddea Lab Resource Manager Sample - Complete ROA implementation</li> <li>\ud83c\udfaf CQRS &amp; Mediation - Command/Query patterns used in ROA</li> <li>\ud83d\uddc4\ufe0f Data Access - Repository patterns for resource storage</li> </ul>"},{"location":"patterns/watcher-reconciliation-execution/","title":"How Watcher and Reconciliation Loop Execute","text":"<p>This document provides a detailed explanation of how the Resource Watcher and Reconciliation Loop patterns execute in our Resource Oriented Architecture (ROA) implementation.</p>"},{"location":"patterns/watcher-reconciliation-execution/#execution-flow-overview","title":"\ud83d\udd04 Execution Flow Overview","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Resource       \u2502    \u2502  Resource       \u2502    \u2502  Background     \u2502\n\u2502  Watcher        \u2502    \u2502  Controller     \u2502    \u2502  Scheduler      \u2502\n\u2502                 \u2502    \u2502                 \u2502    \u2502                 \u2502\n\u2502 \u2022 Polls storage \u2502\u2500\u2500\u2500\u25b6\u2502 \u2022 Reconciles    \u2502\u25c4\u2500\u2500\u25b6\u2502 \u2022 Monitors all  \u2502\n\u2502 \u2022 Detects \u0394     \u2502    \u2502   resources     \u2502    \u2502   resources     \u2502\n\u2502 \u2022 Emits events  \u2502    \u2502 \u2022 Updates state \u2502    \u2502 \u2022 Enforces      \u2502\n\u2502 \u2022 Triggers      \u2502    \u2502 \u2022 Publishes     \u2502    \u2502   lifecycle     \u2502\n\u2502   reconciliation\u2502    \u2502   events        \u2502    \u2502                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                       \u2502                       \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                 \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502    Event Bus &amp;          \u2502\n                    \u2502  Cloud Events           \u2502\n                    \u2502                         \u2502\n                    \u2502 \u2022 Resource created      \u2502\n                    \u2502 \u2022 Resource updated      \u2502\n                    \u2502 \u2022 Status changed        \u2502\n                    \u2502 \u2022 Reconciliation done   \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#1-resource-watcher-execution","title":"1\ufe0f\u20e3 Resource Watcher Execution","text":""},{"location":"patterns/watcher-reconciliation-execution/#polling-loop-implementation","title":"Polling Loop Implementation","text":"<pre><code>class ResourceWatcherBase:\n    async def _watch_loop(self, namespace=None, label_selector=None):\n        \"\"\"\n        Main watch loop - executes continuously:\n\n        1. List current resources from storage\n        2. Compare with cached resources\n        3. Detect changes (CREATED, UPDATED, DELETED, STATUS_UPDATED)\n        4. Process each change\n        5. Update cache\n        6. Sleep until next poll\n        \"\"\"\n        while self._watching:\n            try:\n                # STEP 1: Get current state from storage\n                current_resources = await self._list_resources(namespace, label_selector)\n                current_resource_map = {r.id: r for r in current_resources}\n\n                # STEP 2: Detect changes by comparing with cache\n                changes = self._detect_changes(current_resource_map)\n\n                # STEP 3: Process each detected change\n                for change in changes:\n                    await self._process_change(change)\n\n                # STEP 4: Update cache with current state\n                self._resource_cache = current_resource_map\n\n                # STEP 5: Wait before next poll\n                await asyncio.sleep(self.watch_interval)\n\n            except Exception as e:\n                log.error(f\"Error in watch loop: {e}\")\n                await asyncio.sleep(self.watch_interval)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#change-detection-algorithm","title":"Change Detection Algorithm","text":"<pre><code>def _detect_changes(self, current_resources):\n    \"\"\"\n    Change detection compares current vs cached state:\n\n    \u2022 CREATED: resource_id in current but not in cache\n    \u2022 DELETED: resource_id in cache but not in current\n    \u2022 UPDATED: generation increased (spec changed)\n    \u2022 STATUS_UPDATED: status fields changed\n    \"\"\"\n    changes = []\n    current_ids = set(current_resources.keys())\n    cached_ids = set(self._resource_cache.keys())\n\n    # New resources (CREATED)\n    for resource_id in current_ids - cached_ids:\n        changes.append(ResourceChangeEvent(\n            change_type=ResourceChangeType.CREATED,\n            resource=current_resources[resource_id]\n        ))\n\n    # Deleted resources (DELETED)\n    for resource_id in cached_ids - current_ids:\n        changes.append(ResourceChangeEvent(\n            change_type=ResourceChangeType.DELETED,\n            resource=self._resource_cache[resource_id]\n        ))\n\n    # Modified resources (UPDATED/STATUS_UPDATED)\n    for resource_id in current_ids &amp; cached_ids:\n        current = current_resources[resource_id]\n        cached = self._resource_cache[resource_id]\n\n        # Spec changed (generation incremented)\n        if current.metadata.generation &gt; cached.metadata.generation:\n            changes.append(ResourceChangeEvent(\n                change_type=ResourceChangeType.UPDATED,\n                resource=current,\n                old_resource=cached\n            ))\n        # Status changed\n        elif self._has_status_changed(current, cached):\n            changes.append(ResourceChangeEvent(\n                change_type=ResourceChangeType.STATUS_UPDATED,\n                resource=current,\n                old_resource=cached\n            ))\n\n    return changes\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#event-processing-and-controller-triggering","title":"Event Processing and Controller Triggering","text":"<pre><code>async def _process_change(self, change):\n    \"\"\"\n    When changes are detected:\n\n    1. Call registered change handlers (like controllers)\n    2. Publish CloudEvents to event bus\n    3. Handle errors gracefully\n    \"\"\"\n    # STEP 1: Call all registered handlers\n    for handler in self._change_handlers:\n        try:\n            if asyncio.iscoroutinefunction(handler):\n                await handler(change)  # Triggers controller reconciliation\n            else:\n                handler(change)\n        except Exception as e:\n            log.error(f\"Change handler failed: {e}\")\n\n    # STEP 2: Publish event to broader system\n    await self._publish_change_event(change)\n\n# Example: Lab Instance Watcher\nclass LabInstanceWatcher(ResourceWatcherBase):\n    def __init__(self, repository, controller, event_publisher):\n        super().__init__(event_publisher)\n        # Register controller as change handler\n        self.add_change_handler(self._handle_resource_change)\n\n    async def _handle_resource_change(self, change):\n        \"\"\"Called automatically when changes detected\"\"\"\n        if change.change_type in [ResourceChangeType.CREATED, ResourceChangeType.UPDATED]:\n            # Trigger reconciliation for new/updated resources\n            await self.controller.reconcile(change.resource)\n        elif change.change_type == ResourceChangeType.DELETED:\n            # Trigger cleanup for deleted resources\n            await self.controller.finalize(change.resource)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#2-reconciliation-loop-execution","title":"2\ufe0f\u20e3 Reconciliation Loop Execution","text":""},{"location":"patterns/watcher-reconciliation-execution/#controller-reconciliation-pattern","title":"Controller Reconciliation Pattern","text":"<pre><code>class ResourceControllerBase:\n    async def reconcile(self, resource):\n        \"\"\"\n        Main reconciliation entry point:\n\n        1. Check if reconciliation is needed\n        2. Execute reconciliation logic with timeout\n        3. Handle results (success, failure, requeue)\n        4. Update resource status\n        5. Emit reconciliation events\n        \"\"\"\n        start_time = datetime.now()\n\n        try:\n            # STEP 1: Check if reconciliation needed\n            if not resource.needs_reconciliation():\n                log.debug(f\"Resource {resource.metadata.name} does not need reconciliation\")\n                return\n\n            # STEP 2: Execute reconciliation with timeout\n            result = await asyncio.wait_for(\n                self._do_reconcile(resource),\n                timeout=self._reconciliation_timeout.total_seconds()\n            )\n\n            # STEP 3: Handle reconciliation result\n            await self._handle_reconciliation_result(resource, result, start_time)\n\n        except asyncio.TimeoutError:\n            await self._handle_reconciliation_error(resource, TimeoutError(), start_time)\n        except Exception as e:\n            await self._handle_reconciliation_error(resource, e, start_time)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#lab-instance-controller-implementation","title":"Lab Instance Controller Implementation","text":"<pre><code>class LabInstanceController(ResourceControllerBase):\n    async def _do_reconcile(self, resource: LabInstanceRequest):\n        \"\"\"\n        Lab-specific reconciliation logic:\n\n        \u2022 PENDING \u2192 PROVISIONING: Check if should start\n        \u2022 PROVISIONING \u2192 RUNNING: Start container\n        \u2022 RUNNING \u2192 COMPLETED: Monitor completion\n        \u2022 Handle errors and timeouts\n        \"\"\"\n        current_phase = resource.status.phase\n\n        if current_phase == LabInstancePhase.PENDING:\n            if resource.should_start_now():\n                # Time to start - provision container\n                success = await self._provision_lab_instance(resource)\n                return ReconciliationResult.success() if success else ReconciliationResult.requeue()\n            else:\n                # Not time yet - requeue when it should start\n                remaining_time = resource.get_time_until_start()\n                return ReconciliationResult.requeue_after(remaining_time)\n\n        elif current_phase == LabInstancePhase.PROVISIONING:\n            # Check if container is ready\n            if await self._is_container_ready(resource):\n                resource.transition_to_running()\n                await self._repository.save_async(resource)\n                return ReconciliationResult.success()\n            else:\n                # Still provisioning - check again soon\n                return ReconciliationResult.requeue_after(timedelta(seconds=30))\n\n        elif current_phase == LabInstancePhase.RUNNING:\n            # Monitor for completion or timeout\n            if resource.is_expired():\n                await self._timeout_lab_instance(resource)\n                return ReconciliationResult.success()\n            else:\n                # Check again when it should expire\n                remaining_time = resource.get_remaining_duration()\n                return ReconciliationResult.requeue_after(remaining_time)\n\n        # No action needed for terminal phases\n        return ReconciliationResult.success()\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#3-background-scheduler-as-reconciliation-loop","title":"3\ufe0f\u20e3 Background Scheduler as Reconciliation Loop","text":""},{"location":"patterns/watcher-reconciliation-execution/#scheduler-service-implementation","title":"Scheduler Service Implementation","text":"<pre><code>class LabInstanceSchedulerService(HostedService):\n    \"\"\"\n    Background service that acts as a reconciliation loop:\n\n    \u2022 Runs independently of watchers\n    \u2022 Periodically scans all resources\n    \u2022 Applies policies and enforces state\n    \u2022 Handles bulk operations\n    \"\"\"\n\n    async def _run_scheduler_loop(self):\n        \"\"\"Main scheduler loop - runs continuously\"\"\"\n        cleanup_counter = 0\n\n        while self._running:\n            try:\n                # PHASE 1: Process scheduled instances (PENDING \u2192 PROVISIONING)\n                await self._process_scheduled_instances()\n\n                # PHASE 2: Monitor running instances (RUNNING state health)\n                await self._process_running_instances()\n\n                # PHASE 3: Periodic cleanup (expired/failed instances)\n                cleanup_counter += self._scheduler_interval\n                if cleanup_counter &gt;= self._cleanup_interval:\n                    await self._cleanup_expired_instances()\n                    cleanup_counter = 0\n\n                # Wait before next iteration\n                await asyncio.sleep(self._scheduler_interval)\n\n            except Exception as e:\n                log.error(f\"Error in scheduler loop: {e}\")\n                await asyncio.sleep(self._scheduler_interval)\n\n    async def _process_scheduled_instances(self):\n        \"\"\"Reconcile PENDING instances that should start\"\"\"\n        try:\n            # Find all pending instances that are scheduled\n            pending_instances = await self._repository.find_scheduled_pending_async()\n\n            for instance in pending_instances:\n                if instance.should_start_now():\n                    # Move toward desired state: PENDING \u2192 PROVISIONING \u2192 RUNNING\n                    await self._start_lab_instance(instance)\n\n        except Exception as e:\n            log.error(f\"Error processing scheduled instances: {e}\")\n\n    async def _process_running_instances(self):\n        \"\"\"Reconcile RUNNING instances for health/completion\"\"\"\n        try:\n            running_instances = await self._repository.find_running_instances_async()\n\n            for instance in running_instances:\n                # Check actual container state vs desired state\n                container_status = await self._container_service.get_container_status_async(\n                    instance.status.container_id\n                )\n\n                # Reconcile based on actual vs desired state\n                if container_status == \"stopped\":\n                    # Container stopped - instance should complete\n                    await self._complete_lab_instance(instance)\n                elif container_status == \"error\":\n                    # Container errored - instance should fail\n                    await self._fail_lab_instance(instance, \"Container error\")\n                elif instance.is_expired():\n                    # Policy violation - enforce timeout\n                    await self._timeout_lab_instance(instance)\n\n        except Exception as e:\n            log.error(f\"Error processing running instances: {e}\")\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#4-integration-patterns-and-event-flow","title":"4\ufe0f\u20e3 Integration Patterns and Event Flow","text":""},{"location":"patterns/watcher-reconciliation-execution/#complete-event-flow-example","title":"Complete Event Flow Example","text":"<pre><code>1. User creates LabInstanceRequest\n   \u2514\u2500 Resource saved to storage\n\n2. Watcher detects CREATED event (next poll cycle)\n   \u251c\u2500 Publishes labinstancerequest.created CloudEvent\n   \u2514\u2500 Triggers controller.reconcile(resource)\n\n3. Controller reconciliation\n   \u251c\u2500 Checks: resource.should_start_now() \u2192 false (scheduled for later)\n   \u2514\u2500 Returns: ReconciliationResult.requeue_after(delay)\n\n4. Scheduler loop (independent polling)\n   \u251c\u2500 Finds pending instances that should start\n   \u251c\u2500 Calls _start_lab_instance(resource)\n   \u2502  \u251c\u2500 Transitions: PENDING \u2192 PROVISIONING\n   \u2502  \u251c\u2500 Creates container\n   \u2502  \u2514\u2500 Transitions: PROVISIONING \u2192 RUNNING\n   \u2514\u2500 Updates resource status in storage\n\n5. Watcher detects STATUS_UPDATED event\n   \u251c\u2500 Publishes labinstancerequest.status_updated CloudEvent\n   \u2514\u2500 Triggers controller.reconcile(resource) again\n\n6. Controller reconciliation (RUNNING phase)\n   \u251c\u2500 Calculates when instance should expire\n   \u2514\u2500 Returns: ReconciliationResult.requeue_after(remaining_time)\n\n7. Time passes... scheduler monitors container health\n\n8. Container completes/fails/times out\n   \u251c\u2500 Scheduler detects state change\n   \u251c\u2500 Updates resource: RUNNING \u2192 COMPLETED/FAILED/TIMEOUT\n   \u2514\u2500 Cleans up container resources\n\n9. Watcher detects final STATUS_UPDATED event\n   \u251c\u2500 Publishes final CloudEvent\n   \u2514\u2500 Controller reconciliation confirms no action needed\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#timing-and-coordination","title":"Timing and Coordination","text":"Component Frequency Purpose Watcher 5-10 seconds Detect changes, trigger reactive reconciliation Scheduler 30-60 seconds Proactive reconciliation, policy enforcement Controller Event-driven Handle specific resource changes"},{"location":"patterns/watcher-reconciliation-execution/#error-handling-and-resilience","title":"Error Handling and Resilience","text":"<pre><code># Watcher error handling\nasync def _watch_loop(self):\n    while self._watching:\n        try:\n            # Process changes\n            pass\n        except Exception as e:\n            log.error(f\"Watch loop error: {e}\")\n            await asyncio.sleep(self.watch_interval)  # Continue watching\n\n# Controller error handling\nasync def reconcile(self, resource):\n    try:\n        result = await asyncio.wait_for(self._do_reconcile(resource), timeout=300)\n    except asyncio.TimeoutError:\n        # Handle timeout - mark for retry\n        result = ReconciliationResult.requeue()\n    except Exception as e:\n        # Handle error - exponential backoff\n        result = ReconciliationResult.failed(e)\n\n# Scheduler error handling\nasync def _run_scheduler_loop(self):\n    while self._running:\n        try:\n            # Process all phases\n            pass\n        except Exception as e:\n            log.error(f\"Scheduler error: {e}\")\n            await asyncio.sleep(self._scheduler_interval)  # Continue scheduling\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#observability-and-monitoring","title":"\ud83d\udcca Observability and Monitoring","text":""},{"location":"patterns/watcher-reconciliation-execution/#key-metrics-to-monitor","title":"Key Metrics to Monitor","text":"<pre><code># Watcher metrics\n{\n    \"watch_loop_iterations\": 1234,\n    \"changes_detected\": 56,\n    \"events_published\": 78,\n    \"cache_hit_ratio\": 0.95,\n    \"average_poll_duration\": \"150ms\"\n}\n\n# Controller metrics\n{\n    \"reconciliations_total\": 234,\n    \"reconciliations_successful\": 220,\n    \"reconciliations_failed\": 4,\n    \"reconciliations_requeued\": 10,\n    \"average_reconciliation_time\": \"2.3s\"\n}\n\n# Scheduler metrics\n{\n    \"scheduler_loop_iterations\": 567,\n    \"resources_processed\": 890,\n    \"state_transitions\": 123,\n    \"cleanup_operations\": 45,\n    \"average_loop_duration\": \"5.2s\"\n}\n</code></pre> <p>This architecture provides a robust, scalable foundation for declarative resource management that automatically maintains desired state while being resilient to failures and providing comprehensive observability.</p>"},{"location":"patterns/watcher-reconciliation-patterns/","title":"Resource Watcher and Reconciliation Loop Patterns","text":"<p>This document explains how the Resource Watcher and Reconciliation Loop patterns work in our Resource Oriented Architecture (ROA) implementation, providing the foundation for Kubernetes-style declarative resource management.</p>"},{"location":"patterns/watcher-reconciliation-patterns/#overview","title":"\ud83c\udfaf Overview","text":"<p>The ROA implementation uses two complementary patterns:</p> <ol> <li>Resource Watcher: Detects changes to resources and emits events</li> <li>Reconciliation Loop: Continuously ensures actual state matches desired state</li> </ol> <p>These patterns work together to provide:</p> <ul> <li>Declarative Management: Specify desired state, controllers make it happen</li> <li>Event-Driven Processing: React to changes as they occur</li> <li>Self-Healing: Automatically correct drift from desired state</li> <li>Extensibility: Pluggable controllers for different resource types</li> </ul>"},{"location":"patterns/watcher-reconciliation-patterns/#resource-watcher-pattern","title":"\ud83d\udd0d Resource Watcher Pattern","text":""},{"location":"patterns/watcher-reconciliation-patterns/#how-the-watcher-works","title":"How the Watcher Works","text":"<pre><code>class ResourceWatcherBase(Generic[TResourceSpec, TResourceStatus]):\n    \"\"\"\n    The watcher follows a polling pattern:\n    1. Periodically lists resources from storage\n    2. Compares current state with cached state\n    3. Detects changes (CREATED, UPDATED, DELETED, STATUS_UPDATED)\n    4. Emits events for detected changes\n    5. Updates cache with current state\n    \"\"\"\n\n    async def _watch_loop(self, namespace=None, label_selector=None):\n        while self._watching:\n            # 1. Get current resources\n            current_resources = await self._list_resources(namespace, label_selector)\n            current_resource_map = {r.id: r for r in current_resources}\n\n            # 2. Detect changes\n            changes = self._detect_changes(current_resource_map)\n\n            # 3. Process each change\n            for change in changes:\n                await self._process_change(change)\n\n            # 4. Update cache\n            self._resource_cache = current_resource_map\n\n            # 5. Wait before next poll\n            await asyncio.sleep(self.watch_interval)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#change-detection-logic","title":"Change Detection Logic","text":"<p>The watcher detects four types of changes:</p> <pre><code>def _detect_changes(self, current_resources):\n    changes = []\n    current_ids = set(current_resources.keys())\n    cached_ids = set(self._resource_cache.keys())\n\n    # 1. CREATED: New resources that weren't in cache\n    for resource_id in current_ids - cached_ids:\n        changes.append(ResourceChangeEvent(\n            change_type=ResourceChangeType.CREATED,\n            resource=current_resources[resource_id]\n        ))\n\n    # 2. DELETED: Cached resources no longer present\n    for resource_id in cached_ids - current_ids:\n        changes.append(ResourceChangeEvent(\n            change_type=ResourceChangeType.DELETED,\n            resource=self._resource_cache[resource_id]\n        ))\n\n    # 3. UPDATED: Spec changed (generation increment)\n    # 4. STATUS_UPDATED: Status changed (observed generation, etc.)\n    for resource_id in current_ids &amp; cached_ids:\n        current = current_resources[resource_id]\n        cached = self._resource_cache[resource_id]\n\n        if current.metadata.generation &gt; cached.metadata.generation:\n            # Spec was updated\n            changes.append(ResourceChangeEvent(\n                change_type=ResourceChangeType.UPDATED,\n                resource=current,\n                old_resource=cached\n            ))\n        elif self._has_status_changed(current, cached):\n            # Status was updated\n            changes.append(ResourceChangeEvent(\n                change_type=ResourceChangeType.STATUS_UPDATED,\n                resource=current,\n                old_resource=cached\n            ))\n\n    return changes\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#event-processing-and-publishing","title":"Event Processing and Publishing","text":"<p>When changes are detected, the watcher:</p> <pre><code>async def _process_change(self, change):\n    # 1. Call registered change handlers\n    for handler in self._change_handlers:\n        if asyncio.iscoroutinefunction(handler):\n            await handler(change)\n        else:\n            handler(change)\n\n    # 2. Publish CloudEvent\n    await self._publish_change_event(change)\n\nasync def _publish_change_event(self, change):\n    event_type = f\"{resource.kind.lower()}.{change.change_type.value.lower()}\"\n\n    event = CloudEvent(\n        source=f\"watcher/{resource.kind.lower()}\",\n        type=event_type,  # e.g., \"labinstancerequest.created\"\n        subject=f\"{resource.metadata.namespace}/{resource.metadata.name}\",\n        data={\n            \"resourceUid\": resource.id,\n            \"apiVersion\": resource.api_version,\n            \"kind\": resource.kind,\n            \"changeType\": change.change_type.value,\n            \"generation\": resource.metadata.generation,\n            \"observedGeneration\": resource.status.observed_generation\n        }\n    )\n\n    await self.event_publisher.publish_async(event)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#reconciliation-loop-pattern","title":"\ud83d\udd04 Reconciliation Loop Pattern","text":""},{"location":"patterns/watcher-reconciliation-patterns/#how-reconciliation-works","title":"How Reconciliation Works","text":"<pre><code>class ResourceControllerBase(Generic[TResourceSpec, TResourceStatus]):\n    \"\"\"\n    Controllers implement the reconciliation pattern:\n    1. Receive resource change events\n    2. Compare current state with desired state\n    3. Take actions to move toward desired state\n    4. Update resource status\n    5. Emit reconciliation events\n    \"\"\"\n\n    async def reconcile(self, resource):\n        # 1. Check if reconciliation is needed\n        if not resource.needs_reconciliation():\n            return\n\n        # 2. Execute reconciliation with timeout\n        result = await asyncio.wait_for(\n            self._do_reconcile(resource),\n            timeout=self._reconciliation_timeout.total_seconds()\n        )\n\n        # 3. Handle result (success, failure, requeue)\n        await self._handle_reconciliation_result(resource, result)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#reconciliation-states","title":"Reconciliation States","text":"<p>Controllers can return different reconciliation results:</p> <pre><code>class ReconciliationStatus(Enum):\n    SUCCESS = \"Success\"          # Reconciliation completed successfully\n    FAILED = \"Failed\"            # Reconciliation failed, needs attention\n    REQUEUE = \"Requeue\"          # Retry immediately\n    REQUEUE_AFTER = \"RequeueAfter\"  # Retry after specified delay\n\n# Example usage in controller\nasync def _do_reconcile(self, resource):\n    if resource.status.phase == LabInstancePhase.PENDING:\n        if resource.should_start_now():\n            success = await self._start_lab_instance(resource)\n            return ReconciliationResult.success() if success else ReconciliationResult.requeue()\n        else:\n            # Not time to start yet, check again in 30 seconds\n            return ReconciliationResult.requeue_after(timedelta(seconds=30))\n\n    elif resource.status.phase == LabInstancePhase.RUNNING:\n        if resource.is_expired():\n            await self._stop_lab_instance(resource)\n            return ReconciliationResult.success()\n        else:\n            # Check again when it should expire\n            remaining = resource.get_remaining_duration()\n            return ReconciliationResult.requeue_after(remaining)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#integration-patterns","title":"\ud83d\udd27 Integration Patterns","text":""},{"location":"patterns/watcher-reconciliation-patterns/#pattern-1-watcher-controller-integration","title":"Pattern 1: Watcher \u2192 Controller Integration","text":"<pre><code># Watcher detects changes and triggers controller\nclass LabInstanceWatcher(ResourceWatcherBase[LabInstanceRequestSpec, LabInstanceRequestStatus]):\n    def __init__(self, repository, controller, event_publisher):\n        super().__init__(event_publisher)\n        self.repository = repository\n        self.controller = controller\n\n        # Register controller as change handler\n        self.add_change_handler(self._handle_resource_change)\n\n    async def _list_resources(self, namespace=None, label_selector=None):\n        return await self.repository.list_async(namespace=namespace)\n\n    async def _handle_resource_change(self, change):\n        \"\"\"Called when resource changes are detected.\"\"\"\n        resource = change.resource\n\n        if change.change_type in [ResourceChangeType.CREATED, ResourceChangeType.UPDATED]:\n            # Trigger reconciliation for created or updated resources\n            await self.controller.reconcile(resource)\n        elif change.change_type == ResourceChangeType.DELETED:\n            # Trigger finalization for deleted resources\n            await self.controller.finalize(resource)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#pattern-2-background-scheduler-as-reconciliation-loop","title":"Pattern 2: Background Scheduler as Reconciliation Loop","text":"<pre><code>class LabInstanceSchedulerService(HostedService):\n    \"\"\"\n    Background service that acts as a reconciliation loop:\n    1. Periodically scans all resources\n    2. Identifies resources that need reconciliation\n    3. Applies appropriate actions\n    4. Updates resource status\n    \"\"\"\n\n    async def _run_scheduler_loop(self):\n        while self._running:\n            # Reconciliation phases\n            await self._process_scheduled_instances()  # PENDING \u2192 PROVISIONING\n            await self._process_running_instances()    # RUNNING monitoring\n            await self._cleanup_expired_instances()    # TIMEOUT/CLEANUP\n\n            await asyncio.sleep(self._scheduler_interval)\n\n    async def _process_scheduled_instances(self):\n        \"\"\"Reconcile PENDING resources that should be started.\"\"\"\n        pending_instances = await self.repository.find_by_phase_async(LabInstancePhase.PENDING)\n\n        for instance in pending_instances:\n            if instance.should_start_now():\n                # Move toward desired state: PENDING \u2192 PROVISIONING \u2192 RUNNING\n                await self._start_lab_instance(instance)\n\n    async def _process_running_instances(self):\n        \"\"\"Reconcile RUNNING resources for completion/errors.\"\"\"\n        running_instances = await self.repository.find_by_phase_async(LabInstancePhase.RUNNING)\n\n        for instance in running_instances:\n            # Check actual container state vs desired state\n            container_status = await self.container_service.get_container_status_async(\n                instance.status.container_id\n            )\n\n            if container_status == \"stopped\":\n                # Actual state differs from desired, reconcile\n                await self._complete_lab_instance(instance)\n            elif instance.is_expired():\n                # Policy violation, enforce timeout\n                await self._timeout_lab_instance(instance)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#pattern-3-event-driven-reconciliation","title":"Pattern 3: Event-Driven Reconciliation","text":"<pre><code>class LabInstanceEventHandler:\n    \"\"\"Handle resource events and trigger reconciliation.\"\"\"\n\n    async def handle_lab_instance_created(self, event):\n        \"\"\"When a lab instance is created, ensure it's properly scheduled.\"\"\"\n        resource_id = event.data[\"resourceUid\"]\n        resource = await self.repository.get_by_id_async(resource_id)\n\n        if resource and resource.status.phase == LabInstancePhase.PENDING:\n            # Ensure resource is in scheduling queue\n            await self.controller.reconcile(resource)\n\n    async def handle_lab_instance_updated(self, event):\n        \"\"\"When a lab instance is updated, re-reconcile.\"\"\"\n        resource_id = event.data[\"resourceUid\"]\n        resource = await self.repository.get_by_id_async(resource_id)\n\n        if resource:\n            await self.controller.reconcile(resource)\n\n    async def handle_container_event(self, event):\n        \"\"\"When container state changes, update resource status.\"\"\"\n        container_id = event.data[\"containerId\"]\n\n        # Find resource with this container\n        instances = await self.repository.find_by_container_id_async(container_id)\n\n        for instance in instances:\n            # Reconcile to reflect new container state\n            await self.controller.reconcile(instance)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#complete-integration-example","title":"\ud83d\ude80 Complete Integration Example","text":"<p>Here's how all patterns work together:</p> <pre><code># 1. Setup watcher and controller\nwatcher = LabInstanceWatcher(repository, controller, event_publisher)\nscheduler = LabInstanceSchedulerService(repository, container_service, event_bus)\n\n# 2. Start background processes\nawait watcher.watch(namespace=\"default\")\nawait scheduler.start_async()\n\n# 3. Create a resource (triggers CREATED event)\nlab_instance = LabInstanceRequest(...)\nawait repository.save_async(lab_instance)\n\n# 4. Watcher detects CREATED event\n# 5. Watcher calls controller.reconcile(lab_instance)\n# 6. Controller checks if action needed (should_start_now?)\n# 7. If not time yet, controller returns REQUEUE_AFTER\n# 8. Scheduler loop independently checks all PENDING resources\n# 9. When time arrives, scheduler starts the lab instance\n# 10. Status update triggers STATUS_UPDATED event\n# 11. Watcher publishes CloudEvent\n# 12. Other services can react to the event\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#observability-and-monitoring","title":"\ud83d\udcca Observability and Monitoring","text":"<p>Both patterns provide rich observability:</p>"},{"location":"patterns/watcher-reconciliation-patterns/#watcher-metrics","title":"Watcher Metrics","text":"<pre><code>watcher_metrics = {\n    \"is_watching\": watcher.is_watching(),\n    \"cached_resources\": watcher.get_cached_resource_count(),\n    \"watch_interval\": watcher.watch_interval,\n    \"events_published\": watcher.events_published_count,\n    \"change_handlers\": len(watcher._change_handlers)\n}\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#controller-metrics","title":"Controller Metrics","text":"<pre><code>controller_metrics = {\n    \"reconciliations_total\": controller.reconciliation_count,\n    \"reconciliations_successful\": controller.success_count,\n    \"reconciliations_failed\": controller.failure_count,\n    \"average_reconciliation_duration\": controller.avg_duration,\n    \"pending_reconciliations\": controller.queue_size\n}\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#scheduler-metrics","title":"Scheduler Metrics","text":"<pre><code>scheduler_metrics = {\n    \"running\": scheduler._running,\n    \"scheduler_interval\": scheduler._scheduler_interval,\n    \"instances_by_phase\": {\n        phase.value: await repository.count_by_phase_async(phase)\n        for phase in LabInstancePhase\n    },\n    \"processed_this_cycle\": scheduler.processed_count\n}\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#configuration-and-tuning","title":"\u2699\ufe0f Configuration and Tuning","text":""},{"location":"patterns/watcher-reconciliation-patterns/#watcher-configuration","title":"Watcher Configuration","text":"<pre><code>watcher = LabInstanceWatcher(\n    repository=repository,\n    controller=controller,\n    event_publisher=event_publisher,\n    watch_interval=5.0  # Poll every 5 seconds\n)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#controller-configuration","title":"Controller Configuration","text":"<pre><code>controller = LabInstanceController(\n    service_provider=service_provider,\n    event_publisher=event_publisher\n)\ncontroller._reconciliation_timeout = timedelta(minutes=10)\ncontroller._max_retry_attempts = 5\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#scheduler-configuration","title":"Scheduler Configuration","text":"<pre><code>scheduler = LabInstanceSchedulerService(\n    repository=repository,\n    container_service=container_service,\n    event_bus=event_bus\n)\nscheduler._scheduler_interval = 30      # 30 second reconciliation loop\nscheduler._cleanup_interval = 300       # 5 minute cleanup cycle\n</code></pre> <p>This architecture provides a robust, observable, and extensible foundation for managing resources in a declarative, Kubernetes-style manner while integrating seamlessly with traditional CQRS patterns.</p>"},{"location":"references/12-factor-app/","title":"\ud83c\udfed The Twelve-Factor App with Neuroglia","text":"<p>The Twelve-Factor App is a methodology for building software-as-a-service applications that are portable, scalable, and maintainable. The Neuroglia framework was designed from the ground up to support and enforce these principles, making it easy to build cloud-native applications that follow best practices.</p>"},{"location":"references/12-factor-app/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>How each of the 12 factors applies to modern cloud-native applications</li> <li>How Neuroglia framework features directly support 12-factor compliance</li> <li>Practical implementation patterns using Mario's Pizzeria as an example</li> <li>Best practices for deploying and managing 12-factor applications</li> </ul>"},{"location":"references/12-factor-app/#i-codebase","title":"I. Codebase \ud83d\udcc1","text":"<p>Principle: One codebase tracked in revision control, many deploys</p>"},{"location":"references/12-factor-app/#requirements","title":"Requirements","text":"<ul> <li>Single codebase in version control (Git)</li> <li>Multiple deployments from same codebase (dev, staging, production)</li> <li>No shared code between apps - use libraries instead</li> </ul>"},{"location":"references/12-factor-app/#how-neuroglia-supports-this","title":"How Neuroglia Supports This","text":"<p>The framework enforces clean separation of concerns through its modular architecture:</p> <pre><code># Single codebase structure\nsrc/\n\u251c\u2500\u2500 marios_pizzeria/           # Single application codebase\n\u2502   \u251c\u2500\u2500 api/                   # API layer\n\u2502   \u251c\u2500\u2500 application/           # Business logic\n\u2502   \u251c\u2500\u2500 domain/                # Core domain\n\u2502   \u2514\u2500\u2500 integration/           # External integrations\n\u251c\u2500\u2500 shared_libs/               # Reusable libraries\n\u2502   \u2514\u2500\u2500 neuroglia/            # Framework as separate library\n\u2514\u2500\u2500 deployment/                # Environment-specific configs\n    \u251c\u2500\u2500 dev/\n    \u251c\u2500\u2500 staging/\n    \u2514\u2500\u2500 production/\n</code></pre> <p>Example: Mario's Pizzeria has one codebase but deploys to multiple environments:</p> <pre><code># main.py - Same code, different configs\nfrom neuroglia.hosting.web import WebApplicationBuilder\n\ndef create_app():\n    builder = WebApplicationBuilder()\n\n    # Configuration varies by environment\n    # but same codebase everywhere\n    services = builder.services\n    services.add_controllers([\"api.controllers\"])\n    services.add_mediator()\n\n    return builder.build()\n</code></pre>"},{"location":"references/12-factor-app/#ii-dependencies","title":"II. Dependencies \ud83d\udce6","text":"<p>Principle: Explicitly declare and isolate dependencies</p>"},{"location":"references/12-factor-app/#requirements_1","title":"Requirements","text":"<ul> <li>Explicit dependency declaration</li> <li>Dependency isolation (no system-wide packages)</li> <li>No implicit dependencies on system tools</li> </ul>"},{"location":"references/12-factor-app/#how-neuroglia-supports-this_1","title":"How Neuroglia Supports This","text":"<p>The framework uses Poetry and virtual environments for complete dependency isolation:</p> <pre><code># pyproject.toml - Explicit dependency declaration\n[tool.poetry.dependencies]\npython = \"^3.11\"\nfastapi = \"^0.104.0\"\nuvicorn = \"^0.24.0\"\npydantic = \"^2.4.0\"\nmotor = \"^3.3.0\"\n\n[tool.poetry.group.dev.dependencies]\npytest = \"^7.4.0\"\npytest-asyncio = \"^0.21.0\"\n</code></pre> <p>Dependency Injection Container ensures services are properly declared:</p> <pre><code>from neuroglia.dependency_injection import ServiceLifetime\n\ndef configure_services(services):\n    # Explicit service dependencies\n    services.add_singleton(OrderService)\n    services.add_scoped(PizzaRepository, MongoDbPizzaRepository)\n    services.add_transient(EmailService, SmtpEmailService)\n\n    # Framework handles dependency resolution\n    services.add_mediator()\n</code></pre> <p>No System Dependencies - Everything runs in isolated containers:</p> <pre><code># Dockerfile - Isolated environment\nFROM python:3.11-slim\nWORKDIR /app\nCOPY pyproject.toml poetry.lock ./\nRUN pip install poetry &amp;&amp; poetry install --no-dev\nCOPY src/ ./src/\nCMD [\"poetry\", \"run\", \"python\", \"main.py\"]\n</code></pre>"},{"location":"references/12-factor-app/#iii-config","title":"III. Config \u2699\ufe0f","text":"<p>Principle: Store config in the environment</p>"},{"location":"references/12-factor-app/#requirements_2","title":"Requirements","text":"<ul> <li>Configuration in environment variables</li> <li>Strict separation of config from code</li> <li>No passwords or API keys in code</li> </ul>"},{"location":"references/12-factor-app/#how-neuroglia-supports-this_2","title":"How Neuroglia Supports This","text":"<p>Environment-Based Configuration:</p> <pre><code>import os\nfrom pydantic import BaseSettings\n\nclass AppSettings(BaseSettings):\n    # Database configuration\n    mongodb_connection_string: str\n    database_name: str = \"marios_pizzeria\"\n\n    # External service configuration\n    payment_api_key: str\n    email_smtp_host: str\n    email_smtp_port: int = 587\n\n    # Application configuration\n    jwt_secret_key: str\n    log_level: str = \"INFO\"\n\n    class Config:\n        env_file = \".env\"\n        env_file_encoding = \"utf-8\"\n\n# Usage in application\nsettings = AppSettings()\n\nservices.add_singleton(AppSettings, lambda _: settings)\n</code></pre> <p>Environment-Specific Deployment:</p> <pre><code># Development environment\nexport MONGODB_CONNECTION_STRING=\"mongodb://localhost:27017\"\nexport PAYMENT_API_KEY=\"test_key_123\"\nexport JWT_SECRET_KEY=\"dev-secret\"\n\n# Production environment\nexport MONGODB_CONNECTION_STRING=\"mongodb://prod-cluster:27017/marios\"\nexport PAYMENT_API_KEY=\"pk_live_abc123\"\nexport JWT_SECRET_KEY=\"$(openssl rand -base64 32)\"\n</code></pre> <p>Configuration Injection:</p> <pre><code>class OrderController(ControllerBase):\n    def __init__(self, service_provider: ServiceProviderBase,\n                 mapper: Mapper, mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n        # Settings injected automatically\n        self._settings = service_provider.get_service(AppSettings)\n\n    @post(\"/orders\")\n    async def create_order(self, order_dto: CreateOrderDto):\n        # Use configuration without hardcoding\n        if self._settings.payment_api_key:\n            # Process payment\n            pass\n</code></pre>"},{"location":"references/12-factor-app/#iv-backing-services","title":"IV. Backing Services \ud83d\udd0c","text":"<p>Principle: Treat backing services as attached resources</p>"},{"location":"references/12-factor-app/#requirements_3","title":"Requirements","text":"<ul> <li>Database, message queues, caches as attached resources</li> <li>No distinction between local and third-party services</li> <li>Services attachable via configuration</li> </ul>"},{"location":"references/12-factor-app/#how-neuroglia-supports-this_3","title":"How Neuroglia Supports This","text":"<p>Repository Pattern abstracts backing services:</p> <pre><code># Abstract repository - same interface for all backing services\nfrom abc import ABC, abstractmethod\n\nclass PizzaRepository(ABC):\n    @abstractmethod\n    async def save_async(self, pizza: Pizza) -&gt; None:\n        pass\n\n    @abstractmethod\n    async def get_by_id_async(self, pizza_id: str) -&gt; Optional[Pizza]:\n        pass\n\n# MongoDB implementation\nclass MongoDbPizzaRepository(PizzaRepository):\n    def __init__(self, connection_string: str):\n        self._client = AsyncIOMotorClient(connection_string)\n\n    async def save_async(self, pizza: Pizza) -&gt; None:\n        await self._collection.insert_one(pizza.to_dict())\n\n# In-memory implementation (for testing)\nclass InMemoryPizzaRepository(PizzaRepository):\n    def __init__(self):\n        self._store = {}\n\n    async def save_async(self, pizza: Pizza) -&gt; None:\n        self._store[pizza.id] = pizza\n</code></pre> <p>Service Registration based on environment:</p> <pre><code>def configure_backing_services(services, settings: AppSettings):\n    # Database service - swappable via config\n    if settings.environment == \"production\":\n        services.add_scoped(PizzaRepository,\n            lambda sp: MongoDbPizzaRepository(settings.mongodb_connection_string))\n    else:\n        services.add_scoped(PizzaRepository, InMemoryPizzaRepository)\n\n    # Cache service - Redis in prod, memory in dev\n    if settings.redis_url:\n        services.add_singleton(CacheService,\n            lambda sp: RedisCacheService(settings.redis_url))\n    else:\n        services.add_singleton(CacheService, InMemoryCacheService)\n\n    # Message queue - RabbitMQ in prod, in-memory in dev\n    if settings.rabbitmq_url:\n        services.add_scoped(EventBus,\n            lambda sp: RabbitMqEventBus(settings.rabbitmq_url))\n    else:\n        services.add_scoped(EventBus, InMemoryEventBus)\n</code></pre> <p>Service Abstraction through dependency injection:</p> <pre><code>class ProcessOrderHandler(CommandHandler[ProcessOrderCommand, OperationResult]):\n    def __init__(self, pizza_repository: PizzaRepository,\n                 cache_service: CacheService,\n                 event_bus: EventBus):\n        # Handler doesn't know which implementations it's using\n        self._pizza_repository = pizza_repository\n        self._cache_service = cache_service\n        self._event_bus = event_bus\n\n    async def handle_async(self, command: ProcessOrderCommand):\n        # Same code works with any backing service implementation\n        pizza = await self._pizza_repository.get_by_id_async(command.pizza_id)\n        await self._cache_service.set_async(f\"order:{command.order_id}\", pizza)\n        await self._event_bus.publish_async(OrderProcessedEvent(command.order_id))\n</code></pre>"},{"location":"references/12-factor-app/#v-build-release-run","title":"V. Build, Release, Run \ud83d\ude80","text":"<p>Principle: Strictly separate build and run stages</p>"},{"location":"references/12-factor-app/#requirements_4","title":"Requirements","text":"<ul> <li>Build stage: convert code into executable bundle</li> <li>Release stage: combine build with configuration</li> <li>Run stage: execute the release in runtime environment</li> </ul>"},{"location":"references/12-factor-app/#how-neuroglia-supports-this_4","title":"How Neuroglia Supports This","text":"<p>Build Stage - Create deployable artifacts:</p> <pre><code>#!/bin/bash\n# build.sh - Build stage\nset -e\n\necho \"\ud83d\udd28 Building Neuroglia application...\"\n\n# Install dependencies\npoetry install --no-dev\n\n# Run tests\npoetry run pytest\n\n# Build wheel package\npoetry build\n\necho \"\u2705 Build complete: dist/marios_pizzeria-1.0.0-py3-none-any.whl\"\n</code></pre> <p>Release Stage - Combine build with configuration:</p> <pre><code># release.py - Release stage\nimport os\nimport shutil\nfrom pathlib import Path\n\ndef create_release(build_artifact: str, environment: str, version: str):\n    release_dir = Path(f\"releases/{version}-{environment}\")\n    release_dir.mkdir(parents=True, exist_ok=True)\n\n    # Copy build artifact\n    shutil.copy(build_artifact, release_dir / \"app.whl\")\n\n    # Copy environment-specific configuration\n    env_config = Path(f\"deployment/{environment}\")\n    shutil.copytree(env_config, release_dir / \"config\")\n\n    # Create release manifest\n    manifest = {\n        \"version\": version,\n        \"environment\": environment,\n        \"build_artifact\": \"app.whl\",\n        \"configuration\": \"config/\",\n        \"created_at\": datetime.utcnow().isoformat()\n    }\n\n    with open(release_dir / \"manifest.json\", \"w\") as f:\n        json.dump(manifest, f, indent=2)\n\n    return release_dir\n</code></pre> <p>Run Stage - Execute specific release:</p> <pre><code># run.py - Run stage\ndef run_release(release_path: Path):\n    # Load release manifest\n    with open(release_path / \"manifest.json\") as f:\n        manifest = json.load(f)\n\n    # Set environment from release configuration\n    config_dir = release_path / manifest[\"configuration\"]\n    load_environment_from_config(config_dir)\n\n    # Install and run the exact build artifact\n    app_wheel = release_path / manifest[\"build_artifact\"]\n    subprocess.run([\"pip\", \"install\", str(app_wheel)])\n\n    # Start the application\n    from marios_pizzeria.main import create_app\n    app = create_app()\n    app.run()\n</code></pre> <p>Docker Integration for immutable releases:</p> <pre><code># Multi-stage build\nFROM python:3.11-slim as builder\nWORKDIR /build\nCOPY pyproject.toml poetry.lock ./\nRUN pip install poetry &amp;&amp; poetry install --no-dev\nCOPY src/ ./src/\nRUN poetry build\n\nFROM python:3.11-slim as runtime\nWORKDIR /app\n# Copy only the build artifact\nCOPY --from=builder /build/dist/*.whl ./\nRUN pip install *.whl\n# Configuration comes from environment\nCMD [\"python\", \"-m\", \"marios_pizzeria\"]\n</code></pre>"},{"location":"references/12-factor-app/#vi-processes","title":"VI. Processes \ud83d\udd04","text":"<p>Principle: Execute the app as one or more stateless processes</p>"},{"location":"references/12-factor-app/#requirements_5","title":"Requirements","text":"<ul> <li>Processes are stateless and share-nothing</li> <li>Persistent data stored in backing services</li> <li>No sticky sessions or in-process caching</li> </ul>"},{"location":"references/12-factor-app/#how-neuroglia-supports-this_5","title":"How Neuroglia Supports This","text":"<p>Stateless Design through dependency injection:</p> <pre><code>class PizzaController(ControllerBase):\n    def __init__(self, service_provider: ServiceProviderBase,\n                 mapper: Mapper, mediator: Mediator):\n        # Controller has no instance state\n        super().__init__(service_provider, mapper, mediator)\n\n    @get(\"/pizzas/{pizza_id}\")\n    async def get_pizza(self, pizza_id: str) -&gt; PizzaDto:\n        # All state comes from request and backing services\n        query = GetPizzaByIdQuery(pizza_id=pizza_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre> <p>Repository Pattern for persistent data:</p> <pre><code>class GetPizzaByIdHandler(QueryHandler[GetPizzaByIdQuery, PizzaDto]):\n    def __init__(self, pizza_repository: PizzaRepository, mapper: Mapper):\n        self._pizza_repository = pizza_repository  # Stateless service\n        self._mapper = mapper\n\n    async def handle_async(self, query: GetPizzaByIdQuery) -&gt; PizzaDto:\n        # No process state - all data from backing service\n        pizza = await self._pizza_repository.get_by_id_async(query.pizza_id)\n        if pizza is None:\n            raise NotFoundException(f\"Pizza {query.pizza_id} not found\")\n\n        return self._mapper.map(pizza, PizzaDto)\n</code></pre> <p>Process Scaling configuration:</p> <pre><code># docker-compose.yml - Horizontal scaling\nversion: \"3.8\"\nservices:\n  web:\n    image: marios-pizzeria:latest\n    ports:\n      - \"8000-8003:8000\" # Multiple process instances\n    environment:\n      - MONGODB_CONNECTION_STRING=${MONGODB_URL}\n      - REDIS_URL=${REDIS_URL}\n    deploy:\n      replicas: 4 # 4 stateless processes\n\n  nginx:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n    depends_on:\n      - web\n    # Load balancer - no session affinity needed\n</code></pre> <p>Session State externalization:</p> <pre><code>class SessionService:\n    def __init__(self, cache_service: CacheService):\n        self._cache = cache_service  # External session store\n\n    async def get_user_session(self, session_id: str) -&gt; Optional[UserSession]:\n        # Session stored in external cache, not process memory\n        return await self._cache.get_async(f\"session:{session_id}\")\n\n    async def save_user_session(self, session: UserSession) -&gt; None:\n        await self._cache.set_async(\n            f\"session:{session.id}\",\n            session,\n            ttl=timedelta(hours=24)\n        )\n</code></pre>"},{"location":"references/12-factor-app/#vii-port-binding","title":"VII. Port Binding \ud83c\udf10","text":"<p>Principle: Export services via port binding</p>"},{"location":"references/12-factor-app/#requirements_6","title":"Requirements","text":"<ul> <li>App is self-contained and exports HTTP via port binding</li> <li>No reliance on runtime injection by webserver</li> <li>One app can become backing service for another</li> </ul>"},{"location":"references/12-factor-app/#how-neuroglia-supports-this_6","title":"How Neuroglia Supports This","text":"<p>Self-Contained HTTP Server:</p> <pre><code># main.py - Self-contained application\nfrom neuroglia.hosting.web import WebApplicationBuilder\nimport uvicorn\n\ndef create_app():\n    builder = WebApplicationBuilder()\n\n    # Configure services\n    services = builder.services\n    services.add_controllers([\"api.controllers\"])\n    services.add_mediator()\n\n    # Build FastAPI application\n    app = builder.build()\n    app.use_controllers()\n\n    return app\n\nif __name__ == \"__main__\":\n    app = create_app()\n\n    # Self-contained HTTP server via port binding\n    port = int(os.environ.get(\"PORT\", 8000))\n    uvicorn.run(app, host=\"0.0.0.0\", port=port)\n</code></pre> <p>Port Configuration via environment:</p> <pre><code>class ServerSettings(BaseSettings):\n    port: int = 8000\n    host: str = \"0.0.0.0\"\n    workers: int = 1\n\n    class Config:\n        env_prefix = \"SERVER_\"\n\ndef run_server():\n    settings = ServerSettings()\n    app = create_app()\n\n    uvicorn.run(\n        app,\n        host=settings.host,\n        port=settings.port,\n        workers=settings.workers\n    )\n</code></pre> <p>Service-to-Service Communication:</p> <pre><code># Pizza service exports HTTP interface\nclass PizzaServiceClient:\n    def __init__(self, base_url: str):\n        self._base_url = base_url  # Port-bound service URL\n        self._client = httpx.AsyncClient()\n\n    async def get_pizza_async(self, pizza_id: str) -&gt; PizzaDto:\n        # Call another 12-factor app via its port binding\n        response = await self._client.get(f\"{self._base_url}/pizzas/{pizza_id}\")\n        return PizzaDto.model_validate(response.json())\n\n# Order service uses Pizza service as backing service\nclass OrderService:\n    def __init__(self, pizza_service: PizzaServiceClient):\n        self._pizza_service = pizza_service\n\n    async def create_order_async(self, order: CreateOrderRequest) -&gt; Order:\n        # Verify pizza exists via HTTP call\n        pizza = await self._pizza_service.get_pizza_async(order.pizza_id)\n        # Create order...\n</code></pre> <p>Docker Port Mapping:</p> <pre><code># Dockerfile - Port binding configuration\nFROM python:3.11-slim\nWORKDIR /app\nCOPY . .\nRUN pip install -r requirements.txt\n\n# Expose port for binding\nEXPOSE 8000\n\n# Run self-contained server\nCMD [\"python\", \"main.py\"]\n</code></pre>"},{"location":"references/12-factor-app/#viii-concurrency","title":"VIII. Concurrency \ud83d\udd00","text":"<p>Principle: Scale out via the process model</p>"},{"location":"references/12-factor-app/#requirements_7","title":"Requirements","text":"<ul> <li>Scale horizontally by adding more processes</li> <li>Different process types for different work</li> <li>Processes handle their own internal multiplexing</li> </ul>"},{"location":"references/12-factor-app/#how-neuroglia-supports-this_7","title":"How Neuroglia Supports This","text":"<p>Process Types definition:</p> <pre><code># Different process types for different workloads\n# web.py - HTTP request handler processes\ndef create_web_app():\n    builder = WebApplicationBuilder()\n    services = builder.services\n    services.add_controllers([\"api.controllers\"])\n    return builder.build()\n\n# worker.py - Background task processes\ndef create_worker_app():\n    builder = WebApplicationBuilder()\n    services = builder.services\n    services.add_event_handlers([\"application.handlers\"])\n    services.add_background_tasks()\n    return builder.build()\n\n# scheduler.py - Periodic task processes\ndef create_scheduler_app():\n    builder = WebApplicationBuilder()\n    services = builder.services\n    services.add_scheduled_tasks()\n    return builder.build()\n</code></pre> <p>Process Scaling configuration:</p> <pre><code># Procfile - Process type definitions\nweb: python web.py\nworker: python worker.py\nscheduler: python scheduler.py\n</code></pre> <p>Horizontal Scaling with different process counts:</p> <pre><code># docker-compose.yml\nversion: \"3.8\"\nservices:\n  web:\n    image: marios-pizzeria:latest\n    command: python web.py\n    ports:\n      - \"8000-8003:8000\"\n    deploy:\n      replicas: 4 # 4 web processes\n\n  worker:\n    image: marios-pizzeria:latest\n    command: python worker.py\n    deploy:\n      replicas: 2 # 2 worker processes\n\n  scheduler:\n    image: marios-pizzeria:latest\n    command: python scheduler.py\n    deploy:\n      replicas: 1 # 1 scheduler process\n</code></pre> <p>Internal Multiplexing with async/await:</p> <pre><code>class OrderController(ControllerBase):\n    @post(\"/orders\")\n    async def create_order(self, order_dto: CreateOrderDto):\n        # Single process handles multiple concurrent requests\n        # via async/await internal multiplexing\n        command = self.mapper.map(order_dto, CreateOrderCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\nclass BackgroundTaskService(HostedService):\n    async def start_async(self, cancellation_token):\n        # Single worker process handles multiple tasks concurrently\n        tasks = [\n            self.process_emails(),\n            self.process_notifications(),\n            self.process_analytics()\n        ]\n        await asyncio.gather(*tasks)\n\n    async def process_emails(self):\n        while True:\n            # Internal multiplexing within single process\n            async for email in self.email_queue:\n                await self.send_email(email)\n</code></pre> <p>Process Management with supervision:</p> <pre><code># supervisor.conf - Process supervision\n[program:marios-web]\ncommand=python web.py\nnumprocs=4\nautostart=true\nautorestart=true\n\n[program:marios-worker]\ncommand=python worker.py\nnumprocs=2\nautostart=true\nautorestart=true\n</code></pre>"},{"location":"references/12-factor-app/#ix-disposability","title":"IX. Disposability \u267b\ufe0f","text":"<p>Principle: Maximize robustness with fast startup and graceful shutdown</p>"},{"location":"references/12-factor-app/#requirements_8","title":"Requirements","text":"<ul> <li>Fast startup for elastic scaling</li> <li>Graceful shutdown on SIGTERM</li> <li>Robust against sudden termination</li> </ul>"},{"location":"references/12-factor-app/#how-neuroglia-supports-this_8","title":"How Neuroglia Supports This","text":"<p>Fast Startup through optimized initialization:</p> <pre><code>class WebApplicationBuilder:\n    def build(self) -&gt; FastAPI:\n        app = FastAPI(\n            title=\"Mario's Pizzeria API\",\n            # Fast startup - minimal initialization\n            docs_url=\"/docs\" if self._is_development else None,\n            redoc_url=\"/redoc\" if self._is_development else None\n        )\n\n        # Lazy service initialization\n        app.state.service_provider = LazyServiceProvider(self._services)\n\n        # Fast health check endpoint\n        @app.get(\"/health\")\n        async def health_check():\n            return {\"status\": \"healthy\", \"timestamp\": datetime.utcnow()}\n\n        return app\n\ndef create_app():\n    # Optimized for fast startup\n    builder = WebApplicationBuilder()\n\n    # Register services (no initialization yet)\n    builder.services.add_controllers([\"api.controllers\"])\n    builder.services.add_mediator()\n\n    # Build returns immediately\n    return builder.build()\n</code></pre> <p>Graceful Shutdown handling:</p> <pre><code>import signal\nimport asyncio\nfrom contextlib import asynccontextmanager\n\nclass GracefulShutdownHandler:\n    def __init__(self, app: FastAPI):\n        self._app = app\n        self._shutdown_event = asyncio.Event()\n        self._background_tasks = set()\n\n    def setup_signal_handlers(self):\n        # Handle SIGTERM gracefully\n        signal.signal(signal.SIGTERM, self._signal_handler)\n        signal.signal(signal.SIGINT, self._signal_handler)\n\n    def _signal_handler(self, signum, frame):\n        print(f\"Received signal {signum}, initiating graceful shutdown...\")\n        asyncio.create_task(self._graceful_shutdown())\n\n    async def _graceful_shutdown(self):\n        # Stop accepting new requests\n        self._app.state.accepting_requests = False\n\n        # Wait for current requests to complete (max 30 seconds)\n        try:\n            await asyncio.wait_for(\n                self._wait_for_requests_to_complete(),\n                timeout=30.0\n            )\n        except asyncio.TimeoutError:\n            print(\"Timeout waiting for requests to complete\")\n\n        # Cancel background tasks\n        for task in self._background_tasks:\n            task.cancel()\n\n        # Close connections\n        if hasattr(self._app.state, 'database'):\n            await self._app.state.database.close()\n\n        self._shutdown_event.set()\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Startup\n    shutdown_handler = GracefulShutdownHandler(app)\n    shutdown_handler.setup_signal_handlers()\n\n    yield\n\n    # Shutdown\n    await shutdown_handler._shutdown_event.wait()\n\ndef create_app():\n    return FastAPI(lifespan=lifespan)\n</code></pre> <p>Background Task Resilience:</p> <pre><code>class BackgroundTaskService(HostedService):\n    async def start_async(self, cancellation_token):\n        while not cancellation_token.is_cancelled:\n            try:\n                # Process work with checkpoints\n                async for work_item in self.get_work_items():\n                    if cancellation_token.is_cancelled:\n                        # Return work to queue on shutdown\n                        await self.return_to_queue(work_item)\n                        break\n\n                    await self.process_work_item(work_item)\n\n            except Exception as ex:\n                # Log error but continue running\n                self._logger.error(f\"Background task error: {ex}\")\n                await asyncio.sleep(5)  # Brief pause before retry\n\nclass OrderProcessingService:\n    async def process_order(self, order_id: str):\n        # Idempotent processing - safe to retry\n        order = await self._repository.get_by_id_async(order_id)\n        if order.status == OrderStatus.COMPLETED:\n            return  # Already processed\n\n        # Process with database transaction\n        async with self._repository.begin_transaction():\n            order.status = OrderStatus.PROCESSING\n            await self._repository.save_async(order)\n\n            # Do work...\n\n            order.status = OrderStatus.COMPLETED\n            await self._repository.save_async(order)\n</code></pre> <p>Container Health Checks:</p> <pre><code># Dockerfile with health check\nFROM python:3.11-slim\nWORKDIR /app\nCOPY . .\nRUN pip install -r requirements.txt\n\n# Health check for fast failure detection\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n    CMD curl -f http://localhost:8000/health || exit 1\n\nCMD [\"python\", \"main.py\"]\n</code></pre>"},{"location":"references/12-factor-app/#x-devprod-parity","title":"X. Dev/Prod Parity \ud83d\udd04","text":"<p>Principle: Keep development, staging, and production as similar as possible</p>"},{"location":"references/12-factor-app/#requirements_9","title":"Requirements","text":"<ul> <li>Minimize time gap between development and production</li> <li>Same people involved in development and deployment</li> <li>Use same backing services in all environments</li> </ul>"},{"location":"references/12-factor-app/#how-neuroglia-supports-this_9","title":"How Neuroglia Supports This","text":"<p>Same Backing Services across environments:</p> <pre><code># Use same service types everywhere\nclass DatabaseSettings(BaseSettings):\n    connection_string: str\n    database_name: str\n\n    @property\n    def is_mongodb(self) -&gt; bool:\n        return self.connection_string.startswith(\"mongodb://\")\n\ndef configure_database(services, settings: DatabaseSettings):\n    if settings.is_mongodb:\n        # MongoDB in all environments (dev uses local, prod uses cluster)\n        services.add_scoped(\n            PizzaRepository,\n            lambda sp: MongoDbPizzaRepository(settings.connection_string)\n        )\n    else:\n        # Don't use SQLite in dev and PostgreSQL in prod\n        # Use PostgreSQL everywhere via Docker\n        services.add_scoped(\n            PizzaRepository,\n            lambda sp: PostgreSQLPizzaRepository(settings.connection_string)\n        )\n</code></pre> <p>Docker Development Environment:</p> <pre><code># docker-compose.dev.yml - Same services as production\nversion: \"3.8\"\nservices:\n  app:\n    build: .\n    ports:\n      - \"8000:8000\"\n    environment:\n      - ENVIRONMENT=development\n      - MONGODB_CONNECTION_STRING=mongodb://mongo:27017/marios_dev\n      - REDIS_URL=redis://redis:6379\n    depends_on:\n      - mongo\n      - redis\n\n  mongo:\n    image: mongo:7.0 # Same version as production\n    ports:\n      - \"27017:27017\"\n\n  redis:\n    image: redis:7.2 # Same version as production\n    ports:\n      - \"6379:6379\"\n</code></pre> <p>Environment Parity Validation:</p> <pre><code>class EnvironmentValidator:\n    def __init__(self, settings: AppSettings):\n        self._settings = settings\n\n    def validate_parity(self):\n        \"\"\"Ensure dev/staging/prod use compatible services\"\"\"\n        warnings = []\n\n        # Check database compatibility\n        if self._settings.environment == \"development\":\n            if \"sqlite\" in self._settings.mongodb_connection_string.lower():\n                warnings.append(\n                    \"Development uses SQLite but production uses MongoDB. \"\n                    \"Use MongoDB in development for better parity.\"\n                )\n\n        # Check cache compatibility\n        if not self._settings.redis_url and self._settings.environment != \"test\":\n            warnings.append(\n                \"No Redis configuration found. \"\n                \"Use Redis in all environments for dev/prod parity.\"\n            )\n\n        return warnings\n\n# Application startup validation\ndef create_app():\n    settings = AppSettings()\n    validator = EnvironmentValidator(settings)\n\n    parity_warnings = validator.validate_parity()\n    if parity_warnings:\n        for warning in parity_warnings:\n            logger.warning(f\"Dev/Prod Parity: {warning}\")\n\n    builder = WebApplicationBuilder()\n    # ... configure app\n    return builder.build()\n</code></pre> <p>Continuous Deployment Pipeline:</p> <pre><code># .github/workflows/deploy.yml\nname: Deploy\non:\n  push:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    services:\n      mongo:\n        image: mongo:7.0\n      redis:\n        image: redis:7.2\n    steps:\n      - uses: actions/checkout@v3\n      - name: Run tests against production-like services\n        run: |\n          export MONGODB_CONNECTION_STRING=mongodb://mongo:27017/test\n          export REDIS_URL=redis://redis:6379\n          poetry run pytest\n\n  deploy-staging:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n      - name: Deploy to staging\n        run: |\n          # Same deployment process as production\n          docker build -t marios-pizzeria:${{ github.sha }} .\n          docker push registry/marios-pizzeria:${{ github.sha }}\n          kubectl set image deployment/app app=registry/marios-pizzeria:${{ github.sha }}\n\n  deploy-production:\n    needs: deploy-staging\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'\n    steps:\n      - name: Deploy to production\n        run: |\n          # Identical process to staging\n          kubectl set image deployment/app app=registry/marios-pizzeria:${{ github.sha }}\n</code></pre>"},{"location":"references/12-factor-app/#xi-logs","title":"XI. Logs \ud83d\udcca","text":"<p>Principle: Treat logs as event streams</p>"},{"location":"references/12-factor-app/#requirements_10","title":"Requirements","text":"<ul> <li>Write unbuffered logs to stdout</li> <li>No log file management by the application</li> <li>Log aggregation handled by execution environment</li> </ul>"},{"location":"references/12-factor-app/#how-neuroglia-supports-this_10","title":"How Neuroglia Supports This","text":"<p>Structured Logging to stdout:</p> <pre><code>import structlog\nimport sys\n\n# Configure structured logging\nstructlog.configure(\n    processors=[\n        structlog.stdlib.filter_by_level,\n        structlog.stdlib.add_logger_name,\n        structlog.stdlib.add_log_level,\n        structlog.stdlib.PositionalArgumentsFormatter(),\n        structlog.processors.TimeStamper(fmt=\"iso\"),\n        structlog.processors.StackInfoRenderer(),\n        structlog.processors.format_exc_info,\n        structlog.processors.UnicodeDecoder(),\n        structlog.processors.JSONRenderer()  # JSON for structured logs\n    ],\n    context_class=dict,\n    logger_factory=structlog.stdlib.LoggerFactory(),\n    wrapper_class=structlog.stdlib.BoundLogger,\n    cache_logger_on_first_use=True,\n)\n\n# Application logger - writes to stdout only\nlogger = structlog.get_logger()\n\nclass OrderController(ControllerBase):\n    @post(\"/orders\")\n    async def create_order(self, order_dto: CreateOrderDto):\n        # Structured logging with context\n        logger.info(\n            \"Order creation started\",\n            customer_id=order_dto.customer_id,\n            pizza_count=len(order_dto.pizzas),\n            total_amount=order_dto.total_amount,\n            correlation_id=self.get_correlation_id()\n        )\n\n        try:\n            command = self.mapper.map(order_dto, CreateOrderCommand)\n            result = await self.mediator.execute_async(command)\n\n            logger.info(\n                \"Order created successfully\",\n                order_id=result.value.id,\n                correlation_id=self.get_correlation_id()\n            )\n\n            return self.process(result)\n\n        except Exception as ex:\n            logger.error(\n                \"Order creation failed\",\n                error=str(ex),\n                error_type=type(ex).__name__,\n                correlation_id=self.get_correlation_id()\n            )\n            raise\n</code></pre> <p>Request/Response Logging Middleware:</p> <pre><code>import time\nfrom fastapi import Request, Response\n\nclass LoggingMiddleware:\n    def __init__(self, app):\n        self.app = app\n\n    async def __call__(self, scope, receive, send):\n        if scope[\"type\"] != \"http\":\n            await self.app(scope, receive, send)\n            return\n\n        request = Request(scope, receive)\n        start_time = time.time()\n\n        # Log request\n        logger.info(\n            \"HTTP request started\",\n            method=request.method,\n            path=request.url.path,\n            query_params=str(request.query_params),\n            user_agent=request.headers.get(\"user-agent\"),\n            client_ip=request.client.host if request.client else None\n        )\n\n        async def send_wrapper(message):\n            if message[\"type\"] == \"http.response.start\":\n                # Log response\n                duration = time.time() - start_time\n                logger.info(\n                    \"HTTP request completed\",\n                    method=request.method,\n                    path=request.url.path,\n                    status_code=message[\"status\"],\n                    duration_ms=round(duration * 1000, 2)\n                )\n            await send(message)\n\n        await self.app(scope, receive, send_wrapper)\n\n# Add middleware to application\ndef create_app():\n    builder = WebApplicationBuilder()\n    app = builder.build()\n\n    # Add logging middleware\n    app.add_middleware(LoggingMiddleware)\n\n    return app\n</code></pre> <p>No Log File Management:</p> <pre><code># main.py - No log files, only stdout\nimport logging\nimport sys\n\ndef configure_logging():\n    # Only configure stdout handler\n    root_logger = logging.getLogger()\n\n    # Remove any existing handlers\n    root_logger.handlers.clear()\n\n    # Add only stdout handler\n    stdout_handler = logging.StreamHandler(sys.stdout)\n    stdout_handler.setFormatter(\n        logging.Formatter(\n            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n        )\n    )\n\n    root_logger.addHandler(stdout_handler)\n    root_logger.setLevel(logging.INFO)\n\nif __name__ == \"__main__\":\n    configure_logging()  # No file handlers\n    app = create_app()\n\n    # Application logs go to stdout, captured by container runtime\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000, log_config=None)\n</code></pre> <p>Log Aggregation via deployment environment:</p> <pre><code># kubernetes deployment with log aggregation\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: marios-pizzeria\nspec:\n  template:\n    spec:\n      containers:\n        - name: app\n          image: marios-pizzeria:latest\n          # Logs go to stdout, captured by Kubernetes\n          env:\n            - name: LOG_LEVEL\n              value: \"INFO\"\n          # No volume mounts for log files\n---\n# Fluentd configuration for log aggregation\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: fluentd-config\ndata:\n  fluent.conf: |\n    &lt;source&gt;\n      @type tail\n      path /var/log/containers/marios-pizzeria-*.log\n      pos_file /var/log/fluentd-containers.log.pos\n      tag kubernetes.*\n      format json\n    &lt;/source&gt;\n\n    &lt;match kubernetes.**&gt;\n      @type elasticsearch\n      host elasticsearch.logging.svc.cluster.local\n      port 9200\n      index_name marios-pizzeria\n    &lt;/match&gt;\n</code></pre>"},{"location":"references/12-factor-app/#xii-admin-processes","title":"XII. Admin Processes \ud83d\udd27","text":"<p>Principle: Run admin/management tasks as one-off processes</p>"},{"location":"references/12-factor-app/#requirements_11","title":"Requirements","text":"<ul> <li>Admin tasks run in identical environment as regular processes</li> <li>Use same codebase and configuration</li> <li>Run against specific releases</li> </ul>"},{"location":"references/12-factor-app/#how-neuroglia-supports-this_11","title":"How Neuroglia Supports This","text":"<p>Admin Command Framework:</p> <pre><code># cli/admin.py - Admin process framework\nimport asyncio\nimport sys\nfrom abc import ABC, abstractmethod\nfrom neuroglia.hosting.web import WebApplicationBuilder\n\nclass AdminCommand(ABC):\n    @abstractmethod\n    async def execute_async(self, service_provider) -&gt; int:\n        \"\"\"Execute admin command, return exit code\"\"\"\n        pass\n\nclass MigrateDatabaseCommand(AdminCommand):\n    async def execute_async(self, service_provider) -&gt; int:\n        logger.info(\"Starting database migration...\")\n\n        try:\n            # Use same services as web processes\n            repository = service_provider.get_service(PizzaRepository)\n            await repository.migrate_schema_async()\n\n            logger.info(\"Database migration completed successfully\")\n            return 0\n\n        except Exception as ex:\n            logger.error(f\"Database migration failed: {ex}\")\n            return 1\n\nclass SeedDataCommand(AdminCommand):\n    async def execute_async(self, service_provider) -&gt; int:\n        logger.info(\"Seeding initial data...\")\n\n        try:\n            # Use same repositories as application\n            pizza_repo = service_provider.get_service(PizzaRepository)\n\n            # Create default pizzas\n            default_pizzas = [\n                Pizza(\"margherita\", \"Margherita\", 12.99),\n                Pizza(\"pepperoni\", \"Pepperoni\", 14.99),\n                Pizza(\"hawaiian\", \"Hawaiian\", 15.99)\n            ]\n\n            for pizza in default_pizzas:\n                await pizza_repo.save_async(pizza)\n\n            logger.info(f\"Seeded {len(default_pizzas)} default pizzas\")\n            return 0\n\n        except Exception as ex:\n            logger.error(f\"Data seeding failed: {ex}\")\n            return 1\n\n# Admin process runner\nasync def run_admin_command(command_name: str) -&gt; int:\n    # Create same application context as web processes\n    builder = WebApplicationBuilder()\n\n    # Same service configuration as main application\n    builder.services.add_scoped(PizzaRepository, MongoDbPizzaRepository)\n    builder.services.add_mediator()\n\n    service_provider = builder.services.build_provider()\n\n    # Map commands\n    commands = {\n        \"migrate\": MigrateDatabaseCommand(),\n        \"seed\": SeedDataCommand(),\n    }\n\n    if command_name not in commands:\n        logger.error(f\"Unknown command: {command_name}\")\n        return 1\n\n    # Execute command with same environment\n    return await commands[command_name].execute_async(service_provider)\n\nif __name__ == \"__main__\":\n    if len(sys.argv) != 2:\n        print(\"Usage: python admin.py &lt;command&gt;\")\n        sys.exit(1)\n\n    command = sys.argv[1]\n    exit_code = asyncio.run(run_admin_command(command))\n    sys.exit(exit_code)\n</code></pre> <p>Container-Based Admin Tasks:</p> <pre><code># Same image for web and admin processes\nFROM python:3.11-slim\nWORKDIR /app\nCOPY . .\nRUN pip install -r requirements.txt\n\n# Default command is web process\nCMD [\"python\", \"main.py\"]\n\n# Admin processes use same image with different command\n# docker run marios-pizzeria:latest python admin.py migrate\n# docker run marios-pizzeria:latest python admin.py seed\n</code></pre> <p>Kubernetes Jobs for admin processes:</p> <pre><code># Database migration job\napiVersion: batch/v1\nkind: Job\nmetadata:\n  name: marios-pizzeria-migrate\nspec:\n  template:\n    spec:\n      containers:\n        - name: migrate\n          image: marios-pizzeria:v1.2.3 # Same image as web deployment\n          command: [\"python\", \"admin.py\", \"migrate\"]\n          env:\n            # Same environment as web processes\n            - name: MONGODB_CONNECTION_STRING\n              valueFrom:\n                secretKeyRef:\n                  name: database-secret\n                  key: connection-string\n            - name: ENVIRONMENT\n              value: \"production\"\n      restartPolicy: OnFailure\n---\n# Data seeding job\napiVersion: batch/v1\nkind: Job\nmetadata:\n  name: marios-pizzeria-seed\nspec:\n  template:\n    spec:\n      containers:\n        - name: seed\n          image: marios-pizzeria:v1.2.3 # Exact same release\n          command: [\"python\", \"admin.py\", \"seed\"]\n          env:\n            # Identical configuration\n            - name: MONGODB_CONNECTION_STRING\n              valueFrom:\n                secretKeyRef:\n                  name: database-secret\n                  key: connection-string\n      restartPolicy: OnFailure\n</code></pre> <p>Production Admin Process Examples:</p> <pre><code># Run admin processes in production using same deployment\n# Database migration before release\nkubectl create job --from=deployment/marios-pizzeria migrate-v1-2-3 \\\n  --dry-run=client -o yaml | \\\n  sed 's/app/migrate/' | \\\n  sed 's/main.py/admin.py migrate/' | \\\n  kubectl apply -f -\n\n# One-off data fix\nkubectl run data-fix --image=marios-pizzeria:v1.2.3 \\\n  --env=\"MONGODB_CONNECTION_STRING=$PROD_DB\" \\\n  --restart=Never \\\n  --rm -it -- python admin.py fix-corrupted-orders\n\n# Interactive shell for debugging\nkubectl run debug-shell --image=marios-pizzeria:v1.2.3 \\\n  --env=\"MONGODB_CONNECTION_STRING=$PROD_DB\" \\\n  --restart=Never \\\n  --rm -it -- python -c \"\nfrom main import create_app\napp = create_app()\n# Interactive Python shell with full application context\nimport IPython; IPython.embed()\n\"\n</code></pre>"},{"location":"references/12-factor-app/#summary","title":"\ud83c\udfaf Summary","text":"<p>The Neuroglia framework was designed from the ground up to support the Twelve-Factor App methodology. Here's how each principle is addressed:</p> Factor Neuroglia Support I. Codebase Modular architecture with clean separation, single codebase for multiple deployments II. Dependencies Poetry dependency management, dependency injection container, Docker isolation III. Config Pydantic settings with environment variables, no hardcoded configuration IV. Backing Services Repository pattern, service abstractions, configurable implementations V. Build/Release/Run Docker builds, immutable releases, environment-specific deployments VI. Processes Stateless controllers, repository persistence, horizontal scaling support VII. Port Binding Self-contained FastAPI server, uvicorn HTTP binding, service-to-service HTTP VIII. Concurrency Process types, async/await concurrency, container orchestration IX. Disposability Fast startup, graceful shutdown handlers, idempotent operations X. Dev/Prod Parity Docker dev environments, same backing services, continuous deployment XI. Logs Structured logging to stdout, no file management, aggregation-ready XII. Admin Processes CLI command framework, same environment as web processes, container jobs"},{"location":"references/12-factor-app/#building-12-factor-apps-with-neuroglia","title":"\ud83d\ude80 Building 12-Factor Apps with Neuroglia","text":"<p>When building applications with Neuroglia, following these patterns ensures your application is:</p> <ul> <li>Portable: Runs consistently across different environments</li> <li>Scalable: Horizontal scaling through stateless processes</li> <li>Maintainable: Clean separation of concerns and dependency management</li> <li>Observable: Comprehensive logging and health monitoring</li> <li>Resilient: Graceful handling of failures and shutdowns</li> <li>Cloud-Native: Ready for container orchestration and continuous deployment</li> </ul> <p>The framework's opinionated architecture guides you toward 12-factor compliance naturally, making it easier to build modern, cloud-native applications that follow industry best practices.</p>"},{"location":"references/12-factor-app/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Framework setup and basic usage</li> <li>Dependency Injection - Service container and lifetime management</li> <li>CQRS &amp; Mediation - Command and query patterns</li> <li>MVC Controllers - HTTP API development</li> <li>Data Access - Repository pattern and backing services</li> <li>OpenBank Sample - Complete 12-factor application example</li> </ul>"},{"location":"references/oauth-oidc-jwt/","title":"\ud83d\udd10 OAuth 2.0, OpenID Connect &amp; JWT Reference","text":"<p>This comprehensive guide covers OAuth 2.0, OpenID Connect (OIDC), and JSON Web Tokens (JWT) implementation using the Neuroglia framework, with practical examples from Mario's Pizzeria.</p> <p>Based on official IETF specifications and OpenID Foundation standards, this reference provides production-ready patterns for implementing enterprise-grade authentication and authorization.</p>"},{"location":"references/oauth-oidc-jwt/#what-is-oauth-20","title":"\ud83c\udfaf What is OAuth 2.0?","text":"<p>OAuth 2.0 (RFC 6749) is an authorization framework that enables applications to obtain limited access to user accounts. It works by delegating user authentication to an authorization server and allowing third-party applications to obtain limited access tokens instead of passwords.</p>"},{"location":"references/oauth-oidc-jwt/#key-oauth-20-concepts","title":"Key OAuth 2.0 Concepts","text":"<ul> <li>Resource Owner: The user who owns the data (pizzeria customer/staff)</li> <li>Client: The application requesting access (Mario's Pizzeria web app)</li> <li>Authorization Server: Issues access tokens (Keycloak, Auth0, etc.)</li> <li>Resource Server: Hosts protected resources (Mario's Pizzeria API)</li> <li>Access Token: Credential used to access protected resources</li> <li>Scope: Permissions granted to the client (orders:read, kitchen:manage)</li> </ul>"},{"location":"references/oauth-oidc-jwt/#what-is-openid-connect-oidc","title":"\ud83c\udd94 What is OpenID Connect (OIDC)?","text":"<p>OpenID Connect (OpenID Connect Core 1.0) is an identity layer built on top of OAuth 2.0. While OAuth 2.0 handles authorization (what you can do), OIDC adds authentication (who you are).</p>"},{"location":"references/oauth-oidc-jwt/#oidc-adds-to-oauth-20","title":"OIDC Adds to OAuth 2.0","text":"<ul> <li>ID Token: Contains user identity information (JWT format)</li> <li>UserInfo Endpoint: Provides additional user profile data</li> <li>Standardized Claims: Email, name, roles, etc.</li> <li>Discovery: Automatic configuration discovery</li> </ul>"},{"location":"references/oauth-oidc-jwt/#what-are-json-web-tokens-jwt","title":"\ud83c\udff7\ufe0f What are JSON Web Tokens (JWT)?","text":"<p>JWT (RFC 7519) is a compact, URL-safe means of representing claims between two parties. In our pizzeria context, JWTs contain user identity and permissions.</p>"},{"location":"references/oauth-oidc-jwt/#jwt-structure","title":"JWT Structure","text":"<pre><code>Header.Payload.Signature\n</code></pre> <p>Example JWT for Mario's Pizzeria:</p> <pre><code>// Header\n{\n  \"alg\": \"RS256\",\n  \"typ\": \"JWT\",\n  \"kid\": \"pizzeria-key-1\"\n}\n\n// Payload\n{\n  \"sub\": \"customer_12345\",\n  \"name\": \"Mario Rossi\",\n  \"email\": \"mario@example.com\",\n  \"roles\": [\"customer\"],\n  \"scope\": \"orders:read orders:write menu:read\",\n  \"iss\": \"https://auth.mariospizzeria.com\",\n  \"aud\": \"pizzeria-api\",\n  \"exp\": 1695734400,\n  \"iat\": 1695648000\n}\n\n// Signature (generated by authorization server)\n</code></pre>"},{"location":"references/oauth-oidc-jwt/#oauth-20-authorization-flow","title":"\ud83d\udd04 OAuth 2.0 Authorization Flow","text":"<p>Here's how a customer logs into Mario's Pizzeria:</p> <pre><code>sequenceDiagram\n    participant User as \ud83d\udc64 Customer\n    participant Client as \ud83c\udf55 Pizzeria Web App\n    participant AuthServer as \ud83d\udd10 Keycloak (Auth Server)\n    participant API as \ud83c\udf10 Pizzeria API\n\n    Note over User,API: OAuth 2.0 Authorization Code Flow\n\n    User-&gt;&gt;+Client: 1. Click \"Login\"\n    Client-&gt;&gt;+AuthServer: 2. Redirect to authorization endpoint&lt;br/&gt;?client_id=pizzeria&amp;scope=orders:read+orders:write\n    AuthServer-&gt;&gt;+User: 3. Show login form\n    User-&gt;&gt;AuthServer: 4. Enter credentials\n    AuthServer-&gt;&gt;-User: 5. Redirect with authorization code&lt;br/&gt;?code=ABC123\n\n    User-&gt;&gt;+Client: 6. Return to app with code\n    Client-&gt;&gt;+AuthServer: 7. Exchange code for tokens&lt;br/&gt;POST /token\n    AuthServer-&gt;&gt;-Client: 8. Return access_token + id_token\n\n    Note over Client,API: Making Authenticated API Calls\n\n    Client-&gt;&gt;+API: 9. GET /orders&lt;br/&gt;Authorization: Bearer &lt;access_token&gt;\n    API-&gt;&gt;API: 10. Validate JWT signature &amp; claims\n    API-&gt;&gt;-Client: 11. Return order data\n\n    Client-&gt;&gt;-User: 12. Display user's orders</code></pre>"},{"location":"references/oauth-oidc-jwt/#jwt-validation-process","title":"\ud83d\udd0d JWT Validation Process","text":"<p>When Mario's Pizzeria API receives a request, it validates the JWT:</p> <pre><code>flowchart TD\n    A[\ud83c\udf10 API Receives Request] --&gt; B{JWT Present?}\n    B --&gt;|No| C[\u274c Return 401 Unauthorized]\n    B --&gt;|Yes| D[\ud83d\udcdd Parse JWT Header/Payload]\n\n    D --&gt; E{Valid Signature?}\n    E --&gt;|No| F[\u274c Return 401 Invalid Token]\n    E --&gt;|Yes| G{Token Expired?}\n\n    G --&gt;|Yes| H[\u274c Return 401 Token Expired]\n    G --&gt;|No| I{Valid Issuer?}\n\n    I --&gt;|No| J[\u274c Return 401 Invalid Issuer]\n    I --&gt;|Yes| K{Valid Audience?}\n\n    K --&gt;|No| L[\u274c Return 401 Invalid Audience]\n    K --&gt;|Yes| M{Required Scope?}\n\n    M --&gt;|No| N[\u274c Return 403 Insufficient Scope]\n    M --&gt;|Yes| O[\u2705 Allow Request]\n\n    O --&gt; P[\ud83c\udf55 Process Business Logic]\n\n    style A fill:#E3F2FD\n    style O fill:#E8F5E8\n    style P fill:#E8F5E8\n    style C,F,H,J,L,N fill:#FFEBEE</code></pre>"},{"location":"references/oauth-oidc-jwt/#keycloak-integration-with-neuroglia-framework","title":"\ud83c\udfd7\ufe0f Keycloak Integration with Neuroglia Framework","text":"<p>Here's how to integrate Keycloak (or any OIDC provider) with Mario's Pizzeria:</p>"},{"location":"references/oauth-oidc-jwt/#1-jwt-authentication-middleware","title":"1. JWT Authentication Middleware","text":"<pre><code>from neuroglia.dependency_injection import ServiceCollection\nfrom neuroglia.mvc import ControllerBase\nfrom fastapi import HTTPException, Depends\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nimport jwt\nfrom typing import Dict, List\n\nclass JWTAuthService:\n    def __init__(self,\n                 issuer: str = \"https://keycloak.mariospizzeria.com/auth/realms/pizzeria\",\n                 audience: str = \"pizzeria-api\",\n                 jwks_url: str = \"https://keycloak.mariospizzeria.com/auth/realms/pizzeria/protocol/openid_connect/certs\"):\n        self.issuer = issuer\n        self.audience = audience\n        self.jwks_url = jwks_url\n        self._public_keys = {}\n\n    async def validate_token(self, token: str) -&gt; Dict:\n        \"\"\"Validate JWT token and return claims\"\"\"\n        try:\n            # Decode without verification first to get kid\n            unverified_header = jwt.get_unverified_header(token)\n            kid = unverified_header.get('kid')\n\n            # Get public key for signature verification\n            public_key = await self._get_public_key(kid)\n\n            # Verify and decode token\n            payload = jwt.decode(\n                token,\n                public_key,\n                algorithms=['RS256'],\n                issuer=self.issuer,\n                audience=self.audience,\n                options={\"verify_exp\": True}\n            )\n\n            return payload\n\n        except jwt.ExpiredSignatureError:\n            raise HTTPException(status_code=401, detail=\"Token has expired\")\n        except jwt.InvalidTokenError as e:\n            raise HTTPException(status_code=401, detail=f\"Invalid token: {str(e)}\")\n\n    def check_scope(self, required_scope: str, token_scopes: str) -&gt; bool:\n        \"\"\"Check if required scope is present in token scopes\"\"\"\n        scopes = token_scopes.split(' ') if token_scopes else []\n        return required_scope in scopes\n\n    async def _get_public_key(self, kid: str):\n        \"\"\"Fetch and cache public keys from JWKS endpoint\"\"\"\n        # Implementation would fetch from Keycloak JWKS endpoint\n        # and cache the public keys for signature verification\n        pass\n</code></pre>"},{"location":"references/oauth-oidc-jwt/#2-scope-based-authorization-decorators","title":"2. Scope-Based Authorization Decorators","text":"<pre><code>from functools import wraps\nfrom fastapi import HTTPException\n\ndef require_scope(required_scope: str):\n    \"\"\"Decorator to require specific OAuth scope\"\"\"\n    def decorator(func):\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            # Get current user token from dependency injection\n            auth_service = kwargs.get('auth_service')  # Injected\n            token_data = kwargs.get('current_user')    # From JWT validation\n\n            if not auth_service.check_scope(required_scope, token_data.get('scope', '')):\n                raise HTTPException(\n                    status_code=403,\n                    detail=f\"Insufficient permissions. Required scope: {required_scope}\"\n                )\n\n            return await func(*args, **kwargs)\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"references/oauth-oidc-jwt/#3-protected-controllers-with-oauth-scopes","title":"3. Protected Controllers with OAuth Scopes","text":"<pre><code>from neuroglia.mvc import ControllerBase\nfrom classy_fastapi.decorators import get, post, put, delete\nfrom fastapi import Depends\n\nclass OrdersController(ControllerBase):\n    def __init__(self,\n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator,\n                 auth_service: JWTAuthService):\n        super().__init__(service_provider, mapper, mediator)\n        self.auth_service = auth_service\n\n    @get(\"/\", response_model=List[OrderDto])\n    @require_scope(\"orders:read\")\n    async def get_orders(self,\n                        current_user: dict = Depends(get_current_user)) -&gt; List[OrderDto]:\n        \"\"\"Get orders - requires orders:read scope\"\"\"\n        # Customers see only their orders, staff see all\n        if \"customer\" in current_user.get(\"roles\", []):\n            query = GetOrdersByCustomerQuery(customer_id=current_user[\"sub\"])\n        else:\n            query = GetAllOrdersQuery()\n\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @post(\"/\", response_model=OrderDto, status_code=201)\n    @require_scope(\"orders:write\")\n    async def create_order(self,\n                          create_order_dto: CreateOrderDto,\n                          current_user: dict = Depends(get_current_user)) -&gt; OrderDto:\n        \"\"\"Create new order - requires orders:write scope\"\"\"\n        command = self.mapper.map(create_order_dto, PlaceOrderCommand)\n        command.customer_id = current_user[\"sub\"]  # From JWT\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\nclass KitchenController(ControllerBase):\n\n    @get(\"/status\", response_model=KitchenStatusDto)\n    @require_scope(\"kitchen:read\")\n    async def get_kitchen_status(self,\n                                current_user: dict = Depends(get_current_user)) -&gt; KitchenStatusDto:\n        \"\"\"Get kitchen status - requires kitchen:read scope\"\"\"\n        query = GetKitchenStatusQuery()\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @post(\"/orders/{order_id}/start\")\n    @require_scope(\"kitchen:manage\")\n    async def start_cooking_order(self,\n                                 order_id: str,\n                                 current_user: dict = Depends(get_current_user)) -&gt; OrderDto:\n        \"\"\"Start cooking order - requires kitchen:manage scope\"\"\"\n        command = StartCookingCommand(\n            order_id=order_id,\n            kitchen_staff_id=current_user[\"sub\"]\n        )\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"references/oauth-oidc-jwt/#4-user-context-and-dependency-injection","title":"4. User Context and Dependency Injection","text":"<pre><code>from fastapi import Depends\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\n\nasync def get_current_user(\n    credentials: HTTPAuthorizationCredentials = Depends(security),\n    auth_service: JWTAuthService = Depends()\n) -&gt; dict:\n    \"\"\"Extract and validate user from JWT token\"\"\"\n    token = credentials.credentials\n    user_data = await auth_service.validate_token(token)\n    return user_data\n\ndef configure_auth_services(services: ServiceCollection):\n    \"\"\"Configure authentication services\"\"\"\n    services.add_singleton(JWTAuthService)\n    services.add_scoped(lambda sp: get_current_user)\n</code></pre>"},{"location":"references/oauth-oidc-jwt/#role-based-access-control","title":"\ud83c\udfad Role-Based Access Control","text":"<p>Mario's Pizzeria defines different user roles with specific scopes:</p> <pre><code>ROLE_SCOPES = {\n    \"customer\": [\n        \"orders:read\",      # View own orders\n        \"orders:write\",     # Place new orders\n        \"menu:read\"         # Browse menu\n    ],\n    \"kitchen_staff\": [\n        \"orders:read\",      # View all orders\n        \"kitchen:read\",     # View kitchen status\n        \"kitchen:manage\",   # Manage cooking queue\n        \"menu:read\"         # View menu\n    ],\n    \"manager\": [\n        \"orders:read\",      # View all orders\n        \"orders:write\",     # Create orders for customers\n        \"kitchen:read\",     # Monitor kitchen\n        \"kitchen:manage\",   # Manage kitchen operations\n        \"menu:read\",        # View menu\n        \"menu:write\",       # Update menu items\n        \"reports:read\"      # View analytics\n    ],\n    \"admin\": [\n        \"admin\"             # Full access to everything\n    ]\n}\n</code></pre>"},{"location":"references/oauth-oidc-jwt/#keycloak-configuration","title":"\ud83d\udd27 Keycloak Configuration","text":"<p>Keycloak is an open-source identity and access management solution that implements OAuth 2.0 and OpenID Connect standards.</p>"},{"location":"references/oauth-oidc-jwt/#realm-configuration","title":"Realm Configuration","text":"<pre><code>{\n  \"realm\": \"pizzeria\",\n  \"enabled\": true,\n  \"displayName\": \"Mario's Pizzeria\",\n  \"accessTokenLifespan\": 3600,\n  \"ssoSessionMaxLifespan\": 86400,\n  \"clients\": [\n    {\n      \"clientId\": \"pizzeria-web\",\n      \"enabled\": true,\n      \"protocol\": \"openid-connect\",\n      \"redirectUris\": [\"https://mariospizzeria.com/auth/callback\"],\n      \"webOrigins\": [\"https://mariospizzeria.com\"],\n      \"defaultClientScopes\": [\"profile\", \"email\", \"roles\"]\n    },\n    {\n      \"clientId\": \"pizzeria-api\",\n      \"enabled\": true,\n      \"bearerOnly\": true,\n      \"protocol\": \"openid-connect\"\n    }\n  ],\n  \"clientScopes\": [\n    {\n      \"name\": \"orders:read\",\n      \"description\": \"Read order information\"\n    },\n    {\n      \"name\": \"orders:write\",\n      \"description\": \"Create and modify orders\"\n    },\n    {\n      \"name\": \"kitchen:read\",\n      \"description\": \"View kitchen status\"\n    },\n    {\n      \"name\": \"kitchen:manage\",\n      \"description\": \"Manage kitchen operations\"\n    }\n  ]\n}\n</code></pre>"},{"location":"references/oauth-oidc-jwt/#frontend-integration-example","title":"\ud83d\udcf1 Frontend Integration Example","text":"<pre><code>// React/JavaScript frontend example\nclass PizzeriaAuthService {\n  constructor() {\n    this.keycloakConfig = {\n      url: \"https://keycloak.mariospizzeria.com/auth\",\n      realm: \"pizzeria\",\n      clientId: \"pizzeria-web\",\n    };\n  }\n\n  async login() {\n    // Redirect to Keycloak login\n    const authUrl =\n      `${this.keycloakConfig.url}/realms/${this.keycloakConfig.realm}/protocol/openid_connect/auth` +\n      `?client_id=${this.keycloakConfig.clientId}` +\n      `&amp;response_type=code` +\n      `&amp;scope=openid profile email orders:read orders:write menu:read` +\n      `&amp;redirect_uri=${encodeURIComponent(window.location.origin + \"/auth/callback\")}`;\n\n    window.location.href = authUrl;\n  }\n\n  async makeAuthenticatedRequest(url, options = {}) {\n    const token = localStorage.getItem(\"access_token\");\n\n    return fetch(url, {\n      ...options,\n      headers: {\n        Authorization: `Bearer ${token}`,\n        \"Content-Type\": \"application/json\",\n        ...options.headers,\n      },\n    });\n  }\n\n  // Example: Place order with authentication\n  async placeOrder(orderData) {\n    const response = await this.makeAuthenticatedRequest(\"/api/orders\", {\n      method: \"POST\",\n      body: JSON.stringify(orderData),\n    });\n\n    if (response.status === 401) {\n      // Token expired, redirect to login\n      this.login();\n      return;\n    }\n\n    if (response.status === 403) {\n      throw new Error(\"Insufficient permissions to place order\");\n    }\n\n    return response.json();\n  }\n}\n</code></pre>"},{"location":"references/oauth-oidc-jwt/#testing-authentication","title":"\ud83e\uddea Testing Authentication","text":"<pre><code>import pytest\nfrom unittest.mock import Mock, patch\n\nclass TestAuthenticatedEndpoints:\n    def setup_method(self):\n        self.auth_service = Mock(spec=JWTAuthService)\n        self.test_user = {\n            \"sub\": \"customer_123\",\n            \"name\": \"Mario Rossi\",\n            \"email\": \"mario@example.com\",\n            \"roles\": [\"customer\"],\n            \"scope\": \"orders:read orders:write menu:read\"\n        }\n\n    async def test_get_orders_with_valid_token(self, test_client):\n        \"\"\"Test getting orders with valid customer token\"\"\"\n        self.auth_service.validate_token.return_value = self.test_user\n        self.auth_service.check_scope.return_value = True\n\n        headers = {\"Authorization\": \"Bearer valid_token\"}\n        response = await test_client.get(\"/orders\", headers=headers)\n\n        assert response.status_code == 200\n        # Should only return customer's own orders\n\n    async def test_get_orders_insufficient_scope(self, test_client):\n        \"\"\"Test getting orders without required scope\"\"\"\n        user_without_scope = {**self.test_user, \"scope\": \"menu:read\"}\n        self.auth_service.validate_token.return_value = user_without_scope\n        self.auth_service.check_scope.return_value = False\n\n        headers = {\"Authorization\": \"Bearer limited_token\"}\n        response = await test_client.get(\"/orders\", headers=headers)\n\n        assert response.status_code == 403\n        assert \"Insufficient permissions\" in response.json()[\"detail\"]\n\n    async def test_kitchen_access_staff_only(self, test_client):\n        \"\"\"Test kitchen endpoints require staff role\"\"\"\n        staff_user = {\n            \"sub\": \"staff_456\",\n            \"roles\": [\"kitchen_staff\"],\n            \"scope\": \"kitchen:read kitchen:manage\"\n        }\n        self.auth_service.validate_token.return_value = staff_user\n        self.auth_service.check_scope.return_value = True\n\n        headers = {\"Authorization\": \"Bearer staff_token\"}\n        response = await test_client.get(\"/kitchen/status\", headers=headers)\n\n        assert response.status_code == 200\n\n    async def test_expired_token(self, test_client):\n        \"\"\"Test expired token handling\"\"\"\n        from jwt import ExpiredSignatureError\n        self.auth_service.validate_token.side_effect = ExpiredSignatureError()\n\n        headers = {\"Authorization\": \"Bearer expired_token\"}\n        response = await test_client.get(\"/orders\", headers=headers)\n\n        assert response.status_code == 401\n        assert \"expired\" in response.json()[\"detail\"].lower()\n</code></pre>"},{"location":"references/oauth-oidc-jwt/#security-best-practices","title":"\ud83d\udccb Security Best Practices","text":"<p>Following OAuth 2.0 Security Best Current Practice and JWT Best Current Practices:</p>"},{"location":"references/oauth-oidc-jwt/#1-token-security","title":"1. Token Security","text":"<ul> <li>Short-lived access tokens (15-60 minutes)</li> <li>Secure refresh token rotation</li> <li>HTTPS only in production</li> <li>Secure storage (HttpOnly cookies for web)</li> </ul>"},{"location":"references/oauth-oidc-jwt/#2-scope-management","title":"2. Scope Management","text":"<ul> <li>Principle of least privilege - minimal required scopes</li> <li>Granular permissions - specific scopes for each operation</li> <li>Role-based defaults - sensible scope sets per role</li> </ul>"},{"location":"references/oauth-oidc-jwt/#3-api-security","title":"3. API Security","text":"<ul> <li>Rate limiting on authentication endpoints</li> <li>Input validation on all endpoints</li> <li>Audit logging for sensitive operations</li> <li>CORS configuration for web clients</li> </ul>"},{"location":"references/oauth-oidc-jwt/#production-deployment","title":"\ud83d\ude80 Production Deployment","text":"<pre><code># docker-compose.yml for production\nversion: \"3.8\"\nservices:\n  keycloak:\n    image: quay.io/keycloak/keycloak:latest\n    environment:\n      KEYCLOAK_ADMIN: admin\n      KEYCLOAK_ADMIN_PASSWORD: ${KEYCLOAK_ADMIN_PASSWORD}\n      KC_DB: postgres\n      KC_DB_URL: jdbc:postgresql://postgres:5432/keycloak\n      KC_DB_USERNAME: keycloak\n      KC_DB_PASSWORD: ${DB_PASSWORD}\n    command: start --optimized\n    depends_on:\n      - postgres\n    ports:\n      - \"8080:8080\"\n\n  pizzeria-api:\n    build: .\n    environment:\n      JWT_ISSUER: \"https://keycloak.mariospizzeria.com/auth/realms/pizzeria\"\n      JWT_AUDIENCE: \"pizzeria-api\"\n      JWKS_URL: \"https://keycloak.mariospizzeria.com/auth/realms/pizzeria/protocol/openid_connect/certs\"\n    depends_on:\n      - keycloak\n    ports:\n      - \"8000:8000\"\n</code></pre>"},{"location":"references/oauth-oidc-jwt/#authoritative-references-specifications","title":"\ufffd Authoritative References &amp; Specifications","text":""},{"location":"references/oauth-oidc-jwt/#oauth-20-official-specifications","title":"OAuth 2.0 Official Specifications","text":"<ul> <li>RFC 6749: The OAuth 2.0 Authorization Framework - Core OAuth 2.0 specification</li> <li>RFC 6750: OAuth 2.0 Bearer Token Usage - Bearer tokens specification</li> <li>RFC 7636: Proof Key for Code Exchange (PKCE) - Enhanced security for public clients</li> <li>RFC 8628: OAuth 2.0 Device Authorization Grant - Device flow specification</li> <li>OAuth 2.1 Draft - Latest OAuth evolution with security enhancements</li> </ul>"},{"location":"references/oauth-oidc-jwt/#openid-connect-official-specifications","title":"OpenID Connect Official Specifications","text":"<ul> <li>OpenID Connect Core 1.0 - Core OIDC specification</li> <li>OpenID Connect Discovery 1.0 - Automatic configuration discovery</li> <li>OpenID Connect Session Management 1.0 - Session management specification</li> <li>OpenID Connect Front-Channel Logout 1.0 - Front-channel logout</li> <li>OpenID Connect Back-Channel Logout 1.0 - Back-channel logout</li> </ul>"},{"location":"references/oauth-oidc-jwt/#json-web-token-jwt-specifications","title":"JSON Web Token (JWT) Specifications","text":"<ul> <li>RFC 7519: JSON Web Token (JWT) - Core JWT specification</li> <li>RFC 7515: JSON Web Signature (JWS) - JWT signature algorithms</li> <li>RFC 7516: JSON Web Encryption (JWE) - JWT encryption specification</li> <li>RFC 7517: JSON Web Key (JWK) - Cryptographic key representation</li> <li>RFC 7518: JSON Web Algorithms (JWA) - Cryptographic algorithms for JWS/JWE</li> </ul>"},{"location":"references/oauth-oidc-jwt/#security-best-practices-guidelines","title":"Security Best Practices &amp; Guidelines","text":"<ul> <li>OAuth 2.0 Security Best Current Practice - IETF security recommendations</li> <li>OAuth 2.0 Threat Model and Security Considerations - Security threat analysis</li> <li>JWT Best Current Practices - JWT security best practices</li> <li>OWASP Authentication Cheat Sheet - Authentication security guidance</li> </ul>"},{"location":"references/oauth-oidc-jwt/#identity-provider-documentation","title":"Identity Provider Documentation","text":"<ul> <li>Keycloak Documentation - Open-source identity provider</li> <li>Auth0 Documentation - Commercial identity-as-a-service platform</li> <li>Microsoft Entra ID (Azure AD) - Microsoft identity platform</li> <li>Google Identity Platform - Google identity services</li> <li>AWS Cognito - Amazon identity services</li> </ul>"},{"location":"references/oauth-oidc-jwt/#python-libraries-tools","title":"Python Libraries &amp; Tools","text":"<ul> <li>PyJWT - JWT implementation for Python</li> <li>python-jose - JavaScript Object Signing and Encryption for Python</li> <li>Authlib - Comprehensive OAuth/OIDC library for Python</li> <li>FastAPI Security - FastAPI security utilities</li> <li>requests-oauthlib - OAuth support for Python Requests</li> </ul>"},{"location":"references/oauth-oidc-jwt/#testing-development-tools","title":"Testing &amp; Development Tools","text":"<ul> <li>JWT.io - JWT debugger and decoder</li> <li>OAuth.tools - OAuth flow testing tools</li> <li>OpenID Connect Playground - OIDC flow testing</li> <li>OIDC Debugger - OpenID Connect debugging tool</li> </ul>"},{"location":"references/oauth-oidc-jwt/#educational-resources","title":"Educational Resources","text":"<ul> <li>OAuth 2 Simplified - Comprehensive OAuth 2.0 guide by Aaron Parecki</li> <li>OpenID Connect Explained - OIDC learning resources</li> <li>JWT Introduction - JWT fundamentals and use cases</li> <li>The Nuts and Bolts of OAuth 2.0 - Video course on OAuth 2.0</li> </ul>"},{"location":"references/oauth-oidc-jwt/#related-documentation","title":"\ufffd\ud83d\udd17 Related Documentation","text":"<ul> <li>Mario's Pizzeria Sample - Complete pizzeria implementation using these patterns</li> <li>Dependency Injection - How to configure authentication services</li> <li>MVC Controllers - Building protected API endpoints</li> <li>Getting Started - Setting up your first authenticated Neuroglia application</li> </ul> <p>This comprehensive authentication guide demonstrates how to implement enterprise-grade security using OAuth 2.0, OpenID Connect, and JWT tokens with the Neuroglia framework. The examples show real-world patterns for protecting APIs, managing user permissions, and integrating with identity providers like Keycloak.</p>"},{"location":"references/python_modular_code/","title":"\ud83c\udfd7\ufe0f Python Modular Code Reference","text":"<p>Understanding modular code organization is essential for working with the Neuroglia framework, which emphasizes clean architecture and separation of concerns.</p>"},{"location":"references/python_modular_code/#what-is-modular-code","title":"\ud83c\udfaf What is Modular Code?","text":"<p>Modular code organizes functionality into separate, reusable components (modules) that have clear responsibilities and well-defined interfaces. This makes code easier to understand, test, maintain, and extend.</p>"},{"location":"references/python_modular_code/#the-pizza-kitchen-analogy","title":"The Pizza Kitchen Analogy","text":"<p>Think of a pizzeria kitchen:</p> <pre><code># \u274c Everything in one big file (messy kitchen):\n# pizza_chaos.py - 2000+ lines doing everything\n\ndef make_dough():\n    pass\n\ndef prepare_sauce():\n    pass\n\ndef add_toppings():\n    pass\n\ndef bake_pizza():\n    pass\n\ndef take_order():\n    pass\n\ndef process_payment():\n    pass\n\ndef manage_inventory():\n    pass\n\n# ... 1900+ more lines\n\n# \u2705 Organized into modules (specialized stations):\n\n# dough_station.py\ndef make_dough(flour_type: str, water_amount: float) -&gt; Dough:\n    \"\"\"Specialized dough preparation.\"\"\"\n    pass\n\n# sauce_station.py\ndef prepare_marinara() -&gt; Sauce:\n    \"\"\"Specialized sauce preparation.\"\"\"\n    pass\n\n# assembly_station.py\ndef assemble_pizza(dough: Dough, sauce: Sauce, toppings: List[str]) -&gt; Pizza:\n    \"\"\"Specialized pizza assembly.\"\"\"\n    pass\n\n# order_management.py\ndef take_order(customer: Customer, items: List[str]) -&gt; Order:\n    \"\"\"Specialized order handling.\"\"\"\n    pass\n</code></pre>"},{"location":"references/python_modular_code/#python-module-basics","title":"\ud83d\udd27 Python Module Basics","text":""},{"location":"references/python_modular_code/#what-is-a-module","title":"What is a Module?","text":"<p>A module is simply a Python file containing code. When you create a <code>.py</code> file, you've created a module.</p> <pre><code># math_utils.py - This is a module\ndef add(a: float, b: float) -&gt; float:\n    \"\"\"Add two numbers.\"\"\"\n    return a + b\n\ndef multiply(a: float, b: float) -&gt; float:\n    \"\"\"Multiply two numbers.\"\"\"\n    return a * b\n\nPI = 3.14159\n\n# Using the module in another file:\n# main.py\nimport math_utils\n\nresult = math_utils.add(5, 3)\ncircle_area = math_utils.PI * radius ** 2\n</code></pre>"},{"location":"references/python_modular_code/#packages-modules-organized-in-directories","title":"Packages - Modules Organized in Directories","text":"<p>A package is a directory containing multiple modules:</p> <pre><code>mario_pizzeria/\n\u251c\u2500\u2500 __init__.py          # Makes this a package\n\u251c\u2500\u2500 pizza.py             # Pizza-related code\n\u251c\u2500\u2500 customer.py          # Customer-related code\n\u2514\u2500\u2500 order.py             # Order-related code\n</code></pre> <pre><code># __init__.py - Package initialization\n\"\"\"Mario's Pizzeria - A delicious pizza ordering system.\"\"\"\n\n__version__ = \"1.0.0\"\n__author__ = \"Mario\"\n\n# pizza.py\nfrom dataclasses import dataclass\nfrom typing import List\n\n@dataclass\nclass Pizza:\n    name: str\n    price: float\n    ingredients: List[str]\n\ndef create_margherita() -&gt; Pizza:\n    return Pizza(\n        name=\"Margherita\",\n        price=12.99,\n        ingredients=[\"tomato\", \"mozzarella\", \"basil\"]\n    )\n\n# Using the package:\nfrom mario_pizzeria.pizza import Pizza, create_margherita\nfrom mario_pizzeria import __version__\n\nmargherita = create_margherita()\nprint(f\"Using Mario's Pizzeria v{__version__}\")\n</code></pre>"},{"location":"references/python_modular_code/#neuroglia-framework-architecture","title":"\ud83c\udfdb\ufe0f Neuroglia Framework Architecture","text":"<p>The Neuroglia framework follows a layered architecture with clear module organization:</p>"},{"location":"references/python_modular_code/#directory-structure","title":"Directory Structure","text":"<pre><code>src/\n\u251c\u2500\u2500 neuroglia/                    # Framework core\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 dependency_injection/     # DI container modules\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 service_collection.py\n\u2502   \u2502   \u251c\u2500\u2500 service_provider.py\n\u2502   \u2502   \u2514\u2500\u2500 extensions.py\n\u2502   \u251c\u2500\u2500 mediation/               # CQRS pattern modules\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 mediator.py\n\u2502   \u2502   \u251c\u2500\u2500 commands.py\n\u2502   \u2502   \u251c\u2500\u2500 queries.py\n\u2502   \u2502   \u2514\u2500\u2500 handlers.py\n\u2502   \u251c\u2500\u2500 mvc/                     # MVC pattern modules\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 controller_base.py\n\u2502   \u2502   \u2514\u2500\u2500 routing.py\n\u2502   \u2514\u2500\u2500 data/                    # Data access modules\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 repository.py\n\u2502       \u2514\u2500\u2500 mongo_repository.py\n\u2514\u2500\u2500 mario_pizzeria/              # Application code\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 api/                     # API layer\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 controllers/\n    \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u2502   \u2514\u2500\u2500 pizza_controller.py\n    \u2502   \u2514\u2500\u2500 dtos/\n    \u2502       \u251c\u2500\u2500 __init__.py\n    \u2502       \u2514\u2500\u2500 pizza_dto.py\n    \u251c\u2500\u2500 application/             # Application layer\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 commands/\n    \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u2502   \u2514\u2500\u2500 create_pizza_command.py\n    \u2502   \u251c\u2500\u2500 queries/\n    \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u2502   \u2514\u2500\u2500 get_pizza_query.py\n    \u2502   \u2514\u2500\u2500 handlers/\n    \u2502       \u251c\u2500\u2500 __init__.py\n    \u2502       \u251c\u2500\u2500 create_pizza_handler.py\n    \u2502       \u2514\u2500\u2500 get_pizza_handler.py\n    \u251c\u2500\u2500 domain/                  # Domain layer\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 entities/\n    \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u2502   \u2514\u2500\u2500 pizza.py\n    \u2502   \u2514\u2500\u2500 repositories/\n    \u2502       \u251c\u2500\u2500 __init__.py\n    \u2502       \u2514\u2500\u2500 pizza_repository.py\n    \u2514\u2500\u2500 integration/             # Integration layer\n        \u251c\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 repositories/\n            \u251c\u2500\u2500 __init__.py\n            \u2514\u2500\u2500 mongo_pizza_repository.py\n</code></pre>"},{"location":"references/python_modular_code/#module-organization-principles","title":"Module Organization Principles","text":""},{"location":"references/python_modular_code/#1-single-responsibility-principle","title":"1. Single Responsibility Principle","text":"<p>Each module should have one clear purpose:</p> <pre><code># \u2705 Good - pizza.py focuses only on Pizza entity\nfrom dataclasses import dataclass\nfrom typing import List\nfrom datetime import datetime\n\n@dataclass\nclass Pizza:\n    \"\"\"Represents a pizza entity.\"\"\"\n    id: str\n    name: str\n    price: float\n    ingredients: List[str]\n    created_at: datetime\n    is_available: bool = True\n\n    def add_ingredient(self, ingredient: str) -&gt; None:\n        \"\"\"Add an ingredient to the pizza.\"\"\"\n        if ingredient not in self.ingredients:\n            self.ingredients.append(ingredient)\n\n    def calculate_cost(self) -&gt; float:\n        \"\"\"Calculate base cost based on ingredients.\"\"\"\n        base_cost = 8.0\n        return base_cost + (len(self.ingredients) * 0.50)\n\n# \u274c Bad - pizza_everything.py tries to do too much\nclass Pizza:\n    # Pizza logic...\n    pass\n\nclass Customer:  # Should be in customer.py\n    pass\n\nclass Order:     # Should be in order.py\n    pass\n\ndef send_email():    # Should be in notification.py\n    pass\n\ndef connect_to_database():  # Should be in database.py\n    pass\n</code></pre>"},{"location":"references/python_modular_code/#2-high-cohesion-low-coupling","title":"2. High Cohesion, Low Coupling","text":"<p>Related functionality stays together, unrelated functionality is separated:</p> <pre><code># High cohesion - pizza_operations.py\nfrom typing import List, Optional\nfrom .pizza import Pizza\n\nclass PizzaService:\n    \"\"\"Service for pizza-related operations.\"\"\"\n\n    def __init__(self, repository: 'PizzaRepository'):\n        self._repository = repository\n\n    async def create_pizza(self, name: str, price: float, ingredients: List[str]) -&gt; Pizza:\n        \"\"\"Create a new pizza.\"\"\"\n        pizza = Pizza(\n            id=self._generate_id(),\n            name=name,\n            price=price,\n            ingredients=ingredients,\n            created_at=datetime.now()\n        )\n        await self._repository.save_async(pizza)\n        return pizza\n\n    async def get_available_pizzas(self) -&gt; List[Pizza]:\n        \"\"\"Get all available pizzas.\"\"\"\n        all_pizzas = await self._repository.get_all_async()\n        return [pizza for pizza in all_pizzas if pizza.is_available]\n\n    def _generate_id(self) -&gt; str:\n        \"\"\"Generate unique pizza ID.\"\"\"\n        return str(uuid.uuid4())\n\n# Low coupling - separate concerns into different modules\n# customer_service.py\nclass CustomerService:\n    \"\"\"Service for customer-related operations.\"\"\"\n    pass\n\n# order_service.py\nclass OrderService:\n    \"\"\"Service for order-related operations.\"\"\"\n    pass\n</code></pre>"},{"location":"references/python_modular_code/#import-strategies","title":"\ud83d\udce6 Import Strategies","text":""},{"location":"references/python_modular_code/#absolute-vs-relative-imports","title":"Absolute vs Relative Imports","text":"<pre><code># Project structure:\nmario_pizzeria/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 domain/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 entities/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 pizza.py\n\u2502   \u2502   \u2514\u2500\u2500 customer.py\n\u2502   \u2514\u2500\u2500 services/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 pizza_service.py\n\u2514\u2500\u2500 infrastructure/\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 repositories/\n        \u251c\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 pizza_repository.py\n\n# \u2705 Absolute imports (preferred for clarity):\n# In pizza_service.py\nfrom mario_pizzeria.domain.entities.pizza import Pizza\nfrom mario_pizzeria.domain.entities.customer import Customer\nfrom mario_pizzeria.infrastructure.repositories.pizza_repository import PizzaRepository\n\n# \u2705 Relative imports (good for internal package references):\n# In pizza_service.py\nfrom ..entities.pizza import Pizza\nfrom ..entities.customer import Customer\nfrom ...infrastructure.repositories.pizza_repository import PizzaRepository\n\n# \u274c Avoid mixing styles in the same file\n</code></pre>"},{"location":"references/python_modular_code/#import-organization","title":"Import Organization","text":"<p>Organize imports in a standard order:</p> <pre><code># Standard library imports\nimport os\nimport sys\nfrom datetime import datetime\nfrom typing import List, Optional, Dict\n\n# Third-party imports\nimport fastapi\nfrom pydantic import BaseModel\nimport pymongo\n\n# Local application imports\nfrom neuroglia.dependency_injection import ServiceProvider\nfrom neuroglia.mediation import Mediator, Command, Query\n\n# Local relative imports\nfrom .pizza import Pizza\nfrom .customer import Customer\nfrom ..repositories.pizza_repository import PizzaRepository\n</code></pre>"},{"location":"references/python_modular_code/#controlling-what-gets-imported","title":"Controlling What Gets Imported","text":"<p>Use <code>__init__.py</code> files to control the public API:</p> <pre><code># domain/entities/__init__.py\n\"\"\"Domain entities for Mario's Pizzeria.\"\"\"\n\nfrom .pizza import Pizza\nfrom .customer import Customer\nfrom .order import Order\n\n# Make only specific classes available when importing the package\n__all__ = ['Pizza', 'Customer', 'Order']\n\n# Usage - clean imports for users:\nfrom mario_pizzeria.domain.entities import Pizza, Customer\n# Instead of:\n# from mario_pizzeria.domain.entities.pizza import Pizza\n# from mario_pizzeria.domain.entities.customer import Customer\n</code></pre>"},{"location":"references/python_modular_code/#lazy-loading-for-performance","title":"Lazy Loading for Performance","text":"<p>Load expensive modules only when needed:</p> <pre><code># heavy_analytics.py - expensive to import\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef generate_sales_report() -&gt; pd.DataFrame:\n    # Expensive analytics operations\n    pass\n\n# pizza_service.py - lazy loading\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    # Import only for type checking, not at runtime\n    from .heavy_analytics import generate_sales_report\n\nclass PizzaService:\n    def get_basic_stats(self) -&gt; dict:\n        \"\"\"Fast operation - no heavy imports needed.\"\"\"\n        return {\"total_pizzas\": 42}\n\n    def get_detailed_analytics(self) -&gt; 'pd.DataFrame':\n        \"\"\"Load analytics module only when needed.\"\"\"\n        from .heavy_analytics import generate_sales_report\n        return generate_sales_report()\n</code></pre>"},{"location":"references/python_modular_code/#advanced-modular-patterns","title":"\ud83c\udfa8 Advanced Modular Patterns","text":""},{"location":"references/python_modular_code/#factory-pattern-with-modules","title":"Factory Pattern with Modules","text":"<p>Organize related creation logic:</p> <pre><code># factories/__init__.py\nfrom .pizza_factory import PizzaFactory\nfrom .customer_factory import CustomerFactory\n\n__all__ = ['PizzaFactory', 'CustomerFactory']\n\n# factories/pizza_factory.py\nfrom typing import List\nfrom ..domain.entities.pizza import Pizza\n\nclass PizzaFactory:\n    \"\"\"Factory for creating different types of pizzas.\"\"\"\n\n    @staticmethod\n    def create_margherita() -&gt; Pizza:\n        return Pizza(\n            id=PizzaFactory._generate_id(),\n            name=\"Margherita\",\n            price=12.99,\n            ingredients=[\"tomato sauce\", \"mozzarella\", \"basil\"],\n            created_at=datetime.now()\n        )\n\n    @staticmethod\n    def create_pepperoni() -&gt; Pizza:\n        return Pizza(\n            id=PizzaFactory._generate_id(),\n            name=\"Pepperoni\",\n            price=14.99,\n            ingredients=[\"tomato sauce\", \"mozzarella\", \"pepperoni\"],\n            created_at=datetime.now()\n        )\n\n    @staticmethod\n    def create_custom(name: str, ingredients: List[str]) -&gt; Pizza:\n        base_price = 10.0\n        price = base_price + (len(ingredients) * 1.50)\n\n        return Pizza(\n            id=PizzaFactory._generate_id(),\n            name=name,\n            price=price,\n            ingredients=ingredients,\n            created_at=datetime.now()\n        )\n\n    @staticmethod\n    def _generate_id() -&gt; str:\n        return str(uuid.uuid4())\n\n# Usage:\nfrom mario_pizzeria.factories import PizzaFactory\n\nmargherita = PizzaFactory.create_margherita()\ncustom_pizza = PizzaFactory.create_custom(\"Veggie Supreme\",\n                                         [\"tomato\", \"mozzarella\", \"mushrooms\", \"peppers\"])\n</code></pre>"},{"location":"references/python_modular_code/#plugin-architecture-with-modules","title":"Plugin Architecture with Modules","text":"<p>Create extensible systems using module discovery:</p> <pre><code># plugins/__init__.py\n\"\"\"Plugin system for Mario's Pizzeria.\"\"\"\n\nimport importlib\nimport pkgutil\nfrom typing import List, Type\nfrom abc import ABC, abstractmethod\n\nclass PizzaPlugin(ABC):\n    \"\"\"Base class for pizza plugins.\"\"\"\n\n    @abstractmethod\n    def get_name(self) -&gt; str:\n        pass\n\n    @abstractmethod\n    def create_pizza(self) -&gt; Pizza:\n        pass\n\ndef discover_plugins() -&gt; List[Type[PizzaPlugin]]:\n    \"\"\"Discover all available pizza plugins.\"\"\"\n    plugins = []\n\n    # Discover plugins in the plugins package\n    for finder, name, ispkg in pkgutil.iter_modules(__path__):\n        module = importlib.import_module(f'{__name__}.{name}')\n\n        # Find all plugin classes in the module\n        for attr_name in dir(module):\n            attr = getattr(module, attr_name)\n            if (isinstance(attr, type) and\n                issubclass(attr, PizzaPlugin) and\n                attr is not PizzaPlugin):\n                plugins.append(attr)\n\n    return plugins\n\n# plugins/italian_classics.py\nfrom . import PizzaPlugin\nfrom ..domain.entities.pizza import Pizza\n\nclass MargheritaPlugin(PizzaPlugin):\n    def get_name(self) -&gt; str:\n        return \"Margherita\"\n\n    def create_pizza(self) -&gt; Pizza:\n        return Pizza(\n            id=str(uuid.uuid4()),\n            name=\"Margherita\",\n            price=12.99,\n            ingredients=[\"tomato\", \"mozzarella\", \"basil\"]\n        )\n\nclass QuattroStagioniPlugin(PizzaPlugin):\n    def get_name(self) -&gt; str:\n        return \"Quattro Stagioni\"\n\n    def create_pizza(self) -&gt; Pizza:\n        return Pizza(\n            id=str(uuid.uuid4()),\n            name=\"Quattro Stagioni\",\n            price=16.99,\n            ingredients=[\"tomato\", \"mozzarella\", \"ham\", \"mushrooms\", \"artichokes\", \"olives\"]\n        )\n\n# plugins/american_style.py\nfrom . import PizzaPlugin\nfrom ..domain.entities.pizza import Pizza\n\nclass PepperoniPlugin(PizzaPlugin):\n    def get_name(self) -&gt; str:\n        return \"Pepperoni\"\n\n    def create_pizza(self) -&gt; Pizza:\n        return Pizza(\n            id=str(uuid.uuid4()),\n            name=\"Pepperoni\",\n            price=14.99,\n            ingredients=[\"tomato\", \"mozzarella\", \"pepperoni\"]\n        )\n\n# Usage:\nfrom mario_pizzeria.plugins import discover_plugins\n\n# Automatically discover all pizza plugins\navailable_plugins = discover_plugins()\nfor plugin_class in available_plugins:\n    plugin = plugin_class()\n    print(f\"Available: {plugin.get_name()}\")\n    pizza = plugin.create_pizza()\n</code></pre>"},{"location":"references/python_modular_code/#configuration-modules","title":"Configuration Modules","text":"<p>Organize configuration in modules:</p> <pre><code># config/__init__.py\nfrom .database import DatabaseConfig\nfrom .api import ApiConfig\nfrom .logging import LoggingConfig\n\n# config/database.py\nfrom dataclasses import dataclass\nfrom typing import Optional\n\n@dataclass\nclass DatabaseConfig:\n    \"\"\"Database configuration settings.\"\"\"\n    host: str = \"localhost\"\n    port: int = 27017\n    database: str = \"mario_pizzeria\"\n    username: Optional[str] = None\n    password: Optional[str] = None\n    connection_timeout: int = 30\n\n    @property\n    def connection_string(self) -&gt; str:\n        \"\"\"Generate MongoDB connection string.\"\"\"\n        if self.username and self.password:\n            return f\"mongodb://{self.username}:{self.password}@{self.host}:{self.port}/{self.database}\"\n        return f\"mongodb://{self.host}:{self.port}/{self.database}\"\n\n# config/api.py\n@dataclass\nclass ApiConfig:\n    \"\"\"API configuration settings.\"\"\"\n    host: str = \"0.0.0.0\"\n    port: int = 8000\n    debug: bool = False\n    cors_origins: List[str] = None\n    api_prefix: str = \"/api/v1\"\n\n    def __post_init__(self):\n        if self.cors_origins is None:\n            self.cors_origins = [\"http://localhost:3000\"]\n\n# config/logging.py\nimport logging\nfrom typing import Dict\n\n@dataclass\nclass LoggingConfig:\n    \"\"\"Logging configuration settings.\"\"\"\n    level: str = \"INFO\"\n    format: str = \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n    handlers: List[str] = None\n\n    def __post_init__(self):\n        if self.handlers is None:\n            self.handlers = [\"console\", \"file\"]\n\n    def get_level(self) -&gt; int:\n        \"\"\"Convert string level to logging constant.\"\"\"\n        return getattr(logging, self.level.upper(), logging.INFO)\n\n# Usage:\nfrom mario_pizzeria.config import DatabaseConfig, ApiConfig, LoggingConfig\n\ndb_config = DatabaseConfig(host=\"production-mongo\", database=\"pizzeria_prod\")\napi_config = ApiConfig(port=8080, debug=False)\nlog_config = LoggingConfig(level=\"WARNING\")\n\nprint(f\"Database: {db_config.connection_string}\")\nprint(f\"API will run on: {api_config.host}:{api_config.port}\")\nprint(f\"Log level: {log_config.get_level()}\")\n</code></pre>"},{"location":"references/python_modular_code/#testing-modular-code","title":"\ud83e\uddea Testing Modular Code","text":"<p>Organize tests to mirror your module structure:</p> <pre><code>tests/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 conftest.py              # Shared test fixtures\n\u251c\u2500\u2500 unit/                    # Unit tests\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 domain/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 test_pizza.py\n\u2502   \u2502   \u2514\u2500\u2500 test_customer.py\n\u2502   \u251c\u2500\u2500 application/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 test_pizza_service.py\n\u2502   \u2514\u2500\u2500 infrastructure/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 test_pizza_repository.py\n\u251c\u2500\u2500 integration/             # Integration tests\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 test_api_endpoints.py\n\u2502   \u2514\u2500\u2500 test_database_integration.py\n\u2514\u2500\u2500 fixtures/               # Test data\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 pizza_fixtures.py\n    \u2514\u2500\u2500 customer_fixtures.py\n</code></pre> <pre><code># tests/conftest.py - Shared fixtures\nimport pytest\nfrom mario_pizzeria.domain.entities.pizza import Pizza\nfrom mario_pizzeria.infrastructure.repositories.in_memory_pizza_repository import InMemoryPizzaRepository\n\n@pytest.fixture\ndef sample_pizza() -&gt; Pizza:\n    \"\"\"Create a sample pizza for testing.\"\"\"\n    return Pizza(\n        id=\"test-pizza-1\",\n        name=\"Test Margherita\",\n        price=12.99,\n        ingredients=[\"tomato\", \"mozzarella\", \"basil\"]\n    )\n\n@pytest.fixture\ndef pizza_repository() -&gt; InMemoryPizzaRepository:\n    \"\"\"Create an in-memory pizza repository for testing.\"\"\"\n    return InMemoryPizzaRepository()\n\n# tests/unit/domain/test_pizza.py\nimport pytest\nfrom mario_pizzeria.domain.entities.pizza import Pizza\n\nclass TestPizza:\n    def test_pizza_creation(self, sample_pizza):\n        \"\"\"Test pizza entity creation.\"\"\"\n        assert sample_pizza.name == \"Test Margherita\"\n        assert sample_pizza.price == 12.99\n        assert \"tomato\" in sample_pizza.ingredients\n\n    def test_add_ingredient(self, sample_pizza):\n        \"\"\"Test adding ingredient to pizza.\"\"\"\n        sample_pizza.add_ingredient(\"oregano\")\n        assert \"oregano\" in sample_pizza.ingredients\n\n    def test_calculate_cost(self, sample_pizza):\n        \"\"\"Test pizza cost calculation.\"\"\"\n        cost = sample_pizza.calculate_cost()\n        expected_cost = 8.0 + (3 * 0.50)  # base + (3 ingredients * 0.50)\n        assert cost == expected_cost\n\n# tests/fixtures/pizza_fixtures.py\nfrom typing import List\nfrom mario_pizzeria.domain.entities.pizza import Pizza\n\nclass PizzaFixtures:\n    \"\"\"Factory for creating test pizza data.\"\"\"\n\n    @staticmethod\n    def create_margherita() -&gt; Pizza:\n        return Pizza(\n            id=\"margherita-1\",\n            name=\"Margherita\",\n            price=12.99,\n            ingredients=[\"tomato\", \"mozzarella\", \"basil\"]\n        )\n\n    @staticmethod\n    def create_pizza_list() -&gt; List[Pizza]:\n        return [\n            PizzaFixtures.create_margherita(),\n            Pizza(\"pepperoni-1\", \"Pepperoni\", 14.99, [\"tomato\", \"mozzarella\", \"pepperoni\"]),\n            Pizza(\"hawaiian-1\", \"Hawaiian\", 13.49, [\"tomato\", \"mozzarella\", \"ham\", \"pineapple\"])\n        ]\n</code></pre>"},{"location":"references/python_modular_code/#best-practices-for-modular-code","title":"\ud83d\ude80 Best Practices for Modular Code","text":""},{"location":"references/python_modular_code/#1-use-meaningful-module-names","title":"1. Use Meaningful Module Names","text":"<pre><code># \u2705 Good - clear, descriptive names:\npizza_service.py\ncustomer_repository.py\norder_validation.py\npayment_processing.py\n\n# \u274c Bad - vague or abbreviated names:\nutil.py\nhelper.py\nstuff.py\nps.py (pizza service?)\n</code></pre>"},{"location":"references/python_modular_code/#2-keep-modules-focused-and-small","title":"2. Keep Modules Focused and Small","text":"<pre><code># \u2705 Good - focused pizza entity module (50-100 lines):\n# domain/entities/pizza.py\nfrom dataclasses import dataclass\nfrom typing import List\nfrom datetime import datetime\n\n@dataclass\nclass Pizza:\n    id: str\n    name: str\n    price: float\n    ingredients: List[str]\n    created_at: datetime\n    is_available: bool = True\n\n    def add_ingredient(self, ingredient: str) -&gt; None:\n        if ingredient not in self.ingredients:\n            self.ingredients.append(ingredient)\n\n    def remove_ingredient(self, ingredient: str) -&gt; None:\n        if ingredient in self.ingredients:\n            self.ingredients.remove(ingredient)\n\n    def calculate_cost(self) -&gt; float:\n        base_cost = 8.0\n        return base_cost + (len(self.ingredients) * 0.50)\n\n# \u274c Bad - trying to do everything in one module (1000+ lines)\n</code></pre>"},{"location":"references/python_modular_code/#3-use-dependency-injection-for-module-coupling","title":"3. Use Dependency Injection for Module Coupling","text":"<pre><code># \u2705 Good - dependency injection reduces coupling:\nclass PizzaService:\n    def __init__(self,\n                 repository: PizzaRepository,\n                 validator: PizzaValidator,\n                 notifier: NotificationService):\n        self._repository = repository\n        self._validator = validator\n        self._notifier = notifier\n\n    async def create_pizza(self, pizza_data: dict) -&gt; Pizza:\n        # Use injected dependencies\n        if not self._validator.is_valid(pizza_data):\n            raise ValidationError(\"Invalid pizza data\")\n\n        pizza = Pizza(**pizza_data)\n        await self._repository.save_async(pizza)\n        await self._notifier.notify_pizza_created(pizza)\n        return pizza\n\n# \u274c Bad - tight coupling with direct imports:\nclass PizzaService:\n    def __init__(self):\n        self._repository = MongoPizzaRepository()  # Tightly coupled\n        self._validator = PizzaValidator()         # Hard to test\n        self._notifier = EmailNotifier()          # Can't swap implementations\n</code></pre>"},{"location":"references/python_modular_code/#4-design-clear-module-interfaces","title":"4. Design Clear Module Interfaces","text":"<pre><code># \u2705 Good - clear, well-defined interface:\n# repositories/pizza_repository.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Optional\nfrom ..domain.entities.pizza import Pizza\n\nclass PizzaRepository(ABC):\n    \"\"\"Interface for pizza data access operations.\"\"\"\n\n    @abstractmethod\n    async def get_by_id_async(self, pizza_id: str) -&gt; Optional[Pizza]:\n        \"\"\"Get pizza by ID, returns None if not found.\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_by_name_async(self, name: str) -&gt; List[Pizza]:\n        \"\"\"Get all pizzas matching the given name.\"\"\"\n        pass\n\n    @abstractmethod\n    async def save_async(self, pizza: Pizza) -&gt; None:\n        \"\"\"Save pizza to storage.\"\"\"\n        pass\n\n    @abstractmethod\n    async def delete_async(self, pizza_id: str) -&gt; bool:\n        \"\"\"Delete pizza, returns True if deleted.\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_available_pizzas_async(self) -&gt; List[Pizza]:\n        \"\"\"Get all available pizzas.\"\"\"\n        pass\n\n# Concrete implementation:\nclass MongoPizzaRepository(PizzaRepository):\n    \"\"\"MongoDB implementation of pizza repository.\"\"\"\n\n    def __init__(self, collection):\n        self._collection = collection\n\n    async def get_by_id_async(self, pizza_id: str) -&gt; Optional[Pizza]:\n        # MongoDB-specific implementation\n        pass\n\n    # ... implement other methods\n</code></pre>"},{"location":"references/python_modular_code/#5-use-module-level-constants-and-configuration","title":"5. Use Module-Level Constants and Configuration","text":"<pre><code># constants/pizza_constants.py\n\"\"\"Constants for pizza-related operations.\"\"\"\n\n# Pizza sizes\nSMALL_SIZE = \"small\"\nMEDIUM_SIZE = \"medium\"\nLARGE_SIZE = \"large\"\n\nPIZZA_SIZES = [SMALL_SIZE, MEDIUM_SIZE, LARGE_SIZE]\n\n# Price multipliers by size\nSIZE_MULTIPLIERS = {\n    SMALL_SIZE: 0.8,\n    MEDIUM_SIZE: 1.0,\n    LARGE_SIZE: 1.3\n}\n\n# Ingredient categories\nCHEESE_INGREDIENTS = [\"mozzarella\", \"parmesan\", \"ricotta\", \"goat cheese\"]\nMEAT_INGREDIENTS = [\"pepperoni\", \"sausage\", \"ham\", \"bacon\", \"chicken\"]\nVEGETABLE_INGREDIENTS = [\"mushrooms\", \"peppers\", \"onions\", \"tomatoes\", \"spinach\"]\n\n# Business rules\nMAX_INGREDIENTS_PER_PIZZA = 8\nMIN_PIZZA_PRICE = 8.99\nMAX_PIZZA_PRICE = 29.99\n\n# Usage in other modules:\nfrom mario_pizzeria.constants.pizza_constants import (\n    PIZZA_SIZES,\n    SIZE_MULTIPLIERS,\n    MAX_INGREDIENTS_PER_PIZZA\n)\n\nclass PizzaValidator:\n    def validate_ingredients(self, ingredients: List[str]) -&gt; bool:\n        return len(ingredients) &lt;= MAX_INGREDIENTS_PER_PIZZA\n\n    def validate_size(self, size: str) -&gt; bool:\n        return size in PIZZA_SIZES\n</code></pre>"},{"location":"references/python_modular_code/#6-document-module-purposes-and-apis","title":"6. Document Module Purposes and APIs","text":"<pre><code># services/pizza_service.py\n\"\"\"\nPizza Service Module\n\nThis module provides business logic for pizza operations including creation,\nvalidation, pricing, and management. It serves as the main interface between\nthe API layer and the domain/data layers.\n\nClasses:\n    PizzaService: Main service class for pizza operations\n    PizzaValidator: Validation logic for pizza data\n    PricingCalculator: Pricing logic for pizzas\n\nDependencies:\n    - domain.entities.pizza: Pizza entity\n    - repositories.pizza_repository: Data access interface\n    - services.notification_service: Notification capabilities\n\nExample:\n    &gt;&gt;&gt; from mario_pizzeria.services import PizzaService\n    &gt;&gt;&gt; service = PizzaService(repository, validator, notifier)\n    &gt;&gt;&gt; pizza = await service.create_pizza({\n    ...     \"name\": \"Margherita\",\n    ...     \"ingredients\": [\"tomato\", \"mozzarella\", \"basil\"]\n    ... })\n\"\"\"\n\nfrom typing import List, Optional, Dict, Any\nfrom ..domain.entities.pizza import Pizza\nfrom ..repositories.pizza_repository import PizzaRepository\n\nclass PizzaService:\n    \"\"\"\n    Service class for pizza business operations.\n\n    This service handles pizza creation, validation, pricing calculations,\n    and coordinates with repositories and notification services.\n\n    Attributes:\n        _repository: Pizza data access repository\n        _validator: Pizza validation service\n        _notifier: Notification service for pizza events\n    \"\"\"\n\n    def __init__(self,\n                 repository: PizzaRepository,\n                 validator: 'PizzaValidator',\n                 notifier: 'NotificationService'):\n        \"\"\"\n        Initialize the pizza service.\n\n        Args:\n            repository: Repository for pizza data access\n            validator: Service for validating pizza data\n            notifier: Service for sending notifications\n        \"\"\"\n        self._repository = repository\n        self._validator = validator\n        self._notifier = notifier\n\n    async def create_pizza(self, pizza_data: Dict[str, Any]) -&gt; Pizza:\n        \"\"\"\n        Create a new pizza with validation and notification.\n\n        Args:\n            pizza_data: Dictionary containing pizza information with keys:\n                - name (str): Pizza name\n                - price (float): Pizza price\n                - ingredients (List[str]): List of ingredients\n\n        Returns:\n            Pizza: The created pizza entity\n\n        Raises:\n            ValidationError: If pizza data is invalid\n            RepositoryError: If save operation fails\n\n        Example:\n            &gt;&gt;&gt; pizza_data = {\n            ...     \"name\": \"Margherita\",\n            ...     \"price\": 12.99,\n            ...     \"ingredients\": [\"tomato\", \"mozzarella\", \"basil\"]\n            ... }\n            &gt;&gt;&gt; pizza = await service.create_pizza(pizza_data)\n        \"\"\"\n        # Implementation here...\n        pass\n</code></pre>"},{"location":"references/python_modular_code/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Python Object-Oriented Programming - Classes and inheritance in modular design</li> <li>Python Typing Guide - Type safety, generics, and modular programming patterns</li> <li>Dependency Injection - Managing dependencies between modules</li> <li>CQRS &amp; Mediation - Organizing commands and queries in modules</li> </ul>"},{"location":"references/python_modular_code/#further-reading","title":"\ud83d\udcda Further Reading","text":"<ul> <li>PEP 8 - Style Guide for Python Code</li> <li>Python Module Documentation</li> <li>Clean Architecture by Robert Martin</li> <li>Python Package Discovery</li> </ul>"},{"location":"references/python_object_oriented/","title":"\ud83c\udfdb\ufe0f Python Object-Oriented Programming Reference","text":"<p>Object-Oriented Programming (OOP) is fundamental to the Neuroglia framework's design. Understanding these concepts is essential for building maintainable, extensible applications.</p>"},{"location":"references/python_object_oriented/#what-is-object-oriented-programming","title":"\ud83c\udfaf What is Object-Oriented Programming?","text":"<p>OOP is a programming paradigm that organizes code around objects (data and methods that work on that data) rather than functions and logic. Think of it as creating blueprints (classes) for real-world entities.</p>"},{"location":"references/python_object_oriented/#the-pizza-restaurant-analogy","title":"The Pizza Restaurant Analogy","text":"<pre><code># Real world: A pizza restaurant has different roles and responsibilities\n\n# \u274c Procedural approach - everything is functions:\ndef make_pizza(name, ingredients, size):\n    pass\n\ndef take_order(customer_name, items):\n    pass\n\ndef calculate_bill(items, discounts):\n    pass\n\ndef manage_inventory(ingredient, quantity):\n    pass\n\n# \u2705 Object-oriented approach - organize by entities:\nclass Pizza:\n    \"\"\"A pizza entity with its own data and behaviors.\"\"\"\n    def __init__(self, name, ingredients, size):\n        self.name = name\n        self.ingredients = ingredients\n        self.size = size\n\n    def calculate_price(self):\n        # Pizza knows how to calculate its own price\n        pass\n\n    def add_ingredient(self, ingredient):\n        # Pizza knows how to modify itself\n        pass\n\nclass Chef:\n    \"\"\"A chef entity that knows how to make pizzas.\"\"\"\n    def make_pizza(self, pizza_order):\n        # Chef knows how to make pizzas\n        pass\n\nclass Waiter:\n    \"\"\"A waiter entity that handles customer interactions.\"\"\"\n    def take_order(self, customer, menu):\n        # Waiter knows how to interact with customers\n        pass\n\nclass CashRegister:\n    \"\"\"A cash register that handles billing.\"\"\"\n    def calculate_bill(self, order):\n        # Cash register knows how to calculate bills\n        pass\n</code></pre>"},{"location":"references/python_object_oriented/#core-oop-concepts","title":"\ud83d\udd27 Core OOP Concepts","text":""},{"location":"references/python_object_oriented/#1-classes-and-objects","title":"1. Classes and Objects","text":"<p>A class is a blueprint, an object is an instance of that blueprint:</p> <pre><code>from typing import List\nfrom datetime import datetime\nfrom dataclasses import dataclass\n\n# Class definition - the blueprint\n@dataclass\nclass Pizza:\n    \"\"\"Blueprint for creating pizza objects.\"\"\"\n    name: str\n    price: float\n    ingredients: List[str]\n    size: str = \"medium\"\n    created_at: datetime = None\n\n    def __post_init__(self):\n        \"\"\"Called after object creation.\"\"\"\n        if self.created_at is None:\n            self.created_at = datetime.now()\n\n    # Methods - what pizzas can do\n    def add_ingredient(self, ingredient: str) -&gt; None:\n        \"\"\"Add an ingredient to this pizza.\"\"\"\n        if ingredient not in self.ingredients:\n            self.ingredients.append(ingredient)\n\n    def remove_ingredient(self, ingredient: str) -&gt; None:\n        \"\"\"Remove an ingredient from this pizza.\"\"\"\n        if ingredient in self.ingredients:\n            self.ingredients.remove(ingredient)\n\n    def calculate_cost(self) -&gt; float:\n        \"\"\"Calculate the cost to make this pizza.\"\"\"\n        base_cost = {\"small\": 6.0, \"medium\": 8.0, \"large\": 10.0}\n        ingredient_cost = len(self.ingredients) * 0.75\n        return base_cost[self.size] + ingredient_cost\n\n    def __str__(self) -&gt; str:\n        \"\"\"String representation of the pizza.\"\"\"\n        return f\"{self.size.title()} {self.name} - ${self.price:.2f}\"\n\n# Creating objects - instances of the class\nmargherita = Pizza(\n    name=\"Margherita\",\n    price=12.99,\n    ingredients=[\"tomato sauce\", \"mozzarella\", \"basil\"]\n)\n\npepperoni = Pizza(\n    name=\"Pepperoni\",\n    price=14.99,\n    ingredients=[\"tomato sauce\", \"mozzarella\", \"pepperoni\"],\n    size=\"large\"\n)\n\n# Objects have their own data and can perform actions\nmargherita.add_ingredient(\"extra cheese\")\nprint(f\"Margherita cost to make: ${margherita.calculate_cost():.2f}\")\nprint(f\"Pepperoni: {pepperoni}\")\n\n# Each object is independent\nprint(f\"Margherita ingredients: {margherita.ingredients}\")\nprint(f\"Pepperoni ingredients: {pepperoni.ingredients}\")\n</code></pre>"},{"location":"references/python_object_oriented/#2-encapsulation-data-hiding","title":"2. Encapsulation - Data Hiding","text":"<p>Encapsulation bundles data and methods together and controls access to them:</p> <pre><code>from typing import Optional\n\nclass Customer:\n    \"\"\"Customer entity with controlled access to data.\"\"\"\n\n    def __init__(self, name: str, email: str):\n        self._name = name           # Protected attribute (internal use)\n        self._email = email         # Protected attribute\n        self.__loyalty_points = 0   # Private attribute (name mangling)\n        self._orders = []           # Protected attribute\n\n    # Public interface - how external code interacts with Customer\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Get customer name (read-only).\"\"\"\n        return self._name\n\n    @property\n    def email(self) -&gt; str:\n        \"\"\"Get customer email.\"\"\"\n        return self._email\n\n    @email.setter\n    def email(self, new_email: str) -&gt; None:\n        \"\"\"Set customer email with validation.\"\"\"\n        if \"@\" not in new_email or \".\" not in new_email:\n            raise ValueError(\"Invalid email format\")\n        self._email = new_email\n\n    @property\n    def loyalty_points(self) -&gt; int:\n        \"\"\"Get loyalty points (read-only from outside).\"\"\"\n        return self.__loyalty_points\n\n    def add_loyalty_points(self, points: int) -&gt; None:\n        \"\"\"Add loyalty points (controlled method).\"\"\"\n        if points &gt; 0:\n            self.__loyalty_points += points\n\n    def redeem_points(self, points: int) -&gt; bool:\n        \"\"\"Redeem loyalty points.\"\"\"\n        if points &gt; 0 and points &lt;= self.__loyalty_points:\n            self.__loyalty_points -= points\n            return True\n        return False\n\n    def place_order(self, order: 'Order') -&gt; None:\n        \"\"\"Place an order and earn points.\"\"\"\n        self._orders.append(order)\n        # Earn 1 point per dollar spent\n        points_earned = int(order.total_amount())\n        self.add_loyalty_points(points_earned)\n\n    def get_order_history(self) -&gt; List['Order']:\n        \"\"\"Get copy of order history (don't expose internal list).\"\"\"\n        return self._orders.copy()\n\n# Usage demonstrates encapsulation:\ncustomer = Customer(\"Mario\", \"mario@email.com\")\n\n# \u2705 Public interface works correctly:\nprint(f\"Customer: {customer.name}\")\nprint(f\"Points: {customer.loyalty_points}\")\n\ncustomer.add_loyalty_points(100)\nprint(f\"Points after addition: {customer.loyalty_points}\")\n\n# \u2705 Validation works:\ntry:\n    customer.email = \"invalid-email\"\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n\n# \u274c Direct access to private data is discouraged:\n# customer.__loyalty_points = 1000  # This won't work as expected\n# customer._orders.clear()          # Breaks encapsulation, but possible\n</code></pre>"},{"location":"references/python_object_oriented/#3-inheritance-extending-behavior","title":"3. Inheritance - Extending Behavior","text":"<p>Inheritance allows classes to inherit properties and methods from parent classes:</p> <pre><code>from abc import ABC, abstractmethod\nfrom typing import List, Dict\nfrom enum import Enum\n\nclass MenuItemType(Enum):\n    PIZZA = \"pizza\"\n    DRINK = \"drink\"\n    DESSERT = \"dessert\"\n    APPETIZER = \"appetizer\"\n\n# Base class - common behavior for all menu items\nclass MenuItem(ABC):\n    \"\"\"Abstract base class for all menu items.\"\"\"\n\n    def __init__(self, name: str, price: float, description: str):\n        self.name = name\n        self.price = price\n        self.description = description\n        self.is_available = True\n\n    @abstractmethod\n    def get_type(self) -&gt; MenuItemType:\n        \"\"\"Each menu item must specify its type.\"\"\"\n        pass\n\n    @abstractmethod\n    def calculate_preparation_time(self) -&gt; int:\n        \"\"\"Each menu item must specify preparation time in minutes.\"\"\"\n        pass\n\n    def apply_discount(self, percentage: float) -&gt; float:\n        \"\"\"Common discount calculation.\"\"\"\n        if 0 &lt;= percentage &lt;= 100:\n            return self.price * (1 - percentage / 100)\n        return self.price\n\n    def __str__(self) -&gt; str:\n        status = \"Available\" if self.is_available else \"Unavailable\"\n        return f\"{self.name} - ${self.price:.2f} ({status})\"\n\n# Derived classes - specialized menu items\nclass Pizza(MenuItem):\n    \"\"\"Pizza menu item with pizza-specific behavior.\"\"\"\n\n    def __init__(self, name: str, price: float, description: str,\n                 ingredients: List[str], size: str = \"medium\"):\n        super().__init__(name, price, description)  # Call parent constructor\n        self.ingredients = ingredients\n        self.size = size\n        self.crust_type = \"regular\"\n\n    def get_type(self) -&gt; MenuItemType:\n        \"\"\"Pizzas are PIZZA type.\"\"\"\n        return MenuItemType.PIZZA\n\n    def calculate_preparation_time(self) -&gt; int:\n        \"\"\"Pizza prep time depends on size and toppings.\"\"\"\n        base_time = {\"small\": 12, \"medium\": 15, \"large\": 18}\n        topping_time = len(self.ingredients) * 2\n        return base_time.get(self.size, 15) + topping_time\n\n    # Pizza-specific methods\n    def add_ingredient(self, ingredient: str) -&gt; None:\n        \"\"\"Add ingredient to pizza.\"\"\"\n        if ingredient not in self.ingredients:\n            self.ingredients.append(ingredient)\n            self.price += 1.50  # Extra topping cost\n\n    def set_crust_type(self, crust: str) -&gt; None:\n        \"\"\"Change crust type.\"\"\"\n        crust_options = [\"thin\", \"regular\", \"thick\", \"gluten-free\"]\n        if crust in crust_options:\n            self.crust_type = crust\n            if crust == \"gluten-free\":\n                self.price += 2.00\n\nclass Drink(MenuItem):\n    \"\"\"Drink menu item.\"\"\"\n\n    def __init__(self, name: str, price: float, description: str,\n                 size: str = \"medium\", is_alcoholic: bool = False):\n        super().__init__(name, price, description)\n        self.size = size\n        self.is_alcoholic = is_alcoholic\n        self.temperature = \"cold\"\n\n    def get_type(self) -&gt; MenuItemType:\n        return MenuItemType.DRINK\n\n    def calculate_preparation_time(self) -&gt; int:\n        \"\"\"Drinks are quick to prepare.\"\"\"\n        return 2 if not self.is_alcoholic else 5\n\n    def set_temperature(self, temp: str) -&gt; None:\n        \"\"\"Set drink temperature.\"\"\"\n        if temp in [\"hot\", \"cold\", \"room temperature\"]:\n            self.temperature = temp\n\nclass Dessert(MenuItem):\n    \"\"\"Dessert menu item.\"\"\"\n\n    def __init__(self, name: str, price: float, description: str,\n                 serving_size: str = \"individual\"):\n        super().__init__(name, price, description)\n        self.serving_size = serving_size\n        self.is_homemade = True\n\n    def get_type(self) -&gt; MenuItemType:\n        return MenuItemType.DESSERT\n\n    def calculate_preparation_time(self) -&gt; int:\n        \"\"\"Dessert prep time varies by type.\"\"\"\n        if \"cake\" in self.name.lower():\n            return 10\n        elif \"ice cream\" in self.name.lower():\n            return 3\n        return 5\n\n# Polymorphism - treating different types the same way\ndef create_sample_menu() -&gt; List[MenuItem]:\n    \"\"\"Create a sample menu with different item types.\"\"\"\n    return [\n        Pizza(\"Margherita\", 12.99, \"Classic tomato and mozzarella\",\n              [\"tomato sauce\", \"mozzarella\", \"basil\"]),\n        Pizza(\"Pepperoni\", 14.99, \"Pepperoni with mozzarella\",\n              [\"tomato sauce\", \"mozzarella\", \"pepperoni\"], size=\"large\"),\n        Drink(\"Coca Cola\", 2.99, \"Classic soft drink\", size=\"large\"),\n        Drink(\"House Wine\", 8.99, \"Italian red wine\", is_alcoholic=True),\n        Dessert(\"Tiramisu\", 6.99, \"Classic Italian dessert\"),\n        Dessert(\"Gelato\", 4.99, \"Italian ice cream\")\n    ]\n\n# Usage - polymorphism in action\nmenu = create_sample_menu()\n\nprint(\"=== Mario's Menu ===\")\ntotal_prep_time = 0\n\nfor item in menu:  # Each item behaves according to its specific type\n    print(f\"{item}\")\n    print(f\"  Type: {item.get_type().value}\")\n    print(f\"  Prep time: {item.calculate_preparation_time()} minutes\")\n    print(f\"  With 10% discount: ${item.apply_discount(10):.2f}\")\n    print()\n\n    total_prep_time += item.calculate_preparation_time()\n\nprint(f\"Total preparation time for all items: {total_prep_time} minutes\")\n</code></pre>"},{"location":"references/python_object_oriented/#4-composition-has-a-relationships","title":"4. Composition - \"Has-A\" Relationships","text":"<p>Composition builds objects by combining other objects:</p> <pre><code>from typing import List, Optional, Dict\nfrom datetime import datetime, timedelta\nfrom enum import Enum\n\nclass OrderStatus(Enum):\n    PENDING = \"pending\"\n    PREPARING = \"preparing\"\n    READY = \"ready\"\n    DELIVERED = \"delivered\"\n    CANCELLED = \"cancelled\"\n\nclass OrderItem:\n    \"\"\"Represents one item in an order.\"\"\"\n\n    def __init__(self, menu_item: MenuItem, quantity: int = 1,\n                 special_instructions: str = \"\"):\n        self.menu_item = menu_item\n        self.quantity = quantity\n        self.special_instructions = special_instructions\n        self.unit_price = menu_item.price\n        self.created_at = datetime.now()\n\n    def get_total_price(self) -&gt; float:\n        \"\"\"Calculate total price for this item.\"\"\"\n        return self.unit_price * self.quantity\n\n    def get_preparation_time(self) -&gt; int:\n        \"\"\"Calculate total preparation time.\"\"\"\n        return self.menu_item.calculate_preparation_time() * self.quantity\n\n    def __str__(self) -&gt; str:\n        special = f\" ({self.special_instructions})\" if self.special_instructions else \"\"\n        return f\"{self.quantity}x {self.menu_item.name}{special} - ${self.get_total_price():.2f}\"\n\nclass Order:\n    \"\"\"Order composed of multiple order items, customer, and status.\"\"\"\n\n    def __init__(self, customer: Customer, order_id: str = None):\n        self.customer = customer              # Composition: Order HAS-A Customer\n        self.order_id = order_id or self._generate_id()\n        self.items: List[OrderItem] = []      # Composition: Order HAS-MANY OrderItems\n        self.status = OrderStatus.PENDING\n        self.created_at = datetime.now()\n        self.estimated_ready_time: Optional[datetime] = None\n        self.discount_percentage = 0.0\n        self.tax_rate = 0.08  # 8% tax\n\n    def add_item(self, menu_item: MenuItem, quantity: int = 1,\n                 special_instructions: str = \"\") -&gt; None:\n        \"\"\"Add an item to the order.\"\"\"\n        order_item = OrderItem(menu_item, quantity, special_instructions)\n        self.items.append(order_item)\n        self._update_estimated_time()\n\n    def remove_item(self, item_index: int) -&gt; bool:\n        \"\"\"Remove an item from the order.\"\"\"\n        if 0 &lt;= item_index &lt; len(self.items):\n            del self.items[item_index]\n            self._update_estimated_time()\n            return True\n        return False\n\n    def apply_discount(self, percentage: float) -&gt; None:\n        \"\"\"Apply discount to the entire order.\"\"\"\n        if 0 &lt;= percentage &lt;= 50:  # Max 50% discount\n            self.discount_percentage = percentage\n\n    def calculate_subtotal(self) -&gt; float:\n        \"\"\"Calculate order subtotal.\"\"\"\n        return sum(item.get_total_price() for item in self.items)\n\n    def calculate_discount_amount(self) -&gt; float:\n        \"\"\"Calculate discount amount.\"\"\"\n        return self.calculate_subtotal() * (self.discount_percentage / 100)\n\n    def calculate_tax_amount(self) -&gt; float:\n        \"\"\"Calculate tax amount.\"\"\"\n        subtotal_after_discount = self.calculate_subtotal() - self.calculate_discount_amount()\n        return subtotal_after_discount * self.tax_rate\n\n    def calculate_total(self) -&gt; float:\n        \"\"\"Calculate final total.\"\"\"\n        subtotal = self.calculate_subtotal()\n        discount = self.calculate_discount_amount()\n        tax = self.calculate_tax_amount()\n        return subtotal - discount + tax\n\n    def update_status(self, new_status: OrderStatus) -&gt; None:\n        \"\"\"Update order status.\"\"\"\n        self.status = new_status\n        if new_status == OrderStatus.PREPARING:\n            self._update_estimated_time()\n\n    def _generate_id(self) -&gt; str:\n        \"\"\"Generate unique order ID.\"\"\"\n        import uuid\n        return f\"ORD-{str(uuid.uuid4())[:8].upper()}\"\n\n    def _update_estimated_time(self) -&gt; None:\n        \"\"\"Calculate estimated ready time based on items.\"\"\"\n        if not self.items:\n            self.estimated_ready_time = None\n            return\n\n        total_prep_time = sum(item.get_preparation_time() for item in self.items)\n        # Add buffer time for coordination\n        total_prep_time += 5\n        self.estimated_ready_time = datetime.now() + timedelta(minutes=total_prep_time)\n\n    def get_receipt(self) -&gt; str:\n        \"\"\"Generate order receipt.\"\"\"\n        lines = [\n            f\"=== Mario's Pizzeria Receipt ===\",\n            f\"Order ID: {self.order_id}\",\n            f\"Customer: {self.customer.name}\",\n            f\"Date: {self.created_at.strftime('%Y-%m-%d %H:%M')}\",\n            f\"Status: {self.status.value.title()}\",\n            \"\",\n            \"Items:\"\n        ]\n\n        for i, item in enumerate(self.items, 1):\n            lines.append(f\"  {i}. {item}\")\n\n        lines.extend([\n            \"\",\n            f\"Subtotal: ${self.calculate_subtotal():.2f}\",\n            f\"Discount ({self.discount_percentage}%): -${self.calculate_discount_amount():.2f}\",\n            f\"Tax: ${self.calculate_tax_amount():.2f}\",\n            f\"TOTAL: ${self.calculate_total():.2f}\"\n        ])\n\n        if self.estimated_ready_time:\n            lines.append(f\"Estimated ready: {self.estimated_ready_time.strftime('%H:%M')}\")\n\n        return \"\\n\".join(lines)\n\n# Kitchen class that manages orders\nclass Kitchen:\n    \"\"\"Kitchen that processes orders - composed of orders and equipment.\"\"\"\n\n    def __init__(self, max_concurrent_orders: int = 10):\n        self.active_orders: List[Order] = []    # Composition: Kitchen HAS-MANY Orders\n        self.completed_orders: List[Order] = []\n        self.max_concurrent_orders = max_concurrent_orders\n        self.equipment = {                      # Composition: Kitchen HAS equipment\n            \"ovens\": 3,\n            \"prep_stations\": 5,\n            \"fryers\": 2\n        }\n\n    def accept_order(self, order: Order) -&gt; bool:\n        \"\"\"Accept an order if kitchen has capacity.\"\"\"\n        if len(self.active_orders) &lt; self.max_concurrent_orders:\n            order.update_status(OrderStatus.PREPARING)\n            self.active_orders.append(order)\n            return True\n        return False\n\n    def complete_order(self, order_id: str) -&gt; Optional[Order]:\n        \"\"\"Mark an order as complete.\"\"\"\n        for i, order in enumerate(self.active_orders):\n            if order.order_id == order_id:\n                order.update_status(OrderStatus.READY)\n                completed_order = self.active_orders.pop(i)\n                self.completed_orders.append(completed_order)\n                return completed_order\n        return None\n\n    def get_queue_status(self) -&gt; Dict[str, any]:\n        \"\"\"Get kitchen queue status.\"\"\"\n        return {\n            \"active_orders\": len(self.active_orders),\n            \"max_capacity\": self.max_concurrent_orders,\n            \"queue_full\": len(self.active_orders) &gt;= self.max_concurrent_orders,\n            \"estimated_wait_minutes\": len(self.active_orders) * 3  # Rough estimate\n        }\n\n# Usage example showing composition:\ndef demonstrate_composition():\n    \"\"\"Show how objects work together through composition.\"\"\"\n\n    # Create components\n    customer = Customer(\"Luigi\", \"luigi@email.com\")\n    kitchen = Kitchen(max_concurrent_orders=5)\n\n    # Create menu items\n    margherita = Pizza(\"Margherita\", 12.99, \"Classic pizza\",\n                      [\"tomato\", \"mozzarella\", \"basil\"])\n    coke = Drink(\"Coke\", 2.99, \"Soft drink\")\n    tiramisu = Dessert(\"Tiramisu\", 6.99, \"Italian dessert\")\n\n    # Create order (composition in action)\n    order = Order(customer)  # Order contains Customer\n    order.add_item(margherita, quantity=2, special_instructions=\"Extra cheese\")\n    order.add_item(coke, quantity=2)\n    order.add_item(tiramisu, quantity=1)\n\n    # Apply discount for loyalty customer\n    if customer.loyalty_points &gt; 50:\n        order.apply_discount(10)\n\n    print(order.get_receipt())\n    print()\n\n    # Kitchen processes the order\n    if kitchen.accept_order(order):\n        print(f\"\u2705 Order {order.order_id} accepted by kitchen\")\n        print(f\"Kitchen status: {kitchen.get_queue_status()}\")\n\n        # Simulate completing the order\n        completed_order = kitchen.complete_order(order.order_id)\n        if completed_order:\n            print(f\"\u2705 Order {completed_order.order_id} is ready!\")\n            customer.place_order(completed_order)  # Customer gets loyalty points\n            print(f\"Customer {customer.name} now has {customer.loyalty_points} loyalty points\")\n    else:\n        print(f\"\u274c Kitchen is full, cannot accept order {order.order_id}\")\n\n# Run the demonstration\ndemonstrate_composition()\n</code></pre>"},{"location":"references/python_object_oriented/#oop-in-neuroglia-framework","title":"\ud83c\udfd7\ufe0f OOP in Neuroglia Framework","text":""},{"location":"references/python_object_oriented/#entity-base-classes","title":"Entity Base Classes","text":"<p>The framework uses OOP extensively for domain entities:</p> <pre><code>from abc import ABC, abstractmethod\nfrom typing import List, Any, Dict\nfrom datetime import datetime\nimport uuid\n\nclass Entity(ABC):\n    \"\"\"Base class for all domain entities.\"\"\"\n\n    def __init__(self, id: str = None):\n        self.id = id or str(uuid.uuid4())\n        self.created_at = datetime.now()\n        self.updated_at = datetime.now()\n        self._domain_events: List['DomainEvent'] = []\n\n    def raise_event(self, event: 'DomainEvent') -&gt; None:\n        \"\"\"Raise a domain event.\"\"\"\n        self._domain_events.append(event)\n\n    def get_uncommitted_events(self) -&gt; List['DomainEvent']:\n        \"\"\"Get events that haven't been processed yet.\"\"\"\n        return self._domain_events.copy()\n\n    def mark_events_as_committed(self) -&gt; None:\n        \"\"\"Mark all events as processed.\"\"\"\n        self._domain_events.clear()\n\n    def update_timestamp(self) -&gt; None:\n        \"\"\"Update the entity's last modified timestamp.\"\"\"\n        self.updated_at = datetime.now()\n\n    def __eq__(self, other) -&gt; bool:\n        \"\"\"Two entities are equal if they have the same ID and type.\"\"\"\n        return isinstance(other, self.__class__) and self.id == other.id\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Hash based on entity ID.\"\"\"\n        return hash(self.id)\n\n# Domain entities inherit from Entity\nclass Pizza(Entity):\n    \"\"\"Pizza domain entity with business logic.\"\"\"\n\n    def __init__(self, name: str, price: float, ingredients: List[str], id: str = None):\n        super().__init__(id)\n        self.name = name\n        self.price = price\n        self.ingredients = ingredients.copy()\n        self.is_available = True\n\n        # Raise domain event\n        self.raise_event(PizzaCreatedEvent(self.id, self.name))\n\n    def add_ingredient(self, ingredient: str) -&gt; None:\n        \"\"\"Add ingredient with business rules.\"\"\"\n        if len(self.ingredients) &gt;= 10:\n            raise ValueError(\"Pizza cannot have more than 10 ingredients\")\n\n        if ingredient not in self.ingredients:\n            self.ingredients.append(ingredient)\n            self.price += 1.50  # Business rule: each extra ingredient costs $1.50\n            self.update_timestamp()\n            self.raise_event(PizzaIngredientAddedEvent(self.id, ingredient))\n\n    def change_price(self, new_price: float) -&gt; None:\n        \"\"\"Change price with validation.\"\"\"\n        if new_price &lt; 5.0:\n            raise ValueError(\"Pizza price cannot be less than $5.00\")\n\n        old_price = self.price\n        self.price = new_price\n        self.update_timestamp()\n        self.raise_event(PizzaPriceChangedEvent(self.id, old_price, new_price))\n\n    def discontinue(self) -&gt; None:\n        \"\"\"Discontinue the pizza.\"\"\"\n        self.is_available = False\n        self.update_timestamp()\n        self.raise_event(PizzaDiscontinuedEvent(self.id, self.name))\n\nclass Customer(Entity):\n    \"\"\"Customer domain entity.\"\"\"\n\n    def __init__(self, name: str, email: str, id: str = None):\n        super().__init__(id)\n        self.name = name\n        self.email = email\n        self.loyalty_points = 0\n        self.total_orders = 0\n\n        self.raise_event(CustomerRegisteredEvent(self.id, self.name, self.email))\n\n    def place_order(self, order_total: float) -&gt; None:\n        \"\"\"Process an order and update customer state.\"\"\"\n        self.total_orders += 1\n        points_earned = int(order_total)  # 1 point per dollar\n        self.loyalty_points += points_earned\n        self.update_timestamp()\n\n        self.raise_event(OrderPlacedEvent(self.id, order_total, points_earned))\n\n        # Check for loyalty tier changes\n        if self.total_orders == 5:\n            self.raise_event(CustomerPromotedEvent(self.id, \"Bronze\"))\n        elif self.total_orders == 15:\n            self.raise_event(CustomerPromotedEvent(self.id, \"Silver\"))\n        elif self.total_orders == 30:\n            self.raise_event(CustomerPromotedEvent(self.id, \"Gold\"))\n</code></pre>"},{"location":"references/python_object_oriented/#repository-pattern-with-inheritance","title":"Repository Pattern with Inheritance","text":"<pre><code>from abc import ABC, abstractmethod\nfrom typing import Generic, TypeVar, Optional, List\n\nTEntity = TypeVar('TEntity', bound=Entity)\nTId = TypeVar('TId')\n\nclass Repository(Generic[TEntity, TId], ABC):\n    \"\"\"Abstract repository pattern.\"\"\"\n\n    @abstractmethod\n    async def get_by_id_async(self, id: TId) -&gt; Optional[TEntity]:\n        \"\"\"Get entity by ID.\"\"\"\n        pass\n\n    @abstractmethod\n    async def save_async(self, entity: TEntity) -&gt; None:\n        \"\"\"Save entity.\"\"\"\n        pass\n\n    @abstractmethod\n    async def delete_async(self, id: TId) -&gt; bool:\n        \"\"\"Delete entity.\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_all_async(self) -&gt; List[TEntity]:\n        \"\"\"Get all entities.\"\"\"\n        pass\n\n# Concrete repository implementations\nclass InMemoryRepository(Repository[TEntity, str]):\n    \"\"\"In-memory repository implementation.\"\"\"\n\n    def __init__(self):\n        self._entities: Dict[str, TEntity] = {}\n\n    async def get_by_id_async(self, id: str) -&gt; Optional[TEntity]:\n        return self._entities.get(id)\n\n    async def save_async(self, entity: TEntity) -&gt; None:\n        self._entities[entity.id] = entity\n        # Publish domain events\n        await self._publish_events(entity)\n\n    async def delete_async(self, id: str) -&gt; bool:\n        if id in self._entities:\n            del self._entities[id]\n            return True\n        return False\n\n    async def get_all_async(self) -&gt; List[TEntity]:\n        return list(self._entities.values())\n\n    async def _publish_events(self, entity: TEntity) -&gt; None:\n        \"\"\"Publish domain events from entity.\"\"\"\n        events = entity.get_uncommitted_events()\n        for event in events:\n            # Publish to event bus\n            await self._event_bus.publish_async(event)\n        entity.mark_events_as_committed()\n\nclass PizzaRepository(InMemoryRepository[Pizza]):\n    \"\"\"Specialized pizza repository.\"\"\"\n\n    async def get_available_pizzas_async(self) -&gt; List[Pizza]:\n        \"\"\"Get only available pizzas.\"\"\"\n        all_pizzas = await self.get_all_async()\n        return [pizza for pizza in all_pizzas if pizza.is_available]\n\n    async def get_pizzas_by_ingredient_async(self, ingredient: str) -&gt; List[Pizza]:\n        \"\"\"Find pizzas containing a specific ingredient.\"\"\"\n        all_pizzas = await self.get_all_async()\n        return [pizza for pizza in all_pizzas\n                if ingredient in pizza.ingredients and pizza.is_available]\n\n    async def get_pizzas_in_price_range_async(self, min_price: float, max_price: float) -&gt; List[Pizza]:\n        \"\"\"Find pizzas within a price range.\"\"\"\n        all_pizzas = await self.get_all_async()\n        return [pizza for pizza in all_pizzas\n                if min_price &lt;= pizza.price &lt;= max_price and pizza.is_available]\n</code></pre>"},{"location":"references/python_object_oriented/#command-and-query-handlers-with-inheritance","title":"Command and Query Handlers with Inheritance","text":"<pre><code>from abc import ABC, abstractmethod\nfrom typing import Generic, TypeVar\n\nTCommand = TypeVar('TCommand')\nTQuery = TypeVar('TQuery')\nTResult = TypeVar('TResult')\n\nclass CommandHandler(Generic[TCommand, TResult], ABC):\n    \"\"\"Base class for command handlers.\"\"\"\n\n    @abstractmethod\n    async def handle_async(self, command: TCommand) -&gt; TResult:\n        \"\"\"Handle the command.\"\"\"\n        pass\n\nclass QueryHandler(Generic[TQuery, TResult], ABC):\n    \"\"\"Base class for query handlers.\"\"\"\n\n    @abstractmethod\n    async def handle_async(self, query: TQuery) -&gt; TResult:\n        \"\"\"Handle the query.\"\"\"\n        pass\n\n# Specific handlers inherit from base classes\nclass CreatePizzaHandler(CommandHandler[CreatePizzaCommand, Pizza]):\n    \"\"\"Handler for creating pizzas.\"\"\"\n\n    def __init__(self, repository: PizzaRepository, validator: 'PizzaValidator'):\n        self._repository = repository\n        self._validator = validator\n\n    async def handle_async(self, command: CreatePizzaCommand) -&gt; Pizza:\n        \"\"\"Create and save a new pizza.\"\"\"\n        # Validation\n        validation_result = await self._validator.validate_async(command)\n        if not validation_result.is_valid:\n            raise ValidationError(validation_result.errors)\n\n        # Create pizza entity\n        pizza = Pizza(\n            name=command.name,\n            price=command.price,\n            ingredients=command.ingredients\n        )\n\n        # Save to repository\n        await self._repository.save_async(pizza)\n\n        return pizza\n\nclass GetAvailablePizzasHandler(QueryHandler[GetAvailablePizzasQuery, List[Pizza]]):\n    \"\"\"Handler for getting available pizzas.\"\"\"\n\n    def __init__(self, repository: PizzaRepository):\n        self._repository = repository\n\n    async def handle_async(self, query: GetAvailablePizzasQuery) -&gt; List[Pizza]:\n        \"\"\"Get all available pizzas.\"\"\"\n        return await self._repository.get_available_pizzas_async()\n\nclass GetPizzasByIngredientHandler(QueryHandler[GetPizzasByIngredientQuery, List[Pizza]]):\n    \"\"\"Handler for finding pizzas by ingredient.\"\"\"\n\n    def __init__(self, repository: PizzaRepository):\n        self._repository = repository\n\n    async def handle_async(self, query: GetPizzasByIngredientQuery) -&gt; List[Pizza]:\n        \"\"\"Find pizzas containing the specified ingredient.\"\"\"\n        return await self._repository.get_pizzas_by_ingredient_async(query.ingredient)\n</code></pre>"},{"location":"references/python_object_oriented/#advanced-oop-patterns","title":"\ud83c\udfa8 Advanced OOP Patterns","text":""},{"location":"references/python_object_oriented/#abstract-factory-pattern","title":"Abstract Factory Pattern","text":"<pre><code>from abc import ABC, abstractmethod\nfrom enum import Enum\n\nclass PizzaStyle(Enum):\n    ITALIAN = \"italian\"\n    AMERICAN = \"american\"\n    CHICAGO = \"chicago\"\n\nclass PizzaFactory(ABC):\n    \"\"\"Abstract factory for creating different styles of pizzas.\"\"\"\n\n    @abstractmethod\n    def create_margherita(self) -&gt; Pizza:\n        pass\n\n    @abstractmethod\n    def create_pepperoni(self) -&gt; Pizza:\n        pass\n\n    @abstractmethod\n    def create_supreme(self) -&gt; Pizza:\n        pass\n\nclass ItalianPizzaFactory(PizzaFactory):\n    \"\"\"Factory for authentic Italian-style pizzas.\"\"\"\n\n    def create_margherita(self) -&gt; Pizza:\n        return Pizza(\n            name=\"Margherita Italiana\",\n            price=15.99,\n            ingredients=[\"San Marzano tomatoes\", \"Buffalo mozzarella\", \"Fresh basil\", \"Extra virgin olive oil\"]\n        )\n\n    def create_pepperoni(self) -&gt; Pizza:\n        return Pizza(\n            name=\"Diavola\",\n            price=17.99,\n            ingredients=[\"San Marzano tomatoes\", \"Mozzarella di bufala\", \"Spicy salami\", \"Chili flakes\"]\n        )\n\n    def create_supreme(self) -&gt; Pizza:\n        return Pizza(\n            name=\"Quattro Stagioni\",\n            price=19.99,\n            ingredients=[\"Tomato sauce\", \"Mozzarella\", \"Prosciutto\", \"Mushrooms\", \"Artichokes\", \"Olives\"]\n        )\n\nclass AmericanPizzaFactory(PizzaFactory):\n    \"\"\"Factory for American-style pizzas.\"\"\"\n\n    def create_margherita(self) -&gt; Pizza:\n        return Pizza(\n            name=\"Classic Margherita\",\n            price=12.99,\n            ingredients=[\"Tomato sauce\", \"Mozzarella cheese\", \"Dried basil\"]\n        )\n\n    def create_pepperoni(self) -&gt; Pizza:\n        return Pizza(\n            name=\"Pepperoni Classic\",\n            price=14.99,\n            ingredients=[\"Tomato sauce\", \"Mozzarella cheese\", \"Pepperoni\"]\n        )\n\n    def create_supreme(self) -&gt; Pizza:\n        return Pizza(\n            name=\"Supreme Deluxe\",\n            price=18.99,\n            ingredients=[\"Tomato sauce\", \"Mozzarella\", \"Pepperoni\", \"Sausage\", \"Bell peppers\", \"Onions\", \"Mushrooms\"]\n        )\n\n# Factory selector\nclass PizzaFactoryProvider:\n    \"\"\"Provides the appropriate pizza factory based on style.\"\"\"\n\n    @staticmethod\n    def get_factory(style: PizzaStyle) -&gt; PizzaFactory:\n        \"\"\"Get the appropriate factory for the pizza style.\"\"\"\n        factories = {\n            PizzaStyle.ITALIAN: ItalianPizzaFactory(),\n            PizzaStyle.AMERICAN: AmericanPizzaFactory(),\n            # PizzaStyle.CHICAGO: ChicagoPizzaFactory(),  # Could add more\n        }\n\n        if style not in factories:\n            raise ValueError(f\"Unsupported pizza style: {style}\")\n\n        return factories[style]\n\n# Usage\ndef demonstrate_factory_pattern():\n    \"\"\"Show how factory pattern works.\"\"\"\n\n    # Customer chooses style\n    chosen_style = PizzaStyle.ITALIAN\n    factory = PizzaFactoryProvider.get_factory(chosen_style)\n\n    # Create pizzas using the appropriate factory\n    margherita = factory.create_margherita()\n    pepperoni = factory.create_pepperoni()\n    supreme = factory.create_supreme()\n\n    print(f\"=== {chosen_style.value.title()} Style Pizzas ===\")\n    print(f\"Margherita: {margherita.name} - ${margherita.price}\")\n    print(f\"Pepperoni: {pepperoni.name} - ${pepperoni.price}\")\n    print(f\"Supreme: {supreme.name} - ${supreme.price}\")\n</code></pre>"},{"location":"references/python_object_oriented/#strategy-pattern","title":"Strategy Pattern","text":"<pre><code>from abc import ABC, abstractmethod\n\nclass PricingStrategy(ABC):\n    \"\"\"Abstract strategy for pizza pricing.\"\"\"\n\n    @abstractmethod\n    def calculate_price(self, base_price: float, pizza: Pizza) -&gt; float:\n        pass\n\nclass RegularPricingStrategy(PricingStrategy):\n    \"\"\"Standard pricing - no modifications.\"\"\"\n\n    def calculate_price(self, base_price: float, pizza: Pizza) -&gt; float:\n        return base_price\n\nclass HappyHourPricingStrategy(PricingStrategy):\n    \"\"\"Happy hour pricing - 20% discount.\"\"\"\n\n    def calculate_price(self, base_price: float, pizza: Pizza) -&gt; float:\n        return base_price * 0.8\n\nclass LoyaltyPricingStrategy(PricingStrategy):\n    \"\"\"Loyalty customer pricing - discount based on ingredients.\"\"\"\n\n    def __init__(self, loyalty_level: str):\n        self.loyalty_level = loyalty_level\n        self.discounts = {\n            \"bronze\": 0.05,  # 5% discount\n            \"silver\": 0.10,  # 10% discount\n            \"gold\": 0.15     # 15% discount\n        }\n\n    def calculate_price(self, base_price: float, pizza: Pizza) -&gt; float:\n        discount = self.discounts.get(self.loyalty_level.lower(), 0)\n        return base_price * (1 - discount)\n\nclass GroupOrderPricingStrategy(PricingStrategy):\n    \"\"\"Group order pricing - bulk discount.\"\"\"\n\n    def __init__(self, order_quantity: int):\n        self.order_quantity = order_quantity\n\n    def calculate_price(self, base_price: float, pizza: Pizza) -&gt; float:\n        if self.order_quantity &gt;= 5:\n            return base_price * 0.85  # 15% discount for 5+ pizzas\n        elif self.order_quantity &gt;= 3:\n            return base_price * 0.90  # 10% discount for 3+ pizzas\n        return base_price\n\nclass PizzaPricer:\n    \"\"\"Context class that uses pricing strategies.\"\"\"\n\n    def __init__(self, strategy: PricingStrategy):\n        self._strategy = strategy\n\n    def set_strategy(self, strategy: PricingStrategy) -&gt; None:\n        \"\"\"Change pricing strategy at runtime.\"\"\"\n        self._strategy = strategy\n\n    def calculate_pizza_price(self, pizza: Pizza) -&gt; float:\n        \"\"\"Calculate pizza price using current strategy.\"\"\"\n        return self._strategy.calculate_price(pizza.price, pizza)\n\n    def calculate_order_total(self, pizzas: List[Pizza]) -&gt; float:\n        \"\"\"Calculate total for multiple pizzas.\"\"\"\n        return sum(self.calculate_pizza_price(pizza) for pizza in pizzas)\n\n# Usage example\ndef demonstrate_strategy_pattern():\n    \"\"\"Show how strategy pattern works.\"\"\"\n\n    # Create some pizzas\n    margherita = Pizza(\"Margherita\", 12.99, [\"tomato\", \"mozzarella\", \"basil\"])\n    pepperoni = Pizza(\"Pepperoni\", 14.99, [\"tomato\", \"mozzarella\", \"pepperoni\"])\n    pizzas = [margherita, pepperoni]\n\n    # Different pricing strategies\n    regular_pricer = PizzaPricer(RegularPricingStrategy())\n    happy_hour_pricer = PizzaPricer(HappyHourPricingStrategy())\n    loyalty_pricer = PizzaPricer(LoyaltyPricingStrategy(\"gold\"))\n    group_pricer = PizzaPricer(GroupOrderPricingStrategy(order_quantity=5))\n\n    print(\"=== Pizza Pricing Comparison ===\")\n    print(f\"Regular pricing: ${regular_pricer.calculate_order_total(pizzas):.2f}\")\n    print(f\"Happy hour pricing: ${happy_hour_pricer.calculate_order_total(pizzas):.2f}\")\n    print(f\"Gold loyalty pricing: ${loyalty_pricer.calculate_order_total(pizzas):.2f}\")\n    print(f\"Group order pricing: ${group_pricer.calculate_order_total(pizzas):.2f}\")\n\n    # Strategy can be changed at runtime\n    pricer = PizzaPricer(RegularPricingStrategy())\n    print(f\"\\nUsing initial strategy: ${pricer.calculate_order_total(pizzas):.2f}\")\n\n    pricer.set_strategy(HappyHourPricingStrategy())\n    print(f\"After switching to happy hour: ${pricer.calculate_order_total(pizzas):.2f}\")\n</code></pre>"},{"location":"references/python_object_oriented/#testing-oop-code","title":"\ud83e\uddea Testing OOP Code","text":"<p>Testing object-oriented code requires understanding inheritance and composition:</p> <pre><code>import pytest\nfrom unittest.mock import Mock, patch\nfrom typing import List\n\nclass TestPizza:\n    \"\"\"Test the Pizza entity class.\"\"\"\n\n    def setup_method(self):\n        \"\"\"Setup for each test method.\"\"\"\n        self.pizza = Pizza(\"Test Pizza\", 10.0, [\"cheese\", \"tomato\"])\n\n    def test_pizza_creation(self):\n        \"\"\"Test pizza object creation.\"\"\"\n        assert self.pizza.name == \"Test Pizza\"\n        assert self.pizza.price == 10.0\n        assert self.pizza.ingredients == [\"cheese\", \"tomato\"]\n        assert self.pizza.is_available == True\n        assert self.pizza.id is not None\n\n    def test_add_ingredient(self):\n        \"\"\"Test adding ingredient to pizza.\"\"\"\n        self.pizza.add_ingredient(\"pepperoni\")\n\n        assert \"pepperoni\" in self.pizza.ingredients\n        assert self.pizza.price == 11.50  # Original price + $1.50\n        assert len(self.pizza.get_uncommitted_events()) == 2  # Created + Ingredient added\n\n    def test_add_ingredient_duplicate(self):\n        \"\"\"Test adding duplicate ingredient doesn't change price.\"\"\"\n        original_price = self.pizza.price\n        self.pizza.add_ingredient(\"cheese\")  # Already exists\n\n        assert self.pizza.price == original_price\n        assert self.pizza.ingredients.count(\"cheese\") == 1\n\n    def test_add_too_many_ingredients(self):\n        \"\"\"Test business rule: max 10 ingredients.\"\"\"\n        # Add 8 more ingredients (already has 2)\n        for i in range(8):\n            self.pizza.add_ingredient(f\"ingredient_{i}\")\n\n        # Adding 9th should fail\n        with pytest.raises(ValueError, match=\"cannot have more than 10 ingredients\"):\n            self.pizza.add_ingredient(\"too_many\")\n\n    def test_change_price(self):\n        \"\"\"Test price change with validation.\"\"\"\n        self.pizza.change_price(15.99)\n\n        assert self.pizza.price == 15.99\n        events = self.pizza.get_uncommitted_events()\n        price_change_events = [e for e in events if isinstance(e, PizzaPriceChangedEvent)]\n        assert len(price_change_events) == 1\n\n    def test_change_price_too_low(self):\n        \"\"\"Test price validation.\"\"\"\n        with pytest.raises(ValueError, match=\"cannot be less than\"):\n            self.pizza.change_price(3.0)\n\n    def test_discontinue(self):\n        \"\"\"Test discontinuing pizza.\"\"\"\n        self.pizza.discontinue()\n\n        assert self.pizza.is_available == False\n        events = self.pizza.get_uncommitted_events()\n        discontinue_events = [e for e in events if isinstance(e, PizzaDiscontinuedEvent)]\n        assert len(discontinue_events) == 1\n\nclass TestOrder:\n    \"\"\"Test the Order composition class.\"\"\"\n\n    def setup_method(self):\n        \"\"\"Setup for each test method.\"\"\"\n        self.customer = Customer(\"Test Customer\", \"test@example.com\")\n        self.order = Order(self.customer)\n        self.pizza = Pizza(\"Test Pizza\", 12.99, [\"cheese\", \"tomato\"])\n        self.drink = Drink(\"Coke\", 2.99, \"Soft drink\")\n\n    def test_order_creation(self):\n        \"\"\"Test order object creation.\"\"\"\n        assert self.order.customer == self.customer\n        assert self.order.order_id is not None\n        assert len(self.order.items) == 0\n        assert self.order.status == OrderStatus.PENDING\n\n    def test_add_item(self):\n        \"\"\"Test adding items to order.\"\"\"\n        self.order.add_item(self.pizza, quantity=2)\n        self.order.add_item(self.drink, quantity=1)\n\n        assert len(self.order.items) == 2\n        assert self.order.items[0].quantity == 2\n        assert self.order.items[1].quantity == 1\n        assert self.order.estimated_ready_time is not None\n\n    def test_calculate_totals(self):\n        \"\"\"Test order total calculations.\"\"\"\n        self.order.add_item(self.pizza, quantity=2)  # 2 * 12.99 = 25.98\n        self.order.add_item(self.drink, quantity=1)  # 1 * 2.99 = 2.99\n\n        subtotal = self.order.calculate_subtotal()\n        assert subtotal == 28.97\n\n        self.order.apply_discount(10)  # 10% discount\n        discount = self.order.calculate_discount_amount()\n        assert discount == 2.897  # 10% of 28.97\n\n        tax = self.order.calculate_tax_amount()\n        expected_tax = (28.97 - 2.897) * 0.08  # 8% tax on discounted amount\n        assert abs(tax - expected_tax) &lt; 0.01\n\n    def test_remove_item(self):\n        \"\"\"Test removing items from order.\"\"\"\n        self.order.add_item(self.pizza)\n        self.order.add_item(self.drink)\n\n        removed = self.order.remove_item(0)  # Remove first item\n\n        assert removed == True\n        assert len(self.order.items) == 1\n        assert self.order.items[0].menu_item == self.drink\n\nclass TestPizzaRepository:\n    \"\"\"Test the repository with inheritance and composition.\"\"\"\n\n    def setup_method(self):\n        \"\"\"Setup for each test method.\"\"\"\n        self.repository = PizzaRepository()\n        self.pizza1 = Pizza(\"Margherita\", 12.99, [\"tomato\", \"mozzarella\"])\n        self.pizza2 = Pizza(\"Pepperoni\", 14.99, [\"tomato\", \"mozzarella\", \"pepperoni\"])\n        self.pizza2.is_available = False  # Discontinued\n\n    @pytest.mark.asyncio\n    async def test_save_and_retrieve(self):\n        \"\"\"Test saving and retrieving pizzas.\"\"\"\n        await self.repository.save_async(self.pizza1)\n\n        retrieved = await self.repository.get_by_id_async(self.pizza1.id)\n\n        assert retrieved is not None\n        assert retrieved.id == self.pizza1.id\n        assert retrieved.name == self.pizza1.name\n\n    @pytest.mark.asyncio\n    async def test_get_available_pizzas(self):\n        \"\"\"Test getting only available pizzas.\"\"\"\n        await self.repository.save_async(self.pizza1)  # Available\n        await self.repository.save_async(self.pizza2)  # Not available\n\n        available_pizzas = await self.repository.get_available_pizzas_async()\n\n        assert len(available_pizzas) == 1\n        assert available_pizzas[0].id == self.pizza1.id\n\n    @pytest.mark.asyncio\n    async def test_get_pizzas_by_ingredient(self):\n        \"\"\"Test finding pizzas by ingredient.\"\"\"\n        await self.repository.save_async(self.pizza1)\n        await self.repository.save_async(self.pizza2)\n\n        pizzas_with_pepperoni = await self.repository.get_pizzas_by_ingredient_async(\"pepperoni\")\n\n        # Should not include pizza2 because it's not available\n        assert len(pizzas_with_pepperoni) == 0\n\n        pizzas_with_mozzarella = await self.repository.get_pizzas_by_ingredient_async(\"mozzarella\")\n        assert len(pizzas_with_mozzarella) == 1  # Only available pizza1\n\nclass TestCommandHandlers:\n    \"\"\"Test command handlers with mocking.\"\"\"\n\n    def setup_method(self):\n        \"\"\"Setup for each test method.\"\"\"\n        self.mock_repository = Mock(spec=PizzaRepository)\n        self.mock_validator = Mock()\n        self.handler = CreatePizzaHandler(self.mock_repository, self.mock_validator)\n\n    @pytest.mark.asyncio\n    async def test_successful_pizza_creation(self):\n        \"\"\"Test successful pizza creation.\"\"\"\n        # Setup mocks\n        self.mock_validator.validate_async.return_value = Mock(is_valid=True)\n        self.mock_repository.save_async = Mock()\n\n        command = CreatePizzaCommand(\n            name=\"Test Pizza\",\n            price=12.99,\n            ingredients=[\"cheese\", \"tomato\"]\n        )\n\n        # Execute handler\n        result = await self.handler.handle_async(command)\n\n        # Verify results\n        assert isinstance(result, Pizza)\n        assert result.name == \"Test Pizza\"\n        assert result.price == 12.99\n\n        # Verify mocks were called\n        self.mock_validator.validate_async.assert_called_once_with(command)\n        self.mock_repository.save_async.assert_called_once()\n\n    @pytest.mark.asyncio\n    async def test_validation_failure(self):\n        \"\"\"Test handling validation errors.\"\"\"\n        # Setup mock to return validation failure\n        validation_result = Mock(is_valid=False, errors=[\"Invalid pizza name\"])\n        self.mock_validator.validate_async.return_value = validation_result\n\n        command = CreatePizzaCommand(name=\"\", price=12.99, ingredients=[])\n\n        # Should raise validation error\n        with pytest.raises(ValidationError):\n            await self.handler.handle_async(command)\n\n        # Repository should not be called\n        self.mock_repository.save_async.assert_not_called()\n</code></pre>"},{"location":"references/python_object_oriented/#best-practices-for-oop","title":"\ud83d\ude80 Best Practices for OOP","text":""},{"location":"references/python_object_oriented/#1-follow-solid-principles","title":"1. Follow SOLID Principles","text":"<pre><code># Single Responsibility Principle - each class has one job\nclass PizzaPriceCalculator:\n    \"\"\"Only responsible for price calculations.\"\"\"\n    def calculate_price(self, pizza: Pizza) -&gt; float:\n        pass\n\nclass PizzaValidator:\n    \"\"\"Only responsible for pizza validation.\"\"\"\n    def validate(self, pizza: Pizza) -&gt; ValidationResult:\n        pass\n\n# Open/Closed Principle - open for extension, closed for modification\nclass NotificationService(ABC):\n    @abstractmethod\n    async def send_notification(self, message: str, recipient: str) -&gt; None:\n        pass\n\nclass EmailNotificationService(NotificationService):\n    async def send_notification(self, message: str, recipient: str) -&gt; None:\n        # Email implementation\n        pass\n\nclass SmsNotificationService(NotificationService):\n    async def send_notification(self, message: str, recipient: str) -&gt; None:\n        # SMS implementation\n        pass\n\n# Liskov Substitution Principle - derived classes must be substitutable\ndef send_welcome_message(notification_service: NotificationService, customer: Customer):\n    # Works with any NotificationService implementation\n    await notification_service.send_notification(\n        f\"Welcome {customer.name}!\",\n        customer.email\n    )\n\n# Interface Segregation Principle - many specific interfaces\nclass Readable(Protocol):\n    def read(self) -&gt; str: ...\n\nclass Writable(Protocol):\n    def write(self, data: str) -&gt; None: ...\n\nclass ReadWritable(Readable, Writable, Protocol):\n    pass\n\n# Dependency Inversion Principle - depend on abstractions\nclass OrderService:\n    def __init__(self,\n                 repository: Repository[Order, str],  # Abstract dependency\n                 notifier: NotificationService):      # Abstract dependency\n        self._repository = repository\n        self._notifier = notifier\n</code></pre>"},{"location":"references/python_object_oriented/#2-use-composition-over-inheritance","title":"2. Use Composition over Inheritance","text":"<pre><code># \u2705 Good - composition\nclass Order:\n    def __init__(self, customer: Customer):\n        self.customer = customer          # HAS-A relationship\n        self.payment_method = None        # HAS-A relationship\n        self.items = []                   # HAS-A relationship\n\n# \u274c Avoid deep inheritance hierarchies\nclass Animal:\n    pass\n\nclass Mammal(Animal):\n    pass\n\nclass Carnivore(Mammal):\n    pass\n\nclass Feline(Carnivore):\n    pass\n\nclass Cat(Feline):  # Too deep!\n    pass\n</code></pre>"},{"location":"references/python_object_oriented/#3-keep-classes-focused-and-small","title":"3. Keep Classes Focused and Small","text":"<pre><code># \u2705 Good - focused class\nclass Pizza:\n    \"\"\"Represents a pizza with its properties and behaviors.\"\"\"\n    def __init__(self, name: str, price: float, ingredients: List[str]):\n        self.name = name\n        self.price = price\n        self.ingredients = ingredients\n\n    def add_ingredient(self, ingredient: str) -&gt; None:\n        \"\"\"Add ingredient to pizza.\"\"\"\n        pass\n\n    def calculate_cost(self) -&gt; float:\n        \"\"\"Calculate cost to make pizza.\"\"\"\n        pass\n\n# \u274c Bad - doing too much\nclass PizzaEverything:\n    \"\"\"Class that tries to do everything - violates SRP.\"\"\"\n    def create_pizza(self): pass\n    def save_to_database(self): pass\n    def send_email(self): pass\n    def process_payment(self): pass\n    def manage_inventory(self): pass\n    def generate_reports(self): pass\n</code></pre>"},{"location":"references/python_object_oriented/#4-use-properties-for-controlled-access","title":"4. Use Properties for Controlled Access","text":"<pre><code>class Customer:\n    def __init__(self, name: str, email: str):\n        self._name = name\n        self._email = email\n        self._loyalty_points = 0\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Get customer name.\"\"\"\n        return self._name\n\n    @property\n    def email(self) -&gt; str:\n        \"\"\"Get customer email.\"\"\"\n        return self._email\n\n    @email.setter\n    def email(self, value: str) -&gt; None:\n        \"\"\"Set email with validation.\"\"\"\n        if \"@\" not in value:\n            raise ValueError(\"Invalid email format\")\n        self._email = value\n\n    @property\n    def loyalty_points(self) -&gt; int:\n        \"\"\"Get loyalty points (read-only).\"\"\"\n        return self._loyalty_points\n\n    def add_loyalty_points(self, points: int) -&gt; None:\n        \"\"\"Add loyalty points through controlled method.\"\"\"\n        if points &gt; 0:\n            self._loyalty_points += points\n</code></pre>"},{"location":"references/python_object_oriented/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Python Typing Guide - Type safety, generics, and inheritance patterns</li> <li>Python Modular Code - Organizing classes across modules</li> <li>Dependency Injection - OOP with dependency management</li> <li>CQRS &amp; Mediation - Object-oriented command/query patterns</li> </ul>"},{"location":"references/python_object_oriented/#further-reading","title":"\ud83d\udcda Further Reading","text":"<ul> <li>Python Classes Documentation</li> <li>SOLID Principles in Python</li> <li>Design Patterns in Python</li> <li>Clean Code by Robert Martin</li> </ul>"},{"location":"references/python_typing_guide/","title":"\ud83c\udff7\ufe0f Python Typing Guide - Type Hints &amp; Generics","text":"<p>A comprehensive guide to Python type hints and generic types essential for understanding and working with the Neuroglia framework. They provide clarity, enable better IDE support, and help catch errors before runtime.</p>"},{"location":"references/python_typing_guide/#table-of-contents","title":"\ud83d\udcda Table of Contents","text":"<ol> <li>Type Hints Fundamentals</li> <li>Basic Type Annotations</li> <li>Advanced Type Hints</li> <li>Generic Types Fundamentals</li> <li>Core Generic Concepts</li> <li>Framework Integration</li> <li>Advanced Generic Patterns</li> <li>Testing with Types</li> <li>Type Checking Tools</li> <li>Best Practices</li> </ol>"},{"location":"references/python_typing_guide/#type-hints-fundamentals","title":"\ud83c\udfaf Type Hints Fundamentals","text":"<p>Type hints are optional annotations that specify what types of values functions, variables, and class attributes should have. They make your code more readable and help tools understand your intentions.</p>"},{"location":"references/python_typing_guide/#before-and-after-type-hints","title":"Before and After Type Hints","text":"<pre><code># Without type hints - unclear what types are expected:\ndef process_order(customer, items, discount):\n    total = 0\n    for item in items:\n        total += item[\"price\"] * item[\"quantity\"]\n\n    if discount:\n        total *= (1 - discount)\n\n    return {\n        \"customer\": customer,\n        \"total\": total,\n        \"items\": len(items)\n    }\n\n# With type hints - crystal clear what's expected:\nfrom typing import List, Dict, Optional\n\ndef process_order(\n    customer: str,\n    items: List[Dict[str, float]],\n    discount: Optional[float] = None\n) -&gt; Dict[str, any]:\n    total = 0.0\n    for item in items:\n        total += item[\"price\"] * item[\"quantity\"]\n\n    if discount:\n        total *= (1 - discount)\n\n    return {\n        \"customer\": customer,\n        \"total\": total,\n        \"items\": len(items)\n    }\n</code></pre>"},{"location":"references/python_typing_guide/#basic-type-annotations","title":"\ud83d\udd27 Basic Type Annotations","text":""},{"location":"references/python_typing_guide/#primitive-types","title":"Primitive Types","text":"<pre><code># Basic types:\nname: str = \"Mario\"\nage: int = 25\nprice: float = 12.99\nis_available: bool = True\n\n# Function parameters and return types:\ndef calculate_tax(amount: float, rate: float) -&gt; float:\n    return amount * rate\n\ndef greet_customer(name: str) -&gt; str:\n    return f\"Welcome to Mario's Pizzeria, {name}!\"\n\ndef is_pizza_large(diameter: int) -&gt; bool:\n    return diameter &gt;= 12\n</code></pre>"},{"location":"references/python_typing_guide/#collection-types","title":"Collection Types","text":"<pre><code>from typing import List, Dict, Set, Tuple\n\n# Lists - ordered collections of the same type:\npizza_names: List[str] = [\"Margherita\", \"Pepperoni\", \"Hawaiian\"]\nprices: List[float] = [12.99, 14.99, 13.49]\n\n# Dictionaries - key-value pairs:\npizza_menu: Dict[str, float] = {\n    \"Margherita\": 12.99,\n    \"Pepperoni\": 14.99,\n    \"Hawaiian\": 13.49\n}\n\n# Sets - unique collections:\navailable_toppings: Set[str] = {\"cheese\", \"pepperoni\", \"mushrooms\", \"olives\"}\n\n# Tuples - fixed-size collections:\nlocation: Tuple[float, float] = (40.7128, -74.0060)  # lat, lng\npizza_info: Tuple[str, float, List[str]] = (\n    \"Margherita\",\n    12.99,\n    [\"tomato\", \"mozzarella\", \"basil\"]\n)\n\n# Functions working with collections:\ndef get_most_expensive_pizza(menu: Dict[str, float]) -&gt; Tuple[str, float]:\n    name = max(menu, key=menu.get)\n    price = menu[name]\n    return name, price\n\ndef add_topping(toppings: Set[str], new_topping: str) -&gt; Set[str]:\n    toppings.add(new_topping)\n    return toppings\n</code></pre>"},{"location":"references/python_typing_guide/#advanced-type-hints","title":"\ud83c\udfa8 Advanced Type Hints","text":""},{"location":"references/python_typing_guide/#optional-types","title":"Optional Types","text":"<p>When a value might be <code>None</code>, use <code>Optional</code>:</p> <pre><code>from typing import Optional\n\n# Optional parameters:\ndef find_pizza_by_name(name: str, menu: Dict[str, float]) -&gt; Optional[float]:\n    \"\"\"Returns the price if pizza exists, None otherwise.\"\"\"\n    return menu.get(name)\n\n# Optional attributes:\nclass Customer:\n    def __init__(self, name: str, email: Optional[str] = None):\n        self.name: str = name\n        self.email: Optional[str] = email\n        self.phone: Optional[str] = None\n\n# Functions that might return None:\ndef get_customer_discount(customer_id: str) -&gt; Optional[float]:\n    # Database lookup logic here\n    if customer_exists(customer_id):\n        return 0.10  # 10% discount\n    return None\n\n# Using optional values safely:\ndiscount = get_customer_discount(\"12345\")\nif discount is not None:\n    discounted_price = original_price * (1 - discount)\nelse:\n    discounted_price = original_price\n</code></pre>"},{"location":"references/python_typing_guide/#union-types","title":"Union Types","text":"<p>When a value can be one of several types:</p> <pre><code>from typing import Union\n\n# A value that can be string or number:\nPizzaId = Union[str, int]\n\ndef get_pizza_details(pizza_id: PizzaId) -&gt; Dict[str, any]:\n    # Convert to string for consistent handling:\n    id_str = str(pizza_id)\n    # ... lookup logic\n    return pizza_details\n\n# Multiple possible return types:\ndef process_payment(amount: float) -&gt; Union[str, Dict[str, any]]:\n    if amount &lt;= 0:\n        return \"Invalid amount\"  # Error message\n\n    # Process payment...\n    return {\n        \"transaction_id\": \"TXN123\",\n        \"amount\": amount,\n        \"status\": \"completed\"\n    }\n\n# Modern Python 3.10+ syntax (preferred):\ndef process_payment_modern(amount: float) -&gt; str | Dict[str, any]:\n    # Same logic as above\n    pass\n</code></pre>"},{"location":"references/python_typing_guide/#callable-types","title":"Callable Types","text":"<p>For functions as parameters or return values:</p> <pre><code>from typing import Callable\n\n# Function that takes a function as parameter:\ndef apply_discount(\n    price: float,\n    discount_function: Callable[[float], float]\n) -&gt; float:\n    return discount_function(price)\n\n# Different discount strategies:\ndef student_discount(price: float) -&gt; float:\n    return price * 0.9  # 10% off\n\ndef loyalty_discount(price: float) -&gt; float:\n    return price * 0.85  # 15% off\n\n# Usage:\noriginal_price = 12.99\nstudent_price = apply_discount(original_price, student_discount)\nloyalty_price = apply_discount(original_price, loyalty_discount)\n\n# More complex callable signatures:\nProcessorFunction = Callable[[str, List[str]], Dict[str, any]]\n\ndef process_pizza_order(\n    pizza_name: str,\n    toppings: List[str],\n    processor: ProcessorFunction\n) -&gt; Dict[str, any]:\n    return processor(pizza_name, toppings)\n</code></pre>"},{"location":"references/python_typing_guide/#generic-types-fundamentals","title":"\ud83e\uddec Generic Types Fundamentals","text":"<p>Understanding generics is crucial for working with the Neuroglia framework, as they provide type safety and flexibility throughout the architecture.</p>"},{"location":"references/python_typing_guide/#what-are-generic-types","title":"What Are Generic Types?","text":"<p>Generic types allow you to write code that works with different types while maintaining type safety. Think of them as \"type parameters\" that get filled in later.</p>"},{"location":"references/python_typing_guide/#simple-analogy","title":"Simple Analogy","text":"<p>Imagine a generic container that can hold any type of item:</p> <pre><code># Instead of creating separate containers for each type:\nclass StringContainer:\n    def __init__(self, value: str):\n        self.value = value\n\nclass IntContainer:\n    def __init__(self, value: int):\n        self.value = value\n\n# We create ONE generic container:\nfrom typing import Generic, TypeVar\n\nT = TypeVar('T')\n\nclass Container(Generic[T]):\n    def __init__(self, value: T):\n        self.value = value\n\n    def get_value(self) -&gt; T:\n        return self.value\n\n# Now we can use it with any type:\nstring_container = Container[str](\"Hello\")\nint_container = Container[int](42)\n</code></pre>"},{"location":"references/python_typing_guide/#core-generic-concepts","title":"\ud83d\udd27 Core Generic Concepts","text":""},{"location":"references/python_typing_guide/#typevar-type-variables","title":"TypeVar - Type Variables","text":"<p><code>TypeVar</code> creates a placeholder for a type that will be specified later:</p> <pre><code>from typing import TypeVar, List\n\n# Define a type variable\nT = TypeVar('T')\n\ndef get_first_item(items: List[T]) -&gt; T:\n    \"\"\"Returns the first item from a list, preserving its type.\"\"\"\n    return items[0]\n\n# Usage examples:\nnumbers = [1, 2, 3]\nfirst_number = get_first_item(numbers)  # Type: int\n\nnames = [\"Alice\", \"Bob\", \"Charlie\"]\nfirst_name = get_first_item(names)      # Type: str\n</code></pre>"},{"location":"references/python_typing_guide/#generic-classes","title":"Generic Classes","text":"<p>Classes can be made generic to work with different types:</p> <pre><code>from typing import Generic, TypeVar, Optional, List\n\nT = TypeVar('T')\n\nclass Repository(Generic[T]):\n    \"\"\"A generic repository that can store any type of entity.\"\"\"\n\n    def __init__(self):\n        self._items: List[T] = []\n\n    def add(self, item: T) -&gt; None:\n        self._items.append(item)\n\n    def get_by_index(self, index: int) -&gt; Optional[T]:\n        if 0 &lt;= index &lt; len(self._items):\n            return self._items[index]\n        return None\n\n    def get_all(self) -&gt; List[T]:\n        return self._items.copy()\n\n# Usage with specific types:\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    id: str\n    name: str\n\n@dataclass\nclass Product:\n    id: str\n    name: str\n    price: float\n\n# Create type-specific repositories:\nuser_repo = Repository[User]()\nproduct_repo = Repository[Product]()\n\n# Type safety is maintained:\nuser_repo.add(User(\"1\", \"Alice\"))        # \u2705 Correct\nproduct_repo.add(Product(\"1\", \"Pizza\", 12.99))  # \u2705 Correct\n\n# user_repo.add(Product(\"1\", \"Pizza\", 12.99))  # \u274c Type error!\n</code></pre>"},{"location":"references/python_typing_guide/#framework-integration","title":"\ud83c\udfd7\ufe0f Framework Integration","text":""},{"location":"references/python_typing_guide/#type-hints-in-neuroglia-framework","title":"Type Hints in Neuroglia Framework","text":""},{"location":"references/python_typing_guide/#entity-and-repository-patterns","title":"Entity and Repository Patterns","text":"<pre><code>from typing import Generic, TypeVar, Optional, List, Protocol\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\n\n# Domain entities with type hints:\n@dataclass\nclass Pizza:\n    id: str\n    name: str\n    price: float\n    ingredients: List[str]\n    is_available: bool = True\n\n@dataclass\nclass Customer:\n    id: str\n    name: str\n    email: str\n    phone: Optional[str] = None\n    loyalty_points: int = 0\n\n# Repository with clear type signatures:\nTEntity = TypeVar('TEntity')\nTId = TypeVar('TId')\n\nclass Repository(Generic[TEntity, TId], Protocol):\n    async def get_by_id_async(self, id: TId) -&gt; Optional[TEntity]:\n        \"\"\"Get entity by ID, returns None if not found.\"\"\"\n        ...\n\n    async def save_async(self, entity: TEntity) -&gt; None:\n        \"\"\"Save entity to storage.\"\"\"\n        ...\n\n    async def delete_async(self, id: TId) -&gt; bool:\n        \"\"\"Delete entity, returns True if deleted.\"\"\"\n        ...\n\n    async def get_all_async(self) -&gt; List[TEntity]:\n        \"\"\"Get all entities.\"\"\"\n        ...\n\n# Concrete implementation:\nclass PizzaRepository(Repository[Pizza, str]):\n    def __init__(self):\n        self._pizzas: Dict[str, Pizza] = {}\n\n    async def get_by_id_async(self, id: str) -&gt; Optional[Pizza]:\n        return self._pizzas.get(id)\n\n    async def save_async(self, pizza: Pizza) -&gt; None:\n        self._pizzas[pizza.id] = pizza\n\n    async def delete_async(self, id: str) -&gt; bool:\n        if id in self._pizzas:\n            del self._pizzas[id]\n            return True\n        return False\n\n    async def get_all_async(self) -&gt; List[Pizza]:\n        return list(self._pizzas.values())\n</code></pre>"},{"location":"references/python_typing_guide/#cqrs-commands-and-queries","title":"CQRS Commands and Queries","text":"<pre><code>from typing import Generic, TypeVar\nfrom dataclasses import dataclass\n\nTResult = TypeVar('TResult')\n\n# Base command and query types:\nclass Command(Generic[TResult]):\n    \"\"\"Base class for commands with typed results.\"\"\"\n    pass\n\nclass Query(Generic[TResult]):\n    \"\"\"Base class for queries with typed results.\"\"\"\n    pass\n\n# Specific commands with clear return types:\n@dataclass\nclass CreatePizzaCommand(Command[Pizza]):\n    name: str\n    price: float\n    ingredients: List[str]\n\n@dataclass\nclass UpdatePizzaPriceCommand(Command[Optional[Pizza]]):\n    pizza_id: str\n    new_price: float\n\n@dataclass\nclass DeletePizzaCommand(Command[bool]):\n    pizza_id: str\n\n# Queries with different return types:\n@dataclass\nclass GetPizzaByIdQuery(Query[Optional[Pizza]]):\n    pizza_id: str\n\n@dataclass\nclass GetAvailablePizzasQuery(Query[List[Pizza]]):\n    pass\n\n@dataclass\nclass GetPizzasByPriceRangeQuery(Query[List[Pizza]]):\n    min_price: float\n    max_price: float\n\n# Handler interfaces with type safety:\nTRequest = TypeVar('TRequest')\nTResponse = TypeVar('TResponse')\n\nclass Handler(Generic[TRequest, TResponse], Protocol):\n    async def handle_async(self, request: TRequest) -&gt; TResponse:\n        \"\"\"Handle the request and return typed response.\"\"\"\n        ...\n\n# Concrete handlers:\nclass CreatePizzaHandler(Handler[CreatePizzaCommand, Pizza]):\n    def __init__(self, repository: PizzaRepository):\n        self._repository = repository\n\n    async def handle_async(self, command: CreatePizzaCommand) -&gt; Pizza:\n        pizza = Pizza(\n            id=generate_id(),\n            name=command.name,\n            price=command.price,\n            ingredients=command.ingredients\n        )\n        await self._repository.save_async(pizza)\n        return pizza\n\nclass GetPizzaByIdHandler(Handler[GetPizzaByIdQuery, Optional[Pizza]]):\n    def __init__(self, repository: PizzaRepository):\n        self._repository = repository\n\n    async def handle_async(self, query: GetPizzaByIdQuery) -&gt; Optional[Pizza]:\n        return await self._repository.get_by_id_async(query.pizza_id)\n</code></pre>"},{"location":"references/python_typing_guide/#api-controllers-with-type-safety","title":"API Controllers with Type Safety","text":"<pre><code>from typing import List, Optional\nfrom fastapi import HTTPException\nfrom neuroglia.mvc import ControllerBase\n\n# DTOs with type hints:\n@dataclass\nclass PizzaDto:\n    id: str\n    name: str\n    price: float\n    ingredients: List[str]\n    is_available: bool\n\n@dataclass\nclass CreatePizzaDto:\n    name: str\n    price: float\n    ingredients: List[str]\n\n@dataclass\nclass UpdatePizzaPriceDto:\n    new_price: float\n\n# Controller with clear type signatures:\nclass PizzaController(ControllerBase):\n    def __init__(self, mediator, mapper, service_provider):\n        super().__init__(service_provider, mapper, mediator)\n\n    async def get_pizza(self, pizza_id: str) -&gt; Optional[PizzaDto]:\n        \"\"\"Get a pizza by ID.\"\"\"\n        query = GetPizzaByIdQuery(pizza_id=pizza_id)\n        pizza = await self.mediator.execute_async(query)\n\n        if pizza is None:\n            return None\n\n        return self.mapper.map(pizza, PizzaDto)\n\n    async def create_pizza(self, create_dto: CreatePizzaDto) -&gt; PizzaDto:\n        \"\"\"Create a new pizza.\"\"\"\n        command = CreatePizzaCommand(\n            name=create_dto.name,\n            price=create_dto.price,\n            ingredients=create_dto.ingredients\n        )\n\n        pizza = await self.mediator.execute_async(command)\n        return self.mapper.map(pizza, PizzaDto)\n\n    async def get_all_pizzas(self) -&gt; List[PizzaDto]:\n        \"\"\"Get all available pizzas.\"\"\"\n        query = GetAvailablePizzasQuery()\n        pizzas = await self.mediator.execute_async(query)\n\n        return [self.mapper.map(pizza, PizzaDto) for pizza in pizzas]\n</code></pre>"},{"location":"references/python_typing_guide/#advanced-generic-patterns","title":"\ud83c\udfa8 Advanced Generic Patterns","text":""},{"location":"references/python_typing_guide/#bounded-type-variables","title":"Bounded Type Variables","text":"<p>You can constrain what types a <code>TypeVar</code> can be:</p> <pre><code>from typing import TypeVar\nfrom abc import ABC\n\n# Constraint to specific types:\nNumberType = TypeVar('NumberType', int, float)\n\ndef add_numbers(a: NumberType, b: NumberType) -&gt; NumberType:\n    return a + b\n\n# Bound to a base class:\nclass Entity(ABC):\n    def __init__(self, id: str):\n        self.id = id\n\nEntityType = TypeVar('EntityType', bound=Entity)\n\nclass EntityService(Generic[EntityType]):\n    def __init__(self, repository: Repository[EntityType, str]):\n        self._repository = repository\n\n    async def get_by_id(self, id: str) -&gt; Optional[EntityType]:\n        return await self._repository.get_by_id_async(id)\n\n# Usage - only works with Entity subclasses:\nclass Pizza(Entity):\n    def __init__(self, id: str, name: str):\n        super().__init__(id)\n        self.name = name\n\npizza_service = EntityService[Pizza](pizza_repository)  # \u2705 Works\n# str_service = EntityService[str](string_repo)         # \u274c Error: str is not an Entity\n</code></pre>"},{"location":"references/python_typing_guide/#generic-protocols","title":"Generic Protocols","text":"<p>Protocols define interfaces that any type can implement:</p> <pre><code>from typing import Protocol, TypeVar\n\nclass Comparable(Protocol):\n    \"\"\"Protocol for types that can be compared.\"\"\"\n    def __lt__(self, other: 'Comparable') -&gt; bool: ...\n    def __eq__(self, other: object) -&gt; bool: ...\n\nT = TypeVar('T', bound=Comparable)\n\ndef sort_items(items: List[T]) -&gt; List[T]:\n    \"\"\"Sort any list of comparable items.\"\"\"\n    return sorted(items)\n\n# Works with any type that implements comparison:\nnumbers = [3, 1, 4, 1, 5]\nsorted_numbers = sort_items(numbers)  # \u2705 int implements comparison\n\nnames = [\"Charlie\", \"Alice\", \"Bob\"]\nsorted_names = sort_items(names)      # \u2705 str implements comparison\n\n@dataclass\nclass Pizza:\n    name: str\n    price: float\n\n    def __lt__(self, other: 'Pizza') -&gt; bool:\n        return self.price &lt; other.price\n\n    def __eq__(self, other: object) -&gt; bool:\n        return isinstance(other, Pizza) and self.name == other.name\n\npizzas = [\n    Pizza(\"Margherita\", 12.99),\n    Pizza(\"Pepperoni\", 14.99),\n    Pizza(\"Hawaiian\", 13.49)\n]\nsorted_pizzas = sort_items(pizzas)    # \u2705 Pizza implements Comparable\n</code></pre>"},{"location":"references/python_typing_guide/#testing-with-types","title":"\ud83e\uddea Testing with Types","text":"<p>Type hints make tests more reliable and easier to understand:</p> <pre><code>from typing import List, Dict, Any, Optional\nimport pytest\nfrom unittest.mock import Mock, AsyncMock\n\nclass TestPizzaRepository:\n    def setup_method(self) -&gt; None:\n        \"\"\"Setup test fixtures with proper types.\"\"\"\n        self.repository: PizzaRepository = PizzaRepository()\n        self.sample_pizza: Pizza = Pizza(\n            id=\"1\",\n            name=\"Margherita\",\n            price=12.99,\n            ingredients=[\"tomato\", \"mozzarella\", \"basil\"]\n        )\n\n    async def test_save_and_retrieve_pizza(self) -&gt; None:\n        \"\"\"Test saving and retrieving a pizza.\"\"\"\n        # Save pizza\n        await self.repository.save_async(self.sample_pizza)\n\n        # Retrieve pizza\n        retrieved_pizza: Optional[Pizza] = await self.repository.get_by_id_async(\"1\")\n\n        # Assertions with type safety\n        assert retrieved_pizza is not None\n        assert retrieved_pizza.name == \"Margherita\"\n        assert retrieved_pizza.price == 12.99\n\n    async def test_get_nonexistent_pizza(self) -&gt; None:\n        \"\"\"Test retrieving a pizza that doesn't exist.\"\"\"\n        result: Optional[Pizza] = await self.repository.get_by_id_async(\"999\")\n        assert result is None\n\n    async def test_get_all_pizzas(self) -&gt; None:\n        \"\"\"Test getting all pizzas.\"\"\"\n        pizzas: List[Pizza] = [\n            Pizza(\"1\", \"Margherita\", 12.99, [\"tomato\", \"mozzarella\"]),\n            Pizza(\"2\", \"Pepperoni\", 14.99, [\"tomato\", \"mozzarella\", \"pepperoni\"])\n        ]\n\n        for pizza in pizzas:\n            await self.repository.save_async(pizza)\n\n        all_pizzas: List[Pizza] = await self.repository.get_all_async()\n        assert len(all_pizzas) == 2\n\n# Generic type testing:\nT = TypeVar('T')\n\nclass Stack(Generic[T]):\n    def __init__(self):\n        self._items: List[T] = []\n\n    def push(self, item: T) -&gt; None:\n        self._items.append(item)\n\n    def pop(self) -&gt; T:\n        if not self._items:\n            raise IndexError(\"Stack is empty\")\n        return self._items.pop()\n\n    def is_empty(self) -&gt; bool:\n        return len(self._items) == 0\n\n# Test with multiple types:\nclass TestStack:\n    def test_string_stack(self):\n        stack = Stack[str]()\n        stack.push(\"hello\")\n        stack.push(\"world\")\n\n        assert stack.pop() == \"world\"\n        assert stack.pop() == \"hello\"\n        assert stack.is_empty()\n\n    def test_int_stack(self):\n        stack = Stack[int]()\n        stack.push(1)\n        stack.push(2)\n\n        assert stack.pop() == 2\n        assert stack.pop() == 1\n        assert stack.is_empty()\n\n    def test_pizza_stack(self):\n        stack = Stack[Pizza]()\n        pizza = Pizza(\"1\", \"Margherita\", 12.99, [\"tomato\", \"mozzarella\"])\n        stack.push(pizza)\n\n        popped_pizza = stack.pop()\n        assert popped_pizza.name == \"Margherita\"\n        assert stack.is_empty()\n\n# Mock with proper type hints:\nclass TestPizzaHandler:\n    def setup_method(self) -&gt; None:\n        \"\"\"Setup mocks with proper type hints.\"\"\"\n        self.mock_repository: Mock = Mock(spec=PizzaRepository)\n        self.handler: CreatePizzaHandler = CreatePizzaHandler(self.mock_repository)\n\n    async def test_create_pizza_success(self) -&gt; None:\n        \"\"\"Test successful pizza creation.\"\"\"\n        # Setup mock\n        self.mock_repository.save_async = AsyncMock()\n\n        # Create command\n        command: CreatePizzaCommand = CreatePizzaCommand(\n            name=\"Test Pizza\",\n            price=15.99,\n            ingredients=[\"cheese\", \"tomato\"]\n        )\n\n        # Execute handler\n        result: Pizza = await self.handler.handle_async(command)\n\n        # Verify results\n        assert result.name == \"Test Pizza\"\n        assert result.price == 15.99\n        self.mock_repository.save_async.assert_called_once()\n</code></pre>"},{"location":"references/python_typing_guide/#type-checking-tools","title":"\ud83c\udfaf Type Checking Tools","text":""},{"location":"references/python_typing_guide/#using-mypy","title":"Using mypy","text":"<p>Add type checking to your development workflow:</p> <pre><code># Install mypy\npip install mypy\n\n# Check types in your code\nmypy src/\n\n# Configuration in mypy.ini:\n[mypy]\npython_version = 3.9\nwarn_return_any = True\nwarn_unused_configs = True\ndisallow_untyped_defs = True\n</code></pre> <p>Example mypy output:</p> <pre><code>src/api/controllers/pizza_controller.py:15: error: Function is missing a return type annotation\nsrc/application/handlers/pizza_handler.py:23: error: Argument 1 to \"save_async\" has incompatible type \"str\"; expected \"Pizza\"\n</code></pre>"},{"location":"references/python_typing_guide/#ide-support","title":"IDE Support","text":"<p>Modern IDEs use type hints to provide:</p> <ul> <li>Autocomplete: Suggests methods and attributes</li> <li>Error Detection: Highlights type mismatches</li> <li>Refactoring: Safely rename and move code</li> <li>Documentation: Shows parameter and return types</li> </ul> <pre><code># IDE will show you available methods on pizzas:\npizzas: List[Pizza] = await repository.get_all_async()\n# When you type \"pizzas.\" IDE shows: append, clear, copy, count, etc.\n\n# IDE catches type errors immediately:\npizza: Pizza = Pizza(\"1\", \"Margherita\", 12.99, [\"tomato\"])\npizza.price = \"expensive\"  # IDE warns: Cannot assign str to float\n</code></pre>"},{"location":"references/python_typing_guide/#best-practices","title":"\ud83d\ude80 Best Practices","text":""},{"location":"references/python_typing_guide/#1-start-simple-add-complexity-gradually","title":"1. Start Simple, Add Complexity Gradually","text":"<pre><code># Start with basic types:\ndef calculate_total(price: float, quantity: int) -&gt; float:\n    return price * quantity\n\n# Add more specific types as needed:\nfrom decimal import Decimal\n\ndef calculate_total_precise(price: Decimal, quantity: int) -&gt; Decimal:\n    return price * quantity\n\n# Use generics for reusable components:\nT = TypeVar('T')\n\ndef get_or_default(items: List[T], index: int, default: T) -&gt; T:\n    return items[index] if 0 &lt;= index &lt; len(items) else default\n</code></pre>"},{"location":"references/python_typing_guide/#2-use-type-aliases-for-complex-types","title":"2. Use Type Aliases for Complex Types","text":"<pre><code>from typing import Dict, List, Tuple, TypeAlias\n\n# Create aliases for readability:\nPizzaMenu: TypeAlias = Dict[str, float]\nOrderItem: TypeAlias = Tuple[str, int]  # (pizza_name, quantity)\nCustomerOrder: TypeAlias = Dict[str, List[OrderItem]]\n\ndef process_orders(orders: CustomerOrder) -&gt; Dict[str, float]:\n    \"\"\"Process customer orders and return totals.\"\"\"\n    totals: Dict[str, float] = {}\n\n    for customer_id, items in orders.items():\n        total = 0.0\n        for pizza_name, quantity in items:\n            # ... calculation logic\n            pass\n        totals[customer_id] = total\n\n    return totals\n</code></pre>"},{"location":"references/python_typing_guide/#3-use-descriptive-type-variable-names","title":"3. Use Descriptive Type Variable Names","text":"<pre><code># Good - descriptive names:\nTEntity = TypeVar('TEntity')\nTId = TypeVar('TId')\nTRequest = TypeVar('TRequest')\nTResponse = TypeVar('TResponse')\n\n# Avoid - generic names unless appropriate:\nT = TypeVar('T')  # Only use for truly generic cases\n</code></pre>"},{"location":"references/python_typing_guide/#4-provide-type-bounds-when-appropriate","title":"4. Provide Type Bounds When Appropriate","text":"<pre><code># Good - constrained when you need specific capabilities:\nfrom typing import Protocol\n\nclass Serializable(Protocol):\n    def to_dict(self) -&gt; dict: ...\n\nTSerializable = TypeVar('TSerializable', bound=Serializable)\n\nclass ApiService(Generic[TSerializable]):\n    async def send_data(self, data: TSerializable) -&gt; None:\n        json_data = data.to_dict()  # Safe - we know it has to_dict()\n        # ... send to API\n</code></pre>"},{"location":"references/python_typing_guide/#5-document-complex-types","title":"5. Document Complex Types","text":"<pre><code>from typing import NewType, Dict, List\n\n# Create semantic types:\nCustomerId = NewType('CustomerId', str)\nPizzaId = NewType('PizzaId', str)\nPrice = NewType('Price', float)\n\nclass OrderService:\n    \"\"\"Service for processing pizza orders.\"\"\"\n\n    def calculate_order_total(\n        self,\n        customer_id: CustomerId,\n        items: Dict[PizzaId, int]  # pizza_id -&gt; quantity\n    ) -&gt; Price:\n        \"\"\"\n        Calculate total price for a customer's order.\n\n        Args:\n            customer_id: Unique identifier for the customer\n            items: Dictionary mapping pizza IDs to quantities\n\n        Returns:\n            Total price for the order\n\n        Raises:\n            ValueError: If any pizza ID is not found\n        \"\"\"\n        # Implementation here...\n        pass\n</code></pre>"},{"location":"references/python_typing_guide/#6-handle-optional-values-explicitly","title":"6. Handle Optional Values Explicitly","text":"<pre><code>from typing import Optional\n\n# Be explicit about None handling:\ndef get_customer_name(customer_id: str) -&gt; Optional[str]:\n    \"\"\"Get customer name, returns None if not found.\"\"\"\n    # Database lookup...\n    return customer_name if found else None\n\ndef format_greeting(customer_id: str) -&gt; str:\n    \"\"\"Create personalized greeting.\"\"\"\n    name = get_customer_name(customer_id)\n\n    if name is not None:\n        return f\"Hello, {name}!\"\n    else:\n        return \"Hello, valued customer!\"\n\n# Or use walrus operator (Python 3.8+):\ndef format_greeting_modern(customer_id: str) -&gt; str:\n    \"\"\"Create personalized greeting using walrus operator.\"\"\"\n    if (name := get_customer_name(customer_id)) is not None:\n        return f\"Hello, {name}!\"\n    else:\n        return \"Hello, valued customer!\"\n</code></pre>"},{"location":"references/python_typing_guide/#7-use-protocols-for-duck-typing","title":"7. Use Protocols for Duck Typing","text":"<pre><code>from typing import Protocol\n\nclass Serializable(Protocol):\n    \"\"\"Protocol for objects that can be serialized.\"\"\"\n    def to_dict(self) -&gt; Dict[str, any]:\n        \"\"\"Convert object to dictionary representation.\"\"\"\n        ...\n\nclass Jsonifiable(Protocol):\n    \"\"\"Protocol for objects that can be converted to JSON.\"\"\"\n    def to_json(self) -&gt; str:\n        \"\"\"Convert object to JSON string.\"\"\"\n        ...\n\n# Function that works with any serializable object:\ndef save_to_database(obj: Serializable) -&gt; None:\n    \"\"\"Save any serializable object to database.\"\"\"\n    data = obj.to_dict()\n    # Database save logic...\n\n# Both Pizza and Customer can implement Serializable:\nclass Pizza:\n    def to_dict(self) -&gt; Dict[str, any]:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"price\": self.price,\n            \"ingredients\": self.ingredients\n        }\n\nclass Customer:\n    def to_dict(self) -&gt; Dict[str, any]:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"email\": self.email\n        }\n\n# Both work with save_to_database:\npizza = Pizza(\"1\", \"Margherita\", 12.99, [\"tomato\", \"mozzarella\"])\ncustomer = Customer(\"c1\", \"Mario\", \"mario@pizzeria.com\")\n\nsave_to_database(pizza)     # \u2705 Works\nsave_to_database(customer)  # \u2705 Works\n</code></pre>"},{"location":"references/python_typing_guide/#common-pitfalls-to-avoid","title":"\u274c Common Pitfalls to Avoid","text":""},{"location":"references/python_typing_guide/#1-overusing-any","title":"1. Overusing <code>Any</code>","text":"<pre><code>from typing import Any\n\n# \u274c Avoid - defeats the purpose of type hints:\ndef process_data(data: Any) -&gt; Any:\n    return data.some_method()\n\n# \u2705 Better - be specific:\ndef process_pizza_data(pizza: Pizza) -&gt; PizzaDto:\n    return PizzaDto(\n        id=pizza.id,\n        name=pizza.name,\n        price=pizza.price,\n        ingredients=pizza.ingredients,\n        is_available=pizza.is_available\n    )\n\n# \u2705 Or use generics if truly generic:\nT = TypeVar('T')\n\ndef process_data(data: T, processor: Callable[[T], str]) -&gt; str:\n    return processor(data)\n</code></pre>"},{"location":"references/python_typing_guide/#2-mixing-union-and-optional-incorrectly","title":"2. Mixing Union and Optional Incorrectly","text":"<pre><code># \u274c Wrong - Optional[T] is equivalent to Union[T, None]:\ndef get_pizza(id: str) -&gt; Union[Pizza, None]:  # Redundant\n    pass\n\ndef get_pizza_wrong(id: str) -&gt; Optional[Pizza, str]:  # Error!\n    pass\n\n# \u2705 Correct usage:\ndef get_pizza(id: str) -&gt; Optional[Pizza]:  # Returns Pizza or None\n    pass\n\ndef get_pizza_or_error(id: str) -&gt; Union[Pizza, str]:  # Returns Pizza or error message\n    pass\n</code></pre>"},{"location":"references/python_typing_guide/#3-runtime-type-checking-with-generics","title":"3. Runtime Type Checking with Generics","text":"<pre><code># \u274c Wrong - generics are erased at runtime:\ndef bad_function(value: T) -&gt; str:\n    if isinstance(value, str):  # This works, but defeats the purpose\n        return value\n    return str(value)\n\n# \u2705 Better - use proper type bounds:\nStrOrConvertible = TypeVar('StrOrConvertible', str, int, float)\n\ndef good_function(value: StrOrConvertible) -&gt; str:\n    return str(value)\n</code></pre>"},{"location":"references/python_typing_guide/#4-overcomplicating-simple-cases","title":"4. Overcomplicating Simple Cases","text":"<pre><code># \u274c Overkill for simple functions:\nT = TypeVar('T')\ndef identity(x: T) -&gt; T:\n    return x\n\n# \u2705 Simple functions often don't need generics:\ndef identity(x):\n    return x\n</code></pre>"},{"location":"references/python_typing_guide/#5-missing-type-bounds","title":"5. Missing Type Bounds","text":"<pre><code># \u274c Too permissive - might not have needed methods:\nT = TypeVar('T')\n\ndef sort_and_print(items: List[T]) -&gt; None:\n    sorted_items = sorted(items)  # Might fail if T doesn't support comparison\n    print(sorted_items)\n\n# \u2705 Use bounds when you need specific capabilities:\nfrom typing import Protocol\n\nclass Comparable(Protocol):\n    def __lt__(self, other: 'Comparable') -&gt; bool: ...\n\nT = TypeVar('T', bound=Comparable)\n\ndef sort_and_print(items: List[T]) -&gt; None:\n    sorted_items = sorted(items)  # Safe - T is guaranteed to be comparable\n    print(sorted_items)\n</code></pre>"},{"location":"references/python_typing_guide/#6-not-using-forward-references","title":"6. Not Using Forward References","text":"<pre><code># \u274c This might cause issues if Order references Customer and vice versa:\nclass Customer:\n    def __init__(self, name: str):\n        self.name = name\n        self.orders: List[Order] = []  # Error: Order not defined yet\n\nclass Order:\n    def __init__(self, customer: Customer):\n        self.customer = customer\n\n# \u2705 Use string forward references:\nfrom typing import List, TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from .order import Order\n\nclass Customer:\n    def __init__(self, name: str):\n        self.name = name\n        self.orders: List['Order'] = []  # Forward reference\n\n# \u2705 Or use `from __future__ import annotations` (Python 3.7+):\nfrom __future__ import annotations\nfrom typing import List\n\nclass Customer:\n    def __init__(self, name: str):\n        self.name = name\n        self.orders: List[Order] = []  # Works without quotes\n\nclass Order:\n    def __init__(self, customer: Customer):\n        self.customer = customer\n</code></pre>"},{"location":"references/python_typing_guide/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Python Object-Oriented Programming - Classes, inheritance, and composition patterns</li> <li>Python Modular Code - Module organization and import patterns</li> <li>CQRS &amp; Mediation - Type-safe command/query patterns in the framework</li> <li>MVC Controllers - Type-safe API development techniques</li> <li>Data Access - Repository patterns with full type safety</li> </ul>"},{"location":"references/python_typing_guide/#further-reading","title":"\ud83d\udcda Further Reading","text":"<ul> <li>PEP 484 - Type Hints - Original type hints specification</li> <li>PEP 526 - Variable Annotations - Variable type annotations</li> <li>PEP 585 - Type Hinting Generics - Built-in generic types</li> <li>Python typing module documentation - Official typing reference</li> <li>mypy documentation - Static type checker documentation</li> <li>Real Python: Type Checking - Comprehensive typing tutorial</li> <li>FastAPI and Type Hints - Type hints in web development</li> </ul>"},{"location":"references/source_code_naming_convention/","title":"\ud83c\udff7\ufe0f Source Code Naming Conventions","text":"<p>Consistent naming conventions are crucial for maintainable, readable, and professional codebases. The Neuroglia framework follows Python's established conventions while adding domain-specific patterns for clean architecture. This reference provides comprehensive guidelines for naming across all layers of your application.</p>"},{"location":"references/source_code_naming_convention/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>When to use snake_case vs CamelCase vs PascalCase across different contexts</li> <li>Naming patterns for entities, events, handlers, controllers, and methods</li> <li>Layer-specific conventions that enforce clean architecture boundaries</li> <li>Benefits of consistent naming conventions for team productivity</li> <li>Mario's Pizzeria examples demonstrating proper naming in practice</li> </ul>"},{"location":"references/source_code_naming_convention/#benefits-of-naming-conventions","title":"\ud83d\udccb Benefits of Naming Conventions","text":""},{"location":"references/source_code_naming_convention/#cognitive-load-reduction","title":"\ud83e\udde0 Cognitive Load Reduction","text":"<p>Consistent patterns reduce mental overhead when reading code. Developers can instantly identify the purpose and layer of any component based on its name.</p>"},{"location":"references/source_code_naming_convention/#team-collaboration","title":"\ud83d\udc65 Team Collaboration","text":"<p>Standardized naming eliminates debates about \"what to call this\" and ensures new team members can navigate the codebase intuitively.</p>"},{"location":"references/source_code_naming_convention/#searchability-navigation","title":"\ud83d\udd0d Searchability &amp; Navigation","text":"<p>Well-named components are easier to find using IDE search, grep, and other tools. Consistent patterns enable powerful refactoring operations.</p>"},{"location":"references/source_code_naming_convention/#architecture-enforcement","title":"\ud83c\udfd7\ufe0f Architecture Enforcement","text":"<p>Naming conventions reinforce clean architecture boundaries - you can immediately tell if a component violates layer dependencies.</p>"},{"location":"references/source_code_naming_convention/#productivity-maintenance","title":"\ud83d\ude80 Productivity &amp; Maintenance","text":"<p>Less time spent deciphering unclear names means more time focused on business logic and feature development.</p>"},{"location":"references/source_code_naming_convention/#python-language-conventions","title":"\ud83d\udc0d Python Language Conventions","text":"<p>The framework strictly follows PEP 8 and Python naming conventions as the foundation:</p>"},{"location":"references/source_code_naming_convention/#snake_case-usage","title":"snake_case Usage","text":"<p>Files and Modules:</p> <pre><code># \u2705 Correct\nuser_service.py\ncreate_order_command.py\nbank_account_repository.py\n\n# \u274c Incorrect\nUserService.py\nCreateOrderCommand.py\nBankAccount-Repository.py\n</code></pre> <p>Variables and Functions:</p> <pre><code># \u2705 Correct\nuser_name = \"Mario\"\ntotal_amount = calculate_order_total()\norder_placed_at = datetime.now()\n\ndef process_payment_async(amount: Decimal) -&gt; bool:\n    pass\n\n# \u274c Incorrect\nuserName = \"Mario\"\ntotalAmount = calculateOrderTotal()\nOrderPlacedAt = datetime.now()\n\ndef ProcessPaymentAsync(amount: Decimal) -&gt; bool:\n    pass\n</code></pre> <p>Method and Attribute Names:</p> <pre><code>class Pizza:\n    def __init__(self):\n        self.pizza_name = \"\"        # snake_case attributes\n        self.base_price = Decimal(\"0\")\n        self.available_sizes = []\n\n    def calculate_total_price(self):  # snake_case methods\n        pass\n\n    async def save_to_database_async(self):  # async suffix\n        pass\n</code></pre>"},{"location":"references/source_code_naming_convention/#pascalcase-usage","title":"PascalCase Usage","text":"<p>Classes, Types, and Interfaces:</p> <pre><code># \u2705 Correct - Classes\nclass OrderService:\n    pass\n\nclass CreatePizzaCommand:\n    pass\n\nclass PizzaOrderHandler:\n    pass\n\n# \u2705 Correct - Type Variables\nTEntity = TypeVar(\"TEntity\")\nTKey = TypeVar(\"TKey\")\nTResult = TypeVar(\"TResult\")\n\n# \u2705 Correct - Exceptions\nclass ValidationException(Exception):\n    pass\n\nclass OrderNotFoundException(Exception):\n    pass\n</code></pre> <p>Enums:</p> <pre><code>class OrderStatus(Enum):\n    PENDING = \"pending\"\n    CONFIRMED = \"confirmed\"\n    PREPARING = \"preparing\"\n    READY = \"ready\"\n    DELIVERED = \"delivered\"\n    CANCELLED = \"cancelled\"\n</code></pre>"},{"location":"references/source_code_naming_convention/#upper_case-usage","title":"UPPER_CASE Usage","text":"<p>Constants:</p> <pre><code># \u2705 Correct - Module-level constants\nDEFAULT_PIZZA_SIZE = \"medium\"\nMAX_ORDER_ITEMS = 20\nAPI_BASE_URL = \"https://api.mariospizza.com\"\n\n# \u2705 Correct - Class constants\nclass PizzaService:\n    DEFAULT_COOKING_TIME = 15  # minutes\n    MAX_TOPPINGS_PER_PIZZA = 8\n</code></pre>"},{"location":"references/source_code_naming_convention/#layer-specific-naming-conventions","title":"\ud83c\udfd7\ufe0f Layer-Specific Naming Conventions","text":"<p>The framework enforces different naming patterns for each architectural layer to maintain clean separation of concerns.</p>"},{"location":"references/source_code_naming_convention/#api-layer-api","title":"\ud83c\udf10 API Layer (<code>api/</code>)","text":"<p>The API layer handles HTTP requests and responses, following REST conventions.</p> <p>Controllers:</p> <pre><code># Pattern: {Entity}Controller (PascalCase)\nclass PizzasController(ControllerBase):\n    pass\n\nclass OrdersController(ControllerBase):\n    pass\n\nclass CustomersController(ControllerBase):\n    pass\n\n# \u274c Avoid\nclass PizzaController:      # Singular form\nclass Pizza_Controller:     # snake_case\nclass pizzaController:      # camelCase\n</code></pre> <p>Controller Methods:</p> <pre><code>class PizzasController(ControllerBase):\n    # Pattern: HTTP verb + descriptive name (snake_case)\n    @get(\"/{pizza_id}\")\n    async def get_pizza(self, pizza_id: str) -&gt; PizzaDto:\n        pass\n\n    @post(\"/\")\n    async def create_pizza(self, pizza_dto: CreatePizzaDto) -&gt; PizzaDto:\n        pass\n\n    @put(\"/{pizza_id}\")\n    async def update_pizza(self, pizza_id: str, pizza_dto: UpdatePizzaDto) -&gt; PizzaDto:\n        pass\n\n    @delete(\"/{pizza_id}\")\n    async def delete_pizza(self, pizza_id: str) -&gt; None:\n        pass\n\n    # Complex operations get descriptive names\n    @post(\"/{pizza_id}/customize\")\n    async def customize_pizza_toppings(self, pizza_id: str, toppings: List[str]) -&gt; PizzaDto:\n        pass\n</code></pre> <p>DTOs (Data Transfer Objects):</p> <pre><code># Pattern: {Purpose}{Entity}Dto (PascalCase)\n@dataclass\nclass PizzaDto:\n    pizza_id: str           # snake_case fields\n    pizza_name: str\n    base_price: Decimal\n    available_sizes: List[str]\n\n@dataclass\nclass CreatePizzaDto:\n    pizza_name: str\n    base_price: Decimal\n    ingredient_ids: List[str]\n\n@dataclass\nclass UpdatePizzaDto:\n    pizza_name: Optional[str] = None\n    base_price: Optional[Decimal] = None\n\n# Specialized DTOs\n@dataclass\nclass PizzaMenuItemDto:     # Specific context\n    pass\n\n@dataclass\nclass PizzaInventoryDto:    # Different view\n    pass\n</code></pre>"},{"location":"references/source_code_naming_convention/#application-layer-application","title":"\ud83d\udcbc Application Layer (<code>application/</code>)","text":"<p>The application layer orchestrates business operations through commands, queries, and handlers.</p> <p>Commands (Write Operations):</p> <pre><code># Pattern: {Verb}{Entity}Command (PascalCase)\n@dataclass\nclass CreatePizzaCommand(Command[OperationResult[PizzaDto]]):\n    pizza_name: str         # snake_case fields\n    base_price: Decimal\n    ingredient_ids: List[str]\n\n@dataclass\nclass UpdatePizzaCommand(Command[OperationResult[PizzaDto]]):\n    pizza_id: str\n    pizza_name: Optional[str] = None\n    base_price: Optional[Decimal] = None\n\n@dataclass\nclass DeletePizzaCommand(Command[OperationResult]):\n    pizza_id: str\n\n# Complex business operations\n@dataclass\nclass ProcessOrderPaymentCommand(Command[OperationResult[PaymentDto]]):\n    order_id: str\n    payment_method: PaymentMethod\n    amount: Decimal\n</code></pre> <p>Queries (Read Operations):</p> <pre><code># Pattern: {Action}{Entity}Query (PascalCase)\n@dataclass\nclass GetPizzaByIdQuery(Query[PizzaDto]):\n    pizza_id: str\n\n@dataclass\nclass GetPizzasByTypeQuery(Query[List[PizzaDto]]):\n    pizza_type: PizzaType\n    include_unavailable: bool = False\n\n@dataclass\nclass SearchPizzasQuery(Query[List[PizzaDto]]):\n    search_term: str\n    max_results: int = 50\n\n# Complex queries with business logic\n@dataclass\nclass GetPopularPizzasForRegionQuery(Query[List[PizzaDto]]):\n    region_code: str\n    date_range: DateRange\n    min_order_count: int = 10\n</code></pre> <p>Handlers:</p> <pre><code># Pattern: {Command/Query}Handler (PascalCase)\nclass CreatePizzaCommandHandler(CommandHandler[CreatePizzaCommand, OperationResult[PizzaDto]]):\n    def __init__(self,\n                 pizza_repository: PizzaRepository,\n                 mapper: Mapper,\n                 event_bus: EventBus):\n        self._pizza_repository = pizza_repository    # snake_case fields\n        self._mapper = mapper\n        self._event_bus = event_bus\n\n    async def handle_async(self, command: CreatePizzaCommand) -&gt; OperationResult[PizzaDto]:\n        # snake_case method names and variables\n        validation_result = await self._validate_command(command)\n        if not validation_result.is_success:\n            return validation_result\n\n        pizza = Pizza(\n            name=command.pizza_name,\n            base_price=command.base_price\n        )\n\n        await self._pizza_repository.save_async(pizza)\n\n        # Raise domain event\n        pizza_created_event = PizzaCreatedEvent(\n            pizza_id=pizza.id,\n            pizza_name=pizza.name\n        )\n        await self._event_bus.publish_async(pizza_created_event)\n\n        return self.created(self._mapper.map(pizza, PizzaDto))\n</code></pre> <p>Services:</p> <pre><code># Pattern: {Entity}Service or {Purpose}Service (PascalCase)\nclass PizzaService:\n    async def calculate_cooking_time_async(self, pizza: Pizza) -&gt; int:\n        pass\n\n    async def check_ingredient_availability_async(self, ingredients: List[str]) -&gt; bool:\n        pass\n\nclass OrderService:\n    async def process_order_async(self, order: Order) -&gt; OperationResult[Order]:\n        pass\n\nclass PaymentService:\n    async def process_payment_async(self, payment_info: PaymentInfo) -&gt; PaymentResult:\n        pass\n\n# Specialized services\nclass PizzaRecommendationService:\n    pass\n\nclass OrderNotificationService:\n    pass\n</code></pre>"},{"location":"references/source_code_naming_convention/#domain-layer-domain","title":"\ud83c\udfdb\ufe0f Domain Layer (<code>domain/</code>)","text":"<p>The domain layer contains core business logic and entities, following domain-driven design principles.</p> <p>Entities:</p> <pre><code># Pattern: {BusinessConcept} (PascalCase, singular)\nclass Pizza(Entity[str]):\n    def __init__(self, name: str, base_price: Decimal):\n        super().__init__()\n        self.name = name                    # snake_case attributes\n        self.base_price = base_price\n        self.available_sizes = []\n        self.created_at = datetime.now()\n\n    # Business method names in snake_case\n    def add_ingredient(self, ingredient: Ingredient) -&gt; None:\n        if not self.can_add_ingredient(ingredient):\n            raise BusinessRuleViolation(\"Cannot add ingredient to pizza\")\n\n        self.ingredients.append(ingredient)\n        self.raise_event(IngredientAddedEvent(self.id, ingredient.id))\n\n    def calculate_total_price(self, size: PizzaSize) -&gt; Decimal:\n        base_cost = self.base_price * size.price_multiplier\n        ingredient_cost = sum(i.price for i in self.ingredients)\n        return base_cost + ingredient_cost\n\n    def can_add_ingredient(self, ingredient: Ingredient) -&gt; bool:\n        # Business rules\n        return len(self.ingredients) &lt; self.MAX_INGREDIENTS\n\nclass Order(Entity[str]):\n    def __init__(self, customer_id: str):\n        super().__init__()\n        self.customer_id = customer_id\n        self.order_items = []\n        self.status = OrderStatus.PENDING\n        self.total_amount = Decimal(\"0\")\n\n    def add_pizza(self, pizza: Pizza, quantity: int) -&gt; None:\n        if self.status != OrderStatus.PENDING:\n            raise BusinessRuleViolation(\"Cannot modify confirmed order\")\n\n        order_item = OrderItem(pizza, quantity)\n        self.order_items.append(order_item)\n        self._recalculate_total()\n\n        self.raise_event(PizzaAddedToOrderEvent(self.id, pizza.id, quantity))\n</code></pre> <p>Value Objects:</p> <pre><code># Pattern: {Concept} (PascalCase, represents a value)\n@dataclass(frozen=True)\nclass Money:\n    amount: Decimal\n    currency: str = \"USD\"\n\n    def add(self, other: 'Money') -&gt; 'Money':\n        if self.currency != other.currency:\n            raise ValueError(\"Cannot add different currencies\")\n        return Money(self.amount + other.amount, self.currency)\n\n@dataclass(frozen=True)\nclass Address:\n    street: str\n    city: str\n    state: str\n    zip_code: str\n    country: str = \"USA\"\n\n    def to_display_string(self) -&gt; str:\n        return f\"{self.street}, {self.city}, {self.state} {self.zip_code}\"\n\n@dataclass(frozen=True)\nclass EmailAddress:\n    value: str\n\n    def __post_init__(self):\n        if \"@\" not in self.value:\n            raise ValueError(\"Invalid email address\")\n</code></pre> <p>Domain Events:</p> <pre><code># Pattern: {Entity}{Action}Event (PascalCase)\n@dataclass\nclass PizzaCreatedEvent(DomainEvent[str]):\n    pizza_id: str\n    pizza_name: str\n    created_by: str\n    created_at: datetime = field(default_factory=datetime.now)\n\n@dataclass\nclass OrderConfirmedEvent(DomainEvent[str]):\n    order_id: str\n    customer_id: str\n    total_amount: Decimal\n    estimated_delivery: datetime\n\n@dataclass\nclass PaymentProcessedEvent(DomainEvent[str]):\n    payment_id: str\n    order_id: str\n    amount: Decimal\n    payment_method: str\n\n# Complex business events\n@dataclass\nclass PizzaCustomizationCompletedEvent(DomainEvent[str]):\n    pizza_id: str\n    customization_options: Dict[str, Any]\n    final_price: Decimal\n</code></pre> <p>Repository Interfaces:</p> <pre><code># Pattern: {Entity}Repository (PascalCase)\nclass PizzaRepository(Repository[Pizza, str]):\n    @abstractmethod\n    async def get_by_name_async(self, name: str) -&gt; Optional[Pizza]:\n        pass\n\n    @abstractmethod\n    async def get_popular_pizzas_async(self, limit: int = 10) -&gt; List[Pizza]:\n        pass\n\n    @abstractmethod\n    async def search_by_ingredients_async(self, ingredients: List[str]) -&gt; List[Pizza]:\n        pass\n\nclass OrderRepository(Repository[Order, str]):\n    @abstractmethod\n    async def get_by_customer_id_async(self, customer_id: str) -&gt; List[Order]:\n        pass\n\n    @abstractmethod\n    async def get_pending_orders_async(self) -&gt; List[Order]:\n        pass\n</code></pre> <p>Business Exceptions:</p> <pre><code># Pattern: {Reason}Exception (PascalCase)\nclass BusinessRuleViolation(Exception):\n    def __init__(self, message: str, rule_name: str = None):\n        super().__init__(message)\n        self.rule_name = rule_name\n\nclass PizzaNotAvailableException(BusinessRuleViolation):\n    def __init__(self, pizza_name: str):\n        super().__init__(f\"Pizza '{pizza_name}' is not available\")\n        self.pizza_name = pizza_name\n\nclass InsufficientInventoryException(BusinessRuleViolation):\n    def __init__(self, ingredient_name: str, requested: int, available: int):\n        super().__init__(f\"Insufficient {ingredient_name}: requested {requested}, available {available}\")\n        self.ingredient_name = ingredient_name\n</code></pre>"},{"location":"references/source_code_naming_convention/#integration-layer-integration","title":"\ud83d\udd0c Integration Layer (<code>integration/</code>)","text":"<p>The integration layer handles external systems, databases, and infrastructure concerns.</p> <p>Repository Implementations:</p> <pre><code># Pattern: {Technology}{Entity}Repository (PascalCase)\nclass MongoDbPizzaRepository(PizzaRepository):\n    def __init__(self, database: Database):\n        self._collection = database.pizzas    # snake_case field\n\n    async def save_async(self, pizza: Pizza) -&gt; None:\n        pizza_doc = {\n            \"_id\": pizza.id,\n            \"name\": pizza.name,\n            \"base_price\": float(pizza.base_price),\n            \"ingredients\": [i.to_dict() for i in pizza.ingredients],\n            \"created_at\": pizza.created_at.isoformat()\n        }\n        await self._collection.insert_one(pizza_doc)\n\n    async def get_by_id_async(self, pizza_id: str) -&gt; Optional[Pizza]:\n        doc = await self._collection.find_one({\"_id\": pizza_id})\n        return self._map_to_pizza(doc) if doc else None\n\nclass InMemoryPizzaRepository(PizzaRepository):\n    def __init__(self):\n        self._store: Dict[str, Pizza] = {}    # snake_case field\n\n    async def save_async(self, pizza: Pizza) -&gt; None:\n        self._store[pizza.id] = pizza\n</code></pre> <p>External Service Clients:</p> <pre><code># Pattern: {Service}Client or {System}Service (PascalCase)\nclass PaymentGatewayClient:\n    def __init__(self, api_key: str, base_url: str):\n        self._api_key = api_key\n        self._base_url = base_url\n        self._http_client = httpx.AsyncClient()\n\n    async def process_payment_async(self, payment_request: PaymentRequest) -&gt; PaymentResponse:\n        pass\n\n    async def refund_payment_async(self, transaction_id: str) -&gt; RefundResponse:\n        pass\n\nclass EmailNotificationService:\n    async def send_order_confirmation_async(self, order: Order, customer_email: str) -&gt; None:\n        pass\n\n    async def send_delivery_notification_async(self, order: Order) -&gt; None:\n        pass\n\nclass InventoryManagementService:\n    async def check_ingredient_availability_async(self, ingredient_id: str) -&gt; int:\n        pass\n\n    async def reserve_ingredients_async(self, reservations: List[IngredientReservation]) -&gt; bool:\n        pass\n</code></pre> <p>Configuration Models:</p> <pre><code># Pattern: {Purpose}Settings or {System}Config (PascalCase)\nclass DatabaseSettings(BaseSettings):\n    connection_string: str           # snake_case fields\n    database_name: str\n    connection_timeout: int = 30\n\n    class Config:\n        env_prefix = \"DATABASE_\"\n\nclass ApiSettings(BaseSettings):\n    host: str = \"0.0.0.0\"\n    port: int = 8000\n    debug: bool = False\n    cors_origins: List[str] = [\"*\"]\n\nclass PaymentGatewaySettings(BaseSettings):\n    api_key: str\n    webhook_secret: str\n    sandbox_mode: bool = True\n    timeout_seconds: int = 30\n</code></pre>"},{"location":"references/source_code_naming_convention/#testing-naming-conventions","title":"\ud83e\uddea Testing Naming Conventions","text":"<p>Consistent test naming makes it easy to understand what's being tested and why tests might be failing.</p>"},{"location":"references/source_code_naming_convention/#test-files","title":"Test Files","text":"<pre><code># Pattern: test_{module_under_test}.py\ntest_pizza_service.py\ntest_order_controller.py\ntest_create_pizza_command_handler.py\ntest_mongo_pizza_repository.py\n</code></pre>"},{"location":"references/source_code_naming_convention/#test-classes","title":"Test Classes","text":"<pre><code># Pattern: Test{ClassUnderTest}\nclass TestPizzaService:\n    pass\n\nclass TestCreatePizzaCommandHandler:\n    pass\n\nclass TestOrderController:\n    pass\n</code></pre>"},{"location":"references/source_code_naming_convention/#test-methods","title":"Test Methods","text":"<pre><code>class TestPizzaService:\n    # Pattern: test_{method}_{scenario}_{expected_result}\n    def test_calculate_total_price_with_large_pizza_returns_correct_amount(self):\n        pass\n\n    def test_add_ingredient_with_max_ingredients_raises_exception(self):\n        pass\n\n    def test_create_pizza_with_valid_data_returns_success(self):\n        pass\n\n    # Async tests\n    @pytest.mark.asyncio\n    async def test_save_pizza_async_with_valid_data_saves_successfully(self):\n        pass\n\n    @pytest.mark.asyncio\n    async def test_get_pizza_by_id_async_with_nonexistent_id_returns_none(self):\n        pass\n</code></pre>"},{"location":"references/source_code_naming_convention/#test-fixtures-and-utilities","title":"Test Fixtures and Utilities","text":"<pre><code># Pattern: create_{entity} or {entity}_fixture\n@pytest.fixture\ndef pizza_fixture():\n    return Pizza(name=\"Margherita\", base_price=Decimal(\"12.99\"))\n\n@pytest.fixture\ndef customer_fixture():\n    return Customer(name=\"Mario\", email=\"mario@test.com\")\n\ndef create_test_pizza(name: str = \"Test Pizza\") -&gt; Pizza:\n    return Pizza(name=name, base_price=Decimal(\"10.00\"))\n\ndef create_mock_repository() -&gt; Mock:\n    repository = Mock(spec=PizzaRepository)\n    repository.save_async.return_value = None\n    return repository\n</code></pre>"},{"location":"references/source_code_naming_convention/#case-conversion-patterns","title":"\ud83d\udd04 Case Conversion Patterns","text":"<p>The framework provides utilities to handle different naming conventions across system boundaries.</p>"},{"location":"references/source_code_naming_convention/#api-boundary-conversion","title":"API Boundary Conversion","text":"<pre><code># Internal Python code uses snake_case\nclass PizzaService:\n    def __init__(self):\n        self.total_price = Decimal(\"0\")      # snake_case\n        self.cooking_time = 15\n        self.ingredient_list = []\n\n# API DTOs can use camelCase for frontend compatibility\nclass PizzaDto(CamelModel):\n    pizza_name: str          # Becomes \"pizzaName\" in JSON\n    base_price: Decimal      # Becomes \"basePrice\" in JSON\n    cooking_time: int        # Becomes \"cookingTime\" in JSON\n    ingredient_list: List[str]  # Becomes \"ingredientList\" in JSON\n\n# Frontend receives camelCase JSON\n{\n    \"pizzaName\": \"Margherita\",\n    \"basePrice\": 12.99,\n    \"cookingTime\": 15,\n    \"ingredientList\": [\"tomato\", \"mozzarella\", \"basil\"]\n}\n</code></pre>"},{"location":"references/source_code_naming_convention/#database-field-mapping","title":"Database Field Mapping","text":"<pre><code># Python entity with snake_case\nclass Pizza(Entity):\n    def __init__(self):\n        self.pizza_name = \"\"         # snake_case in Python\n        self.base_price = Decimal(\"0\")\n        self.created_at = datetime.now()\n\n# MongoDB document mapping\npizza_document = {\n    \"pizza_name\": pizza.pizza_name,      # snake_case in database\n    \"base_price\": float(pizza.base_price),\n    \"created_at\": pizza.created_at.isoformat()\n}\n\n# SQL table with snake_case columns\nCREATE TABLE pizzas (\n    pizza_id UUID PRIMARY KEY,\n    pizza_name VARCHAR(100) NOT NULL,    -- snake_case columns\n    base_price DECIMAL(10,2) NOT NULL,\n    created_at TIMESTAMP DEFAULT NOW()\n);\n</code></pre>"},{"location":"references/source_code_naming_convention/#file-and-directory-naming","title":"\ud83d\udcc1 File and Directory Naming","text":"<p>Consistent file organization makes codebases navigable and maintainable.</p>"},{"location":"references/source_code_naming_convention/#file-naming-patterns","title":"File Naming Patterns","text":"<pre><code># \u2705 Correct - snake_case for all files\npizza_service.py\ncreate_order_command.py\nmongo_pizza_repository.py\norder_controller.py\npizza_created_event.py\n\n# \u274c Incorrect\nPizzaService.py\nCreateOrderCommand.py\nMongoPizzaRepository.py\nOrderController.py\n</code></pre>"},{"location":"references/source_code_naming_convention/#directory-structure","title":"Directory Structure","text":"<pre><code>src/marios_pizzeria/\n\u251c\u2500\u2500 api/                          # Layer directories\n\u2502   \u251c\u2500\u2500 controllers/              # Component type directories\n\u2502   \u2502   \u251c\u2500\u2500 pizzas_controller.py  # Plural for REST controllers\n\u2502   \u2502   \u251c\u2500\u2500 orders_controller.py\n\u2502   \u2502   \u2514\u2500\u2500 customers_controller.py\n\u2502   \u2514\u2500\u2500 dtos/\n\u2502       \u251c\u2500\u2500 pizza_dto.py          # Singular entity + dto\n\u2502       \u251c\u2500\u2500 create_pizza_dto.py   # Action + entity + dto\n\u2502       \u2514\u2500\u2500 order_dto.py\n\u251c\u2500\u2500 application/\n\u2502   \u251c\u2500\u2500 commands/\n\u2502   \u2502   \u251c\u2500\u2500 pizzas/               # Group by entity\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 create_pizza_command.py\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 update_pizza_command.py\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 delete_pizza_command.py\n\u2502   \u2502   \u2514\u2500\u2500 orders/\n\u2502   \u2502       \u251c\u2500\u2500 create_order_command.py\n\u2502   \u2502       \u2514\u2500\u2500 confirm_order_command.py\n\u2502   \u251c\u2500\u2500 queries/\n\u2502   \u2502   \u251c\u2500\u2500 get_pizza_by_id_query.py\n\u2502   \u2502   \u2514\u2500\u2500 search_pizzas_query.py\n\u2502   \u2514\u2500\u2500 handlers/\n\u2502       \u251c\u2500\u2500 create_pizza_handler.py\n\u2502       \u2514\u2500\u2500 process_order_handler.py\n\u251c\u2500\u2500 domain/\n\u2502   \u251c\u2500\u2500 entities/\n\u2502   \u2502   \u251c\u2500\u2500 pizza.py              # Singular entity names\n\u2502   \u2502   \u251c\u2500\u2500 order.py\n\u2502   \u2502   \u2514\u2500\u2500 customer.py\n\u2502   \u251c\u2500\u2500 events/\n\u2502   \u2502   \u251c\u2500\u2500 pizza_events.py       # Group related events\n\u2502   \u2502   \u2514\u2500\u2500 order_events.py\n\u2502   \u251c\u2500\u2500 repositories/\n\u2502   \u2502   \u251c\u2500\u2500 pizza_repository.py   # Abstract interfaces\n\u2502   \u2502   \u2514\u2500\u2500 order_repository.py\n\u2502   \u2514\u2500\u2500 exceptions/\n\u2502       \u251c\u2500\u2500 business_exceptions.py\n\u2502       \u2514\u2500\u2500 validation_exceptions.py\n\u2514\u2500\u2500 integration/\n    \u251c\u2500\u2500 repositories/\n    \u2502   \u251c\u2500\u2500 mongodb_pizza_repository.py  # Technology + entity + repository\n    \u2502   \u2514\u2500\u2500 postgres_order_repository.py\n    \u251c\u2500\u2500 services/\n    \u2502   \u251c\u2500\u2500 payment_gateway_client.py\n    \u2502   \u2514\u2500\u2500 email_notification_service.py\n    \u2514\u2500\u2500 configuration/\n        \u251c\u2500\u2500 database_settings.py\n        \u2514\u2500\u2500 api_settings.py\n</code></pre>"},{"location":"references/source_code_naming_convention/#common-anti-patterns-to-avoid","title":"\u26a1 Common Anti-Patterns to Avoid","text":""},{"location":"references/source_code_naming_convention/#inconsistent-casing","title":"\u274c Inconsistent Casing","text":"<pre><code># \u274c Mixed conventions in same context\nclass PizzaService:\n    def __init__(self):\n        self.pizzaName = \"\"          # camelCase in Python\n        self.base_price = Decimal(\"0\")  # snake_case\n        self.CookingTime = 15        # PascalCase\n\n# \u2705 Consistent snake_case\nclass PizzaService:\n    def __init__(self):\n        self.pizza_name = \"\"\n        self.base_price = Decimal(\"0\")\n        self.cooking_time = 15\n</code></pre>"},{"location":"references/source_code_naming_convention/#unclear-abbreviations","title":"\u274c Unclear Abbreviations","text":"<pre><code># \u274c Cryptic abbreviations\nclass PzSvc:           # Pizza Service?\n    def calc_ttl_prc(self):  # Calculate total price?\n        pass\n\ndef proc_ord(ord_id):  # Process order?\n    pass\n\n# \u2705 Clear, descriptive names\nclass PizzaService:\n    def calculate_total_price(self):\n        pass\n\ndef process_order(order_id: str):\n    pass\n</code></pre>"},{"location":"references/source_code_naming_convention/#misleading-names","title":"\u274c Misleading Names","text":"<pre><code># \u274c Name doesn't match behavior\nclass PizzaService:\n    def get_pizza(self, pizza_id: str):\n        # Actually creates and saves a new pizza!\n        pizza = Pizza(\"New Pizza\", Decimal(\"10.00\"))\n        self.repository.save(pizza)\n        return pizza\n\n# \u2705 Name matches behavior\nclass PizzaService:\n    def create_pizza(self, name: str, price: Decimal) -&gt; Pizza:\n        pizza = Pizza(name, price)\n        self.repository.save(pizza)\n        return pizza\n\n    def get_pizza(self, pizza_id: str) -&gt; Optional[Pizza]:\n        return self.repository.get_by_id(pizza_id)\n</code></pre>"},{"location":"references/source_code_naming_convention/#generic-names","title":"\u274c Generic Names","text":"<pre><code># \u274c Too generic\nclass Manager:\n    pass\n\nclass Helper:\n    pass\n\ndef process(data):\n    pass\n\n# \u2705 Specific and descriptive\nclass OrderManager:\n    pass\n\nclass PizzaValidationHelper:\n    pass\n\ndef process_payment_transaction(payment_info: PaymentInfo):\n    pass\n</code></pre>"},{"location":"references/source_code_naming_convention/#framework-specific-patterns","title":"\ud83c\udfaf Framework-Specific Patterns","text":""},{"location":"references/source_code_naming_convention/#command-and-query-naming","title":"Command and Query Naming","text":"<pre><code># Commands (imperative, action-oriented)\nclass CreatePizzaCommand:         # Create + Entity + Command\nclass UpdateOrderStatusCommand:   # Update + Entity + Attribute + Command\nclass ProcessPaymentCommand:      # Process + Concept + Command\nclass CancelOrderCommand:         # Cancel + Entity + Command\n\n# Queries (descriptive, question-oriented)\nclass GetPizzaByIdQuery:          # Get + Entity + Criteria + Query\nclass FindOrdersByCustomerQuery:  # Find + Entity + Criteria + Query\nclass SearchPizzasQuery:          # Search + Entity + Query\nclass CountActiveOrdersQuery:     # Count + Description + Query\n</code></pre>"},{"location":"references/source_code_naming_convention/#event-naming","title":"Event Naming","text":"<pre><code># Domain Events (past tense, what happened)\nclass PizzaCreatedEvent:          # Entity + Action + Event\nclass OrderConfirmedEvent:        # Entity + Action + Event\nclass PaymentProcessedEvent:      # Concept + Action + Event\nclass InventoryUpdatedEvent:      # System + Action + Event\n\n# Integration Events (external system communication)\nclass CustomerRegisteredIntegrationEvent:  # Action + Integration + Event\nclass OrderShippedIntegrationEvent:        # Action + Integration + Event\n</code></pre>"},{"location":"references/source_code_naming_convention/#repository-naming","title":"Repository Naming","text":"<pre><code># Abstract repositories (domain layer)\nclass PizzaRepository(Repository[Pizza, str]):\n    pass\n\n# Concrete implementations (integration layer)\nclass MongoDbPizzaRepository(PizzaRepository):\n    pass\n\nclass PostgreSqlOrderRepository(OrderRepository):\n    pass\n\nclass InMemoryCustomerRepository(CustomerRepository):  # For testing\n    pass\n</code></pre>"},{"location":"references/source_code_naming_convention/#best-practices-summary","title":"\ud83d\ude80 Best Practices Summary","text":""},{"location":"references/source_code_naming_convention/#dos","title":"\u2705 Do's","text":"<ol> <li>Be Consistent: Use the same patterns throughout your codebase</li> <li>Be Descriptive: Names should clearly indicate purpose and behavior</li> <li>Follow Layer Conventions: Different layers have different naming patterns</li> <li>Use Standard Suffixes: Command, Query, Handler, Repository, Service, etc.</li> <li>Group Related Items: Use directories and modules to organize related code</li> <li>Consider Context: API DTOs might need different casing than internal models</li> <li>Test Names Should Tell Stories: Long, descriptive test method names are good</li> </ol>"},{"location":"references/source_code_naming_convention/#donts","title":"\u274c Don'ts","text":"<ol> <li>Don't Mix Conventions: Pick snake_case or camelCase and stick to it within context</li> <li>Don't Use Abbreviations: Prefer <code>customer_service</code> over <code>cust_svc</code></li> <li>Don't Use Generic Names: Avoid <code>Manager</code>, <code>Helper</code>, <code>Utility</code> without context</li> <li>Don't Ignore Framework Patterns: Follow established Command/Query/Handler patterns</li> <li>Don't Violate Layer Naming: Controllers in API layer, Handlers in Application layer</li> <li>Don't Use Misleading Names: Names should match actual behavior</li> <li>Don't Skip Namespace Prefixes: Use clear module organization</li> </ol>"},{"location":"references/source_code_naming_convention/#marios-pizzeria-example","title":"\ud83c\udf55 Mario's Pizzeria Example","text":"<p>Here's how all these conventions work together in a complete feature:</p> <pre><code># Domain Layer - domain/entities/pizza.py\nclass Pizza(Entity[str]):\n    def __init__(self, name: str, base_price: Decimal):\n        super().__init__()\n        self.name = name\n        self.base_price = base_price\n        self.toppings = []\n\n    def add_topping(self, topping: Topping) -&gt; None:\n        if len(self.toppings) &gt;= self.MAX_TOPPINGS:\n            raise TooManyToppingsException(self.name)\n\n        self.toppings.append(topping)\n        self.raise_event(ToppingAddedEvent(self.id, topping.id))\n\n# Domain Layer - domain/events/pizza_events.py\n@dataclass\nclass PizzaCreatedEvent(DomainEvent[str]):\n    pizza_id: str\n    pizza_name: str\n    base_price: Decimal\n\n# Application Layer - application/commands/create_pizza_command.py\n@dataclass\nclass CreatePizzaCommand(Command[OperationResult[PizzaDto]]):\n    pizza_name: str\n    base_price: Decimal\n    topping_ids: List[str]\n\n# Application Layer - application/handlers/create_pizza_handler.py\nclass CreatePizzaCommandHandler(CommandHandler[CreatePizzaCommand, OperationResult[PizzaDto]]):\n    async def handle_async(self, command: CreatePizzaCommand) -&gt; OperationResult[PizzaDto]:\n        pizza = Pizza(command.pizza_name, command.base_price)\n        await self._pizza_repository.save_async(pizza)\n        return self.created(self._mapper.map(pizza, PizzaDto))\n\n# API Layer - api/controllers/pizzas_controller.py\nclass PizzasController(ControllerBase):\n    @post(\"/\", response_model=PizzaDto, status_code=201)\n    async def create_pizza(self, create_dto: CreatePizzaDto) -&gt; PizzaDto:\n        command = self.mapper.map(create_dto, CreatePizzaCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n# Integration Layer - integration/repositories/mongodb_pizza_repository.py\nclass MongoDbPizzaRepository(PizzaRepository):\n    async def save_async(self, pizza: Pizza) -&gt; None:\n        document = self._map_to_document(pizza)\n        await self._collection.insert_one(document)\n</code></pre> <p>This example demonstrates how naming conventions create a clear, navigable codebase where each component's purpose and location are immediately obvious.</p>"},{"location":"references/source_code_naming_convention/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Python Typing Guide - Complete guide to type hints, generics, and advanced typing patterns</li> <li>Python Object-Oriented Programming - OOP principles and class design</li> <li>CQRS &amp; Mediation - Command and query pattern implementation</li> <li>Dependency Injection - Service registration and naming patterns</li> </ul>"},{"location":"references/test-mermaid/","title":"Mermaid Test Page","text":"<p>This page tests Mermaid diagram rendering in MkDocs.</p>"},{"location":"references/test-mermaid/#basic-flowchart","title":"Basic Flowchart","text":"<pre><code>graph TD\n    A[Start] --&gt; B{Is it working?}\n    B --&gt;|Yes| C[Great!]\n    B --&gt;|No| D[Debug]\n    D --&gt; A\n    C --&gt; E[End]</code></pre>"},{"location":"references/test-mermaid/#sequence-diagram","title":"Sequence Diagram","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Controller\n    participant Service\n    participant Database\n\n    User-&gt;&gt;Controller: HTTP Request\n    Controller-&gt;&gt;Service: Business Logic\n    Service-&gt;&gt;Database: Query Data\n    Database--&gt;&gt;Service: Result\n    Service--&gt;&gt;Controller: Response\n    Controller--&gt;&gt;User: HTTP Response</code></pre>"},{"location":"references/test-mermaid/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>graph TB\n    subgraph \"Application Layer\"\n        A[Controllers] --&gt; B[Mediator]\n        B --&gt; C[Command Handlers]\n        B --&gt; D[Query Handlers]\n    end\n\n    subgraph \"Domain Layer\"\n        E[Entities] --&gt; F[Value Objects]\n        E --&gt; G[Domain Events]\n    end\n\n    subgraph \"Integration Layer\"\n        H[Repositories] --&gt; I[External APIs]\n        H --&gt; J[Database]\n    end\n\n    C --&gt; E\n    D --&gt; H\n    A --&gt; B</code></pre>"},{"location":"references/test-mermaid/#class-diagram","title":"Class Diagram","text":"<pre><code>classDiagram\n    class Controller {\n        +service_provider: ServiceProvider\n        +mediator: Mediator\n        +mapper: Mapper\n        +process(result: OperationResult): Response\n    }\n\n    class CommandHandler {\n        +handle_async(command: Command): OperationResult\n    }\n\n    class QueryHandler {\n        +handle_async(query: Query): Result\n    }\n\n    Controller --&gt; CommandHandler : uses\n    Controller --&gt; QueryHandler : uses\n    CommandHandler --&gt; Entity : creates/modifies\n    QueryHandler --&gt; Repository : reads from</code></pre>"},{"location":"samples/","title":"\ud83d\udcbc Sample Applications","text":"<p>Comprehensive sample applications that demonstrate real-world implementation of the Neuroglia framework. Each sample showcases different architectural patterns, integration scenarios, and business domains to provide practical guidance for building production-ready systems.</p>"},{"location":"samples/#production-ready-examples","title":"\ud83c\udfe6 Production-Ready Examples","text":""},{"location":"samples/#openbank-event-sourcing-banking-system","title":"\ud83c\udfe6 OpenBank - Event Sourcing Banking System","text":"<p>A complete banking system demonstrating event sourcing, CQRS, and financial domain modeling. Shows how to handle complex business rules, audit trails, and regulatory compliance.</p> <p>Domain Focus:</p> <ul> <li>Account management</li> <li>Transaction processing</li> <li>Balance calculations</li> <li>Regulatory compliance</li> </ul> <p>Key Patterns:</p> <ul> <li>Event sourcing with snapshots</li> <li>Complex domain aggregates</li> <li>Financial calculations with precision</li> <li>Audit trail implementation</li> </ul> <p>Technology Stack:</p> <ul> <li>EventStoreDB for event persistence</li> <li>MongoDB for read models</li> <li>FastAPI for REST APIs</li> <li>Comprehensive test coverage</li> </ul>"},{"location":"samples/#api-gateway-microservice-orchestration","title":"\ud83c\udf10 API Gateway - Microservice Orchestration","text":"<p>Demonstrates microservice coordination, request routing, and cross-cutting concerns like authentication, rate limiting, and monitoring.</p> <p>Domain Focus:</p> <ul> <li>Service discovery and routing</li> <li>Authentication and authorization</li> <li>Request/response transformation</li> <li>Circuit breaker patterns</li> </ul> <p>Key Patterns:</p> <ul> <li>Gateway aggregation pattern</li> <li>Service mesh integration</li> <li>Distributed tracing</li> <li>Health check orchestration</li> </ul> <p>Technology Stack:</p> <ul> <li>FastAPI for gateway implementation</li> <li>Redis for caching and rate limiting</li> <li>Prometheus for metrics</li> <li>Distributed logging</li> </ul>"},{"location":"samples/#desktop-controller-background-services","title":"\ud83d\udda5\ufe0f Desktop Controller - Background Services","text":"<p>Shows how to build background services that interact with system resources, handle long-running operations, and manage desktop environments.</p> <p>Domain Focus:</p> <ul> <li>System resource management</li> <li>Process orchestration</li> <li>File system operations</li> <li>Desktop environment control</li> </ul> <p>Key Patterns:</p> <ul> <li>Background service patterns</li> <li>Resource locking mechanisms</li> <li>Process lifecycle management</li> <li>System integration patterns</li> </ul> <p>Technology Stack:</p> <ul> <li>Background service hosting</li> <li>File system watchers</li> <li>System API integration</li> <li>Inter-process communication</li> </ul>"},{"location":"samples/#getting-started-with-samples","title":"\ud83d\ude80 Getting Started with Samples","text":""},{"location":"samples/#quick-start-guide","title":"Quick Start Guide","text":"<ol> <li>Choose Your Domain: Select the sample that matches your use case</li> <li>Review Architecture: Understand the patterns and structure</li> <li>Run Locally: Follow setup instructions for local development</li> <li>Explore Code: Study the implementation details</li> <li>Adapt and Extend: Customize for your specific needs</li> </ol>"},{"location":"samples/#sample-complexity-levels","title":"Sample Complexity Levels","text":""},{"location":"samples/#beginner-level","title":"\ud83d\udfe2 Beginner Level","text":"<ul> <li>Desktop Controller: Straightforward background services</li> <li>Clear separation of concerns</li> <li>Basic integration patterns</li> </ul>"},{"location":"samples/#intermediate-level","title":"\ud83d\udfe1 Intermediate Level","text":"<ul> <li>API Gateway: Microservice coordination</li> <li>Cross-cutting concerns implementation</li> <li>Distributed system patterns</li> </ul>"},{"location":"samples/#advanced-level","title":"\ud83d\udd34 Advanced Level","text":"<ul> <li>OpenBank: Complex event sourcing</li> <li>Lab Resource Manager: Kubernetes operators</li> <li>Advanced domain modeling</li> </ul>"},{"location":"samples/#development-and-testing","title":"\ud83e\uddea Development and Testing","text":""},{"location":"samples/#local-development-setup","title":"Local Development Setup","text":"<p>Each sample includes:</p> <ul> <li>Docker Compose: Complete local environment</li> <li>Development Scripts: Build, test, and run commands</li> <li>Database Migrations: Schema and data setup</li> <li>Mock Services: External dependency simulation</li> </ul>"},{"location":"samples/#testing-strategies","title":"Testing Strategies","text":"<pre><code>graph LR\n    A[Unit Tests&lt;br/&gt;\ud83e\uddea Components] --&gt; B[Integration Tests&lt;br/&gt;\ud83d\udd17 Services]\n    B --&gt; C[End-to-End Tests&lt;br/&gt;\ud83c\udfaf Workflows]\n    C --&gt; D[Performance Tests&lt;br/&gt;\u26a1 Load Testing]\n\n    style A fill:#e8f5e8\n    style B fill:#e3f2fd\n    style C fill:#fff3e0\n    style D fill:#f3e5f5</code></pre>"},{"location":"samples/#deployment-options","title":"Deployment Options","text":"<ul> <li>Local Development: Docker Compose environments</li> <li>Cloud Deployment: Kubernetes manifests and Helm charts</li> <li>CI/CD Pipelines: GitHub Actions and Jenkins examples</li> <li>Monitoring Setup: Observability and logging configuration</li> </ul>"},{"location":"samples/#sample-comparison-matrix","title":"\ud83d\udcca Sample Comparison Matrix","text":"Feature OpenBank API Gateway Desktop Controller Complexity \ud83d\udd34 Advanced \ud83d\udfe1 Intermediate \ud83d\udfe2 Beginner Domain Financial Integration System Architecture Event Sourcing Gateway Pattern Background Services Storage EventStore + Mongo Redis + SQL File System Integration REST APIs Multiple Services System APIs Deployment Cloud/On-Premise Cloud Native Desktop/Server"},{"location":"samples/#learning-outcomes","title":"\ud83c\udf93 Learning Outcomes","text":""},{"location":"samples/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Real-world Implementation: See patterns in action</li> <li>Best Practices: Production-ready code examples</li> <li>Testing Strategies: Comprehensive test coverage</li> <li>Deployment Patterns: Multiple deployment scenarios</li> <li>Performance Optimization: Scalability considerations</li> </ul>"},{"location":"samples/#skills-developed","title":"Skills Developed","text":"<ul> <li>Architecture Design: Pattern selection and implementation</li> <li>Domain Modeling: Business logic representation</li> <li>Integration Patterns: External system coordination</li> <li>Testing Mastery: Test strategy development</li> <li>Operations Knowledge: Deployment and monitoring</li> </ul>"},{"location":"samples/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\ud83c\udfaf Architecture Patterns - Foundational design patterns</li> <li>\ud83d\ude80 Framework Features - Detailed feature documentation</li> <li>\ud83d\udcd6 Implementation Guides - Step-by-step tutorials</li> <li>\ud83c\udf55 Mario's Pizzeria - Unified domain example</li> </ul>"},{"location":"samples/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ol> <li>Explore Sample Code: Clone and run the samples locally</li> <li>Study Implementation: Review architecture decisions and patterns</li> <li>Adapt for Your Needs: Use samples as starting templates</li> <li>Contribute Back: Share improvements and additional samples</li> </ol> <p>Each sample application is production-ready and includes comprehensive documentation, tests, and deployment guides. They serve as both learning resources and starting templates for your own applications.</p>"},{"location":"samples/api_gateway/","title":"\ud83d\ude80 API Gateway Sample Application","text":"<p>The API Gateway sample demonstrates how to build a modern microservice gateway using the Neuroglia framework. This application showcases advanced patterns including OAuth2 authentication, external service integration, background task processing, and cloud event handling.</p>"},{"location":"samples/api_gateway/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>Microservice Gateway Patterns: How to build a centralized API gateway for service orchestration</li> <li>OAuth2 Authentication &amp; Authorization: Implementing JWT-based security with Keycloak integration</li> <li>External Service Integration: Connecting to multiple external APIs with proper abstraction</li> <li>Background Task Processing: Asynchronous task execution with Redis-backed job scheduling</li> <li>Object Storage Integration: File management with MinIO S3-compatible storage</li> <li>Cloud Events: Event-driven communication between microservices</li> <li>Advanced Dependency Injection: Complex service configuration and lifetime management</li> </ul>"},{"location":"samples/api_gateway/#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<pre><code>graph TB\n    subgraph \"API Gateway Service\"\n        A[PromptController] --&gt; B[Mediator]\n        B --&gt; C[Command/Query Handlers]\n        C --&gt; D[Domain Models]\n        C --&gt; E[Integration Services]\n\n        F[OAuth2 Middleware] --&gt; A\n        G[Cloud Event Middleware] --&gt; A\n        H[Exception Handling] --&gt; A\n    end\n\n    subgraph \"External Dependencies\"\n        I[Keycloak OAuth2]\n        J[Redis Cache]\n        K[MinIO Storage]\n        L[External APIs]\n        M[Background Tasks]\n    end\n\n    E --&gt; I\n    E --&gt; J\n    E --&gt; K\n    E --&gt; L\n    C --&gt; M</code></pre> <p>The API Gateway follows a distributed microservice pattern where:</p> <ul> <li>Gateway Layer: Centralized entry point for multiple downstream services</li> <li>Authentication Layer: OAuth2/JWT-based security with external identity provider</li> <li>Integration Layer: Multiple external service clients with proper abstraction</li> <li>DTOs: Data transfer objects for external communication</li> </ul>"},{"location":"samples/api_gateway/#key-features-demonstrated","title":"\ud83d\ude80 Key Features Demonstrated","text":""},{"location":"samples/api_gateway/#1-oauth2-authentication-security","title":"1. OAuth2 Authentication &amp; Security","text":"<pre><code># JWT token validation with Keycloak\n@post(\"/item\", response_model=ItemPromptCommandResponseDto)\nasync def create_new_item_prompt(\n    self,\n    command_dto: CreateNewItemPromptCommandDto,\n    key: str = Depends(validate_mosaic_authentication)\n) -&gt; Any:\n    # Protected endpoint with API key validation\n</code></pre>"},{"location":"samples/api_gateway/#2-multi-service-integration","title":"2. Multi-Service Integration","text":"<pre><code># External service clients\nMinioStorageManager.configure(builder)          # Object storage\nMosaicApiClient.configure(builder)              # External API\nAsyncStringCacheRepository.configure(builder)   # Redis caching\nBackgroundTaskScheduler.configure(builder)      # Async processing\n</code></pre>"},{"location":"samples/api_gateway/#3-advanced-domain-model","title":"3. Advanced Domain Model","text":"<pre><code>@map_to(PromptResponseDto)\n@dataclass\nclass PromptResponse:\n    id: str\n    prompt_id: str\n    content: str\n    status: PromptStatus\n    metadata: dict[str, Any]\n    created_at: datetime.datetime\n</code></pre>"},{"location":"samples/api_gateway/#4-background-task-processing","title":"4. Background Task Processing","text":"<pre><code># Asynchronous task execution\nBackgroundTaskScheduler.configure(builder, [\"application.tasks\"])\n\n# Redis-backed job queue\nbackground_job_store: dict[str, str | int] = {\n    \"redis_host\": \"redis47\",\n    \"redis_port\": 6379,\n    \"redis_db\": 0\n}\n</code></pre>"},{"location":"samples/api_gateway/#5-cloud-events-integration","title":"5. Cloud Events Integration","text":"<pre><code># Event publishing and consumption\nCloudEventIngestor.configure(builder, [\"application.events.integration\"])\nCloudEventPublisher.configure(builder)\napp.add_middleware(CloudEventMiddleware, service_provider=app.services)\n</code></pre>"},{"location":"samples/api_gateway/#configuration-settings","title":"\ud83d\udd27 Configuration &amp; Settings","text":""},{"location":"samples/api_gateway/#application-settings","title":"Application Settings","text":"<pre><code>class AiGatewaySettings(ApplicationSettings):\n    # OAuth2 Configuration\n    jwt_authority: str = \"http://keycloak47/realms/mozart\"\n    jwt_audience: str = \"ai-gateways\"\n    required_scope: str = \"api\"\n\n    # External Service Settings\n    s3_endpoint: str                    # MinIO storage\n    connection_strings: dict[str, str]  # Redis, databases\n    mosaic_api_keys: list[str]         # API authentication\n\n    # Background Processing\n    background_job_store: dict[str, str | int]\n    redis_max_connections: int = 10\n</code></pre>"},{"location":"samples/api_gateway/#service-registration","title":"Service Registration","text":"<pre><code># Core framework services\nMapper.configure(builder, application_modules)\nMediator.configure(builder, application_modules)\nJsonSerializer.configure(builder)\n\n# Custom application services\nAsyncStringCacheRepository.configure(builder, Prompt, str)\nBackgroundTaskScheduler.configure(builder, [\"application.tasks\"])\nMinioStorageManager.configure(builder)\nLocalFileSystemManager.configure(builder)\n\n# External integrations\nbuilder.services.add_singleton(AiGatewaySettings, singleton=app_settings)\n</code></pre>"},{"location":"samples/api_gateway/#testing-strategy","title":"\ud83e\uddea Testing Strategy","text":""},{"location":"samples/api_gateway/#unit-tests","title":"Unit Tests","text":"<pre><code>class TestPromptController:\n    def setup_method(self):\n        self.mock_mediator = Mock(spec=Mediator)\n        self.mock_mapper = Mock(spec=Mapper)\n        self.controller = PromptController(\n            service_provider=Mock(),\n            mapper=self.mock_mapper,\n            mediator=self.mock_mediator\n        )\n\n    @pytest.mark.asyncio\n    async def test_create_prompt_success(self):\n        # Test successful prompt creation\n        command_dto = CreateNewItemPromptCommandDto(content=\"test\")\n        result = await self.controller.create_new_item_prompt(command_dto, \"valid-key\")\n\n        assert result.status == \"created\"\n        self.mock_mediator.execute_async.assert_called_once()\n</code></pre>"},{"location":"samples/api_gateway/#integration-tests","title":"Integration Tests","text":"<pre><code>@pytest.mark.integration\nclass TestApiGatewayIntegration:\n    @pytest.mark.asyncio\n    async def test_full_prompt_workflow(self, test_client):\n        # Test complete workflow from API to external services\n        response = await test_client.post(\n            \"/api/prompts/item\",\n            json={\"content\": \"test prompt\"},\n            headers={\"Authorization\": \"Bearer valid-token\"}\n        )\n\n        assert response.status_code == 201\n        assert \"id\" in response.json()\n</code></pre>"},{"location":"samples/api_gateway/#implementation-details","title":"\ud83d\udcda Implementation Details","text":""},{"location":"samples/api_gateway/#1-controller-layer-apicontrollers","title":"1. Controller Layer (<code>api/controllers/</code>)","text":"<ul> <li>PromptController: Main API endpoints for prompt management</li> <li>AppController: Application health and metadata endpoints</li> <li>InternalController: Internal service endpoints</li> <li>Authentication Schemes: OAuth2 and API key validation</li> </ul>"},{"location":"samples/api_gateway/#2-application-layer-application","title":"2. Application Layer (<code>application/</code>)","text":"<ul> <li>Commands: Write operations (CreateNewPromptCommand)</li> <li>Queries: Read operations (GetPromptByIdQuery)</li> <li>Services: Business logic orchestration</li> <li>Tasks: Background job definitions</li> <li>Events: Integration event handlers</li> </ul>"},{"location":"samples/api_gateway/#3-domain-layer-domain","title":"3. Domain Layer (<code>domain/</code>)","text":"<ul> <li>Prompt: Core domain entity with business rules</li> <li>PromptResponse: Value object for API responses</li> <li>Domain Events: Business event definitions</li> <li>Validation: Domain-specific validation logic</li> </ul>"},{"location":"samples/api_gateway/#4-integration-layer-integration","title":"4. Integration Layer (<code>integration/</code>)","text":"<ul> <li>External API Clients: Mosaic, GenAI, Mozart APIs</li> <li>Storage Services: MinIO object storage, Redis caching</li> <li>Background Services: Task scheduling and execution</li> <li>DTOs: Data transfer objects for external communication</li> </ul>"},{"location":"samples/api_gateway/#background-processing","title":"\ud83d\udd04 Background Processing","text":"<p>The API Gateway demonstrates advanced background processing patterns:</p> <pre><code># Task scheduling configuration\nBackgroundTaskScheduler.configure(builder, [\"application.tasks\"])\n\n# Redis-backed job store\nbuilder.services.add_singleton(AiGatewaySettings, singleton=app_settings)\n\n# Asynchronous task execution\n@task_handler\nclass ProcessPromptTask:\n    async def execute_async(self, prompt_id: str):\n        # Long-running prompt processing\n        prompt = await self.prompt_service.get_by_id(prompt_id)\n        result = await self.genai_client.process_prompt(prompt)\n        await self.storage_service.store_result(result)\n</code></pre>"},{"location":"samples/api_gateway/#external-service-integration","title":"\ud83c\udf10 External Service Integration","text":""},{"location":"samples/api_gateway/#minio-object-storage","title":"MinIO Object Storage","text":"<pre><code>class MinioStorageManager:\n    async def upload_file_async(self, bucket: str, key: str, data: bytes) -&gt; str:\n        # S3-compatible object storage\n        return await self.client.put_object(bucket, key, data)\n</code></pre>"},{"location":"samples/api_gateway/#redis-caching","title":"Redis Caching","text":"<pre><code>class AsyncStringCacheRepository:\n    async def get_async(self, key: str) -&gt; Optional[str]:\n        return await self.redis_client.get(key)\n\n    async def set_async(self, key: str, value: str, ttl: int = None):\n        await self.redis_client.set(key, value, ex=ttl)\n</code></pre>"},{"location":"samples/api_gateway/#external-api-integration","title":"External API Integration","text":"<pre><code>class MosaicApiClient:\n    async def submit_prompt_async(self, prompt: PromptDto) -&gt; PromptResponseDto:\n        # OAuth2 authenticated API calls\n        token = await self.get_access_token()\n        response = await self.http_client.post(\n            \"/api/prompts\",\n            json=prompt.dict(),\n            headers={\"Authorization\": f\"Bearer {token}\"}\n        )\n        return PromptResponseDto.parse_obj(response.json())\n</code></pre>"},{"location":"samples/api_gateway/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"samples/api_gateway/#1-prerequisites","title":"1. Prerequisites","text":"<pre><code># Install dependencies\npip install -r requirements.txt\n\n# Configure external services\ndocker-compose up -d redis keycloak minio\n</code></pre>"},{"location":"samples/api_gateway/#2-configuration","title":"2. Configuration","text":"<pre><code># Set environment variables\nexport JWT_AUTHORITY=\"http://localhost:8080/realms/mozart\"\nexport S3_ENDPOINT=\"http://localhost:9000\"\nexport REDIS_URL=\"redis://localhost:6379\"\n</code></pre>"},{"location":"samples/api_gateway/#3-run-the-application","title":"3. Run the Application","text":"<pre><code># Start the API Gateway\npython samples/api-gateway/main.py\n\n# Access Swagger UI\nopen http://localhost:8000/docs\n</code></pre>"},{"location":"samples/api_gateway/#4-test-the-api","title":"4. Test the API","text":"<pre><code># Get access token from Keycloak\ncurl -X POST http://localhost:8080/realms/mozart/protocol/openid-connect/token \\\n  -H \"Content-Type: application/x-www-form-urlencoded\" \\\n  -d \"grant_type=client_credentials&amp;client_id=ai-gateway&amp;client_secret=secret\"\n\n# Call protected endpoint\ncurl -X POST http://localhost:8000/api/prompts/item \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"content\": \"Generate a sample prompt\"}'\n</code></pre>"},{"location":"samples/api_gateway/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>CQRS &amp; Mediation - Command/Query patterns</li> <li>Dependency Injection - Service configuration</li> <li>Data Access - Repository patterns</li> <li>OpenBank Sample - Event sourcing comparison</li> <li>Desktop Controller Sample - Background services</li> </ul>"},{"location":"samples/api_gateway/#comparison-with-openbank-sample","title":"\ud83d\udd0d Comparison with OpenBank Sample","text":"<p>The API Gateway and OpenBank samples demonstrate different architectural patterns within the Neuroglia framework. Here's a detailed comparison:</p>"},{"location":"samples/api_gateway/#architecture-patterns","title":"Architecture Patterns","text":"Aspect API Gateway OpenBank Primary Pattern Microservice Gateway Event Sourcing + DDD Data Persistence Multi-store (Redis, MinIO, MongoDB) Event Store + Read Models State Management Stateless with caching Event-sourced aggregates External Integration Multiple external APIs Focused domain model Background Processing Async task queues Event-driven projections"},{"location":"samples/api_gateway/#domain-complexity","title":"Domain Complexity","text":""},{"location":"samples/api_gateway/#api-gateway-integration-focused","title":"API Gateway - Integration-Focused","text":"<pre><code># Simple domain model focused on orchestration\n@dataclass\nclass PromptResponse:\n    id: str\n    prompt_id: str\n    content: str\n    status: PromptStatus\n    metadata: dict[str, Any]\n</code></pre>"},{"location":"samples/api_gateway/#openbank-rich-domain-model","title":"OpenBank - Rich Domain Model","text":"<pre><code># Complex aggregate with business rules\nclass BankAccountV1(AggregateRoot[str]):\n    def record_transaction(self, amount: Decimal, transaction_type: BankTransactionTypeV1):\n        # Complex business logic and invariants\n        if transaction_type == BankTransactionTypeV1.DEBIT:\n            if self.state.balance + amount &lt; -self.state.overdraft_limit:\n                raise InsufficientFundsException()\n\n        # Event sourcing\n        self.raise_event(BankAccountTransactionRecordedDomainEventV1(...))\n</code></pre>"},{"location":"samples/api_gateway/#data-persistence-strategy","title":"Data Persistence Strategy","text":""},{"location":"samples/api_gateway/#api-gateway-multi-store-architecture","title":"API Gateway - Multi-Store Architecture","text":"<pre><code># Multiple specialized storage systems\nAsyncStringCacheRepository.configure(builder, Prompt, str)  # Redis caching\nMinioStorageManager.configure(builder)                      # Object storage\nBackgroundTaskScheduler.configure(builder)                 # Job queue\n\n# Standard CRUD operations\nasync def save_prompt(self, prompt: Prompt):\n    await self.cache_repository.set_async(prompt.id, prompt.content)\n    await self.storage_manager.upload_async(prompt.id, prompt.data)\n</code></pre>"},{"location":"samples/api_gateway/#openbank-event-sourcing","title":"OpenBank - Event Sourcing","text":"<pre><code># Event-driven persistence\nESEventStore.configure(builder, EventStoreOptions(database_name, consumer_group))\n\n# Write model: Event sourcing\nDataAccessLayer.WriteModel.configure(\n    builder,\n    [\"samples.openbank.domain.models\"],\n    lambda builder_, entity_type, key_type: EventSourcingRepository.configure(...)\n)\n\n# Read model: Projections\nDataAccessLayer.ReadModel.configure(\n    builder,\n    [\"samples.openbank.integration.models\"],\n    lambda builder_, entity_type, key_type: MongoRepository.configure(...)\n)\n</code></pre>"},{"location":"samples/api_gateway/#authentication-security","title":"Authentication &amp; Security","text":""},{"location":"samples/api_gateway/#api-gateway-oauth2-api-keys","title":"API Gateway - OAuth2 + API Keys","text":"<pre><code># Multiple authentication schemes\n@post(\"/item\", dependencies=[Depends(validate_mosaic_authentication)])\nasync def create_item_prompt(self, command_dto: CreateNewItemPromptCommandDto):\n    # API key validation for external services\n\n@get(\"/status\", dependencies=[Depends(validate_token)])\nasync def get_status(self):\n    # JWT token validation for internal services\n</code></pre>"},{"location":"samples/api_gateway/#openbank-domain-focused-security","title":"OpenBank - Domain-Focused Security","text":"<pre><code># Business rule enforcement\nclass BankAccountV1(AggregateRoot[str]):\n    def record_transaction(self, amount: Decimal, transaction_type: BankTransactionTypeV1):\n        # Domain-level authorization\n        if not self.is_authorized_for_transaction(amount):\n            raise UnauthorizedTransactionException()\n</code></pre>"},{"location":"samples/api_gateway/#external-service-integration_1","title":"External Service Integration","text":""},{"location":"samples/api_gateway/#api-gateway-extensive-integration","title":"API Gateway - Extensive Integration","text":"<pre><code># Multiple external service clients\nclass MosaicApiClient:\n    async def submit_prompt_async(self, prompt: PromptDto) -&gt; PromptResponseDto:\n        token = await self.oauth_client.get_token_async()\n        return await self.http_client.post(\"/api/prompts\", prompt, token)\n\nclass GenAiClient:\n    async def process_prompt_async(self, prompt: str) -&gt; str:\n        return await self.ai_service.generate_response(prompt)\n\nclass MinioStorageManager:\n    async def store_file_async(self, bucket: str, key: str, data: bytes):\n        return await self.s3_client.put_object(bucket, key, data)\n</code></pre>"},{"location":"samples/api_gateway/#openbank-minimal-integration","title":"OpenBank - Minimal Integration","text":"<pre><code># Focused on domain logic, minimal external dependencies\nclass CreateBankAccountCommandHandler:\n    async def handle_async(self, command: CreateBankAccountCommand):\n        # Pure domain logic without external service calls\n        owner = await self.person_repository.get_by_id_async(command.owner_id)\n        account = BankAccountV1(str(uuid.uuid4()), owner, command.initial_balance)\n        await self.account_repository.save_async(account)\n</code></pre>"},{"location":"samples/api_gateway/#background-processing_1","title":"Background Processing","text":""},{"location":"samples/api_gateway/#api-gateway-task-queue-pattern","title":"API Gateway - Task Queue Pattern","text":"<pre><code># Redis-backed job queues\nBackgroundTaskScheduler.configure(builder, [\"application.tasks\"])\n\n@task_handler\nclass ProcessPromptTask:\n    async def execute_async(self, prompt_id: str):\n        prompt = await self.prompt_service.get_by_id(prompt_id)\n        result = await self.genai_client.process_prompt(prompt)\n        await self.storage_service.store_result(result)\n</code></pre>"},{"location":"samples/api_gateway/#openbank-event-driven-projections","title":"OpenBank - Event-Driven Projections","text":"<pre><code># Event handlers for read model updates\nclass BankAccountEventHandler:\n    @event_handler(BankAccountCreatedDomainEventV1)\n    async def handle_account_created(self, event: BankAccountCreatedDomainEventV1):\n        projection = BankAccountProjection.from_event(event)\n        await self.read_model_repository.save_async(projection)\n</code></pre>"},{"location":"samples/api_gateway/#testing-strategies","title":"Testing Strategies","text":""},{"location":"samples/api_gateway/#api-gateway-integration-heavy-testing","title":"API Gateway - Integration-Heavy Testing","text":"<pre><code>@pytest.mark.integration\nclass TestApiGatewayIntegration:\n    async def test_full_prompt_workflow(self, test_client, mock_external_services):\n        # Test complete workflow including external services\n        response = await test_client.post(\"/api/prompts/item\", json=prompt_data)\n\n        # Verify external service calls\n        mock_external_services.genai_client.process_prompt.assert_called_once()\n        mock_external_services.storage_manager.upload.assert_called_once()\n</code></pre>"},{"location":"samples/api_gateway/#openbank-domain-focused-testing","title":"OpenBank - Domain-Focused Testing","text":"<pre><code>class TestBankAccountAggregate:\n    def test_transaction_recording(self):\n        # Pure domain logic testing\n        account = BankAccountV1(\"123\", owner, Decimal(\"1000\"))\n        account.record_transaction(Decimal(\"-100\"), BankTransactionTypeV1.DEBIT)\n\n        # Verify business rules and events\n        assert account.state.balance == Decimal(\"900\")\n        events = account.get_uncommitted_events()\n        assert isinstance(events[-1], BankAccountTransactionRecordedDomainEventV1)\n</code></pre>"},{"location":"samples/api_gateway/#use-case-recommendations","title":"Use Case Recommendations","text":""},{"location":"samples/api_gateway/#choose-api-gateway-pattern-when","title":"Choose API Gateway Pattern when","text":"<ul> <li>\u2705 Building microservice orchestration layers</li> <li>\u2705 Integrating multiple external services</li> <li>\u2705 Need background job processing</li> <li>\u2705 Require complex authentication schemes</li> <li>\u2705 Working with heterogeneous data stores</li> <li>\u2705 Building service mesh entry points</li> </ul>"},{"location":"samples/api_gateway/#choose-event-sourcing-pattern-when","title":"Choose Event Sourcing Pattern when","text":"<ul> <li>\u2705 Need complete audit trails</li> <li>\u2705 Complex business logic and invariants</li> <li>\u2705 Temporal queries are important</li> <li>\u2705 Regulatory compliance requirements</li> <li>\u2705 High consistency requirements</li> <li>\u2705 Rich domain models with behavior</li> </ul>"},{"location":"samples/api_gateway/#framework-features-utilized","title":"Framework Features Utilized","text":"Feature API Gateway Usage OpenBank Usage CQRS/Mediation Service orchestration Domain command/query separation Dependency Injection External service clients Repository abstractions Event Handling Integration events Domain events + projections Data Access Multi-repository pattern Event sourcing + read models Background Processing Async task queues Event-driven handlers Mapping DTO transformations Domain-to-DTO mapping Validation API contract validation Business rule enforcement <p>Both samples showcase different strengths of the Neuroglia framework, demonstrating its flexibility in supporting various architectural patterns while maintaining clean architecture principles.</p>"},{"location":"samples/desktop_controller/","title":"\ud83d\udda5\ufe0f Desktop Controller Sample Application","text":"<p>The Desktop Controller sample demonstrates how to build a remote desktop management system using the Neuroglia framework. This application showcases system integration patterns including SSH-based remote control, background service registration, cloud event publishing, and OAuth2 security for enterprise desktop management.</p>"},{"location":"samples/desktop_controller/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>Remote System Control: SSH-based command execution on host systems</li> <li>Background Service Patterns: Periodic self-registration and heartbeat services</li> <li>Cloud Event Publishing: Automated service discovery and registration events</li> <li>System Integration: Host system information gathering and state management</li> <li>OAuth2 Security: Enterprise authentication with secure SSH key management</li> <li>File System Integration: Remote file management and data persistence</li> <li>Docker Host Communication: Container-to-host communication patterns</li> </ul>"},{"location":"samples/desktop_controller/#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<pre><code>graph TB\n    subgraph \"Desktop Controller Service\"\n        A[HostController] --&gt; B[Mediator]\n        B --&gt; C[Command/Query Handlers]\n        C --&gt; D[Domain Models]\n        C --&gt; E[SSH Integration Services]\n\n        F[OAuth2 Middleware] --&gt; A\n        G[Background Registrator] --&gt; H[Cloud Event Bus]\n        I[SSH Client] --&gt; J[Docker Host]\n\n        C --&gt; K[File System Repository]\n        K --&gt; I\n    end\n\n    subgraph \"External Dependencies\"\n        L[Keycloak OAuth2]\n        M[Desktop Registry]\n        N[Docker Host/VM]\n        O[Remote File System]\n    end\n\n    F --&gt; L\n    H --&gt; M\n    I --&gt; N\n    K --&gt; O\n\n    style A fill:#e1f5fe\n    style G fill:#f3e5f5\n    style I fill:#fff3e0</code></pre> <p>This architecture enables secure remote control of desktop systems through containerized services that communicate with their host environments via SSH while maintaining enterprise security standards.</p>"},{"location":"samples/desktop_controller/#key-features-demonstrated","title":"\ud83d\ude80 Key Features Demonstrated","text":""},{"location":"samples/desktop_controller/#1-ssh-based-remote-control","title":"1. SSH-Based Remote Control","text":"<pre><code># Secure command execution on host systems\nclass SecuredHost:\n    async def run_command_async(self, command: HostCommand) -&gt; HostCommandResult:\n        stdin, stdout, stderr = await asyncio.to_thread(\n            self.ssh_client.exec_command, command.line\n        )\n\n        exit_status = stdout.channel.recv_exit_status()\n        return HostCommandResult(\n            command=command.line,\n            exit_status=exit_status,\n            stdout=stdout.read().decode(),\n            stderr=stderr.read().decode()\n        )\n</code></pre>"},{"location":"samples/desktop_controller/#2-background-service-registration","title":"2. Background Service Registration","text":"<pre><code># Periodic self-registration with cloud events\nclass DesktopRegistrator(HostedService):\n    async def start_async(self):\n        while not self.cancellation_token.is_cancelled:\n            await self._register_desktop()\n            await asyncio.sleep(self.registration_interval_seconds)\n\n    async def _register_desktop(self):\n        event = DesktopHostRegistrationRequestedIntegrationEventV1(\n            desktop_id=self.desktop_id,\n            host_ip_address=self.host_ip,\n            registration_timestamp=datetime.utcnow()\n        )\n        await self.cloud_event_publisher.publish_async(event)\n</code></pre>"},{"location":"samples/desktop_controller/#3-host-system-information-management","title":"3. Host System Information Management","text":"<pre><code># Domain model for host information\n@dataclass\nclass HostInfo(Entity[str]):\n    desktop_id: str\n    host_ip_address: str\n    host_state: HostState\n    last_seen: datetime\n    is_locked: bool\n    system_info: dict[str, Any]\n\n    def update_system_state(self, new_state: HostState):\n        self.host_state = new_state\n        self.last_seen = datetime.now(timezone.utc)\n</code></pre>"},{"location":"samples/desktop_controller/#4-commandquery-pattern-for-remote-operations","title":"4. Command/Query Pattern for Remote Operations","text":"<pre><code># Remote command execution\n@dataclass\nclass SetHostLockCommand(Command):\n    script_name: str = \"/usr/local/bin/lock.sh\"\n\nclass HostLockCommandsHandler(CommandHandler[SetHostLockCommand, OperationResult[Any]]):\n    async def handle_async(self, command: SetHostLockCommand) -&gt; OperationResult[Any]:\n        host_command = HostCommand(line=command.script_name)\n        result = await self.docker_host_command_runner.run_async(host_command)\n\n        if result.exit_status == 0:\n            return self.success(\"Host locked successfully\")\n        return self.bad_request(f\"Lock command failed: {result.stderr}\")\n</code></pre>"},{"location":"samples/desktop_controller/#5-oauth2-with-ssh-security","title":"5. OAuth2 with SSH Security","text":"<pre><code># Dual security: OAuth2 for API + SSH for host access\n@get(\"/info\", dependencies=[Depends(validate_token)])\nasync def get_host_info(self):\n    query = ReadHostInfoQuery()\n    result = await self.mediator.execute_async(query)\n    return self.process(result)\n</code></pre>"},{"location":"samples/desktop_controller/#configuration-settings","title":"\ud83d\udd27 Configuration &amp; Settings","text":""},{"location":"samples/desktop_controller/#application-settings","title":"Application Settings","text":"<pre><code>class DesktopControllerSettings(ApplicationSettings):\n    # OAuth2 Configuration\n    jwt_authority: str = \"http://keycloak47/realms/mozart\"\n    jwt_audience: str = \"desktops\"\n    required_scope: str = \"api\"\n\n    # SSH Configuration\n    docker_host_user_name: str = \"sys-admin\"\n    docker_host_host_name: str = \"host.docker.internal\"\n\n    # File System Configuration\n    remotefs_base_folder: str = \"/tmp\"\n    hostinfo_filename: str = \"hostinfo.json\"\n    userinfo_filename: str = \"userinfo.json\"\n\n    # Registration Configuration\n    desktop_registration_interval: int = 30  # seconds\n</code></pre>"},{"location":"samples/desktop_controller/#ssh-client-configuration","title":"SSH Client Configuration","text":"<pre><code>class SshClientSettings(BaseModel):\n    username: str\n    hostname: str\n    port: int = 22\n    private_key_filename: str = \"/app/id_rsa\"\n\n# SSH key setup required:\n# 1. Generate SSH key pair\n# 2. Mount private key to container at /app/id_rsa\n# 3. Add public key to host's ~/.ssh/authorized_keys\n</code></pre>"},{"location":"samples/desktop_controller/#testing-strategy","title":"\ud83e\uddea Testing Strategy","text":""},{"location":"samples/desktop_controller/#unit-tests","title":"Unit Tests","text":"<pre><code>class TestHostController:\n    def test_host_lock_command_success(self):\n        # Test successful host locking\n        command = SetHostLockCommand(script_name=\"/usr/local/bin/lock.sh\")\n\n        # Mock SSH client response\n        mock_result = HostCommandResult(\n            command=\"/usr/local/bin/lock.sh\",\n            exit_status=0,\n            stdout=\"Host locked\",\n            stderr=\"\"\n        )\n\n        result = await handler.handle_async(command)\n        assert result.is_success\n        assert \"locked successfully\" in result.data\n</code></pre>"},{"location":"samples/desktop_controller/#integration-tests","title":"Integration Tests","text":"<pre><code>class TestDesktopControllerIntegration:\n    @pytest.mark.integration\n    async def test_ssh_host_communication(self):\n        # Test actual SSH communication with test host\n        ssh_client = SecuredHost(test_ssh_settings)\n        command = HostCommand(line=\"echo 'test'\")\n\n        result = await ssh_client.run_command_async(command)\n\n        assert result.exit_status == 0\n        assert \"test\" in result.stdout\n</code></pre>"},{"location":"samples/desktop_controller/#implementation-details","title":"\ud83d\udcda Implementation Details","text":""},{"location":"samples/desktop_controller/#1-controller-layer-apicontrollers","title":"1. Controller Layer (<code>api/controllers/</code>)","text":"<ul> <li>HostController: Host system management and information endpoints</li> <li>UserController: User session and information management</li> <li>HostScriptController: Custom script execution on host systems</li> <li>OAuth2Scheme: Authentication and authorization middleware</li> </ul>"},{"location":"samples/desktop_controller/#2-application-layer-application","title":"2. Application Layer (<code>application/</code>)","text":"<ul> <li>Commands: System control operations (lock, unlock, script execution)</li> <li>Queries: System information retrieval (host info, user info, lock status)</li> <li>Services: Background registration, SSH command execution</li> <li>Events: Integration events for desktop registration</li> </ul>"},{"location":"samples/desktop_controller/#3-domain-layer-domain","title":"3. Domain Layer (<code>domain/</code>)","text":"<ul> <li>HostInfo: Desktop system information and state</li> <li>UserInfo: User session and authentication state</li> <li>HostIsLocked: Lock state management for security</li> <li>Domain Events: System state change notifications</li> </ul>"},{"location":"samples/desktop_controller/#4-integration-layer-integration","title":"4. Integration Layer (<code>integration/</code>)","text":"<ul> <li>SSH Services: Secure host communication via SSH</li> <li>File System Repository: Remote file management</li> <li>Cloud Event Models: External service communication</li> <li>Enums: System state and configuration enumerations</li> </ul>"},{"location":"samples/desktop_controller/#external-service-integration","title":"\ud83c\udf10 External Service Integration","text":""},{"location":"samples/desktop_controller/#ssh-host-communication","title":"SSH Host Communication","text":"<pre><code>class SecuredDockerHost:\n    \"\"\"SSH-based secure communication with Docker host system\"\"\"\n\n    async def execute_system_command(self, command: str) -&gt; CommandResult:\n        ssh_command = HostCommand(line=command)\n        return await self.secured_host.run_command_async(ssh_command)\n</code></pre>"},{"location":"samples/desktop_controller/#cloud-event-publishing","title":"Cloud Event Publishing","text":"<pre><code>class DesktopRegistrationEvent:\n    \"\"\"Periodic registration with external desktop registry\"\"\"\n\n    event_type = \"com.cisco.mozart.desktop.registered.v1\"\n\n    async def publish_registration(self):\n        cloud_event = CloudEvent(\n            type=self.event_type,\n            source=f\"desktop-controller/{self.desktop_id}\",\n            data=DesktopHostRegistrationRequestedIntegrationEventV1(\n                desktop_id=self.desktop_id,\n                host_ip_address=self.get_host_ip(),\n                capabilities=self.get_host_capabilities()\n            )\n        )\n        await self.cloud_event_bus.publish_async(cloud_event)\n</code></pre>"},{"location":"samples/desktop_controller/#remote-file-system-access","title":"Remote File System Access","text":"<pre><code>class RemoteFileSystemRepository:\n    \"\"\"File-based data persistence on host system\"\"\"\n\n    async def save_host_info(self, host_info: HostInfo):\n        json_data = self.json_serializer.serialize(host_info)\n        await self.write_file_async(\"hostinfo.json\", json_data)\n\n    async def write_file_async(self, filename: str, content: str):\n        # Use SSH to write files to host filesystem\n        command = f\"echo '{content}' &gt; {self.base_path}/{filename}\"\n        await self.ssh_client.run_command_async(HostCommand(line=command))\n</code></pre>"},{"location":"samples/desktop_controller/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"samples/desktop_controller/#prerequisites","title":"Prerequisites","text":"<pre><code># 1. Docker and Docker Desktop installed\n# 2. SSH key pair generated\nssh-keygen -t rsa -b 4096 -f ~/.ssh/desktop_controller_key\n\n# 3. Copy public key to target host\nssh-copy-id -i ~/.ssh/desktop_controller_key.pub user@target-host\n</code></pre>"},{"location":"samples/desktop_controller/#running-the-application","title":"Running the Application","text":"<pre><code># 1. Clone and setup\ngit clone &lt;repository&gt;\ncd samples/desktop-controller\n\n# 2. Configure environment\ncp .env.example .env\n# Edit .env with your settings\n\n# 3. Mount SSH private key and run\ndocker run -d\n  -p 8080:80\n  -v ~/.ssh/desktop_controller_key:/app/id_rsa:ro\n  -e DOCKER_HOST_USER_NAME=sys-admin\n  -e JWT_AUTHORITY=http://your-keycloak/realms/mozart\n  desktop-controller:latest\n\n# 4. Test the API\ncurl -H \"Authorization: Bearer &lt;token&gt;\"\n     http://localhost:8080/api/host/info\n</code></pre>"},{"location":"samples/desktop_controller/#development-setup","title":"Development Setup","text":"<pre><code># 1. Install dependencies\npoetry install\n\n# 2. Configure SSH access\nsudo cp ~/.ssh/desktop_controller_key ./id_rsa\nsudo chmod 600 ./id_rsa\n\n# 3. Start development server\npoetry run python main.py\n\n# 4. Access Swagger UI\nopen http://localhost:8080/docs\n</code></pre>"},{"location":"samples/desktop_controller/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>OAuth2 Security - Authentication patterns</li> <li>Background Services - Hosted service patterns</li> <li>Cloud Events - Event publishing and consumption</li> <li>System Integration - External system communication</li> <li>API Gateway Sample - Service gateway patterns</li> <li>OpenBank Sample - Event sourcing and CQRS patterns</li> </ul>"},{"location":"samples/desktop_controller/#comparison-with-other-samples","title":"\ud83d\udd0d Comparison with Other Samples","text":""},{"location":"samples/desktop_controller/#architecture-patterns","title":"Architecture Patterns","text":""},{"location":"samples/desktop_controller/#desktop-controller-system-integration-focused","title":"Desktop Controller - System Integration Focused","text":"<pre><code># SSH-based system control\nclass HostController(ControllerBase):\n    @post(\"/lock\")\n    async def lock_host(self):\n        command = SetHostLockCommand()\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n# Background service registration\nclass DesktopRegistrator(HostedService):\n    async def start_async(self):\n        while not self.stopping:\n            await self.register_desktop()\n            await asyncio.sleep(30)\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-service-orchestration","title":"API Gateway - Service Orchestration","text":"<pre><code># External API orchestration\nclass PromptController(ControllerBase):\n    @post(\"/prompts\")\n    async def create_prompt(self, dto: CreatePromptDto):\n        command = self.mapper.map(dto, CreatePromptCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-rich-domain-model","title":"OpenBank - Rich Domain Model","text":"<pre><code># Event-sourced business logic\nclass BankAccount(AggregateRoot[str]):\n    def try_add_transaction(self, transaction: BankTransaction) -&gt; bool:\n        if self.can_process_transaction(transaction):\n            self.state.on(self.register_event(TransactionRecorded(transaction)))\n            return True\n        return False\n</code></pre>"},{"location":"samples/desktop_controller/#domain-complexity","title":"Domain Complexity","text":""},{"location":"samples/desktop_controller/#desktop-controller-system-state-management","title":"Desktop Controller - System State Management","text":"<ul> <li>Focus: Host system control and monitoring</li> <li>Entities: HostInfo, UserInfo, SystemState</li> <li>Operations: Lock/unlock, script execution, information gathering</li> <li>State: Current system state with periodic updates</li> </ul>"},{"location":"samples/desktop_controller/#api-gateway-service-integration","title":"API Gateway - Service Integration","text":"<ul> <li>Focus: Request routing and external service coordination</li> <li>Entities: Prompt, PromptResponse, ServiceConfiguration</li> <li>Operations: Create, process, route requests</li> <li>State: Request/response transformation and routing</li> </ul>"},{"location":"samples/desktop_controller/#openbank-business-domain-model","title":"OpenBank - Business Domain Model","text":"<ul> <li>Focus: Financial business rules and transactions</li> <li>Entities: BankAccount, Person, Transaction</li> <li>Operations: Account creation, money transfer, balance inquiry</li> <li>State: Event-sourced business state with full history</li> </ul>"},{"location":"samples/desktop_controller/#data-persistence-strategy","title":"Data Persistence Strategy","text":""},{"location":"samples/desktop_controller/#desktop-controller-file-based-remote-storage","title":"Desktop Controller - File-Based + Remote Storage","text":"<pre><code># File-based persistence on remote host\nclass RemoteFileSystemRepository:\n    async def save_host_info(self, host_info: HostInfo):\n        json_content = self.serializer.serialize(host_info)\n        await self.write_remote_file(\"hostinfo.json\", json_content)\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-multi-store-architecture","title":"API Gateway - Multi-Store Architecture","text":"<pre><code># Multiple storage backends\nservices.add_scoped(MinioStorageManager)      # Object storage\nservices.add_scoped(RedisCache)               # Caching\nservices.add_scoped(MongoRepository)          # Document storage\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-event-sourcing","title":"OpenBank - Event Sourcing","text":"<pre><code># Event store with projections\nclass EventStoreRepository:\n    async def save_async(self, aggregate: AggregateRoot):\n        events = aggregate._pending_events\n        await self.event_store.append_events_async(aggregate.id, events)\n</code></pre>"},{"location":"samples/desktop_controller/#authentication-security","title":"Authentication &amp; Security","text":""},{"location":"samples/desktop_controller/#desktop-controller-oauth2-ssh-keys","title":"Desktop Controller - OAuth2 + SSH Keys","text":"<pre><code># Dual security model\n@get(\"/info\", dependencies=[Depends(validate_token)])\nasync def get_host_info(self):\n    # OAuth2 for API access + SSH for host communication\n    pass\n\n# SSH key management\nclass SshClientSettings:\n    private_key_filename: str = \"/app/id_rsa\"\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-oauth2-api-keys","title":"API Gateway - OAuth2 + API Keys","text":"<pre><code># Multiple authentication schemes\n@post(\"/item\", dependencies=[Depends(validate_oauth2_token)])\nasync def create_item_oauth(self, item_data: ItemDto):\n    pass\n\n@get(\"/health\", dependencies=[Depends(validate_api_key)])\nasync def health_check(self):\n    pass\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-domain-focused-security","title":"OpenBank - Domain-Focused Security","text":"<pre><code># Business rule-based security\nclass BankAccount:\n    def withdraw(self, amount: Decimal, user: Person):\n        if not self.is_owner(user):\n            raise UnauthorizedOperationException()\n        if not self.has_sufficient_funds(amount):\n            raise InsufficientFundsException()\n</code></pre>"},{"location":"samples/desktop_controller/#external-service-integration_1","title":"External Service Integration","text":""},{"location":"samples/desktop_controller/#desktop-controller-system-integration","title":"Desktop Controller - System Integration","text":"<pre><code># Direct system integration via SSH\nclass DockerHostCommandRunner:\n    async def run_async(self, command: HostCommand) -&gt; HostCommandResult:\n        return await self.ssh_client.execute_command(command)\n\n# Cloud event publishing for registration\nclass DesktopRegistrator:\n    async def register_desktop(self):\n        event = DesktopRegistrationEvent(self.host_info)\n        await self.cloud_event_bus.publish_async(event)\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-extensive-integration","title":"API Gateway - Extensive Integration","text":"<pre><code># Multiple external service clients\nservices.add_scoped(MosaicApiClient)\nservices.add_scoped(MinioStorageManager)\nservices.add_scoped(RedisCache)\nservices.add_scoped(GenAiApiClient)\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-minimal-integration","title":"OpenBank - Minimal Integration","text":"<pre><code># Domain-focused with minimal external dependencies\nservices.add_singleton(EventStoreClient)\nservices.add_scoped(MongoRepository)  # For read models\n</code></pre>"},{"location":"samples/desktop_controller/#background-processing","title":"Background Processing","text":""},{"location":"samples/desktop_controller/#desktop-controller-periodic-registration","title":"Desktop Controller - Periodic Registration","text":"<pre><code># Background service for system registration\nclass DesktopRegistrator(HostedService):\n    async def start_async(self):\n        self.registration_task = asyncio.create_task(self.registration_loop())\n\n    async def registration_loop(self):\n        while not self.stopping:\n            await self.register_with_registry()\n            await asyncio.sleep(self.interval)\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-task-queue-pattern","title":"API Gateway - Task Queue Pattern","text":"<pre><code># Redis-backed background task processing\n@dataclass\nclass ProcessPromptTask(BackgroundTask):\n    prompt_id: str\n    user_id: str\n\nclass PromptProcessingService:\n    async def queue_processing_task(self, prompt: Prompt):\n        task = ProcessPromptTask(prompt.id, prompt.user_id)\n        await self.task_scheduler.schedule_async(task)\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-event-driven-projections","title":"OpenBank - Event-Driven Projections","text":"<pre><code># Domain event-driven read model updates\nclass BankAccountProjectionHandler:\n    @dispatch(BankAccountCreatedDomainEventV1)\n    async def handle_async(self, event: BankAccountCreatedDomainEventV1):\n        projection = BankAccountProjection.from_event(event)\n        await self.projection_repository.save_async(projection)\n</code></pre>"},{"location":"samples/desktop_controller/#testing-strategies","title":"Testing Strategies","text":""},{"location":"samples/desktop_controller/#desktop-controller-system-integration-testing","title":"Desktop Controller - System Integration Testing","text":"<pre><code># SSH integration tests\n@pytest.mark.integration\nclass TestSSHIntegration:\n    async def test_host_command_execution(self):\n        ssh_client = SecuredHost(test_settings)\n        result = await ssh_client.run_command_async(HostCommand(\"echo test\"))\n        assert result.exit_status == 0\n        assert \"test\" in result.stdout\n\n# Background service testing\nclass TestDesktopRegistrator:\n    async def test_periodic_registration(self):\n        registrator = DesktopRegistrator(mock_cloud_event_bus)\n        await registrator.start_async()\n        # Verify registration events are published\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-integration-heavy-testing","title":"API Gateway - Integration-Heavy Testing","text":"<pre><code># External service integration tests\n@pytest.mark.integration\nclass TestExternalServices:\n    async def test_mosaic_api_integration(self):\n        client = MosaicApiClient(test_settings)\n        response = await client.get_data_async(\"test-id\")\n        assert response.status_code == 200\n\n# Background task testing\nclass TestTaskProcessing:\n    async def test_prompt_processing_workflow(self):\n        task = ProcessPromptTask(\"prompt-123\", \"user-456\")\n        result = await self.task_processor.process_async(task)\n        assert result.is_success\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-domain-focused-testing","title":"OpenBank - Domain-Focused Testing","text":"<pre><code># Rich domain behavior testing\nclass TestBankAccount:\n    def test_account_creation_raises_creation_event(self):\n        account = BankAccount()\n        account.create_account(\"owner-123\", Decimal(\"1000.00\"))\n\n        events = account._pending_events\n        assert len(events) == 1\n        assert isinstance(events[0], BankAccountCreatedDomainEventV1)\n\n# Event sourcing testing\nclass TestEventStore:\n    async def test_aggregate_reconstruction_from_events(self):\n        events = [creation_event, transaction_event]\n        account = await self.repository.load_from_events(events)\n        assert account.balance == expected_balance\n</code></pre>"},{"location":"samples/desktop_controller/#use-case-recommendations","title":"Use Case Recommendations","text":""},{"location":"samples/desktop_controller/#choose-desktop-controller-pattern-when","title":"Choose Desktop Controller Pattern when","text":"<ul> <li>\u2705 Building system administration and control applications</li> <li>\u2705 Managing remote desktop or VM environments</li> <li>\u2705 Implementing SSH-based automation and control</li> <li>\u2705 Creating enterprise desktop management solutions</li> <li>\u2705 Needing periodic service registration and discovery</li> <li>\u2705 Integrating containerized apps with host systems</li> <li>\u2705 Building secure remote command execution systems</li> </ul>"},{"location":"samples/desktop_controller/#choose-api-gateway-pattern-when","title":"Choose API Gateway Pattern when","text":"<ul> <li>\u2705 Building microservice entry points and orchestration</li> <li>\u2705 Implementing complex external service integration</li> <li>\u2705 Creating service mesh control planes</li> <li>\u2705 Needing advanced authentication and authorization</li> <li>\u2705 Building background task processing systems</li> <li>\u2705 Implementing file storage and caching solutions</li> </ul>"},{"location":"samples/desktop_controller/#choose-event-sourcing-pattern-when","title":"Choose Event Sourcing Pattern when","text":"<ul> <li>\u2705 Rich domain models with behavior</li> <li>\u2705 Complete audit trails and temporal queries</li> <li>\u2705 Event-driven architecture with projections</li> <li>\u2705 Financial or business-critical applications</li> <li>\u2705 CQRS with separate read/write models</li> </ul>"},{"location":"samples/desktop_controller/#framework-features-utilized","title":"Framework Features Utilized","text":"<p>The Desktop Controller sample demonstrates unique aspects of the Neuroglia framework:</p> <ul> <li>Background Services: <code>HostedService</code> for long-running registration tasks</li> <li>SSH Integration: Custom integration services for secure system communication</li> <li>Cloud Event Publishing: External service registration and discovery</li> <li>File-Based Repositories: Remote filesystem data persistence</li> <li>OAuth2 Security: Enterprise authentication with secure key management</li> <li>System Integration Patterns: Container-to-host communication strategies</li> </ul> <p>Both samples showcase different strengths of the Neuroglia framework, demonstrating its flexibility in supporting various architectural patterns while maintaining clean architecture principles.</p>"},{"location":"samples/desktop_controller/#overview","title":"Overview","text":""},{"location":"samples/desktop_controller/#controllers-interactions","title":"Controller's Interactions","text":"<p>TODO</p>"},{"location":"samples/desktop_controller/#controllers-context","title":"Controller's Context","text":"<p>TODO</p>"},{"location":"samples/desktop_controller/#design","title":"Design","text":"<p>TODO</p>"},{"location":"samples/desktop_controller/#development","title":"Development","text":""},{"location":"samples/desktop_controller/#setup","title":"Setup","text":"<pre><code># 0. Prerequisites:\n#    Have Python 3.12 installed\n#\n#    - Create/Activate a local python environment (e.g. with pyenv)\n#      pyenv virtualenv 3.12.2 desktop-controller\n#      pyenv activate desktop-controller\n#\n#    - Start Docker Desktop locally\n#\n# 1. Clone the repository\ncd ~/\n\ngit clone git@....\n\ncd desktop-controller\n\n# pip install pre-commit\npre-commit install\n\n# pip install poetry\npoetry lock &amp;&amp; poetry install\n\n# 2. Start the docker-compose stack\n# sudo apt-get install make\nmake up\n\n# Access Swagger UI\nopen http://localhost:8080/docs\n</code></pre>"},{"location":"samples/desktop_controller/#key-implementation-highlights","title":"\ud83d\udca1 Key Implementation Highlights","text":"<p>The Desktop Controller sample uniquely demonstrates:</p>"},{"location":"samples/desktop_controller/#1-dual-security-architecture","title":"1. Dual Security Architecture","text":"<ul> <li>API Security: OAuth2/JWT for REST API access</li> <li>System Security: SSH key-based authentication for host communication</li> <li>Separation of Concerns: Different security models for different access layers</li> </ul>"},{"location":"samples/desktop_controller/#2-container-to-host-communication","title":"2. Container-to-Host Communication","text":"<ul> <li>SSH Bridge: Secure communication between containerized service and host system</li> <li>Command Execution: Remote shell command execution with result capture</li> <li>File System Access: Remote file management on host filesystem</li> </ul>"},{"location":"samples/desktop_controller/#3-background-service-registration","title":"3. Background Service Registration","text":"<ul> <li>Self-Discovery: Periodic registration with external service registry</li> <li>Cloud Events: Standards-based event publishing for service discovery</li> <li>Heartbeat Pattern: Continuous availability signaling</li> </ul>"},{"location":"samples/desktop_controller/#4-system-integration-patterns","title":"4. System Integration Patterns","text":"<ul> <li>Host Information Gathering: Real-time system state collection</li> <li>Remote Control Operations: Secure desktop management capabilities</li> <li>State Persistence: File-based data storage for inter-application communication</li> </ul> <p>This sample showcases how the Neuroglia framework can effectively bridge containerized microservices with host system management, providing enterprise-grade security and reliability for remote desktop control scenarios.</p> <p>Both the Desktop Controller and other samples demonstrate the framework's versatility in handling diverse architectural patterns - from event-sourced business applications to system integration and service orchestration solutions.</p>"},{"location":"samples/lab-resource-manager/","title":"\ud83e\uddea Lab Resource Manager Sample Application","text":"<p>The Lab Resource Manager demonstrates Resource Oriented Architecture (ROA) patterns using Neuroglia's advanced features. It simulates a system for managing ephemeral lab environments for students, showcasing watchers, controllers, and reconciliation loops.</p>"},{"location":"samples/lab-resource-manager/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>Resource Oriented Architecture: Declarative resource management patterns</li> <li>Watcher Pattern: Continuous monitoring of resource changes</li> <li>Controller Pattern: Event-driven business logic responses</li> <li>Reconciliation Loops: Periodic consistency checks and drift correction</li> <li>State Machine Implementation: Resource lifecycle management</li> <li>Asynchronous Coordination: Multiple concurrent components working together</li> </ul>"},{"location":"samples/lab-resource-manager/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Lab Resource Manager                            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502   Watcher       \u2502    \u2502   Controller    \u2502    \u2502  Reconciler     \u2502 \u2502\n\u2502  \u2502   (2s polling)  \u2502\u2500\u2500\u2500\u25b6\u2502   (immediate)   \u2502    \u2502   (10s loop)    \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502           \u2502                       \u2502                       \u2502        \u2502\n\u2502           \u25bc                       \u25bc                       \u25bc        \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502                    Resource Storage                           \u2502 \u2502\n\u2502  \u2502            (Kubernetes-like API with versioning)              \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"samples/lab-resource-manager/#domain-model","title":"\ud83c\udfaf Domain Model","text":""},{"location":"samples/lab-resource-manager/#labinstance-resource","title":"LabInstance Resource","text":"<p>The core resource representing a student lab environment:</p> <pre><code>@dataclass\nclass LabInstanceResource:\n    api_version: str = \"lab.neuroglia.com/v1\"\n    kind: str = \"LabInstance\"\n    metadata: Dict[str, Any] = None  # Name, namespace, timestamps, versions\n    spec: Dict[str, Any] = None      # Desired state: template, duration, student\n    status: Dict[str, Any] = None    # Current state: phase, endpoint, conditions\n</code></pre>"},{"location":"samples/lab-resource-manager/#resource-states","title":"Resource States","text":"<p>Lab instances progress through a defined lifecycle:</p> <pre><code>PENDING \u2500\u2500\u2192 PROVISIONING \u2500\u2500\u2192 READY \u2500\u2500\u2192 DELETING \u2500\u2500\u2192 DELETED\n   \u2502              \u2502             \u2502\n   \u25bc              \u25bc             \u25bc\nFAILED        FAILED         FAILED\n</code></pre>"},{"location":"samples/lab-resource-manager/#sample-resource","title":"Sample Resource","text":"<pre><code>{\n  \"apiVersion\": \"lab.neuroglia.com/v1\",\n  \"kind\": \"LabInstance\",\n  \"metadata\": {\n    \"name\": \"python-basics-lab\",\n    \"namespace\": \"student-labs\",\n    \"resourceVersion\": \"1\",\n    \"creationTimestamp\": \"2025-09-09T21:34:19Z\"\n  },\n  \"spec\": {\n    \"template\": \"python-basics\",\n    \"studentEmail\": \"student@example.com\",\n    \"duration\": \"60m\",\n    \"environment\": {\n      \"PYTHON_VERSION\": \"3.11\"\n    }\n  },\n  \"status\": {\n    \"state\": \"ready\",\n    \"message\": \"Lab instance is ready\",\n    \"endpoint\": \"https://lab-python-basics.example.com\",\n    \"readyAt\": \"2025-09-09T21:34:25Z\"\n  }\n}\n</code></pre>"},{"location":"samples/lab-resource-manager/#component-implementation","title":"\ud83d\udd27 Component Implementation","text":""},{"location":"samples/lab-resource-manager/#1-watcher-labinstancewatcher","title":"1. Watcher: LabInstanceWatcher","text":"<p>Continuously monitors for resource changes:</p> <pre><code>class LabInstanceWatcher:\n    async def start_watching(self):\n        while self.is_running:\n            # Poll for changes since last known version\n            changes = self.storage.list_resources(since_version=self.last_resource_version)\n\n            for resource in changes:\n                resource_version = int(resource.metadata.get('resourceVersion', '0'))\n                if resource_version &gt; self.last_resource_version:\n                    await self._handle_resource_change(resource)\n                    self.last_resource_version = max(self.last_resource_version, resource_version)\n\n            await asyncio.sleep(self.poll_interval)\n</code></pre> <p>Key Features:</p> <ul> <li>Polls every 2 seconds for near-real-time responsiveness</li> <li>Uses resource versioning to detect changes efficiently</li> <li>Notifies multiple event handlers when changes occur</li> <li>Handles errors gracefully with continued monitoring</li> </ul>"},{"location":"samples/lab-resource-manager/#2-controller-labinstancecontroller","title":"2. Controller: LabInstanceController","text":"<p>Implements business logic for state transitions:</p> <pre><code>class LabInstanceController:\n    async def handle_resource_event(self, resource: LabInstanceResource):\n        current_state = resource.status.get('state')\n\n        if current_state == ResourceState.PENDING.value:\n            await self._start_provisioning(resource)\n        elif current_state == ResourceState.PROVISIONING.value:\n            await self._check_provisioning_status(resource)\n        elif current_state == ResourceState.READY.value:\n            await self._monitor_lab_instance(resource)\n</code></pre> <p>Key Features:</p> <ul> <li>Event-driven processing responding immediately to changes</li> <li>State machine implementation with clear transitions</li> <li>Business rule enforcement (timeouts, validation, etc.)</li> <li>Integration with external provisioning systems</li> </ul>"},{"location":"samples/lab-resource-manager/#3-reconciler-labinstancescheduler","title":"3. Reconciler: LabInstanceScheduler","text":"<p>Provides safety and eventual consistency:</p> <pre><code>class LabInstanceScheduler:\n    async def start_reconciliation(self):\n        while self.is_running:\n            await self._reconcile_all_resources()\n            await asyncio.sleep(self.reconcile_interval)\n\n    async def _reconcile_resource(self, resource):\n        # Check for stuck states\n        if self._is_stuck_provisioning(resource):\n            await self._mark_as_failed(resource, \"Provisioning timeout\")\n\n        # Check for expiration\n        if self._is_expired(resource):\n            await self._schedule_deletion(resource)\n</code></pre> <p>Key Features:</p> <ul> <li>Runs every 10 seconds scanning all resources</li> <li>Detects stuck states and takes corrective action</li> <li>Enforces business policies (lab expiration, cleanup)</li> <li>Provides safety net for controller failures</li> </ul>"},{"location":"samples/lab-resource-manager/#execution-flow","title":"\u26a1 Execution Flow","text":""},{"location":"samples/lab-resource-manager/#1-resource-creation","title":"1. Resource Creation","text":"<pre><code>1. API creates LabInstance resource (state: PENDING)\n2. Storage backend assigns resource version and timestamps\n3. Watcher detects new resource on next poll cycle (\u22642s)\n4. Controller receives sevent and starts provisioning\n5. Resource state transitions to PROVISIONING\n</code></pre>"},{"location":"samples/lab-resource-manager/#2-state-progression","title":"2. State Progression","text":"<pre><code>6. Watcher detects state change to PROVISIONING\n7. Controller checks provisioning status periodically\n8. When provisioning completes, state transitions to READY\n9. Watcher detects READY state\n10. Controller begins monitoring ready lab instance\n</code></pre>"},{"location":"samples/lab-resource-manager/#3-reconciliation-safety","title":"3. Reconciliation Safety","text":"<pre><code>11. Reconciler runs every 10 seconds checking all resources\n12. Detects if any resource is stuck in PROVISIONING too long\n13. Marks stuck resources as FAILED with timeout message\n14. Detects expired READY resources and schedules deletion\n</code></pre>"},{"location":"samples/lab-resource-manager/#running-the-sample","title":"\ud83d\ude80 Running the Sample","text":""},{"location":"samples/lab-resource-manager/#prerequisites","title":"Prerequisites","text":"<pre><code>cd samples/lab-resource-manager\n</code></pre>"},{"location":"samples/lab-resource-manager/#option-1-full-interactive-demo","title":"Option 1: Full Interactive Demo","text":"<pre><code>python run_watcher_demo.py\n</code></pre> <p>This runs the complete demonstration showing:</p> <ul> <li>Resource creation and state transitions</li> <li>Watcher detecting changes in real-time</li> <li>Controller responding with business logic</li> <li>Reconciler providing safety and cleanup</li> </ul>"},{"location":"samples/lab-resource-manager/#option-2-simple-patterns-demo","title":"Option 2: Simple Patterns Demo","text":"<pre><code>python simple_demo.py\n</code></pre> <p>A simplified version focusing on the core patterns without framework dependencies.</p>"},{"location":"samples/lab-resource-manager/#expected-output","title":"Expected Output","text":"<pre><code>\ud83c\udfaf Resource Oriented Architecture: Watcher &amp; Reconciliation Demo\n============================================================\n\ud83d\udc40 LabInstance Watcher started\n\ud83d\udd04 LabInstance Scheduler started reconciliation\n\ud83d\udce6 Created resource: student-labs/python-basics-lab\n\ud83d\udd0d Watcher detected change: student-labs/python-basics-lab -&gt; pending\n\ud83c\udfae Controller processing: student-labs/python-basics-lab (state: pending)\n\ud83d\ude80 Starting provisioning for: student-labs/python-basics-lab\n\ud83d\udd04 Updated resource: student-labs/python-basics-lab -&gt; {'status': {'state': 'provisioning'}}\n\ud83d\udd0d Watcher detected change: student-labs/python-basics-lab -&gt; provisioning\n\ud83c\udfae Controller processing: student-labs/python-basics-lab (state: provisioning)\n\ud83d\udd04 Reconciling 2 lab instances\n\u26a0\ufe0f Reconciler: Lab instance stuck in provisioning: student-labs/python-basics-lab\n</code></pre>"},{"location":"samples/lab-resource-manager/#key-implementation-details","title":"\ud83d\udca1 Key Implementation Details","text":""},{"location":"samples/lab-resource-manager/#resource-versioning","title":"Resource Versioning","text":"<p>Each resource change increments the version:</p> <pre><code>def update_resource(self, resource_id: str, updates: Dict[str, Any]):\n    resource = self.resources[resource_id]\n    self.resource_version += 1\n    resource.metadata['resourceVersion'] = str(self.resource_version)\n</code></pre>"},{"location":"samples/lab-resource-manager/#event-handling","title":"Event Handling","text":"<p>Watchers notify multiple handlers:</p> <pre><code>watcher.add_event_handler(controller.handle_resource_event)\nwatcher.add_event_handler(audit_logger.log_change)\nwatcher.add_event_handler(metrics_collector.record_event)\n</code></pre>"},{"location":"samples/lab-resource-manager/#error-resilience","title":"Error Resilience","text":"<p>All components handle errors gracefully:</p> <pre><code>try:\n    await self._provision_lab_instance(resource)\nexcept Exception as e:\n    logger.error(f\"Provisioning failed: {e}\")\n    await self._mark_as_failed(resource, str(e))\n</code></pre>"},{"location":"samples/lab-resource-manager/#concurrent-processing","title":"Concurrent Processing","text":"<p>Components run independently:</p> <pre><code>async def main():\n    watcher_task = asyncio.create_task(watcher.start_watching())\n    scheduler_task = asyncio.create_task(scheduler.start_reconciliation())\n\n    # Both run concurrently until stopped\n    await asyncio.gather(watcher_task, scheduler_task)\n</code></pre>"},{"location":"samples/lab-resource-manager/#design-patterns-demonstrated","title":"\ud83c\udfaf Design Patterns Demonstrated","text":""},{"location":"samples/lab-resource-manager/#1-observer-pattern","title":"1. Observer Pattern","text":"<p>Watchers observe storage and notify controllers of changes.</p>"},{"location":"samples/lab-resource-manager/#2-state-machine","title":"2. State Machine","text":"<p>Resources progress through well-defined states with clear transitions.</p>"},{"location":"samples/lab-resource-manager/#3-command-pattern","title":"3. Command Pattern","text":"<p>Controllers execute commands based on resource state.</p>"},{"location":"samples/lab-resource-manager/#4-strategy-pattern","title":"4. Strategy Pattern","text":"<p>Different provisioning strategies for different lab templates.</p>"},{"location":"samples/lab-resource-manager/#5-circuit-breaker","title":"5. Circuit Breaker","text":"<p>Reconcilers detect failures and prevent cascade issues.</p>"},{"location":"samples/lab-resource-manager/#configuration-options","title":"\ud83d\udd27 Configuration Options","text":""},{"location":"samples/lab-resource-manager/#timing-configuration","title":"Timing Configuration","text":"<pre><code># Development: Fast feedback\nwatcher = LabInstanceWatcher(storage, poll_interval=1.0)\nscheduler = LabInstanceScheduler(storage, reconcile_interval=5.0)\n\n# Production: Optimized performance\nwatcher = LabInstanceWatcher(storage, poll_interval=5.0)\nscheduler = LabInstanceScheduler(storage, reconcile_interval=30.0)\n</code></pre>"},{"location":"samples/lab-resource-manager/#timeout-configuration","title":"Timeout Configuration","text":"<pre><code>class LabInstanceController:\n    PROVISIONING_TIMEOUT = 300  # 5 minutes\n    MAX_RETRIES = 3\n    RETRY_BACKOFF = 30  # seconds\n</code></pre>"},{"location":"samples/lab-resource-manager/#resource-policies","title":"Resource Policies","text":"<pre><code>class LabInstanceScheduler:\n    DEFAULT_LAB_DURATION = 3600  # 1 hour\n    CLEANUP_GRACE_PERIOD = 300   # 5 minutes\n    MAX_CONCURRENT_PROVISIONS = 10\n</code></pre>"},{"location":"samples/lab-resource-manager/#testing-the-sample","title":"\ud83e\uddea Testing the Sample","text":"<p>The sample includes comprehensive tests:</p> <pre><code># Run all sample tests\npytest samples/lab-resource-manager/tests/\n\n# Test individual components\npytest samples/lab-resource-manager/tests/test_watcher.py\npytest samples/lab-resource-manager/tests/test_controller.py\npytest samples/lab-resource-manager/tests/test_reconciler.py\n</code></pre>"},{"location":"samples/lab-resource-manager/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\ud83c\udfaf Resource Oriented Architecture - Core ROA concepts</li> <li>\ud83c\udfd7\ufe0f Watcher &amp; Reconciliation Patterns - Detailed patterns</li> <li>\u26a1 Execution Flow - Component coordination</li> <li>\ud83c\udfaf CQRS &amp; Mediation - Command/Query handling</li> <li>\ud83d\uddc4\ufe0f Data Access - Storage patterns</li> <li>\ud83d\udccb Source Code Naming Conventions - Consistent naming patterns used in this sample</li> </ul>"},{"location":"samples/lab-resource-manager/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<p>After exploring this sample:</p> <ol> <li>Extend the Domain: Add more resource types (LabTemplate, StudentSession)</li> <li>Add Persistence: Integrate with MongoDB or Event Store</li> <li>Implement Authentication: Add student authentication and authorization</li> <li>Add Monitoring: Integrate metrics collection and alerting</li> <li>Scale Horizontally: Implement resource sharding for multiple instances</li> </ol>"},{"location":"samples/openbank/","title":"\ud83c\udfe6 OpenBank Sample Application","text":"<p>OpenBank is a comprehensive sample application that demonstrates advanced Neuroglia features including event sourcing, CQRS, domain-driven design, and event-driven architecture. It simulates a simple banking system with persons and accounts.</p>"},{"location":"samples/openbank/#overview","title":"\ud83c\udfaf Overview","text":"<p>The OpenBank sample showcases:</p> <ul> <li>Event Sourcing: Complete event-sourced domain with event store</li> <li>CQRS: Separate command and query models</li> <li>Domain-Driven Design: Rich domain models with business rules</li> <li>Event-Driven Architecture: Domain events and integration events</li> <li>Clean Architecture: Clear separation of layers</li> <li>Repository Pattern: Both write (event sourcing) and read (MongoDB) repositories</li> </ul>"},{"location":"samples/openbank/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    API Layer                                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502  PersonsController \u2502  \u2502 AccountsController \u2502  \u2502  Other APIs  \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Application Layer                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502    Commands     \u2502  \u2502     Queries     \u2502  \u2502     Events     \u2502   \u2502\n\u2502  \u2502   Handlers      \u2502  \u2502    Handlers     \u2502  \u2502   Handlers     \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Domain Layer                                 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502     Person      \u2502  \u2502     Account     \u2502  \u2502    Address     \u2502   \u2502\n\u2502  \u2502   Aggregate     \u2502  \u2502   Aggregate     \u2502  \u2502 Value Object   \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Integration Layer                              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502 Event Store     \u2502  \u2502   MongoDB       \u2502  \u2502  API Clients   \u2502   \u2502\n\u2502  \u2502 Repository      \u2502  \u2502  Repository     \u2502  \u2502                \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"samples/openbank/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"samples/openbank/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+</li> <li>Docker and Docker Compose</li> <li>MongoDB (via Docker)</li> <li>EventStoreDB (via Docker)</li> </ul>"},{"location":"samples/openbank/#setup","title":"Setup","text":"<ol> <li>Start Dependencies:</li> </ol> <pre><code>cd samples/openbank\ndocker-compose up -d mongodb eventstoredb\n</code></pre> <ol> <li>Install Dependencies:</li> </ol> <pre><code>pip install -r requirements.txt\n</code></pre> <ol> <li>Run the Application:</li> </ol> <pre><code>python api/main.py\n</code></pre> <ol> <li> <p>Access the API:</p> </li> <li> <p>API Documentation: http://localhost:8000/api/docs</p> </li> <li>EventStoreDB UI: http://localhost:2113 (admin/changeit)</li> </ol>"},{"location":"samples/openbank/#project-structure","title":"\ud83d\udcc1 Project Structure","text":"<pre><code>samples/openbank/\n\u251c\u2500\u2500 api/\n\u2502   \u251c\u2500\u2500 main.py                     # Application entry point\n\u2502   \u2514\u2500\u2500 controllers/\n\u2502       \u251c\u2500\u2500 persons_controller.py   # Person management API\n\u2502       \u2514\u2500\u2500 accounts_controller.py  # Account management API\n\u251c\u2500\u2500 application/\n\u2502   \u251c\u2500\u2500 commands/\n\u2502   \u2502   \u251c\u2500\u2500 persons/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 register_person_command.py\n\u2502   \u2502   \u2514\u2500\u2500 accounts/\n\u2502   \u2502       \u251c\u2500\u2500 open_account_command.py\n\u2502   \u2502       \u2514\u2500\u2500 deposit_command.py\n\u2502   \u251c\u2500\u2500 queries/\n\u2502   \u2502   \u251c\u2500\u2500 person_by_id.py\n\u2502   \u2502   \u2514\u2500\u2500 account_by_owner.py\n\u2502   \u2514\u2500\u2500 events/\n\u2502       \u251c\u2500\u2500 integration/\n\u2502       \u2502   \u2514\u2500\u2500 person_registered_handler.py\n\u2502       \u2514\u2500\u2500 domain/\n\u251c\u2500\u2500 domain/\n\u2502   \u2514\u2500\u2500 models/\n\u2502       \u251c\u2500\u2500 person.py               # Person aggregate\n\u2502       \u251c\u2500\u2500 account.py              # Account aggregate\n\u2502       \u2514\u2500\u2500 address.py              # Address value object\n\u2514\u2500\u2500 integration/\n    \u251c\u2500\u2500 models/                     # DTOs and read models\n    \u2502   \u251c\u2500\u2500 person.py\n    \u2502   \u2514\u2500\u2500 account.py\n    \u2514\u2500\u2500 commands/                   # API command DTOs\n        \u2514\u2500\u2500 persons/\n            \u2514\u2500\u2500 register_person_command_dto.py\n</code></pre>"},{"location":"samples/openbank/#domain-models","title":"\ud83c\udfdb\ufe0f Domain Models","text":""},{"location":"samples/openbank/#person-aggregate","title":"Person Aggregate","text":"<p>The Person aggregate manages person registration and personal information:</p> <pre><code>from dataclasses import dataclass\nfrom datetime import date\nfrom neuroglia.data.abstractions import AggregateRoot\nfrom samples.openbank.integration import PersonGender\n\n@dataclass\nclass PersonState:\n    \"\"\"Person aggregate state\"\"\"\n    id: str = None\n    first_name: str = None\n    last_name: str = None\n    nationality: str = None\n    gender: PersonGender = None\n    date_of_birth: date = None\n    address: Address = None\n\nclass Person(AggregateRoot[str]):\n    \"\"\"Person aggregate root\"\"\"\n\n    def __init__(self, id: str = None):\n        super().__init__(id)\n        self.state = PersonState()\n\n    def register(self, first_name: str, last_name: str, nationality: str,\n                gender: PersonGender, date_of_birth: date, address: Address):\n        \"\"\"Register a new person\"\"\"\n\n        # Validate business rules\n        if not first_name or not last_name:\n            raise ValueError(\"First name and last name are required\")\n\n        if date_of_birth &gt;= date.today():\n            raise ValueError(\"Date of birth must be in the past\")\n\n        # Raise domain event\n        self.apply(PersonRegisteredEvent(\n            person_id=self.id,\n            first_name=first_name,\n            last_name=last_name,\n            nationality=nationality,\n            gender=gender,\n            date_of_birth=date_of_birth,\n            address=address\n        ))\n\n    def update_address(self, new_address: Address):\n        \"\"\"Update person's address\"\"\"\n        self.apply(PersonAddressUpdatedEvent(\n            person_id=self.id,\n            old_address=self.state.address,\n            new_address=new_address\n        ))\n\n    # Event handlers\n    def on_person_registered(self, event: PersonRegisteredEvent):\n        \"\"\"Handle person registered event\"\"\"\n        self.state.id = event.person_id\n        self.state.first_name = event.first_name\n        self.state.last_name = event.last_name\n        self.state.nationality = event.nationality\n        self.state.gender = event.gender\n        self.state.date_of_birth = event.date_of_birth\n        self.state.address = event.address\n\n    def on_person_address_updated(self, event: PersonAddressUpdatedEvent):\n        \"\"\"Handle address updated event\"\"\"\n        self.state.address = event.new_address\n</code></pre>"},{"location":"samples/openbank/#account-aggregate","title":"Account Aggregate","text":"<p>The Account aggregate manages banking accounts and transactions:</p> <pre><code>from decimal import Decimal\nfrom neuroglia.data.abstractions import AggregateRoot\n\n@dataclass\nclass AccountState:\n    \"\"\"Account aggregate state\"\"\"\n    id: str = None\n    owner_id: str = None\n    account_number: str = None\n    balance: Decimal = Decimal('0.00')\n    currency: str = 'USD'\n    is_active: bool = True\n\nclass Account(AggregateRoot[str]):\n    \"\"\"Account aggregate root\"\"\"\n\n    def __init__(self, id: str = None):\n        super().__init__(id)\n        self.state = AccountState()\n\n    def open(self, owner_id: str, account_number: str, initial_deposit: Decimal = None):\n        \"\"\"Open a new account\"\"\"\n\n        # Validate business rules\n        if not owner_id:\n            raise ValueError(\"Owner ID is required\")\n\n        if not account_number:\n            raise ValueError(\"Account number is required\")\n\n        if initial_deposit and initial_deposit &lt; Decimal('0'):\n            raise ValueError(\"Initial deposit cannot be negative\")\n\n        # Raise domain event\n        self.apply(AccountOpenedEvent(\n            account_id=self.id,\n            owner_id=owner_id,\n            account_number=account_number,\n            initial_deposit=initial_deposit or Decimal('0.00')\n        ))\n\n    def deposit(self, amount: Decimal, description: str = None):\n        \"\"\"Deposit money to the account\"\"\"\n\n        # Validate business rules\n        if amount &lt;= Decimal('0'):\n            raise ValueError(\"Deposit amount must be positive\")\n\n        if not self.state.is_active:\n            raise ValueError(\"Cannot deposit to inactive account\")\n\n        # Raise domain event\n        self.apply(MoneyDepositedEvent(\n            account_id=self.id,\n            amount=amount,\n            description=description,\n            balance_after=self.state.balance + amount\n        ))\n\n    def withdraw(self, amount: Decimal, description: str = None):\n        \"\"\"Withdraw money from the account\"\"\"\n\n        # Validate business rules\n        if amount &lt;= Decimal('0'):\n            raise ValueError(\"Withdrawal amount must be positive\")\n\n        if not self.state.is_active:\n            raise ValueError(\"Cannot withdraw from inactive account\")\n\n        if self.state.balance &lt; amount:\n            raise ValueError(\"Insufficient funds\")\n\n        # Raise domain event\n        self.apply(MoneyWithdrawnEvent(\n            account_id=self.id,\n            amount=amount,\n            description=description,\n            balance_after=self.state.balance - amount\n        ))\n\n    # Event handlers\n    def on_account_opened(self, event: AccountOpenedEvent):\n        \"\"\"Handle account opened event\"\"\"\n        self.state.id = event.account_id\n        self.state.owner_id = event.owner_id\n        self.state.account_number = event.account_number\n        self.state.balance = event.initial_deposit\n\n    def on_money_deposited(self, event: MoneyDepositedEvent):\n        \"\"\"Handle money deposited event\"\"\"\n        self.state.balance = event.balance_after\n\n    def on_money_withdrawn(self, event: MoneyWithdrawnEvent):\n        \"\"\"Handle money withdrawn event\"\"\"\n        self.state.balance = event.balance_after\n</code></pre>"},{"location":"samples/openbank/#application-layer","title":"\ud83d\udcbc Application Layer","text":""},{"location":"samples/openbank/#command-handlers","title":"Command Handlers","text":"<p>Command handlers execute business operations:</p> <pre><code>from neuroglia.mediation.mediator import CommandHandler\nfrom neuroglia.data.infrastructure.abstractions import Repository\n\nclass RegisterPersonCommandHandler(CommandHandler[RegisterPersonCommand, OperationResult[PersonDto]]):\n    \"\"\"Handles person registration commands\"\"\"\n\n    def __init__(self,\n                 mapper: Mapper,\n                 person_repository: Repository[Person, str]):\n        self.mapper = mapper\n        self.person_repository = person_repository\n\n    async def handle_async(self, command: RegisterPersonCommand) -&gt; OperationResult[PersonDto]:\n        try:\n            # Create new person aggregate\n            person = Person(str(uuid.uuid4()))\n\n            # Execute business operation\n            person.register(\n                first_name=command.first_name,\n                last_name=command.last_name,\n                nationality=command.nationality,\n                gender=command.gender,\n                date_of_birth=command.date_of_birth,\n                address=command.address\n            )\n\n            # Save to event store\n            saved_person = await self.person_repository.add_async(person)\n\n            # Map to DTO and return\n            person_dto = self.mapper.map(saved_person.state, PersonDto)\n            return self.created(person_dto)\n\n        except ValueError as ex:\n            return self.bad_request(str(ex))\n        except Exception as ex:\n            return self.internal_error(f\"Failed to register person: {ex}\")\n\nclass DepositCommandHandler(CommandHandler[DepositCommand, OperationResult[AccountDto]]):\n    \"\"\"Handles money deposit commands\"\"\"\n\n    def __init__(self,\n                 mapper: Mapper,\n                 account_repository: Repository[Account, str]):\n        self.mapper = mapper\n        self.account_repository = account_repository\n\n    async def handle_async(self, command: DepositCommand) -&gt; OperationResult[AccountDto]:\n        try:\n            # Load account from event store\n            account = await self.account_repository.get_by_id_async(command.account_id)\n            if account is None:\n                return self.not_found(\"Account not found\")\n\n            # Execute business operation\n            account.deposit(command.amount, command.description)\n\n            # Save changes\n            await self.account_repository.update_async(account)\n\n            # Map to DTO and return\n            account_dto = self.mapper.map(account.state, AccountDto)\n            return self.ok(account_dto)\n\n        except ValueError as ex:\n            return self.bad_request(str(ex))\n        except Exception as ex:\n            return self.internal_error(f\"Failed to deposit money: {ex}\")\n</code></pre>"},{"location":"samples/openbank/#query-handlers","title":"Query Handlers","text":"<p>Query handlers retrieve data for read operations:</p> <pre><code>class GetPersonByIdQueryHandler(QueryHandler[GetPersonByIdQuery, OperationResult[PersonDto]]):\n    \"\"\"Handles person lookup queries\"\"\"\n\n    def __init__(self,\n                 mapper: Mapper,\n                 person_repository: Repository[PersonDto, str]):  # Read model repository\n        self.mapper = mapper\n        self.person_repository = person_repository\n\n    async def handle_async(self, query: GetPersonByIdQuery) -&gt; OperationResult[PersonDto]:\n        person = await self.person_repository.get_by_id_async(query.person_id)\n\n        if person is None:\n            return self.not_found(f\"Person with ID {query.person_id} not found\")\n\n        return self.ok(person)\n\nclass GetAccountsByOwnerQueryHandler(QueryHandler[GetAccountsByOwnerQuery, OperationResult[List[AccountDto]]]):\n    \"\"\"Handles account lookup by owner queries\"\"\"\n\n    def __init__(self, account_repository: Repository[AccountDto, str]):\n        self.account_repository = account_repository\n\n    async def handle_async(self, query: GetAccountsByOwnerQuery) -&gt; OperationResult[List[AccountDto]]:\n        accounts = await self.account_repository.find_by_criteria_async(\n            {\"owner_id\": query.owner_id}\n        )\n        return self.ok(accounts)\n</code></pre>"},{"location":"samples/openbank/#event-handling","title":"\ud83d\udce1 Event Handling","text":""},{"location":"samples/openbank/#domain-events","title":"Domain Events","text":"<p>Domain events represent business events within aggregates:</p> <pre><code>@dataclass\nclass PersonRegisteredEvent(DomainEvent):\n    \"\"\"Event raised when a person is registered\"\"\"\n    person_id: str\n    first_name: str\n    last_name: str\n    nationality: str\n    gender: PersonGender\n    date_of_birth: date\n    address: Address\n\n@dataclass\nclass AccountOpenedEvent(DomainEvent):\n    \"\"\"Event raised when an account is opened\"\"\"\n    account_id: str\n    owner_id: str\n    account_number: str\n    initial_deposit: Decimal\n\n@dataclass\nclass MoneyDepositedEvent(DomainEvent):\n    \"\"\"Event raised when money is deposited\"\"\"\n    account_id: str\n    amount: Decimal\n    description: str\n    balance_after: Decimal\n</code></pre>"},{"location":"samples/openbank/#integration-events","title":"Integration Events","text":"<p>Integration events handle cross-bounded-context communication:</p> <pre><code>class PersonRegisteredIntegrationEventHandler(EventHandler[PersonRegisteredEvent]):\n    \"\"\"Handles person registered events for integration purposes\"\"\"\n\n    def __init__(self,\n                 cloud_event_publisher: CloudEventPublisher,\n                 mapper: Mapper):\n        self.cloud_event_publisher = cloud_event_publisher\n        self.mapper = mapper\n\n    async def handle_async(self, event: PersonRegisteredEvent):\n        # Create integration event\n        integration_event = PersonRegisteredIntegrationEvent(\n            person_id=event.person_id,\n            email=event.email,\n            full_name=f\"{event.first_name} {event.last_name}\",\n            timestamp=datetime.utcnow()\n        )\n\n        # Publish as CloudEvent\n        await self.cloud_event_publisher.publish_async(\n            event_type=\"person.registered.v1\",\n            data=integration_event,\n            source=\"openbank.persons\"\n        )\n</code></pre>"},{"location":"samples/openbank/#data-access","title":"\ud83d\uddc4\ufe0f Data Access","text":""},{"location":"samples/openbank/#event-sourcing-repository","title":"Event Sourcing Repository","text":"<p>The write model uses event sourcing:</p> <pre><code># Configuration in main.py\nfrom neuroglia.data.infrastructure.event_sourcing import EventSourcingRepository\nfrom neuroglia.data.infrastructure.event_sourcing.event_store import ESEventStore\n\n# Configure Event Store\nESEventStore.configure(builder, EventStoreOptions(database_name, consumer_group))\n\n# Configure event sourcing repositories\nDataAccessLayer.WriteModel.configure(\n    builder,\n    [\"samples.openbank.domain.models\"],\n    lambda builder_, entity_type, key_type: EventSourcingRepository.configure(\n        builder_, entity_type, key_type\n    )\n)\n</code></pre>"},{"location":"samples/openbank/#read-model-repository","title":"Read Model Repository","text":"<p>The read model uses MongoDB:</p> <pre><code># Configuration in main.py\nfrom neuroglia.data.infrastructure.mongo import MongoRepository\n\n# Configure MongoDB repositories\nDataAccessLayer.ReadModel.configure(\n    builder,\n    [\"samples.openbank.integration.models\", \"samples.openbank.application.events\"],\n    lambda builder_, entity_type, key_type: MongoRepository.configure(\n        builder_, entity_type, key_type, database_name\n    )\n)\n</code></pre>"},{"location":"samples/openbank/#api-layer","title":"\ud83c\udf10 API Layer","text":""},{"location":"samples/openbank/#controllers","title":"Controllers","text":"<p>Controllers expose the domain through REST APIs:</p> <pre><code>class PersonsController(ControllerBase):\n    \"\"\"Persons management API\"\"\"\n\n    @post(\"/\", response_model=PersonDto, status_code=201)\n    async def register_person(self, command: RegisterPersonCommandDto) -&gt; PersonDto:\n        \"\"\"Register a new person\"\"\"\n        # Map DTO to domain command\n        domain_command = self.mapper.map(command, RegisterPersonCommand)\n\n        # Execute through mediator\n        result = await self.mediator.execute_async(domain_command)\n\n        # Process and return result\n        return self.process(result)\n\n    @get(\"/\", response_model=List[PersonDto])\n    async def list_persons(self) -&gt; List[PersonDto]:\n        \"\"\"List all registered persons\"\"\"\n        query = ListPersonsQuery()\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/{person_id}\", response_model=PersonDto)\n    async def get_person_by_id(self, person_id: str) -&gt; PersonDto:\n        \"\"\"Get person by ID\"\"\"\n        query = GetPersonByIdQuery(person_id=person_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\nclass AccountsController(ControllerBase):\n    \"\"\"Accounts management API\"\"\"\n\n    @post(\"/\", response_model=AccountDto, status_code=201)\n    async def open_account(self, command: OpenAccountCommandDto) -&gt; AccountDto:\n        \"\"\"Open a new account\"\"\"\n        domain_command = self.mapper.map(command, OpenAccountCommand)\n        result = await self.mediator.execute_async(domain_command)\n        return self.process(result)\n\n    @post(\"/{account_id}/deposit\", response_model=AccountDto)\n    async def deposit(self, account_id: str, command: DepositCommandDto) -&gt; AccountDto:\n        \"\"\"Deposit money to account\"\"\"\n        domain_command = self.mapper.map(command, DepositCommand)\n        domain_command.account_id = account_id\n        result = await self.mediator.execute_async(domain_command)\n        return self.process(result)\n\n    @get(\"/by-owner/{owner_id}\", response_model=List[AccountDto])\n    async def get_accounts_by_owner(self, owner_id: str) -&gt; List[AccountDto]:\n        \"\"\"Get all accounts for a person\"\"\"\n        query = GetAccountsByOwnerQuery(owner_id=owner_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"samples/openbank/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"samples/openbank/#unit-tests","title":"Unit Tests","text":"<p>Test domain logic in isolation:</p> <pre><code>def test_person_registration():\n    # Arrange\n    person = Person(\"test-id\")\n    address = Address(\"123 Main St\", \"Anytown\", \"12345\", \"USA\")\n\n    # Act\n    person.register(\n        first_name=\"John\",\n        last_name=\"Doe\",\n        nationality=\"US\",\n        gender=PersonGender.MALE,\n        date_of_birth=date(1990, 1, 1),\n        address=address\n    )\n\n    # Assert\n    assert person.state.first_name == \"John\"\n    assert person.state.last_name == \"Doe\"\n    assert len(person.uncommitted_events) == 1\n    assert isinstance(person.uncommitted_events[0], PersonRegisteredEvent)\n\ndef test_account_deposit():\n    # Arrange\n    account = Account(\"test-account\")\n    account.open(\"owner-id\", \"123456789\", Decimal('100.00'))\n\n    # Act\n    account.deposit(Decimal('50.00'), \"Test deposit\")\n\n    # Assert\n    assert account.state.balance == Decimal('150.00')\n    assert len(account.uncommitted_events) == 2  # Open + Deposit\n</code></pre>"},{"location":"samples/openbank/#integration-tests","title":"Integration Tests","text":"<p>Test the complete flow:</p> <pre><code>@pytest.mark.asyncio\nasync def test_person_registration_flow():\n    # Arrange\n    client = TestClient(app)\n    person_data = {\n        \"first_name\": \"John\",\n        \"last_name\": \"Doe\",\n        \"nationality\": \"US\",\n        \"gender\": \"MALE\",\n        \"date_of_birth\": \"1990-01-01\",\n        \"address\": {\n            \"street\": \"123 Main St\",\n            \"city\": \"Anytown\",\n            \"postal_code\": \"12345\",\n            \"country\": \"USA\"\n        }\n    }\n\n    # Act\n    response = client.post(\"/api/v1/persons\", json=person_data)\n\n    # Assert\n    assert response.status_code == 201\n    person = response.json()\n    assert person[\"first_name\"] == \"John\"\n    assert person[\"last_name\"] == \"Doe\"\n\n    # Verify person can be retrieved\n    get_response = client.get(f\"/api/v1/persons/{person['id']}\")\n    assert get_response.status_code == 200\n</code></pre>"},{"location":"samples/openbank/#running-the-sample","title":"\ud83d\ude80 Running the Sample","text":""},{"location":"samples/openbank/#start-the-application","title":"Start the Application","text":"<ol> <li>Start infrastructure:</li> </ol> <pre><code>docker-compose up -d\n</code></pre> <ol> <li>Run the application:</li> </ol> <pre><code>python api/main.py\n</code></pre>"},{"location":"samples/openbank/#example-api-calls","title":"Example API Calls","text":"<p>Register a Person:</p> <pre><code>curl -X POST \"http://localhost:8000/api/v1/persons\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"first_name\": \"John\",\n    \"last_name\": \"Doe\",\n    \"nationality\": \"US\",\n    \"gender\": \"MALE\",\n    \"date_of_birth\": \"1990-01-01\",\n    \"address\": {\n      \"street\": \"123 Main St\",\n      \"city\": \"Anytown\",\n      \"postal_code\": \"12345\",\n      \"country\": \"USA\"\n    }\n  }'\n</code></pre> <p>Open an Account:</p> <pre><code>curl -X POST \"http://localhost:8000/api/v1/accounts\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"owner_id\": \"PERSON_ID_FROM_ABOVE\",\n    \"account_number\": \"123456789\",\n    \"initial_deposit\": 1000.00\n  }'\n</code></pre> <p>Deposit Money:</p> <pre><code>curl -X POST \"http://localhost:8000/api/v1/accounts/ACCOUNT_ID/deposit\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"amount\": 500.00,\n    \"description\": \"Salary deposit\"\n  }'\n</code></pre>"},{"location":"samples/openbank/#key-learnings","title":"\ud83d\udccb Key Learnings","text":"<p>The OpenBank sample demonstrates:</p> <ol> <li>Event Sourcing: How to store state as a sequence of events</li> <li>CQRS: Separation of write and read models</li> <li>Domain-Driven Design: Rich domain models with business rules</li> <li>Clean Architecture: Clear separation of concerns</li> <li>Event-Driven Architecture: How events enable loose coupling</li> <li>Repository Pattern: Abstract data access for different storage types</li> <li>Integration Events: Cross-bounded-context communication</li> </ol>"},{"location":"samples/openbank/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Basic Neuroglia concepts</li> <li>Event Sourcing - Event sourcing patterns</li> <li>CQRS &amp; Mediation - Command and query patterns</li> <li>Event Handling - Event-driven architecture</li> <li>Source Code Naming Conventions - Naming patterns used throughout this sample</li> </ul>"}]}