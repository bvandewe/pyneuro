{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\ude80 Neuroglia Python Framework","text":"<p>Neuroglia is a lightweight, opinionated framework built on top of FastAPI that provides a comprehensive set of tools and patterns for building clean, maintainable, and scalable microservices. It enforces architectural best practices and provides out-of-the-box implementations of common patterns.</p>"},{"location":"#what-makes-neuroglia-special","title":"\u2728 What Makes Neuroglia Special?","text":"<ul> <li>\ud83c\udfd7\ufe0f Clean Architecture Enforced: Clear separation between API, Application, Domain, and Integration layers</li> <li>\ud83d\udc89 Powerful Dependency Injection: Lightweight container with automatic service discovery</li> <li>\ud83c\udfaf CQRS &amp; Mediation Built-in: Command Query Responsibility Segregation with mediator pattern</li> <li>\ud83d\udce1 Event-Driven by Design: Native CloudEvents, event sourcing, and reactive programming</li> <li>\ud83d\udd0c MVC Done Right: Class-based controllers with automatic discovery and OpenAPI generation</li> <li>\ud83d\uddc4\ufe0f Flexible Data Access: Repository pattern with MongoDB, Event Store, and in-memory support</li> <li>\ud83d\udcca Smart Object Mapping: Bidirectional mapping between domain models and DTOs</li> <li>\u26a1 Reactive Programming: Built-in RxPy support for asynchronous event handling</li> </ul>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"<p>Get up and running in minutes:</p> <pre><code># Install Neuroglia\npip install neuroglia\n\n# Create your first app\npython -c \"\nfrom neuroglia.hosting.web import WebApplicationBuilder\n\nbuilder = WebApplicationBuilder()\nbuilder.add_controllers(['api.controllers'])\n\napp = builder.build()\napp.use_controllers()\napp.run()\n\"\n</code></pre> <p>\ud83d\udc49 Get Started Now</p>"},{"location":"#architecture-overview","title":"\ud83c\udfaf Architecture Overview","text":"<p>Neuroglia promotes a clean, layered architecture:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  API Layer                      \u2502  \u2190 Controllers, DTOs, Routes\n\u2502            (FastAPI Integration)                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 Commands &amp; Queries\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Application Layer                  \u2502  \u2190 Handlers, Services, Workflows\n\u2502         (CQRS, Mediation, Use Cases)            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 Domain Operations\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502               Domain Layer                      \u2502  \u2190 Business Logic, Entities, Rules\n\u2502         (Pure Business Logic)                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 Interface Implementation\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            Integration Layer                    \u2502  \u2190 Databases, APIs, Infrastructure\n\u2502      (Repositories, External Services)          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>\ud83d\udcd6 Learn the Architecture</p>"},{"location":"#core-features","title":"\ud83c\udfaa Core Features","text":""},{"location":"#dependency-injection","title":"\ud83d\udc89 Dependency Injection","text":"<p>Powerful, lightweight DI container with automatic service discovery:</p> <pre><code># Automatic registration\nservices.add_scoped(UserService)\nservices.add_singleton(CacheService)\n\n# Constructor injection\nclass UserController(ControllerBase):\n    def __init__(self, user_service: UserService):\n        self.user_service = user_service\n</code></pre> <p>\ud83d\udcd6 Dependency Injection Guide</p>"},{"location":"#cqrs-mediation","title":"\ud83c\udfaf CQRS &amp; Mediation","text":"<p>Clean separation of commands and queries with built-in mediation:</p> <pre><code># Command\n@dataclass\nclass CreateUserCommand(Command[OperationResult[UserDto]]):\n    email: str\n    first_name: str\n\n# Handler\nclass CreateUserHandler(CommandHandler[CreateUserCommand, OperationResult[UserDto]]):\n    async def handle_async(self, command: CreateUserCommand) -&gt; OperationResult[UserDto]:\n        # Business logic here\n        return self.created(user_dto)\n\n# Usage in controller\nresult = await self.mediator.execute_async(command)\n</code></pre> <p>\ud83d\udcd6 CQRS &amp; Mediation Guide</p>"},{"location":"#mvc-controllers","title":"\ud83d\udd0c MVC Controllers","text":"<p>Class-based controllers with automatic discovery and full FastAPI integration:</p> <pre><code>class UsersController(ControllerBase):\n    @post(\"/\", response_model=UserDto, status_code=201)\n    async def create_user(self, user_dto: CreateUserDto) -&gt; UserDto:\n        command = self.mapper.map(user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre> <p>\ud83d\udcd6 MVC Controllers Guide</p>"},{"location":"#event-driven-architecture","title":"\ud83d\udce1 Event-Driven Architecture","text":"<p>Native support for CloudEvents and reactive programming:</p> <pre><code># Domain events\nclass UserCreatedEvent(DomainEvent):\n    user_id: str\n    email: str\n\n# Event handlers\nclass WelcomeEmailHandler(EventHandler[UserCreatedEvent]):\n    async def handle_async(self, event: UserCreatedEvent):\n        await self.email_service.send_welcome(event.email)\n</code></pre> <p>\ud83d\udcd6 Event Handling Guide</p>"},{"location":"#data-access","title":"\ud83d\uddc4\ufe0f Data Access","text":"<p>Flexible repository pattern with multiple storage backends:</p> <pre><code># Repository interface\nclass IUserRepository(Repository[User, str]):\n    async def get_by_email(self, email: str) -&gt; User:\n        pass\n\n# MongoDB implementation\nclass MongoUserRepository(IUserRepository):\n    # Implementation\n\n# Event sourcing implementation  \nclass EventSourcedUserRepository(IUserRepository):\n    # Implementation\n</code></pre> <p>\ud83d\udcd6 Data Access Guide</p>"},{"location":"#sample-applications","title":"\ud83c\udf93 Sample Applications","text":"<p>Learn by example with complete, production-ready sample applications:</p>"},{"location":"#openbank-event-sourced-banking-system","title":"\ud83c\udfe6 OpenBank - Event-Sourced Banking System","text":"<p>A comprehensive banking domain showcasing:</p> <ul> <li>\u2705 Event sourcing with EventStoreDB</li> <li>\u2705 CQRS with separate read/write models  </li> <li>\u2705 Domain-driven design patterns</li> <li>\u2705 Event-driven architecture</li> <li>\u2705 Clean architecture layers</li> </ul> <p>\ud83d\udc49 Explore OpenBank</p>"},{"location":"#api-gateway-microservice-gateway","title":"\ud83d\udeaa API Gateway - Microservice Gateway","text":"<p>An intelligent API gateway featuring:</p> <ul> <li>\u2705 Request routing and load balancing</li> <li>\u2705 Authentication and authorization</li> <li>\u2705 Rate limiting and caching</li> <li>\u2705 Monitoring and observability</li> </ul> <p>\ud83d\udc49 Explore API Gateway</p>"},{"location":"#desktop-controller-remote-management","title":"\ud83d\udda5\ufe0f Desktop Controller - Remote Management","text":"<p>A desktop management API demonstrating:</p> <ul> <li>\u2705 Background services and scheduling</li> <li>\u2705 Real-time communication</li> <li>\u2705 System integration patterns</li> <li>\u2705 Docker containerization</li> </ul> <p>\ud83d\udc49 Explore Desktop Controller</p>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":""},{"location":"#getting-started","title":"\ud83d\ude80 Getting Started","text":"<ul> <li>Quick Start Guide - Build your first app in 10 minutes</li> <li>Architecture Overview - Understand the framework's design</li> <li>Project Structure - Organize your code properly</li> </ul>"},{"location":"#feature-guides","title":"\ud83c\udfaa Feature Guides","text":"Feature Description Documentation Dependency Injection Service container and automatic registration \ud83d\udcd6 Guide CQRS &amp; Mediation Command/Query separation with mediator \ud83d\udcd6 Guide MVC Controllers Class-based API controllers \ud83d\udcd6 Guide Data Access Repository pattern and persistence \ud83d\udcd6 Guide Event Handling Events, messaging, and reactive programming \ud83d\udcd6 Guide Object Mapping Automatic object-to-object mapping \ud83d\udcd6 Guide Configuration Settings and environment management \ud83d\udcd6 Guide Hosting Web application hosting and lifecycle \ud83d\udcd6 Guide"},{"location":"#requirements","title":"\ud83d\udccb Requirements","text":"<ul> <li>Python 3.11+</li> <li>FastAPI (automatic)</li> <li>Pydantic (automatic)</li> <li>Optional: MongoDB, EventStoreDB, Redis (based on features used)</li> </ul>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions! Here's how you can help:</p> <ul> <li>\ud83d\udc1b Report bugs - Found an issue? Let us know!</li> <li>\ud83d\udca1 Suggest features - Have an idea? We'd love to hear it!</li> <li>\ud83d\udcdd Improve docs - Help make our documentation better</li> <li>\ud83d\udd27 Submit PRs - Code contributions are always welcome</li> </ul> <p>\ud83d\udc49 Contributing Guide</p>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"#why-choose-neuroglia","title":"\ud83c\udf1f Why Choose Neuroglia?","text":"<p>\u2705 Production Ready: Battle-tested patterns and practices \u2705 Developer Friendly: Intuitive APIs and excellent documentation \u2705 Highly Testable: Built with testing in mind from day one \u2705 Scalable: Patterns that grow with your application \u2705 Modern: Leverages the latest Python and FastAPI features \u2705 Flexible: Use only what you need, when you need it  </p> <p>Ready to build something amazing? Get Started Now \ud83d\ude80</p>"},{"location":"#running-background-tasks","title":"Running Background Tasks","text":"<p>Neuroglia integrates with apscheduler for background tasks:</p> <pre><code>from apscheduler.schedulers.asyncio import AsyncIOScheduler\nfrom neuroglia.hosting.abstractions import HostedService\n\nclass BackgroundTaskService(HostedService):\n    def __init__(self):\n        self._scheduler = AsyncIOScheduler()\n\n    async def start_async(self):\n        # Add jobs\n        self._scheduler.add_job(self._process_data, 'interval', minutes=5)\n        self._scheduler.start()\n\n    async def stop_async(self):\n        self._scheduler.shutdown()\n\n    async def _process_data(self):\n        # Task implementation\n        pass\n</code></pre>"},{"location":"#advanced-features","title":"Advanced Features","text":""},{"location":"#real-time-communication-with-cloudevents","title":"Real-time Communication with CloudEvents","text":"<pre><code>from neuroglia.eventing.cloud_events.infrastructure import CloudEventIngestor\nfrom neuroglia.eventing.cloud_events.decorators import cloud_event_handler\n\nclass NotificationService:\n    def __init__(self, event_ingestor: CloudEventIngestor):\n        event_ingestor.subscribe(\"user.created\", self._on_user_created)\n\n    @cloud_event_handler\n    async def _on_user_created(self, event_data):\n        # Process user created event\n        user_id = event_data[\"id\"]\n        # Send notification\n</code></pre>"},{"location":"#custom-repository-implementation","title":"Custom Repository Implementation","text":"<pre><code>from neuroglia.data.infrastructure.abstractions import Repository\n\nclass CustomRepository(Repository[Entity, str]):\n    async def add(self, entity: Entity) -&gt; None:\n        # Custom implementation\n\n    async def update(self, entity: Entity) -&gt; None:\n        # Custom implementation\n\n    async def remove(self, entity: Entity) -&gt; None:\n        # Custom implementation\n\n    async def find_by_id(self, id: str) -&gt; Optional[Entity]:\n        # Custom implementation\n</code></pre>"},{"location":"#samples","title":"Samples","text":""},{"location":"#openbank","title":"OpenBank","text":"<p>Implements a simplified Bank that manages Accounts, Users and Transactions with full Event Sourcing, CQRS</p> <p>Explore OpenBank</p>"},{"location":"#desktop-controller","title":"Desktop Controller","text":"<p>Remotely and securely control custom files or commands on a Desktop running the app as a Docker container...</p> <p>Explore Desktop Controller</p>"},{"location":"#api-gateway","title":"API Gateway","text":"<p>Expose single entry point for 3rd party clients into an internal layer, like a GenAI stack... Models a Prompt entity, enforces a business logic (e.g. Prompt' state-machine), handles scheduled background task (with persistence), exposes API with multiple Security schemes, ...</p> <p>Explore API Gateway</p>"},{"location":"#cisco-remote-output-collector","title":"Cisco Remote Output Collector","text":"<p>Statefull microservice that handles complex and custom HTTP Commands which in turn each encapsulates arbitrary interactions with given Cisco Device(s) via Telnet, such as <code>FindPrompt</code>, <code>CollectCommandLineOutput</code>, <code>AddConfiguration</code>, <code>SaveConfiguration</code>, <code>Ping</code>, <code>Traceroute</code>, <code>ClearNatTranslation</code>, <code>CheckReachability</code>, <code>BounceInterface</code>, <code>RunViaTelnetTo</code>, <code>FindSpanningTreeRoot</code>, ... etc.</p> <p>Explore IOS ROC</p> <p>Current state: functional but simple implemention, 100% stateless collection of multiple CLI to a single device via Telnet.</p> <p>TODO:</p> <ul> <li>[ ] Add Session management (defines a Pod for subsequent scenarios) with persistence</li> <li>[ ] Add DeviceConnection and ConnectionManager</li> <li>[ ] Add DeviceDrivers and PromptPatterns libraries</li> <li>[ ] ...</li> </ul>"},{"location":"#deployment","title":"Deployment","text":""},{"location":"#docker-deployment","title":"Docker Deployment","text":"<p>The framework is designed to work seamlessly with Docker. A typical Dockerfile might look like:</p> <pre><code>FROM python:3.10-slim\n\nWORKDIR /app\n\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\nCOPY . .\n\nEXPOSE 8000\n\nCMD [\"uvicorn\", \"api.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n</code></pre>"},{"location":"#environment-configuration","title":"Environment Configuration","text":"<p>Following the 12-Factor App principles, configuration is stored in environment variables:</p> <pre><code>from neuroglia.hosting.abstractions import ApplicationSettings\nfrom pydantic import BaseSettings\n\nclass MyAppSettings(ApplicationSettings):\n    database_url: str\n    api_key: str\n    debug_mode: bool = False\n</code></pre>"},{"location":"#testing","title":"Testing","text":"<p>The framework supports comprehensive testing with pytest:</p> <pre><code># Example test for a command handler\nasync def test_create_user_command():\n    # Arrange\n    handler = CreateUserCommandHandler(mock_repository)\n    command = CreateUserCommand(\"test\", \"test@example.com\")\n\n    # Act\n    result = await handler.handle(command)\n\n    # Assert\n    assert result is not None\n    assert mock_repository.add.called_once\n</code></pre>"},{"location":"#best-practices","title":"Best Practices","text":"<ol> <li>Keep Domain Models Pure: Domain models should be free of infrastructure concerns</li> <li>Use Commands for State Changes: All state-changing operations should be modeled as commands</li> <li>Use Queries for Reading Data: All data retrieval should be modeled as queries</li> <li>Leverage Dependency Injection: Always use DI to create loosely coupled components</li> <li>Handle Errors with Problem Details: Use the standard ProblemDetails format for error responses</li> <li>Follow Layered Architecture: Maintain clear boundaries between API, Application, Domain, and Integration layers</li> </ol>"},{"location":"#conclusion","title":"Conclusion","text":"<p>The Neuroglia Python Framework provides a comprehensive foundation for building clean, maintainable, and feature-rich microservices. By embracing modern architectural patterns like CQRS, Event Sourcing, and Clean Architecture, it helps developers create applications that are easier to understand, test, and evolve over time.</p> <p>For more information, check out the sample applications or contribute to the framework development.</p>"},{"location":"architecture/","title":"\ud83c\udfd7\ufe0f Architecture Guide","text":"<p>Neuroglia implements a clean, layered architecture that promotes separation of concerns, testability, and maintainability. This guide explains the architectural principles and how they're implemented in the framework.</p>"},{"location":"architecture/#architectural-principles","title":"\ud83c\udfaf Architectural Principles","text":""},{"location":"architecture/#1-clean-architecture","title":"1. Clean Architecture","text":"<p>Neuroglia follows Clean Architecture principles:</p> <ul> <li>Dependency Rule: Dependencies always point inward (toward the domain)</li> <li>Independent of Frameworks: Business logic doesn't depend on framework details</li> <li>Testable: Business rules can be tested without external dependencies</li> <li>Independent of UI: The application can work with different interfaces</li> <li>Independent of Database: Business rules aren't bound to a specific database</li> </ul>"},{"location":"architecture/#2-separation-of-concerns","title":"2. Separation of Concerns","text":"<p>Each layer has a specific responsibility and doesn't concern itself with the details of other layers:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 API Layer                        \u2502  \u2190 External Interface\n\u2502            (Controllers, DTOs)                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 depends on\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Application Layer                   \u2502  \u2190 Orchestration\n\u2502         (Commands, Queries, Handlers)           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 depends on\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502               Domain Layer                       \u2502  \u2190 Business Logic\n\u2502            (Entities, Services)                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 implements\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            Integration Layer                     \u2502  \u2190 External Concerns\n\u2502        (Repositories, API Clients)              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#3-inversion-of-control","title":"3. Inversion of Control","text":"<p>The framework uses dependency injection to invert control flow and reduce coupling between components.</p>"},{"location":"architecture/#layer-breakdown","title":"\ud83c\udfe2 Layer Breakdown","text":""},{"location":"architecture/#api-layer-srcapi","title":"\ud83d\udce1 API Layer (<code>src/api/</code>)","text":"<p>Purpose: Defines the external interface of your application</p> <p>Responsibilities:</p> <ul> <li>HTTP endpoints and routing</li> <li>Request/response DTOs</li> <li>Authentication and authorization</li> <li>Input validation</li> <li>OpenAPI documentation</li> </ul> <p>Key Components:</p> <ul> <li>Controllers: Handle HTTP requests and delegate to application layer</li> <li>DTOs: Data Transfer Objects for API contracts</li> <li>Middleware: Cross-cutting concerns like authentication, logging</li> </ul> <p>Example Structure:</p> <pre><code>api/\n\u251c\u2500\u2500 controllers/\n\u2502   \u251c\u2500\u2500 users_controller.py\n\u2502   \u2514\u2500\u2500 orders_controller.py\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 user_dto.py\n\u2502   \u2514\u2500\u2500 order_dto.py\n\u2514\u2500\u2500 middleware/\n    \u251c\u2500\u2500 auth_middleware.py\n    \u2514\u2500\u2500 logging_middleware.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Keep controllers thin - delegate business logic to application layer</li> <li>Use DTOs to define API contracts</li> <li>Validate input at the API boundary</li> <li>Map between DTOs and domain models</li> </ul>"},{"location":"architecture/#application-layer-srcapplication","title":"\ud83d\udcbc Application Layer (<code>src/application/</code>)","text":"<p>Purpose: Orchestrates business workflows and coordinates domain operations</p> <p>Responsibilities:</p> <ul> <li>Command and query handling</li> <li>Business workflow orchestration</li> <li>Transaction management</li> <li>Event publishing</li> <li>Application services</li> </ul> <p>Key Components:</p> <ul> <li>Commands: Represent actions that change state</li> <li>Queries: Represent read operations</li> <li>Handlers: Process commands and queries</li> <li>Services: Application-specific business logic</li> </ul> <p>Example Structure:</p> <pre><code>application/\n\u251c\u2500\u2500 commands/\n\u2502   \u251c\u2500\u2500 create_user_command.py\n\u2502   \u2514\u2500\u2500 update_user_command.py\n\u251c\u2500\u2500 queries/\n\u2502   \u251c\u2500\u2500 get_user_query.py\n\u2502   \u2514\u2500\u2500 list_users_query.py\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 user_service.py\n\u2502   \u2514\u2500\u2500 notification_service.py\n\u2514\u2500\u2500 events/\n    \u251c\u2500\u2500 user_created_event.py\n    \u2514\u2500\u2500 user_updated_event.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Each command/query should have a single responsibility</li> <li>Use the mediator pattern to decouple handlers</li> <li>Keep application services focused on coordination</li> <li>Publish domain events for side effects</li> </ul>"},{"location":"architecture/#domain-layer-srcdomain","title":"\ud83c\udfdb\ufe0f Domain Layer (<code>src/domain/</code>)","text":"<p>Purpose: Contains the core business logic and rules</p> <p>Responsibilities:</p> <ul> <li>Business entities and aggregates</li> <li>Value objects</li> <li>Domain services</li> <li>Business rules and invariants</li> <li>Domain events</li> </ul> <p>Key Components:</p> <ul> <li>Entities: Objects with identity and lifecycle</li> <li>Value Objects: Immutable objects defined by their attributes</li> <li>Aggregates: Consistency boundaries</li> <li>Domain Services: Business logic that doesn't belong to entities</li> </ul> <p>Example Structure:</p> <pre><code>domain/\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 user.py\n\u2502   \u251c\u2500\u2500 order.py\n\u2502   \u2514\u2500\u2500 address.py\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 pricing_service.py\n\u2502   \u2514\u2500\u2500 validation_service.py\n\u2514\u2500\u2500 events/\n    \u251c\u2500\u2500 user_registered.py\n    \u2514\u2500\u2500 order_placed.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Keep domain models rich with behavior</li> <li>Enforce business invariants</li> <li>Use domain events for decoupling</li> <li>Avoid dependencies on infrastructure</li> </ul>"},{"location":"architecture/#integration-layer-srcintegration","title":"\ud83d\udd0c Integration Layer (<code>src/integration/</code>)","text":"<p>Purpose: Handles external integrations and infrastructure concerns</p> <p>Responsibilities:</p> <ul> <li>Database repositories</li> <li>External API clients</li> <li>Message queue integration</li> <li>File system operations</li> <li>Caching</li> </ul> <p>Key Components:</p> <ul> <li>Repositories: Data access implementations</li> <li>API Clients: External service integrations</li> <li>DTOs: External data contracts</li> <li>Infrastructure Services: Technical concerns</li> </ul> <p>Example Structure:</p> <pre><code>integration/\n\u251c\u2500\u2500 repositories/\n\u2502   \u251c\u2500\u2500 user_repository.py\n\u2502   \u2514\u2500\u2500 order_repository.py\n\u251c\u2500\u2500 clients/\n\u2502   \u251c\u2500\u2500 payment_client.py\n\u2502   \u2514\u2500\u2500 email_client.py\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 user_entity.py\n\u2502   \u2514\u2500\u2500 payment_dto.py\n\u2514\u2500\u2500 services/\n    \u251c\u2500\u2500 cache_service.py\n    \u2514\u2500\u2500 file_service.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Implement domain repository interfaces</li> <li>Handle external failures gracefully</li> <li>Use DTOs for external data contracts</li> <li>Isolate infrastructure concerns</li> </ul>"},{"location":"architecture/#data-flow","title":"\ud83d\udd04 Data Flow","text":""},{"location":"architecture/#command-flow-write-operations","title":"Command Flow (Write Operations)","text":"<ol> <li>Controller receives HTTP request with DTO</li> <li>Controller maps DTO to Command and sends to Mediator</li> <li>Mediator routes Command to appropriate Handler</li> <li>Handler loads domain entities via Repository</li> <li>Handler executes business logic on domain entities</li> <li>Handler saves changes via Repository</li> <li>Handler publishes domain events</li> <li>Handler returns result to Controller</li> <li>Controller maps result to DTO and returns HTTP response</li> </ol> <pre><code>HTTP Request \u2192 Controller \u2192 Command \u2192 Handler \u2192 Domain \u2192 Repository \u2192 Database\n                    \u2193           \u2193        \u2193\n               HTTP Response \u2190 DTO \u2190 Result \u2190 Events\n</code></pre>"},{"location":"architecture/#query-flow-read-operations","title":"Query Flow (Read Operations)","text":"<ol> <li>Controller receives HTTP request with parameters</li> <li>Controller creates Query and sends to Mediator</li> <li>Mediator routes Query to appropriate Handler</li> <li>Handler loads data via Repository or Read Model</li> <li>Handler returns data to Controller</li> <li>Controller maps data to DTO and returns HTTP response</li> </ol> <pre><code>HTTP Request \u2192 Controller \u2192 Query \u2192 Handler \u2192 Repository \u2192 Database\n                    \u2193         \u2193       \u2193\n               HTTP Response \u2190 DTO \u2190 Result\n</code></pre>"},{"location":"architecture/#patterns-implemented","title":"\ud83c\udfad Patterns Implemented","text":""},{"location":"architecture/#1-command-query-responsibility-segregation-cqrs","title":"1. Command Query Responsibility Segregation (CQRS)","text":"<p>Separates read and write operations to optimize performance and scalability:</p> <pre><code># Command (Write)\n@dataclass\nclass CreateUserCommand(Command[OperationResult[UserDto]]):\n    email: str\n    first_name: str\n    last_name: str\n\n# Query (Read)\n@dataclass\nclass GetUserQuery(Query[OperationResult[UserDto]]):\n    user_id: str\n</code></pre>"},{"location":"architecture/#2-mediator-pattern","title":"2. Mediator Pattern","text":"<p>Decouples components by routing requests through a central mediator:</p> <pre><code># In controller\nresult = await self.mediator.execute_async(command)\n</code></pre>"},{"location":"architecture/#3-repository-pattern","title":"3. Repository Pattern","text":"<p>Abstracts data access and provides a consistent interface:</p> <pre><code>class UserRepository(Repository[User, str]):\n    async def add_async(self, user: User) -&gt; User:\n        # Implementation details\n        pass\n</code></pre>"},{"location":"architecture/#4-event-sourcing-optional","title":"4. Event Sourcing (Optional)","text":"<p>Stores state changes as events rather than current state:</p> <pre><code>class User(AggregateRoot[str]):\n    def register(self, email: str, name: str):\n        self.apply(UserRegisteredEvent(email, name))\n</code></pre>"},{"location":"architecture/#5-dependency-injection","title":"5. Dependency Injection","text":"<p>Manages object creation and dependencies:</p> <pre><code># Automatic registration\nbuilder.services.add_scoped(UserService)\n\n# Resolution\nuser_service = provider.get_required_service(UserService)\n</code></pre>"},{"location":"architecture/#testing-architecture","title":"\ud83e\uddea Testing Architecture","text":"<p>The layered architecture makes testing straightforward:</p>"},{"location":"architecture/#unit-tests","title":"Unit Tests","text":"<p>Test individual components in isolation:</p> <pre><code>def test_user_registration():\n    # Arrange\n    command = CreateUserCommand(\"test@example.com\", \"John\", \"Doe\")\n    handler = CreateUserCommandHandler(mock_repository)\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n</code></pre>"},{"location":"architecture/#integration-tests","title":"Integration Tests","text":"<p>Test interactions between layers:</p> <pre><code>def test_create_user_endpoint():\n    # Test API \u2192 Application \u2192 Domain integration\n    response = test_client.post(\"/api/v1/users\", json=user_data)\n    assert response.status_code == 201\n</code></pre>"},{"location":"architecture/#architecture-tests","title":"Architecture Tests","text":"<p>Verify architectural constraints:</p> <pre><code>def test_domain_has_no_infrastructure_dependencies():\n    # Ensure domain layer doesn't depend on infrastructure\n    domain_modules = get_domain_modules()\n    for module in domain_modules:\n        assert not has_infrastructure_imports(module)\n</code></pre>"},{"location":"architecture/#benefits","title":"\ud83d\ude80 Benefits","text":""},{"location":"architecture/#maintainability","title":"Maintainability","text":"<ul> <li>Clear boundaries: Each layer has well-defined responsibilities</li> <li>Loose coupling: Changes in one layer don't affect others</li> <li>High cohesion: Related functionality is grouped together</li> </ul>"},{"location":"architecture/#testability","title":"Testability","text":"<ul> <li>Isolated testing: Each layer can be tested independently</li> <li>Mock dependencies: External dependencies can be easily mocked</li> <li>Fast tests: Business logic tests don't require infrastructure</li> </ul>"},{"location":"architecture/#scalability","title":"Scalability","text":"<ul> <li>CQRS: Read and write models can be optimized separately</li> <li>Event-driven: Asynchronous processing for better performance</li> <li>Microservice ready: Clear boundaries make extraction easier</li> </ul>"},{"location":"architecture/#flexibility","title":"Flexibility","text":"<ul> <li>Technology agnostic: Swap implementations without affecting business logic</li> <li>Framework independence: Business logic isn't tied to web framework</li> <li>Future-proof: Architecture adapts to changing requirements</li> </ul>"},{"location":"architecture/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Build your first application</li> <li>Dependency Injection - Managing dependencies</li> <li>CQRS &amp; Mediation - Command and query patterns</li> <li>Data Access - Repository pattern and persistence</li> <li>Event Handling - Event-driven architecture</li> </ul>"},{"location":"getting-started/","title":"\ud83d\ude80 Getting Started with Neuroglia","text":"<p>This guide will help you create your first Neuroglia application from scratch. By the end, you'll have a working REST API with dependency injection, CQRS patterns, and clean architecture.</p>"},{"location":"getting-started/#prerequisites","title":"\ud83d\udccb Prerequisites","text":"<ul> <li>Python 3.11 or higher</li> <li>Basic understanding of FastAPI and async/await patterns</li> <li>Familiarity with dependency injection concepts</li> </ul>"},{"location":"getting-started/#quick-setup","title":"\u26a1 Quick Setup","text":""},{"location":"getting-started/#1-installation","title":"1. Installation","text":"<pre><code># Install from PyPI (when available)\npip install neuroglia\n\n# Or install from source\ngit clone &lt;repository-url&gt;\ncd pyneuro\npip install -e .\n</code></pre>"},{"location":"getting-started/#2-project-structure","title":"2. Project Structure","text":"<p>Create a new project with the following structure:</p> <pre><code>my-app/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 main.py                 # Application entry point\n\u2502   \u251c\u2500\u2500 api/                    # API Layer\n\u2502   \u2502   \u2514\u2500\u2500 controllers/        # REST controllers\n\u2502   \u251c\u2500\u2500 application/            # Application Layer\n\u2502   \u2502   \u251c\u2500\u2500 commands/           # Command handlers\n\u2502   \u2502   \u251c\u2500\u2500 queries/            # Query handlers\n\u2502   \u2502   \u2514\u2500\u2500 services/           # Business services\n\u2502   \u251c\u2500\u2500 domain/                 # Domain Layer\n\u2502   \u2502   \u2514\u2500\u2500 models/             # Domain entities\n\u2502   \u2514\u2500\u2500 integration/            # Integration Layer\n\u2502       \u251c\u2500\u2500 models/             # DTOs and external models\n\u2502       \u2514\u2500\u2500 services/           # External service clients\n\u2514\u2500\u2500 requirements.txt\n</code></pre>"},{"location":"getting-started/#3-create-your-first-application","title":"3. Create Your First Application","text":"<p>main.py - Application entry point:</p> <pre><code>import logging\nfrom neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.mediation.mediator import Mediator\nfrom neuroglia.mapping.mapper import Mapper\nfrom neuroglia.serialization.json import JsonSerializer\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlog = logging.getLogger(__name__)\n\ndef create_app():\n    \"\"\"Create and configure the Neuroglia application\"\"\"\n\n    # Create the application builder\n    builder = WebApplicationBuilder()\n\n    # Configure core services\n    Mapper.configure(builder, [\"application\", \"domain\", \"integration\"])\n    Mediator.configure(builder, [\"application\"])\n    JsonSerializer.configure(builder)\n\n    # Register controllers\n    builder.add_controllers([\"api.controllers\"])\n\n    # Build the application\n    app = builder.build()\n\n    # Configure middleware and routes\n    app.use_controllers()\n\n    return app\n\nif __name__ == \"__main__\":\n    app = create_app()\n    app.run()\n</code></pre>"},{"location":"getting-started/#4-create-a-domain-model","title":"4. Create a Domain Model","text":"<p>domain/models/user.py:</p> <pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Optional\nfrom neuroglia.data.abstractions import Entity\n\n@dataclass\nclass User(Entity[str]):\n    \"\"\"User domain entity\"\"\"\n\n    id: str\n    email: str\n    first_name: str\n    last_name: str\n    is_active: bool = True\n    created_at: Optional[datetime] = None\n\n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.utcnow()\n\n    @property\n    def full_name(self) -&gt; str:\n        \"\"\"Get the user's full name\"\"\"\n        return f\"{self.first_name} {self.last_name}\"\n\n    def deactivate(self):\n        \"\"\"Deactivate the user\"\"\"\n        self.is_active = False\n</code></pre>"},{"location":"getting-started/#5-create-dtos-for-the-api","title":"5. Create DTOs for the API","text":"<p>integration/models/user_dto.py:</p> <pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Optional\n\n@dataclass\nclass UserDto:\n    \"\"\"User data transfer object\"\"\"\n\n    id: str\n    email: str\n    first_name: str\n    last_name: str\n    full_name: str\n    is_active: bool\n    created_at: Optional[datetime] = None\n\n@dataclass\nclass CreateUserDto:\n    \"\"\"DTO for creating a new user\"\"\"\n\n    email: str\n    first_name: str\n    last_name: str\n</code></pre>"},{"location":"getting-started/#6-create-commands-and-queries","title":"6. Create Commands and Queries","text":"<p>application/commands/create_user_command.py:</p> <pre><code>from dataclasses import dataclass\nfrom neuroglia.core.operation_result import OperationResult\nfrom neuroglia.mediation.mediator import Command, CommandHandler\nfrom neuroglia.mapping.mapper import Mapper, map_from\nfrom integration.models.user_dto import CreateUserDto, UserDto\nfrom domain.models.user import User\nimport uuid\n\n@map_from(CreateUserDto)\n@dataclass\nclass CreateUserCommand(Command[OperationResult[UserDto]]):\n    \"\"\"Command to create a new user\"\"\"\n\n    email: str\n    first_name: str\n    last_name: str\n\nclass CreateUserCommandHandler(CommandHandler[CreateUserCommand, OperationResult[UserDto]]):\n    \"\"\"Handler for CreateUserCommand\"\"\"\n\n    def __init__(self, mapper: Mapper):\n        self.mapper = mapper\n        # In a real app, you'd inject a repository here\n        self._users = {}  # Simple in-memory storage for demo\n\n    async def handle_async(self, command: CreateUserCommand) -&gt; OperationResult[UserDto]:\n        # Create the domain entity\n        user = User(\n            id=str(uuid.uuid4()),\n            email=command.email,\n            first_name=command.first_name,\n            last_name=command.last_name\n        )\n\n        # Store the user (in a real app, use a repository)\n        self._users[user.id] = user\n\n        # Map to DTO and return\n        user_dto = self.mapper.map(user, UserDto)\n        return self.created(user_dto)\n</code></pre> <p>application/queries/get_user_query.py:</p> <pre><code>from dataclasses import dataclass\nfrom neuroglia.core.operation_result import OperationResult\nfrom neuroglia.mediation.mediator import Query, QueryHandler\nfrom neuroglia.mapping.mapper import Mapper\nfrom integration.models.user_dto import UserDto\nfrom typing import Optional\n\n@dataclass\nclass GetUserQuery(Query[OperationResult[UserDto]]):\n    \"\"\"Query to get a user by ID\"\"\"\n\n    user_id: str\n\nclass GetUserQueryHandler(QueryHandler[GetUserQuery, OperationResult[UserDto]]):\n    \"\"\"Handler for GetUserQuery\"\"\"\n\n    def __init__(self, mapper: Mapper):\n        self.mapper = mapper\n        # In a real app, you'd inject a repository here\n        self._users = {}  # Simple in-memory storage for demo\n\n    async def handle_async(self, query: GetUserQuery) -&gt; OperationResult[UserDto]:\n        user = self._users.get(query.user_id)\n\n        if user is None:\n            return self.not_found(f\"User with ID {query.user_id} not found\")\n\n        user_dto = self.mapper.map(user, UserDto)\n        return self.ok(user_dto)\n</code></pre>"},{"location":"getting-started/#7-create-a-controller","title":"7. Create a Controller","text":"<p>api/controllers/users_controller.py:</p> <pre><code>from typing import List\nfrom fastapi import status\nfrom classy_fastapi.decorators import get, post\nfrom neuroglia.mvc.controller_base import ControllerBase\nfrom neuroglia.dependency_injection.service_provider import ServiceProviderBase\nfrom neuroglia.mapping.mapper import Mapper\nfrom neuroglia.mediation.mediator import Mediator\n\nfrom integration.models.user_dto import UserDto, CreateUserDto\nfrom application.commands.create_user_command import CreateUserCommand\nfrom application.queries.get_user_query import GetUserQuery\n\nclass UsersController(ControllerBase):\n    \"\"\"Users API controller\"\"\"\n\n    def __init__(self, service_provider: ServiceProviderBase, mapper: Mapper, mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n    @post(\"/\", response_model=UserDto, status_code=status.HTTP_201_CREATED)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        \"\"\"Create a new user\"\"\"\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @get(\"/{user_id}\", response_model=UserDto)\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        \"\"\"Get a user by ID\"\"\"\n        query = GetUserQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"getting-started/#8-configure-object-mapping","title":"8. Configure Object Mapping","text":"<p>Add mapping profiles to configure how objects are mapped between layers:</p> <p>application/mapping/user_mapping.py:</p> <pre><code>from neuroglia.mapping.mapper import Mapper\nfrom domain.models.user import User\nfrom integration.models.user_dto import UserDto\n\ndef configure_user_mapping():\n    \"\"\"Configure mapping between User and UserDto\"\"\"\n\n    # Map from User entity to UserDto\n    Mapper.create_map(User, UserDto).add_member_mapping(\n        lambda src: src.full_name, lambda dst: dst.full_name\n    )\n\n    # Map from UserDto back to User (if needed)\n    Mapper.create_map(UserDto, User)\n\n# Auto-configure when module is imported\nconfigure_user_mapping()\n</code></pre>"},{"location":"getting-started/#9-run-your-application","title":"9. Run Your Application","text":"<pre><code>cd my-app\npython src/main.py\n</code></pre> <p>Your API will be available at:</p> <ul> <li>API Documentation: http://localhost:8000/api/docs</li> <li>Create User: <code>POST http://localhost:8000/api/v1/users/</code></li> <li>Get User: <code>GET http://localhost:8000/api/v1/users/{user_id}</code></li> </ul>"},{"location":"getting-started/#testing-your-api","title":"\ud83e\uddea Testing Your API","text":"<p>Use curl or any HTTP client to test your endpoints:</p> <pre><code># Create a user\ncurl -X POST \"http://localhost:8000/api/v1/users/\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"email\": \"john.doe@example.com\",\n    \"first_name\": \"John\",\n    \"last_name\": \"Doe\"\n  }'\n\n# Get the user (replace {user_id} with the ID from the response above)\ncurl \"http://localhost:8000/api/v1/users/{user_id}\"\n</code></pre>"},{"location":"getting-started/#what-youve-learned","title":"\ud83c\udfaf What You've Learned","text":"<p>Congratulations! You've created a complete Neuroglia application that demonstrates:</p> <p>\u2705 Clean Architecture: Separation of concerns across layers \u2705 Dependency Injection: Automatic service registration and resolution \u2705 CQRS Pattern: Commands for writes, queries for reads \u2705 Object Mapping: Automatic mapping between domain models and DTOs \u2705 MVC Controllers: Clean REST API endpoints \u2705 Mediation: Decoupled request handling  </p>"},{"location":"getting-started/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<p>Now that you have a basic application running, explore these advanced features:</p> <ul> <li>Data Access: Add real repositories with MongoDB or Event Store</li> <li>Event Handling: Implement event-driven architecture with CloudEvents</li> <li>Authentication: Add security to your APIs</li> <li>Background Tasks: Process long-running tasks</li> <li>Testing: Write comprehensive tests for your application</li> </ul>"},{"location":"getting-started/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Architecture Guide - Deep dive into the framework's architecture</li> <li>Dependency Injection - Advanced DI patterns</li> <li>CQRS &amp; Mediation - Command and query patterns</li> <li>Sample Applications - Complete example applications</li> </ul>"},{"location":"features/cqrs-mediation/","title":"\ud83c\udfaf CQRS &amp; Mediation","text":"<p>Neuroglia implements Command Query Responsibility Segregation (CQRS) through a powerful mediation pattern that decouples your application logic and promotes clean separation between commands (writes) and queries (reads).</p>"},{"location":"features/cqrs-mediation/#overview","title":"\ud83c\udfad Overview","text":"<p>The mediation system provides:</p> <ul> <li>Commands: Operations that modify state</li> <li>Queries: Operations that retrieve data  </li> <li>Events: Notifications of state changes</li> <li>Handlers: Process commands, queries, and events</li> <li>Mediator: Routes requests to appropriate handlers</li> </ul>"},{"location":"features/cqrs-mediation/#core-concepts","title":"\ud83c\udfd7\ufe0f Core Concepts","text":""},{"location":"features/cqrs-mediation/#commands","title":"Commands","text":"<p>Commands represent intentions to change the system state:</p> <pre><code>from dataclasses import dataclass\nfrom neuroglia.mediation.mediator import Command\nfrom neuroglia.core.operation_result import OperationResult\n\n@dataclass\nclass CreateUserCommand(Command[OperationResult[UserDto]]):\n    \"\"\"Command to create a new user\"\"\"\n    email: str\n    first_name: str\n    last_name: str\n    password: str\n\n@dataclass\nclass UpdateUserCommand(Command[OperationResult[UserDto]]):\n    \"\"\"Command to update an existing user\"\"\"\n    user_id: str\n    first_name: str\n    last_name: str\n\n@dataclass\nclass DeactivateUserCommand(Command[OperationResult]):\n    \"\"\"Command to deactivate a user\"\"\"\n    user_id: str\n</code></pre>"},{"location":"features/cqrs-mediation/#queries","title":"Queries","text":"<p>Queries represent requests for data without side effects:</p> <pre><code>from dataclasses import dataclass\nfrom typing import List\nfrom neuroglia.mediation.mediator import Query\n\n@dataclass\nclass GetUserByIdQuery(Query[OperationResult[UserDto]]):\n    \"\"\"Query to get a user by ID\"\"\"\n    user_id: str\n\n@dataclass\nclass GetUsersByDepartmentQuery(Query[OperationResult[List[UserDto]]]):\n    \"\"\"Query to get users by department\"\"\"\n    department_id: str\n    include_inactive: bool = False\n\n@dataclass\nclass SearchUsersQuery(Query[OperationResult[List[UserDto]]]):\n    \"\"\"Query to search users\"\"\"\n    search_term: str\n    page: int = 1\n    page_size: int = 20\n</code></pre>"},{"location":"features/cqrs-mediation/#events","title":"Events","text":"<p>Events represent things that have happened in the system:</p> <pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom neuroglia.data.abstractions import DomainEvent\n\n@dataclass\nclass UserCreatedEvent(DomainEvent):\n    \"\"\"Event raised when a user is created\"\"\"\n    user_id: str\n    email: str\n    created_at: datetime\n\n@dataclass\nclass UserUpdatedEvent(DomainEvent):\n    \"\"\"Event raised when a user is updated\"\"\"\n    user_id: str\n    changes: dict\n    updated_at: datetime\n\n@dataclass\nclass UserDeactivatedEvent(DomainEvent):\n    \"\"\"Event raised when a user is deactivated\"\"\"\n    user_id: str\n    reason: str\n    deactivated_at: datetime\n</code></pre>"},{"location":"features/cqrs-mediation/#handlers","title":"\ud83c\udfaa Handlers","text":""},{"location":"features/cqrs-mediation/#command-handlers","title":"Command Handlers","text":"<p>Process commands and execute business logic:</p> <pre><code>from neuroglia.mediation.mediator import CommandHandler\nfrom neuroglia.mapping.mapper import Mapper\nfrom neuroglia.data.abstractions import Repository\n\nclass CreateUserCommandHandler(CommandHandler[CreateUserCommand, OperationResult[UserDto]]):\n    \"\"\"Handles user creation commands\"\"\"\n\n    def __init__(self, \n                 user_repository: Repository[User, str],\n                 mapper: Mapper,\n                 password_service: IPasswordService,\n                 email_service: IEmailService):\n        self.user_repository = user_repository\n        self.mapper = mapper\n        self.password_service = password_service\n        self.email_service = email_service\n\n    async def handle_async(self, command: CreateUserCommand) -&gt; OperationResult[UserDto]:\n        # Validate business rules\n        existing_user = await self.user_repository.get_by_email_async(command.email)\n        if existing_user:\n            return self.conflict(\"User with this email already exists\")\n\n        # Hash password\n        password_hash = await self.password_service.hash_password(command.password)\n\n        # Create domain entity\n        user = User.create(\n            email=command.email,\n            first_name=command.first_name,\n            last_name=command.last_name,\n            password_hash=password_hash\n        )\n\n        # Save to repository\n        saved_user = await self.user_repository.add_async(user)\n\n        # Send welcome email (side effect)\n        await self.email_service.send_welcome_email(saved_user.email)\n\n        # Map to DTO and return success\n        user_dto = self.mapper.map(saved_user, UserDto)\n        return self.created(user_dto)\n</code></pre>"},{"location":"features/cqrs-mediation/#query-handlers","title":"Query Handlers","text":"<p>Process queries and return data:</p> <pre><code>class GetUserByIdQueryHandler(QueryHandler[GetUserByIdQuery, OperationResult[UserDto]]):\n    \"\"\"Handles user lookup queries\"\"\"\n\n    def __init__(self, \n                 user_repository: Repository[User, str],\n                 mapper: Mapper):\n        self.user_repository = user_repository\n        self.mapper = mapper\n\n    async def handle_async(self, query: GetUserByIdQuery) -&gt; OperationResult[UserDto]:\n        user = await self.user_repository.get_by_id_async(query.user_id)\n\n        if user is None:\n            return self.not_found(f\"User with ID {query.user_id} not found\")\n\n        user_dto = self.mapper.map(user, UserDto)\n        return self.ok(user_dto)\n\nclass SearchUsersQueryHandler(QueryHandler[SearchUsersQuery, OperationResult[List[UserDto]]]):\n    \"\"\"Handles user search queries\"\"\"\n\n    def __init__(self, \n                 user_repository: Repository[User, str],\n                 mapper: Mapper):\n        self.user_repository = user_repository\n        self.mapper = mapper\n\n    async def handle_async(self, query: SearchUsersQuery) -&gt; OperationResult[List[UserDto]]:\n        users = await self.user_repository.search_async(\n            search_term=query.search_term,\n            page=query.page,\n            page_size=query.page_size\n        )\n\n        user_dtos = [self.mapper.map(user, UserDto) for user in users]\n        return self.ok(user_dtos)\n</code></pre>"},{"location":"features/cqrs-mediation/#event-handlers","title":"Event Handlers","text":"<p>Process events for side effects and integrations:</p> <pre><code>from neuroglia.mediation.mediator import EventHandler\n\nclass UserCreatedEventHandler(EventHandler[UserCreatedEvent]):\n    \"\"\"Handles user created events\"\"\"\n\n    def __init__(self, \n                 audit_service: IAuditService,\n                 analytics_service: IAnalyticsService):\n        self.audit_service = audit_service\n        self.analytics_service = analytics_service\n\n    async def handle_async(self, event: UserCreatedEvent):\n        # Log audit entry\n        await self.audit_service.log_user_created(event.user_id, event.created_at)\n\n        # Track analytics\n        await self.analytics_service.track_user_registration(event.user_id)\n\nclass SendWelcomeEmailHandler(EventHandler[UserCreatedEvent]):\n    \"\"\"Sends welcome email when user is created\"\"\"\n\n    def __init__(self, email_service: IEmailService):\n        self.email_service = email_service\n\n    async def handle_async(self, event: UserCreatedEvent):\n        await self.email_service.send_welcome_email(event.email)\n</code></pre>"},{"location":"features/cqrs-mediation/#mediator-usage","title":"\ud83d\ude80 Mediator Usage","text":""},{"location":"features/cqrs-mediation/#configuration","title":"Configuration","text":"<p>Configure the mediator in your application startup:</p> <pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.mediation.mediator import Mediator\n\nbuilder = WebApplicationBuilder()\n\n# Configure mediator with handler modules\nMediator.configure(builder, [\n    \"application.commands\",\n    \"application.queries\",\n    \"application.events\"\n])\n\napp = builder.build()\n</code></pre>"},{"location":"features/cqrs-mediation/#in-controllers","title":"In Controllers","text":"<p>Use the mediator in your API controllers:</p> <pre><code>from neuroglia.mvc.controller_base import ControllerBase\n\nclass UsersController(ControllerBase):\n\n    @post(\"/\", response_model=UserDto, status_code=201)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        # Map DTO to command\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n\n        # Execute through mediator\n        result = await self.mediator.execute_async(command)\n\n        # Process result and return\n        return self.process(result)\n\n    @get(\"/{user_id}\", response_model=UserDto)\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        # Create query\n        query = GetUserByIdQuery(user_id=user_id)\n\n        # Execute through mediator\n        result = await self.mediator.execute_async(query)\n\n        # Process result and return\n        return self.process(result)\n\n    @get(\"/\", response_model=List[UserDto])\n    async def search_users(self, \n                          search: str = \"\",\n                          page: int = 1,\n                          page_size: int = 20) -&gt; List[UserDto]:\n        # Create query\n        query = SearchUsersQuery(\n            search_term=search,\n            page=page,\n            page_size=page_size\n        )\n\n        # Execute through mediator\n        result = await self.mediator.execute_async(query)\n\n        # Process result and return\n        return self.process(result)\n</code></pre>"},{"location":"features/cqrs-mediation/#in-services","title":"In Services","text":"<p>Use the mediator in application services:</p> <pre><code>class UserService:\n    def __init__(self, mediator: Mediator):\n        self.mediator = mediator\n\n    async def register_user(self, registration_data: UserRegistrationData) -&gt; UserDto:\n        # Create command\n        command = CreateUserCommand(\n            email=registration_data.email,\n            first_name=registration_data.first_name,\n            last_name=registration_data.last_name,\n            password=registration_data.password\n        )\n\n        # Execute command\n        result = await self.mediator.execute_async(command)\n\n        if result.is_success:\n            return result.data\n        else:\n            raise UserRegistrationException(result.error_message)\n</code></pre>"},{"location":"features/cqrs-mediation/#advanced-patterns","title":"\ud83c\udfad Advanced Patterns","text":""},{"location":"features/cqrs-mediation/#pipeline-behaviors","title":"Pipeline Behaviors","text":"<p>Add cross-cutting concerns through pipeline behaviors:</p> <pre><code>from neuroglia.mediation.mediator import PipelineBehavior\n\nclass ValidationBehavior(PipelineBehavior):\n    \"\"\"Validates requests before processing\"\"\"\n\n    async def handle_async(self, request, next_handler):\n        # Validate request\n        if hasattr(request, 'validate'):\n            validation_result = request.validate()\n            if not validation_result.is_valid:\n                return OperationResult.validation_error(validation_result.errors)\n\n        # Continue to next behavior/handler\n        return await next_handler()\n\nclass LoggingBehavior(PipelineBehavior):\n    \"\"\"Logs requests and responses\"\"\"\n\n    def __init__(self, logger: Logger):\n        self.logger = logger\n\n    async def handle_async(self, request, next_handler):\n        request_name = type(request).__name__\n        self.logger.info(f\"Executing {request_name}\")\n\n        try:\n            result = await next_handler()\n            self.logger.info(f\"Completed {request_name}\")\n            return result\n        except Exception as ex:\n            self.logger.error(f\"Failed {request_name}: {ex}\")\n            raise\n\n# Register behaviors\nbuilder.services.add_pipeline_behavior(ValidationBehavior)\nbuilder.services.add_pipeline_behavior(LoggingBehavior)\n</code></pre>"},{"location":"features/cqrs-mediation/#transaction-behavior","title":"Transaction Behavior","text":"<p>Wrap commands in database transactions:</p> <pre><code>class TransactionBehavior(PipelineBehavior):\n    \"\"\"Wraps commands in database transactions\"\"\"\n\n    def __init__(self, unit_of_work: IUnitOfWork):\n        self.unit_of_work = unit_of_work\n\n    async def handle_async(self, request, next_handler):\n        # Only apply to commands\n        if not isinstance(request, Command):\n            return await next_handler()\n\n        async with self.unit_of_work.begin_transaction():\n            try:\n                result = await next_handler()\n                await self.unit_of_work.commit()\n                return result\n            except Exception:\n                await self.unit_of_work.rollback()\n                raise\n</code></pre>"},{"location":"features/cqrs-mediation/#caching-behavior","title":"Caching Behavior","text":"<p>Cache query results:</p> <pre><code>class CachingBehavior(PipelineBehavior):\n    \"\"\"Caches query results\"\"\"\n\n    def __init__(self, cache_service: ICacheService):\n        self.cache_service = cache_service\n\n    async def handle_async(self, request, next_handler):\n        # Only cache queries\n        if not isinstance(request, Query):\n            return await next_handler()\n\n        # Generate cache key\n        cache_key = f\"{type(request).__name__}:{hash(str(request))}\"\n\n        # Try to get from cache\n        cached_result = await self.cache_service.get_async(cache_key)\n        if cached_result:\n            return cached_result\n\n        # Execute query\n        result = await next_handler()\n\n        # Cache successful results\n        if result.is_success:\n            await self.cache_service.set_async(cache_key, result, expiry=timedelta(minutes=5))\n\n        return result\n</code></pre>"},{"location":"features/cqrs-mediation/#domain-events","title":"\ud83c\udfdb\ufe0f Domain Events","text":""},{"location":"features/cqrs-mediation/#publishing-events","title":"Publishing Events","text":"<p>Publish domain events from entities or handlers:</p> <pre><code>class User(AggregateRoot[str]):\n    def create(self, email: str, first_name: str, last_name: str):\n        # Apply business rules\n        self.email = email\n        self.first_name = first_name\n        self.last_name = last_name\n        self.created_at = datetime.utcnow()\n\n        # Raise domain event\n        self.raise_event(UserCreatedEvent(\n            user_id=self.id,\n            email=self.email,\n            created_at=self.created_at\n        ))\n\nclass CreateUserCommandHandler(CommandHandler[CreateUserCommand, OperationResult[UserDto]]):\n    async def handle_async(self, command: CreateUserCommand) -&gt; OperationResult[UserDto]:\n        # Create user (events are raised automatically)\n        user = User.create(command.email, command.first_name, command.last_name)\n\n        # Save user (this will publish the events)\n        await self.user_repository.add_async(user)\n\n        return self.created(self.mapper.map(user, UserDto))\n</code></pre>"},{"location":"features/cqrs-mediation/#event-dispatching","title":"Event Dispatching","text":"<p>Events are automatically dispatched to registered handlers:</p> <pre><code># Multiple handlers can listen to the same event\nclass UserCreatedEventHandler(EventHandler[UserCreatedEvent]):\n    async def handle_async(self, event: UserCreatedEvent):\n        # Handle audit logging\n        pass\n\nclass WelcomeEmailHandler(EventHandler[UserCreatedEvent]):\n    async def handle_async(self, event: UserCreatedEvent):\n        # Send welcome email\n        pass\n\nclass AnalyticsHandler(EventHandler[UserCreatedEvent]):\n    async def handle_async(self, event: UserCreatedEvent):\n        # Track user registration\n        pass\n</code></pre>"},{"location":"features/cqrs-mediation/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"features/cqrs-mediation/#testing-handlers","title":"Testing Handlers","text":"<p>Test handlers in isolation:</p> <pre><code>import pytest\nfrom unittest.mock import Mock\n\n@pytest.mark.asyncio\nasync def test_create_user_command_handler():\n    # Arrange\n    mock_repository = Mock()\n    mock_mapper = Mock()\n    mock_password_service = Mock()\n    mock_email_service = Mock()\n\n    handler = CreateUserCommandHandler(\n        mock_repository, \n        mock_mapper, \n        mock_password_service,\n        mock_email_service\n    )\n\n    command = CreateUserCommand(\n        email=\"test@example.com\",\n        first_name=\"John\",\n        last_name=\"Doe\",\n        password=\"password123\"\n    )\n\n    # Configure mocks\n    mock_repository.get_by_email_async.return_value = None\n    mock_password_service.hash_password.return_value = \"hashed_password\"\n    mock_repository.add_async.return_value = test_user\n    mock_mapper.map.return_value = test_user_dto\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n    assert result.data == test_user_dto\n    mock_repository.add_async.assert_called_once()\n    mock_email_service.send_welcome_email.assert_called_once()\n</code></pre>"},{"location":"features/cqrs-mediation/#integration-testing","title":"Integration Testing","text":"<p>Test the complete flow through the mediator:</p> <pre><code>@pytest.mark.asyncio\nasync def test_user_creation_flow():\n    # Arrange\n    test_client = TestClient(app)\n\n    user_data = {\n        \"email\": \"test@example.com\",\n        \"first_name\": \"John\",\n        \"last_name\": \"Doe\",\n        \"password\": \"password123\"\n    }\n\n    # Act\n    response = test_client.post(\"/api/v1/users\", json=user_data)\n\n    # Assert\n    assert response.status_code == 201\n\n    created_user = response.json()\n    assert created_user[\"email\"] == user_data[\"email\"]\n    assert created_user[\"first_name\"] == user_data[\"first_name\"]\n\n    # Verify user was actually created\n    get_response = test_client.get(f\"/api/v1/users/{created_user['id']}\")\n    assert get_response.status_code == 200\n</code></pre>"},{"location":"features/cqrs-mediation/#best-practices","title":"\ud83d\ude80 Best Practices","text":""},{"location":"features/cqrs-mediation/#1-single-responsibility","title":"1. Single Responsibility","text":"<p>Each command/query should have a single, well-defined purpose:</p> <pre><code># Good - Single responsibility\nclass CreateUserCommand: pass\nclass UpdateUserEmailCommand: pass\nclass DeactivateUserCommand: pass\n\n# Avoid - Multiple responsibilities\nclass ManageUserCommand: pass  # Too broad\n</code></pre>"},{"location":"features/cqrs-mediation/#2-immutable-requests","title":"2. Immutable Requests","text":"<p>Make commands and queries immutable:</p> <pre><code># Good - Immutable\n@dataclass(frozen=True)\nclass CreateUserCommand:\n    email: str\n    first_name: str\n    last_name: str\n\n# Avoid - Mutable\nclass CreateUserCommand:\n    def __init__(self):\n        self.email = None\n        self.first_name = None\n</code></pre>"},{"location":"features/cqrs-mediation/#3-rich-domain-models","title":"3. Rich Domain Models","text":"<p>Use domain events to decouple side effects:</p> <pre><code># Good - Domain events\nclass User:\n    def activate(self):\n        self.is_active = True\n        self.raise_event(UserActivatedEvent(self.id))\n\n# Avoid - Direct coupling\nclass User:\n    def activate(self, email_service: IEmailService):\n        self.is_active = True\n        email_service.send_activation_email(self.email)  # Tight coupling\n</code></pre>"},{"location":"features/cqrs-mediation/#4-validation","title":"4. Validation","text":"<p>Validate inputs at the right level:</p> <pre><code># Domain validation (business rules)\nclass CreateUserCommand:\n    def validate(self) -&gt; ValidationResult:\n        errors = []\n        if not self.email or '@' not in self.email:\n            errors.append(\"Valid email is required\")\n        return ValidationResult(errors)\n\n# Input validation (format/required fields)\nclass CreateUserDto:\n    email: str = Field(..., regex=r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$')\n    first_name: str = Field(..., min_length=1, max_length=50)\n</code></pre>"},{"location":"features/cqrs-mediation/#5-error-handling","title":"5. Error Handling","text":"<p>Use consistent error handling patterns:</p> <pre><code>class CreateUserCommandHandler(CommandHandler):\n    async def handle_async(self, command: CreateUserCommand) -&gt; OperationResult[UserDto]:\n        try:\n            # Business logic\n            user = await self.create_user(command)\n            return self.created(user)\n\n        except EmailAlreadyExistsException:\n            return self.conflict(\"Email already exists\")\n        except InvalidEmailException:\n            return self.bad_request(\"Invalid email format\")\n        except Exception as ex:\n            return self.internal_error(f\"Failed to create user: {ex}\")\n</code></pre>"},{"location":"features/cqrs-mediation/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Basic CQRS usage</li> <li>Architecture Guide - How CQRS fits in the architecture</li> <li>Dependency Injection - DI with handlers</li> <li>Data Access - Repositories and units of work</li> <li>Event Handling - Domain events and integration events</li> </ul>"},{"location":"features/data-access/","title":"\ud83d\uddc4\ufe0f Data Access","text":"<p>Neuroglia provides a flexible data access layer that supports multiple storage backends through a unified repository pattern. It includes built-in support for MongoDB, Event Store, and in-memory repositories, with extensibility for other data stores.</p>"},{"location":"features/data-access/#overview","title":"\ud83c\udfaf Overview","text":"<p>The data access system provides:</p> <ul> <li>Repository Pattern: Unified interface for data operations</li> <li>Multiple Storage Backends: MongoDB, Event Store, in-memory, and custom implementations</li> <li>Event Sourcing: Complete event sourcing support with EventStoreDB</li> <li>CQRS Support: Separate read and write models</li> <li>Query Abstractions: Flexible querying capabilities</li> <li>Unit of Work: Transaction management across repositories</li> </ul>"},{"location":"features/data-access/#core-abstractions","title":"\ud83c\udfd7\ufe0f Core Abstractions","text":""},{"location":"features/data-access/#repository-interface","title":"Repository Interface","text":"<p>The base repository interface defines standard CRUD operations:</p> <pre><code>from abc import ABC, abstractmethod\nfrom typing import Generic, TypeVar, List, Optional\n\nTEntity = TypeVar('TEntity')\nTKey = TypeVar('TKey')\n\nclass Repository(Generic[TEntity, TKey], ABC):\n    \"\"\"Base repository interface\"\"\"\n\n    @abstractmethod\n    async def get_by_id_async(self, id: TKey) -&gt; Optional[TEntity]:\n        \"\"\"Get entity by ID\"\"\"\n        pass\n\n    @abstractmethod\n    async def add_async(self, entity: TEntity) -&gt; TEntity:\n        \"\"\"Add new entity\"\"\"\n        pass\n\n    @abstractmethod\n    async def update_async(self, entity: TEntity) -&gt; TEntity:\n        \"\"\"Update existing entity\"\"\"\n        pass\n\n    @abstractmethod\n    async def remove_async(self, entity: TEntity):\n        \"\"\"Remove entity\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_async(self, predicate) -&gt; List[TEntity]:\n        \"\"\"Find entities matching predicate\"\"\"\n        pass\n</code></pre>"},{"location":"features/data-access/#queryable-interface","title":"Queryable Interface","text":"<p>For advanced querying capabilities:</p> <pre><code>from neuroglia.data.abstractions import Queryable\n\nclass ExtendedRepository(Repository[TEntity, TKey], Queryable[TEntity]):\n    \"\"\"Repository with advanced querying\"\"\"\n\n    async def where(self, predicate) -&gt; 'ExtendedRepository[TEntity, TKey]':\n        \"\"\"Filter entities\"\"\"\n        pass\n\n    async def order_by(self, selector) -&gt; 'ExtendedRepository[TEntity, TKey]':\n        \"\"\"Order entities\"\"\"\n        pass\n\n    async def take(self, count: int) -&gt; 'ExtendedRepository[TEntity, TKey]':\n        \"\"\"Take specified number of entities\"\"\"\n        pass\n</code></pre>"},{"location":"features/data-access/#mongodb-integration","title":"\ud83d\uddc3\ufe0f MongoDB Integration","text":""},{"location":"features/data-access/#mongodb-repository","title":"MongoDB Repository","text":"<p>Built-in MongoDB repository implementation:</p> <pre><code>from neuroglia.data.infrastructure.mongo import MongoRepository\nfrom motor.motor_asyncio import AsyncIOMotorClient\n\nclass UserRepository(MongoRepository[User, str]):\n    \"\"\"MongoDB repository for users\"\"\"\n\n    def __init__(self, connection_string: str, database_name: str):\n        super().__init__(connection_string, database_name, \"users\")\n\n    async def get_by_email_async(self, email: str) -&gt; Optional[User]:\n        \"\"\"Custom method to find user by email\"\"\"\n        filter_dict = {\"email\": email}\n        document = await self.collection.find_one(filter_dict)\n\n        if document is None:\n            return None\n\n        return self._map_document_to_entity(document)\n\n    async def find_by_department_async(self, department: str) -&gt; List[User]:\n        \"\"\"Find users by department\"\"\"\n        filter_dict = {\"department\": department}\n        cursor = self.collection.find(filter_dict)\n\n        users = []\n        async for document in cursor:\n            users.append(self._map_document_to_entity(document))\n\n        return users\n</code></pre>"},{"location":"features/data-access/#configuration","title":"Configuration","text":"<p>Configure MongoDB repositories in your application:</p> <pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.hosting.configuration.data_access_layer import DataAccessLayer\n\nbuilder = WebApplicationBuilder()\n\n# Configure MongoDB repositories for read models\nDataAccessLayer.ReadModel.configure(\n    builder,\n    [\"integration.models\"],  # Modules containing DTOs\n    lambda builder_, entity_type, key_type: MongoRepository.configure(\n        builder_, entity_type, key_type, \"myapp_db\"\n    )\n)\n\napp = builder.build()\n</code></pre>"},{"location":"features/data-access/#event-sourcing","title":"\ud83d\udcc5 Event Sourcing","text":""},{"location":"features/data-access/#event-store-repository","title":"Event Store Repository","text":"<p>For event-sourced aggregates:</p> <pre><code>from neuroglia.data.infrastructure.event_sourcing import EventSourcingRepository\nfrom neuroglia.data.abstractions import AggregateRoot\n\nclass Person(AggregateRoot[str]):\n    \"\"\"Event-sourced person aggregate\"\"\"\n\n    def __init__(self, id: str = None):\n        super().__init__(id)\n        self.state = PersonState()\n\n    def register(self, first_name: str, last_name: str, email: str):\n        \"\"\"Register a new person\"\"\"\n        self.apply(PersonRegisteredEvent(\n            person_id=self.id,\n            first_name=first_name,\n            last_name=last_name,\n            email=email\n        ))\n\n    def change_email(self, new_email: str):\n        \"\"\"Change person's email\"\"\"\n        self.apply(PersonEmailChangedEvent(\n            person_id=self.id,\n            old_email=self.state.email,\n            new_email=new_email\n        ))\n\n    # Event handlers\n    def on_person_registered(self, event: PersonRegisteredEvent):\n        self.state.id = event.person_id\n        self.state.first_name = event.first_name\n        self.state.last_name = event.last_name\n        self.state.email = event.email\n\n    def on_person_email_changed(self, event: PersonEmailChangedEvent):\n        self.state.email = event.new_email\n</code></pre>"},{"location":"features/data-access/#event-store-configuration","title":"Event Store Configuration","text":"<p>Configure EventStoreDB integration:</p> <pre><code>from neuroglia.data.infrastructure.event_sourcing.event_store import ESEventStore\nfrom neuroglia.data.infrastructure.event_sourcing.abstractions import EventStoreOptions\n\n# Configure EventStore\nbuilder = WebApplicationBuilder()\n\nESEventStore.configure(\n    builder,\n    EventStoreOptions(\n        database_name=\"myapp\",\n        consumer_group=\"myapp_consumers\"\n    )\n)\n\n# Configure event sourcing repositories for write models\nDataAccessLayer.WriteModel.configure(\n    builder,\n    [\"domain.models\"],  # Modules containing aggregates\n    lambda builder_, entity_type, key_type: EventSourcingRepository.configure(\n        builder_, entity_type, key_type\n    )\n)\n</code></pre>"},{"location":"features/data-access/#in-memory-repository","title":"\ud83d\udcbe In-Memory Repository","text":"<p>For testing and development:</p> <pre><code>from neuroglia.data.infrastructure.memory import MemoryRepository\n\nclass InMemoryUserRepository(MemoryRepository[User, str]):\n    \"\"\"In-memory repository for testing\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self._users_by_email = {}\n\n    async def add_async(self, user: User) -&gt; User:\n        \"\"\"Add user and index by email\"\"\"\n        result = await super().add_async(user)\n        self._users_by_email[user.email] = user\n        return result\n\n    async def get_by_email_async(self, email: str) -&gt; Optional[User]:\n        \"\"\"Get user by email\"\"\"\n        return self._users_by_email.get(email)\n\n    async def remove_async(self, user: User):\n        \"\"\"Remove user and clean up email index\"\"\"\n        await super().remove_async(user)\n        if user.email in self._users_by_email:\n            del self._users_by_email[user.email]\n</code></pre>"},{"location":"features/data-access/#cqrs-with-separate-models","title":"\ud83d\udd04 CQRS with Separate Models","text":""},{"location":"features/data-access/#write-model-commands","title":"Write Model (Commands)","text":"<p>Use event-sourced aggregates for write operations:</p> <pre><code>class CreateUserCommandHandler(CommandHandler[CreateUserCommand, OperationResult[UserDto]]):\n    \"\"\"Handles user creation commands\"\"\"\n\n    def __init__(self, \n                 user_repository: Repository[User, str],  # Event-sourced repository\n                 mapper: Mapper):\n        self.user_repository = user_repository\n        self.mapper = mapper\n\n    async def handle_async(self, command: CreateUserCommand) -&gt; OperationResult[UserDto]:\n        # Create aggregate\n        user = User(str(uuid.uuid4()))\n        user.register(command.first_name, command.last_name, command.email)\n\n        # Save to event store\n        saved_user = await self.user_repository.add_async(user)\n\n        # Return DTO\n        user_dto = self.mapper.map(saved_user.state, UserDto)\n        return self.created(user_dto)\n</code></pre>"},{"location":"features/data-access/#read-model-queries","title":"Read Model (Queries)","text":"<p>Use optimized read models for queries:</p> <pre><code>@dataclass\nclass UserReadModel:\n    \"\"\"Optimized read model for user queries\"\"\"\n    id: str\n    first_name: str\n    last_name: str\n    email: str\n    full_name: str\n    department: str\n    created_at: datetime\n    is_active: bool\n\nclass GetUsersQueryHandler(QueryHandler[GetUsersQuery, OperationResult[List[UserDto]]]):\n    \"\"\"Handles user queries using read model\"\"\"\n\n    def __init__(self, \n                 read_model_repository: Repository[UserReadModel, str]):\n        self.read_model_repository = read_model_repository\n\n    async def handle_async(self, query: GetUsersQuery) -&gt; OperationResult[List[UserDto]]:\n        # Query optimized read model\n        users = await self.read_model_repository.find_async(\n            lambda u: u.department == query.department if query.department else True\n        )\n\n        # Map to DTOs\n        user_dtos = [self._map_to_dto(user) for user in users]\n        return self.ok(user_dtos)\n</code></pre>"},{"location":"features/data-access/#custom-repository-implementation","title":"\ud83c\udfed Custom Repository Implementation","text":""},{"location":"features/data-access/#creating-custom-repository","title":"Creating Custom Repository","text":"<p>Implement the repository interface for custom data stores:</p> <pre><code>import aioredis\nfrom typing import Optional, List\n\nclass RedisUserRepository(Repository[User, str]):\n    \"\"\"Redis-based user repository\"\"\"\n\n    def __init__(self, redis_url: str):\n        self.redis_url = redis_url\n        self._redis = None\n\n    async def _get_redis(self):\n        \"\"\"Get Redis connection\"\"\"\n        if self._redis is None:\n            self._redis = await aioredis.from_url(self.redis_url)\n        return self._redis\n\n    async def get_by_id_async(self, user_id: str) -&gt; Optional[User]:\n        \"\"\"Get user from Redis\"\"\"\n        redis = await self._get_redis()\n        data = await redis.get(f\"user:{user_id}\")\n\n        if data is None:\n            return None\n\n        return self._deserialize_user(data)\n\n    async def add_async(self, user: User) -&gt; User:\n        \"\"\"Add user to Redis\"\"\"\n        redis = await self._get_redis()\n        data = self._serialize_user(user)\n        await redis.set(f\"user:{user.id}\", data)\n\n        # Add to email index\n        await redis.set(f\"user:email:{user.email}\", user.id)\n\n        return user\n\n    async def update_async(self, user: User) -&gt; User:\n        \"\"\"Update user in Redis\"\"\"\n        return await self.add_async(user)  # Redis is key-value, so update = set\n\n    async def remove_async(self, user: User):\n        \"\"\"Remove user from Redis\"\"\"\n        redis = await self._get_redis()\n        await redis.delete(f\"user:{user.id}\")\n        await redis.delete(f\"user:email:{user.email}\")\n\n    async def find_async(self, predicate) -&gt; List[User]:\n        \"\"\"Find users (basic implementation)\"\"\"\n        redis = await self._get_redis()\n        keys = await redis.keys(\"user:*\")\n\n        users = []\n        for key in keys:\n            if not key.startswith(\"user:email:\"):\n                data = await redis.get(key)\n                user = self._deserialize_user(data)\n                if predicate(user):\n                    users.append(user)\n\n        return users\n\n    def _serialize_user(self, user: User) -&gt; str:\n        \"\"\"Serialize user to JSON\"\"\"\n        import json\n        return json.dumps({\n            'id': user.id,\n            'first_name': user.first_name,\n            'last_name': user.last_name,\n            'email': user.email\n        })\n\n    def _deserialize_user(self, data: str) -&gt; User:\n        \"\"\"Deserialize user from JSON\"\"\"\n        import json\n        user_data = json.loads(data)\n        return User(\n            id=user_data['id'],\n            first_name=user_data['first_name'],\n            last_name=user_data['last_name'],\n            email=user_data['email']\n        )\n</code></pre>"},{"location":"features/data-access/#unit-of-work-pattern","title":"\ud83d\udd04 Unit of Work Pattern","text":"<p>For transaction management across multiple repositories:</p> <pre><code>from abc import ABC, abstractmethod\nfrom contextlib import asynccontextmanager\n\nclass IUnitOfWork(ABC):\n    \"\"\"Unit of work interface\"\"\"\n\n    @property\n    @abstractmethod\n    def users(self) -&gt; Repository[User, str]:\n        pass\n\n    @property\n    @abstractmethod\n    def orders(self) -&gt; Repository[Order, str]:\n        pass\n\n    @abstractmethod\n    async def commit_async(self):\n        \"\"\"Commit all changes\"\"\"\n        pass\n\n    @abstractmethod\n    async def rollback_async(self):\n        \"\"\"Rollback all changes\"\"\"\n        pass\n\n    @asynccontextmanager\n    async def transaction(self):\n        \"\"\"Context manager for transactions\"\"\"\n        try:\n            yield self\n            await self.commit_async()\n        except Exception:\n            await self.rollback_async()\n            raise\n\nclass MongoUnitOfWork(IUnitOfWork):\n    \"\"\"MongoDB implementation of unit of work\"\"\"\n\n    def __init__(self, client: AsyncIOMotorClient, database_name: str):\n        self.client = client\n        self.database_name = database_name\n        self.session = None\n        self._users = None\n        self._orders = None\n\n    @property\n    def users(self) -&gt; Repository[User, str]:\n        if self._users is None:\n            self._users = MongoUserRepository(self.client, self.database_name, self.session)\n        return self._users\n\n    @property\n    def orders(self) -&gt; Repository[Order, str]:\n        if self._orders is None:\n            self._orders = MongoOrderRepository(self.client, self.database_name, self.session)\n        return self._orders\n\n    async def commit_async(self):\n        \"\"\"Commit transaction\"\"\"\n        if self.session:\n            await self.session.commit_transaction()\n\n    async def rollback_async(self):\n        \"\"\"Rollback transaction\"\"\"\n        if self.session:\n            await self.session.abort_transaction()\n\n    @asynccontextmanager\n    async def transaction(self):\n        \"\"\"Start a MongoDB transaction\"\"\"\n        async with await self.client.start_session() as session:\n            self.session = session\n            async with session.start_transaction():\n                try:\n                    yield self\n                    await session.commit_transaction()\n                except Exception:\n                    await session.abort_transaction()\n                    raise\n                finally:\n                    self.session = None\n\n# Usage in command handler\nclass ProcessOrderCommandHandler(CommandHandler[ProcessOrderCommand, OperationResult]):\n    def __init__(self, unit_of_work: IUnitOfWork):\n        self.unit_of_work = unit_of_work\n\n    async def handle_async(self, command: ProcessOrderCommand) -&gt; OperationResult:\n        async with self.unit_of_work.transaction():\n            # Get user\n            user = await self.unit_of_work.users.get_by_id_async(command.user_id)\n            if user is None:\n                return self.not_found(\"User not found\")\n\n            # Create order\n            order = Order.create(command.items, user.id)\n            await self.unit_of_work.orders.add_async(order)\n\n            # Update user stats\n            user.increment_order_count()\n            await self.unit_of_work.users.update_async(user)\n\n            # Transaction commits automatically\n            return self.ok()\n</code></pre>"},{"location":"features/data-access/#testing-with-repositories","title":"\ud83e\uddea Testing with Repositories","text":""},{"location":"features/data-access/#test-doubles","title":"Test Doubles","text":"<p>Use in-memory repositories for testing:</p> <pre><code>import pytest\nfrom unittest.mock import Mock\n\n@pytest.fixture\ndef user_repository():\n    \"\"\"In-memory user repository for testing\"\"\"\n    return InMemoryUserRepository()\n\n@pytest.mark.asyncio\nasync def test_create_user_command(user_repository):\n    # Arrange\n    mapper = Mock()\n    mapper.map.return_value = test_user_dto\n\n    handler = CreateUserCommandHandler(user_repository, mapper)\n    command = CreateUserCommand(\"John\", \"Doe\", \"john@example.com\")\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n\n    # Verify user was saved\n    saved_user = await user_repository.get_by_id_async(result.data.id)\n    assert saved_user is not None\n    assert saved_user.email == \"john@example.com\"\n</code></pre>"},{"location":"features/data-access/#integration-testing","title":"Integration Testing","text":"<p>Test with real databases:</p> <pre><code>import pytest\nimport motor.motor_asyncio\nfrom testcontainers.mongodb import MongoDbContainer\n\n@pytest.fixture(scope=\"session\")\nasync def mongodb_container():\n    \"\"\"Start MongoDB container for testing\"\"\"\n    with MongoDbContainer() as container:\n        yield container\n\n@pytest.fixture\nasync def mongo_repository(mongodb_container):\n    \"\"\"MongoDB repository for integration testing\"\"\"\n    connection_string = mongodb_container.get_connection_url()\n    return MongoUserRepository(connection_string, \"test_db\")\n\n@pytest.mark.asyncio\nasync def test_user_repository_integration(mongo_repository):\n    # Arrange\n    user = User(\"test-id\", \"John\", \"Doe\", \"john@test.com\")\n\n    # Act\n    saved_user = await mongo_repository.add_async(user)\n    retrieved_user = await mongo_repository.get_by_id_async(user.id)\n\n    # Assert\n    assert saved_user.id == user.id\n    assert retrieved_user is not None\n    assert retrieved_user.email == user.email\n</code></pre>"},{"location":"features/data-access/#best-practices","title":"\ud83d\ude80 Best Practices","text":""},{"location":"features/data-access/#1-use-interface-segregation","title":"1. Use Interface Segregation","text":"<p>Define specific repository interfaces for different use cases:</p> <pre><code># Good - Specific interfaces\nclass IUserReadRepository(ABC):\n    async def get_by_email_async(self, email: str) -&gt; Optional[UserDto]:\n        pass\n\n    async def search_async(self, criteria: UserSearchCriteria) -&gt; List[UserDto]:\n        pass\n\nclass IUserWriteRepository(ABC):\n    async def add_async(self, user: User) -&gt; User:\n        pass\n\n    async def update_async(self, user: User) -&gt; User:\n        pass\n\n# Avoid - Generic repository for everything\nclass IGenericUserRepository(Repository[User, str]):\n    # Too broad, mixes read and write concerns\n    pass\n</code></pre>"},{"location":"features/data-access/#2-separate-read-and-write-models","title":"2. Separate Read and Write Models","text":"<p>Use different models for commands and queries:</p> <pre><code># Write model (domain entity)\nclass User(AggregateRoot[str]):\n    # Rich domain model with behavior\n    def change_email(self, new_email: str):\n        # Business logic and validation\n        pass\n\n# Read model (DTO)\n@dataclass\nclass UserListDto:\n    # Optimized for display\n    id: str\n    display_name: str\n    email: str\n    last_login: datetime\n    status: str\n</code></pre>"},{"location":"features/data-access/#3-handle-concurrency","title":"3. Handle Concurrency","text":"<p>Implement optimistic concurrency for event-sourced aggregates:</p> <pre><code>class User(AggregateRoot[str]):\n    def __init__(self, id: str = None):\n        super().__init__(id)\n        self.version = 0  # Concurrency token\n\n    def apply_event(self, event: DomainEvent):\n        super().apply_event(event)\n        self.version += 1\n\nclass EventSourcingRepository(Repository[User, str]):\n    async def update_async(self, user: User) -&gt; User:\n        # Check for concurrent modifications\n        current_version = await self.get_version(user.id)\n        if current_version != user.original_version:\n            raise ConcurrencyException(\"Entity was modified by another process\")\n\n        # Save events\n        await self.save_events(user.uncommitted_events, user.version)\n        return user\n</code></pre>"},{"location":"features/data-access/#4-use-specifications-pattern","title":"4. Use Specifications Pattern","text":"<p>For complex queries:</p> <pre><code>from abc import ABC, abstractmethod\n\nclass Specification(ABC):\n    @abstractmethod\n    def is_satisfied_by(self, entity) -&gt; bool:\n        pass\n\n    def and_(self, other: 'Specification') -&gt; 'Specification':\n        return AndSpecification(self, other)\n\n    def or_(self, other: 'Specification') -&gt; 'Specification':\n        return OrSpecification(self, other)\n\nclass ActiveUserSpecification(Specification):\n    def is_satisfied_by(self, user: User) -&gt; bool:\n        return user.is_active\n\nclass UserInDepartmentSpecification(Specification):\n    def __init__(self, department: str):\n        self.department = department\n\n    def is_satisfied_by(self, user: User) -&gt; bool:\n        return user.department == self.department\n\n# Usage\nactive_engineering_users = ActiveUserSpecification().and_(\n    UserInDepartmentSpecification(\"Engineering\")\n)\n\nusers = await repository.find_async(active_engineering_users.is_satisfied_by)\n</code></pre>"},{"location":"features/data-access/#5-repository-registration","title":"5. Repository Registration","text":"<p>Register repositories properly in DI container:</p> <pre><code># In application startup\nbuilder = WebApplicationBuilder()\n\n# Register by interface\nbuilder.services.add_scoped(IUserRepository, MongoUserRepository)\nbuilder.services.add_scoped(IOrderRepository, EventSourcedOrderRepository)\n\n# Register factory for complex initialization\ndef create_user_repository(provider: ServiceProviderBase) -&gt; IUserRepository:\n    config = provider.get_required_service(DatabaseConfig)\n    if config.use_event_sourcing:\n        return EventSourcedUserRepository(config.event_store_connection)\n    else:\n        return MongoUserRepository(config.mongo_connection, config.database_name)\n\nbuilder.services.add_scoped(IUserRepository, factory=create_user_repository)\n</code></pre>"},{"location":"features/data-access/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Basic repository usage</li> <li>Architecture Guide - How repositories fit in the architecture</li> <li>CQRS &amp; Mediation - Using repositories with CQRS</li> <li>Event Sourcing - Event sourcing with repositories</li> <li>Dependency Injection - DI with repositories</li> </ul>"},{"location":"features/dependency-injection/","title":"\ud83d\udc89 Dependency Injection","text":"<p>Neuroglia provides a lightweight, powerful dependency injection (DI) container that manages service registration, lifetime, and resolution. The DI system supports automatic service discovery and follows common DI patterns.</p>"},{"location":"features/dependency-injection/#overview","title":"\ud83c\udfaf Overview","text":"<p>The dependency injection system consists of:</p> <ul> <li>ServiceCollection: Registry for service definitions</li> <li>ServiceProvider: Container for resolving and managing services</li> <li>ServiceLifetime: Controls when services are created and disposed</li> <li>Automatic Discovery: Services can be automatically discovered and registered</li> </ul>"},{"location":"features/dependency-injection/#service-lifetimes","title":"\ud83c\udfd7\ufe0f Service Lifetimes","text":""},{"location":"features/dependency-injection/#singleton","title":"Singleton","text":"<p>Created once and reused for the entire application lifetime:</p> <pre><code>from neuroglia.dependency_injection.service_provider import ServiceCollection\n\nservices = ServiceCollection()\nservices.add_singleton(DatabaseConnection)\nservices.add_singleton(CacheService)\n</code></pre> <p>Use Cases:</p> <ul> <li>Database connections</li> <li>Configuration services</li> <li>Caching services</li> <li>Application-wide state</li> </ul>"},{"location":"features/dependency-injection/#scoped","title":"Scoped","text":"<p>Created once per scope (typically per HTTP request):</p> <pre><code>services.add_scoped(UserRepository)\nservices.add_scoped(OrderService)\n</code></pre> <p>Use Cases:</p> <ul> <li>Repositories</li> <li>Unit of Work</li> <li>Request-specific services</li> <li>Database contexts</li> </ul>"},{"location":"features/dependency-injection/#transient","title":"Transient","text":"<p>Created each time they are requested:</p> <pre><code>services.add_transient(EmailService)\nservices.add_transient(CalculationService)\n</code></pre> <p>Use Cases:</p> <ul> <li>Stateless services</li> <li>Lightweight operations</li> <li>Services with short lifecycles</li> </ul>"},{"location":"features/dependency-injection/#registration-patterns","title":"\ud83d\udd27 Registration Patterns","text":""},{"location":"features/dependency-injection/#interface-and-implementation","title":"Interface and Implementation","text":"<p>Register services by interface and implementation:</p> <pre><code>from abc import ABC, abstractmethod\n\nclass IUserRepository(ABC):\n    @abstractmethod\n    async def get_by_id(self, user_id: str) -&gt; User:\n        pass\n\nclass MongoUserRepository(IUserRepository):\n    async def get_by_id(self, user_id: str) -&gt; User:\n        # MongoDB implementation\n        pass\n\n# Registration\nservices.add_scoped(IUserRepository, MongoUserRepository)\n</code></pre>"},{"location":"features/dependency-injection/#factory-functions","title":"Factory Functions","text":"<p>Use factory functions for complex initialization:</p> <pre><code>def create_database_connection() -&gt; DatabaseConnection:\n    connection_string = get_connection_string()\n    return DatabaseConnection(connection_string)\n\nservices.add_singleton(DatabaseConnection, factory=create_database_connection)\n</code></pre>"},{"location":"features/dependency-injection/#generic-services","title":"Generic Services","text":"<p>Register generic services with type parameters:</p> <pre><code>from typing import TypeVar, Generic\n\nT = TypeVar('T')\n\nclass Repository(Generic[T]):\n    def __init__(self, db_context: DbContext):\n        self.db_context = db_context\n\n# Registration\nservices.add_scoped(Repository[User])\nservices.add_scoped(Repository[Order])\n</code></pre>"},{"location":"features/dependency-injection/#automatic-discovery","title":"\ud83d\udd0d Automatic Discovery","text":"<p>Neuroglia can automatically discover and register services based on conventions:</p>"},{"location":"features/dependency-injection/#module-based-discovery","title":"Module-Based Discovery","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\n\nbuilder = WebApplicationBuilder()\n\n# Automatically discover and register services in modules\nbuilder.services.discover_services([\n    \"application.services\",\n    \"integration.repositories\",\n    \"domain.services\"\n])\n</code></pre>"},{"location":"features/dependency-injection/#attribute-based-registration","title":"Attribute-Based Registration","text":"<p>Use decorators to mark services for automatic registration:</p> <pre><code>from neuroglia.dependency_injection import service\n\n@service(lifetime=ServiceLifetime.SCOPED)\nclass UserService:\n    def __init__(self, user_repository: IUserRepository):\n        self.user_repository = user_repository\n\n@service(interface=IUserRepository, lifetime=ServiceLifetime.SCOPED)\nclass MongoUserRepository(IUserRepository):\n    def __init__(self, db_context: MongoContext):\n        self.db_context = db_context\n</code></pre>"},{"location":"features/dependency-injection/#service-resolution","title":"\ud83d\udd04 Service Resolution","text":""},{"location":"features/dependency-injection/#manual-resolution","title":"Manual Resolution","text":"<pre><code># Build the service provider\nprovider = services.build_service_provider()\n\n# Resolve services\nuser_service = provider.get_required_service(UserService)\nuser_repo = provider.get_service(IUserRepository)  # Returns None if not registered\nall_repos = provider.get_services(IRepository)  # Returns all implementations\n</code></pre>"},{"location":"features/dependency-injection/#constructor-injection","title":"Constructor Injection","text":"<p>Services are automatically injected into constructors:</p> <pre><code>class UserController(ControllerBase):\n    def __init__(self, \n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator,\n                 user_service: UserService):  # Automatically injected\n        super().__init__(service_provider, mapper, mediator)\n        self.user_service = user_service\n</code></pre>"},{"location":"features/dependency-injection/#property-injection","title":"Property Injection","text":"<p>Access services through the service provider:</p> <pre><code>class UserService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.service_provider = service_provider\n\n    def get_email_service(self) -&gt; EmailService:\n        return self.service_provider.get_required_service(EmailService)\n</code></pre>"},{"location":"features/dependency-injection/#advanced-patterns","title":"\ud83c\udfad Advanced Patterns","text":""},{"location":"features/dependency-injection/#service-locator-pattern","title":"Service Locator Pattern","text":"<pre><code>class ServiceLocator:\n    _provider: ServiceProviderBase = None\n\n    @classmethod\n    def configure(cls, provider: ServiceProviderBase):\n        cls._provider = provider\n\n    @classmethod\n    def get_service(cls, service_type: Type[T]) -&gt; T:\n        return cls._provider.get_required_service(service_type)\n\n# Usage\nemail_service = ServiceLocator.get_service(EmailService)\n</code></pre>"},{"location":"features/dependency-injection/#conditional-registration","title":"Conditional Registration","text":"<p>Register services based on conditions:</p> <pre><code>if app_settings.use_redis_cache:\n    services.add_singleton(ICacheService, RedisCacheService)\nelse:\n    services.add_singleton(ICacheService, MemoryCacheService)\n</code></pre>"},{"location":"features/dependency-injection/#decorated-services","title":"Decorated Services","text":"<p>Wrap services with additional behavior:</p> <pre><code>class LoggingUserService(IUserService):\n    def __init__(self, inner: IUserService, logger: Logger):\n        self.inner = inner\n        self.logger = logger\n\n    async def create_user(self, user_data: UserData) -&gt; User:\n        self.logger.info(f\"Creating user: {user_data.email}\")\n        result = await self.inner.create_user(user_data)\n        self.logger.info(f\"User created: {result.id}\")\n        return result\n\n# Registration with decoration\nservices.add_scoped(IUserService, UserService)\nservices.decorate(IUserService, LoggingUserService)\n</code></pre>"},{"location":"features/dependency-injection/#configuration-integration","title":"\ud83d\udd27 Configuration Integration","text":""},{"location":"features/dependency-injection/#configuration-objects","title":"Configuration Objects","text":"<p>Bind configuration sections to objects:</p> <pre><code>from dataclasses import dataclass\n\n@dataclass\nclass DatabaseConfig:\n    connection_string: str\n    timeout: int\n    retry_count: int\n\n# Register configuration\nservices.configure(DatabaseConfig, app_settings.database)\n\n# Use in services\nclass UserRepository:\n    def __init__(self, config: DatabaseConfig):\n        self.connection_string = config.connection_string\n</code></pre>"},{"location":"features/dependency-injection/#options-pattern","title":"Options Pattern","text":"<p>Use the options pattern for configuration:</p> <pre><code>from neuroglia.configuration import IOptions\n\nclass UserService:\n    def __init__(self, options: IOptions[UserServiceOptions]):\n        self.options = options.value\n\n    def send_welcome_email(self, user: User):\n        if self.options.send_welcome_emails:\n            # Send email logic\n            pass\n</code></pre>"},{"location":"features/dependency-injection/#testing-with-di","title":"\ud83e\uddea Testing with DI","text":""},{"location":"features/dependency-injection/#test-service-registration","title":"Test Service Registration","text":"<p>Override services for testing:</p> <pre><code>import pytest\nfrom neuroglia.dependency_injection import ServiceCollection\n\n@pytest.fixture\ndef test_services():\n    services = ServiceCollection()\n\n    # Register test implementations\n    services.add_singleton(IUserRepository, InMemoryUserRepository)\n    services.add_singleton(IEmailService, MockEmailService)\n\n    return services.build_service_provider()\n\ndef test_user_creation(test_services):\n    user_service = test_services.get_required_service(UserService)\n    result = user_service.create_user(user_data)\n    assert result.is_success\n</code></pre>"},{"location":"features/dependency-injection/#mock-dependencies","title":"Mock Dependencies","text":"<p>Use mocking frameworks with DI:</p> <pre><code>from unittest.mock import Mock\n\ndef test_user_service_with_mocks():\n    # Arrange\n    mock_repo = Mock(spec=IUserRepository)\n    mock_repo.add_async.return_value = test_user\n\n    services = ServiceCollection()\n    services.add_instance(IUserRepository, mock_repo)\n    provider = services.build_service_provider()\n\n    # Act\n    user_service = provider.get_required_service(UserService)\n    result = await user_service.create_user(user_data)\n\n    # Assert\n    mock_repo.add_async.assert_called_once()\n    assert result.email == test_user.email\n</code></pre>"},{"location":"features/dependency-injection/#framework-integration","title":"\ud83c\udfaa Framework Integration","text":""},{"location":"features/dependency-injection/#web-application-builder","title":"Web Application Builder","text":"<p>The WebApplicationBuilder provides convenient methods for service registration:</p> <pre><code>from neuroglia.hosting.web import WebApplicationBuilder\n\nbuilder = WebApplicationBuilder()\n\n# Configure framework services\nbuilder.services.add_mediation([\"application\"])\nbuilder.services.add_mapping([\"application\", \"domain\"])\nbuilder.services.add_repositories([\"integration.repositories\"])\n\n# Add custom services\nbuilder.services.add_scoped(UserService)\nbuilder.services.add_singleton(EmailService)\n\napp = builder.build()\n</code></pre>"},{"location":"features/dependency-injection/#controller-dependencies","title":"Controller Dependencies","text":"<p>Controllers automatically receive dependencies:</p> <pre><code>class UsersController(ControllerBase):\n    def __init__(self, \n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator,\n                 user_service: UserService,\n                 email_service: EmailService):\n        super().__init__(service_provider, mapper, mediator)\n        self.user_service = user_service\n        self.email_service = email_service\n</code></pre>"},{"location":"features/dependency-injection/#middleware-dependencies","title":"Middleware Dependencies","text":"<p>Middleware can also use dependency injection:</p> <pre><code>class AuthenticationMiddleware:\n    def __init__(self, auth_service: IAuthService):\n        self.auth_service = auth_service\n\n    async def __call__(self, request: Request, call_next):\n        # Use auth_service for authentication logic\n        pass\n</code></pre>"},{"location":"features/dependency-injection/#best-practices","title":"\ud83d\ude80 Best Practices","text":""},{"location":"features/dependency-injection/#1-register-by-interface","title":"1. Register by Interface","text":"<p>Always register services by their interface when possible:</p> <pre><code># Good\nservices.add_scoped(IUserRepository, MongoUserRepository)\n\n# Avoid\nservices.add_scoped(MongoUserRepository)\n</code></pre>"},{"location":"features/dependency-injection/#2-use-appropriate-lifetimes","title":"2. Use Appropriate Lifetimes","text":"<p>Choose the correct lifetime for your services:</p> <ul> <li>Singleton: Expensive to create, stateless, or application-wide</li> <li>Scoped: Request-specific, maintains state during request</li> <li>Transient: Lightweight, stateless, or disposable</li> </ul>"},{"location":"features/dependency-injection/#3-avoid-service-locator","title":"3. Avoid Service Locator","text":"<p>Prefer constructor injection over service locator:</p> <pre><code># Good - Constructor injection\nclass UserService:\n    def __init__(self, user_repository: IUserRepository):\n        self.user_repository = user_repository\n\n# Avoid - Service locator\nclass UserService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.service_provider = service_provider\n\n    def some_method(self):\n        repo = self.service_provider.get_required_service(IUserRepository)\n</code></pre>"},{"location":"features/dependency-injection/#4-validate-dependencies","title":"4. Validate Dependencies","text":"<p>Ensure all required dependencies are registered:</p> <pre><code>def validate_services(provider: ServiceProviderBase):\n    \"\"\"Validate that all required services are registered\"\"\"\n    required_services = [IUserRepository, IEmailService, ICacheService]\n\n    for service_type in required_services:\n        service = provider.get_service(service_type)\n        if service is None:\n            raise ValueError(f\"Required service {service_type} not registered\")\n</code></pre>"},{"location":"features/dependency-injection/#5-use-factories-for-complex-objects","title":"5. Use Factories for Complex Objects","text":"<p>Use factory functions for services that need complex initialization:</p> <pre><code>def create_user_repository(provider: ServiceProviderBase) -&gt; IUserRepository:\n    config = provider.get_required_service(DatabaseConfig)\n    connection = provider.get_required_service(DatabaseConnection)\n\n    if config.use_caching:\n        cache = provider.get_required_service(ICacheService)\n        return CachedUserRepository(connection, cache)\n    else:\n        return UserRepository(connection)\n\nservices.add_scoped(IUserRepository, factory=create_user_repository)\n</code></pre>"},{"location":"features/dependency-injection/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Basic DI usage</li> <li>Architecture Guide - How DI fits in the architecture</li> <li>CQRS &amp; Mediation - DI with command handlers</li> <li>Data Access - DI with repositories</li> <li>Testing - Testing with dependency injection</li> </ul>"},{"location":"features/event-sourcing/","title":"\ud83c\udfaf Event Sourcing","text":"<p>Event Sourcing is a data storage pattern where state changes are stored as a sequence of immutable events rather than updating data in place. Neuroglia provides comprehensive event sourcing support with EventStoreDB integration, aggregate root patterns, and event-driven projections.</p>"},{"location":"features/event-sourcing/#overview","title":"\ud83c\udfaf Overview","text":"<p>Event Sourcing offers several key benefits:</p> <ul> <li>Complete Audit Trail: Every state change is captured as an immutable event</li> <li>Temporal Queries: Query system state at any point in time</li> <li>Event Replay: Reconstruct current state by replaying events</li> <li>Business Intelligence: Analyze patterns and trends from event streams</li> <li>Debugging: Full visibility into how state changes occurred</li> <li>Scalability: Events can be replayed to create optimized read models</li> </ul>"},{"location":"features/event-sourcing/#core-concepts","title":"\ud83c\udfd7\ufe0f Core Concepts","text":""},{"location":"features/event-sourcing/#events-as-source-of-truth","title":"Events as Source of Truth","text":"<p>In traditional systems, current state is stored directly:</p> <pre><code># Traditional approach - current state only\nclass BankAccount:\n    def __init__(self, id: str, balance: Decimal):\n        self.id = id\n        self.balance = balance  # Current state stored directly\n\n    def withdraw(self, amount: Decimal):\n        self.balance -= amount  # State updated in place\n</code></pre> <p>With Event Sourcing, we store the events that led to the current state:</p> <pre><code># Event Sourcing approach - events as source of truth\nclass BankAccountCreatedEvent(DomainEvent[str]):\n    def __init__(self, account_id: str, initial_balance: Decimal):\n        super().__init__(account_id)\n        self.initial_balance = initial_balance\n\nclass MoneyWithdrawnEvent(DomainEvent[str]):\n    def __init__(self, account_id: str, amount: Decimal):\n        super().__init__(account_id)\n        self.amount = amount\n\nclass BankAccount(AggregateRoot[BankAccountState, str]):\n    def __init__(self, id: str, initial_balance: Decimal):\n        super().__init__()\n        self.state.on(self.register_event(BankAccountCreatedEvent(id, initial_balance)))\n\n    def withdraw(self, amount: Decimal):\n        if self.state.balance &lt; amount:\n            raise InsufficientFundsException()\n        self.state.on(self.register_event(MoneyWithdrawnEvent(self.state.id, amount)))\n</code></pre>"},{"location":"features/event-sourcing/#state-reconstruction-from-events","title":"State Reconstruction from Events","text":"<p>Current state is derived by applying events in sequence using the <code>@dispatch</code> decorator:</p> <pre><code>from neuroglia.data.abstractions import AggregateRoot, DomainEvent\nfrom neuroglia.mapping.mapper import map_to\nfrom decimal import Decimal\nfrom multipledispatch import dispatch\n\nclass BankAccountCreatedDomainEventV1(DomainEvent[str]):\n    def __init__(self, aggregate_id: str, owner_id: str, overdraft_limit: Decimal):\n        super().__init__(aggregate_id)\n        self.owner_id = owner_id\n        self.overdraft_limit = overdraft_limit\n\nclass BankAccountTransactionRecordedDomainEventV1(DomainEvent[str]):\n    def __init__(self, aggregate_id: str, transaction_id: str, amount: Decimal):\n        super().__init__(aggregate_id)\n        self.transaction_id = transaction_id\n        self.amount = amount\n\nclass BankAccountV1(AggregateRoot[str]):\n    def __init__(self, account_id: str = None):\n        super().__init__(account_id)\n        self._balance = Decimal('0.00')\n        self._owner_id = \"\"\n        self._overdraft_limit = Decimal('0.00')\n\n    @property\n    def balance(self) -&gt; Decimal:\n        return self._balance\n\n    @dispatch(BankAccountCreatedDomainEventV1)\n    def state_manager(self, event: BankAccountCreatedDomainEventV1):\n        \"\"\"Handle account creation for state reconstruction\"\"\"\n        self._owner_id = event.owner_id\n        self._overdraft_limit = event.overdraft_limit\n\n    @dispatch(BankAccountTransactionRecordedDomainEventV1)\n    def state_manager(self, event: BankAccountTransactionRecordedDomainEventV1):\n        \"\"\"Handle transaction recording for state reconstruction\"\"\"\n        self._balance += event.amount\n</code></pre>"},{"location":"features/event-sourcing/#aggregate-root-pattern","title":"\ud83d\ude80 Aggregate Root Pattern","text":""},{"location":"features/event-sourcing/#defining-aggregates","title":"Defining Aggregates","text":"<p>Aggregates are domain objects that encapsulate business logic and raise domain events:</p> <pre><code>from neuroglia.data.abstractions import AggregateRoot, AggregateState, DomainEvent\nfrom decimal import Decimal\nfrom datetime import datetime\nimport uuid\n\nclass BankAccountV1(AggregateRoot[BankAccountState, str]):\n    \"\"\"Bank Account aggregate with event sourcing\"\"\"\n\n    def __init__(self, owner: Person, initial_balance: Decimal):\n        super().__init__()\n\n        # Validate business rules\n        if initial_balance &lt; Decimal('0.00'):\n            raise InvalidInitialBalanceException(\"Initial balance cannot be negative\")\n\n        # Register creation event and apply to state\n        self.state.on(self.register_event(BankAccountCreatedDomainEventV1(\n            aggregate_id=str(uuid.uuid4()).replace('-', ''),\n            owner_id=owner.id(),\n            initial_balance=initial_balance,\n            created_at=datetime.utcnow()\n        )))\n\n    def get_available_balance(self) -&gt; Decimal:\n        \"\"\"Get the available balance including overdraft\"\"\"\n        return Decimal(self.state.balance) + Decimal(self.state.overdraft_limit)\n\n    def try_add_transaction(self, transaction: BankTransactionV1) -&gt; bool:\n        \"\"\"Record a financial transaction\"\"\"\n\n        # Business rule validation  \n        if (transaction.type != BankTransactionTypeV1.DEPOSIT and \n            transaction.type != BankTransactionTypeV1.INTEREST and \n            not (transaction.type == BankTransactionTypeV1.TRANSFER and transaction.to_account_id == self.id()) and \n            transaction.amount &gt; self.get_available_balance()):\n            return False\n\n        # Register transaction event and apply to state\n        self.state.on(self.register_event(BankAccountTransactionRecordedDomainEventV1(\n            self.id(), transaction\n        )))\n        return True\n\n    def set_overdraft_limit(self, limit: Decimal):\n        \"\"\"Set the overdraft limit for the account\"\"\"\n        if limit &lt; Decimal('0.00'):\n            raise InvalidOverdraftLimitException(\"Overdraft limit cannot be negative\")\n\n        self.state.on(self.register_event(OverdraftLimitChangedDomainEventV1(\n            aggregate_id=self.state.id,\n            old_limit=self.state.overdraft_limit,\n            new_limit=limit\n        )))\n\n    def close_account(self, reason: str):\n        \"\"\"Close the bank account\"\"\"\n        if self.state.balance != Decimal('0.00'):\n            raise AccountHasBalanceException(\"Cannot close account with non-zero balance\")\n\n        self.state.on(self.register_event(BankAccountClosedDomainEventV1(\n            aggregate_id=self.state.id,\n            reason=reason,\n            final_balance=self.state.balance\n        )))\n</code></pre>"},{"location":"features/event-sourcing/#aggregate-state-management","title":"Aggregate State Management","text":"<p>The aggregate manages its internal state through event application:</p> <pre><code>from multipledispatch import dispatch\nfrom decimal import Decimal\nfrom typing import List\n\nclass BankAccountV1(AggregateRoot[str]):\n    \"\"\"Bank Account aggregate with event sourcing\"\"\"\n\n    def __init__(self, account_id: str = None):\n        super().__init__(account_id)\n        self._balance = Decimal('0.00')\n        self._overdraft_limit = Decimal('0.00')\n        self._owner_id = \"\"\n        self._is_closed = False\n        self._transactions = []\n\n    @property\n    def balance(self) -&gt; Decimal:\n        return self._balance\n\n    @property\n    def owner_id(self) -&gt; str:\n        return self._owner_id\n\n    @property\n    def overdraft_limit(self) -&gt; Decimal:\n        return self._overdraft_limit\n\n    @dispatch(BankAccountCreatedDomainEventV1)\n    def state_manager(self, event: BankAccountCreatedDomainEventV1):\n        \"\"\"Handle account creation\"\"\"\n        self._owner_id = event.owner_id\n        self._overdraft_limit = event.overdraft_limit\n\n    @dispatch(BankAccountTransactionRecordedDomainEventV1)\n    def state_manager(self, event: BankAccountTransactionRecordedDomainEventV1):\n        \"\"\"Handle transaction recording\"\"\"\n        # Update balance based on transaction amount\n        self._balance += event.amount\n        self.last_modified = event.timestamp\n\n    @dispatch(OverdraftLimitChangedDomainEventV1)\n    def on(self, event: OverdraftLimitChangedDomainEventV1):\n        \"\"\"Handle overdraft limit changes\"\"\"\n        self.overdraft_limit = event.new_limit\n        self.last_modified = event.timestamp\n\n    @dispatch(BankAccountClosedDomainEventV1)\n    def on(self, event: BankAccountClosedDomainEventV1):\n        \"\"\"Handle account closure\"\"\"\n        self.is_closed = True\n        self.last_modified = event.timestamp\n</code></pre>"},{"location":"features/event-sourcing/#event-store-configuration","title":"\ud83c\udfea Event Store Configuration","text":""},{"location":"features/event-sourcing/#eventstoredb-setup","title":"EventStoreDB Setup","text":"<p>Configure EventStoreDB as the event storage backend:</p> <pre><code>from neuroglia.data.infrastructure.event_sourcing.event_store import ESEventStore\nfrom neuroglia.data.infrastructure.event_sourcing.abstractions import EventStoreOptions\nfrom neuroglia.hosting.web import WebApplicationBuilder\n\ndef configure_event_store(builder: WebApplicationBuilder):\n    \"\"\"Configure EventStoreDB for event sourcing\"\"\"\n\n    # Event store configuration\n    database_name = \"bankingsystem\"\n    consumer_group = \"banking-api-v1\"\n\n    ESEventStore.configure(\n        builder, \n        EventStoreOptions(\n            database_name=database_name,\n            consumer_group=consumer_group,\n            connection_string=\"esdb://localhost:2113?tls=false\",\n            credentials={\"username\": \"admin\", \"password\": \"changeit\"}\n        )\n    )\n\n    # Configure event sourcing repository for write model\n    EventSourcingRepository.configure(builder, BankAccountV1, str)\n\n    return builder\n</code></pre>"},{"location":"features/event-sourcing/#repository-configuration","title":"Repository Configuration","text":"<p>Set up separate repositories for write and read models:</p> <pre><code>from neuroglia.hosting.configuration.data_access_layer import DataAccessLayer\nfrom neuroglia.data.infrastructure.event_sourcing.event_sourcing_repository import EventSourcingRepository\nfrom neuroglia.data.infrastructure.mongo.mongo_repository import MongoRepository\n\ndef configure_data_access(builder: WebApplicationBuilder):\n    \"\"\"Configure write and read model repositories\"\"\"\n\n    # Write Model: Event-sourced aggregates\n    DataAccessLayer.WriteModel.configure(\n        builder,\n        [\"samples.banking.domain.models\"],  # Domain aggregate modules\n        lambda builder_, entity_type, key_type: EventSourcingRepository.configure(\n            builder_, entity_type, key_type\n        )\n    )\n\n    # Read Model: MongoDB projections\n    DataAccessLayer.ReadModel.configure(\n        builder,\n        [\"samples.banking.integration.models\"],  # Read model modules\n        lambda builder_, entity_type, key_type: MongoRepository.configure(\n            builder_, entity_type, key_type, database_name=\"banking_read_models\"\n        )\n    )\n\n    return builder\n</code></pre>"},{"location":"features/event-sourcing/#event-driven-projections","title":"\ud83d\udcca Event-Driven Projections","text":""},{"location":"features/event-sourcing/#creating-read-model-projections","title":"Creating Read Model Projections","text":"<p>Transform domain events into optimized read models:</p> <pre><code>from neuroglia.eventing import event_handler\n\nclass BankAccountProjectionHandler:\n    \"\"\"Handles domain events to update read model projections\"\"\"\n\n    def __init__(self, read_repository: Repository[BankAccountProjection, str]):\n        self.read_repository = read_repository\n\n    @event_handler(BankAccountCreatedDomainEventV1)\n    async def handle_account_created(self, event: BankAccountCreatedDomainEventV1):\n        \"\"\"Create read model projection when account is created\"\"\"\n\n        projection = BankAccountProjection(\n            id=event.aggregate_id,\n            owner_id=event.owner_id,\n            balance=event.initial_balance,\n            overdraft_limit=Decimal('0.00'),\n            status=\"ACTIVE\",\n            created_at=event.created_at,\n            last_modified=event.created_at,\n            transaction_count=0,\n            last_transaction_at=None\n        )\n\n        await self.read_repository.add_async(projection)\n\n    @event_handler(BankAccountTransactionRecordedDomainEventV1)\n    async def handle_transaction_recorded(self, event: BankAccountTransactionRecordedDomainEventV1):\n        \"\"\"Update projection when transaction is recorded\"\"\"\n\n        projection = await self.read_repository.get_by_id_async(event.aggregate_id)\n        if projection:\n            projection.balance += event.amount\n            projection.transaction_count += 1\n            projection.last_transaction_at = event.timestamp\n            projection.last_modified = event.timestamp\n\n            await self.read_repository.update_async(projection)\n\n    @event_handler(BankAccountClosedDomainEventV1)\n    async def handle_account_closed(self, event: BankAccountClosedDomainEventV1):\n        \"\"\"Update projection when account is closed\"\"\"\n\n        projection = await self.read_repository.get_by_id_async(event.aggregate_id)\n        if projection:\n            projection.status = \"CLOSED\"\n            projection.last_modified = event.timestamp\n\n            await self.read_repository.update_async(projection)\n</code></pre>"},{"location":"features/event-sourcing/#read-model-optimization","title":"Read Model Optimization","text":"<p>Design read models for specific query patterns:</p> <pre><code>@dataclass\nclass BankAccountProjection:\n    \"\"\"Optimized read model for bank account queries\"\"\"\n\n    id: str\n    owner_id: str\n    balance: Decimal\n    overdraft_limit: Decimal\n    status: str  # ACTIVE, CLOSED, SUSPENDED\n    created_at: datetime\n    last_modified: datetime\n    transaction_count: int\n    last_transaction_at: Optional[datetime]\n\n    # Denormalized owner information for efficient queries\n    owner_name: Optional[str] = None\n    owner_email: Optional[str] = None\n\n    # Aggregated transaction data\n    total_debits: Decimal = Decimal('0.00')\n    total_credits: Decimal = Decimal('0.00')\n    largest_transaction: Decimal = Decimal('0.00')\n\n@dataclass\nclass AccountSummaryProjection:\n    \"\"\"Summary projection for dashboard queries\"\"\"\n\n    owner_id: str\n    total_accounts: int\n    total_balance: Decimal\n    active_accounts: int\n    closed_accounts: int\n    last_activity: datetime\n</code></pre>"},{"location":"features/event-sourcing/#temporal-queries","title":"\ud83d\udd70\ufe0f Temporal Queries","text":""},{"location":"features/event-sourcing/#point-in-time-state-reconstruction","title":"Point-in-Time State Reconstruction","text":"<p>Query aggregate state at any specific point in time:</p> <pre><code>class TemporalQueryService:\n    \"\"\"Service for temporal queries on event-sourced aggregates\"\"\"\n\n    def __init__(self, event_store: EventStore, aggregator: Aggregator):\n        self.event_store = event_store\n        self.aggregator = aggregator\n\n    async def get_account_balance_at_date(self, account_id: str, as_of_date: datetime) -&gt; Decimal:\n        \"\"\"Get account balance as it was at a specific date\"\"\"\n\n        stream_id = f\"BankAccount-{account_id}\"\n\n        # Read events up to the specified date\n        events = await self.event_store.read_async(\n            stream_id,\n            direction=StreamReadDirection.FORWARDS,\n            from_position=0,\n            to_date=as_of_date\n        )\n\n        # Reconstruct state at that point in time\n        account = self.aggregator.aggregate(events, BankAccountV1)\n        return account.state.balance if account else Decimal('0.00')\n\n    async def get_transaction_history_between_dates(\n        self, \n        account_id: str, \n        from_date: datetime, \n        to_date: datetime\n    ) -&gt; List[BankTransactionV1]:\n        \"\"\"Get all transactions within a date range\"\"\"\n\n        stream_id = f\"BankAccount-{account_id}\"\n\n        events = await self.event_store.read_async(\n            stream_id,\n            direction=StreamReadDirection.FORWARDS,\n            from_date=from_date,\n            to_date=to_date\n        )\n\n        transactions = []\n        for event_record in events:\n            if isinstance(event_record.data, BankAccountTransactionRecordedDomainEventV1):\n                transaction = BankTransactionV1(\n                    id=event_record.data.transaction_id,\n                    amount=event_record.data.amount,\n                    type=event_record.data.transaction_type,\n                    recorded_at=event_record.data.timestamp\n                )\n                transactions.append(transaction)\n\n        return transactions\n</code></pre>"},{"location":"features/event-sourcing/#business-intelligence-queries","title":"Business Intelligence Queries","text":"<p>Analyze historical data patterns:</p> <pre><code>class BusinessIntelligenceService:\n    \"\"\"Service for analyzing business patterns from events\"\"\"\n\n    def __init__(self, event_store: EventStore):\n        self.event_store = event_store\n\n    async def get_transaction_analytics(\n        self, \n        from_date: datetime, \n        to_date: datetime\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Analyze transaction patterns over time\"\"\"\n\n        # Query all transaction events in date range\n        events = await self.event_store.get_events_by_type_async(\n            BankAccountTransactionRecordedDomainEventV1,\n            from_date=from_date,\n            to_date=to_date\n        )\n\n        if not events:\n            return {\"message\": \"No transactions found in date range\"}\n\n        # Calculate analytics\n        total_transactions = len(events)\n        total_amount = sum(e.amount for e in events)\n        debit_transactions = [e for e in events if e.amount &lt; 0]\n        credit_transactions = [e for e in events if e.amount &gt; 0]\n\n        return {\n            \"period\": {\"from\": from_date.isoformat(), \"to\": to_date.isoformat()},\n            \"total_transactions\": total_transactions,\n            \"total_amount\": float(total_amount),\n            \"average_transaction\": float(total_amount / total_transactions),\n            \"debit_count\": len(debit_transactions),\n            \"credit_count\": len(credit_transactions),\n            \"largest_debit\": float(min(e.amount for e in debit_transactions)) if debit_transactions else 0,\n            \"largest_credit\": float(max(e.amount for e in credit_transactions)) if credit_transactions else 0,\n            \"daily_breakdown\": self._calculate_daily_breakdown(events, from_date, to_date)\n        }\n\n    def _calculate_daily_breakdown(self, events: List[BankAccountTransactionRecordedDomainEventV1], from_date: datetime, to_date: datetime) -&gt; List[Dict]:\n        \"\"\"Calculate daily transaction breakdown\"\"\"\n        daily_data = {}\n\n        for event in events:\n            day_key = event.timestamp.date().isoformat()\n            if day_key not in daily_data:\n                daily_data[day_key] = {\"count\": 0, \"amount\": Decimal('0.00')}\n\n            daily_data[day_key][\"count\"] += 1\n            daily_data[day_key][\"amount\"] += event.amount\n\n        return [\n            {\n                \"date\": date,\n                \"transaction_count\": data[\"count\"],\n                \"total_amount\": float(data[\"amount\"])\n            }\n            for date, data in sorted(daily_data.items())\n        ]\n</code></pre>"},{"location":"features/event-sourcing/#testing-event-sourced-systems","title":"\ud83e\uddea Testing Event-Sourced Systems","text":""},{"location":"features/event-sourcing/#unit-testing-aggregates","title":"Unit Testing Aggregates","text":"<p>Test business logic by verifying events are raised correctly:</p> <pre><code>import pytest\nfrom decimal import Decimal\n\nclass TestBankAccountAggregate:\n    \"\"\"Unit tests for BankAccount aggregate\"\"\"\n\n    def test_account_creation_raises_creation_event(self):\n        \"\"\"Test that creating an account raises the correct event\"\"\"\n        account = BankAccountV1()\n        owner_id = \"john-doe-123\"\n        overdraft_limit = Decimal(\"1000.00\")\n\n        account.create_account(owner_id, overdraft_limit)\n\n        events = account._pending_events\n\n        assert len(events) == 1\n        assert isinstance(events[0], BankAccountCreatedDomainEventV1)\n        assert events[0].owner_id == owner_id\n        assert events[0].overdraft_limit == overdraft_limit\n\n    def test_transaction_recording_updates_balance_and_raises_event(self):\n        \"\"\"Test that recording a transaction updates balance and raises event\"\"\"\n        account = self._create_test_account()\n\n        # Create a transaction using the actual method signature\n        transaction_id = \"trans-123\"\n        amount = Decimal(\"100.00\")\n\n        result = account.try_add_transaction(transaction_id, amount)\n\n        # Verify transaction was accepted\n        assert result == True\n\n        # Verify event was registered\n        events = account._pending_events\n        transaction_events = [e for e in events if isinstance(e, BankAccountTransactionRecordedDomainEventV1)]\n\n        assert len(transaction_events) == 1\n\n    def test_insufficient_funds_raises_exception(self):\n        \"\"\"Test that insufficient funds rejects transaction\"\"\"\n        account = self._create_test_account()\n\n        # Create transaction that exceeds available balance\n        large_transaction = BankTransactionV1(\n            type=BankTransactionTypeV1.WITHDRAWAL,\n            amount=Decimal(\"2000.00\"),  # More than available balance\n            from_account_id=account.id(),\n            to_account_id=None\n        )\n\n        result = account.try_add_transaction(large_transaction)\n\n        # Verify transaction was rejected\n        assert result == False\n\n        # Verify no event was registered\n        events = account._pending_events\n        transaction_events = [e for e in events if isinstance(e, BankAccountTransactionRecordedDomainEventV1)]\n        assert len(transaction_events) == 0\n\n    def test_state_reconstruction_from_events(self):\n        \"\"\"Test that aggregate state can be reconstructed from events\"\"\"\n\n        # Create aggregate\n        account = BankAccountV1()\n\n        # Create and apply events directly to simulate repository loading\n        creation_event = BankAccountCreatedDomainEventV1(\n            aggregate_id=account.id,\n            owner_id=\"owner-123\",\n            overdraft_limit=Decimal(\"500.00\")\n        )\n\n        transaction_event = BankAccountTransactionRecordedDomainEventV1(\n            aggregate_id=account.id,\n            transaction_id=\"trans-123\",\n            amount=Decimal(\"100.00\")\n        )\n\n        # Apply events to reconstruct state\n        account.state_manager(creation_event)\n        account.state_manager(transaction_event)\n\n        # Verify state reconstruction\n        assert account.owner_id == \"owner-123\"\n        assert account.overdraft_limit == Decimal(\"500.00\")\n        assert account.balance == Decimal(\"100.00\")\n\n    def _create_test_account(self) -&gt; BankAccountV1:\n        \"\"\"Helper method to create a test account\"\"\"\n        account = BankAccountV1()\n        account.create_account(\"test-owner\", Decimal(\"1000.00\"))\n        # Clear pending events for clean testing\n        account._pending_events.clear()\n        return account\n</code></pre>"},{"location":"features/event-sourcing/#integration-testing-with-event-store","title":"Integration Testing with Event Store","text":"<p>Test the complete event sourcing workflow:</p> <pre><code>@pytest.mark.integration\nclass TestEventSourcingIntegration:\n    \"\"\"Integration tests for event sourcing workflow\"\"\"\n\n    @pytest.fixture\n    async def event_store(self):\n        \"\"\"Create test event store\"\"\"\n        options = EventStoreOptions(\n            database_name=\"test_banking\",\n            consumer_group=\"test_group\",\n            connection_string=\"esdb://localhost:2113?tls=false\"\n        )\n        # Return configured event store for testing\n        pass\n\n    @pytest.fixture\n    async def repository(self, event_store):\n        \"\"\"Create test repository\"\"\"\n        aggregator = Aggregator()\n        return EventSourcingRepository(event_store, aggregator)\n\n    @pytest.mark.asyncio\n    async def test_complete_aggregate_lifecycle(self, repository):\n        \"\"\"Test complete aggregate lifecycle with persistence\"\"\"\n\n        # Create aggregate\n        owner = Person(\"integration@test.com\", \"Integration\", \"Test\")\n        account = BankAccountV1(owner, Decimal(\"1000.00\"))\n\n        # Save to event store\n        saved_account = await repository.add_async(account)\n        assert saved_account.state.state_version &gt; 0\n\n        # Load from event store\n        loaded_account = await repository.get_async(saved_account.id())\n        assert loaded_account is not None\n        assert loaded_account.state.balance == Decimal(\"1000.00\")\n        assert loaded_account.state.owner_id == owner.id()\n\n        # Modify and save again\n        transaction = BankTransactionV1(\n            type=BankTransactionTypeV1.WITHDRAWAL,\n            amount=Decimal(\"200.00\"),\n            from_account_id=loaded_account.id(),\n            to_account_id=None\n        )\n        loaded_account.try_add_transaction(transaction)\n        updated_account = await repository.update_async(loaded_account)\n\n        # Verify persistence\n        final_account = await repository.get_async(updated_account.id())\n        assert len(final_account.state.transactions) == 1\n\n    @pytest.mark.asyncio\n    async def test_concurrent_modifications_throw_concurrency_exception(self, repository):\n        \"\"\"Test that concurrent modifications are detected\"\"\"\n\n        # Create and save account\n        owner = Person(\"concurrent@test.com\", \"Concurrent\", \"Test\")\n        account = BankAccountV1(owner, Decimal(\"1000.00\"))\n        saved_account = await repository.add_async(account)\n        account_id = saved_account.id()\n\n        # Load same account in two instances\n        account1 = await repository.get_async(account_id)\n        account2 = await repository.get_async(account_id)\n\n        # Modify both\n        transaction1 = BankTransactionV1(BankTransactionTypeV1.WITHDRAWAL, Decimal(\"100.00\"), account_id, None)\n        transaction2 = BankTransactionV1(BankTransactionTypeV1.WITHDRAWAL, Decimal(\"200.00\"), account_id, None)\n\n        account1.try_add_transaction(transaction1)\n        account2.try_add_transaction(transaction2)\n\n        # Save first modification\n        await repository.update_async(account1)\n\n        # Second modification should fail due to concurrency\n        with pytest.raises(ConcurrencyException):\n            await repository.update_async(account2)\n</code></pre>"},{"location":"features/event-sourcing/#advanced-patterns","title":"\ud83d\udd27 Advanced Patterns","text":""},{"location":"features/event-sourcing/#event-versioning","title":"Event Versioning","text":"<p>Handle evolving event schemas over time:</p> <pre><code># V1 Event\n@dataclass\nclass BankAccountCreatedDomainEventV1(DomainEvent[str]):\n    owner_id: str\n    initial_balance: Decimal\n\n# V2 Event - Added account type\n@dataclass  \nclass BankAccountCreatedDomainEventV2(DomainEvent[str]):\n    owner_id: str\n    initial_balance: Decimal\n    account_type: str  # New field\n\n# Event upcasting for backward compatibility\nclass EventUpcaster:\n    def upcast(self, event_data: dict, event_type: str) -&gt; dict:\n        if event_type == \"BankAccountCreatedDomainEventV1\":\n            # Upcast V1 to V2 by adding default account type\n            event_data[\"account_type\"] = \"CHECKING\"\n            return event_data\n        return event_data\n</code></pre>"},{"location":"features/event-sourcing/#snapshots-for-performance","title":"Snapshots for Performance","text":"<p>Optimize performance for long event streams:</p> <pre><code>@dataclass\nclass BankAccountSnapshot:\n    \"\"\"Snapshot of bank account state for performance optimization\"\"\"\n\n    aggregate_id: str\n    version: int\n    balance: Decimal\n    overdraft_limit: Decimal\n    transaction_count: int\n    created_at: datetime\n    snapshot_at: datetime\n\nclass SnapshotRepository:\n    \"\"\"Repository for managing aggregate snapshots\"\"\"\n\n    async def save_snapshot_async(self, aggregate: BankAccountV1) -&gt; None:\n        \"\"\"Save a snapshot of the current aggregate state\"\"\"\n        snapshot = BankAccountSnapshot(\n            aggregate_id=aggregate.state.id,\n            version=aggregate.state.state_version,\n            balance=aggregate.state.balance,\n            overdraft_limit=aggregate.state.overdraft_limit,\n            transaction_count=len(aggregate.state.transactions),\n            created_at=aggregate.state.created_at,\n            snapshot_at=datetime.utcnow()\n        )\n        await self.repository.add_async(snapshot)\n\n    async def load_from_snapshot_async(self, aggregate_id: str) -&gt; Optional[BankAccountV1]:\n        \"\"\"Load aggregate from latest snapshot plus subsequent events\"\"\"\n        snapshot = await self.get_latest_snapshot_async(aggregate_id)\n        if not snapshot:\n            return None\n\n        # Load events since snapshot\n        events = await self.event_store.read_async(\n            f\"BankAccount-{aggregate_id}\",\n            from_version=snapshot.version + 1\n        )\n\n        # Reconstruct aggregate from snapshot + events\n        aggregate = self._create_from_snapshot(snapshot)\n        self._apply_events(aggregate, events)\n\n        return aggregate\n</code></pre>"},{"location":"features/event-sourcing/#saga-pattern-for-distributed-transactions","title":"Saga Pattern for Distributed Transactions","text":"<p>Coordinate long-running business processes:</p> <pre><code>class MoneyTransferSaga:\n    \"\"\"Saga for coordinating money transfers between accounts\"\"\"\n\n    @saga_step\n    async def debit_source_account(self, transfer_id: str, source_account_id: str, amount: Decimal):\n        \"\"\"Step 1: Debit the source account\"\"\"\n        command = DebitAccountCommand(source_account_id, amount, transfer_id)\n        result = await self.mediator.execute_async(command)\n\n        if result.is_success:\n            await self.complete_step(\"debit_source\", transfer_id)\n        else:\n            await self.compensate_transfer(transfer_id, \"Failed to debit source account\")\n\n    @saga_step\n    async def credit_target_account(self, transfer_id: str, target_account_id: str, amount: Decimal):\n        \"\"\"Step 2: Credit the target account\"\"\"\n        command = CreditAccountCommand(target_account_id, amount, transfer_id)\n        result = await self.mediator.execute_async(command)\n\n        if result.is_success:\n            await self.complete_saga(transfer_id)\n        else:\n            await self.compensate_debit(transfer_id, source_account_id, amount)\n\n    @compensating_action\n    async def compensate_debit(self, transfer_id: str, account_id: str, amount: Decimal):\n        \"\"\"Compensate by crediting back the debited amount\"\"\"\n        compensation_command = CreditAccountCommand(account_id, amount, f\"compensation-{transfer_id}\")\n        await self.mediator.execute_async(compensation_command)\n</code></pre>"},{"location":"features/event-sourcing/#monitoring-and-observability","title":"\ud83d\udcca Monitoring and Observability","text":""},{"location":"features/event-sourcing/#event-stream-health-monitoring","title":"Event Stream Health Monitoring","text":"<p>Monitor the health of your event streams:</p> <pre><code>class EventStoreHealthService:\n    \"\"\"Service for monitoring event store health\"\"\"\n\n    async def get_stream_statistics(self, stream_id: str) -&gt; Dict[str, Any]:\n        \"\"\"Get statistics for a specific event stream\"\"\"\n        descriptor = await self.event_store.get_stream_descriptor_async(stream_id)\n\n        return {\n            \"stream_id\": stream_id,\n            \"event_count\": descriptor.length,\n            \"first_event_at\": descriptor.first_event_at.isoformat() if descriptor.first_event_at else None,\n            \"last_event_at\": descriptor.last_event_at.isoformat() if descriptor.last_event_at else None,\n            \"stream_age_days\": (datetime.utcnow() - descriptor.first_event_at).days if descriptor.first_event_at else 0\n        }\n\n    async def detect_problematic_streams(self, max_age_days: int = 30) -&gt; List[str]:\n        \"\"\"Detect streams that haven't had events for a long time\"\"\"\n        all_streams = await self.event_store.list_streams_async()\n        problematic_streams = []\n\n        for stream_id in all_streams:\n            descriptor = await self.event_store.get_stream_descriptor_async(stream_id)\n            if descriptor.last_event_at:\n                age = (datetime.utcnow() - descriptor.last_event_at).days\n                if age &gt; max_age_days:\n                    problematic_streams.append(stream_id)\n\n        return problematic_streams\n</code></pre>"},{"location":"features/event-sourcing/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Data Access - Repository patterns and data persistence</li> <li>CQRS &amp; Mediation - Command/Query separation patterns  </li> <li>Domain Events - Domain event modeling</li> <li>OpenBank Sample - Complete event sourcing implementation</li> <li>Testing Strategies - Testing event-sourced systems</li> </ul>"},{"location":"features/event-sourcing/#best-practices","title":"\ud83c\udfaf Best Practices","text":""},{"location":"features/event-sourcing/#dos","title":"Do's \u2705","text":"<ul> <li>Design events as immutable facts - Events represent what happened, not what should happen</li> <li>Use meaningful event names - Events should clearly describe business occurrences</li> <li>Keep events focused - Each event should represent a single business fact</li> <li>Version your events - Plan for schema evolution from the beginning</li> <li>Test event handlers thoroughly - Ensure state transitions work correctly</li> <li>Monitor stream health - Track stream growth and performance metrics</li> </ul>"},{"location":"features/event-sourcing/#donts","title":"Don'ts \u274c","text":"<ul> <li>Don't modify events - Events are immutable historical facts</li> <li>Don't make events too granular - Avoid events for every minor state change</li> <li>Don't ignore concurrency - Handle concurrent modifications appropriately</li> <li>Don't skip snapshots - Use snapshots for performance with long streams</li> <li>Don't forget about eventual consistency - Read models may lag behind write models</li> <li>Don't ignore event ordering - Event sequence matters for state reconstruction</li> </ul> <p>Event Sourcing provides powerful capabilities for building auditable, scalable, and maintainable systems. The Neuroglia framework makes it straightforward to implement event sourcing patterns while maintaining clean architecture principles.</p>"},{"location":"features/mvc-controllers/","title":"\ud83d\udd0c MVC Controllers","text":"<p>Neuroglia provides a powerful MVC controller system built on top of FastAPI that enables class-based API development with automatic discovery, dependency injection, and OpenAPI documentation generation.</p>"},{"location":"features/mvc-controllers/#overview","title":"\ud83c\udfaf Overview","text":"<p>The MVC system provides:</p> <ul> <li>Class-based Controllers: Organize related endpoints in classes</li> <li>Automatic Discovery: Controllers are automatically found and registered</li> <li>Dependency Injection: Full DI support in controllers</li> <li>OpenAPI Integration: Automatic documentation generation</li> <li>Routing: Flexible routing with prefixes and tags</li> <li>Response Processing: Built-in result processing and error handling</li> </ul>"},{"location":"features/mvc-controllers/#controller-basics","title":"\ud83c\udfd7\ufe0f Controller Basics","text":""},{"location":"features/mvc-controllers/#creating-a-controller","title":"Creating a Controller","text":"<p>All controllers inherit from <code>ControllerBase</code>:</p> <pre><code>from neuroglia.mvc.controller_base import ControllerBase\nfrom neuroglia.dependency_injection.service_provider import ServiceProviderBase\nfrom neuroglia.mapping.mapper import Mapper\nfrom neuroglia.mediation.mediator import Mediator\n\nclass UsersController(ControllerBase):\n    def __init__(self, \n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n</code></pre>"},{"location":"features/mvc-controllers/#basic-endpoints","title":"Basic Endpoints","text":"<p>Use FastAPI decorators to define endpoints:</p> <pre><code>from classy_fastapi.decorators import get, post, put, delete\nfrom fastapi import status\nfrom typing import List\n\nclass UsersController(ControllerBase):\n\n    @get(\"/\", response_model=List[UserDto])\n    async def get_users(self) -&gt; List[UserDto]:\n        \"\"\"Get all users\"\"\"\n        query = GetAllUsersQuery()\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/{user_id}\", response_model=UserDto)\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        \"\"\"Get user by ID\"\"\"\n        query = GetUserByIdQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @post(\"/\", response_model=UserDto, status_code=status.HTTP_201_CREATED)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        \"\"\"Create a new user\"\"\"\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @put(\"/{user_id}\", response_model=UserDto)\n    async def update_user(self, user_id: str, update_user_dto: UpdateUserDto) -&gt; UserDto:\n        \"\"\"Update an existing user\"\"\"\n        command = self.mapper.map(update_user_dto, UpdateUserCommand)\n        command.user_id = user_id\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @delete(\"/{user_id}\", status_code=status.HTTP_204_NO_CONTENT)\n    async def delete_user(self, user_id: str):\n        \"\"\"Delete a user\"\"\"\n        command = DeleteUserCommand(user_id=user_id)\n        result = await self.mediator.execute_async(command)\n        self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#advanced-features","title":"\ud83d\ude80 Advanced Features","text":""},{"location":"features/mvc-controllers/#query-parameters","title":"Query Parameters","text":"<p>Handle query parameters for filtering and pagination:</p> <pre><code>from fastapi import Query\nfrom typing import Optional\n\nclass UsersController(ControllerBase):\n\n    @get(\"/\", response_model=List[UserDto])\n    async def get_users(self,\n                       department: Optional[str] = Query(None, description=\"Filter by department\"),\n                       active_only: bool = Query(True, description=\"Include only active users\"),\n                       page: int = Query(1, ge=1, description=\"Page number\"),\n                       page_size: int = Query(20, ge=1, le=100, description=\"Items per page\")) -&gt; List[UserDto]:\n        \"\"\"Get users with filtering and pagination\"\"\"\n\n        query = GetUsersQuery(\n            department=department,\n            active_only=active_only,\n            page=page,\n            page_size=page_size\n        )\n\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#request-body-validation","title":"Request Body Validation","text":"<p>Use Pydantic models for request validation:</p> <pre><code>from pydantic import BaseModel, Field, EmailStr\nfrom typing import Optional\n\nclass CreateUserDto(BaseModel):\n    email: EmailStr = Field(..., description=\"User's email address\")\n    first_name: str = Field(..., min_length=1, max_length=50, description=\"First name\")\n    last_name: str = Field(..., min_length=1, max_length=50, description=\"Last name\")\n    department: Optional[str] = Field(None, max_length=100, description=\"Department\")\n\n    class Config:\n        schema_extra = {\n            \"example\": {\n                \"email\": \"john.doe@company.com\",\n                \"first_name\": \"John\",\n                \"last_name\": \"Doe\",\n                \"department\": \"Engineering\"\n            }\n        }\n\nclass UsersController(ControllerBase):\n\n    @post(\"/\", response_model=UserDto, status_code=status.HTTP_201_CREATED)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        \"\"\"Create a new user\"\"\"\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#file-uploads","title":"File Uploads","text":"<p>Handle file uploads:</p> <pre><code>from fastapi import UploadFile, File\n\nclass UsersController(ControllerBase):\n\n    @post(\"/{user_id}/avatar\", response_model=UserDto)\n    async def upload_avatar(self, \n                           user_id: str,\n                           file: UploadFile = File(..., description=\"Avatar image\")) -&gt; UserDto:\n        \"\"\"Upload user avatar\"\"\"\n\n        # Validate file type\n        if not file.content_type.startswith('image/'):\n            return self.bad_request(\"File must be an image\")\n\n        # Create command\n        command = UploadUserAvatarCommand(\n            user_id=user_id,\n            file_name=file.filename,\n            file_content=await file.read(),\n            content_type=file.content_type\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#response-headers","title":"Response Headers","text":"<p>Set custom response headers:</p> <pre><code>from fastapi import Response\n\nclass UsersController(ControllerBase):\n\n    @get(\"/{user_id}/export\", response_class=Response)\n    async def export_user_data(self, user_id: str, response: Response):\n        \"\"\"Export user data as CSV\"\"\"\n\n        query = ExportUserDataQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n\n        if not result.is_success:\n            return self.process(result)\n\n        # Set CSV headers\n        response.headers[\"Content-Type\"] = \"text/csv\"\n        response.headers[\"Content-Disposition\"] = f\"attachment; filename=user_{user_id}.csv\"\n\n        return result.data\n</code></pre>"},{"location":"features/mvc-controllers/#controller-configuration","title":"\ud83c\udfaa Controller Configuration","text":""},{"location":"features/mvc-controllers/#custom-routing","title":"Custom Routing","text":"<p>Customize controller routing:</p> <pre><code>class UsersController(ControllerBase):\n    def __init__(self, service_provider, mapper, mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n        # Custom prefix and tags\n        self.router.prefix = \"/users\"\n        self.router.tags = [\"User Management\"]\n\n        # Add custom middleware to this controller\n        self.router.middleware(\"http\")(self.auth_middleware)\n\n    async def auth_middleware(self, request, call_next):\n        \"\"\"Custom authentication middleware for this controller\"\"\"\n        # Authentication logic\n        response = await call_next(request)\n        return response\n</code></pre>"},{"location":"features/mvc-controllers/#nested-controllers","title":"Nested Controllers","text":"<p>Create hierarchical resource structures:</p> <pre><code>class UserAccountsController(ControllerBase):\n    \"\"\"Handles user account operations\"\"\"\n\n    def __init__(self, service_provider, mapper, mediator):\n        super().__init__(service_provider, mapper, mediator)\n        self.router.prefix = \"/users/{user_id}/accounts\"\n\n    @get(\"/\", response_model=List[AccountDto])\n    async def get_user_accounts(self, user_id: str) -&gt; List[AccountDto]:\n        \"\"\"Get all accounts for a user\"\"\"\n        query = GetUserAccountsQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @post(\"/\", response_model=AccountDto, status_code=status.HTTP_201_CREATED)\n    async def create_account(self, user_id: str, create_account_dto: CreateAccountDto) -&gt; AccountDto:\n        \"\"\"Create a new account for a user\"\"\"\n        command = self.mapper.map(create_account_dto, CreateAccountCommand)\n        command.user_id = user_id\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#error-handling","title":"\ud83d\udee1\ufe0f Error Handling","text":""},{"location":"features/mvc-controllers/#built-in-error-responses","title":"Built-in Error Responses","text":"<p>Controllers include standard error responses:</p> <pre><code>class UsersController(ControllerBase):\n\n    @get(\"/{user_id}\", \n         response_model=UserDto,\n         responses=ControllerBase.error_responses)  # Adds 400, 404, 500 responses\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        \"\"\"Get user by ID\"\"\"\n        query = GetUserByIdQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)  # Automatically handles error responses\n</code></pre>"},{"location":"features/mvc-controllers/#custom-error-handling","title":"Custom Error Handling","text":"<p>Add custom error handling:</p> <pre><code>from fastapi import HTTPException\n\nclass UsersController(ControllerBase):\n\n    @post(\"/\", response_model=UserDto, status_code=status.HTTP_201_CREATED)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        \"\"\"Create a new user\"\"\"\n        try:\n            command = self.mapper.map(create_user_dto, CreateUserCommand)\n            result = await self.mediator.execute_async(command)\n            return self.process(result)\n\n        except EmailAlreadyExistsException:\n            raise HTTPException(\n                status_code=status.HTTP_409_CONFLICT,\n                detail=\"A user with this email already exists\"\n            )\n        except ValidationException as ex:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=str(ex)\n            )\n</code></pre>"},{"location":"features/mvc-controllers/#global-error-handling","title":"Global Error Handling","text":"<p>Use middleware for global error handling:</p> <pre><code>from neuroglia.hosting.web import ExceptionHandlingMiddleware\n\n# In main.py\napp.add_middleware(ExceptionHandlingMiddleware, service_provider=app.services)\n</code></pre>"},{"location":"features/mvc-controllers/#authentication-authorization","title":"\ud83d\udd10 Authentication &amp; Authorization","text":""},{"location":"features/mvc-controllers/#dependency-injection-for-auth","title":"Dependency Injection for Auth","text":"<p>Inject authentication services:</p> <pre><code>from fastapi import Depends\nfrom neuroglia.security import IAuthService, AuthUser\n\nclass UsersController(ControllerBase):\n\n    def __init__(self, \n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator,\n                 auth_service: IAuthService):\n        super().__init__(service_provider, mapper, mediator)\n        self.auth_service = auth_service\n\n    @get(\"/profile\", response_model=UserDto)\n    async def get_current_user(self, \n                              current_user: AuthUser = Depends(auth_service.get_current_user)) -&gt; UserDto:\n        \"\"\"Get current user's profile\"\"\"\n        query = GetUserByIdQuery(user_id=current_user.user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#role-based-authorization","title":"Role-based Authorization","text":"<p>Implement role-based access control:</p> <pre><code>from neuroglia.security import require_role\n\nclass UsersController(ControllerBase):\n\n    @get(\"/\", response_model=List[UserDto])\n    @require_role(\"admin\")  # Custom decorator\n    async def get_all_users(self) -&gt; List[UserDto]:\n        \"\"\"Get all users (admin only)\"\"\"\n        query = GetAllUsersQuery()\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @delete(\"/{user_id}\")\n    @require_role([\"admin\", \"manager\"])  # Multiple roles\n    async def delete_user(self, user_id: str):\n        \"\"\"Delete a user (admin or manager only)\"\"\"\n        command = DeleteUserCommand(user_id=user_id)\n        result = await self.mediator.execute_async(command)\n        self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#response-processing","title":"\ud83d\udcca Response Processing","text":""},{"location":"features/mvc-controllers/#the-process-method","title":"The <code>process</code> Method","text":"<p>The <code>process</code> method handles <code>OperationResult</code> objects automatically:</p> <pre><code># OperationResult with data\nresult = OperationResult.success(user_dto)\nreturn self.process(result)  # Returns user_dto with 200 status\n\n# OperationResult with error\nresult = OperationResult.not_found(\"User not found\")\nreturn self.process(result)  # Raises HTTPException with 404 status\n\n# OperationResult created\nresult = OperationResult.created(user_dto)\nreturn self.process(result)  # Returns user_dto with 201 status\n</code></pre>"},{"location":"features/mvc-controllers/#custom-response-processing","title":"Custom Response Processing","text":"<p>Override response processing for special cases:</p> <pre><code>class UsersController(ControllerBase):\n\n    @get(\"/{user_id}\", response_model=UserDto)\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        \"\"\"Get user by ID\"\"\"\n        query = GetUserByIdQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n\n        # Custom processing\n        if not result.is_success:\n            if result.status_code == 404:\n                # Log the attempt\n                self.logger.warning(f\"Attempt to access non-existent user: {user_id}\")\n            return self.process(result)\n\n        # Add custom headers for successful responses\n        response = self.process(result)\n        # Custom logic here\n        return response\n</code></pre>"},{"location":"features/mvc-controllers/#testing-controllers","title":"\ud83e\uddea Testing Controllers","text":""},{"location":"features/mvc-controllers/#unit-testing","title":"Unit Testing","text":"<p>Test controllers with mocked dependencies:</p> <pre><code>import pytest\nfrom unittest.mock import Mock, AsyncMock\n\n@pytest.mark.asyncio\nasync def test_get_user_success():\n    # Arrange\n    mock_mediator = Mock()\n    mock_mediator.execute_async = AsyncMock(return_value=OperationResult.success(test_user_dto))\n\n    controller = UsersController(\n        service_provider=mock_service_provider,\n        mapper=mock_mapper,\n        mediator=mock_mediator\n    )\n\n    # Act\n    result = await controller.get_user(\"user123\")\n\n    # Assert\n    assert result == test_user_dto\n    mock_mediator.execute_async.assert_called_once()\n</code></pre>"},{"location":"features/mvc-controllers/#integration-testing","title":"Integration Testing","text":"<p>Test controllers with TestClient:</p> <pre><code>from fastapi.testclient import TestClient\n\ndef test_create_user_integration():\n    # Arrange\n    client = TestClient(app)\n    user_data = {\n        \"email\": \"test@example.com\",\n        \"first_name\": \"John\",\n        \"last_name\": \"Doe\"\n    }\n\n    # Act\n    response = client.post(\"/api/v1/users\", json=user_data)\n\n    # Assert\n    assert response.status_code == 201\n\n    created_user = response.json()\n    assert created_user[\"email\"] == user_data[\"email\"]\n    assert \"id\" in created_user\n</code></pre>"},{"location":"features/mvc-controllers/#api-testing","title":"API Testing","text":"<p>Test the complete API flow:</p> <pre><code>def test_user_crud_flow():\n    client = TestClient(app)\n\n    # Create user\n    create_response = client.post(\"/api/v1/users\", json=test_user_data)\n    assert create_response.status_code == 201\n    user = create_response.json()\n    user_id = user[\"id\"]\n\n    # Get user\n    get_response = client.get(f\"/api/v1/users/{user_id}\")\n    assert get_response.status_code == 200\n    assert get_response.json()[\"id\"] == user_id\n\n    # Update user\n    update_data = {\"first_name\": \"Jane\"}\n    update_response = client.put(f\"/api/v1/users/{user_id}\", json=update_data)\n    assert update_response.status_code == 200\n    assert update_response.json()[\"first_name\"] == \"Jane\"\n\n    # Delete user\n    delete_response = client.delete(f\"/api/v1/users/{user_id}\")\n    assert delete_response.status_code == 204\n\n    # Verify deletion\n    get_deleted_response = client.get(f\"/api/v1/users/{user_id}\")\n    assert get_deleted_response.status_code == 404\n</code></pre>"},{"location":"features/mvc-controllers/#best-practices","title":"\ud83d\ude80 Best Practices","text":""},{"location":"features/mvc-controllers/#1-keep-controllers-thin","title":"1. Keep Controllers Thin","text":"<p>Controllers should delegate to the application layer:</p> <pre><code># Good - Thin controller\nclass UsersController(ControllerBase):\n    @post(\"/\", response_model=UserDto)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n# Avoid - Business logic in controller\nclass UsersController(ControllerBase):\n    @post(\"/\", response_model=UserDto)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        # Validate email\n        if not self.is_valid_email(create_user_dto.email):\n            raise HTTPException(400, \"Invalid email\")\n\n        # Check if user exists\n        existing = await self.user_repo.get_by_email(create_user_dto.email)\n        if existing:\n            raise HTTPException(409, \"User exists\")\n\n        # Create user\n        user = User(...)\n        # ... more business logic\n</code></pre>"},{"location":"features/mvc-controllers/#2-use-dtos-for-api-contracts","title":"2. Use DTOs for API Contracts","text":"<p>Always use DTOs to define your API contracts:</p> <pre><code># API DTOs\nclass CreateUserDto(BaseModel):\n    email: str\n    first_name: str\n    last_name: str\n\nclass UserDto(BaseModel):\n    id: str\n    email: str\n    first_name: str\n    last_name: str\n    created_at: datetime\n\n# Domain entities stay separate\nclass User(Entity[str]):\n    def __init__(self, email: str, first_name: str, last_name: str):\n        # Domain logic\n        pass\n</code></pre>"},{"location":"features/mvc-controllers/#3-consistent-error-handling","title":"3. Consistent Error Handling","text":"<p>Use consistent patterns for error handling:</p> <pre><code>class UsersController(ControllerBase):\n\n    @get(\"/{user_id}\", \n         response_model=UserDto,\n         responses={\n             404: {\"description\": \"User not found\"},\n             400: {\"description\": \"Invalid user ID format\"}\n         })\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        # Validate input format\n        if not self.is_valid_uuid(user_id):\n            return self.bad_request(\"Invalid user ID format\")\n\n        # Execute query\n        query = GetUserByIdQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n\n        # Process will handle 404 automatically\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#4-document-your-apis","title":"4. Document Your APIs","text":"<p>Provide comprehensive API documentation:</p> <pre><code>class UsersController(ControllerBase):\n\n    @post(\"/\",\n          response_model=UserDto,\n          status_code=status.HTTP_201_CREATED,\n          summary=\"Create a new user\",\n          description=\"Creates a new user account in the system\",\n          response_description=\"The created user\",\n          tags=[\"User Management\"])\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        \"\"\"\n        Create a new user account.\n\n        - **email**: User's email address (must be unique)\n        - **first_name**: User's first name\n        - **last_name**: User's last name\n\n        Returns the created user with generated ID and timestamps.\n        \"\"\"\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#5-version-your-apis","title":"5. Version Your APIs","text":"<p>Plan for API versioning:</p> <pre><code># v1 controller\nclass V1UsersController(ControllerBase):\n    def __init__(self, service_provider, mapper, mediator):\n        super().__init__(service_provider, mapper, mediator)\n        self.router.prefix = \"/v1/users\"\n\n# v2 controller with breaking changes\nclass V2UsersController(ControllerBase):\n    def __init__(self, service_provider, mapper, mediator):\n        super().__init__(service_provider, mapper, mediator)\n        self.router.prefix = \"/v2/users\"\n</code></pre>"},{"location":"features/mvc-controllers/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Basic controller usage</li> <li>Architecture Guide - How controllers fit in the architecture</li> <li>CQRS &amp; Mediation - Using mediator in controllers</li> <li>Dependency Injection - DI in controllers</li> <li>Data Access - Working with data in controllers</li> </ul>"},{"location":"samples/api_gateway/","title":"\ud83d\ude80 API Gateway Sample Application","text":"<p>The API Gateway sample demonstrates how to build a modern microservice gateway using the Neuroglia framework. This application showcases advanced patterns including OAuth2 authentication, external service integration, background task processing, and cloud event handling.</p>"},{"location":"samples/api_gateway/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>Microservice Gateway Patterns: How to build a centralized API gateway for service orchestration</li> <li>OAuth2 Authentication &amp; Authorization: Implementing JWT-based security with Keycloak integration</li> <li>External Service Integration: Connecting to multiple external APIs with proper abstraction</li> <li>Background Task Processing: Asynchronous task execution with Redis-backed job scheduling</li> <li>Object Storage Integration: File management with MinIO S3-compatible storage</li> <li>Cloud Events: Event-driven communication between microservices</li> <li>Advanced Dependency Injection: Complex service configuration and lifetime management</li> </ul>"},{"location":"samples/api_gateway/#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<pre><code>graph TB\n    subgraph \"API Gateway Service\"\n        A[PromptController] --&gt; B[Mediator]\n        B --&gt; C[Command/Query Handlers]\n        C --&gt; D[Domain Models]\n        C --&gt; E[Integration Services]\n\n        F[OAuth2 Middleware] --&gt; A\n        G[Cloud Event Middleware] --&gt; A\n        H[Exception Handling] --&gt; A\n    end\n\n    subgraph \"External Dependencies\"\n        I[Keycloak OAuth2]\n        J[Redis Cache]\n        K[MinIO Storage]\n        L[External APIs]\n        M[Background Tasks]\n    end\n\n    E --&gt; I\n    E --&gt; J\n    E --&gt; K\n    E --&gt; L\n    C --&gt; M\n</code></pre> <p>The API Gateway follows a distributed microservice pattern where:</p> <ul> <li>Gateway Layer: Centralized entry point for multiple downstream services</li> <li>Authentication Layer: OAuth2/JWT-based security with external identity provider</li> <li>Integration Layer: Multiple external service clients with proper abstraction</li> <li>DTOs: Data transfer objects for external communication</li> </ul>"},{"location":"samples/api_gateway/#key-features-demonstrated","title":"\ud83d\ude80 Key Features Demonstrated","text":""},{"location":"samples/api_gateway/#1-oauth2-authentication-security","title":"1. OAuth2 Authentication &amp; Security","text":"<pre><code># JWT token validation with Keycloak\n@post(\"/item\", response_model=ItemPromptCommandResponseDto)\nasync def create_new_item_prompt(\n    self, \n    command_dto: CreateNewItemPromptCommandDto, \n    key: str = Depends(validate_mosaic_authentication)\n) -&gt; Any:\n    # Protected endpoint with API key validation\n</code></pre>"},{"location":"samples/api_gateway/#2-multi-service-integration","title":"2. Multi-Service Integration","text":"<pre><code># External service clients\nMinioStorageManager.configure(builder)          # Object storage\nMosaicApiClient.configure(builder)              # External API\nAsyncStringCacheRepository.configure(builder)   # Redis caching\nBackgroundTaskScheduler.configure(builder)      # Async processing\n</code></pre>"},{"location":"samples/api_gateway/#3-advanced-domain-model","title":"3. Advanced Domain Model","text":"<pre><code>@map_to(PromptResponseDto)\n@dataclass\nclass PromptResponse:\n    id: str\n    prompt_id: str\n    content: str\n    status: PromptStatus\n    metadata: dict[str, Any]\n    created_at: datetime.datetime\n</code></pre>"},{"location":"samples/api_gateway/#4-background-task-processing","title":"4. Background Task Processing","text":"<pre><code># Asynchronous task execution\nBackgroundTaskScheduler.configure(builder, [\"application.tasks\"])\n\n# Redis-backed job queue\nbackground_job_store: dict[str, str | int] = {\n    \"redis_host\": \"redis47\", \n    \"redis_port\": 6379, \n    \"redis_db\": 0\n}\n</code></pre>"},{"location":"samples/api_gateway/#5-cloud-events-integration","title":"5. Cloud Events Integration","text":"<pre><code># Event publishing and consumption\nCloudEventIngestor.configure(builder, [\"application.events.integration\"])\nCloudEventPublisher.configure(builder)\napp.add_middleware(CloudEventMiddleware, service_provider=app.services)\n</code></pre>"},{"location":"samples/api_gateway/#configuration-settings","title":"\ud83d\udd27 Configuration &amp; Settings","text":""},{"location":"samples/api_gateway/#application-settings","title":"Application Settings","text":"<pre><code>class AiGatewaySettings(ApplicationSettings):\n    # OAuth2 Configuration\n    jwt_authority: str = \"http://keycloak47/realms/mozart\"\n    jwt_audience: str = \"ai-gateways\"\n    required_scope: str = \"api\"\n\n    # External Service Settings\n    s3_endpoint: str                    # MinIO storage\n    connection_strings: dict[str, str]  # Redis, databases\n    mosaic_api_keys: list[str]         # API authentication\n\n    # Background Processing\n    background_job_store: dict[str, str | int]\n    redis_max_connections: int = 10\n</code></pre>"},{"location":"samples/api_gateway/#service-registration","title":"Service Registration","text":"<pre><code># Core framework services\nMapper.configure(builder, application_modules)\nMediator.configure(builder, application_modules)\nJsonSerializer.configure(builder)\n\n# Custom application services\nAsyncStringCacheRepository.configure(builder, Prompt, str)\nBackgroundTaskScheduler.configure(builder, [\"application.tasks\"])\nMinioStorageManager.configure(builder)\nLocalFileSystemManager.configure(builder)\n\n# External integrations\nbuilder.services.add_singleton(AiGatewaySettings, singleton=app_settings)\n</code></pre>"},{"location":"samples/api_gateway/#testing-strategy","title":"\ud83e\uddea Testing Strategy","text":""},{"location":"samples/api_gateway/#unit-tests","title":"Unit Tests","text":"<pre><code>class TestPromptController:\n    def setup_method(self):\n        self.mock_mediator = Mock(spec=Mediator)\n        self.mock_mapper = Mock(spec=Mapper)\n        self.controller = PromptController(\n            service_provider=Mock(),\n            mapper=self.mock_mapper,\n            mediator=self.mock_mediator\n        )\n\n    @pytest.mark.asyncio\n    async def test_create_prompt_success(self):\n        # Test successful prompt creation\n        command_dto = CreateNewItemPromptCommandDto(content=\"test\")\n        result = await self.controller.create_new_item_prompt(command_dto, \"valid-key\")\n\n        assert result.status == \"created\"\n        self.mock_mediator.execute_async.assert_called_once()\n</code></pre>"},{"location":"samples/api_gateway/#integration-tests","title":"Integration Tests","text":"<pre><code>@pytest.mark.integration\nclass TestApiGatewayIntegration:\n    @pytest.mark.asyncio\n    async def test_full_prompt_workflow(self, test_client):\n        # Test complete workflow from API to external services\n        response = await test_client.post(\n            \"/api/prompts/item\",\n            json={\"content\": \"test prompt\"},\n            headers={\"Authorization\": \"Bearer valid-token\"}\n        )\n\n        assert response.status_code == 201\n        assert \"id\" in response.json()\n</code></pre>"},{"location":"samples/api_gateway/#implementation-details","title":"\ud83d\udcda Implementation Details","text":""},{"location":"samples/api_gateway/#1-controller-layer-apicontrollers","title":"1. Controller Layer (<code>api/controllers/</code>)","text":"<ul> <li>PromptController: Main API endpoints for prompt management</li> <li>AppController: Application health and metadata endpoints</li> <li>InternalController: Internal service endpoints</li> <li>Authentication Schemes: OAuth2 and API key validation</li> </ul>"},{"location":"samples/api_gateway/#2-application-layer-application","title":"2. Application Layer (<code>application/</code>)","text":"<ul> <li>Commands: Write operations (CreateNewPromptCommand)</li> <li>Queries: Read operations (GetPromptByIdQuery)</li> <li>Services: Business logic orchestration</li> <li>Tasks: Background job definitions</li> <li>Events: Integration event handlers</li> </ul>"},{"location":"samples/api_gateway/#3-domain-layer-domain","title":"3. Domain Layer (<code>domain/</code>)","text":"<ul> <li>Prompt: Core domain entity with business rules</li> <li>PromptResponse: Value object for API responses</li> <li>Domain Events: Business event definitions</li> <li>Validation: Domain-specific validation logic</li> </ul>"},{"location":"samples/api_gateway/#4-integration-layer-integration","title":"4. Integration Layer (<code>integration/</code>)","text":"<ul> <li>External API Clients: Mosaic, GenAI, Mozart APIs</li> <li>Storage Services: MinIO object storage, Redis caching</li> <li>Background Services: Task scheduling and execution</li> <li>DTOs: Data transfer objects for external communication</li> </ul>"},{"location":"samples/api_gateway/#background-processing","title":"\ud83d\udd04 Background Processing","text":"<p>The API Gateway demonstrates advanced background processing patterns:</p> <pre><code># Task scheduling configuration\nBackgroundTaskScheduler.configure(builder, [\"application.tasks\"])\n\n# Redis-backed job store\nbuilder.services.add_singleton(AiGatewaySettings, singleton=app_settings)\n\n# Asynchronous task execution\n@task_handler\nclass ProcessPromptTask:\n    async def execute_async(self, prompt_id: str):\n        # Long-running prompt processing\n        prompt = await self.prompt_service.get_by_id(prompt_id)\n        result = await self.genai_client.process_prompt(prompt)\n        await self.storage_service.store_result(result)\n</code></pre>"},{"location":"samples/api_gateway/#external-service-integration","title":"\ud83c\udf10 External Service Integration","text":""},{"location":"samples/api_gateway/#minio-object-storage","title":"MinIO Object Storage","text":"<pre><code>class MinioStorageManager:\n    async def upload_file_async(self, bucket: str, key: str, data: bytes) -&gt; str:\n        # S3-compatible object storage\n        return await self.client.put_object(bucket, key, data)\n</code></pre>"},{"location":"samples/api_gateway/#redis-caching","title":"Redis Caching","text":"<pre><code>class AsyncStringCacheRepository:\n    async def get_async(self, key: str) -&gt; Optional[str]:\n        return await self.redis_client.get(key)\n\n    async def set_async(self, key: str, value: str, ttl: int = None):\n        await self.redis_client.set(key, value, ex=ttl)\n</code></pre>"},{"location":"samples/api_gateway/#external-api-integration","title":"External API Integration","text":"<pre><code>class MosaicApiClient:\n    async def submit_prompt_async(self, prompt: PromptDto) -&gt; PromptResponseDto:\n        # OAuth2 authenticated API calls\n        token = await self.get_access_token()\n        response = await self.http_client.post(\n            \"/api/prompts\",\n            json=prompt.dict(),\n            headers={\"Authorization\": f\"Bearer {token}\"}\n        )\n        return PromptResponseDto.parse_obj(response.json())\n</code></pre>"},{"location":"samples/api_gateway/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"samples/api_gateway/#1-prerequisites","title":"1. Prerequisites","text":"<pre><code># Install dependencies\npip install -r requirements.txt\n\n# Configure external services\ndocker-compose up -d redis keycloak minio\n</code></pre>"},{"location":"samples/api_gateway/#2-configuration","title":"2. Configuration","text":"<pre><code># Set environment variables\nexport JWT_AUTHORITY=\"http://localhost:8080/realms/mozart\"\nexport S3_ENDPOINT=\"http://localhost:9000\"\nexport REDIS_URL=\"redis://localhost:6379\"\n</code></pre>"},{"location":"samples/api_gateway/#3-run-the-application","title":"3. Run the Application","text":"<pre><code># Start the API Gateway\npython samples/api-gateway/main.py\n\n# Access Swagger UI\nopen http://localhost:8000/docs\n</code></pre>"},{"location":"samples/api_gateway/#4-test-the-api","title":"4. Test the API","text":"<pre><code># Get access token from Keycloak\ncurl -X POST http://localhost:8080/realms/mozart/protocol/openid-connect/token \\\n  -H \"Content-Type: application/x-www-form-urlencoded\" \\\n  -d \"grant_type=client_credentials&amp;client_id=ai-gateway&amp;client_secret=secret\"\n\n# Call protected endpoint\ncurl -X POST http://localhost:8000/api/prompts/item \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"content\": \"Generate a sample prompt\"}'\n</code></pre>"},{"location":"samples/api_gateway/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>CQRS &amp; Mediation - Command/Query patterns</li> <li>Dependency Injection - Service configuration</li> <li>Data Access - Repository patterns</li> <li>OpenBank Sample - Event sourcing comparison</li> <li>Desktop Controller Sample - Background services</li> </ul>"},{"location":"samples/api_gateway/#comparison-with-openbank-sample","title":"\ud83d\udd0d Comparison with OpenBank Sample","text":"<p>The API Gateway and OpenBank samples demonstrate different architectural patterns within the Neuroglia framework. Here's a detailed comparison:</p>"},{"location":"samples/api_gateway/#architecture-patterns","title":"Architecture Patterns","text":"Aspect API Gateway OpenBank Primary Pattern Microservice Gateway Event Sourcing + DDD Data Persistence Multi-store (Redis, MinIO, MongoDB) Event Store + Read Models State Management Stateless with caching Event-sourced aggregates External Integration Multiple external APIs Focused domain model Background Processing Async task queues Event-driven projections"},{"location":"samples/api_gateway/#domain-complexity","title":"Domain Complexity","text":""},{"location":"samples/api_gateway/#api-gateway-integration-focused","title":"API Gateway - Integration-Focused","text":"<pre><code># Simple domain model focused on orchestration\n@dataclass\nclass PromptResponse:\n    id: str\n    prompt_id: str\n    content: str\n    status: PromptStatus\n    metadata: dict[str, Any]\n</code></pre>"},{"location":"samples/api_gateway/#openbank-rich-domain-model","title":"OpenBank - Rich Domain Model","text":"<pre><code># Complex aggregate with business rules\nclass BankAccountV1(AggregateRoot[str]):\n    def record_transaction(self, amount: Decimal, transaction_type: BankTransactionTypeV1):\n        # Complex business logic and invariants\n        if transaction_type == BankTransactionTypeV1.DEBIT:\n            if self.state.balance + amount &lt; -self.state.overdraft_limit:\n                raise InsufficientFundsException()\n\n        # Event sourcing\n        self.raise_event(BankAccountTransactionRecordedDomainEventV1(...))\n</code></pre>"},{"location":"samples/api_gateway/#data-persistence-strategy","title":"Data Persistence Strategy","text":""},{"location":"samples/api_gateway/#api-gateway-multi-store-architecture","title":"API Gateway - Multi-Store Architecture","text":"<pre><code># Multiple specialized storage systems\nAsyncStringCacheRepository.configure(builder, Prompt, str)  # Redis caching\nMinioStorageManager.configure(builder)                      # Object storage\nBackgroundTaskScheduler.configure(builder)                 # Job queue\n\n# Standard CRUD operations\nasync def save_prompt(self, prompt: Prompt):\n    await self.cache_repository.set_async(prompt.id, prompt.content)\n    await self.storage_manager.upload_async(prompt.id, prompt.data)\n</code></pre>"},{"location":"samples/api_gateway/#openbank-event-sourcing","title":"OpenBank - Event Sourcing","text":"<pre><code># Event-driven persistence\nESEventStore.configure(builder, EventStoreOptions(database_name, consumer_group))\n\n# Write model: Event sourcing\nDataAccessLayer.WriteModel.configure(\n    builder, \n    [\"samples.openbank.domain.models\"], \n    lambda builder_, entity_type, key_type: EventSourcingRepository.configure(...)\n)\n\n# Read model: Projections\nDataAccessLayer.ReadModel.configure(\n    builder,\n    [\"samples.openbank.integration.models\"], \n    lambda builder_, entity_type, key_type: MongoRepository.configure(...)\n)\n</code></pre>"},{"location":"samples/api_gateway/#authentication-security","title":"Authentication &amp; Security","text":""},{"location":"samples/api_gateway/#api-gateway-oauth2-api-keys","title":"API Gateway - OAuth2 + API Keys","text":"<pre><code># Multiple authentication schemes\n@post(\"/item\", dependencies=[Depends(validate_mosaic_authentication)])\nasync def create_item_prompt(self, command_dto: CreateNewItemPromptCommandDto):\n    # API key validation for external services\n\n@get(\"/status\", dependencies=[Depends(validate_token)])\nasync def get_status(self):\n    # JWT token validation for internal services\n</code></pre>"},{"location":"samples/api_gateway/#openbank-domain-focused-security","title":"OpenBank - Domain-Focused Security","text":"<pre><code># Business rule enforcement\nclass BankAccountV1(AggregateRoot[str]):\n    def record_transaction(self, amount: Decimal, transaction_type: BankTransactionTypeV1):\n        # Domain-level authorization\n        if not self.is_authorized_for_transaction(amount):\n            raise UnauthorizedTransactionException()\n</code></pre>"},{"location":"samples/api_gateway/#external-service-integration_1","title":"External Service Integration","text":""},{"location":"samples/api_gateway/#api-gateway-extensive-integration","title":"API Gateway - Extensive Integration","text":"<pre><code># Multiple external service clients\nclass MosaicApiClient:\n    async def submit_prompt_async(self, prompt: PromptDto) -&gt; PromptResponseDto:\n        token = await self.oauth_client.get_token_async()\n        return await self.http_client.post(\"/api/prompts\", prompt, token)\n\nclass GenAiClient:\n    async def process_prompt_async(self, prompt: str) -&gt; str:\n        return await self.ai_service.generate_response(prompt)\n\nclass MinioStorageManager:\n    async def store_file_async(self, bucket: str, key: str, data: bytes):\n        return await self.s3_client.put_object(bucket, key, data)\n</code></pre>"},{"location":"samples/api_gateway/#openbank-minimal-integration","title":"OpenBank - Minimal Integration","text":"<pre><code># Focused on domain logic, minimal external dependencies\nclass CreateBankAccountCommandHandler:\n    async def handle_async(self, command: CreateBankAccountCommand):\n        # Pure domain logic without external service calls\n        owner = await self.person_repository.get_by_id_async(command.owner_id)\n        account = BankAccountV1(str(uuid.uuid4()), owner, command.initial_balance)\n        await self.account_repository.save_async(account)\n</code></pre>"},{"location":"samples/api_gateway/#background-processing_1","title":"Background Processing","text":""},{"location":"samples/api_gateway/#api-gateway-task-queue-pattern","title":"API Gateway - Task Queue Pattern","text":"<pre><code># Redis-backed job queues\nBackgroundTaskScheduler.configure(builder, [\"application.tasks\"])\n\n@task_handler\nclass ProcessPromptTask:\n    async def execute_async(self, prompt_id: str):\n        prompt = await self.prompt_service.get_by_id(prompt_id)\n        result = await self.genai_client.process_prompt(prompt)\n        await self.storage_service.store_result(result)\n</code></pre>"},{"location":"samples/api_gateway/#openbank-event-driven-projections","title":"OpenBank - Event-Driven Projections","text":"<pre><code># Event handlers for read model updates\nclass BankAccountEventHandler:\n    @event_handler(BankAccountCreatedDomainEventV1)\n    async def handle_account_created(self, event: BankAccountCreatedDomainEventV1):\n        projection = BankAccountProjection.from_event(event)\n        await self.read_model_repository.save_async(projection)\n</code></pre>"},{"location":"samples/api_gateway/#testing-strategies","title":"Testing Strategies","text":""},{"location":"samples/api_gateway/#api-gateway-integration-heavy-testing","title":"API Gateway - Integration-Heavy Testing","text":"<pre><code>@pytest.mark.integration\nclass TestApiGatewayIntegration:\n    async def test_full_prompt_workflow(self, test_client, mock_external_services):\n        # Test complete workflow including external services\n        response = await test_client.post(\"/api/prompts/item\", json=prompt_data)\n\n        # Verify external service calls\n        mock_external_services.genai_client.process_prompt.assert_called_once()\n        mock_external_services.storage_manager.upload.assert_called_once()\n</code></pre>"},{"location":"samples/api_gateway/#openbank-domain-focused-testing","title":"OpenBank - Domain-Focused Testing","text":"<pre><code>class TestBankAccountAggregate:\n    def test_transaction_recording(self):\n        # Pure domain logic testing\n        account = BankAccountV1(\"123\", owner, Decimal(\"1000\"))\n        account.record_transaction(Decimal(\"-100\"), BankTransactionTypeV1.DEBIT)\n\n        # Verify business rules and events\n        assert account.state.balance == Decimal(\"900\")\n        events = account.get_uncommitted_events()\n        assert isinstance(events[-1], BankAccountTransactionRecordedDomainEventV1)\n</code></pre>"},{"location":"samples/api_gateway/#use-case-recommendations","title":"Use Case Recommendations","text":""},{"location":"samples/api_gateway/#choose-api-gateway-pattern-when","title":"Choose API Gateway Pattern when","text":"<ul> <li>\u2705 Building microservice orchestration layers</li> <li>\u2705 Integrating multiple external services</li> <li>\u2705 Need background job processing</li> <li>\u2705 Require complex authentication schemes</li> <li>\u2705 Working with heterogeneous data stores</li> <li>\u2705 Building service mesh entry points</li> </ul>"},{"location":"samples/api_gateway/#choose-event-sourcing-pattern-when","title":"Choose Event Sourcing Pattern when","text":"<ul> <li>\u2705 Need complete audit trails</li> <li>\u2705 Complex business logic and invariants</li> <li>\u2705 Temporal queries are important</li> <li>\u2705 Regulatory compliance requirements</li> <li>\u2705 High consistency requirements</li> <li>\u2705 Rich domain models with behavior</li> </ul>"},{"location":"samples/api_gateway/#framework-features-utilized","title":"Framework Features Utilized","text":"Feature API Gateway Usage OpenBank Usage CQRS/Mediation Service orchestration Domain command/query separation Dependency Injection External service clients Repository abstractions Event Handling Integration events Domain events + projections Data Access Multi-repository pattern Event sourcing + read models Background Processing Async task queues Event-driven handlers Mapping DTO transformations Domain-to-DTO mapping Validation API contract validation Business rule enforcement <p>Both samples showcase different strengths of the Neuroglia framework, demonstrating its flexibility in supporting various architectural patterns while maintaining clean architecture principles.</p>"},{"location":"samples/desktop_controller/","title":"Desktop Controller","text":"<p>REST API to remotely control a Desktop (i.e. the Docker Host running the controller) over HTTP.</p> <p>The Controller must:</p> <ol> <li>Register itself periodically (via CloudEvent) to the Desktops Registry (providing its IP address as the identifier to the Registry)</li> <li>Securely expose a set of <code>Commands</code> and <code>Queries</code> via a REST API (with OpenAPI 3.x specs) that enable remote control for the Desktop's <code>HostInfo</code> and <code>UserInfo</code> (wrapping Linux Shell commands as HTTP Requests)</li> <li>Maintain various local files (e.g. <code>/data/hostinfo.json</code>, <code>/data/userinfo.json</code>) that other apps (on the Desktop VM) may rely upon (Screen Logger).</li> <li>Trigger remote execution of custom Shell scripts to be run on the Desktop VM (not the controller's container!)</li> </ol> <p>[[TOC]]</p>"},{"location":"samples/desktop_controller/#overview","title":"Overview","text":""},{"location":"samples/desktop_controller/#controllers-interactions","title":"Controller's Interactions","text":""},{"location":"samples/desktop_controller/#controllers-context","title":"Controller's Context","text":""},{"location":"samples/desktop_controller/#design","title":"Design","text":""},{"location":"samples/desktop_controller/#development","title":"Development","text":""},{"location":"samples/desktop_controller/#setup","title":"Setup","text":"<pre><code># 0. Prerequisites:\n#    Have Python 3.12 installed\n# \n#    - Create/Activate a local python environment (e.g. with pyenv)\n#      pyenv virtualenv 3.12.2 desktop-controller\n#      pyenv activate desktop-controller\n# \n#    - Start Docker Desktop locally\n#\n# 1. Clone the repository\ncd ~/\n\ngit clone git@....\n\ncd desktop-controller\n\n# pip install pre-commit\npre-commit install\n\n# pip install poetry\npoetry lock &amp;&amp; poetry install \n\n# 2. Start the docker-compose stack\n# sudo apt-get install make\nmake up\n\n# 3. Connect the vscode debugger to the running container\n# From vscode: hit F5 (ensure that the \"Run and Debug\" launcher is set to \"Python: Remote Attach\")\n\n# 4. Open the SwaggerUI at http://localhost:9781/api/docs\n\n# 5. Add a Breakpoint, e.g. in api.controllers.userinfo_controller.py:29...\n\n# 6. Send a test request :)\n\n# 7. Enjoy live debugging on your local development\n</code></pre>"},{"location":"samples/desktop_controller/#code-contribution","title":"Code Contribution","text":"<ol> <li>Clone <code>main</code> branch</li> <li>Create new branch, e.g. <code>feat-cmd-userinfo</code> or <code>fix-linux-cmd</code></li> <li>Push the new branch to Gitlab and create a Merge Request into <code>main</code></li> <li>Document the review</li> <li>Approve and merge (may discard the branch if needed)</li> </ol>"},{"location":"samples/desktop_controller/#release-process","title":"Release Process","text":"<ol> <li>Refer to Semantic Versioning</li> <li>Create new Tag in Gitlab &gt; Repository &gt; Tags &gt; New Tag</li> <li>This will trigger Gitlab CI to publish a new container image based on the latest commit in the <code>main</code> branch and will be named as per the new Tag.</li> <li>Test the image locally: <code>docker run -p 8080:80 desktop-controller:latest</code> then browse to http://localhost:8080/api/docs</li> </ol>"},{"location":"samples/desktop_controller/#settings","title":"Settings","text":"<p>Required configuration:</p> <ul> <li>create new SSH key pair</li> <li>install the private key into the container and the public key into the DockerHost/SSH server</li> <li>mount the SSH private key to <code>:/app/id_rsa</code> when starting the container</li> <li>add the pub key to the DockerHost's <code>~/.ssh/authorized_keys</code></li> <li>add env var <code>DOCKER_HOST_USER_NAME</code> with the sys-admin' username on the DockerHost!</li> </ul> <p>See App Settings.</p>"},{"location":"samples/desktop_controller/#testing","title":"Testing","text":"<p>The API has a sample <code>Command</code> that ultimately resolves to remotely run <code>~/test_shell_script_on_host.sh -i {user_input}</code> on the DockerHost. </p> <p>See sample_bin/test_shell_script_on_host.sh.</p> <p>E.g.: Install with</p> <pre><code># copy the sample shell script on the Docker Host' user' home folder\ncp sample_bin/test_shell_script_on_host.sh ~/test_shell_script_on_host.sh\n\n# set permissions to execute\nchmod a+x ~/test_shell_script_on_host.sh\n\n# set ownership\nchown $USERNAME:staff ~/test_shell_script_on_host.sh\n\n# test run as user:\n~/test_shell_script_on_host.sh -i \"my input value\"\n\nAdding a new line my input value to /tmp/test.txt...\n\n# verify local file on Docker Host: \ncat /tmp/test.txt\n\nUserInput: my input value\n</code></pre>"},{"location":"samples/desktop_controller/#test_shell_script_on_hostsh","title":"test_shell_script_on_host.sh","text":"<p>See sample_bin/test_shell_script_on_host.sh.</p> <p>This test script just adds a line to a file <code>/tmp/test.txt</code>.</p> <pre><code>#!/bin/bash\n\n# test_shell_script_on_host.sh\n\nif [ $# -lt 2 ]; then\n  echo \"Error: Please provide an argument after the -i flag.\"\n  exit 1\nfi\n\nif [ \"$1\" != \"-i\" ]; then\n  echo \"Error: Please use the -i flag followed by your argument.\"\n  exit 1\nfi\n\nargument=\"$2\"\n\necho \"Adding a new line $argument to /tmp/test.txt...\"\n\necho \"UserInput: $argument\" &gt;&gt; /tmp/test.txt\n</code></pre>"},{"location":"samples/desktop_controller/#call-test-endpoint","title":"Call Test Endpoint","text":"<p>The HTTP <code>Command</code> runs a SSH client that simply connects to the DockerHost at <code>host.docker.internal</code> (with preconfigured username and SSH keys) and runs a custom command_line.</p> <p>From SwaggerUI</p> <p><code>http://localhost:9781/api/docs#/Custom/run_test_write_file_on_host_api_v1_custom_test_shell_script_on_host_sh_post</code></p> <p>From Curl: (will need <code>Authorization</code> header with JWT, see API Auth)</p> <pre><code>curl -X 'POST' \\\n  'http://localhost:9781/api/v1/custom/test/shell_script_on_host.sh' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n  \"user_input\": \"my input value\"\n}'\n</code></pre> <pre><code># 201   Response body\n{\n  \"command_line\": \"~/test_shell_script_on_host.sh -i my_input_value\",\n  \"stdout\": [\n    \"Adding a new line my_input_value to /tmp/test.txt...\"\n  ],\n  \"stderr\": [],\n  \"aggregate_id\": \"4c660c0572d8449598ee5fde58e04423\",\n  \"success\": true\n}\n</code></pre>"},{"location":"samples/desktop_controller/#api-authentication","title":"API Authentication","text":"<p>We're using Keycloak as the IDP. See <code>deployment/keycloak/realm-config.json</code> for sample keycloak config.</p> <p>The intent is that \"whoever\" wants to remotely control a desktop first needs to get a valid token from the common Keycloak instance (which is the one that the VDI/BYOD Desktops - ie. DockerHosts have access to!).</p> <p>Local testings can be done with a local/dev Keycloak instance. Just include it in <code>docker-compose.yml</code>!</p> <pre><code>version: \"3.4\"\n\nname: mozart-dev\nservices:\n  # http://localhost:9780\n  keycloak97:\n    image: jboss/keycloak\n    environment:\n      - KEYCLOAK_USER=admin\n      - KEYCLOAK_PASSWORD=admin\n      - KEYCLOAK_IMPORT=/tmp/realm-export.json\n    volumes:\n      - ./deployment/keycloak/realm-config.json:/tmp/realm-export.json\n    ports:\n      - 9780:8080\n    networks:\n      - desktopcontrollernet\n</code></pre> <p>Login at http://localhost:9780 using <code>admin</code>:<code>admin</code></p>"},{"location":"samples/desktop_controller/#source-code","title":"Source Code","text":""},{"location":"samples/desktop_controller/#context","title":"Context","text":""},{"location":"samples/desktop_controller/#containers","title":"Containers","text":""},{"location":"samples/desktop_controller/#components","title":"Components","text":""},{"location":"samples/desktop_controller/#code","title":"Code","text":""},{"location":"samples/desktop_controller/#app-settings","title":"App Settings","text":"<pre><code>    environment:\n      APP_TITLE: Remote Desktop Controller\n      LOCAL_DEV: true\n      LOG_LEVEL: DEBUG\n\n      CLOUD_EVENT_SINK: http://event-player97/events/pub\n      CLOUD_EVENT_SOURCE: https://desktop-controller.domain.com\n      CLOUD_EVENT_TYPE_PREFIX: com.domain.desktop-controller\n\n      OAUTH2_SCHEME: client_credentials  # authorization_code or client_credentials\n      JWT_AUTHORITY: http://keycloak97/auth/realms/mozart\n      JWT_SIGNING_KEY: MIIBIj...copy_from_keycloak...elJ3dvQIDAQAB\n      JWT_AUDIENCE: desktops\n      REQUIRED_SCOPE: api\n\n      SWAGGER_UI_JWT_AUTHORITY: http://localhost:9780/auth/realms/mozart\n      SWAGGER_UI_CLIENT_ID: desktop-controller\n      SWAGGER_UI_CLIENT_SECRET: 6Wbr0V1TtgEUPUCRSqHh1T0vYuVyG0aa\n\n      USER_INFO_FILE_NAME: '/tmp/userinfo.json'\n      HOST_INFO_FILE_NAME: '/tmp/hostinfo.json'\n      DOCKER_HOST_USER_NAME: bvandewe  # UPDATE TO YOUR LOCAL USERNAME!\n      DOCKER_HOST_HOST_NAME: host.docker.internal\n</code></pre> <p>Set corresponding <code>ENV VARS</code> in <code>docker-compose.yml</code>.</p> <p>Pydantic settings automatically parses environment variables, see ./src/api/settings.py.</p> <pre><code># ./src/api/settings.py\n\nfrom neuroglia.hosting.abstractions import ApplicationSettings\nfrom pydantic import ConfigDict\n\nclass DesktopControllerSettings(ApplicationSettings):\n    model_config = ConfigDict(extra=\"allow\")\n\n    required_scopes: str\n    jwt_authority: str\n    jwt_signing_key: str\n    jwt_audience: str = \"desktops\"\n    docker_host_user_name: str = \"sys-admin\"\n    userinfo_filename: str = \"/app/data/userinfo.json\"\n    ...\n\napp_settings = DesktopControllerSettings(_env_file=\".env\")\n</code></pre>"},{"location":"samples/desktop_controller/#app-bootup","title":"App Bootup","text":"<p>The <code>main.py</code> file pre-loads all required services using the Dependency Injection mechanism from the neuroglia framework.</p> <p>API Controllers and Application Handlers may then declare any dependencies in their constructor (<code>def __init__(self, my_dependency: RegisteredDependency)</code>) and the framework will provide the instance!</p> <p>See Dependency Injection.</p> <pre><code># ./src/main.py\n...\nbuilder = WebApplicationBuilder()\n\n# required shared resources\nMapper.configure(builder, application_modules)\nMediator.configure(builder, application_modules)\nJsonSerializer.configure(builder)\nCloudEventIngestor.configure(builder, application_modules)\nCloudEventPublisher.configure(builder)\n\n# custom shared resources\n# \n# ADD ANY REQUIRED RESOURCE\nbuilder.services.add_scoped(paramiko.SSHClient, paramiko.SSHClient)\nbuilder.services.add_scoped(SecuredDockerHost, SecuredDockerHost)\nbuilder.services.add_singleton(DockerHostSshClientSettings, singleton=DockerHostSshClientSettings(username=builder.settings.docker_host_user_name))\nbuilder.services.add_scoped(DockerHostCommandRunner, DockerHostCommandRunner)\n\n# app\napp = builder.build()\n...\napp.run()\n</code></pre>"},{"location":"samples/desktop_controller/#dependency-injection","title":"Dependency Injection","text":"<ol> <li>Add a Custom Service source code file (likely in any of the <code>application_modules</code> folder in <code>./src/api/controllers</code> or <code>./src/application/commands</code> or <code>./src/application/queries</code> or <code>./src/application/events</code>) that requires a <code>Dependency</code>:</li> </ol> <pre><code># ./src/application/services/docker_host_command_runner.py\n...\nclass DockerHostCommandRunner:\n    def __init__(self, secured_docker_host: SecuredDockerHost):  # Declare Dependencies!\n        self.secured_docker_host = secured_docker_host\n\n    secured_docker_host: SecuredDockerHost  # Injected when handling a Command!\n\n    async def run(self, command: HostCommand) -&gt; dict[str, Any]:\n        data = {}\n        await self.secured_docker_host.connect()\n        stdout, stderr = await self.secured_docker_host.execute_command(command)\n        await self.secured_docker_host.close()\n        stdout_lines = [line.strip() for line in stdout.splitlines() if line.strip()]\n        data = {\"command_line\": command.line, \"stdout\": stdout_lines, \"stderr\": stderr.splitlines() if stderr else []}\n        return data\n...\n</code></pre> <ol> <li>Add the source code for the dependency itself (likely in <code>./src/integration/services</code>!). It may also include other dependencies! (e.g. <code>DockerHostSshClientSettings</code>!!)</li> </ol> <pre><code># ./src/integration/services/secured_docker_host.py\n...\n\nclass DockerHostSshClientSettings(BaseModel):\n    username: str\n    hostname: str = \"host.docker.internal\"\n    port: int = 22\n    private_key_filename: str = \"/app/id_rsa\"\n...\nclass SecuredDockerHost:\n    \"\"\"Service that Securely provides access to the Docker Host's Shell via SSH.\"\"\"\n\n    def __init__(self, ssh_client: paramiko.SSHClient, ssh_client_settings: DockerHostSshClientSettings):\n        self.hostname: str = ssh_client_settings.hostname\n        self.port: int = ssh_client_settings.port\n        self.username: str = ssh_client_settings.username\n        self.private_key_filename: str = ssh_client_settings.private_key_filename\n        self.ssh_client: paramiko.SSHClient = ssh_client\n        self.ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n\n    async def connect(self):\n        ...\n\n    async def execute_command(self, command: HostCommand):\n        async def run_command(command_line: str):\n            ...\n\n        stdout, stderr = await run_command(command.line)\n        return stdout.decode(), stderr.decode()\n\n    async def close(self):\n        ...\n</code></pre> <ol> <li>Register its service_type (<code>singleton</code>, <code>scoped</code>, <code>transient</code>) in the <code>main.py</code> bootup script</li> </ol> <pre><code># ./src/main.py\n...\nbuilder.services.add_scoped(paramiko.SSHClient, paramiko.SSHClient)\nbuilder.services.add_scoped(SecuredDockerHost, SecuredDockerHost)\nbuilder.services.add_singleton(DockerHostSshClientSettings, singleton=DockerHostSshClientSettings(username=builder.settings.docker_host_user_name))\nbuilder.services.add_scoped(DockerHostCommandRunner, DockerHostCommandRunner)\n...\n</code></pre> <ol> <li>Declare it as a dependency in a consumer Service, e.g. Application's <code>CommandHandler</code>: </li> </ol> <p>Note how the <code>DockerHostCommandRunner</code> is just declared as a dependency in the constructor function <code>__init__</code>! This is the same for the other dependencies (<code>CloudEventBus</code>, <code>CloudEventPublishingOptions</code>)</p> <pre><code>@map_from(TestHostScriptCommandDto)\n@map_to(TestHostScriptCommandDto)\n@dataclass\nclass TestHostScriptCommand(Command):\n    user_input: str\n\nclass TestHostScriptCommandsHandler(CommandHandler[TestHostScriptCommand, OperationResult[Any]]):\n    \"\"\"Represents the service used to handle UserInfo-related Commands\"\"\"\n\n    cloud_event_bus: CloudEventBus\n    \"\"\" Gets the service used to observe the cloud events consumed and produced by the application \"\"\"\n\n    cloud_event_publishing_options: CloudEventPublishingOptions\n    \"\"\" Gets the options used to configure how the application should publish cloud events \"\"\"\n\n    docker_host_command_runner: DockerHostCommandRunner\n\n    def __init__(self, cloud_event_bus: CloudEventBus, cloud_event_publishing_options: CloudEventPublishingOptions, docker_host_command_runner: DockerHostCommandRunner):\n        self.cloud_event_bus = cloud_event_bus\n        self.cloud_event_publishing_options = cloud_event_publishing_options\n        self.docker_host_command_runner = docker_host_command_runner\n\n    async def handle_async(self, command: TestHostScriptCommand) -&gt; OperationResult[Any]:\n        command_id = str(uuid.uuid4()).replace(\"-\", \"\")\n        command_line = HostCommand()\n        data = {}\n        try:\n            line = f\"~/test_shell_script_on_host.sh -i {command.user_input.replace(' ', '_')}\"\n            log.debug(f\"TestHostScriptCommand Line: {line}\")\n            await self.publish_cloud_event_async(DesktopHostCommandReceivedIntegrationEventV1(aggregate_id=command_id, command_line=line))\n\n            command_line.line = line\n            data = await self.docker_host_command_runner.run(command_line)\n            data.update({\"aggregate_id\": command_id})\n            log.debug(f\"TestHostScriptCommand: {data}\")\n\n            await self.publish_cloud_event_async(DesktopHostCommandExecutedIntegrationEventV1(**data))\n            data.update({\"success\": True}) if len(data[\"stderr\"]) == 0 else data.update({\"success\": False})\n            return self.created(data)\n\n        except Exception as ex:\n            return self.bad_request(f\"Exception when trying to run a shell script on the host: {command_line.line}: {data}: {ex}\")\n</code></pre>"},{"location":"samples/desktop_controller/#api-controllers","title":"API Controllers","text":"<ul> <li>inherits ControllerBase</li> </ul> <pre><code># ./src/api/controllers/host_controller.py\n\nclass HostController(ControllerBase):\n    def __init__(self, service_provider: ServiceProviderBase, mapper: Mapper, mediator: Mediator):\n        ControllerBase.__init__(self, service_provider, mapper, mediator)\n\n    @post(\"/info\", response_model=Any, status_code=201, responses=ControllerBase.error_responses)\n    async def set_host_info(self, command_dto: SetHostInfoCommandDto, token: str = Depends(validate_token)) -&gt; Any:\n        \"\"\"Sets data of the hostinfo.json file.\"\"\"\n        log.debug(f\"set_host_info: command_dto:{command_dto}, token={token}\")\n        return self.process(await self.mediator.execute_async(self.mapper.map(command_dto, SetHostInfoCommand)))\n\n    @get(\"/info\", response_model=Any, status_code=201, responses=ControllerBase.error_responses)\n    async def get_host_info(self):\n        query = ReadHostInfoQuery()\n        log.debug(f\"get_host_info: query:{query}\")\n        return self.process(await self.mediator.execute_async(query))\n</code></pre>"},{"location":"samples/open_bank/","title":"\ud83c\udfe6 OpenBank Sample Application","text":"<p>The OpenBank sample demonstrates event sourcing and domain-driven design patterns using the Neuroglia framework. This application showcases how to build a banking system with complete audit trails, event-driven architecture, and CQRS implementation.</p>"},{"location":"samples/open_bank/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>Event Sourcing: Complete audit trail with event-driven state reconstruction</li> <li>Domain-Driven Design: Rich domain models with business logic and invariants</li> <li>CQRS Implementation: Separate read and write models for optimal performance</li> <li>Aggregate Root Pattern: Domain entity lifecycle management and consistency</li> <li>Event Store Integration: Persistent event streams with EventStoreDB</li> <li>Domain Events: Business event modeling and handling</li> <li>Clean Architecture: Strict layer separation and dependency inversion</li> </ul>"},{"location":"samples/open_bank/#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<pre><code>graph TB\n    subgraph \"OpenBank Service\"\n        A[Controllers] --&gt; B[Mediator]\n        B --&gt; C[Command Handlers]\n        B --&gt; D[Query Handlers]\n        C --&gt; E[Domain Aggregates]\n        D --&gt; F[Read Models]\n\n        E --&gt; G[Domain Events]\n        G --&gt; H[Event Handlers]\n        H --&gt; I[Read Model Updates]\n    end\n\n    subgraph \"Persistence Layer\"\n        J[EventStore - Write Model]\n        K[MongoDB - Read Model]\n    end\n\n    C --&gt; J\n    D --&gt; K\n    H --&gt; K\n</code></pre> <p>The OpenBank follows an event-sourced domain model where:</p> <ul> <li>Write Model: Event-sourced aggregates stored in EventStoreDB</li> <li>Read Model: Denormalized projections stored in MongoDB  </li> <li>Event Handlers: Update read models based on domain events</li> <li>Complete Audit Trail: Every state change is captured as an immutable event</li> </ul>"},{"location":"samples/open_bank/#key-features-demonstrated","title":"\ud83d\ude80 Key Features Demonstrated","text":""},{"location":"samples/open_bank/#1-event-sourced-aggregates","title":"1. Event-Sourced Aggregates","text":"<pre><code>class BankAccountV1(AggregateRoot[str]):\n    def __init__(self, id: str, owner: Person, initial_balance: Decimal):\n        super().__init__(id)\n\n        # Raise domain event\n        self.raise_event(BankAccountCreatedDomainEventV1(\n            aggregate_id=id,\n            owner_id=owner.id,\n            initial_balance=initial_balance,\n            created_at=datetime.utcnow()\n        ))\n\n    def record_transaction(self, amount: Decimal, transaction_type: BankTransactionTypeV1):\n        # Business rule validation\n        if transaction_type == BankTransactionTypeV1.DEBIT:\n            if self.state.balance + amount &lt; -self.state.overdraft_limit:\n                raise InsufficientFundsException()\n\n        # Record the transaction event\n        self.raise_event(BankAccountTransactionRecordedDomainEventV1(\n            aggregate_id=self.id,\n            transaction_id=str(uuid.uuid4()),\n            amount=amount,\n            transaction_type=transaction_type\n        ))\n</code></pre>"},{"location":"samples/open_bank/#2-event-store-configuration","title":"2. Event Store Configuration","text":"<pre><code># Event sourcing repository setup\nESEventStore.configure(builder, EventStoreOptions(database_name, consumer_group))\n\n# Write model with event sourcing\nDataAccessLayer.WriteModel.configure(\n    builder, \n    [\"samples.openbank.domain.models\"], \n    lambda builder_, entity_type, key_type: EventSourcingRepository.configure(\n        builder_, entity_type, key_type\n    )\n)\n\n# Read model with MongoDB\nDataAccessLayer.ReadModel.configure(\n    builder,\n    [\"samples.openbank.integration.models\", \"samples.openbank.application.events\"],\n    lambda builder_, entity_type, key_type: MongoRepository.configure(\n        builder_, entity_type, key_type, database_name\n    )\n)\n</code></pre>"},{"location":"samples/open_bank/#3-aggregate-state-management","title":"3. Aggregate State Management","text":"<pre><code>@map_to(BankAccountDto)\nclass BankAccountStateV1(AggregateState[str]):\n    owner_id: str\n    transactions: List[BankTransactionV1] = []\n    balance: Decimal\n    overdraft_limit: Decimal\n\n    @dispatch(BankAccountCreatedDomainEventV1)\n    def on(self, e: BankAccountCreatedDomainEventV1):\n        self.id = e.aggregate_id\n        self.owner_id = e.owner_id\n        self.balance = e.initial_balance\n        self.overdraft_limit = Decimal(\"0.00\")\n\n    @dispatch(BankAccountTransactionRecordedDomainEventV1)\n    def on(self, e: BankAccountTransactionRecordedDomainEventV1):\n        transaction = BankTransactionV1(\n            id=e.transaction_id,\n            amount=e.amount,\n            type=e.transaction_type,\n            recorded_at=e.occurred_at\n        )\n        self.transactions.append(transaction)\n        self.balance += e.amount\n</code></pre>"},{"location":"samples/open_bank/#4-domain-event-handlers","title":"4. Domain Event Handlers","text":"<pre><code>class BankAccountEventHandler:\n    @event_handler(BankAccountCreatedDomainEventV1)\n    async def handle_account_created(self, event: BankAccountCreatedDomainEventV1):\n        # Update read model projections\n        account_projection = BankAccountProjection(\n            id=event.aggregate_id,\n            owner_id=event.owner_id,\n            balance=event.initial_balance,\n            created_at=event.occurred_at\n        )\n        await self.read_model_repository.save_async(account_projection)\n</code></pre>"},{"location":"samples/open_bank/#5-command-and-query-separation","title":"5. Command and Query Separation","text":"<pre><code># Command for state changes\n@dataclass\nclass CreateBankAccountCommand(Command[OperationResult[BankAccountDto]]):\n    owner_id: str\n    initial_balance: Decimal\n\nclass CreateBankAccountCommandHandler(CommandHandler[CreateBankAccountCommand, OperationResult[BankAccountDto]]):\n    async def handle_async(self, command: CreateBankAccountCommand) -&gt; OperationResult[BankAccountDto]:\n        owner = await self.person_repository.get_by_id_async(command.owner_id)\n\n        account = BankAccountV1(\n            id=str(uuid.uuid4()),\n            owner=owner,\n            initial_balance=command.initial_balance\n        )\n\n        await self.write_repository.save_async(account)\n        return self.created(self.mapper.map(account.state, BankAccountDto))\n\n# Query for data retrieval\n@dataclass\nclass AccountsByOwnerQuery(Query[List[BankAccountDto]]):\n    owner_id: str\n\nclass AccountsByOwnerQueryHandler(QueryHandler[AccountsByOwnerQuery, List[BankAccountDto]]):\n    async def handle_async(self, query: AccountsByOwnerQuery) -&gt; List[BankAccountDto]:\n        accounts = await self.read_repository.find_async(\n            {\"owner_id\": query.owner_id}\n        )\n        return [self.mapper.map(acc, BankAccountDto) for acc in accounts]\n</code></pre>"},{"location":"samples/open_bank/#testing-strategy","title":"\ud83e\uddea Testing Strategy","text":""},{"location":"samples/open_bank/#event-sourcing-tests","title":"Event Sourcing Tests","text":"<pre><code>class TestBankAccountAggregate:\n    def test_account_creation_raises_event(self):\n        owner = Person(\"john.doe@example.com\", \"John\", \"Doe\")\n        account = BankAccountV1(\"acc-123\", owner, Decimal(\"1000.00\"))\n\n        events = account.get_uncommitted_events()\n        assert len(events) == 1\n        assert isinstance(events[0], BankAccountCreatedDomainEventV1)\n        assert events[0].initial_balance == Decimal(\"1000.00\")\n\n    def test_transaction_recording_updates_balance(self):\n        account = self._create_test_account()\n\n        account.record_transaction(Decimal(\"-100.00\"), BankTransactionTypeV1.DEBIT)\n\n        assert account.state.balance == Decimal(\"900.00\")\n        events = account.get_uncommitted_events()\n        assert any(isinstance(e, BankAccountTransactionRecordedDomainEventV1) for e in events)\n\n    def test_insufficient_funds_raises_exception(self):\n        account = self._create_test_account()\n\n        with pytest.raises(InsufficientFundsException):\n            account.record_transaction(Decimal(\"-2000.00\"), BankTransactionTypeV1.DEBIT)\n</code></pre>"},{"location":"samples/open_bank/#integration-tests","title":"Integration Tests","text":"<pre><code>@pytest.mark.integration\nclass TestBankingWorkflow:\n    @pytest.mark.asyncio\n    async def test_complete_banking_workflow(self, test_client):\n        # Create person\n        person_response = await test_client.post(\"/api/persons\", json={\n            \"email\": \"john@example.com\",\n            \"firstName\": \"John\", \n            \"lastName\": \"Doe\"\n        })\n        person_id = person_response.json()[\"id\"]\n\n        # Create bank account\n        account_response = await test_client.post(\"/api/accounts/create\", json={\n            \"ownerId\": person_id,\n            \"initialBalance\": \"1000.00\"\n        })\n        account_id = account_response.json()[\"id\"]\n\n        # Record transaction\n        transaction_response = await test_client.post(\"/api/transactions/record\", json={\n            \"accountId\": account_id,\n            \"amount\": \"-100.00\",\n            \"type\": \"DEBIT\"\n        })\n\n        # Verify final state\n        account_response = await test_client.get(f\"/api/accounts/{account_id}\")\n        assert account_response.json()[\"balance\"] == \"900.00\"\n</code></pre>"},{"location":"samples/open_bank/#implementation-details","title":"\ud83d\udcda Implementation Details","text":""},{"location":"samples/open_bank/#1-domain-layer-domainmodels","title":"1. Domain Layer (<code>domain/models/</code>)","text":"<ul> <li>BankAccount: Event-sourced aggregate root with business logic</li> <li>Person: Value object for account ownership</li> <li>BankTransaction: Value object for financial operations</li> <li>Address: Supporting value object for person details</li> </ul>"},{"location":"samples/open_bank/#2-application-layer-application","title":"2. Application Layer (<code>application/</code>)","text":"<ul> <li>Commands: Account creation, transaction recording</li> <li>Queries: Account lookup, transaction history</li> <li>Event Handlers: Read model projection updates</li> <li>Mapping: Object-to-object transformations</li> </ul>"},{"location":"samples/open_bank/#3-integration-layer-integration","title":"3. Integration Layer (<code>integration/</code>)","text":"<ul> <li>Read Models: Denormalized projections for queries</li> <li>DTOs: API data transfer objects</li> <li>Commands: External command contracts</li> </ul>"},{"location":"samples/open_bank/#4-api-layer-apicontrollers","title":"4. API Layer (<code>api/controllers/</code>)","text":"<ul> <li>AccountsController: Account management endpoints</li> <li>PersonsController: Person management endpoints  </li> <li>TransactionsController: Transaction operations</li> </ul>"},{"location":"samples/open_bank/#event-sourcing-benefits","title":"\ud83d\udd04 Event Sourcing Benefits","text":""},{"location":"samples/open_bank/#complete-audit-trail","title":"Complete Audit Trail","text":"<pre><code># Every state change is captured as an immutable event\nevents = [\n    BankAccountCreatedDomainEventV1(account_id=\"123\", initial_balance=1000.00),\n    BankAccountTransactionRecordedDomainEventV1(account_id=\"123\", amount=-100.00),\n    BankAccountTransactionRecordedDomainEventV1(account_id=\"123\", amount=50.00),\n]\n\n# State can be reconstructed from events\ncurrent_balance = sum(event.amount for event in events if hasattr(event, 'amount'))\n</code></pre>"},{"location":"samples/open_bank/#temporal-queries","title":"Temporal Queries","text":"<pre><code># Query account state at any point in time\nasync def get_account_balance_at_date(self, account_id: str, date: datetime) -&gt; Decimal:\n    events = await self.event_store.get_events_async(\n        account_id, \n        to_date=date\n    )\n\n    account = BankAccountV1.from_events(events)\n    return account.state.balance\n</code></pre>"},{"location":"samples/open_bank/#business-intelligence","title":"Business Intelligence","text":"<pre><code># Analyze transaction patterns\nasync def get_transaction_analytics(self, from_date: datetime, to_date: datetime):\n    events = await self.event_store.get_events_by_type_async(\n        BankAccountTransactionRecordedDomainEventV1,\n        from_date=from_date,\n        to_date=to_date\n    )\n\n    return {\n        \"total_transactions\": len(events),\n        \"total_amount\": sum(e.amount for e in events),\n        \"avg_transaction\": sum(e.amount for e in events) / len(events)\n    }\n</code></pre>"},{"location":"samples/open_bank/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"samples/open_bank/#1-prerequisites","title":"1. Prerequisites","text":"<pre><code># Install dependencies\npip install -r requirements.txt\n\n# Start infrastructure\ndocker-compose up -d eventstore mongodb\n</code></pre>"},{"location":"samples/open_bank/#2-run-the-application","title":"2. Run the Application","text":"<pre><code># Start OpenBank API\npython samples/openbank/api/main.py\n\n# Access Swagger UI\nopen http://localhost:8000/docs\n</code></pre>"},{"location":"samples/open_bank/#3-test-the-api","title":"3. Test the API","text":"<pre><code># Create a person\ncurl -X POST http://localhost:8000/api/persons \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\": \"john@example.com\", \"firstName\": \"John\", \"lastName\": \"Doe\"}'\n\n# Create a bank account\ncurl -X POST http://localhost:8000/api/accounts/create \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"ownerId\": \"person-id\", \"initialBalance\": \"1000.00\"}'\n\n# Record a transaction\ncurl -X POST http://localhost:8000/api/transactions/record \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"accountId\": \"account-id\", \"amount\": \"-100.00\", \"type\": \"DEBIT\"}'\n</code></pre>"},{"location":"samples/open_bank/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Event Sourcing - Event sourcing patterns</li> <li>CQRS &amp; Mediation - Command/Query separation</li> <li>Data Access - Repository patterns</li> <li>API Gateway Sample - Microservice gateway comparison</li> </ul>"},{"location":"samples/openbank/","title":"\ud83c\udfe6 OpenBank Sample Application","text":"<p>OpenBank is a comprehensive sample application that demonstrates advanced Neuroglia features including event sourcing, CQRS, domain-driven design, and event-driven architecture. It simulates a simple banking system with persons and accounts.</p>"},{"location":"samples/openbank/#overview","title":"\ud83c\udfaf Overview","text":"<p>The OpenBank sample showcases:</p> <ul> <li>Event Sourcing: Complete event-sourced domain with event store</li> <li>CQRS: Separate command and query models</li> <li>Domain-Driven Design: Rich domain models with business rules</li> <li>Event-Driven Architecture: Domain events and integration events</li> <li>Clean Architecture: Clear separation of layers</li> <li>Repository Pattern: Both write (event sourcing) and read (MongoDB) repositories</li> </ul>"},{"location":"samples/openbank/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    API Layer                                     \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502  PersonsController \u2502  \u2502 AccountsController \u2502  \u2502  Other APIs    \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Application Layer                             \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502    Commands     \u2502  \u2502     Queries     \u2502  \u2502     Events     \u2502   \u2502\n\u2502  \u2502   Handlers      \u2502  \u2502    Handlers     \u2502  \u2502   Handlers     \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Domain Layer                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502     Person      \u2502  \u2502     Account     \u2502  \u2502    Address     \u2502   \u2502\n\u2502  \u2502   Aggregate     \u2502  \u2502   Aggregate     \u2502  \u2502 Value Object   \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Integration Layer                               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502 Event Store     \u2502  \u2502   MongoDB       \u2502  \u2502  API Clients   \u2502   \u2502\n\u2502  \u2502 Repository      \u2502  \u2502  Repository     \u2502  \u2502                \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"samples/openbank/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"samples/openbank/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+</li> <li>Docker and Docker Compose</li> <li>MongoDB (via Docker)</li> <li>EventStoreDB (via Docker)</li> </ul>"},{"location":"samples/openbank/#setup","title":"Setup","text":"<ol> <li>Start Dependencies:</li> </ol> <pre><code>cd samples/openbank\ndocker-compose up -d mongodb eventstoredb\n</code></pre> <ol> <li>Install Dependencies:</li> </ol> <pre><code>pip install -r requirements.txt\n</code></pre> <ol> <li>Run the Application:</li> </ol> <pre><code>python api/main.py\n</code></pre> <ol> <li> <p>Access the API:</p> </li> <li> <p>API Documentation: http://localhost:8000/api/docs</p> </li> <li>EventStoreDB UI: http://localhost:2113 (admin/changeit)</li> </ol>"},{"location":"samples/openbank/#project-structure","title":"\ud83d\udcc1 Project Structure","text":"<pre><code>samples/openbank/\n\u251c\u2500\u2500 api/\n\u2502   \u251c\u2500\u2500 main.py                     # Application entry point\n\u2502   \u2514\u2500\u2500 controllers/\n\u2502       \u251c\u2500\u2500 persons_controller.py   # Person management API\n\u2502       \u2514\u2500\u2500 accounts_controller.py  # Account management API\n\u251c\u2500\u2500 application/\n\u2502   \u251c\u2500\u2500 commands/\n\u2502   \u2502   \u251c\u2500\u2500 persons/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 register_person_command.py\n\u2502   \u2502   \u2514\u2500\u2500 accounts/\n\u2502   \u2502       \u251c\u2500\u2500 open_account_command.py\n\u2502   \u2502       \u2514\u2500\u2500 deposit_command.py\n\u2502   \u251c\u2500\u2500 queries/\n\u2502   \u2502   \u251c\u2500\u2500 person_by_id.py\n\u2502   \u2502   \u2514\u2500\u2500 account_by_owner.py\n\u2502   \u2514\u2500\u2500 events/\n\u2502       \u251c\u2500\u2500 integration/\n\u2502       \u2502   \u2514\u2500\u2500 person_registered_handler.py\n\u2502       \u2514\u2500\u2500 domain/\n\u251c\u2500\u2500 domain/\n\u2502   \u2514\u2500\u2500 models/\n\u2502       \u251c\u2500\u2500 person.py               # Person aggregate\n\u2502       \u251c\u2500\u2500 account.py              # Account aggregate\n\u2502       \u2514\u2500\u2500 address.py              # Address value object\n\u2514\u2500\u2500 integration/\n    \u251c\u2500\u2500 models/                     # DTOs and read models\n    \u2502   \u251c\u2500\u2500 person.py\n    \u2502   \u2514\u2500\u2500 account.py\n    \u2514\u2500\u2500 commands/                   # API command DTOs\n        \u2514\u2500\u2500 persons/\n            \u2514\u2500\u2500 register_person_command_dto.py\n</code></pre>"},{"location":"samples/openbank/#domain-models","title":"\ud83c\udfdb\ufe0f Domain Models","text":""},{"location":"samples/openbank/#person-aggregate","title":"Person Aggregate","text":"<p>The Person aggregate manages person registration and personal information:</p> <pre><code>from dataclasses import dataclass\nfrom datetime import date\nfrom neuroglia.data.abstractions import AggregateRoot\nfrom samples.openbank.integration import PersonGender\n\n@dataclass\nclass PersonState:\n    \"\"\"Person aggregate state\"\"\"\n    id: str = None\n    first_name: str = None\n    last_name: str = None\n    nationality: str = None\n    gender: PersonGender = None\n    date_of_birth: date = None\n    address: Address = None\n\nclass Person(AggregateRoot[str]):\n    \"\"\"Person aggregate root\"\"\"\n\n    def __init__(self, id: str = None):\n        super().__init__(id)\n        self.state = PersonState()\n\n    def register(self, first_name: str, last_name: str, nationality: str, \n                gender: PersonGender, date_of_birth: date, address: Address):\n        \"\"\"Register a new person\"\"\"\n\n        # Validate business rules\n        if not first_name or not last_name:\n            raise ValueError(\"First name and last name are required\")\n\n        if date_of_birth &gt;= date.today():\n            raise ValueError(\"Date of birth must be in the past\")\n\n        # Raise domain event\n        self.apply(PersonRegisteredEvent(\n            person_id=self.id,\n            first_name=first_name,\n            last_name=last_name,\n            nationality=nationality,\n            gender=gender,\n            date_of_birth=date_of_birth,\n            address=address\n        ))\n\n    def update_address(self, new_address: Address):\n        \"\"\"Update person's address\"\"\"\n        self.apply(PersonAddressUpdatedEvent(\n            person_id=self.id,\n            old_address=self.state.address,\n            new_address=new_address\n        ))\n\n    # Event handlers\n    def on_person_registered(self, event: PersonRegisteredEvent):\n        \"\"\"Handle person registered event\"\"\"\n        self.state.id = event.person_id\n        self.state.first_name = event.first_name\n        self.state.last_name = event.last_name\n        self.state.nationality = event.nationality\n        self.state.gender = event.gender\n        self.state.date_of_birth = event.date_of_birth\n        self.state.address = event.address\n\n    def on_person_address_updated(self, event: PersonAddressUpdatedEvent):\n        \"\"\"Handle address updated event\"\"\"\n        self.state.address = event.new_address\n</code></pre>"},{"location":"samples/openbank/#account-aggregate","title":"Account Aggregate","text":"<p>The Account aggregate manages banking accounts and transactions:</p> <pre><code>from decimal import Decimal\nfrom neuroglia.data.abstractions import AggregateRoot\n\n@dataclass\nclass AccountState:\n    \"\"\"Account aggregate state\"\"\"\n    id: str = None\n    owner_id: str = None\n    account_number: str = None\n    balance: Decimal = Decimal('0.00')\n    currency: str = 'USD'\n    is_active: bool = True\n\nclass Account(AggregateRoot[str]):\n    \"\"\"Account aggregate root\"\"\"\n\n    def __init__(self, id: str = None):\n        super().__init__(id)\n        self.state = AccountState()\n\n    def open(self, owner_id: str, account_number: str, initial_deposit: Decimal = None):\n        \"\"\"Open a new account\"\"\"\n\n        # Validate business rules\n        if not owner_id:\n            raise ValueError(\"Owner ID is required\")\n\n        if not account_number:\n            raise ValueError(\"Account number is required\")\n\n        if initial_deposit and initial_deposit &lt; Decimal('0'):\n            raise ValueError(\"Initial deposit cannot be negative\")\n\n        # Raise domain event\n        self.apply(AccountOpenedEvent(\n            account_id=self.id,\n            owner_id=owner_id,\n            account_number=account_number,\n            initial_deposit=initial_deposit or Decimal('0.00')\n        ))\n\n    def deposit(self, amount: Decimal, description: str = None):\n        \"\"\"Deposit money to the account\"\"\"\n\n        # Validate business rules\n        if amount &lt;= Decimal('0'):\n            raise ValueError(\"Deposit amount must be positive\")\n\n        if not self.state.is_active:\n            raise ValueError(\"Cannot deposit to inactive account\")\n\n        # Raise domain event\n        self.apply(MoneyDepositedEvent(\n            account_id=self.id,\n            amount=amount,\n            description=description,\n            balance_after=self.state.balance + amount\n        ))\n\n    def withdraw(self, amount: Decimal, description: str = None):\n        \"\"\"Withdraw money from the account\"\"\"\n\n        # Validate business rules\n        if amount &lt;= Decimal('0'):\n            raise ValueError(\"Withdrawal amount must be positive\")\n\n        if not self.state.is_active:\n            raise ValueError(\"Cannot withdraw from inactive account\")\n\n        if self.state.balance &lt; amount:\n            raise ValueError(\"Insufficient funds\")\n\n        # Raise domain event\n        self.apply(MoneyWithdrawnEvent(\n            account_id=self.id,\n            amount=amount,\n            description=description,\n            balance_after=self.state.balance - amount\n        ))\n\n    # Event handlers\n    def on_account_opened(self, event: AccountOpenedEvent):\n        \"\"\"Handle account opened event\"\"\"\n        self.state.id = event.account_id\n        self.state.owner_id = event.owner_id\n        self.state.account_number = event.account_number\n        self.state.balance = event.initial_deposit\n\n    def on_money_deposited(self, event: MoneyDepositedEvent):\n        \"\"\"Handle money deposited event\"\"\"\n        self.state.balance = event.balance_after\n\n    def on_money_withdrawn(self, event: MoneyWithdrawnEvent):\n        \"\"\"Handle money withdrawn event\"\"\"\n        self.state.balance = event.balance_after\n</code></pre>"},{"location":"samples/openbank/#application-layer","title":"\ud83d\udcbc Application Layer","text":""},{"location":"samples/openbank/#command-handlers","title":"Command Handlers","text":"<p>Command handlers execute business operations:</p> <pre><code>from neuroglia.mediation.mediator import CommandHandler\nfrom neuroglia.data.infrastructure.abstractions import Repository\n\nclass RegisterPersonCommandHandler(CommandHandler[RegisterPersonCommand, OperationResult[PersonDto]]):\n    \"\"\"Handles person registration commands\"\"\"\n\n    def __init__(self, \n                 mapper: Mapper,\n                 person_repository: Repository[Person, str]):\n        self.mapper = mapper\n        self.person_repository = person_repository\n\n    async def handle_async(self, command: RegisterPersonCommand) -&gt; OperationResult[PersonDto]:\n        try:\n            # Create new person aggregate\n            person = Person(str(uuid.uuid4()))\n\n            # Execute business operation\n            person.register(\n                first_name=command.first_name,\n                last_name=command.last_name,\n                nationality=command.nationality,\n                gender=command.gender,\n                date_of_birth=command.date_of_birth,\n                address=command.address\n            )\n\n            # Save to event store\n            saved_person = await self.person_repository.add_async(person)\n\n            # Map to DTO and return\n            person_dto = self.mapper.map(saved_person.state, PersonDto)\n            return self.created(person_dto)\n\n        except ValueError as ex:\n            return self.bad_request(str(ex))\n        except Exception as ex:\n            return self.internal_error(f\"Failed to register person: {ex}\")\n\nclass DepositCommandHandler(CommandHandler[DepositCommand, OperationResult[AccountDto]]):\n    \"\"\"Handles money deposit commands\"\"\"\n\n    def __init__(self, \n                 mapper: Mapper,\n                 account_repository: Repository[Account, str]):\n        self.mapper = mapper\n        self.account_repository = account_repository\n\n    async def handle_async(self, command: DepositCommand) -&gt; OperationResult[AccountDto]:\n        try:\n            # Load account from event store\n            account = await self.account_repository.get_by_id_async(command.account_id)\n            if account is None:\n                return self.not_found(\"Account not found\")\n\n            # Execute business operation\n            account.deposit(command.amount, command.description)\n\n            # Save changes\n            await self.account_repository.update_async(account)\n\n            # Map to DTO and return\n            account_dto = self.mapper.map(account.state, AccountDto)\n            return self.ok(account_dto)\n\n        except ValueError as ex:\n            return self.bad_request(str(ex))\n        except Exception as ex:\n            return self.internal_error(f\"Failed to deposit money: {ex}\")\n</code></pre>"},{"location":"samples/openbank/#query-handlers","title":"Query Handlers","text":"<p>Query handlers retrieve data for read operations:</p> <pre><code>class GetPersonByIdQueryHandler(QueryHandler[GetPersonByIdQuery, OperationResult[PersonDto]]):\n    \"\"\"Handles person lookup queries\"\"\"\n\n    def __init__(self, \n                 mapper: Mapper,\n                 person_repository: Repository[PersonDto, str]):  # Read model repository\n        self.mapper = mapper\n        self.person_repository = person_repository\n\n    async def handle_async(self, query: GetPersonByIdQuery) -&gt; OperationResult[PersonDto]:\n        person = await self.person_repository.get_by_id_async(query.person_id)\n\n        if person is None:\n            return self.not_found(f\"Person with ID {query.person_id} not found\")\n\n        return self.ok(person)\n\nclass GetAccountsByOwnerQueryHandler(QueryHandler[GetAccountsByOwnerQuery, OperationResult[List[AccountDto]]]):\n    \"\"\"Handles account lookup by owner queries\"\"\"\n\n    def __init__(self, account_repository: Repository[AccountDto, str]):\n        self.account_repository = account_repository\n\n    async def handle_async(self, query: GetAccountsByOwnerQuery) -&gt; OperationResult[List[AccountDto]]:\n        accounts = await self.account_repository.find_by_criteria_async(\n            {\"owner_id\": query.owner_id}\n        )\n        return self.ok(accounts)\n</code></pre>"},{"location":"samples/openbank/#event-handling","title":"\ud83d\udce1 Event Handling","text":""},{"location":"samples/openbank/#domain-events","title":"Domain Events","text":"<p>Domain events represent business events within aggregates:</p> <pre><code>@dataclass\nclass PersonRegisteredEvent(DomainEvent):\n    \"\"\"Event raised when a person is registered\"\"\"\n    person_id: str\n    first_name: str\n    last_name: str\n    nationality: str\n    gender: PersonGender\n    date_of_birth: date\n    address: Address\n\n@dataclass\nclass AccountOpenedEvent(DomainEvent):\n    \"\"\"Event raised when an account is opened\"\"\"\n    account_id: str\n    owner_id: str\n    account_number: str\n    initial_deposit: Decimal\n\n@dataclass\nclass MoneyDepositedEvent(DomainEvent):\n    \"\"\"Event raised when money is deposited\"\"\"\n    account_id: str\n    amount: Decimal\n    description: str\n    balance_after: Decimal\n</code></pre>"},{"location":"samples/openbank/#integration-events","title":"Integration Events","text":"<p>Integration events handle cross-bounded-context communication:</p> <pre><code>class PersonRegisteredIntegrationEventHandler(EventHandler[PersonRegisteredEvent]):\n    \"\"\"Handles person registered events for integration purposes\"\"\"\n\n    def __init__(self, \n                 cloud_event_publisher: CloudEventPublisher,\n                 mapper: Mapper):\n        self.cloud_event_publisher = cloud_event_publisher\n        self.mapper = mapper\n\n    async def handle_async(self, event: PersonRegisteredEvent):\n        # Create integration event\n        integration_event = PersonRegisteredIntegrationEvent(\n            person_id=event.person_id,\n            email=event.email,\n            full_name=f\"{event.first_name} {event.last_name}\",\n            timestamp=datetime.utcnow()\n        )\n\n        # Publish as CloudEvent\n        await self.cloud_event_publisher.publish_async(\n            event_type=\"person.registered.v1\",\n            data=integration_event,\n            source=\"openbank.persons\"\n        )\n</code></pre>"},{"location":"samples/openbank/#data-access","title":"\ud83d\uddc4\ufe0f Data Access","text":""},{"location":"samples/openbank/#event-sourcing-repository","title":"Event Sourcing Repository","text":"<p>The write model uses event sourcing:</p> <pre><code># Configuration in main.py\nfrom neuroglia.data.infrastructure.event_sourcing import EventSourcingRepository\nfrom neuroglia.data.infrastructure.event_sourcing.event_store import ESEventStore\n\n# Configure Event Store\nESEventStore.configure(builder, EventStoreOptions(database_name, consumer_group))\n\n# Configure event sourcing repositories\nDataAccessLayer.WriteModel.configure(\n    builder, \n    [\"samples.openbank.domain.models\"], \n    lambda builder_, entity_type, key_type: EventSourcingRepository.configure(\n        builder_, entity_type, key_type\n    )\n)\n</code></pre>"},{"location":"samples/openbank/#read-model-repository","title":"Read Model Repository","text":"<p>The read model uses MongoDB:</p> <pre><code># Configuration in main.py\nfrom neuroglia.data.infrastructure.mongo import MongoRepository\n\n# Configure MongoDB repositories\nDataAccessLayer.ReadModel.configure(\n    builder,\n    [\"samples.openbank.integration.models\", \"samples.openbank.application.events\"],\n    lambda builder_, entity_type, key_type: MongoRepository.configure(\n        builder_, entity_type, key_type, database_name\n    )\n)\n</code></pre>"},{"location":"samples/openbank/#api-layer","title":"\ud83c\udf10 API Layer","text":""},{"location":"samples/openbank/#controllers","title":"Controllers","text":"<p>Controllers expose the domain through REST APIs:</p> <pre><code>class PersonsController(ControllerBase):\n    \"\"\"Persons management API\"\"\"\n\n    @post(\"/\", response_model=PersonDto, status_code=201)\n    async def register_person(self, command: RegisterPersonCommandDto) -&gt; PersonDto:\n        \"\"\"Register a new person\"\"\"\n        # Map DTO to domain command\n        domain_command = self.mapper.map(command, RegisterPersonCommand)\n\n        # Execute through mediator\n        result = await self.mediator.execute_async(domain_command)\n\n        # Process and return result\n        return self.process(result)\n\n    @get(\"/\", response_model=List[PersonDto])\n    async def list_persons(self) -&gt; List[PersonDto]:\n        \"\"\"List all registered persons\"\"\"\n        query = ListPersonsQuery()\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/{person_id}\", response_model=PersonDto)\n    async def get_person_by_id(self, person_id: str) -&gt; PersonDto:\n        \"\"\"Get person by ID\"\"\"\n        query = GetPersonByIdQuery(person_id=person_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\nclass AccountsController(ControllerBase):\n    \"\"\"Accounts management API\"\"\"\n\n    @post(\"/\", response_model=AccountDto, status_code=201)\n    async def open_account(self, command: OpenAccountCommandDto) -&gt; AccountDto:\n        \"\"\"Open a new account\"\"\"\n        domain_command = self.mapper.map(command, OpenAccountCommand)\n        result = await self.mediator.execute_async(domain_command)\n        return self.process(result)\n\n    @post(\"/{account_id}/deposit\", response_model=AccountDto)\n    async def deposit(self, account_id: str, command: DepositCommandDto) -&gt; AccountDto:\n        \"\"\"Deposit money to account\"\"\"\n        domain_command = self.mapper.map(command, DepositCommand)\n        domain_command.account_id = account_id\n        result = await self.mediator.execute_async(domain_command)\n        return self.process(result)\n\n    @get(\"/by-owner/{owner_id}\", response_model=List[AccountDto])\n    async def get_accounts_by_owner(self, owner_id: str) -&gt; List[AccountDto]:\n        \"\"\"Get all accounts for a person\"\"\"\n        query = GetAccountsByOwnerQuery(owner_id=owner_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"samples/openbank/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"samples/openbank/#unit-tests","title":"Unit Tests","text":"<p>Test domain logic in isolation:</p> <pre><code>def test_person_registration():\n    # Arrange\n    person = Person(\"test-id\")\n    address = Address(\"123 Main St\", \"Anytown\", \"12345\", \"USA\")\n\n    # Act\n    person.register(\n        first_name=\"John\",\n        last_name=\"Doe\",\n        nationality=\"US\",\n        gender=PersonGender.MALE,\n        date_of_birth=date(1990, 1, 1),\n        address=address\n    )\n\n    # Assert\n    assert person.state.first_name == \"John\"\n    assert person.state.last_name == \"Doe\"\n    assert len(person.uncommitted_events) == 1\n    assert isinstance(person.uncommitted_events[0], PersonRegisteredEvent)\n\ndef test_account_deposit():\n    # Arrange\n    account = Account(\"test-account\")\n    account.open(\"owner-id\", \"123456789\", Decimal('100.00'))\n\n    # Act\n    account.deposit(Decimal('50.00'), \"Test deposit\")\n\n    # Assert\n    assert account.state.balance == Decimal('150.00')\n    assert len(account.uncommitted_events) == 2  # Open + Deposit\n</code></pre>"},{"location":"samples/openbank/#integration-tests","title":"Integration Tests","text":"<p>Test the complete flow:</p> <pre><code>@pytest.mark.asyncio\nasync def test_person_registration_flow():\n    # Arrange\n    client = TestClient(app)\n    person_data = {\n        \"first_name\": \"John\",\n        \"last_name\": \"Doe\",\n        \"nationality\": \"US\",\n        \"gender\": \"MALE\",\n        \"date_of_birth\": \"1990-01-01\",\n        \"address\": {\n            \"street\": \"123 Main St\",\n            \"city\": \"Anytown\",\n            \"postal_code\": \"12345\",\n            \"country\": \"USA\"\n        }\n    }\n\n    # Act\n    response = client.post(\"/api/v1/persons\", json=person_data)\n\n    # Assert\n    assert response.status_code == 201\n    person = response.json()\n    assert person[\"first_name\"] == \"John\"\n    assert person[\"last_name\"] == \"Doe\"\n\n    # Verify person can be retrieved\n    get_response = client.get(f\"/api/v1/persons/{person['id']}\")\n    assert get_response.status_code == 200\n</code></pre>"},{"location":"samples/openbank/#running-the-sample","title":"\ud83d\ude80 Running the Sample","text":""},{"location":"samples/openbank/#start-the-application","title":"Start the Application","text":"<ol> <li>Start infrastructure:</li> </ol> <pre><code>docker-compose up -d\n</code></pre> <ol> <li>Run the application:</li> </ol> <pre><code>python api/main.py\n</code></pre>"},{"location":"samples/openbank/#example-api-calls","title":"Example API Calls","text":"<p>Register a Person:</p> <pre><code>curl -X POST \"http://localhost:8000/api/v1/persons\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"first_name\": \"John\",\n    \"last_name\": \"Doe\",\n    \"nationality\": \"US\",\n    \"gender\": \"MALE\",\n    \"date_of_birth\": \"1990-01-01\",\n    \"address\": {\n      \"street\": \"123 Main St\",\n      \"city\": \"Anytown\",\n      \"postal_code\": \"12345\",\n      \"country\": \"USA\"\n    }\n  }'\n</code></pre> <p>Open an Account:</p> <pre><code>curl -X POST \"http://localhost:8000/api/v1/accounts\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"owner_id\": \"PERSON_ID_FROM_ABOVE\",\n    \"account_number\": \"123456789\",\n    \"initial_deposit\": 1000.00\n  }'\n</code></pre> <p>Deposit Money:</p> <pre><code>curl -X POST \"http://localhost:8000/api/v1/accounts/ACCOUNT_ID/deposit\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"amount\": 500.00,\n    \"description\": \"Salary deposit\"\n  }'\n</code></pre>"},{"location":"samples/openbank/#key-learnings","title":"\ud83d\udccb Key Learnings","text":"<p>The OpenBank sample demonstrates:</p> <ol> <li>Event Sourcing: How to store state as a sequence of events</li> <li>CQRS: Separation of write and read models</li> <li>Domain-Driven Design: Rich domain models with business rules</li> <li>Clean Architecture: Clear separation of concerns</li> <li>Event-Driven Architecture: How events enable loose coupling</li> <li>Repository Pattern: Abstract data access for different storage types</li> <li>Integration Events: Cross-bounded-context communication</li> </ol>"},{"location":"samples/openbank/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Basic Neuroglia concepts</li> <li>Architecture Guide - Understanding the architecture</li> <li>Event Sourcing - Event sourcing patterns</li> <li>CQRS &amp; Mediation - Command and query patterns</li> <li>Event Handling - Event-driven architecture</li> </ul>"}]}