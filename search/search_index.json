{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Neuroglia Python Framework","text":"<p>This Python framework is a lightweight layer built on top of FastAPI. It offers developers a set of useful tools and features that can be applied to any microservice, no matter its specific purpose or domain. These features include:</p> <ul> <li>Adherence to 12-Factor App principles.</li> <li>Built-in MVC Web App structure: It provides a foundation for building web applications using the Model-View-Controller pattern, with essential abstractions.</li> <li>Simplified Dependency Injection: A straightforward mechanism for managing dependencies, including automatic discovery and instantiation of classes.</li> <li>Class-based API Controllers with Automatic Loading: Easily define API controllers using classes, with the framework automatically finding and loading them.</li> <li>Modular Command/Query Separation (CQRS): Supports a clear separation of commands (actions that change data) and queries (actions that retrieve data).</li> <li>Optional Event-Sourcing: Provides the option to implement event-sourcing for building event-driven domain models.</li> <li> <p>Clean, Layered Code: Encourages a clean architecture approach, similar to the principles outlined in [link to clean architecture article].</p> <ul> <li>Pure Domain Models: Allows you to define domain models that are independent of any specific persistence mechanism.</li> <li>Application Handlers: Provides a structure for handling commands, queries, events, and background tasks within your application logic.</li> <li>Repository Pattern Implementation: Includes support for the Repository pattern for abstracting data access.</li> <li>Separation of API and Domain: Keeps API controllers, endpoints, and data transfer objects (DTOs) separate from your core domain models and business logic.</li> </ul> </li> <li> <p>Native Asynchronous Event Handling with RxPy: Offers built-in support for handling, emitting, and ingesting asynchronous events (in JSON CloudEvent format) using the ReactiveX programming paradigm with RxPy.</p> </li> <li>Data Model Mapping: Provides tools for easily mapping data between your domain models and integration layers.</li> <li>Easy Background Task Scheduling: Integrates seamlessly with apscheduler for scheduling background tasks.</li> <li>And more...</li> </ul>"},{"location":"#code-structure","title":"Code Structure","text":""},{"location":"#entry-point","title":"Entry Point","text":"<p>The main entry point of your application is typically the <code>src/main.py</code> file (or <code>src/api/main.py</code>). This file is where you define all the necessary dependencies and specify the sub-folders where the framework should dynamically load your API, Application, Integration, and Domain Layers.</p>"},{"location":"#framework-conventions","title":"Framework Conventions","text":"<p>The <code>src</code> folder contains four distinct Layers:</p> <p></p> <ul> <li> <p>API Layer (Controllers): <code>uses the Application Layer</code></p> <ul> <li>Defines the endpoints available to external clients (incl. OpenAPI specs)</li> <li>Maps each endpoint to its corresponding Application handler.</li> <li>Maps external data (DTO's) models (API Requests and Responses schemas) to internal Domain layer</li> </ul> </li> <li> <p>Application Layer (Handlers and Services): <code>executes the main biz logic, uses the Domain and Integration Layers</code></p> <ul> <li>Loads the logic for handling commands, queries, events, tasks, and any other business logic services.</li> </ul> </li> <li> <p>Integration Layer (Dependencies): <code>provides reusable independent logic (persistence Layer, API clients, external logic)</code></p> <ul> <li>Loads any external API client services, persistence layer clients, and their associated data models (API DTOs for requests and responses).</li> </ul> </li> <li> <p>Domain Layer (Models): <code>contains the core business domain models and rules</code></p> <ul> <li>Defines the core entities, value objects, and business rules of your application.</li> <li>These models should be persistence-agnostic and represent your business domain.</li> </ul> </li> </ul>"},{"location":"#developer-guide","title":"Developer Guide","text":""},{"location":"#wip-disclaimer","title":"WIP - DISCLAIMER","text":"<p>This section was generated by AI and contains many errors - this is still in-progress!! Please refer to the samples code for accurate information.</p>"},{"location":"#core-framework-components","title":"Core Framework Components","text":"<p>The Neuroglia framework is composed of multiple modular components that work together to provide a comprehensive development experience:</p>"},{"location":"#1-core-module-neurogliacore","title":"1. Core Module (<code>neuroglia.core</code>)","text":"<p>The core module provides foundational utilities and classes:</p> <ul> <li>TypeFinder: Discovers classes and types within specified modules</li> <li>ModuleLoader: Handles dynamic loading of modules</li> <li>ProblemDetails: Standardized error response format</li> <li>OperationResult: Wrapper for operation results with success/failure status</li> </ul>"},{"location":"#2-dependency-injection-neurogliadependency_injection","title":"2. Dependency Injection (<code>neuroglia.dependency_injection</code>)","text":"<p>A lightweight dependency injection system:</p> <ul> <li>ServiceProvider: Central container for registering and resolving services</li> <li>ServiceCollection: Registry for service definitions</li> <li>Automatic Discovery: Services can be automatically discovered and registered</li> </ul> <pre><code># Example of dependency registration\nfrom neuroglia.dependency_injection.service_provider import ServiceCollection\n\nservices = ServiceCollection()\nservices.add_singleton(MyService)\nservices.add_scoped(ScopedService)\nservices.add_transient(TransientService)\n\nprovider = services.build_service_provider()\nmy_service = provider.get_required_service(MyService)\n</code></pre>"},{"location":"#3-web-hosting-neurogliahosting","title":"3. Web Hosting (<code>neuroglia.hosting</code>)","text":"<p>Web application hosting abstractions:</p> <ul> <li>WebApplicationBuilder: Factory for building and configuring web applications</li> <li>WebHost: Base host for web applications, integrating with FastAPI</li> <li>Middleware Support: Exception handling, CloudEvents, etc.</li> </ul> <pre><code># Example of application setup\nfrom neuroglia.hosting.web import WebApplicationBuilder\n\nbuilder = WebApplicationBuilder()\n# Configure services\napp = builder.build()\n</code></pre>"},{"location":"#4-mvc-pattern-neurogliamvc","title":"4. MVC Pattern (<code>neuroglia.mvc</code>)","text":"<p>Support for Model-View-Controller pattern:</p> <ul> <li>ControllerBase: Base class for creating API controllers</li> <li>Automatic Controller Discovery: Controllers are automatically found and registered</li> </ul> <pre><code># Example controller\nfrom fastapi import APIRouter\nfrom neuroglia.mvc.controller_base import ControllerBase\n\nclass UsersController(ControllerBase):\n    def __init__(self):\n        super().__init__()\n        self.router = APIRouter(tags=[\"users\"])\n\n        @self.router.get(\"/users\")\n        async def get_users():\n            # Implementation\n            return []\n</code></pre>"},{"location":"#5-cqrs-and-mediation-neurogliamediation","title":"5. CQRS and Mediation (<code>neuroglia.mediation</code>)","text":"<p>Support for Command Query Responsibility Segregation:</p> <ul> <li>Mediator: Central hub for handling commands and queries</li> <li>RequestHandler: Base class for command and query handlers</li> </ul> <pre><code># Command example\nfrom neuroglia.mediation.mediator import RequestHandler\n\nclass CreateUserCommand:\n    def __init__(self, name: str, email: str):\n        self.name = name\n        self.email = email\n\nclass CreateUserCommandHandler(RequestHandler[CreateUserCommand, str]):\n    async def handle(self, request: CreateUserCommand) -&gt; str:\n        # Implementation\n        return \"user_id\"\n\n# Usage\nresult = await mediator.send(CreateUserCommand(\"John\", \"john@example.com\"))\n</code></pre>"},{"location":"#6-data-access-neurogliadata","title":"6. Data Access (<code>neuroglia.data</code>)","text":"<p>Database access abstractions:</p> <ul> <li>Repository Pattern: Generic repositories for data access</li> <li>MongoDB Integration: Ready-to-use MongoDB repositories</li> <li>Event Sourcing: Support for event sourcing pattern</li> <li>Queryable: Fluent query interface</li> </ul> <pre><code># Repository example\nfrom neuroglia.data.infrastructure.mongo.mongo_repository import MongoRepository\n\nclass UserRepository(MongoRepository[User, str]):\n    def __init__(self, connection_string: str):\n        super().__init__(connection_string, \"users\", \"users\")\n</code></pre>"},{"location":"#7-event-handling-neurogliaeventing","title":"7. Event Handling (<code>neuroglia.eventing</code>)","text":"<p>Event-based communication support:</p> <ul> <li>CloudEvents: Support for CloudEvents standard</li> <li>Event Publishing: Mechanisms to publish events</li> <li>Event Ingestion: Capabilities to consume events</li> </ul> <pre><code># Event publishing example\nfrom neuroglia.eventing.cloud_events.infrastructure.cloud_event_publisher import CloudEventPublisher\n\npublisher = CloudEventPublisher(\"source\")\nawait publisher.publish(\"user.created\", {\"id\": \"123\", \"name\": \"John\"})\n</code></pre>"},{"location":"#8-object-mapping-neurogliamapping","title":"8. Object Mapping (<code>neuroglia.mapping</code>)","text":"<p>Mapping between different object representations:</p> <ul> <li>Mapper: Bidirectional object mapping</li> <li>Profile Configuration: Define mapping profiles for different object types</li> </ul> <pre><code># Mapping example\nfrom neuroglia.mapping.mapper import Mapper\n\n# Configure mapping\nMapper.create_map(UserDTO, User)\nMapper.create_map(User, UserDTO)\n\n# Map objects\nuser_dto = Mapper.map(User(\"123\", \"John\", \"john@example.com\"), UserDTO)\n</code></pre>"},{"location":"#9-serialization-neurogliaserialization","title":"9. Serialization (<code>neuroglia.serialization</code>)","text":"<p>Serialization utilities:</p> <ul> <li>JsonSerializer: JSON serialization with enhanced features</li> <li>Customizable serialization options</li> </ul>"},{"location":"#10-reactive-programming-neurogliareactive","title":"10. Reactive Programming (<code>neuroglia.reactive</code>)","text":"<p>Support for reactive programming:</p> <ul> <li>RxPy Integration: Reactive Extensions for Python</li> <li>RxAsync: Asynchronous reactive programming utilities</li> </ul>"},{"location":"#creating-a-new-application","title":"Creating a New Application","text":"<p>Follow these steps to create a new Neuroglia application:</p> <ol> <li> <p>Set up project structure:    <code>my_project/    \u251c\u2500\u2500 api/    \u2502   \u251c\u2500\u2500 main.py              # Entry point    \u2502   \u2514\u2500\u2500 controllers/         # API controllers    \u251c\u2500\u2500 application/    \u2502   \u251c\u2500\u2500 commands/            # Command handlers    \u2502   \u251c\u2500\u2500 queries/             # Query handlers    \u2502   \u251c\u2500\u2500 events/              # Event handlers    \u2502   \u2514\u2500\u2500 services/            # Application services    \u251c\u2500\u2500 domain/    \u2502   \u2514\u2500\u2500 models/              # Domain models    \u2514\u2500\u2500 integration/        \u251c\u2500\u2500 models/              # External data models        \u2514\u2500\u2500 services/            # External services</code></p> </li> <li> <p>Create the entry point (<code>api/main.py</code>):    ```python    import logging    from neuroglia.hosting.web import WebApplicationBuilder    from neuroglia.mapping.mapper import Mapper    from neuroglia.mediation.mediator import Mediator</p> </li> </ol> <p># Configure logging    logging.basicConfig(level=logging.INFO)    log = logging.getLogger(name)</p> <p># Create application builder    builder = WebApplicationBuilder()</p> <p># Configure services    Mapper.configure(builder, [\"myproject.application\"])    builder.services.add_singleton(Mediator)</p> <p># Build and run the application    app = builder.build()    ```</p> <ol> <li>Create domain models (<code>domain/models/user.py</code>):    ```python    from dataclasses import dataclass    from neuroglia.data.abstractions import AggregateRoot</li> </ol> <p>@dataclass    class User(AggregateRoot[str]):        name: str        email: str    ```</p> <ol> <li>Create commands and queries:    ```python    # application/commands/create_user.py    from dataclasses import dataclass    from neuroglia.mediation.mediator import RequestHandler</li> </ol> <p>@dataclass    class CreateUserCommand:        name: str        email: str</p> <p>class CreateUserCommandHandler(RequestHandler[CreateUserCommand, str]):        async def handle(self, request: CreateUserCommand) -&gt; str:            # Implementation            return \"user_id\"    ```</p> <ol> <li>Create controllers (<code>api/controllers/users_controller.py</code>):    ```python    from fastapi import APIRouter, Depends    from neuroglia.mvc.controller_base import ControllerBase    from neuroglia.mediation.mediator import Mediator    from application.commands.create_user import CreateUserCommand</li> </ol> <p>class UsersController(ControllerBase):        def init(self, mediator: Mediator):            super().init()            self.mediator = mediator            self.router = APIRouter(tags=[\"users\"])</p> <pre><code>       @self.router.post(\"/users\")\n       async def create_user(name: str, email: str):\n           return await self.mediator.send(CreateUserCommand(name, email))\n</code></pre> <p>```</p>"},{"location":"#using-event-sourcing","title":"Using Event Sourcing","text":"<p>Event Sourcing is a powerful pattern that Neuroglia supports out of the box:</p> <ol> <li>Define domain events:    ```python    from dataclasses import dataclass    from neuroglia.data.abstractions import DomainEvent</li> </ol> <p>@dataclass    class UserCreatedEvent(DomainEvent):        name: str        email: str    ```</p> <ol> <li>Create event-sourced aggregate:    ```python    from neuroglia.data.abstractions import AggregateRoot</li> </ol> <p>class User(AggregateRoot[str]):        _name: str = None        _email: str = None</p> <pre><code>   @property\n   def name(self) -&gt; str:\n       return self._name\n\n   @property\n   def email(self) -&gt; str:\n       return self._email\n\n   @staticmethod\n   def create(id: str, name: str, email: str) -&gt; \"User\":\n       user = User(id)\n       user.apply_change(UserCreatedEvent(id, name, email))\n       return user\n\n   def _on_user_created(self, event: UserCreatedEvent):\n       self._name = event.name\n       self._email = event.email\n</code></pre> <p>```</p> <ol> <li>Configure event store:    ```python    from neuroglia.data.infrastructure.event_sourcing.event_store.event_store import ESEventStore    from neuroglia.data.infrastructure.event_sourcing.event_sourcing_repository import EventSourcingRepository</li> </ol> <p># Setup event store    event_store = ESEventStore(\"connection_string\", \"stream_prefix\")</p> <p># Create repository    user_repository = EventSourcingRepositoryUser, str    ```</p>"},{"location":"#running-background-tasks","title":"Running Background Tasks","text":"<p>Neuroglia integrates with apscheduler for background tasks:</p> <pre><code>from apscheduler.schedulers.asyncio import AsyncIOScheduler\nfrom neuroglia.hosting.abstractions import HostedService\n\nclass BackgroundTaskService(HostedService):\n    def __init__(self):\n        self._scheduler = AsyncIOScheduler()\n\n    async def start_async(self):\n        # Add jobs\n        self._scheduler.add_job(self._process_data, 'interval', minutes=5)\n        self._scheduler.start()\n\n    async def stop_async(self):\n        self._scheduler.shutdown()\n\n    async def _process_data(self):\n        # Task implementation\n        pass\n</code></pre>"},{"location":"#advanced-features","title":"Advanced Features","text":""},{"location":"#real-time-communication-with-cloudevents","title":"Real-time Communication with CloudEvents","text":"<pre><code>from neuroglia.eventing.cloud_events.infrastructure import CloudEventIngestor\nfrom neuroglia.eventing.cloud_events.decorators import cloud_event_handler\n\nclass NotificationService:\n    def __init__(self, event_ingestor: CloudEventIngestor):\n        event_ingestor.subscribe(\"user.created\", self._on_user_created)\n\n    @cloud_event_handler\n    async def _on_user_created(self, event_data):\n        # Process user created event\n        user_id = event_data[\"id\"]\n        # Send notification\n</code></pre>"},{"location":"#custom-repository-implementation","title":"Custom Repository Implementation","text":"<pre><code>from neuroglia.data.infrastructure.abstractions import Repository\n\nclass CustomRepository(Repository[Entity, str]):\n    async def add(self, entity: Entity) -&gt; None:\n        # Custom implementation\n\n    async def update(self, entity: Entity) -&gt; None:\n        # Custom implementation\n\n    async def remove(self, entity: Entity) -&gt; None:\n        # Custom implementation\n\n    async def find_by_id(self, id: str) -&gt; Optional[Entity]:\n        # Custom implementation\n</code></pre>"},{"location":"#samples","title":"Samples","text":""},{"location":"#openbank","title":"OpenBank","text":"<p>Implements a simplified Bank that manages Accounts, Users and Transactions with full Event Sourcing, CQRS</p> <p>Explore OpenBank</p>"},{"location":"#desktop-controller","title":"Desktop Controller","text":"<p>Remotely and securely control custom files or commands on a Desktop running the app as a Docker container...</p> <p>Explore Desktop Controller</p>"},{"location":"#api-gateway","title":"API Gateway","text":"<p>Expose single entry point for 3rd party clients into an internal layer, like a GenAI stack... Models a Prompt entity, enforces a business logic (e.g. Prompt' state-machine), handles scheduled background task (with persistence), exposes API with multiple Security schemes, ...</p> <p>Explore API Gateway</p>"},{"location":"#cisco-remote-output-collector","title":"Cisco Remote Output Collector","text":"<p>Statefull microservice that handles complex and custom HTTP Commands which in turn each encapsulates arbitrary interactions with given Cisco Device(s) via Telnet, such as <code>FindPrompt</code>, <code>CollectCommandLineOutput</code>, <code>AddConfiguration</code>, <code>SaveConfiguration</code>, <code>Ping</code>, <code>Traceroute</code>, <code>ClearNatTranslation</code>, <code>CheckReachability</code>, <code>BounceInterface</code>, <code>RunViaTelnetTo</code>, <code>FindSpanningTreeRoot</code>, ... etc.</p> <p>Explore IOS ROC</p> <p>Current state: functional but simple implemention, 100% stateless collection of multiple CLI to a single device via Telnet.</p> <p>TODO:</p> <ul> <li>[ ] Add Session management (defines a Pod for subsequent scenarios) with persistence</li> <li>[ ] Add DeviceConnection and ConnectionManager</li> <li>[ ] Add DeviceDrivers and PromptPatterns libraries</li> <li>[ ] ...</li> </ul>"},{"location":"#deployment","title":"Deployment","text":""},{"location":"#docker-deployment","title":"Docker Deployment","text":"<p>The framework is designed to work seamlessly with Docker. A typical Dockerfile might look like:</p> <pre><code>FROM python:3.10-slim\n\nWORKDIR /app\n\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\nCOPY . .\n\nEXPOSE 8000\n\nCMD [\"uvicorn\", \"api.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n</code></pre>"},{"location":"#environment-configuration","title":"Environment Configuration","text":"<p>Following the 12-Factor App principles, configuration is stored in environment variables:</p> <pre><code>from neuroglia.hosting.abstractions import ApplicationSettings\nfrom pydantic import BaseSettings\n\nclass MyAppSettings(ApplicationSettings):\n    database_url: str\n    api_key: str\n    debug_mode: bool = False\n</code></pre>"},{"location":"#testing","title":"Testing","text":"<p>The framework supports comprehensive testing with pytest:</p> <pre><code># Example test for a command handler\nasync def test_create_user_command():\n    # Arrange\n    handler = CreateUserCommandHandler(mock_repository)\n    command = CreateUserCommand(\"test\", \"test@example.com\")\n\n    # Act\n    result = await handler.handle(command)\n\n    # Assert\n    assert result is not None\n    assert mock_repository.add.called_once\n</code></pre>"},{"location":"#best-practices","title":"Best Practices","text":"<ol> <li>Keep Domain Models Pure: Domain models should be free of infrastructure concerns</li> <li>Use Commands for State Changes: All state-changing operations should be modeled as commands</li> <li>Use Queries for Reading Data: All data retrieval should be modeled as queries</li> <li>Leverage Dependency Injection: Always use DI to create loosely coupled components</li> <li>Handle Errors with Problem Details: Use the standard ProblemDetails format for error responses</li> <li>Follow Layered Architecture: Maintain clear boundaries between API, Application, Domain, and Integration layers</li> </ol>"},{"location":"#conclusion","title":"Conclusion","text":"<p>The Neuroglia Python Framework provides a comprehensive foundation for building clean, maintainable, and feature-rich microservices. By embracing modern architectural patterns like CQRS, Event Sourcing, and Clean Architecture, it helps developers create applications that are easier to understand, test, and evolve over time.</p> <p>For more information, check out the sample applications or contribute to the framework development.</p>"},{"location":"samples/api_gateway/","title":"API Gateway","text":"<p>TODO</p>"},{"location":"samples/desktop_controller/","title":"Desktop Controller","text":"<p>REST API to remotely control a Desktop (i.e. the Docker Host running the controller) over HTTP.</p> <p>The Controller must:</p> <ol> <li>Register itself periodically (via CloudEvent) to the Desktops Registry (providing its IP address as the identifier to the Registry)</li> <li>Securely expose a set of <code>Commands</code> and <code>Queries</code> via a REST API (with OpenAPI 3.x specs) that enable remote control for the Desktop's <code>HostInfo</code> and <code>UserInfo</code> (wrapping Linux Shell commands as HTTP Requests)</li> <li>Maintain various local files (e.g. <code>/data/hostinfo.json</code>, <code>/data/userinfo.json</code>) that other apps (on the Desktop VM) may rely upon (Screen Logger).</li> <li>Trigger remote execution of custom Shell scripts to be run on the Desktop VM (not the controller's container!)</li> </ol> <p>[[TOC]]</p>"},{"location":"samples/desktop_controller/#overview","title":"Overview","text":""},{"location":"samples/desktop_controller/#controllers-interactions","title":"Controller's Interactions","text":""},{"location":"samples/desktop_controller/#controllers-context","title":"Controller's Context","text":""},{"location":"samples/desktop_controller/#design","title":"Design","text":""},{"location":"samples/desktop_controller/#development","title":"Development","text":""},{"location":"samples/desktop_controller/#setup","title":"Setup","text":"<pre><code>\n# 0. Prerequisites:\n#    Have Python 3.12 installed\n# \n#    - Create/Activate a local python environment (e.g. with pyenv)\n#      pyenv virtualenv 3.12.2 desktop-controller\n#      pyenv activate desktop-controller\n# \n#    - Start Docker Desktop locally\n#\n# 1. Clone the repository\ncd ~/\n\ngit clone git@....\n\ncd desktop-controller\n\n# pip install pre-commit\npre-commit install\n\n# pip install poetry\npoetry lock &amp;&amp; poetry install \n\n# 2. Start the docker-compose stack\n# sudo apt-get install make\nmake up\n\n# 3. Connect the vscode debugger to the running container\n# From vscode: hit F5 (ensure that the \"Run and Debug\" launcher is set to \"Python: Remote Attach\")\n\n# 4. Open the SwaggerUI at http://localhost:9781/api/docs\n\n# 5. Add a Breakpoint, e.g. in api.controllers.userinfo_controller.py:29...\n\n# 6. Send a test request :)\n\n# 7. Enjoy live debugging on your local development\n</code></pre>"},{"location":"samples/desktop_controller/#code-contribution","title":"Code Contribution","text":"<ol> <li>Clone <code>main</code> branch</li> <li>Create new branch, e.g. <code>feat-cmd-userinfo</code> or <code>fix-linux-cmd</code></li> <li>Push the new branch to Gitlab and create a Merge Request into <code>main</code></li> <li>Document the review</li> <li>Approve and merge (may discard the branch if needed)</li> </ol>"},{"location":"samples/desktop_controller/#release-process","title":"Release Process","text":"<ol> <li>Refer to Semantic Versioning</li> <li>Create new Tag in Gitlab &gt; Repository &gt; Tags &gt; New Tag</li> <li>This will trigger Gitlab CI to publish a new container image based on the latest commit in the <code>main</code> branch and will be named as per the new Tag.</li> <li>Test the image locally: <code>docker run -p 8080:80 desktop-controller:latest</code> then browse to http://localhost:8080/api/docs</li> </ol>"},{"location":"samples/desktop_controller/#settings","title":"Settings","text":"<p>Required configuration:</p> <ul> <li>create new SSH key pair</li> <li>install the private key into the container and the public key into the DockerHost/SSH server</li> <li>mount the SSH private key to <code>:/app/id_rsa</code> when starting the container</li> <li>add the pub key to the DockerHost's <code>~/.ssh/authorized_keys</code></li> <li>add env var <code>DOCKER_HOST_USER_NAME</code> with the sys-admin' username on the DockerHost!</li> </ul> <p>See App Settings.</p>"},{"location":"samples/desktop_controller/#testing","title":"Testing","text":"<p>The API has a sample <code>Command</code> that ultimately resolves to remotely run <code>~/test_shell_script_on_host.sh -i {user_input}</code> on the DockerHost. </p> <p>See sample_bin/test_shell_script_on_host.sh.</p> <p>E.g.: Install with</p> <pre><code># copy the sample shell script on the Docker Host' user' home folder\ncp sample_bin/test_shell_script_on_host.sh ~/test_shell_script_on_host.sh\n\n# set permissions to execute\nchmod a+x ~/test_shell_script_on_host.sh\n\n# set ownership\nchown $USERNAME:staff ~/test_shell_script_on_host.sh\n\n# test run as user:\n~/test_shell_script_on_host.sh -i \"my input value\"\n\nAdding a new line my input value to /tmp/test.txt...\n\n# verify local file on Docker Host: \ncat /tmp/test.txt\n\nUserInput: my input value\n\n</code></pre>"},{"location":"samples/desktop_controller/#test_shell_script_on_hostsh","title":"test_shell_script_on_host.sh","text":"<p>See sample_bin/test_shell_script_on_host.sh.</p> <p>This test script just adds a line to a file <code>/tmp/test.txt</code>.</p> <pre><code>#!/bin/bash\n\n# test_shell_script_on_host.sh\n\nif [ $# -lt 2 ]; then\n  echo \"Error: Please provide an argument after the -i flag.\"\n  exit 1\nfi\n\nif [ \"$1\" != \"-i\" ]; then\n  echo \"Error: Please use the -i flag followed by your argument.\"\n  exit 1\nfi\n\nargument=\"$2\"\n\necho \"Adding a new line $argument to /tmp/test.txt...\"\n\necho \"UserInput: $argument\" &gt;&gt; /tmp/test.txt\n\n</code></pre>"},{"location":"samples/desktop_controller/#call-test-endpoint","title":"Call Test Endpoint","text":"<p>The HTTP <code>Command</code> runs a SSH client that simply connects to the DockerHost at <code>host.docker.internal</code> (with preconfigured username and SSH keys) and runs a custom command_line.</p> <p>From SwaggerUI</p> <p><code>http://localhost:9781/api/docs#/Custom/run_test_write_file_on_host_api_v1_custom_test_shell_script_on_host_sh_post</code></p> <p>From Curl: (will need <code>Authorization</code> header with JWT, see API Auth)</p> <pre><code>curl -X 'POST' \\\n  'http://localhost:9781/api/v1/custom/test/shell_script_on_host.sh' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n  \"user_input\": \"my input value\"\n}'\n</code></pre> <pre><code># 201   Response body\n{\n  \"command_line\": \"~/test_shell_script_on_host.sh -i my_input_value\",\n  \"stdout\": [\n    \"Adding a new line my_input_value to /tmp/test.txt...\"\n  ],\n  \"stderr\": [],\n  \"aggregate_id\": \"4c660c0572d8449598ee5fde58e04423\",\n  \"success\": true\n}\n</code></pre>"},{"location":"samples/desktop_controller/#api-authentication","title":"API Authentication","text":"<p>We're using Keycloak as the IDP. See <code>deployment/keycloak/realm-config.json</code> for sample keycloak config.</p> <p>The intent is that \"whoever\" wants to remotely control a desktop first needs to get a valid token from the common Keycloak instance (which is the one that the VDI/BYOD Desktops - ie. DockerHosts have access to!).</p> <p>Local testings can be done with a local/dev Keycloak instance. Just include it in <code>docker-compose.yml</code>!</p> <pre><code>version: \"3.4\"\n\nname: mozart-dev\nservices:\n  # http://localhost:9780\n  keycloak97:\n    image: jboss/keycloak\n    environment:\n      - KEYCLOAK_USER=admin\n      - KEYCLOAK_PASSWORD=admin\n      - KEYCLOAK_IMPORT=/tmp/realm-export.json\n    volumes:\n      - ./deployment/keycloak/realm-config.json:/tmp/realm-export.json\n    ports:\n      - 9780:8080\n    networks:\n      - desktopcontrollernet\n</code></pre> <p>Login at http://localhost:9780 using <code>admin</code>:<code>admin</code></p>"},{"location":"samples/desktop_controller/#source-code","title":"Source Code","text":""},{"location":"samples/desktop_controller/#context","title":"Context","text":""},{"location":"samples/desktop_controller/#containers","title":"Containers","text":""},{"location":"samples/desktop_controller/#components","title":"Components","text":""},{"location":"samples/desktop_controller/#code","title":"Code","text":""},{"location":"samples/desktop_controller/#app-settings","title":"App Settings","text":"<pre><code>    environment:\n      APP_TITLE: Remote Desktop Controller\n      LOCAL_DEV: true\n      LOG_LEVEL: DEBUG\n\n      CLOUD_EVENT_SINK: http://event-player97/events/pub\n      CLOUD_EVENT_SOURCE: https://desktop-controller.domain.com\n      CLOUD_EVENT_TYPE_PREFIX: com.domain.desktop-controller\n\n      OAUTH2_SCHEME: client_credentials  # authorization_code or client_credentials\n      JWT_AUTHORITY: http://keycloak97/auth/realms/mozart\n      JWT_SIGNING_KEY: MIIBIj...copy_from_keycloak...elJ3dvQIDAQAB\n      JWT_AUDIENCE: desktops\n      REQUIRED_SCOPE: api\n\n      SWAGGER_UI_JWT_AUTHORITY: http://localhost:9780/auth/realms/mozart\n      SWAGGER_UI_CLIENT_ID: desktop-controller\n      SWAGGER_UI_CLIENT_SECRET: 6Wbr0V1TtgEUPUCRSqHh1T0vYuVyG0aa\n\n      USER_INFO_FILE_NAME: '/tmp/userinfo.json'\n      HOST_INFO_FILE_NAME: '/tmp/hostinfo.json'\n      DOCKER_HOST_USER_NAME: bvandewe  # UPDATE TO YOUR LOCAL USERNAME!\n      DOCKER_HOST_HOST_NAME: host.docker.internal\n\n</code></pre> <p>Set corresponding <code>ENV VARS</code> in <code>docker-compose.yml</code>.</p> <p>Pydantic settings automatically parses environment variables, see ./src/api/settings.py.</p> <pre><code># ./src/api/settings.py\n\nfrom neuroglia.hosting.abstractions import ApplicationSettings\nfrom pydantic import ConfigDict\n\n\nclass DesktopControllerSettings(ApplicationSettings):\n    model_config = ConfigDict(extra=\"allow\")\n\n    required_scopes: str\n    jwt_authority: str\n    jwt_signing_key: str\n    jwt_audience: str = \"desktops\"\n    docker_host_user_name: str = \"sys-admin\"\n    userinfo_filename: str = \"/app/data/userinfo.json\"\n    ...\n\napp_settings = DesktopControllerSettings(_env_file=\".env\")\n\n</code></pre>"},{"location":"samples/desktop_controller/#app-bootup","title":"App Bootup","text":"<p>The <code>main.py</code> file pre-loads all required services using the Dependency Injection mechanism from the neuroglia framework.</p> <p>API Controllers and Application Handlers may then declare any dependencies in their constructor (<code>def __init__(self, my_dependency: RegisteredDependency)</code>) and the framework will provide the instance!</p> <p>See Dependency Injection.</p> <pre><code># ./src/main.py\n...\nbuilder = WebApplicationBuilder()\n\n# required shared resources\nMapper.configure(builder, application_modules)\nMediator.configure(builder, application_modules)\nJsonSerializer.configure(builder)\nCloudEventIngestor.configure(builder, application_modules)\nCloudEventPublisher.configure(builder)\n\n# custom shared resources\n# \n# ADD ANY REQUIRED RESOURCE\nbuilder.services.add_scoped(paramiko.SSHClient, paramiko.SSHClient)\nbuilder.services.add_scoped(SecuredDockerHost, SecuredDockerHost)\nbuilder.services.add_singleton(DockerHostSshClientSettings, singleton=DockerHostSshClientSettings(username=builder.settings.docker_host_user_name))\nbuilder.services.add_scoped(DockerHostCommandRunner, DockerHostCommandRunner)\n\n# app\napp = builder.build()\n...\napp.run()\n</code></pre>"},{"location":"samples/desktop_controller/#dependency-injection","title":"Dependency Injection","text":"<ol> <li>Add a Custom Service source code file (likely in any of the <code>application_modules</code> folder in <code>./src/api/controllers</code> or <code>./src/application/commands</code> or <code>./src/application/queries</code> or <code>./src/application/events</code>) that requires a <code>Dependency</code>:</li> </ol> <p>```python   # ./src/application/services/docker_host_command_runner.py   ...   class DockerHostCommandRunner:       def init(self, secured_docker_host: SecuredDockerHost):  # Declare Dependencies!           self.secured_docker_host = secured_docker_host</p> <pre><code>  secured_docker_host: SecuredDockerHost  # Injected when handling a Command!\n\n  async def run(self, command: HostCommand) -&gt; dict[str, Any]:\n      data = {}\n      await self.secured_docker_host.connect()\n      stdout, stderr = await self.secured_docker_host.execute_command(command)\n      await self.secured_docker_host.close()\n      stdout_lines = [line.strip() for line in stdout.splitlines() if line.strip()]\n      data = {\"command_line\": command.line, \"stdout\": stdout_lines, \"stderr\": stderr.splitlines() if stderr else []}\n      return data\n</code></pre> <p>...   ```</p> <ol> <li>Add the source code for the dependency itself (likely in <code>./src/integration/services</code>!). It may also include other dependencies! (e.g. <code>DockerHostSshClientSettings</code>!!)</li> </ol> <p>```python   # ./src/integration/services/secured_docker_host.py   ...</p> <p>class DockerHostSshClientSettings(BaseModel):       username: str       hostname: str = \"host.docker.internal\"       port: int = 22       private_key_filename: str = \"/app/id_rsa\"   ...   class SecuredDockerHost:       \"\"\"Service that Securely provides access to the Docker Host's Shell via SSH.\"\"\"</p> <pre><code>  def __init__(self, ssh_client: paramiko.SSHClient, ssh_client_settings: DockerHostSshClientSettings):\n      self.hostname: str = ssh_client_settings.hostname\n      self.port: int = ssh_client_settings.port\n      self.username: str = ssh_client_settings.username\n      self.private_key_filename: str = ssh_client_settings.private_key_filename\n      self.ssh_client: paramiko.SSHClient = ssh_client\n      self.ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n\n  async def connect(self):\n      ...\n\n  async def execute_command(self, command: HostCommand):\n      async def run_command(command_line: str):\n          ...\n\n      stdout, stderr = await run_command(command.line)\n      return stdout.decode(), stderr.decode()\n\n  async def close(self):\n      ...\n</code></pre> <p>```</p> <ol> <li>Register its service_type (<code>singleton</code>, <code>scoped</code>, <code>transient</code>) in the <code>main.py</code> bootup script</li> </ol> <p><code>python   # ./src/main.py   ...   builder.services.add_scoped(paramiko.SSHClient, paramiko.SSHClient)   builder.services.add_scoped(SecuredDockerHost, SecuredDockerHost)   builder.services.add_singleton(DockerHostSshClientSettings, singleton=DockerHostSshClientSettings(username=builder.settings.docker_host_user_name))   builder.services.add_scoped(DockerHostCommandRunner, DockerHostCommandRunner)   ...</code></p> <ol> <li>Declare it as a dependency in a consumer Service, e.g. Application's <code>CommandHandler</code>: </li> </ol> <p>Note how the <code>DockerHostCommandRunner</code> is just declared as a dependency in the constructor function <code>__init__</code>! This is the same for the other dependencies (<code>CloudEventBus</code>, <code>CloudEventPublishingOptions</code>)</p> <p>```python</p> <p>@map_from(TestHostScriptCommandDto)   @map_to(TestHostScriptCommandDto)   @dataclass   class TestHostScriptCommand(Command):       user_input: str</p> <p>class TestHostScriptCommandsHandler(CommandHandler[TestHostScriptCommand, OperationResult[Any]]):       \"\"\"Represents the service used to handle UserInfo-related Commands\"\"\"</p> <pre><code>  cloud_event_bus: CloudEventBus\n  \"\"\" Gets the service used to observe the cloud events consumed and produced by the application \"\"\"\n\n  cloud_event_publishing_options: CloudEventPublishingOptions\n  \"\"\" Gets the options used to configure how the application should publish cloud events \"\"\"\n\n  docker_host_command_runner: DockerHostCommandRunner\n\n  def __init__(self, cloud_event_bus: CloudEventBus, cloud_event_publishing_options: CloudEventPublishingOptions, docker_host_command_runner: DockerHostCommandRunner):\n      self.cloud_event_bus = cloud_event_bus\n      self.cloud_event_publishing_options = cloud_event_publishing_options\n      self.docker_host_command_runner = docker_host_command_runner\n\n  async def handle_async(self, command: TestHostScriptCommand) -&gt; OperationResult[Any]:\n      command_id = str(uuid.uuid4()).replace(\"-\", \"\")\n      command_line = HostCommand()\n      data = {}\n      try:\n          line = f\"~/test_shell_script_on_host.sh -i {command.user_input.replace(' ', '_')}\"\n          log.debug(f\"TestHostScriptCommand Line: {line}\")\n          await self.publish_cloud_event_async(DesktopHostCommandReceivedIntegrationEventV1(aggregate_id=command_id, command_line=line))\n\n          command_line.line = line\n          data = await self.docker_host_command_runner.run(command_line)\n          data.update({\"aggregate_id\": command_id})\n          log.debug(f\"TestHostScriptCommand: {data}\")\n\n          await self.publish_cloud_event_async(DesktopHostCommandExecutedIntegrationEventV1(**data))\n          data.update({\"success\": True}) if len(data[\"stderr\"]) == 0 else data.update({\"success\": False})\n          return self.created(data)\n\n      except Exception as ex:\n          return self.bad_request(f\"Exception when trying to run a shell script on the host: {command_line.line}: {data}: {ex}\")\n</code></pre> <p>```</p>"},{"location":"samples/desktop_controller/#api-controllers","title":"API Controllers","text":"<ul> <li>inherits ControllerBase</li> </ul> <pre><code># ./src/api/controllers/host_controller.py\n\nclass HostController(ControllerBase):\n    def __init__(self, service_provider: ServiceProviderBase, mapper: Mapper, mediator: Mediator):\n        ControllerBase.__init__(self, service_provider, mapper, mediator)\n\n    @post(\"/info\", response_model=Any, status_code=201, responses=ControllerBase.error_responses)\n    async def set_host_info(self, command_dto: SetHostInfoCommandDto, token: str = Depends(validate_token)) -&gt; Any:\n        \"\"\"Sets data of the hostinfo.json file.\"\"\"\n        log.debug(f\"set_host_info: command_dto:{command_dto}, token={token}\")\n        return self.process(await self.mediator.execute_async(self.mapper.map(command_dto, SetHostInfoCommand)))\n\n    @get(\"/info\", response_model=Any, status_code=201, responses=ControllerBase.error_responses)\n    async def get_host_info(self):\n        query = ReadHostInfoQuery()\n        log.debug(f\"get_host_info: query:{query}\")\n        return self.process(await self.mediator.execute_async(query))\n\n</code></pre>"},{"location":"samples/open_bank/","title":"OpenBank","text":"<p>See samples/openbank...</p>"}]}