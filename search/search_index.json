{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udf55 Neuroglia Python Framework","text":"<p>Neuroglia is a lightweight, opinionated framework built on FastAPI that enforces clean architecture principles and provides comprehensive tooling for building maintainable microservices. Through practical examples with Mario's Pizzeria, we'll show you how to build production-ready applications using CQRS, dependency injection, and event-driven architecture.</p>"},{"location":"#what-youll-build-marios-pizzeria-management-system","title":"\ud83c\udfaf What You'll Build: Mario's Pizzeria Management System","text":"<p>Throughout the documentation, we use Mario's Pizzeria as a unified example to demonstrate every framework feature:</p> <ul> <li>\ud83d\udccb Order Management: Place orders, track status, handle payments</li> <li>\ud83c\udf55 Menu Administration: Manage pizzas, ingredients, pricing  </li> <li>\ud83d\udc68\u200d\ud83c\udf73 Kitchen Operations: Workflow management, status updates, notifications</li> <li>\ud83d\udcca Analytics: Order tracking, sales reporting, customer insights</li> <li>\ud83d\udd10 Authentication: OAuth-based access control for staff and customers</li> </ul> <p>This real-world example shows how all framework components work together to create a complete business application.</p>"},{"location":"#what-makes-neuroglia-special","title":"\u2728 What Makes Neuroglia Special?","text":"<ul> <li>\ud83c\udfd7\ufe0f Clean Architecture Enforced: Clear separation between API, Application, Domain, and Integration layers</li> <li>\ud83d\udc89 Powerful Dependency Injection: Lightweight container with automatic service discovery and lifetime management</li> <li>\ud83c\udfaf CQRS &amp; Mediation Built-in: Command Query Responsibility Segregation with comprehensive mediator pattern</li> <li>\ud83d\udce1 Event-Driven by Design: Native CloudEvents support, domain events, and reactive programming</li> <li>\ud83d\udd0c MVC Done Right: Class-based controllers with automatic discovery and OpenAPI generation</li> <li>\ud83d\uddc4\ufe0f Flexible Data Access: Repository pattern with file-based, MongoDB, and event sourcing support</li> <li>\ud83d\udcca Smart Object Mapping: Bidirectional mapping between domain models and DTOs</li> <li>\ud83e\uddea Testing First: Built-in testing utilities and patterns for all architectural layers</li> </ul>"},{"location":"#quick-start-your-first-pizzeria-app","title":"\ud83d\ude80 Quick Start: Your First Pizzeria App","text":"<p>Get Mario's Pizzeria running in minutes:</p> <pre><code># Install Neuroglia\npip install neuroglia\n\n# Create a simple pizzeria API\n</code></pre> <pre><code># main.py\nfrom dataclasses import dataclass\nfrom typing import List\nfrom neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.mvc import ControllerBase\nfrom classy_fastapi import get, post\n\n@dataclass\nclass PizzaDto:\n    name: str\n    size: str\n    price: float\n\n@dataclass\nclass OrderDto:\n    id: str\n    customer_name: str\n    pizzas: List[PizzaDto]\n    total: float\n    status: str\n\nclass MenuController(ControllerBase):\n    \"\"\"Mario's menu management\"\"\"\n\n    @get(\"/menu/pizzas\", response_model=List[PizzaDto])\n    async def get_pizzas(self) -&gt; List[PizzaDto]:\n        return [\n            PizzaDto(\"Margherita\", \"large\", 15.99),\n            PizzaDto(\"Pepperoni\", \"large\", 17.99),\n            PizzaDto(\"Quattro Stagioni\", \"large\", 19.99)\n        ]\n\nclass OrdersController(ControllerBase):\n    \"\"\"Mario's order management\"\"\"\n\n    @post(\"/orders\", response_model=OrderDto)\n    async def place_order(self, customer_name: str, pizza_names: List[str]) -&gt; OrderDto:\n        # Simple order creation\n        pizzas = [PizzaDto(name, \"large\", 15.99) for name in pizza_names]\n        total = sum(p.price for p in pizzas)\n\n        return OrderDto(\n            id=\"order_123\",\n            customer_name=customer_name,\n            pizzas=pizzas,\n            total=total,\n            status=\"received\"\n        )\n\ndef create_pizzeria_app():\n    \"\"\"Create Mario's Pizzeria application\"\"\"\n    builder = WebApplicationBuilder()\n\n    # Add controllers\n    builder.services.add_controllers([\"__main__\"])\n\n    app = builder.build()\n    app.use_controllers()\n\n    return app\n\nif __name__ == \"__main__\":\n    app = create_pizzeria_app()\n    app.run()\n</code></pre> <pre><code># Run the pizzeria\npython main.py\n\n# Test the API\ncurl http://localhost:8000/menu/pizzas\ncurl -X POST \"http://localhost:8000/orders?customer_name=Mario\" \\\n     -H \"Content-Type: application/json\" \\\n     -d '[\"Margherita\", \"Pepperoni\"]'\n</code></pre> <p>\ud83d\udc49 Complete Tutorial: Build the Full Pizzeria System</p>"},{"location":"#architecture-overview","title":"\ufffd\ufe0f Architecture Overview","text":"<p>Mario's Pizzeria demonstrates clean, layered architecture:</p> <pre><code>    \ud83c\udf10 API Layer (Controllers &amp; DTOs)\n         OrdersController, MenuController, KitchenController\n         \u2193 Commands &amp; Queries\n    \ud83d\udcbc Application Layer (CQRS Handlers)\n         PlaceOrderHandler, GetMenuHandler, UpdateOrderStatusHandler\n         \u2193 Domain Operations  \n    \ud83c\udfdb\ufe0f Domain Layer (Business Logic)\n         Order, Pizza, Customer entities with business rules\n         \u2191 Repository Interfaces\n    \ud83d\udd0c Integration Layer (Data &amp; External Services)\n         FileOrderRepository, MongoOrderRepository, PaymentService\n</code></pre> <p>Each layer has specific responsibilities:</p> <ul> <li>\ud83c\udf10 API Layer: HTTP endpoints, request/response handling, authentication</li> <li>\ud83d\udcbc Application Layer: Business workflows, command/query processing, event coordination</li> <li>\ud83c\udfdb\ufe0f Domain Layer: Core business rules, entity logic, domain events</li> <li>\ud83d\udd0c Integration Layer: Data persistence, external APIs, infrastructure services</li> </ul> <p>\ud83d\udcd6 Deep Dive: Clean Architecture with Mario's Pizzeria</p>"},{"location":"#core-features","title":"\ud83c\udfaa Core Features","text":""},{"location":"#dependency-injection","title":"\ud83d\udc89 Dependency Injection","text":"<p>Powerful service container demonstrated through Mario's Pizzeria:</p> <pre><code># Service registration for pizzeria\nbuilder.services.add_scoped(IOrderRepository, FileOrderRepository)\nbuilder.services.add_scoped(IPaymentService, MockPaymentService) \nbuilder.services.add_mediator()\nbuilder.services.add_controllers([\"api.controllers\"])\n\n# Constructor injection in controllers\nclass OrdersController(ControllerBase):\n    def __init__(self, service_provider: ServiceProviderBase, \n                 mapper: Mapper, mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n    @post(\"/orders\", response_model=OrderDto)\n    async def place_order(self, request: PlaceOrderDto) -&gt; OrderDto:\n        command = self.mapper.map(request, PlaceOrderCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre> <p>\ud83d\udcd6 Dependency Injection with Mario's Pizzeria</p>"},{"location":"#cqrs-mediation","title":"\ud83c\udfaf CQRS &amp; Mediation","text":"<p>Clean command/query separation demonstrated through pizza ordering:</p> <pre><code># Command for placing orders\n@dataclass\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    customer_name: str\n    customer_phone: str\n    customer_address: str\n    pizzas: List[PizzaOrderDto]\n    payment_method: str\n\n# Handler with business logic\nclass PlaceOrderCommandHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    def __init__(self, order_repository: IOrderRepository, \n                 payment_service: IPaymentService,\n                 mapper: Mapper):\n        self.order_repository = order_repository\n        self.payment_service = payment_service\n        self.mapper = mapper\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        # 1. Create domain entity with business logic\n        pizzas = [Pizza(p.name, p.size, p.extras) for p in command.pizzas]\n        order = Order.create_new(\n            command.customer_name, \n            command.customer_phone,\n            command.customer_address,\n            pizzas,\n            command.payment_method\n        )\n\n        # 2. Process payment\n        payment_result = await self.payment_service.process_payment_async(\n            order.total_amount, command.payment_method\n        )\n        if not payment_result.is_success:\n            return self.bad_request(\"Payment processing failed\")\n\n        # 3. Save order and return result\n        saved_order = await self.order_repository.save_async(order)\n        order_dto = self.mapper.map(saved_order, OrderDto)\n        return self.created(order_dto)\n\n# Query for retrieving menu\n@dataclass  \nclass GetMenuQuery(Query[List[PizzaDto]]):\n    category: Optional[str] = None\n\nclass GetMenuQueryHandler(QueryHandler[GetMenuQuery, List[PizzaDto]]):\n    async def handle_async(self, query: GetMenuQuery) -&gt; List[PizzaDto]:\n        # Query logic here\n        pizzas = await self.pizza_repository.get_all_async()\n        if query.category:\n            pizzas = [p for p in pizzas if p.category == query.category]\n        return [self.mapper.map(p, PizzaDto) for p in pizzas]\n\n# Usage in controller\n@post(\"/orders\", response_model=OrderDto)\nasync def place_order(self, request: PlaceOrderDto) -&gt; OrderDto:\n    command = self.mapper.map(request, PlaceOrderCommand)\n    result = await self.mediator.execute_async(command)\n    return self.process(result)\n</code></pre> <p>\ud83d\udcd6 CQRS &amp; Mediation with Mario's Pizzeria</p>"},{"location":"#mvc-controllers","title":"\ud83d\udd0c MVC Controllers","text":"<p>Class-based controllers with automatic discovery demonstrated through pizzeria APIs:</p> <pre><code>class OrdersController(ControllerBase):\n    \"\"\"Mario's order management endpoint\"\"\"\n\n    @post(\"/orders\", response_model=OrderDto, status_code=201)\n    async def place_order(self, request: PlaceOrderDto) -&gt; OrderDto:\n        \"\"\"Place a new pizza order\"\"\"\n        command = self.mapper.map(request, PlaceOrderCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @get(\"/orders/{order_id}\", response_model=OrderDto)\n    async def get_order(self, order_id: str) -&gt; OrderDto:\n        \"\"\"Get order details by ID\"\"\"\n        query = GetOrderByIdQuery(order_id=order_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\nclass MenuController(ControllerBase):\n    \"\"\"Mario's menu management\"\"\"\n\n    @get(\"/menu/pizzas\", response_model=List[PizzaDto])\n    async def get_pizzas(self, category: Optional[str] = None) -&gt; List[PizzaDto]:\n        \"\"\"Get available pizzas, optionally filtered by category\"\"\"\n        query = GetMenuQuery(category=category)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n# Automatic OpenAPI documentation generation\n# Built-in validation, error handling, and response formatting\n</code></pre> <p>\ud83d\udcd6 MVC Controllers with Mario's Pizzeria</p>"},{"location":"#event-driven-architecture","title":"\ud83d\udce1 Event-Driven Architecture","text":"<p>Native support for domain events and reactive programming demonstrated through pizzeria operations:</p> <pre><code># Domain events in Mario's Pizzeria\n@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    order_id: str\n    customer_name: str\n    total_amount: Decimal\n    pizzas: List[str]\n\n@dataclass\nclass OrderReadyEvent(DomainEvent):\n    order_id: str\n    customer_phone: str\n    pickup_time: datetime\n\n# Event handlers for pizzeria workflow\nclass KitchenNotificationHandler(EventHandler[OrderPlacedEvent]):\n    \"\"\"Notify kitchen when order is placed\"\"\"\n    async def handle_async(self, event: OrderPlacedEvent):\n        await self.kitchen_service.add_to_queue(event.order_id, event.pizzas)\n\nclass CustomerNotificationHandler(EventHandler[OrderReadyEvent]):\n    \"\"\"Notify customer when order is ready\"\"\"\n    async def handle_async(self, event: OrderReadyEvent):\n        message = f\"Your order {event.order_id} is ready for pickup!\"\n        await self.sms_service.send_message(event.customer_phone, message)\n\n# Events are automatically published when domain entities change\nclass Order(Entity):\n    def update_status(self, new_status: OrderStatus, updated_by: str):\n        self.status = new_status\n        self.last_updated = datetime.utcnow()\n        self.updated_by = updated_by\n\n        # Raise domain event\n        if new_status == OrderStatus.READY:\n            self.raise_event(OrderReadyEvent(\n                order_id=self.id,\n                customer_phone=self.customer_phone,\n                pickup_time=datetime.utcnow()\n            ))\n</code></pre> <p>\ud83d\udcd6 Event-Driven Architecture with Mario's Pizzeria</p>"},{"location":"#data-access","title":"\ud83d\uddc4\ufe0f Data Access","text":"<p>Flexible repository pattern with multiple storage backends demonstrated through Mario's Pizzeria:</p> <pre><code># Repository interface for orders\nclass IOrderRepository(Repository[Order, str]):\n    async def get_by_customer_phone_async(self, phone: str) -&gt; List[Order]:\n        pass\n\n    async def get_orders_by_status_async(self, status: OrderStatus) -&gt; List[Order]:\n        pass\n\n# File-based implementation (development)\nclass FileOrderRepository(IOrderRepository):\n    def __init__(self, data_directory: str):\n        self.data_directory = Path(data_directory)\n        self.data_directory.mkdir(exist_ok=True)\n\n    async def save_async(self, order: Order) -&gt; Order:\n        order_data = {\n            \"id\": order.id,\n            \"customer_name\": order.customer_name,\n            \"status\": order.status.value,\n            \"total_amount\": float(order.total_amount),\n            \"created_at\": order.created_at.isoformat()\n        }\n\n        file_path = self.data_directory / f\"{order.id}.json\"\n        with open(file_path, 'w') as f:\n            json.dump(order_data, f, indent=2)\n\n        return order\n\n# MongoDB implementation (production)\nclass MongoOrderRepository(IOrderRepository):\n    def __init__(self, collection: Collection):\n        self.collection = collection\n\n    async def save_async(self, order: Order) -&gt; Order:\n        document = self._order_to_document(order)\n        await self.collection.insert_one(document)\n        return order\n\n    async def get_orders_by_status_async(self, status: OrderStatus) -&gt; List[Order]:\n        cursor = self.collection.find({\"status\": status.value})\n        documents = await cursor.to_list(length=None)\n        return [self._document_to_order(doc) for doc in documents]\n\n# Event sourcing for complex workflows\nclass EventSourcedOrderRepository(IOrderRepository):\n    \"\"\"Track complete order lifecycle through events\"\"\"\n    async def save_async(self, order: Order) -&gt; Order:\n        # Persist domain events instead of just final state\n        events = order.get_uncommitted_events()\n        for event in events:\n            await self.event_store.append_async(order.id, event)\n        return order\n</code></pre> <p>\ud83d\udcd6 Data Access with Mario's Pizzeria</p>"},{"location":"#object-mapping","title":"\ud83d\udcca Object Mapping","text":"<p>Bidirectional mapping between domain entities and DTOs:</p> <pre><code># Automatic mapping configuration\nbuilder.services.add_auto_mapper()\n\n# Domain entity\nclass Order(Entity):\n    customer_name: str\n    pizzas: List[Pizza] \n    total_amount: Decimal\n    status: OrderStatus\n\n# DTO for API\n@dataclass\nclass OrderDto:\n    id: str\n    customer_name: str\n    pizzas: List[PizzaDto]\n    total_amount: float\n    status: str\n    created_at: str\n\n# Usage in handlers\nclass PlaceOrderCommandHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        # Create domain entity\n        order = Order.create_new(command.customer_name, ...)\n\n        # Save entity\n        saved_order = await self.order_repository.save_async(order)\n\n        # Map to DTO for response\n        order_dto = self.mapper.map(saved_order, OrderDto)\n        return self.created(order_dto)\n</code></pre>"},{"location":"#learn-through-marios-pizzeria","title":"\ud83c\udf93 Learn Through Mario's Pizzeria","text":"<p>All documentation uses Mario's Pizzeria as a consistent, comprehensive example:</p>"},{"location":"#complete-business-domain","title":"\ud83c\udf55 Complete Business Domain","text":"<ul> <li>\ud83d\udc65 Customer Management: Registration, authentication, order history</li> <li>\ud83d\udccb Order Processing: Place orders, payment processing, status tracking  </li> <li>\ud83c\udf55 Menu Management: Pizzas, ingredients, pricing, categories</li> <li>\ud83d\udc68\u200d\ud83c\udf73 Kitchen Operations: Order queue, preparation workflow, notifications</li> <li>\ud83d\udcca Business Analytics: Sales reports, popular items, customer insights</li> <li>\ud83d\udd10 Staff Authentication: Role-based access for different staff functions</li> </ul>"},{"location":"#architecture-demonstrated","title":"\ud83c\udfd7\ufe0f Architecture Demonstrated","text":"<p>Each major framework feature is shown through realistic pizzeria scenarios:</p> <ul> <li>\ud83c\udf10 API Layer: RESTful endpoints for customers and staff</li> <li>\ufffd Application Layer: Business workflows like order processing</li> <li>\ud83c\udfdb\ufe0f Domain Layer: Rich business entities with validation and events  </li> <li>\ud83d\udd0c Integration Layer: File storage, MongoDB, payment services, SMS notifications</li> </ul>"},{"location":"#progressive-learning-path","title":"\ud83c\udfaf Progressive Learning Path","text":"<ol> <li>\ud83d\ude80 Getting Started - Build your first pizzeria app step-by-step</li> <li>\ud83c\udfd7\ufe0f Architecture - Understand clean architecture through pizzeria layers</li> <li>\ufffd Dependency Injection - Configure pizzeria services and repositories</li> <li>\ud83c\udfaf CQRS &amp; Mediation - Implement order processing workflows</li> <li>\ufffd MVC Controllers - Build pizzeria API endpoints</li> <li>\ud83d\uddc4\ufe0f Data Access - Persist orders with file and database storage</li> </ol>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":""},{"location":"#getting-started","title":"\ud83d\ude80 Getting Started","text":"<ul> <li>Quick Start Guide - Build Mario's Pizzeria in 7 steps</li> <li>Architecture Overview - Clean architecture through pizzeria example</li> <li>Project Structure - Organize pizzeria code properly</li> </ul>"},{"location":"#feature-guides","title":"\ud83c\udfaa Feature Guides","text":"Feature Mario's Pizzeria Example Documentation \ud83c\udfd7\ufe0f Architecture Complete pizzeria system layers \ud83d\udcd6 Guide \ud83d\udc89 Dependency Injection Service registration for pizzeria \ud83d\udcd6 Guide \ud83c\udfaf CQRS &amp; Mediation Order processing commands &amp; queries \ud83d\udcd6 Guide \ud83d\udd0c MVC Controllers Pizzeria API endpoints \ud83d\udcd6 Guide \ud83d\uddc4\ufe0f Data Access Order &amp; menu repositories \ud83d\udcd6 Guide"},{"location":"#installation-requirements","title":"\ud83d\udee0\ufe0f Installation &amp; Requirements","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8+ (Python 3.11+ recommended)</li> <li>pip or poetry for dependency management</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code># Install from PyPI (coming soon)\npip install neuroglia\n\n# Or install from source for development\ngit clone https://github.com/neuroglia-io/python.git\ncd python\npip install -e .\n</code></pre>"},{"location":"#optional-dependencies","title":"Optional Dependencies","text":"<pre><code># MongoDB support\npip install neuroglia[mongo]\n\n# Event sourcing with EventStoreDB\npip install neuroglia[eventstore]\n\n# All features\npip install neuroglia[all]\n</code></pre>"},{"location":"#community-support","title":"\ud83e\udd1d Community &amp; Support","text":""},{"location":"#getting-help","title":"Getting Help","text":"<ul> <li>\ud83d\udcd6 Documentation: Comprehensive guides with Mario's Pizzeria examples</li> <li>\ud83d\udcac GitHub Discussions: Ask questions and share ideas</li> <li>\ud83d\udc1b Issues: Report bugs and request features</li> <li>\ud83d\udce7 Email: Contact maintainers directly</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions from the community:</p> <ul> <li>\ud83d\udcdd Documentation - Help improve pizzeria examples and guides</li> <li>\ud83d\udc1b Bug Reports - Help us identify and fix issues  </li> <li>\u2728 Features - Propose new framework capabilities</li> <li>\ud83e\uddea Tests - Improve test coverage and quality</li> <li>\ud83d\udd27 Code - Submit PRs with improvements and fixes</li> </ul>"},{"location":"#roadmap","title":"Roadmap","text":"<p>Upcoming features and improvements:</p> <ul> <li>Enhanced Resource Oriented Architecture - Extended watcher and controller patterns</li> <li>Advanced Event Sourcing - More sophisticated event store integrations  </li> <li>Performance Optimizations - Faster startup and runtime performance</li> <li>Additional Storage Backends - PostgreSQL, Redis, and more</li> <li>Extended Authentication - Additional OAuth providers and JWT enhancements</li> <li>Monitoring &amp; Observability - Built-in metrics and distributed tracing</li> </ul>"},{"location":"#license","title":"\ufffd License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"#why-choose-neuroglia","title":"\ud83c\udf1f Why Choose Neuroglia?","text":"<p>\u2705 Production Ready: Battle-tested patterns used in real-world applications \u2705 Developer Friendly: Intuitive APIs with consistent Mario's Pizzeria examples \u2705 Highly Testable: Comprehensive testing utilities and patterns built-in \u2705 Scalable Architecture: Clean architecture principles that grow with your needs \u2705 Modern Framework: Leverages latest Python 3.11+ and FastAPI features \u2705 Flexible Design: Use individual components or the complete framework \u2705 Excellent Documentation: Every feature explained through practical examples \u2705 Active Development: Continuously improved with community feedback  </p> <p>Ready to build Mario's Pizzeria? Get Started Now \ud83c\udf55 | Data Access | Repository pattern and persistence | \ud83d\udcd6 Guide | | Event Handling | Events, messaging, and reactive programming | \ud83d\udcd6 Guide | | Object Mapping | Automatic object-to-object mapping | \ud83d\udcd6 Guide | | Configuration | Settings and environment management | \ud83d\udcd6 Guide | | Hosting | Web application hosting and lifecycle | \ud83d\udcd6 Guide |</p>"},{"location":"#requirements","title":"\ud83d\udccb Requirements","text":"<ul> <li>Python 3.11+</li> <li>FastAPI (automatic)</li> <li>Pydantic (automatic)</li> <li>Optional: MongoDB, EventStoreDB, Redis (based on features used)</li> </ul>"},{"location":"#contributing_1","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions! Here's how you can help:</p> <ul> <li>\ud83d\udc1b Report bugs - Found an issue? Let us know!</li> <li>\ud83d\udca1 Suggest features - Have an idea? We'd love to hear it!</li> <li>\ud83d\udcdd Improve docs - Help make our documentation better</li> <li>\ud83d\udd27 Submit PRs - Code contributions are always welcome</li> </ul> <p>\ud83d\udc49 Contributing Guide</p>"},{"location":"#license_1","title":"\ud83d\udcc4 License","text":""},{"location":"#running-background-tasks","title":"Running Background Tasks","text":"<p>Neuroglia integrates with apscheduler for background tasks:</p> <pre><code>from apscheduler.schedulers.asyncio import AsyncIOScheduler\nfrom neuroglia.hosting.abstractions import HostedService\n\nclass BackgroundTaskService(HostedService):\n    def __init__(self):\n        self._scheduler = AsyncIOScheduler()\n\n    async def start_async(self):\n        # Add jobs\n        self._scheduler.add_job(self._process_data, 'interval', minutes=5)\n        self._scheduler.start()\n\n    async def stop_async(self):\n        self._scheduler.shutdown()\n\n    async def _process_data(self):\n        # Task implementation\n        pass\n</code></pre>"},{"location":"#advanced-features","title":"Advanced Features","text":""},{"location":"#real-time-communication-with-cloudevents","title":"Real-time Communication with CloudEvents","text":"<pre><code>from neuroglia.eventing.cloud_events.infrastructure import CloudEventIngestor\nfrom neuroglia.eventing.cloud_events.decorators import cloud_event_handler\n\nclass NotificationService:\n    def __init__(self, event_ingestor: CloudEventIngestor):\n        event_ingestor.subscribe(\"user.created\", self._on_user_created)\n\n    @cloud_event_handler\n    async def _on_user_created(self, event_data):\n        # Process user created event\n        user_id = event_data[\"id\"]\n        # Send notification\n</code></pre>"},{"location":"#custom-repository-implementation","title":"Custom Repository Implementation","text":"<pre><code>from neuroglia.data.infrastructure.abstractions import Repository\n\nclass CustomRepository(Repository[Entity, str]):\n    async def add(self, entity: Entity) -&gt; None:\n        # Custom implementation\n\n    async def update(self, entity: Entity) -&gt; None:\n        # Custom implementation\n\n    async def remove(self, entity: Entity) -&gt; None:\n        # Custom implementation\n\n    async def find_by_id(self, id: str) -&gt; Optional[Entity]:\n        # Custom implementation\n</code></pre>"},{"location":"#samples","title":"Samples","text":""},{"location":"#openbank","title":"OpenBank","text":"<p>Implements a simplified Bank that manages Accounts, Users and Transactions with full Event Sourcing, CQRS</p> <p>Explore OpenBank</p>"},{"location":"#desktop-controller","title":"Desktop Controller","text":"<p>Remotely and securely control custom files or commands on a Desktop running the app as a Docker container...</p> <p>Explore Desktop Controller</p>"},{"location":"#api-gateway","title":"API Gateway","text":"<p>Expose single entry point for 3rd party clients into an internal layer, like a GenAI stack... Models a Prompt entity, enforces a business logic (e.g. Prompt' state-machine), handles scheduled background task (with persistence), exposes API with multiple Security schemes, ...</p> <p>Explore API Gateway</p>"},{"location":"#cisco-remote-output-collector","title":"Cisco Remote Output Collector","text":"<p>Statefull microservice that handles complex and custom HTTP Commands which in turn each encapsulates arbitrary interactions with given Cisco Device(s) via Telnet, such as <code>FindPrompt</code>, <code>CollectCommandLineOutput</code>, <code>AddConfiguration</code>, <code>SaveConfiguration</code>, <code>Ping</code>, <code>Traceroute</code>, <code>ClearNatTranslation</code>, <code>CheckReachability</code>, <code>BounceInterface</code>, <code>RunViaTelnetTo</code>, <code>FindSpanningTreeRoot</code>, ... etc.</p> <p>Explore IOS ROC</p> <p>Current state: functional but simple implemention, 100% stateless collection of multiple CLI to a single device via Telnet.</p> <p>TODO:</p> <ul> <li>[ ] Add Session management (defines a Pod for subsequent scenarios) with persistence</li> <li>[ ] Add DeviceConnection and ConnectionManager</li> <li>[ ] Add DeviceDrivers and PromptPatterns libraries</li> <li>[ ] ...</li> </ul>"},{"location":"#deployment","title":"Deployment","text":""},{"location":"#docker-deployment","title":"Docker Deployment","text":"<p>The framework is designed to work seamlessly with Docker. A typical Dockerfile might look like:</p> <pre><code>FROM python:3.10-slim\n\nWORKDIR /app\n\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\nCOPY . .\n\nEXPOSE 8000\n\nCMD [\"uvicorn\", \"api.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n</code></pre>"},{"location":"#environment-configuration","title":"Environment Configuration","text":"<p>Following the 12-Factor App principles, configuration is stored in environment variables:</p> <pre><code>from neuroglia.hosting.abstractions import ApplicationSettings\nfrom pydantic import BaseSettings\n\nclass MyAppSettings(ApplicationSettings):\n    database_url: str\n    api_key: str\n    debug_mode: bool = False\n</code></pre>"},{"location":"#testing","title":"Testing","text":"<p>The framework supports comprehensive testing with pytest:</p> <pre><code># Example test for a command handler\nasync def test_create_user_command():\n    # Arrange\n    handler = CreateUserCommandHandler(mock_repository)\n    command = CreateUserCommand(\"test\", \"test@example.com\")\n\n    # Act\n    result = await handler.handle(command)\n\n    # Assert\n    assert result is not None\n    assert mock_repository.add.called_once\n</code></pre>"},{"location":"#best-practices","title":"Best Practices","text":"<ol> <li>Keep Domain Models Pure: Domain models should be free of infrastructure concerns</li> <li>Use Commands for State Changes: All state-changing operations should be modeled as commands</li> <li>Use Queries for Reading Data: All data retrieval should be modeled as queries</li> <li>Leverage Dependency Injection: Always use DI to create loosely coupled components</li> <li>Handle Errors with Problem Details: Use the standard ProblemDetails format for error responses</li> <li>Follow Layered Architecture: Maintain clear boundaries between API, Application, Domain, and Integration layers</li> </ol>"},{"location":"#conclusion","title":"Conclusion","text":"<p>The Neuroglia Python Framework provides a comprehensive foundation for building clean, maintainable, and feature-rich microservices. By embracing modern architectural patterns like CQRS, Event Sourcing, and Clean Architecture, it helps developers create applications that are easier to understand, test, and evolve over time.</p> <p>For more information, check out the sample applications or contribute to the framework development.</p>"},{"location":"MERMAID_SETUP/","title":"\ud83c\udfaf Mermaid Diagram Setup Summary","text":""},{"location":"MERMAID_SETUP/#completed-configuration","title":"\u2705 Completed Configuration","text":"<p>The Neuroglia Python Framework documentation now has full Mermaid diagram support configured and tested.</p>"},{"location":"MERMAID_SETUP/#what-was-configured","title":"\ud83d\udccb What Was Configured","text":"<ol> <li>MkDocs Configuration (<code>mkdocs.yml</code>):</li> <li>Added <code>mkdocs-mermaid2-plugin</code> to plugins section</li> <li>Configured <code>pymdownx.superfences</code> with custom Mermaid fence support</li> <li>Added Mermaid theme configuration with auto dark/light mode</li> <li> <p>Set primary colors to match Material theme (#1976d2)</p> </li> <li> <p>Dependencies (<code>pyproject.toml</code>):</p> </li> <li>Added <code>mkdocs-mermaid2-plugin &gt;= 1.1.1</code> dependency</li> <li> <p>Updated Poetry lock file with new dependencies</p> </li> <li> <p>Documentation Files:</p> </li> <li>Created comprehensive Mermaid documentation (<code>docs/features/mermaid-diagrams.md</code>)</li> <li>Added architecture diagram to ROA documentation</li> <li> <p>Updated navigation in <code>mkdocs.yml</code> to include Mermaid documentation</p> </li> <li> <p>Build Tools:</p> </li> <li>Created automated build script (<code>build_docs.sh</code>) with validation</li> <li>Created validation script (<code>validate_mermaid.py</code>) for testing</li> </ol>"},{"location":"MERMAID_SETUP/#technical-details","title":"\ud83d\udd27 Technical Details","text":""},{"location":"MERMAID_SETUP/#mermaid-plugin-configuration","title":"Mermaid Plugin Configuration","text":"<pre><code>plugins:\n  - search\n  - mermaid2:\n      arguments:\n        theme: auto\n        themeVariables:\n          primaryColor: '#1976d2'\n          primaryTextColor: '#ffffff'\n          primaryBorderColor: '#1976d2'\n          lineColor: '#1976d2'\n          secondaryColor: '#f5f5f5'\n          tertiaryColor: '#ffffff'\n</code></pre>"},{"location":"MERMAID_SETUP/#superfences-configuration","title":"Superfences Configuration","text":"<pre><code>markdown_extensions:\n  - pymdownx.superfences:\n      custom_fences:\n        - name: mermaid\n          class: mermaid\n          format: !!python/name:pymdownx.superfences.fence_code_format\n</code></pre>"},{"location":"MERMAID_SETUP/#validation-results","title":"\ud83d\udcca Validation Results","text":"<ul> <li>\u2705 Plugin Loading: Mermaid2 plugin initializes successfully</li> <li>\u2705 JavaScript Library: Uses Mermaid 10.4.0 from unpkg CDN</li> <li>\u2705 Theme Support: Auto theme switching (light/dark mode)</li> <li>\u2705 Diagram Count: Found diagrams in 4 documentation files</li> <li>\u2705 HTML Generation: All 18 generated HTML files contain Mermaid content</li> <li>\u2705 Build Process: Clean builds complete in ~4 seconds</li> </ul>"},{"location":"MERMAID_SETUP/#usage-examples","title":"\ud83d\ude80 Usage Examples","text":""},{"location":"MERMAID_SETUP/#basic-flowchart","title":"Basic Flowchart","text":"<pre><code>```mermaid\ngraph TD\n    A[Start] --&gt; B{Decision}\n    B --&gt;|Yes| C[Action 1]\n    B --&gt;|No| D[Action 2]\n    C --&gt; E[End]\n    D --&gt; E\n```\n</code></pre>"},{"location":"MERMAID_SETUP/#sequence-diagram","title":"Sequence Diagram","text":"<pre><code>```mermaid\nsequenceDiagram\n    participant Client\n    participant API\n    participant Service\n    participant Database\n\n    Client-&gt;&gt;API: Request\n    API-&gt;&gt;Service: Process\n    Service-&gt;&gt;Database: Query\n    Database--&gt;&gt;Service: Data\n    Service--&gt;&gt;API: Result\n    API--&gt;&gt;Client: Response\n```\n</code></pre>"},{"location":"MERMAID_SETUP/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>```mermaid\ngraph TB\n    subgraph \"API Layer\"\n        A[Controllers]\n        B[DTOs]\n    end\n\n    subgraph \"Application Layer\"\n        C[Commands/Queries]\n        D[Handlers]\n    end\n\n    subgraph \"Domain Layer\"\n        E[Entities]\n        F[Value Objects]\n    end\n\n    A --&gt; C\n    C --&gt; D\n    D --&gt; E\n```\n</code></pre>"},{"location":"MERMAID_SETUP/#build-commands","title":"\ud83d\udee0\ufe0f Build Commands","text":""},{"location":"MERMAID_SETUP/#development-server","title":"Development Server","text":"<pre><code>poetry run mkdocs serve\n# Serves on http://127.0.0.1:8000 with live reload\n</code></pre>"},{"location":"MERMAID_SETUP/#production-build","title":"Production Build","text":"<pre><code>./build_docs.sh\n# Automated build with validation and reporting\n</code></pre>"},{"location":"MERMAID_SETUP/#manual-build","title":"Manual Build","text":"<pre><code>poetry run mkdocs build --clean\n# Builds to ./site directory\n</code></pre>"},{"location":"MERMAID_SETUP/#generated-files","title":"\ud83d\udcc1 Generated Files","text":"<p>The documentation build generates: - HTML Files: 18 static HTML files in <code>./site/</code> - Mermaid Content: All diagrams converted to interactive SVG - Theme Support: Automatic dark/light mode switching - Mobile Responsive: Works on all device sizes</p>"},{"location":"MERMAID_SETUP/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Mermaid Diagrams Guide</li> <li>Resource Oriented Architecture (includes Mermaid examples)</li> <li>Sample Applications (various Mermaid diagrams)</li> </ul>"},{"location":"MERMAID_SETUP/#external-resources","title":"\ud83d\udcda External Resources","text":"<ul> <li>Mermaid.js Official Documentation</li> <li>MkDocs Material Theme</li> <li>Mermaid2 Plugin Documentation</li> </ul>"},{"location":"MERMAID_SETUP/#success-confirmation","title":"\ud83c\udf89 Success Confirmation","text":"<p>The setup is fully functional and ready for production use. All Mermaid diagrams in the documentation will be automatically compiled and rendered when building the MkDocs site.</p>"},{"location":"_pizzeria_domain/","title":"\ud83c\udf55 Pizzeria Domain Model - Documentation Example","text":"<p>This document defines the unified pizzeria domain model used consistently throughout all Neuroglia documentation.</p>"},{"location":"_pizzeria_domain/#domain-overview","title":"\ud83d\udccb Domain Overview","text":"<p>Mario's Pizzeria is a simple restaurant that: - Takes pizza orders from customers - Manages pizza recipes and inventory - Cooks pizzas in the kitchen - Tracks order status and completion - Handles payments and customer notifications</p>"},{"location":"_pizzeria_domain/#domain-entities","title":"\ud83c\udfd7\ufe0f Domain Entities","text":""},{"location":"_pizzeria_domain/#pizza","title":"Pizza","text":"<pre><code>from dataclasses import dataclass\nfrom typing import List, Optional\nfrom decimal import Decimal\nfrom neuroglia.data.abstractions import Entity\n\n@dataclass\nclass Pizza(Entity[str]):\n    \"\"\"A pizza with toppings and size\"\"\"\n    id: str\n    name: str\n    size: str  # \"small\", \"medium\", \"large\"\n    base_price: Decimal\n    toppings: List[str]\n    preparation_time_minutes: int\n\n    @property\n    def total_price(self) -&gt; Decimal:\n        return self.base_price + (Decimal(\"1.50\") * len(self.toppings))\n</code></pre>"},{"location":"_pizzeria_domain/#order","title":"Order","text":"<pre><code>@dataclass \nclass Order(Entity[str]):\n    \"\"\"A customer pizza order\"\"\"\n    id: str\n    customer_name: str\n    customer_phone: str\n    pizzas: List[Pizza]\n    status: str  # \"pending\", \"cooking\", \"ready\", \"delivered\"\n    order_time: datetime\n    estimated_ready_time: Optional[datetime] = None\n    total_amount: Optional[Decimal] = None\n\n    def __post_init__(self):\n        if self.total_amount is None:\n            self.total_amount = sum(pizza.total_price for pizza in self.pizzas)\n</code></pre>"},{"location":"_pizzeria_domain/#kitchen","title":"Kitchen","text":"<pre><code>@dataclass\nclass Kitchen(Entity[str]):\n    \"\"\"Kitchen state and cooking capacity\"\"\"\n    id: str\n    active_orders: List[str]  # Order IDs being cooked\n    max_concurrent_orders: int = 3\n\n    @property\n    def is_busy(self) -&gt; bool:\n        return len(self.active_orders) &gt;= self.max_concurrent_orders\n</code></pre>"},{"location":"_pizzeria_domain/#value-objects","title":"\ud83d\udcca Value Objects","text":""},{"location":"_pizzeria_domain/#address","title":"Address","text":"<pre><code>@dataclass\nclass Address:\n    street: str\n    city: str\n    zip_code: str\n\n    def __str__(self) -&gt; str:\n        return f\"{self.street}, {self.city} {self.zip_code}\"\n</code></pre>"},{"location":"_pizzeria_domain/#money","title":"Money","text":"<pre><code>@dataclass \nclass Money:\n    amount: Decimal\n    currency: str = \"USD\"\n\n    def __str__(self) -&gt; str:\n        return f\"${self.amount:.2f}\"\n</code></pre>"},{"location":"_pizzeria_domain/#commands-write-operations","title":"\ud83c\udfaf Commands (Write Operations)","text":""},{"location":"_pizzeria_domain/#placeordercommand","title":"PlaceOrderCommand","text":"<pre><code>@dataclass\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    customer_name: str\n    customer_phone: str\n    pizzas: List[PizzaOrderItem]\n    delivery_address: Optional[Address] = None\n</code></pre>"},{"location":"_pizzeria_domain/#startcookingcommand","title":"StartCookingCommand","text":"<pre><code>@dataclass\nclass StartCookingCommand(Command[OperationResult[OrderDto]]):\n    order_id: str\n</code></pre>"},{"location":"_pizzeria_domain/#completeordercommand","title":"CompleteOrderCommand","text":"<pre><code>@dataclass\nclass CompleteOrderCommand(Command[OperationResult[OrderDto]]):\n    order_id: str\n</code></pre>"},{"location":"_pizzeria_domain/#queries-read-operations","title":"\ud83d\udd0d Queries (Read Operations)","text":""},{"location":"_pizzeria_domain/#getorderquery","title":"GetOrderQuery","text":"<pre><code>@dataclass\nclass GetOrderQuery(Query[OperationResult[OrderDto]]):\n    order_id: str\n</code></pre>"},{"location":"_pizzeria_domain/#getmenuquery","title":"GetMenuQuery","text":"<pre><code>@dataclass  \nclass GetMenuQuery(Query[OperationResult[List[PizzaDto]]]):\n    pass\n</code></pre>"},{"location":"_pizzeria_domain/#getkitchenstatusquery","title":"GetKitchenStatusQuery","text":"<pre><code>@dataclass\nclass GetKitchenStatusQuery(Query[OperationResult[KitchenStatusDto]]):\n    pass\n</code></pre>"},{"location":"_pizzeria_domain/#events","title":"\ud83d\udce1 Events","text":""},{"location":"_pizzeria_domain/#orderplacedevent","title":"OrderPlacedEvent","text":"<pre><code>@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    order_id: str\n    customer_name: str\n    total_amount: Decimal\n    estimated_ready_time: datetime\n</code></pre>"},{"location":"_pizzeria_domain/#cookingstartedevent","title":"CookingStartedEvent","text":"<pre><code>@dataclass\nclass CookingStartedEvent(DomainEvent):\n    order_id: str\n    started_at: datetime\n</code></pre>"},{"location":"_pizzeria_domain/#orderreadyevent","title":"OrderReadyEvent","text":"<pre><code>@dataclass\nclass OrderReadyEvent(DomainEvent):\n    order_id: str\n    customer_name: str\n    customer_phone: str\n</code></pre>"},{"location":"_pizzeria_domain/#dtos-data-transfer-objects","title":"\ud83d\udccb DTOs (Data Transfer Objects)","text":""},{"location":"_pizzeria_domain/#orderdto","title":"OrderDto","text":"<pre><code>@dataclass\nclass OrderDto:\n    id: str\n    customer_name: str  \n    customer_phone: str\n    pizzas: List[PizzaDto]\n    status: str\n    total_amount: str  # Formatted money\n    order_time: str   # ISO datetime\n    estimated_ready_time: Optional[str] = None\n</code></pre>"},{"location":"_pizzeria_domain/#pizzadto","title":"PizzaDto","text":"<pre><code>@dataclass\nclass PizzaDto:\n    id: str\n    name: str\n    size: str\n    toppings: List[str]\n    price: str  # Formatted money\n</code></pre>"},{"location":"_pizzeria_domain/#createorderdto","title":"CreateOrderDto","text":"<pre><code>@dataclass\nclass CreateOrderDto:\n    customer_name: str\n    customer_phone: str\n    pizzas: List[PizzaOrderItem]\n    delivery_address: Optional[AddressDto] = None\n</code></pre>"},{"location":"_pizzeria_domain/#file-based-persistence-structure","title":"\ud83d\uddc2\ufe0f File-Based Persistence Structure","text":"<pre><code>pizzeria_data/\n\u251c\u2500\u2500 orders/\n\u2502   \u251c\u2500\u2500 2024-09-22/           # Orders by date\n\u2502   \u2502   \u251c\u2500\u2500 order_001.json\n\u2502   \u2502   \u251c\u2500\u2500 order_002.json\n\u2502   \u2502   \u2514\u2500\u2500 order_003.json\n\u2502   \u2514\u2500\u2500 index.json            # Order index\n\u251c\u2500\u2500 menu/\n\u2502   \u2514\u2500\u2500 pizzas.json           # Available pizzas\n\u251c\u2500\u2500 kitchen/\n\u2502   \u2514\u2500\u2500 status.json           # Kitchen state\n\u2514\u2500\u2500 customers/\n    \u2514\u2500\u2500 customers.json        # Customer history\n</code></pre>"},{"location":"_pizzeria_domain/#api-endpoints","title":"\ud83c\udf10 API Endpoints","text":""},{"location":"_pizzeria_domain/#orders-api","title":"Orders API","text":"<pre><code>POST   /api/orders           # Place new order\nGET    /api/orders/{id}      # Get order details  \nGET    /api/orders           # List orders\nPUT    /api/orders/{id}/cook # Start cooking\nPUT    /api/orders/{id}/ready # Mark ready\n</code></pre>"},{"location":"_pizzeria_domain/#menu-api","title":"Menu API","text":"<pre><code>GET    /api/menu            # Get available pizzas\nGET    /api/menu/{id}       # Get pizza details\n</code></pre>"},{"location":"_pizzeria_domain/#kitchen-api","title":"Kitchen API","text":"<pre><code>GET    /api/kitchen/status  # Get kitchen status\nGET    /api/kitchen/queue   # Get cooking queue\n</code></pre>"},{"location":"_pizzeria_domain/#oauth-scopes","title":"\ud83d\udd10 OAuth Scopes","text":"<pre><code>SCOPES = {\n    \"orders:read\": \"Read order information\",\n    \"orders:write\": \"Create and modify orders\", \n    \"kitchen:read\": \"View kitchen status\",\n    \"kitchen:manage\": \"Manage kitchen operations\",\n    \"menu:read\": \"View menu items\",\n    \"admin\": \"Full administrative access\"\n}\n</code></pre>"},{"location":"_pizzeria_domain/#simple-ui-pages","title":"\ud83c\udfa8 Simple UI Pages","text":"<ol> <li>Menu Page - Display available pizzas with ordering</li> <li>Order Page - Place new orders </li> <li>Status Page - Check order status</li> <li>Kitchen Dashboard - Manage cooking queue (staff only)</li> <li>Admin Panel - Manage menu and view analytics</li> </ol>"},{"location":"_pizzeria_domain/#benefits-of-this-domain","title":"\ud83d\ude80 Benefits of This Domain","text":"<ul> <li>Familiar Context - Everyone understands pizza ordering</li> <li>Clear Bounded Context - Well-defined business operations  </li> <li>Rich Domain Logic - Pricing, cooking times, status workflows</li> <li>Event-Driven - Natural events (order placed, cooking started, ready)</li> <li>Multiple User Types - Customers, kitchen staff, managers</li> <li>Simple Data Model - Easy to understand and maintain</li> <li>Realistic Complexity - Enough features to demonstrate patterns without being overwhelming</li> </ul> <p>This domain model will be used consistently across all documentation to provide clear, relatable examples of Neuroglia framework features.</p>"},{"location":"architecture/","title":"\ud83c\udfd7\ufe0f Architecture Guide","text":"<p>Neuroglia's clean architecture is demonstrated through Mario's Pizzeria, showing how layered architecture promotes separation of concerns, testability, and maintainability in a real-world application.</p>"},{"location":"architecture/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>Clean Architecture Layers: How Mario's Pizzeria separates concerns across API, Application, Domain, and Integration layers</li> <li>Dependency Flow: How pizza order workflow demonstrates the dependency rule in practice</li> <li>CQRS Implementation: How command and query separation works in kitchen operations</li> <li>Event-Driven Design: How domain events coordinate between pizza preparation and customer notifications</li> <li>Testing Strategy: How architecture enables comprehensive testing at every layer</li> </ul>"},{"location":"architecture/#marios-pizzeria-architecture","title":"\ud83c\udf55 Mario's Pizzeria Architecture","text":""},{"location":"architecture/#overview-from-order-to-pizza","title":"Overview: From Order to Pizza","text":"<p>Mario's Pizzeria demonstrates clean architecture through the complete pizza ordering and preparation workflow:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            \ud83c\udf10 API Layer (Controllers)           \u2502  \u2190 Customer &amp; Staff Interface\n\u2502   OrdersController \u2502 MenuController \u2502 Kitchen   \u2502\n\u2502   Authentication   \u2502 Error Handling \u2502 Swagger   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 orchestrates\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502       \ud83d\udcbc Application Layer (CQRS + Events)      \u2502  \u2190 Business Workflow\n\u2502  PlaceOrderCommand \u2502 GetMenuQuery \u2502 Handlers    \u2502\n\u2502  OrderPlacedEvent  \u2502 Kitchen Workflow Pipeline  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 uses\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         \ud83c\udfdb\ufe0f Domain Layer (Business Logic)        \u2502  \u2190 Pizza Business Rules\n\u2502    Order Entity    \u2502    Pizza Entity           \u2502\n\u2502  Kitchen Workflow  \u2502  Pricing Rules            \u2502\n\u2502   Domain Events    \u2502  Business Validation      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 implements\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502      \ud83d\udd0c Integration Layer (External Systems)    \u2502  \u2190 Data &amp; External APIs\n\u2502  Order Repository  \u2502  Payment Gateway          \u2502\n\u2502   File Storage     \u2502  MongoDB \u2502 Event Store    \u2502\n\u2502  SMS Notifications \u2502  Email Service            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#the-dependency-rule-in-action","title":"The Dependency Rule in Action","text":"<p>Pizza order flow demonstrates how dependencies always point inward:</p> <ol> <li>API Layer \u2192 Application Layer: Controller calls <code>PlaceOrderCommand</code></li> <li>Application Layer \u2192 Domain Layer: Handler uses <code>Order</code> entity business logic</li> <li>Integration Layer \u2192 Domain Layer: Repository implements domain <code>IOrderRepository</code> interface</li> <li>Never: Domain layer doesn't know about API controllers or database implementation</li> </ol>"},{"location":"architecture/#layer-details-with-pizza-examples","title":"\ud83c\udfe2 Layer Details with Pizza Examples","text":""},{"location":"architecture/#api-layer-customer-staff-interface","title":"\ud83d\udce1 API Layer: Customer &amp; Staff Interface","text":"<p>Purpose: External interface for Mario's Pizzeria operations</p> <p>Responsibilities:</p> <ul> <li>HTTP endpoints for orders, menu, kitchen operations</li> <li>Customer and staff authentication (OAuth 2.0)</li> <li>Request validation and error handling</li> <li>OpenAPI documentation generation</li> </ul> <p>Key Components:</p> <pre><code># src/api/controllers/orders_controller.py\nclass OrdersController(ControllerBase):\n    \"\"\"Handle customer pizza orders\"\"\"\n\n    @post(\"/\", response_model=OrderDto, status_code=201)\n    async def place_order(self, order_request: PlaceOrderDto) -&gt; OrderDto:\n        \"\"\"Place new pizza order\"\"\"\n        command = PlaceOrderCommand(\n            customer_name=order_request.customer_name,\n            customer_phone=order_request.customer_phone,\n            pizzas=order_request.pizzas,\n            payment_method=order_request.payment_method\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)  # Framework handles success/error response\n\n# src/api/dtos/order_dto.py\nclass PlaceOrderDto(BaseModel):\n    \"\"\"Request DTO for placing pizza orders\"\"\"\n    customer_name: str = Field(..., min_length=2, max_length=100)\n    customer_phone: str = Field(..., regex=r\"^\\+?1?[2-9]\\d{9}$\")\n    customer_address: str = Field(..., min_length=10, max_length=200)\n    pizzas: List[PizzaOrderDto] = Field(..., min_items=1, max_items=20)\n    payment_method: str = Field(..., regex=\"^(cash|card|online)$\")\n</code></pre> <p>Architecture Benefits:</p> <ul> <li> <ul> <li>Framework Independence: Pure business logic with no external dependencies</li> </ul> </li> </ul>"},{"location":"architecture/#integration-layer-external-systems","title":"\ud83d\udd0c Integration Layer: External Systems","text":"<p>Purpose: Handles external system interactions and data persistence</p> <p>Responsibilities:</p> <ul> <li>Data persistence (file storage, MongoDB, event store)</li> <li>External API integration (payment, notifications)</li> <li>Infrastructure concerns (caching, logging)</li> <li>Implements domain interfaces</li> </ul> <p>Integration Components:</p> <pre><code># src/integration/repositories/file_order_repository.py\nclass FileOrderRepository(IOrderRepository):\n    \"\"\"File-based order repository for development\"\"\"\n\n    def __init__(self, orders_directory: str = \"data/orders\"):\n        self.orders_directory = Path(orders_directory)\n        self.orders_directory.mkdir(parents=True, exist_ok=True)\n\n    async def save_async(self, order: Order) -&gt; Order:\n        \"\"\"Save order to JSON file\"\"\"\n        order_file = self.orders_directory / f\"{order.id}.json\"\n\n        order_data = {\n            \"id\": order.id,\n            \"customer_name\": order.customer_name,\n            \"customer_phone\": order.customer_phone,\n            \"customer_address\": order.customer_address,\n            \"pizzas\": [self._pizza_to_dict(pizza) for pizza in order.pizzas],\n            \"status\": order.status.value,\n            \"order_time\": order.order_time.isoformat(),\n            \"total_amount\": float(order.total_amount)\n        }\n\n        async with aiofiles.open(order_file, 'w') as f:\n            await f.write(json.dumps(order_data, indent=2))\n\n        return order\n\n# src/integration/services/payment_service.py\nclass StripePaymentService(IPaymentService):\n    \"\"\"Payment processing using Stripe API\"\"\"\n\n    async def process_payment_async(self, \n                                    amount: Decimal, \n                                    payment_method: str) -&gt; PaymentResult:\n        \"\"\"Process payment through Stripe\"\"\"\n        try:\n            import stripe\n            stripe.api_key = os.getenv(\"STRIPE_SECRET_KEY\")\n\n            # Create payment intent\n            intent = stripe.PaymentIntent.create(\n                amount=int(amount * 100),  # Convert to cents\n                currency=\"usd\",\n                payment_method=payment_method,\n                confirm=True,\n                return_url=\"https://marios-pizzeria.com/payment-success\"\n            )\n\n            return PaymentResult(\n                is_success=True,\n                transaction_id=intent.id,\n                amount_processed=amount\n            )\n\n        except stripe.error.StripeError as e:\n            return PaymentResult(\n                is_success=False,\n                error_message=str(e)\n            )\n\n# src/integration/services/notification_service.py\nclass TwilioNotificationService(INotificationService):\n    \"\"\"SMS notifications using Twilio\"\"\"\n\n    async def send_order_confirmation_async(self, order: Order) -&gt; None:\n        \"\"\"Send order confirmation SMS\"\"\"\n        from twilio.rest import Client\n\n        client = Client(\n            os.getenv(\"TWILIO_ACCOUNT_SID\"),\n            os.getenv(\"TWILIO_AUTH_TOKEN\")\n        )\n\n        message = (f\"Hi {order.customer_name}! Your pizza order #{order.id} \"\n                  f\"has been confirmed. Total: ${order.total_amount}. \"\n                  f\"Estimated ready time: {order.estimated_ready_time.strftime('%I:%M %p')}\")\n\n        await client.messages.create(\n            body=message,\n            from_=os.getenv(\"TWILIO_PHONE_NUMBER\"),\n            to=order.customer_phone\n        )\n\n    async def send_order_ready_notification_async(self, order: Order) -&gt; None:\n        \"\"\"Send order ready SMS\"\"\"\n        message = (f\"\ud83c\udf55 Your order #{order.id} is ready for pickup at Mario's Pizzeria! \"\n                  f\"Please arrive within 15 minutes to keep your pizzas hot.\")\n\n        # Implementation details...\n</code></pre>"},{"location":"architecture/#cqrs-implementation-in-marios-pizzeria","title":"\ud83c\udfaf CQRS Implementation in Mario's Pizzeria","text":""},{"location":"architecture/#command-and-query-separation","title":"Command and Query Separation","text":"<p>Mario's Pizzeria demonstrates CQRS (Command Query Responsibility Segregation):</p> <pre><code># Commands: Change state (Write operations)\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Command to place new pizza order\"\"\"\n    pass\n\nclass UpdateOrderStatusCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Command to update order status in kitchen\"\"\"\n    pass\n\nclass CancelOrderCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Command to cancel existing order\"\"\"\n    pass\n\n# Queries: Read state (Read operations)\nclass GetOrderByIdQuery(Query[OrderDto]):\n    \"\"\"Query to get specific order details\"\"\"\n    pass\n\nclass GetKitchenQueueQuery(Query[List[KitchenOrderDto]]):\n    \"\"\"Query to get orders in kitchen preparation queue\"\"\"\n    pass\n\nclass GetMenuQuery(Query[List[PizzaDto]]):\n    \"\"\"Query to get available pizza menu\"\"\"\n    pass\n</code></pre>"},{"location":"architecture/#benefits-of-cqrs-in-pizzeria-context","title":"Benefits of CQRS in Pizzeria Context","text":"<p>Write Side (Commands):</p> <ul> <li>Order Placement: Validates business rules, processes payments</li> <li>Kitchen Operations: Updates order status, manages workflow</li> <li>Menu Management: Updates pizza availability, pricing</li> </ul> <p>Read Side (Queries):</p> <ul> <li>Customer App: Fast menu browsing, order tracking</li> <li>Kitchen Display: Real-time queue updates</li> <li>Analytics: Revenue reports, performance metrics</li> </ul> <p>Separate Optimization:</p> <ul> <li>Commands use MongoDB for ACID transactions</li> <li>Queries use optimized read models for fast retrieval</li> <li>Analytics use event store for historical data</li> </ul>"},{"location":"architecture/#event-driven-architecture","title":"\ud83d\udcca Event-Driven Architecture","text":""},{"location":"architecture/#domain-events-in-pizza-workflow","title":"Domain Events in Pizza Workflow","text":"<p>Events coordinate between different parts of Mario's Pizzeria:</p> <pre><code># Domain events flow through the system\nOrderPlacedEvent \u2192 KitchenNotificationHandler \u2192 Kitchen Display Update\n                \u2198 CustomerConfirmationHandler \u2192 SMS Confirmation\n                \u2198 InventoryHandler \u2192 Update Pizza Availability\n\nOrderReadyEvent \u2192 CustomerNotificationHandler \u2192 \"Order Ready\" SMS\n               \u2198 DeliveryScheduleHandler \u2192 Schedule Delivery\n\nOrderCompletedEvent \u2192 AnalyticsHandler \u2192 Update Revenue Metrics\n                   \u2198 CustomerHistoryHandler \u2192 Update Customer Profile\n</code></pre>"},{"location":"architecture/#event-handler-examples","title":"Event Handler Examples","text":"<pre><code>class KitchenNotificationHandler(EventHandler[OrderPlacedEvent]):\n    \"\"\"Update kitchen display when new order placed\"\"\"\n\n    async def handle_async(self, event: OrderPlacedEvent):\n        # Add order to kitchen queue\n        command = AddToKitchenQueueCommand(\n            order_id=event.order_id,\n            estimated_ready_time=event.estimated_ready_time\n        )\n        await self.mediator.execute_async(command)\n\nclass CustomerNotificationHandler(EventHandler[OrderReadyEvent]):\n    \"\"\"Notify customer when order is ready\"\"\"\n\n    async def handle_async(self, event: OrderReadyEvent):\n        # Send SMS notification\n        await self.notification_service.send_order_ready_notification_async(\n            order_id=event.order_id,\n            customer_phone=event.customer_phone\n        )\n\nclass RevenueAnalyticsHandler(EventHandler[OrderCompletedEvent]):\n    \"\"\"Update revenue analytics when order completed\"\"\"\n\n    async def handle_async(self, event: OrderCompletedEvent):\n        # Update daily revenue\n        command = UpdateDailyRevenueCommand(\n            date=event.completed_at.date(),\n            amount=event.total_amount,\n            order_count=1\n        )\n        await self.mediator.execute_async(command)\n</code></pre>"},{"location":"architecture/#testing-strategy-across-layers","title":"\ud83e\uddea Testing Strategy Across Layers","text":""},{"location":"architecture/#layer-specific-testing-approaches","title":"Layer-Specific Testing Approaches","text":"<p>Each layer in Mario's Pizzeria has specific testing strategies:</p> <p>API Layer (Controllers):</p> <ul> <li>Unit Tests: Mock mediator, test HTTP status codes and response formatting</li> <li>Integration Tests: Test full HTTP request/response cycle with real dependencies</li> <li>Contract Tests: Validate request/response schemas match OpenAPI spec</li> </ul> <pre><code>@pytest.mark.asyncio\nasync def test_place_order_success(orders_controller, mock_mediator):\n    \"\"\"Test successful order placement through controller\"\"\"\n    # Arrange\n    order_request = PlaceOrderDto(\n        customer_name=\"Test Customer\",\n        customer_phone=\"+1234567890\",\n        pizzas=[PizzaOrderDto(name=\"Margherita\", size=\"large\", quantity=1)]\n    )\n\n    expected_order = OrderDto(id=\"order_123\", status=\"received\")\n    mock_mediator.execute_async.return_value = OperationResult.success(expected_order)\n\n    # Act\n    result = await orders_controller.place_order(order_request)\n\n    # Assert\n    assert result.id == \"order_123\"\n    assert result.status == \"received\"\n</code></pre> <p>Application Layer (Handlers):</p> <ul> <li>Unit Tests: Mock all dependencies (repositories, external services)</li> <li>Behavior Tests: Verify business workflow logic and error handling</li> <li>Event Tests: Validate domain events are raised correctly</li> </ul> <pre><code>@pytest.mark.asyncio \nasync def test_place_order_handler_workflow(mock_order_repo, mock_payment_service):\n    \"\"\"Test complete order placement workflow\"\"\"\n    # Arrange\n    handler = PlaceOrderCommandHandler(mock_order_repo, mock_payment_service, ...)\n    command = PlaceOrderCommand(customer_name=\"Test\", pizzas=[...])\n\n    mock_payment_service.process_payment_async.return_value = PaymentResult(success=True)\n    mock_order_repo.save_async.return_value = Order(id=\"order_123\")\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n    mock_payment_service.process_payment_async.assert_called_once()\n    mock_order_repo.save_async.assert_called_once()\n</code></pre> <p>Domain Layer (Entities &amp; Services):</p> <ul> <li>Unit Tests: Pure business logic testing with no external dependencies</li> <li>Business Rule Tests: Validate invariants and business constraints</li> <li>Event Tests: Ensure domain events are raised for business-significant changes</li> </ul> <pre><code>def test_order_total_calculation():\n    \"\"\"Test pizza order total calculation business logic\"\"\"\n    # Arrange\n    pizzas = [\n        Pizza(\"Margherita\", \"large\", [\"extra_cheese\"]),\n        Pizza(\"Pepperoni\", \"medium\", [])\n    ]\n\n    # Act\n    order = Order.create_new(\"Customer\", \"+1234567890\", \"Address\", pizzas, \"card\")\n\n    # Assert\n    expected_subtotal = Decimal(\"15.99\") + Decimal(\"12.99\")  # Pizza prices\n    expected_tax = expected_subtotal * Decimal(\"0.0875\")     # 8.75% tax\n    expected_delivery = Decimal(\"2.99\")                      # Delivery fee\n    expected_total = expected_subtotal + expected_tax + expected_delivery\n\n    assert order.total_amount == expected_total.quantize(Decimal(\"0.01\"))\n\ndef test_order_status_transition_validation():\n    \"\"\"Test order status transition business rules\"\"\"\n    # Arrange\n    order = Order.create_new(\"Customer\", \"+1234567890\", \"Address\", [], \"card\")\n\n    # Act &amp; Assert - Valid transition\n    order.update_status(OrderStatus.PREPARING, \"chef_mario\")\n    assert order.status == OrderStatus.PREPARING\n\n    # Act &amp; Assert - Invalid transition\n    with pytest.raises(DomainException):\n        order.update_status(OrderStatus.DELIVERED, \"chef_mario\")  # Cannot skip to delivered\n\ndef test_domain_events_raised():\n    \"\"\"Test that domain events are raised correctly\"\"\"\n    # Arrange\n    pizzas = [Pizza(\"Margherita\", \"large\", [])]\n\n    # Act\n    order = Order.create_new(\"Customer\", \"+1234567890\", \"Address\", pizzas, \"card\")\n\n    # Assert\n    events = order.get_uncommitted_events()\n    assert len(events) == 1\n    assert isinstance(events[0], OrderPlacedEvent)\n    assert events[0].order_id == order.id\n</code></pre> <p>Integration Layer (Repositories &amp; Services):</p> <ul> <li>Unit Tests: Mock external dependencies (databases, APIs)</li> <li>Integration Tests: Test against real external systems in controlled environments</li> <li>Contract Tests: Validate external API integrations</li> </ul> <pre><code>@pytest.mark.integration\nasync def test_file_order_repository_roundtrip():\n    \"\"\"Test saving and retrieving orders from file system\"\"\"\n    # Arrange\n    repository = FileOrderRepository(\"test_data/orders\")\n    order = Order.create_new(\"Test Customer\", \"+1234567890\", \"Test Address\", [], \"cash\")\n\n    # Act\n    saved_order = await repository.save_async(order)\n    retrieved_order = await repository.get_by_id_async(saved_order.id)\n\n    # Assert\n    assert retrieved_order is not None\n    assert retrieved_order.customer_name == \"Test Customer\"\n    assert retrieved_order.id == saved_order.id\n\n@pytest.mark.integration\nasync def test_stripe_payment_service():\n    \"\"\"Test payment processing with Stripe (using test API keys)\"\"\"\n    # Arrange\n    payment_service = StripePaymentService()\n    amount = Decimal(\"29.99\")\n\n    # Act\n    result = await payment_service.process_payment_async(amount, \"pm_card_visa\")\n\n    # Assert\n    assert result.is_success\n    assert result.amount_processed == amount\n    assert result.transaction_id is not None\n</code></pre>"},{"location":"architecture/#end-to-end-testing","title":"End-to-End Testing","text":"<p>Full workflow testing across all layers:</p> <pre><code>@pytest.mark.e2e\nasync def test_complete_pizza_order_workflow():\n    \"\"\"Test complete order workflow from API to persistence\"\"\"\n    async with TestClient(create_pizzeria_app()) as client:\n        # 1. Get menu\n        menu_response = await client.get(\"/api/menu/pizzas\")\n        assert menu_response.status_code == 200\n\n        # 2. Place order\n        order_data = {\n            \"customer_name\": \"E2E Test Customer\",\n            \"customer_phone\": \"+1234567890\",\n            \"customer_address\": \"123 Test St\",\n            \"pizzas\": [{\"name\": \"Margherita\", \"size\": \"large\", \"quantity\": 1}],\n            \"payment_method\": \"card\"\n        }\n\n        order_response = await client.post(\"/api/orders/\", json=order_data)\n        assert order_response.status_code == 201\n        order = order_response.json()\n\n        # 3. Update order status (kitchen)\n        status_update = {\"status\": \"preparing\", \"notes\": \"Started preparation\"}\n        status_response = await client.put(\n            f\"/api/kitchen/orders/{order['id']}/status\",\n            json=status_update,\n            headers={\"Authorization\": \"Bearer {kitchen_token}\"}\n        )\n        assert status_response.status_code == 200\n\n        # 4. Verify order status\n        check_response = await client.get(f\"/api/orders/{order['id']}\")\n        updated_order = check_response.json()\n        assert updated_order[\"status\"] == \"preparing\"\n</code></pre>"},{"location":"architecture/#dependency-injection-configuration","title":"\ud83d\udee0\ufe0f Dependency Injection Configuration","text":""},{"location":"architecture/#service-registration-for-marios-pizzeria","title":"Service Registration for Mario's Pizzeria","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\n\ndef configure_pizzeria_services(builder: WebApplicationBuilder):\n    \"\"\"Configure all services for Mario's Pizzeria\"\"\"\n\n    # Domain services\n    builder.services.add_scoped(KitchenWorkflowService)\n    builder.services.add_scoped(PricingService)\n\n    # Application services\n    builder.services.add_mediator()\n    builder.services.add_auto_mapper()\n\n    # Infrastructure services (environment-specific)\n    environment = os.getenv(\"ENVIRONMENT\", \"development\")\n\n    if environment == \"development\":\n        # File-based repositories for development\n        builder.services.add_scoped(IOrderRepository, FileOrderRepository)\n        builder.services.add_scoped(IPizzaRepository, FilePizzaRepository)\n        builder.services.add_scoped(INotificationService, ConsoleNotificationService)\n        builder.services.add_scoped(IPaymentService, MockPaymentService)\n\n    else:  # production\n        # MongoDB repositories for production\n        builder.services.add_scoped(IOrderRepository, MongoOrderRepository)\n        builder.services.add_scoped(IPizzaRepository, MongoPizzaRepository)\n        builder.services.add_scoped(INotificationService, TwilioNotificationService)\n        builder.services.add_scoped(IPaymentService, StripePaymentService)\n\n    # Event handlers\n    builder.services.add_scoped(EventHandler[OrderPlacedEvent], KitchenNotificationHandler)\n    builder.services.add_scoped(EventHandler[OrderReadyEvent], CustomerNotificationHandler)\n    builder.services.add_scoped(EventHandler[OrderCompletedEvent], AnalyticsHandler)\n\n    # Controllers\n    builder.services.add_controllers([\n        \"api.controllers.orders_controller\",\n        \"api.controllers.menu_controller\",\n        \"api.controllers.kitchen_controller\"\n    ])\n</code></pre>"},{"location":"architecture/#benefits-of-this-architecture","title":"\ud83d\ude80 Benefits of This Architecture","text":""},{"location":"architecture/#for-marios-pizzeria-business","title":"For Mario's Pizzeria Business","text":"<ul> <li>Scalability: Can handle increasing order volume by scaling individual layers</li> <li>Maintainability: Business logic changes are isolated to domain layer</li> <li>Testability: Comprehensive testing at every layer ensures reliability</li> <li>Flexibility: Easy to change storage, payment providers, or notification methods</li> <li>Team Productivity: Clear boundaries enable parallel development</li> </ul>"},{"location":"architecture/#for-development-teams","title":"For Development Teams","text":"<ul> <li>Clear Responsibilities: Each layer has well-defined purpose and boundaries</li> <li>Technology Independence: Can swap infrastructure without changing business logic  </li> <li>Parallel Development: Teams can work on different layers simultaneously</li> <li>Easy Onboarding: New developers understand system through consistent patterns</li> </ul>"},{"location":"architecture/#for-long-term-maintenance","title":"For Long-Term Maintenance","text":"<ul> <li>Evolution Support: Architecture supports changing business requirements</li> <li>Technology Updates: Infrastructure can be updated without business logic changes</li> <li>Performance Optimization: Each layer can be optimized independently</li> <li>Monitoring &amp; Debugging: Clear separation aids in troubleshooting issues</li> </ul>"},{"location":"architecture/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started Guide - Complete Mario's Pizzeria tutorial</li> <li>CQRS &amp; Mediation - Command and query patterns in depth</li> <li>Dependency Injection - Service registration and DI patterns</li> <li>MVC Controllers - API layer implementation details</li> <li>Data Access - Repository patterns and data persistence</li> </ul> <p>This architecture guide demonstrates clean architecture principles using Mario's Pizzeria as a comprehensive example. The layered approach shown here scales from simple applications to complex enterprise systems while maintaining clear separation of concerns and testability.</p>"},{"location":"architecture/#application-layer-pizza-business-workflow","title":"\ud83d\udcbc Application Layer: Pizza Business Workflow","text":"<p>Purpose: Orchestrates pizza business operations and workflows</p> <p>Responsibilities:</p> <ul> <li>Command and query handling (CQRS)</li> <li>Business workflow coordination</li> <li>Domain event processing</li> <li>Cross-cutting concerns (logging, validation, caching)</li> </ul> <p>Key Components:</p> <pre><code># src/application/commands/place_order_command.py\n@dataclass\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Command to place a pizza order\"\"\"\n    customer_name: str\n    customer_phone: str\n    customer_address: str\n    pizzas: List[PizzaOrderDto]\n    payment_method: str\n\n# src/application/handlers/place_order_handler.py\nclass PlaceOrderCommandHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    \"\"\"Handles pizza order placement business workflow\"\"\"\n\n    def __init__(self, \n                 order_repository: IOrderRepository,\n                 pizza_repository: IPizzaRepository,\n                 payment_service: IPaymentService,\n                 notification_service: INotificationService,\n                 mapper: Mapper):\n        self.order_repository = order_repository\n        self.pizza_repository = pizza_repository\n        self.payment_service = payment_service\n        self.notification_service = notification_service\n        self.mapper = mapper\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        \"\"\"Execute pizza order placement workflow\"\"\"\n        try:\n            # 1. Validate pizzas are available\n            for pizza_request in command.pizzas:\n                pizza = await self.pizza_repository.get_by_name_async(pizza_request.name)\n                if not pizza or not pizza.is_available:\n                    return self.bad_request(f\"Pizza '{pizza_request.name}' is not available\")\n\n            # 2. Calculate order total using domain logic\n            order = Order.create_new(\n                customer_name=command.customer_name,\n                customer_phone=command.customer_phone,\n                customer_address=command.customer_address,\n                pizzas=command.pizzas,\n                payment_method=command.payment_method\n            )\n\n            # 3. Process payment (integration layer)\n            payment_result = await self.payment_service.process_payment_async(\n                order.total_amount, command.payment_method\n            )\n\n            if not payment_result.is_success:\n                return self.bad_request(\"Payment processing failed\")\n\n            order.mark_payment_processed(payment_result.transaction_id)\n\n            # 4. Save order (integration layer)\n            saved_order = await self.order_repository.save_async(order)\n\n            # 5. Domain event will trigger kitchen notification automatically\n            # (OrderPlacedEvent is raised by Order entity)\n\n            # 6. Send customer confirmation\n            await self.notification_service.send_order_confirmation_async(saved_order)\n\n            # 7. Return success result\n            order_dto = self.mapper.map(saved_order, OrderDto)\n            return self.created(order_dto)\n\n        except Exception as ex:\n            return self.internal_server_error(f\"Failed to place order: {str(ex)}\")\n</code></pre> <p>Architecture Benefits:</p> <ul> <li>Single Responsibility: Each handler has one clear purpose</li> <li>Testability: Easy to unit test handlers with mocked repositories</li> <li>Transaction Management: Clear transaction boundaries</li> <li>Event-Driven: Domain events enable loose coupling</li> </ul>"},{"location":"architecture/#domain-layer-pizza-business-logic","title":"\ud83c\udfdb\ufe0f Domain Layer: Pizza Business Logic","text":"<p>Purpose: Contains core pizza business rules and entities</p> <p>Responsibilities:</p> <ul> <li>Business entities with behavior</li> <li>Domain services for complex business logic</li> <li>Domain events for business-significant occurrences</li> <li>Business rule validation and invariants</li> </ul> <p>Key Components:</p> <p>Key Components:</p> <ul> <li>Controllers: Handle HTTP requests and delegate to application layer</li> <li>DTOs: Data Transfer Objects for API contracts</li> <li>Middleware: Cross-cutting concerns like authentication, logging</li> </ul> <p>Example Structure:</p> <pre><code>api/\n\u251c\u2500\u2500 controllers/\n\u2502   \u251c\u2500\u2500 users_controller.py\n\u2502   \u2514\u2500\u2500 orders_controller.py\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 user_dto.py\n\u2502   \u2514\u2500\u2500 order_dto.py\n\u2514\u2500\u2500 middleware/\n    \u251c\u2500\u2500 auth_middleware.py\n    \u2514\u2500\u2500 logging_middleware.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Keep controllers thin - delegate business logic to application layer</li> <li>Use DTOs to define API contracts</li> <li>Validate input at the API boundary</li> <li>Map between DTOs and domain models</li> </ul>"},{"location":"architecture/#application-layer-srcapplication","title":"\ud83d\udcbc Application Layer (<code>src/application/</code>)","text":"<p>Purpose: Orchestrates business workflows and coordinates domain operations</p> <p>Responsibilities:</p> <ul> <li>Command and query handling</li> <li>Business workflow orchestration</li> <li>Transaction management</li> <li>Event publishing</li> <li>Application services</li> </ul> <p>Key Components:</p> <ul> <li>Commands: Represent actions that change state</li> <li>Queries: Represent read operations</li> <li>Handlers: Process commands and queries</li> <li>Services: Application-specific business logic</li> </ul> <p>Example Structure:</p> <pre><code>application/\n\u251c\u2500\u2500 commands/\n\u2502   \u251c\u2500\u2500 create_user_command.py\n\u2502   \u2514\u2500\u2500 update_user_command.py\n\u251c\u2500\u2500 queries/\n\u2502   \u251c\u2500\u2500 get_user_query.py\n\u2502   \u2514\u2500\u2500 list_users_query.py\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 user_service.py\n\u2502   \u2514\u2500\u2500 notification_service.py\n\u2514\u2500\u2500 events/\n    \u251c\u2500\u2500 user_created_event.py\n    \u2514\u2500\u2500 user_updated_event.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Each command/query should have a single responsibility</li> <li>Use the mediator pattern to decouple handlers</li> <li>Keep application services focused on coordination</li> <li>Publish domain events for side effects</li> </ul>"},{"location":"architecture/#domain-layer-srcdomain","title":"\ud83c\udfdb\ufe0f Domain Layer (<code>src/domain/</code>)","text":"<p>Purpose: Contains the core business logic and rules</p> <p>Responsibilities:</p> <ul> <li>Business entities and aggregates</li> <li>Value objects</li> <li>Domain services</li> <li>Business rules and invariants</li> <li>Domain events</li> </ul> <p>Key Components:</p> <ul> <li>Entities: Objects with identity and lifecycle</li> <li>Value Objects: Immutable objects defined by their attributes</li> <li>Aggregates: Consistency boundaries</li> <li>Domain Services: Business logic that doesn't belong to entities</li> </ul> <p>Example Structure:</p> <pre><code>domain/\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 user.py\n\u2502   \u251c\u2500\u2500 order.py\n\u2502   \u2514\u2500\u2500 address.py\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 pricing_service.py\n\u2502   \u2514\u2500\u2500 validation_service.py\n\u2514\u2500\u2500 events/\n    \u251c\u2500\u2500 user_registered.py\n    \u2514\u2500\u2500 order_placed.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Keep domain models rich with behavior</li> <li>Enforce business invariants</li> <li>Use domain events for decoupling</li> <li>Avoid dependencies on infrastructure</li> </ul>"},{"location":"architecture/#integration-layer-srcintegration","title":"\ud83d\udd0c Integration Layer (<code>src/integration/</code>)","text":"<p>Purpose: Handles external integrations and infrastructure concerns</p> <p>Responsibilities:</p> <ul> <li>Database repositories</li> <li>External API clients</li> <li>Message queue integration</li> <li>File system operations</li> <li>Caching</li> </ul> <p>Key Components:</p> <ul> <li>Repositories: Data access implementations</li> <li>API Clients: External service integrations</li> <li>DTOs: External data contracts</li> <li>Infrastructure Services: Technical concerns</li> </ul> <p>Example Structure:</p> <pre><code>integration/\n\u251c\u2500\u2500 repositories/\n\u2502   \u251c\u2500\u2500 user_repository.py\n\u2502   \u2514\u2500\u2500 order_repository.py\n\u251c\u2500\u2500 clients/\n\u2502   \u251c\u2500\u2500 payment_client.py\n\u2502   \u2514\u2500\u2500 email_client.py\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 user_entity.py\n\u2502   \u2514\u2500\u2500 payment_dto.py\n\u2514\u2500\u2500 services/\n    \u251c\u2500\u2500 cache_service.py\n    \u2514\u2500\u2500 file_service.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Implement domain repository interfaces</li> <li>Handle external failures gracefully</li> <li>Use DTOs for external data contracts</li> <li>Isolate infrastructure concerns</li> </ul>"},{"location":"architecture/#data-flow","title":"\ud83d\udd04 Data Flow","text":""},{"location":"architecture/#command-flow-write-operations","title":"Command Flow (Write Operations)","text":"<ol> <li>Controller receives HTTP request with DTO</li> <li>Controller maps DTO to Command and sends to Mediator</li> <li>Mediator routes Command to appropriate Handler</li> <li>Handler loads domain entities via Repository</li> <li>Handler executes business logic on domain entities</li> <li>Handler saves changes via Repository</li> <li>Handler publishes domain events</li> <li>Handler returns result to Controller</li> <li>Controller maps result to DTO and returns HTTP response</li> </ol> <pre><code>HTTP Request \u2192 Controller \u2192 Command \u2192 Handler \u2192 Domain \u2192 Repository \u2192 Database\n                    \u2193           \u2193        \u2193\n               HTTP Response \u2190 DTO \u2190 Result \u2190 Events\n</code></pre>"},{"location":"architecture/#query-flow-read-operations","title":"Query Flow (Read Operations)","text":"<ol> <li>Controller receives HTTP request with parameters</li> <li>Controller creates Query and sends to Mediator</li> <li>Mediator routes Query to appropriate Handler</li> <li>Handler loads data via Repository or Read Model</li> <li>Handler returns data to Controller</li> <li>Controller maps data to DTO and returns HTTP response</li> </ol> <pre><code>HTTP Request \u2192 Controller \u2192 Query \u2192 Handler \u2192 Repository \u2192 Database\n                    \u2193         \u2193       \u2193\n               HTTP Response \u2190 DTO \u2190 Result\n</code></pre>"},{"location":"architecture/#patterns-implemented","title":"\ud83c\udfad Patterns Implemented","text":""},{"location":"architecture/#1-command-query-responsibility-segregation-cqrs","title":"1. Command Query Responsibility Segregation (CQRS)","text":"<p>Separates read and write operations to optimize performance and scalability:</p> <pre><code># Command (Write)\n@dataclass\nclass CreateUserCommand(Command[OperationResult[UserDto]]):\n    email: str\n    first_name: str\n    last_name: str\n\n# Query (Read)\n@dataclass\nclass GetUserQuery(Query[OperationResult[UserDto]]):\n    user_id: str\n</code></pre>"},{"location":"architecture/#2-mediator-pattern","title":"2. Mediator Pattern","text":"<p>Decouples components by routing requests through a central mediator:</p> <pre><code># In controller\nresult = await self.mediator.execute_async(command)\n</code></pre>"},{"location":"architecture/#3-repository-pattern","title":"3. Repository Pattern","text":"<p>Abstracts data access and provides a consistent interface:</p> <pre><code>class UserRepository(Repository[User, str]):\n    async def add_async(self, user: User) -&gt; User:\n        # Implementation details\n        pass\n</code></pre>"},{"location":"architecture/#4-event-sourcing-optional","title":"4. Event Sourcing (Optional)","text":"<p>Stores state changes as events rather than current state:</p> <pre><code>class User(AggregateRoot[str]):\n    def register(self, email: str, name: str):\n        self.apply(UserRegisteredEvent(email, name))\n</code></pre>"},{"location":"architecture/#5-dependency-injection","title":"5. Dependency Injection","text":"<p>Manages object creation and dependencies:</p> <pre><code># Automatic registration\nbuilder.services.add_scoped(UserService)\n\n# Resolution\nuser_service = provider.get_required_service(UserService)\n</code></pre>"},{"location":"architecture/#testing-architecture","title":"\ud83e\uddea Testing Architecture","text":"<p>The layered architecture makes testing straightforward:</p>"},{"location":"architecture/#unit-tests","title":"Unit Tests","text":"<p>Test individual components in isolation:</p> <pre><code>def test_user_registration():\n    # Arrange\n    command = CreateUserCommand(\"test@example.com\", \"John\", \"Doe\")\n    handler = CreateUserCommandHandler(mock_repository)\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n</code></pre>"},{"location":"architecture/#integration-tests","title":"Integration Tests","text":"<p>Test interactions between layers:</p> <pre><code>def test_create_user_endpoint():\n    # Test API \u2192 Application \u2192 Domain integration\n    response = test_client.post(\"/api/v1/users\", json=user_data)\n    assert response.status_code == 201\n</code></pre>"},{"location":"architecture/#architecture-tests","title":"Architecture Tests","text":"<p>Verify architectural constraints:</p> <pre><code>def test_domain_has_no_infrastructure_dependencies():\n    # Ensure domain layer doesn't depend on infrastructure\n    domain_modules = get_domain_modules()\n    for module in domain_modules:\n        assert not has_infrastructure_imports(module)\n</code></pre>"},{"location":"architecture/#benefits","title":"\ud83d\ude80 Benefits","text":""},{"location":"architecture/#maintainability","title":"Maintainability","text":"<ul> <li>Clear boundaries: Each layer has well-defined responsibilities</li> <li>Loose coupling: Changes in one layer don't affect others</li> <li>High cohesion: Related functionality is grouped together</li> </ul>"},{"location":"architecture/#testability","title":"Testability","text":"<ul> <li>Isolated testing: Each layer can be tested independently</li> <li>Mock dependencies: External dependencies can be easily mocked</li> <li>Fast tests: Business logic tests don't require infrastructure</li> </ul>"},{"location":"architecture/#scalability","title":"Scalability","text":"<ul> <li>CQRS: Read and write models can be optimized separately</li> <li>Event-driven: Asynchronous processing for better performance</li> <li>Microservice ready: Clear boundaries make extraction easier</li> </ul>"},{"location":"architecture/#flexibility","title":"Flexibility","text":"<ul> <li>Technology agnostic: Swap implementations without affecting business logic</li> <li>Framework independence: Business logic isn't tied to web framework</li> <li>Future-proof: Architecture adapts to changing requirements</li> </ul>"},{"location":"getting-started/","title":"\ud83c\udf55 Getting Started with Neuroglia","text":"<p>Welcome to Neuroglia! Let's build Mario's Pizzeria - a complete pizza ordering system that demonstrates all the framework's features in a familiar, easy-to-understand context.</p>"},{"location":"getting-started/#what-youll-build","title":"\ud83d\udccb What You'll Build","text":"<p>By the end of this guide, you'll have a complete pizzeria application with:</p> <ul> <li>\ud83c\udf10 REST API with automatic Swagger documentation</li> <li>\ud83c\udfa8 Simple Web UI for customers and kitchen staff  </li> <li>\ud83d\udd10 OAuth Authentication for secure access</li> <li>\ud83d\udcbe File-based persistence using the repository pattern</li> <li>\ud83d\udce1 Event-driven architecture with domain events</li> <li>\ud83c\udfd7\ufe0f Clean Architecture with CQRS and dependency injection</li> </ul>"},{"location":"getting-started/#quick-setup","title":"\u26a1 Quick Setup","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>pip install neuroglia-python[web]\n</code></pre>"},{"location":"getting-started/#project-structure","title":"Project Structure","text":"<pre><code>marios-pizzeria/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 main.py                    # Application entry point\n\u2502   \u251c\u2500\u2500 domain/\n\u2502   \u2502   \u251c\u2500\u2500 pizza.py              # Pizza entity\n\u2502   \u2502   \u251c\u2500\u2500 order.py              # Order entity  \n\u2502   \u2502   \u2514\u2500\u2500 events.py             # Domain events\n\u2502   \u251c\u2500\u2500 application/\n\u2502   \u2502   \u251c\u2500\u2500 commands/             # Order placement, cooking\n\u2502   \u2502   \u2514\u2500\u2500 queries/              # Menu, order status\n\u2502   \u251c\u2500\u2500 infrastructure/\n\u2502   \u2502   \u251c\u2500\u2500 repositories/         # File-based persistence\n\u2502   \u2502   \u2514\u2500\u2500 auth.py              # OAuth configuration\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u2514\u2500\u2500 controllers/         # REST endpoints\n\u2502   \u251c\u2500\u2500 web/\n\u2502   \u2502   \u2514\u2500\u2500 static/              # Simple HTML/CSS/JS\n\u2502   \u2514\u2500\u2500 data/                    # JSON files storage\n\u2514\u2500\u2500 requirements.txt\n</code></pre>"},{"location":"getting-started/#step-1-domain-model","title":"\ud83c\udfd7\ufe0f Step 1: Domain Model","text":"<p>src/domain/pizza.py</p> <pre><code>from dataclasses import dataclass\nfrom decimal import Decimal\nfrom typing import List\nfrom neuroglia.data.abstractions import Entity\n\n@dataclass\nclass Pizza(Entity[str]):\n    \"\"\"A pizza with toppings and pricing\"\"\"\n    id: str\n    name: str\n    size: str  # \"small\", \"medium\", \"large\"\n    base_price: Decimal\n    toppings: List[str]\n    preparation_time_minutes: int\n\n    @property\n    def total_price(self) -&gt; Decimal:\n        \"\"\"Calculate total price with toppings\"\"\"\n        return self.base_price + (Decimal(\"1.50\") * len(self.toppings))\n\n    def __post_init__(self):\n        if not self.id:\n            import uuid\n            self.id = str(uuid.uuid4())\n</code></pre> <p>src/domain/order.py</p> <pre><code>from dataclasses import dataclass, field\nfrom datetime import datetime, timedelta\nfrom decimal import Decimal\nfrom typing import List, Optional\nfrom neuroglia.data.abstractions import Entity\nfrom .pizza import Pizza\nfrom .events import OrderPlacedEvent\n\n@dataclass  \nclass Order(Entity[str]):\n    \"\"\"A customer pizza order\"\"\"\n    id: str\n    customer_name: str\n    customer_phone: str\n    pizzas: List[Pizza]\n    status: str = \"pending\"  # pending, cooking, ready, delivered\n    order_time: datetime = field(default_factory=datetime.utcnow)\n    estimated_ready_time: Optional[datetime] = None\n    total_amount: Optional[Decimal] = None\n\n    def __post_init__(self):\n        if not self.id:\n            import uuid\n            self.id = str(uuid.uuid4())\n\n        if self.total_amount is None:\n            self.total_amount = sum(pizza.total_price for pizza in self.pizzas)\n\n        if self.estimated_ready_time is None:\n            prep_time = max(pizza.preparation_time_minutes for pizza in self.pizzas)\n            self.estimated_ready_time = self.order_time + timedelta(minutes=prep_time)\n\n        # Raise domain event when order is placed\n        if self.status == \"pending\":\n            self.raise_event(OrderPlacedEvent(\n                order_id=self.id,\n                customer_name=self.customer_name,\n                total_amount=self.total_amount,\n                estimated_ready_time=self.estimated_ready_time\n            ))\n\n    def start_cooking(self):\n        \"\"\"Start cooking this order\"\"\"\n        if self.status != \"pending\":\n            raise ValueError(\"Only pending orders can start cooking\")\n        self.status = \"cooking\"\n\n    def mark_ready(self):\n        \"\"\"Mark order as ready for pickup/delivery\"\"\"\n        if self.status != \"cooking\":\n            raise ValueError(\"Only cooking orders can be marked ready\")\n        self.status = \"ready\"\n</code></pre> <p>src/domain/events.py</p> <pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom neuroglia.data.abstractions import DomainEvent\n\n@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    \"\"\"Event raised when a new order is placed\"\"\"\n    order_id: str\n    customer_name: str\n    total_amount: Decimal\n    estimated_ready_time: datetime\n\n    def __post_init__(self):\n        super().__init__(self.order_id)\n</code></pre>"},{"location":"getting-started/#step-2-commands-and-queries","title":"\ud83c\udfaf Step 2: Commands and Queries","text":"<p>src/application/commands/place_order.py</p> <pre><code>from dataclasses import dataclass\nfrom typing import List\nfrom neuroglia.mediation import Command, CommandHandler\nfrom neuroglia.core import OperationResult\nfrom neuroglia.data.abstractions import Repository\nfrom src.domain.order import Order\nfrom src.domain.pizza import Pizza\n\n@dataclass\nclass PizzaOrderItem:\n    \"\"\"Item in a pizza order\"\"\"\n    pizza_id: str\n    size: str\n    toppings: List[str]\n\n@dataclass\nclass PlaceOrderCommand(Command[OperationResult]):\n    \"\"\"Command to place a new pizza order\"\"\"\n    customer_name: str\n    customer_phone: str\n    pizza_items: List[PizzaOrderItem]\n\nclass PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult]):\n    \"\"\"Handler for placing pizza orders\"\"\"\n\n    def __init__(self, \n                 order_repository: Repository[Order, str],\n                 pizza_repository: Repository[Pizza, str]):\n        self.order_repository = order_repository\n        self.pizza_repository = pizza_repository\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult:\n        try:\n            # Build pizzas for the order\n            pizzas = []\n            for item in command.pizza_items:\n                # Get base pizza\n                base_pizza = await self.pizza_repository.get_by_id_async(item.pizza_id)\n                if not base_pizza:\n                    return self.bad_request(f\"Pizza {item.pizza_id} not found\")\n\n                # Create customized pizza\n                pizza = Pizza(\n                    id=\"\",  # Will be generated\n                    name=base_pizza.name,\n                    size=item.size,\n                    base_price=base_pizza.base_price,\n                    toppings=item.toppings,\n                    preparation_time_minutes=base_pizza.preparation_time_minutes\n                )\n                pizzas.append(pizza)\n\n            # Create the order\n            order = Order(\n                id=\"\",  # Will be generated\n                customer_name=command.customer_name,\n                customer_phone=command.customer_phone,\n                pizzas=pizzas\n            )\n\n            # Save the order\n            await self.order_repository.save_async(order)\n\n            return self.created({\n                \"order_id\": order.id,\n                \"total_amount\": str(order.total_amount),\n                \"estimated_ready_time\": order.estimated_ready_time.isoformat()\n            })\n\n        except Exception as e:\n            return self.internal_server_error(f\"Failed to place order: {str(e)}\")\n</code></pre> <p>src/application/queries/get_menu.py</p> <pre><code>from dataclasses import dataclass\nfrom typing import List\nfrom neuroglia.mediation import Query, QueryHandler\nfrom neuroglia.core import OperationResult\nfrom neuroglia.data.abstractions import Repository\nfrom src.domain.pizza import Pizza\n\n@dataclass\nclass GetMenuQuery(Query[OperationResult[List[dict]]]):\n    \"\"\"Query to get the pizzeria menu\"\"\"\n    pass\n\nclass GetMenuHandler(QueryHandler[GetMenuQuery, OperationResult[List[dict]]]):\n    \"\"\"Handler for getting the pizzeria menu\"\"\"\n\n    def __init__(self, pizza_repository: Repository[Pizza, str]):\n        self.pizza_repository = pizza_repository\n\n    async def handle_async(self, query: GetMenuQuery) -&gt; OperationResult[List[dict]]:\n        try:\n            pizzas = await self.pizza_repository.get_all_async()\n\n            menu_items = []\n            for pizza in pizzas:\n                menu_items.append({\n                    \"id\": pizza.id,\n                    \"name\": pizza.name,\n                    \"base_price\": str(pizza.base_price),\n                    \"preparation_time_minutes\": pizza.preparation_time_minutes,\n                    \"sizes\": [\"small\", \"medium\", \"large\"],\n                    \"available_toppings\": [\n                        \"pepperoni\", \"mushrooms\", \"bell_peppers\",\n                        \"onions\", \"sausage\", \"extra_cheese\"\n                    ]\n                })\n\n            return self.ok(menu_items)\n\n        except Exception as e:\n            return self.internal_server_error(f\"Failed to get menu: {str(e)}\")\n</code></pre>"},{"location":"getting-started/#step-3-file-based-repository","title":"\ud83d\udcbe Step 3: File-Based Repository","text":"<p>src/infrastructure/repositories/file_repository.py</p> <pre><code>import json\nimport os\nfrom pathlib import Path\nfrom typing import List, Optional, TypeVar, Generic\nfrom neuroglia.data.abstractions import Repository\n\nT = TypeVar('T')\nTKey = TypeVar('TKey')\n\nclass FileRepository(Repository[T, TKey], Generic[T, TKey]):\n    \"\"\"Simple file-based repository using JSON storage\"\"\"\n\n    def __init__(self, entity_type: type, data_dir: str = \"data\"):\n        self.entity_type = entity_type\n        self.data_dir = Path(data_dir)\n        self.entity_dir = self.data_dir / entity_type.__name__.lower()\n\n        # Ensure directory exists\n        self.entity_dir.mkdir(parents=True, exist_ok=True)\n\n    async def save_async(self, entity: T) -&gt; None:\n        \"\"\"Save entity to JSON file\"\"\"\n        file_path = self.entity_dir / f\"{entity.id}.json\"\n\n        # Convert entity to dict for JSON serialization\n        entity_dict = self._entity_to_dict(entity)\n\n        with open(file_path, 'w') as f:\n            json.dump(entity_dict, f, indent=2, default=str)\n\n    async def get_by_id_async(self, id: TKey) -&gt; Optional[T]:\n        \"\"\"Get entity by ID from JSON file\"\"\"\n        file_path = self.entity_dir / f\"{id}.json\"\n\n        if not file_path.exists():\n            return None\n\n        with open(file_path, 'r') as f:\n            entity_dict = json.load(f)\n\n        return self._dict_to_entity(entity_dict)\n\n    async def get_all_async(self) -&gt; List[T]:\n        \"\"\"Get all entities from JSON files\"\"\"\n        entities = []\n\n        for file_path in self.entity_dir.glob(\"*.json\"):\n            with open(file_path, 'r') as f:\n                entity_dict = json.load(f)\n                entities.append(self._dict_to_entity(entity_dict))\n\n        return entities\n\n    async def delete_async(self, id: TKey) -&gt; None:\n        \"\"\"Delete entity JSON file\"\"\"\n        file_path = self.entity_dir / f\"{id}.json\"\n        if file_path.exists():\n            file_path.unlink()\n\n    def _entity_to_dict(self, entity: T) -&gt; dict:\n        \"\"\"Convert entity to dictionary for JSON serialization\"\"\"\n        if hasattr(entity, '__dict__'):\n            return entity.__dict__\n        return entity._asdict() if hasattr(entity, '_asdict') else dict(entity)\n\n    def _dict_to_entity(self, data: dict) -&gt; T:\n        \"\"\"Convert dictionary back to entity\"\"\"\n        return self.entity_type(**data)\n</code></pre>"},{"location":"getting-started/#step-4-rest-api-controllers","title":"\ud83c\udf10 Step 4: REST API Controllers","text":"<p>src/api/controllers/orders_controller.py</p> <pre><code>from typing import List\nfrom fastapi import status, Depends\nfrom classy_fastapi.decorators import get, post, put\nfrom neuroglia.mvc import ControllerBase\nfrom neuroglia.dependency_injection import ServiceProviderBase\nfrom neuroglia.mediation import Mediator\nfrom neuroglia.mapping import Mapper\n\nfrom src.application.commands.place_order import PlaceOrderCommand, PizzaOrderItem\nfrom src.application.queries.get_menu import GetMenuQuery\nfrom src.infrastructure.auth import get_current_user\n\nclass OrdersController(ControllerBase):\n    \"\"\"Pizza orders API controller\"\"\"\n\n    def __init__(self, service_provider: ServiceProviderBase, mapper: Mapper, mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n    @post(\"/\", response_model=dict, status_code=status.HTTP_201_CREATED)\n    async def place_order(self, request: dict) -&gt; dict:\n        \"\"\"Place a new pizza order\"\"\"\n        command = PlaceOrderCommand(\n            customer_name=request[\"customer_name\"],\n            customer_phone=request[\"customer_phone\"],\n            pizza_items=[\n                PizzaOrderItem(**item) for item in request[\"pizza_items\"]\n            ]\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @get(\"/{order_id}\", response_model=dict)\n    async def get_order(self, order_id: str) -&gt; dict:\n        \"\"\"Get order details by ID\"\"\"\n        # This would use a GetOrderQuery - simplified for brevity\n        return {\"order_id\": order_id, \"status\": \"pending\"}\n\n    @put(\"/{order_id}/cook\", response_model=dict)\n    async def start_cooking(self, order_id: str, current_user = Depends(get_current_user)) -&gt; dict:\n        \"\"\"Start cooking an order (kitchen staff only)\"\"\"\n        # This would use a StartCookingCommand - simplified for brevity\n        return {\"order_id\": order_id, \"status\": \"cooking\"}\n\nclass MenuController(ControllerBase):\n    \"\"\"Pizza menu API controller\"\"\"\n\n    def __init__(self, service_provider: ServiceProviderBase, mapper: Mapper, mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n    @get(\"/\", response_model=List[dict])\n    async def get_menu(self) -&gt; List[dict]:\n        \"\"\"Get the pizzeria menu\"\"\"\n        query = GetMenuQuery()\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"getting-started/#step-5-oauth-authentication","title":"\ud83d\udd10 Step 5: OAuth Authentication","text":"<p>src/infrastructure/auth.py</p> <pre><code>from typing import Optional\nfrom fastapi import HTTPException, Depends, status\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom neuroglia.core import OperationResult\n\n# Simple OAuth configuration\nOAUTH_SCOPES = {\n    \"orders:read\": \"Read order information\",\n    \"orders:write\": \"Create and modify orders\",\n    \"kitchen:manage\": \"Manage kitchen operations\",\n    \"admin\": \"Full administrative access\"\n}\n\n# Simple token validation (in production, use proper OAuth provider)\nVALID_TOKENS = {\n    \"customer_token\": {\"user\": \"customer\", \"scopes\": [\"orders:read\", \"orders:write\"]},\n    \"staff_token\": {\"user\": \"kitchen_staff\", \"scopes\": [\"orders:read\", \"kitchen:manage\"]},\n    \"admin_token\": {\"user\": \"admin\", \"scopes\": [\"admin\"]}\n}\n\nsecurity = HTTPBearer()\n\nasync def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)) -&gt; dict:\n    \"\"\"Validate token and return user info\"\"\"\n    token = credentials.credentials\n\n    if token not in VALID_TOKENS:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid authentication token\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n    return VALID_TOKENS[token]\n\ndef require_scope(required_scope: str):\n    \"\"\"Decorator to require specific OAuth scope\"\"\"\n    def check_scope(current_user: dict = Depends(get_current_user)):\n        user_scopes = current_user.get(\"scopes\", [])\n        if required_scope not in user_scopes and \"admin\" not in user_scopes:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=f\"Insufficient permissions. Required scope: {required_scope}\"\n            )\n        return current_user\n    return check_scope\n</code></pre>"},{"location":"getting-started/#step-6-simple-web-ui","title":"\ud83c\udfa8 Step 6: Simple Web UI","text":"<p>src/web/static/index.html</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Mario's Pizzeria&lt;/title&gt;\n    &lt;style&gt;\n        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }\n        .pizza-card { border: 1px solid #ddd; border-radius: 8px; padding: 15px; margin: 10px 0; }\n        .order-form { background: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0; }\n        button { background: #e74c3c; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; }\n        button:hover { background: #c0392b; }\n        input, select { padding: 8px; margin: 5px; border: 1px solid #ddd; border-radius: 4px; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;\ud83c\udf55 Welcome to Mario's Pizzeria&lt;/h1&gt;\n\n    &lt;div id=\"menu-section\"&gt;\n        &lt;h2&gt;Our Menu&lt;/h2&gt;\n        &lt;div id=\"menu-items\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;div class=\"order-form\"&gt;\n        &lt;h2&gt;Place Your Order&lt;/h2&gt;\n        &lt;form id=\"order-form\"&gt;\n            &lt;div&gt;\n                &lt;input type=\"text\" id=\"customer-name\" placeholder=\"Your Name\" required&gt;\n                &lt;input type=\"tel\" id=\"customer-phone\" placeholder=\"Phone Number\" required&gt;\n            &lt;/div&gt;\n            &lt;div id=\"pizza-selection\"&gt;&lt;/div&gt;\n            &lt;button type=\"submit\"&gt;Place Order&lt;/button&gt;\n        &lt;/form&gt;\n    &lt;/div&gt;\n\n    &lt;div id=\"order-status\" style=\"display: none;\"&gt;\n        &lt;h2&gt;Order Status&lt;/h2&gt;\n        &lt;div id=\"status-details\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n        // Load menu on page load\n        document.addEventListener('DOMContentLoaded', loadMenu);\n\n        async function loadMenu() {\n            try {\n                const response = await fetch('/api/menu');\n                const menu = await response.json();\n                displayMenu(menu);\n            } catch (error) {\n                console.error('Failed to load menu:', error);\n            }\n        }\n\n        function displayMenu(menu) {\n            const menuContainer = document.getElementById('menu-items');\n            menuContainer.innerHTML = menu.map(pizza =&gt; `\n                &lt;div class=\"pizza-card\"&gt;\n                    &lt;h3&gt;${pizza.name}&lt;/h3&gt;\n                    &lt;p&gt;Base Price: $${pizza.base_price}&lt;/p&gt;\n                    &lt;p&gt;Prep Time: ${pizza.preparation_time_minutes} minutes&lt;/p&gt;\n                    &lt;button onclick=\"addToOrder('${pizza.id}', '${pizza.name}')\"&gt;Add to Order&lt;/button&gt;\n                &lt;/div&gt;\n            `).join('');\n        }\n\n        function addToOrder(pizzaId, pizzaName) {\n            const selection = document.getElementById('pizza-selection');\n            selection.innerHTML += `\n                &lt;div class=\"pizza-selection\"&gt;\n                    &lt;span&gt;${pizzaName}&lt;/span&gt;\n                    &lt;select name=\"size\"&gt;\n                        &lt;option value=\"small\"&gt;Small&lt;/option&gt;\n                        &lt;option value=\"medium\"&gt;Medium&lt;/option&gt;\n                        &lt;option value=\"large\"&gt;Large&lt;/option&gt;\n                    &lt;/select&gt;\n                    &lt;select name=\"toppings\" multiple&gt;\n                        &lt;option value=\"pepperoni\"&gt;Pepperoni&lt;/option&gt;\n                        &lt;option value=\"mushrooms\"&gt;Mushrooms&lt;/option&gt;\n                        &lt;option value=\"bell_peppers\"&gt;Bell Peppers&lt;/option&gt;\n                    &lt;/select&gt;\n                    &lt;input type=\"hidden\" name=\"pizza_id\" value=\"${pizzaId}\"&gt;\n                &lt;/div&gt;\n            `;\n        }\n\n        document.getElementById('order-form').addEventListener('submit', async (e) =&gt; {\n            e.preventDefault();\n\n            const formData = new FormData(e.target);\n            const order = {\n                customer_name: formData.get('customer-name'),\n                customer_phone: formData.get('customer-phone'),\n                pizza_items: Array.from(document.querySelectorAll('.pizza-selection')).map(item =&gt; ({\n                    pizza_id: item.querySelector('[name=\"pizza_id\"]').value,\n                    size: item.querySelector('[name=\"size\"]').value,\n                    toppings: Array.from(item.querySelectorAll('[name=\"toppings\"] option:checked')).map(opt =&gt; opt.value)\n                }))\n            };\n\n            try {\n                const response = await fetch('/api/orders', {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify(order)\n                });\n\n                const result = await response.json();\n                showOrderStatus(result);\n            } catch (error) {\n                alert('Failed to place order: ' + error.message);\n            }\n        });\n\n        function showOrderStatus(order) {\n            document.getElementById('order-status').style.display = 'block';\n            document.getElementById('status-details').innerHTML = `\n                &lt;p&gt;&lt;strong&gt;Order ID:&lt;/strong&gt; ${order.order_id}&lt;/p&gt;\n                &lt;p&gt;&lt;strong&gt;Total:&lt;/strong&gt; $${order.total_amount}&lt;/p&gt;\n                &lt;p&gt;&lt;strong&gt;Estimated Ready Time:&lt;/strong&gt; ${new Date(order.estimated_ready_time).toLocaleTimeString()}&lt;/p&gt;\n            `;\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"getting-started/#step-7-application-setup","title":"\ud83d\ude80 Step 7: Application Setup","text":"<p>src/main.py</p> <pre><code>import logging\nfrom pathlib import Path\nfrom neuroglia.hosting import EnhancedWebApplicationBuilder\nfrom neuroglia.mediation import Mediator\nfrom neuroglia.mapping import Mapper\n\nfrom src.domain.pizza import Pizza\nfrom src.domain.order import Order\nfrom src.infrastructure.repositories.file_repository import FileRepository\nfrom src.application.commands.place_order import PlaceOrderHandler\nfrom src.application.queries.get_menu import GetMenuHandler\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlog = logging.getLogger(__name__)\n\ndef create_app():\n    \"\"\"Create and configure Mario's Pizzeria application\"\"\"\n\n    # Create enhanced web application builder\n    builder = EnhancedWebApplicationBuilder()\n\n    # Register repositories\n    builder.services.add_singleton(lambda: FileRepository(Pizza, \"data\"))\n    builder.services.add_singleton(lambda: FileRepository(Order, \"data\"))\n\n    # Register command/query handlers\n    builder.services.add_scoped(PlaceOrderHandler)\n    builder.services.add_scoped(GetMenuHandler)\n\n    # Configure mediation\n    Mediator.configure(builder, [\"src.application\"])\n\n    # Configure object mapping\n    Mapper.configure(builder, [\"src\"])\n\n    # Add controllers with API prefix\n    builder.add_controllers_with_prefix(\"src.api.controllers\", \"/api\")\n\n    # Build the application\n    app = builder.build()\n\n    # Add static file serving for the web UI\n    from fastapi.staticfiles import StaticFiles\n    app.mount(\"/\", StaticFiles(directory=\"src/web/static\", html=True), name=\"static\")\n\n    # Add middleware for CORS (if needed)\n    from fastapi.middleware.cors import CORSMiddleware\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n\n    return app\n\nasync def setup_sample_data():\n    \"\"\"Create sample pizza menu\"\"\"\n    pizza_repo = FileRepository(Pizza, \"data\")\n\n    # Check if data already exists\n    existing_pizzas = await pizza_repo.get_all_async()\n    if existing_pizzas:\n        return\n\n    # Create sample pizzas\n    sample_pizzas = [\n        Pizza(\"margherita\", \"Margherita\", \"medium\", Decimal(\"12.99\"), [], 15),\n        Pizza(\"pepperoni\", \"Pepperoni\", \"medium\", Decimal(\"15.99\"), [\"pepperoni\"], 18),\n        Pizza(\"supreme\", \"Supreme\", \"medium\", Decimal(\"18.99\"), [\"pepperoni\", \"mushrooms\", \"bell_peppers\"], 22)\n    ]\n\n    for pizza in sample_pizzas:\n        await pizza_repo.save_async(pizza)\n\n    log.info(\"Sample pizza menu created\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    import uvicorn\n\n    # Setup sample data\n    asyncio.run(setup_sample_data())\n\n    # Create and run the application\n    app = create_app()\n\n    log.info(\"\ud83c\udf55 Starting Mario's Pizzeria...\")\n    log.info(\"\ud83c\udf10 Web UI: http://localhost:8000\")\n    log.info(\"\ud83d\udcda API Docs: http://localhost:8000/docs\")\n\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre>"},{"location":"getting-started/#youre-done","title":"\ud83c\udf89 You're Done!","text":"<p>Run your pizzeria:</p> <pre><code>cd marios-pizzeria\npython src/main.py\n</code></pre> <p>Visit your application:</p> <ul> <li>Web UI: http://localhost:8000</li> <li>API Documentation: http://localhost:8000/docs</li> <li>API Endpoints: http://localhost:8000/api</li> </ul>"},{"location":"getting-started/#what-youve-built","title":"\ud83d\udd0d What You've Built","text":"<p>\u2705 Complete Web Application with UI and API \u2705 Clean Architecture with domain, application, and infrastructure layers \u2705 CQRS Pattern with commands and queries \u2705 Event-Driven Design with domain events \u2705 File-Based Persistence using the repository pattern \u2705 OAuth Authentication for secure endpoints \u2705 Enhanced Web Application Builder with multi-app support \u2705 Automatic API Documentation with Swagger UI</p>"},{"location":"getting-started/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<p>Explore advanced features:</p> <ul> <li>CQRS &amp; Mediation - Advanced command/query patterns</li> <li>Resilient Handler Discovery - Robust handler registration</li> <li>Event Sourcing - Complete event-driven architecture  </li> <li>Dependency Injection - Advanced DI patterns</li> <li>Data Access - MongoDB and other persistence options</li> </ul> <p>All documentation uses this same pizzeria example for consistency! \ud83c\udf55</p>"},{"location":"test-mermaid/","title":"Mermaid Test Page","text":"<p>This page tests Mermaid diagram rendering in MkDocs.</p>"},{"location":"test-mermaid/#basic-flowchart","title":"Basic Flowchart","text":"<pre><code>graph TD\n    A[Start] --&gt; B{Is it working?}\n    B --&gt;|Yes| C[Great!]\n    B --&gt;|No| D[Debug]\n    D --&gt; A\n    C --&gt; E[End]</code></pre>"},{"location":"test-mermaid/#sequence-diagram","title":"Sequence Diagram","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Controller\n    participant Service\n    participant Database\n\n    User-&gt;&gt;Controller: HTTP Request\n    Controller-&gt;&gt;Service: Business Logic\n    Service-&gt;&gt;Database: Query Data\n    Database--&gt;&gt;Service: Result\n    Service--&gt;&gt;Controller: Response\n    Controller--&gt;&gt;User: HTTP Response</code></pre>"},{"location":"test-mermaid/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>graph TB\n    subgraph \"Application Layer\"\n        A[Controllers] --&gt; B[Mediator]\n        B --&gt; C[Command Handlers]\n        B --&gt; D[Query Handlers]\n    end\n\n    subgraph \"Domain Layer\"\n        E[Entities] --&gt; F[Value Objects]\n        E --&gt; G[Domain Events]\n    end\n\n    subgraph \"Integration Layer\"\n        H[Repositories] --&gt; I[External APIs]\n        H --&gt; J[Database]\n    end\n\n    C --&gt; E\n    D --&gt; H\n    A --&gt; B</code></pre>"},{"location":"test-mermaid/#class-diagram","title":"Class Diagram","text":"<pre><code>classDiagram\n    class Controller {\n        +service_provider: ServiceProvider\n        +mediator: Mediator\n        +mapper: Mapper\n        +process(result: OperationResult): Response\n    }\n\n    class CommandHandler {\n        +handle_async(command: Command): OperationResult\n    }\n\n    class QueryHandler {\n        +handle_async(query: Query): Result\n    }\n\n    Controller --&gt; CommandHandler : uses\n    Controller --&gt; QueryHandler : uses\n    CommandHandler --&gt; Entity : creates/modifies\n    QueryHandler --&gt; Repository : reads from</code></pre>"},{"location":"features/DOCUMENTATION_UPDATES/","title":"\ud83d\udcdd Documentation Updates Summary","text":""},{"location":"features/DOCUMENTATION_UPDATES/#new-roa-features-added-to-main-readmemd","title":"New ROA Features Added to Main README.md","text":""},{"location":"features/DOCUMENTATION_UPDATES/#key-features-section","title":"\ud83d\ude80 Key Features Section","text":"<ul> <li>Added Resource Oriented Architecture to the key features list</li> <li>Positioned ROA alongside other core features like CQRS, Event-Driven Architecture, etc.</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#documentation-links-section","title":"\ud83d\udcda Documentation Links Section","text":"<ul> <li>Added link to Resource Oriented Architecture documentation</li> <li>Positioned in logical order with other architectural features</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#sample-applications-section","title":"\ud83d\udccb Sample Applications Section","text":"<ul> <li>Added Lab Resource Manager sample with ROA demonstration</li> <li>Includes brief description highlighting key ROA patterns</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#framework-components-table","title":"\ud83c\udfd7\ufe0f Framework Components Table","text":"<ul> <li>Added Resource Oriented Architecture component entry</li> <li>Links to comprehensive ROA documentation</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#new-documentation-files-created","title":"New Documentation Files Created","text":""},{"location":"features/DOCUMENTATION_UPDATES/#1-docsfeaturesresource-oriented-architecturemd","title":"1. <code>docs/features/resource-oriented-architecture.md</code>","text":"<p>Comprehensive ROA feature documentation covering: - Overview of ROA concepts and benefits - Core components: Resources, Watchers, Controllers, Reconcilers - Key patterns: Declarative state, event-driven processing, state machines - Execution model: timing, coordination, concurrent processing - Safety and reliability: timeouts, error recovery, drift detection - Observability: metrics, logging, resource versioning - Configuration and scaling considerations - Use cases and related documentation links</p>"},{"location":"features/DOCUMENTATION_UPDATES/#2-docssampleslab-resource-managermd","title":"2. <code>docs/samples/lab-resource-manager.md</code>","text":"<p>Complete sample application documentation covering: - What developers will learn from the sample - Detailed architecture diagrams - Domain model with LabInstance resources - Component implementation details (Watcher, Controller, Reconciler) - Execution flow explanations - Running instructions with multiple demo options - Key implementation details and design patterns - Configuration options and testing guidance - Next steps for extending the sample</p>"},{"location":"features/DOCUMENTATION_UPDATES/#3-updates-to-docsindexmd","title":"3. Updates to <code>docs/index.md</code>","text":"<p>Enhanced main documentation index with: - ROA added to \"What Makes Neuroglia Special\" features list - New ROA section in Core Features with code examples - Lab Resource Manager added to Sample Applications section</p>"},{"location":"features/DOCUMENTATION_UPDATES/#4-updates-to-mkdocsyml","title":"4. Updates to <code>mkdocs.yml</code>","text":"<p>Enhanced navigation structure with: - Resource Oriented Architecture in Features section - Watcher &amp; Reconciliation Patterns documentation links - Watcher &amp; Reconciliation Execution documentation links - Lab Resource Manager in Sample Applications section</p>"},{"location":"features/DOCUMENTATION_UPDATES/#content-highlights","title":"Content Highlights","text":""},{"location":"features/DOCUMENTATION_UPDATES/#roa-documentation-features","title":"\ud83c\udfaf ROA Documentation Features","text":"<ul> <li>Practical Examples: Real code samples showing patterns in action</li> <li>Architecture Diagrams: Visual representation of component relationships</li> <li>Execution Models: Detailed timing and coordination explanations</li> <li>Safety Mechanisms: Comprehensive error handling and recovery patterns</li> <li>Configuration Guidance: Production-ready tuning recommendations</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#lab-resource-manager-sample-features","title":"\ud83e\uddea Lab Resource Manager Sample Features","text":"<ul> <li>Complete Implementation: Working demonstration with multiple complexity levels</li> <li>Real-time Execution: Live demonstration showing patterns in action</li> <li>Educational Focus: Clear explanations of why and how patterns work</li> <li>Multiple Demo Options: From simple pattern demos to full framework integration</li> <li>Comprehensive Testing: Unit and integration test examples</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#documentation-quality-standards","title":"Documentation Quality Standards","text":""},{"location":"features/DOCUMENTATION_UPDATES/#standards-applied","title":"\u2705 Standards Applied","text":"<ul> <li>Consistent Formatting: Following existing documentation style and emoji usage</li> <li>Cross-References: Proper linking between related documentation sections</li> <li>Code Examples: Working, realistic code samples throughout</li> <li>Progressive Complexity: Simple to advanced examples</li> <li>Practical Focus: Real-world use cases and implementation guidance</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#link-structure","title":"\ud83d\udd17 Link Structure","text":"<ul> <li>Bidirectional Links: Documents reference each other appropriately</li> <li>Logical Navigation: Features \u2192 Samples \u2192 Getting Started flow</li> <li>MkDocs Integration: Proper navigation structure for documentation site</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#impact-on-framework","title":"Impact on Framework","text":""},{"location":"features/DOCUMENTATION_UPDATES/#enhanced-capabilities","title":"\ud83d\udcc8 Enhanced Capabilities","text":"<ul> <li>New Architectural Pattern: ROA adds powerful resource management capabilities</li> <li>Complete Pattern Implementation: Watchers, controllers, and reconcilers working together</li> <li>Real-world Examples: Practical demonstration of complex distributed system patterns</li> <li>Educational Value: Developers can learn advanced patterns through working examples</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#framework-positioning","title":"\ud83c\udfaf Framework Positioning","text":"<ul> <li>Kubernetes-like Patterns: Brings declarative resource management to Python applications</li> <li>Production-Ready: Comprehensive error handling, monitoring, and configuration options</li> <li>Framework Integration: ROA patterns work seamlessly with existing CQRS and DI features</li> </ul> <p>The documentation updates provide comprehensive coverage of the new ROA features while maintaining consistency with existing documentation standards and navigation patterns.</p>"},{"location":"features/cqrs-mediation/","title":"\ufffd CQRS &amp; Mediation","text":"<p>Neuroglia implements Command Query Responsibility Segregation (CQRS) through a powerful mediation pattern that decouples your application logic and promotes clean separation between commands (writes) and queries (reads).</p> <p>Let's explore this using Mario's Pizzeria - where commands handle order placement and cooking, while queries retrieve menus and order status.</p>"},{"location":"features/cqrs-mediation/#overview","title":"\ud83c\udfad Overview","text":"<p>The mediation system provides:</p> <ul> <li>Commands: Operations that modify state (place orders, start cooking)</li> <li>Queries: Operations that retrieve data (get menu, check order status)</li> <li>Events: Notifications of state changes (order placed, pizza ready)</li> <li>Handlers: Process commands, queries, and events</li> <li>Mediator: Routes requests to appropriate handlers</li> <li>Pipeline Behaviors: Cross-cutting concerns (validation, logging, caching)</li> </ul>"},{"location":"features/cqrs-mediation/#core-concepts","title":"\ud83c\udfd7\ufe0f Core Concepts","text":""},{"location":"features/cqrs-mediation/#commands","title":"Commands","text":"<p>Commands represent business intentions that change the pizzeria's state:</p> <pre><code>from dataclasses import dataclass\nfrom typing import List\nfrom decimal import Decimal\nfrom neuroglia.mediation.mediator import Command\nfrom neuroglia.core.operation_result import OperationResult\n\n@dataclass\nclass PizzaItem:\n    \"\"\"A pizza item in an order\"\"\"\n    pizza_id: str\n    size: str  # \"small\", \"medium\", \"large\"\n    toppings: List[str]\n    special_instructions: str = \"\"\n\n@dataclass\nclass PlaceOrderCommand(Command[OperationResult]):\n    \"\"\"Command to place a new pizza order\"\"\"\n    customer_name: str\n    customer_phone: str\n    customer_address: str\n    pizza_items: List[PizzaItem]\n    payment_method: str = \"cash\"\n\n@dataclass\nclass StartCookingCommand(Command[OperationResult]):\n    \"\"\"Command to start cooking an order\"\"\"\n    order_id: str\n    kitchen_staff_id: str\n    estimated_cooking_time_minutes: int\n\n@dataclass\nclass MarkPizzaReadyCommand(Command[OperationResult]):\n    \"\"\"Command to mark a pizza as ready\"\"\"\n    order_id: str\n    pizza_index: int  # Which pizza in the order\n    actual_cooking_time_minutes: int\n\n@dataclass\nclass ProcessPaymentCommand(Command[OperationResult]):\n    \"\"\"Command to process payment for an order\"\"\"\n    order_id: str\n    payment_amount: Decimal\n    payment_method: str\n</code></pre>"},{"location":"features/cqrs-mediation/#queries","title":"Queries","text":"<p>Queries retrieve pizzeria data without side effects:</p> <pre><code>from dataclasses import dataclass\nfrom typing import List, Optional\nfrom decimal import Decimal\nfrom neuroglia.mediation.mediator import Query\n\n@dataclass\nclass GetMenuQuery(Query[OperationResult[List[dict]]]):\n    \"\"\"Query to get the pizzeria menu with pricing\"\"\"\n    category: Optional[str] = None  # \"pizza\", \"appetizers\", \"drinks\"\n    include_seasonal: bool = True\n\n@dataclass\nclass GetOrderStatusQuery(Query[OperationResult]):\n    \"\"\"Query to get current order status\"\"\"\n    order_id: str\n\n@dataclass\nclass GetOrdersByCustomerQuery(Query[OperationResult[List[dict]]]):\n    \"\"\"Query to get customer's order history\"\"\"\n    customer_phone: str\n    limit: int = 10\n\n@dataclass\nclass GetKitchenQueueQuery(Query[OperationResult[List[dict]]]):\n    \"\"\"Query to get current kitchen queue for staff\"\"\"\n    status: str = \"cooking\"  # \"pending\", \"cooking\", \"ready\"\n\n@dataclass\nclass GetDailySalesQuery(Query[OperationResult]):\n    \"\"\"Query to get daily sales report\"\"\"\n    date: str  # ISO date format\n    include_details: bool = False\n</code></pre>"},{"location":"features/cqrs-mediation/#events","title":"Events","text":"<p>Events represent important business occurrences in the pizzeria:</p> <pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom neuroglia.data.abstractions import DomainEvent\n\n```python\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom neuroglia.data.abstractions import DomainEvent\n\n@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    \"\"\"Event raised when a customer places an order\"\"\"\n    order_id: str\n    customer_name: str\n    customer_phone: str\n    total_amount: Decimal\n    estimated_ready_time: datetime\n\n@dataclass\nclass CookingStartedEvent(DomainEvent):\n    \"\"\"Event raised when kitchen starts cooking an order\"\"\"\n    order_id: str\n    kitchen_staff_id: str\n    started_at: datetime\n    estimated_completion: datetime\n\n@dataclass\nclass PizzaReadyEvent(DomainEvent):\n    \"\"\"Event raised when a pizza is ready\"\"\"\n    order_id: str\n    pizza_index: int\n    completed_at: datetime\n    actual_cooking_time_minutes: int\n\n@dataclass\nclass OrderCompletedEvent(DomainEvent):\n    \"\"\"Event raised when entire order is ready for pickup/delivery\"\"\"\n    order_id: str\n    completed_at: datetime\n    total_cooking_time_minutes: int\n</code></pre>"},{"location":"features/cqrs-mediation/#handlers","title":"\ud83c\udfaa Handlers","text":""},{"location":"features/cqrs-mediation/#command-handlers","title":"Command Handlers","text":"<p>Command handlers process business operations and enforce business rules:</p> <pre><code>from neuroglia.mediation.mediator import CommandHandler\nfrom neuroglia.mapping.mapper import Mapper\nfrom neuroglia.data.abstractions import Repository\nfrom src.domain.order import Order\nfrom src.domain.pizza import Pizza\n\nclass PlaceOrderCommandHandler(CommandHandler[PlaceOrderCommand, OperationResult]):\n    \"\"\"Handles pizza order placement\"\"\"\n\n    def __init__(self, \n                 order_repository: Repository[Order, str],\n                 pizza_repository: Repository[Pizza, str],\n                 mapper: Mapper,\n                 payment_service: IPaymentService,\n                 notification_service: INotificationService):\n        self.order_repository = order_repository\n        self.pizza_repository = pizza_repository\n        self.mapper = mapper\n        self.payment_service = payment_service\n        self.notification_service = notification_service\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult:\n        try:\n            # Validate pizza availability\n            pizza_ids = [item.pizza_id for item in command.pizza_items]\n            available_pizzas = await self.pizza_repository.get_by_ids_async(pizza_ids)\n\n            if len(available_pizzas) != len(pizza_ids):\n                return self.bad_request(\"One or more pizzas are not available\")\n\n            # Calculate total amount\n            total_amount = Decimal(\"0\")\n            order_pizzas = []\n\n            for item in command.pizza_items:\n                base_pizza = next(p for p in available_pizzas if p.id == item.pizza_id)\n\n                # Create customized pizza\n                customized_pizza = Pizza(\n                    id=\"\",  # Will be generated\n                    name=base_pizza.name,\n                    size=item.size,\n                    base_price=self._get_size_price(base_pizza.base_price, item.size),\n                    toppings=item.toppings,\n                    special_instructions=item.special_instructions\n                )\n\n                order_pizzas.append(customized_pizza)\n                total_amount += customized_pizza.total_price\n\n            # Create order domain entity\n            order = Order.create(\n                customer_name=command.customer_name,\n                customer_phone=command.customer_phone,\n                customer_address=command.customer_address,\n                pizzas=order_pizzas,\n                payment_method=command.payment_method\n            )\n\n            # Save order\n            await self.order_repository.save_async(order)\n\n            # Send confirmation\n            await self.notification_service.send_order_confirmation(\n                order.customer_phone,\n                order.id,\n                order.estimated_ready_time\n            )\n\n            return self.created({\n                \"order_id\": order.id,\n                \"total_amount\": str(total_amount),\n                \"estimated_ready_time\": order.estimated_ready_time.isoformat()\n            })\n\n        except Exception as e:\n            return self.internal_server_error(f\"Failed to place order: {str(e)}\")\n\n    def _get_size_price(self, base_price: Decimal, size: str) -&gt; Decimal:\n        multipliers = {\"small\": Decimal(\"0.8\"), \"medium\": Decimal(\"1.0\"), \"large\": Decimal(\"1.3\")}\n        return base_price * multipliers.get(size, Decimal(\"1.0\"))\n\nclass StartCookingCommandHandler(CommandHandler[StartCookingCommand, OperationResult]):\n    \"\"\"Handles starting to cook an order\"\"\"\n\n    def __init__(self, \n                 order_repository: Repository[Order, str],\n                 kitchen_service: IKitchenService):\n        self.order_repository = order_repository\n        self.kitchen_service = kitchen_service\n\n    async def handle_async(self, command: StartCookingCommand) -&gt; OperationResult:\n        # Get the order\n        order = await self.order_repository.get_by_id_async(command.order_id)\n        if not order:\n            return self.not_found(\"Order not found\")\n\n        # Validate business rules\n        if order.status != \"pending\":\n            return self.bad_request(f\"Cannot start cooking order in {order.status} status\")\n\n        # Start cooking\n        order.start_cooking(\n            kitchen_staff_id=command.kitchen_staff_id,\n            estimated_cooking_time=command.estimated_cooking_time_minutes\n        )\n\n        # Save updated order\n        await self.order_repository.save_async(order)\n\n        # Update kitchen queue\n        await self.kitchen_service.add_to_cooking_queue(order)\n\n        return self.ok({\"message\": f\"Started cooking order {order.id}\"})\n</code></pre> <pre><code>from neuroglia.mediation.mediator import QueryHandler\n\nclass GetMenuQueryHandler(QueryHandler[GetMenuQuery, OperationResult[List[dict]]]):\n    \"\"\"Handles menu retrieval queries\"\"\"\n\n    def __init__(self, \n                 pizza_repository: Repository[Pizza, str],\n                 cache_service: ICacheService):\n        self.pizza_repository = pizza_repository\n        self.cache_service = cache_service\n\n    async def handle_async(self, query: GetMenuQuery) -&gt; OperationResult[List[dict]]:\n        # Check cache first for performance\n        cache_key = f\"menu:{query.category}:{query.include_seasonal}\"\n        cached_menu = await self.cache_service.get_async(cache_key)\n\n        if cached_menu:\n            return self.ok(cached_menu)\n\n        # Get all pizzas\n        pizzas = await self.pizza_repository.get_all_async()\n\n        # Filter by category if specified\n        if query.category:\n            pizzas = [p for p in pizzas if p.category == query.category]\n\n        # Filter seasonal items if not requested\n        if not query.include_seasonal:\n            pizzas = [p for p in pizzas if not p.is_seasonal]\n\n        # Build menu response\n        menu_items = []\n        for pizza in pizzas:\n            menu_items.append({\n                \"id\": pizza.id,\n                \"name\": pizza.name,\n                \"description\": pizza.description,\n                \"base_price\": str(pizza.base_price),\n                \"category\": pizza.category,\n                \"preparation_time_minutes\": pizza.preparation_time_minutes,\n                \"available_sizes\": [\"small\", \"medium\", \"large\"],\n                \"available_toppings\": pizza.available_toppings,\n                \"is_seasonal\": pizza.is_seasonal\n            })\n\n        # Cache for 15 minutes\n        await self.cache_service.set_async(cache_key, menu_items, expire_minutes=15)\n\n        return self.ok(menu_items)\n\nclass GetOrderStatusQueryHandler(QueryHandler[GetOrderStatusQuery, OperationResult]):\n    \"\"\"Handles order status queries\"\"\"\n\n    def __init__(self, order_repository: Repository[Order, str]):\n        self.order_repository = order_repository\n\n    async def handle_async(self, query: GetOrderStatusQuery) -&gt; OperationResult:\n        order = await self.order_repository.get_by_id_async(query.order_id)\n\n        if not order:\n            return self.not_found(f\"Order {query.order_id} not found\")\n\n        return self.ok({\n            \"order_id\": order.id,\n            \"status\": order.status,\n            \"customer_name\": order.customer_name,\n            \"order_time\": order.order_time.isoformat(),\n            \"estimated_ready_time\": order.estimated_ready_time.isoformat() if order.estimated_ready_time else None,\n            \"total_amount\": str(order.total_amount),\n            \"pizzas\": [\n                {\n                    \"name\": pizza.name,\n                    \"size\": pizza.size,\n                    \"toppings\": pizza.toppings,\n                    \"status\": \"cooking\" if order.status == \"cooking\" else \"pending\"\n                }\n                for pizza in order.pizzas\n            ]\n        })\n\nclass GetKitchenQueueQueryHandler(QueryHandler[GetKitchenQueueQuery, OperationResult[List[dict]]]):\n    \"\"\"Handles kitchen queue queries for staff\"\"\"\n\n    def __init__(self, order_repository: Repository[Order, str]):\n        self.order_repository = order_repository\n\n    async def handle_async(self, query: GetKitchenQueueQuery) -&gt; OperationResult[List[dict]]:\n        # Get orders by status\n        orders = await self.order_repository.get_by_status_async(query.status)\n\n        # Sort by order time (FIFO)\n        orders.sort(key=lambda o: o.order_time)\n\n        queue_items = []\n        for order in orders:\n            queue_items.append({\n                \"order_id\": order.id,\n                \"customer_name\": order.customer_name,\n                \"order_time\": order.order_time.isoformat(),\n                \"estimated_ready_time\": order.estimated_ready_time.isoformat() if order.estimated_ready_time else None,\n                \"pizza_count\": len(order.pizzas),\n                \"total_prep_time\": sum(p.preparation_time_minutes for p in order.pizzas),\n                \"special_instructions\": [p.special_instructions for p in order.pizzas if p.special_instructions]\n            })\n\n        return self.ok(queue_items)\n</code></pre> <pre><code>from neuroglia.mediation.mediator import EventHandler\n\nclass OrderPlacedEventHandler(EventHandler[OrderPlacedEvent]):\n    \"\"\"Handles order placed events - sends notifications\"\"\"\n\n    def __init__(self, \n                 notification_service: INotificationService,\n                 analytics_service: IAnalyticsService):\n        self.notification_service = notification_service\n        self.analytics_service = analytics_service\n\n    async def handle_async(self, event: OrderPlacedEvent):\n        # Send SMS confirmation to customer\n        await self.notification_service.send_sms(\n            phone=event.customer_phone,\n            message=f\"Order {event.order_id[:8]} confirmed! \"\n                   f\"Total: ${event.total_amount}. \"\n                   f\"Ready by: {event.estimated_ready_time.strftime('%H:%M')}\"\n        )\n\n        # Notify kitchen staff\n        await self.notification_service.notify_kitchen_staff(\n            f\"New order {event.order_id[:8]} from {event.customer_name}\"\n        )\n\n        # Track order analytics\n        await self.analytics_service.track_order_placed(\n            order_id=event.order_id,\n            amount=event.total_amount,\n            customer_type=\"returning\" if await self._is_returning_customer(event.customer_phone) else \"new\"\n        )\n\nclass CookingStartedEventHandler(EventHandler[CookingStartedEvent]):\n    \"\"\"Handles cooking started events - updates displays\"\"\"\n\n    def __init__(self, \n                 kitchen_display_service: IKitchenDisplayService,\n                 performance_service: IPerformanceService):\n        self.kitchen_display_service = kitchen_display_service\n        self.performance_service = performance_service\n\n    async def handle_async(self, event: CookingStartedEvent):\n        # Update kitchen display board\n        await self.kitchen_display_service.update_order_status(\n            order_id=event.order_id,\n            status=\"cooking\",\n            staff_id=event.kitchen_staff_id,\n            started_at=event.started_at\n        )\n\n        # Track kitchen performance metrics\n        await self.performance_service.track_cooking_start(\n            order_id=event.order_id,\n            staff_id=event.kitchen_staff_id,\n            estimated_completion=event.estimated_completion\n        )\n\nclass PizzaReadyEventHandler(EventHandler[PizzaReadyEvent]):\n    \"\"\"Handles pizza ready events - manages completion tracking\"\"\"\n\n    def __init__(self, \n                 order_service: IOrderService,\n                 performance_service: IPerformanceService):\n        self.order_service = order_service\n        self.performance_service = performance_service\n\n    async def handle_async(self, event: PizzaReadyEvent):\n        # Check if entire order is complete\n        order_complete = await self.order_service.check_if_order_complete(event.order_id)\n\n        if order_complete:\n            # Mark order as ready and notify customer\n            await self.order_service.mark_order_ready(event.order_id)\n\n        # Track pizza cooking performance\n        await self.performance_service.track_pizza_completion(\n            order_id=event.order_id,\n            pizza_index=event.pizza_index,\n            actual_time=event.actual_cooking_time_minutes,\n            completed_at=event.completed_at\n        )\n\nclass OrderCompletedEventHandler(EventHandler[OrderCompletedEvent]):\n    \"\"\"Handles order completion - final notifications\"\"\"\n\n    def __init__(self, \n                 notification_service: INotificationService,\n                 loyalty_service: ILoyaltyService):\n        self.notification_service = notification_service\n        self.loyalty_service = loyalty_service\n\n    async def handle_async(self, event: OrderCompletedEvent):\n        # Get order details for notification\n        order = await self.order_repository.get_by_id_async(event.order_id)\n\n        # Notify customer order is ready\n        await self.notification_service.send_sms(\n            phone=order.customer_phone,\n            message=f\"Your order {event.order_id[:8]} is ready for pickup! \ud83c\udf55\"\n        )\n\n        # Update loyalty points\n        await self.loyalty_service.award_points(\n            customer_phone=order.customer_phone,\n            order_amount=order.total_amount\n        )\n</code></pre>"},{"location":"features/cqrs-mediation/#mediator-usage-in-marios-pizzeria","title":"\ud83d\ude80 Mediator Usage in Mario's Pizzeria","text":""},{"location":"features/cqrs-mediation/#configuration","title":"Configuration","text":"<p>Configure the mediator in your pizzeria application startup:</p> <pre><code>from neuroglia.hosting.web import EnhancedWebApplicationBuilder\nfrom neuroglia.mediation.mediator import Mediator\n\ndef create_pizzeria_app():\n    builder = EnhancedWebApplicationBuilder()\n\n    # Configure mediator with pizzeria handler modules\n    Mediator.configure(builder, [\n        \"src.application.commands\",  # PlaceOrderCommandHandler, StartCookingCommandHandler\n        \"src.application.queries\",   # GetMenuQueryHandler, GetOrderStatusQueryHandler\n        \"src.application.events\"     # OrderPlacedEventHandler, CookingStartedEventHandler\n    ])\n\n    # Register repositories\n    builder.services.add_scoped(lambda: FileRepository(Order, \"data\"))\n    builder.services.add_scoped(lambda: FileRepository(Pizza, \"data\"))\n\n    return builder.build()\n</code></pre>"},{"location":"features/cqrs-mediation/#in-controllers","title":"In Controllers","text":"<p>Use the mediator in your pizzeria API controllers:</p> <pre><code>from neuroglia.mvc.controller_base import ControllerBase\nfrom classy_fastapi.decorators import get, post, put\n\nclass OrdersController(ControllerBase):\n    \"\"\"Pizza orders API controller\"\"\"\n\n    @post(\"/\", response_model=dict, status_code=201)\n    async def place_order(self, order_request: dict) -&gt; dict:\n        # Create command from request\n        command = PlaceOrderCommand(\n            customer_name=order_request[\"customer_name\"],\n            customer_phone=order_request[\"customer_phone\"],\n            customer_address=order_request[\"customer_address\"],\n            pizza_items=[PizzaItem(**item) for item in order_request[\"pizza_items\"]],\n            payment_method=order_request.get(\"payment_method\", \"cash\")\n        )\n\n        # Execute through mediator\n        result = await self.mediator.execute_async(command)\n\n        # Process result and return\n        return self.process(result)\n\n    @get(\"/{order_id}/status\", response_model=dict)\n    async def get_order_status(self, order_id: str) -&gt; dict:\n        # Create query\n        query = GetOrderStatusQuery(order_id=order_id)\n\n        # Execute through mediator\n        result = await self.mediator.execute_async(query)\n\n        # Process result and return\n        return self.process(result)\n\n    @put(\"/{order_id}/cook\", response_model=dict)\n    async def start_cooking(self, order_id: str, cooking_request: dict) -&gt; dict:\n        # Create command\n        command = StartCookingCommand(\n            order_id=order_id,\n            kitchen_staff_id=cooking_request[\"kitchen_staff_id\"],\n            estimated_cooking_time_minutes=cooking_request[\"estimated_cooking_time_minutes\"]\n        )\n\n        # Execute through mediator\n        result = await self.mediator.execute_async(command)\n\n        # Process result and return\n        return self.process(result)\n\nclass MenuController(ControllerBase):\n    \"\"\"Pizza menu API controller\"\"\"\n\n    @get(\"/\", response_model=List[dict])\n    async def get_menu(self, category: Optional[str] = None, include_seasonal: bool = True) -&gt; List[dict]:\n        # Create query\n        query = GetMenuQuery(\n            category=category,\n            include_seasonal=include_seasonal\n        )\n\n        # Execute through mediator  \n        result = await self.mediator.execute_async(query)\n\n        # Process result and return\n        return self.process(result)\n\n    @get(\"/\", response_model=List[UserDto])\n    async def search_users(self, \n                          search: str = \"\",\n                          page: int = 1,\n</code></pre>"},{"location":"features/cqrs-mediation/#in-services","title":"In Services","text":"<p>Use the mediator in pizzeria application services:</p> <pre><code>class PizzeriaService:\n    \"\"\"High-level pizzeria operations service\"\"\"\n\n    def __init__(self, mediator: Mediator):\n        self.mediator = mediator\n\n    async def process_online_order(self, order_data: OnlineOrderData) -&gt; dict:\n        \"\"\"Process a complete online order workflow\"\"\"\n\n        # 1. Place the order\n        place_command = PlaceOrderCommand(\n            customer_name=order_data.customer_name,\n            customer_phone=order_data.customer_phone,\n            customer_address=order_data.customer_address,\n            pizza_items=order_data.pizza_items,\n            payment_method=order_data.payment_method\n        )\n\n        place_result = await self.mediator.execute_async(place_command)\n\n        if not place_result.is_success:\n            raise OrderPlacementException(place_result.error_message)\n\n        # 2. Process payment if needed\n        if order_data.payment_method != \"cash\":\n            payment_command = ProcessPaymentCommand(\n                order_id=place_result.data[\"order_id\"],\n                payment_amount=Decimal(place_result.data[\"total_amount\"]),\n                payment_method=order_data.payment_method\n            )\n\n            payment_result = await self.mediator.execute_async(payment_command)\n\n            if not payment_result.is_success:\n                raise PaymentException(payment_result.error_message)\n\n        return place_result.data\n\n    async def get_customer_order_history(self, customer_phone: str) -&gt; List[dict]:\n        \"\"\"Get customer's order history\"\"\"\n        query = GetOrdersByCustomerQuery(\n            customer_phone=customer_phone,\n            limit=10\n        )\n\n        result = await self.mediator.execute_async(query)\n\n        if result.is_success:\n            return result.data\n        else:\n            raise OrderHistoryException(result.error_message)\n</code></pre>"},{"location":"features/cqrs-mediation/#advanced-patterns","title":"\ud83c\udfad Advanced Patterns","text":""},{"location":"features/cqrs-mediation/#pipeline-behaviors","title":"Pipeline Behaviors","text":"<p>Add cross-cutting concerns through pipeline behaviors:</p> <pre><code>from neuroglia.mediation.mediator import PipelineBehavior\nfrom neuroglia.core.operation_result import OperationResult\nfrom typing import Type, Any\nimport logging\nimport time\n\nclass OrderValidationBehavior(PipelineBehavior):\n    \"\"\"Validates pizza orders before processing\"\"\"\n\n    async def handle_async(self, request, next_handler):\n        # Only validate order commands\n        if isinstance(request, PlaceOrderCommand):\n            # Business rule: minimum order amount\n            if not request.pizza_items:\n                return OperationResult.validation_error(\"Order must contain at least one pizza\")\n\n            # Business rule: validate customer info\n            if not request.customer_phone or len(request.customer_phone) &lt; 10:\n                return OperationResult.validation_error(\"Valid phone number required\")\n\n        # Continue to next behavior/handler\n        return await next_handler()\n\nclass KitchenOperationsLoggingBehavior(PipelineBehavior):\n    \"\"\"Logs all kitchen operations for compliance\"\"\"\n\n    def __init__(self, logger: logging.Logger):\n        self.logger = logger\n\n    async def handle_async(self, request, next_handler):\n        request_name = type(request).__name__\n\n        # Log kitchen-related commands with extra detail\n        if isinstance(request, (StartCookingCommand, MarkPizzaReadyCommand)):\n            self.logger.info(f\"Kitchen: {request_name} - Order: {request.order_id}\")\n        else:\n            self.logger.info(f\"Processing {request_name}\")\n\n        start_time = time.time()\n\n        try:\n            result = await next_handler()\n            duration = time.time() - start_time\n\n            self.logger.info(f\"Completed {request_name} in {duration:.3f}s\")\n            return result\n        except Exception as ex:\n            self.logger.error(f\"Failed {request_name}: {ex}\")\n            raise\n\nclass PerformanceMonitoringBehavior(PipelineBehavior):\n    \"\"\"Monitors command/query performance\"\"\"\n\n    def __init__(self, performance_service: IPerformanceService):\n        self.performance_service = performance_service\n\n    async def handle_async(self, request, next_handler):\n        start_time = time.time()\n        request_type = type(request).__name__\n\n        try:\n            result = await next_handler()\n            duration = time.time() - start_time\n\n            # Track performance metrics\n            await self.performance_service.record_operation(\n                operation_type=request_type,\n                duration_seconds=duration,\n                success=True\n            )\n\n            return result\n        except Exception as ex:\n            duration = time.time() - start_time\n\n            await self.performance_service.record_operation(\n                operation_type=request_type,\n                duration_seconds=duration,\n                success=False,\n                error=str(ex)\n            )\n\n            raise\n\n# Register behaviors in application startup\ndef configure_pipeline_behaviors(builder: EnhancedWebApplicationBuilder):\n    \"\"\"Configure pipeline behaviors for pizzeria operations\"\"\"\n\n    builder.services.add_pipeline_behavior(OrderValidationBehavior)\n    builder.services.add_pipeline_behavior(KitchenOperationsLoggingBehavior)\n    builder.services.add_pipeline_behavior(PerformanceMonitoringBehavior)\n</code></pre>"},{"location":"features/cqrs-mediation/#caching-behavior","title":"Caching Behavior","text":"<p>Cache query results for better performance:</p> <pre><code>class QueryCachingBehavior(PipelineBehavior):\n    \"\"\"Caches query results based on query type and parameters\"\"\"\n\n    def __init__(self, cache_service: ICacheService):\n        self.cache_service = cache_service\n\n    async def handle_async(self, request, next_handler):\n        # Only cache queries, not commands\n        if not isinstance(request, Query):\n            return await next_handler()\n\n        # Generate cache key\n        cache_key = self._generate_cache_key(request)\n\n        # Try to get from cache first\n        cached_result = await self.cache_service.get_async(cache_key)\n        if cached_result:\n            return cached_result\n\n        # Execute query\n        result = await next_handler()\n\n        # Cache successful results\n        if result.is_success:\n            # Different TTL based on query type\n            ttl_minutes = self._get_cache_ttl(type(request))\n            await self.cache_service.set_async(cache_key, result, expire_minutes=ttl_minutes)\n\n        return result\n\n    def _generate_cache_key(self, request: Query) -&gt; str:\n        \"\"\"Generate cache key from request\"\"\"\n        request_type = type(request).__name__\n        request_data = str(request.__dict__)\n        return f\"query:{request_type}:{hash(request_data)}\"\n\n    def _get_cache_ttl(self, query_type: Type) -&gt; int:\n        \"\"\"Get cache TTL based on query type\"\"\"\n        cache_strategies = {\n            GetMenuQuery: 30,           # Menu changes infrequently\n            GetOrderStatusQuery: 1,     # Order status changes frequently\n            GetKitchenQueueQuery: 2,    # Kitchen queue changes regularly\n            GetDailySalesQuery: 60      # Sales data can be cached longer\n        }\n        return cache_strategies.get(query_type, 5)  # Default 5 minutes\n</code></pre>"},{"location":"features/cqrs-mediation/#transaction-behavior","title":"Transaction Behavior","text":"<p>Wrap commands in database transactions for consistency:</p> <pre><code>class TransactionBehavior(PipelineBehavior):\n    \"\"\"Wraps commands in database transactions\"\"\"\n\n    def __init__(self, unit_of_work: IUnitOfWork):\n        self.unit_of_work = unit_of_work\n\n    async def handle_async(self, request, next_handler):\n        # Only apply to commands\n        if not isinstance(request, Command):\n            return await next_handler()\n\n        async with self.unit_of_work.begin_transaction():\n            try:\n                result = await next_handler()\n                await self.unit_of_work.commit()\n                return result\n            except Exception:\n                await self.unit_of_work.rollback()\n                raise\n</code></pre>"},{"location":"features/cqrs-mediation/#caching-behavior_1","title":"Caching Behavior","text":"<p>Cache query results:</p> <pre><code>class CachingBehavior(PipelineBehavior):\n    \"\"\"Caches query results\"\"\"\n\n    def __init__(self, cache_service: ICacheService):\n        self.cache_service = cache_service\n\n    async def handle_async(self, request, next_handler):\n        # Only cache queries\n        if not isinstance(request, Query):\n            return await next_handler()\n\n        # Generate cache key\n        cache_key = f\"{type(request).__name__}:{hash(str(request))}\"\n\n        # Try to get from cache\n        cached_result = await self.cache_service.get_async(cache_key)\n        if cached_result:\n            return cached_result\n\n        # Execute query\n        result = await next_handler()\n\n        # Cache successful results\n        if result.is_success:\n            await self.cache_service.set_async(cache_key, result, expiry=timedelta(minutes=5))\n\n        return result\n</code></pre>"},{"location":"features/cqrs-mediation/#domain-events","title":"\ud83c\udfdb\ufe0f Domain Events","text":""},{"location":"features/cqrs-mediation/#publishing-events","title":"Publishing Events","text":"<p>Publish domain events from entities or handlers:</p> <pre><code>class User(AggregateRoot[str]):\n    def create(self, email: str, first_name: str, last_name: str):\n        # Apply business rules\n        self.email = email\n        self.first_name = first_name\n        self.last_name = last_name\n        self.created_at = datetime.utcnow()\n\n        # Raise domain event\n        self.raise_event(UserCreatedEvent(\n            user_id=self.id,\n            email=self.email,\n            created_at=self.created_at\n        ))\n\nclass CreateUserCommandHandler(CommandHandler[CreateUserCommand, OperationResult[UserDto]]):\n    async def handle_async(self, command: CreateUserCommand) -&gt; OperationResult[UserDto]:\n        # Create user (events are raised automatically)\n        user = User.create(command.email, command.first_name, command.last_name)\n\n        # Save user (this will publish the events)\n        await self.user_repository.add_async(user)\n\n        return self.created(self.mapper.map(user, UserDto))\n</code></pre>"},{"location":"features/cqrs-mediation/#event-dispatching","title":"Event Dispatching","text":"<p>Events are automatically dispatched to registered handlers:</p> <pre><code># Multiple handlers can listen to the same event\nclass UserCreatedEventHandler(EventHandler[UserCreatedEvent]):\n    async def handle_async(self, event: UserCreatedEvent):\n        # Handle audit logging\n        pass\n\nclass WelcomeEmailHandler(EventHandler[UserCreatedEvent]):\n    async def handle_async(self, event: UserCreatedEvent):\n        # Send welcome email\n        pass\n\nclass AnalyticsHandler(EventHandler[UserCreatedEvent]):\n    async def handle_async(self, event: UserCreatedEvent):\n        # Track user registration\n        pass\n</code></pre>"},{"location":"features/cqrs-mediation/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"features/cqrs-mediation/#testing-handlers","title":"Testing Handlers","text":"<p>Test handlers in isolation:</p> <pre><code>import pytest\nfrom unittest.mock import Mock\n\n@pytest.mark.asyncio\nasync def test_create_user_command_handler():\n    # Arrange\n    mock_repository = Mock()\n    mock_mapper = Mock()\n    mock_password_service = Mock()\n    mock_email_service = Mock()\n\n    handler = CreateUserCommandHandler(\n        mock_repository, \n        mock_mapper, \n        mock_password_service,\n        mock_email_service\n```python\nclass OrderTransactionBehavior(PipelineBehavior):\n    \"\"\"Wraps order commands in database transactions\"\"\"\n\n    def __init__(self, unit_of_work: IUnitOfWork):\n        self.unit_of_work = unit_of_work\n\n    async def handle_async(self, request, next_handler):\n        # Only apply transactions to commands that modify data\n        if not isinstance(request, (PlaceOrderCommand, StartCookingCommand, ProcessPaymentCommand)):\n            return await next_handler()\n\n        async with self.unit_of_work.begin_transaction():\n            try:\n                result = await next_handler()\n\n                if result.is_success:\n                    await self.unit_of_work.commit_async()\n                else:\n                    await self.unit_of_work.rollback_async()\n\n                return result\n            except Exception:\n                await self.unit_of_work.rollback_async()\n                raise\n</code></pre>"},{"location":"features/cqrs-mediation/#testing-cqrs-components","title":"\ud83e\uddea Testing CQRS Components","text":""},{"location":"features/cqrs-mediation/#testing-command-handlers","title":"Testing Command Handlers","text":"<pre><code>import pytest\nfrom unittest.mock import Mock, AsyncMock\nfrom src.application.commands.place_order import PlaceOrderCommandHandler, PlaceOrderCommand, PizzaItem\nfrom src.domain.order import Order\nfrom src.domain.pizza import Pizza\n\n@pytest.mark.asyncio\nasync def test_place_order_command_handler_success():\n    # Arrange\n    mock_order_repo = Mock()\n    mock_pizza_repo = Mock()\n    mock_mapper = Mock()\n    mock_payment_service = Mock()\n    mock_notification_service = Mock()\n\n    handler = PlaceOrderCommandHandler(\n        order_repository=mock_order_repo,\n        pizza_repository=mock_pizza_repo,\n        mapper=mock_mapper,\n        payment_service=mock_payment_service,\n        notification_service=mock_notification_service\n    )\n\n    # Mock pizza availability\n    margherita = Pizza(\"margherita\", \"Margherita\", \"medium\", Decimal(\"12.99\"), [], 15)\n    mock_pizza_repo.get_by_ids_async.return_value = [margherita]\n\n    command = PlaceOrderCommand(\n        customer_name=\"John Doe\",\n        customer_phone=\"555-0123\",\n        customer_address=\"123 Pizza St\",\n        pizza_items=[PizzaItem(pizza_id=\"margherita\", size=\"large\", toppings=[\"extra_cheese\"])],\n        payment_method=\"cash\"\n    )\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n    assert \"order_id\" in result.data\n    assert \"total_amount\" in result.data\n    mock_order_repo.save_async.assert_called_once()\n    mock_notification_service.send_order_confirmation.assert_called_once()\n\n@pytest.mark.asyncio\nasync def test_place_order_command_handler_pizza_not_available():\n    # Arrange\n    handler = PlaceOrderCommandHandler(Mock(), Mock(), Mock(), Mock(), Mock())\n    handler.pizza_repository.get_by_ids_async.return_value = []  # No pizzas available\n\n    command = PlaceOrderCommand(\n        customer_name=\"John Doe\",\n        customer_phone=\"555-0123\", \n        customer_address=\"123 Pizza St\",\n        pizza_items=[PizzaItem(pizza_id=\"nonexistent\", size=\"large\", toppings=[])],\n        payment_method=\"cash\"\n    )\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert not result.is_success\n    assert \"not available\" in result.error_message\n</code></pre>"},{"location":"features/cqrs-mediation/#testing-query-handlers","title":"Testing Query Handlers","text":"<pre><code>@pytest.mark.asyncio\nasync def test_get_menu_query_handler():\n    # Arrange\n    mock_pizza_repo = Mock()\n    mock_cache_service = Mock()\n\n    handler = GetMenuQueryHandler(\n        pizza_repository=mock_pizza_repo,\n        cache_service=mock_cache_service\n    )\n\n    # Mock cache miss\n    mock_cache_service.get_async.return_value = None\n\n    # Mock pizza data\n    pizzas = [\n        Pizza(\"margherita\", \"Margherita\", \"medium\", Decimal(\"12.99\"), [], 15),\n        Pizza(\"pepperoni\", \"Pepperoni\", \"medium\", Decimal(\"15.99\"), [\"pepperoni\"], 18)\n    ]\n    mock_pizza_repo.get_all_async.return_value = pizzas\n\n    query = GetMenuQuery(category=None, include_seasonal=True)\n\n    # Act\n    result = await handler.handle_async(query)\n\n    # Assert\n    assert result.is_success\n    assert len(result.data) == 2\n    assert result.data[0][\"name\"] == \"Margherita\"\n    mock_cache_service.set_async.assert_called_once()\n</code></pre>"},{"location":"features/cqrs-mediation/#integration-testing","title":"Integration Testing","text":"<p>Test the complete pizzeria workflow:</p> <pre><code>@pytest.mark.integration\n@pytest.mark.asyncio\nasync def test_complete_order_workflow():\n    \"\"\"Test the complete order placement and cooking workflow\"\"\"\n\n    # Arrange - use test client with real mediator\n    test_client = TestClient(create_pizzeria_app())\n\n    # Create order\n    order_data = {\n        \"customer_name\": \"John Doe\",\n        \"customer_phone\": \"555-0123\", \n        \"customer_address\": \"123 Pizza St\",\n        \"pizza_items\": [\n            {\n                \"pizza_id\": \"margherita\",\n                \"size\": \"large\", \n                \"toppings\": [\"extra_cheese\"],\n                \"special_instructions\": \"Extra crispy\"\n            }\n        ],\n        \"payment_method\": \"cash\"\n    }\n\n    # Act &amp; Assert - Place order\n    response = test_client.post(\"/api/orders\", json=order_data)\n    assert response.status_code == 201\n\n    order_result = response.json()\n    order_id = order_result[\"order_id\"]\n    assert \"total_amount\" in order_result\n    assert \"estimated_ready_time\" in order_result\n\n    # Act &amp; Assert - Check order status\n    status_response = test_client.get(f\"/api/orders/{order_id}/status\")\n    assert status_response.status_code == 200\n\n    status_data = status_response.json()\n    assert status_data[\"status\"] == \"pending\"\n    assert status_data[\"customer_name\"] == \"John Doe\"\n\n    # Act &amp; Assert - Start cooking (kitchen staff)\n    cooking_data = {\n        \"kitchen_staff_id\": \"staff_001\",\n        \"estimated_cooking_time_minutes\": 20\n    }\n\n    cook_response = test_client.put(f\"/api/orders/{order_id}/cook\", json=cooking_data)\n    assert cook_response.status_code == 200\n\n    # Verify status changed\n    final_status = test_client.get(f\"/api/orders/{order_id}/status\")\n    assert final_status.json()[\"status\"] == \"cooking\"\n</code></pre>"},{"location":"features/cqrs-mediation/#best-practices-for-pizzeria-cqrs","title":"\ud83d\ude80 Best Practices for Pizzeria CQRS","text":""},{"location":"features/cqrs-mediation/#1-single-responsibility","title":"1. Single Responsibility","text":"<p>Each command/query should have a single, well-defined business purpose:</p> <pre><code># \u2705 Good - Single responsibility\nclass PlaceOrderCommand: pass          # Only handles order placement\nclass UpdateOrderAddressCommand: pass  # Only updates delivery address  \nclass StartCookingCommand: pass        # Only starts cooking process\n\n# \u274c Avoid - Multiple responsibilities  \nclass ManageOrderCommand:              # Too broad, unclear purpose\n    action: str  # \"place\", \"update\", \"cook\" - violates SRP\n</code></pre>"},{"location":"features/cqrs-mediation/#2-immutable-commands-and-queries","title":"2. Immutable Commands and Queries","text":"<p>Make your requests immutable using dataclasses with frozen=True:</p> <pre><code>@dataclass(frozen=True)\nclass PlaceOrderCommand(Command[OperationResult]):\n    \"\"\"Immutable command - cannot be modified after creation\"\"\"\n    customer_name: str\n    customer_phone: str\n    pizza_items: tuple[PizzaItem, ...]  # Use tuple for immutability\n\n    def __post_init__(self):\n        # Validate on construction\n        if not self.pizza_items:\n            raise ValueError(\"Order must contain at least one pizza\")\n</code></pre>"},{"location":"features/cqrs-mediation/#3-rich-domain-events","title":"3. Rich Domain Events","text":"<p>Include all relevant context in domain events for downstream processing:</p> <pre><code>@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    \"\"\"Rich event with all necessary context\"\"\"\n    order_id: str\n    customer_name: str\n    customer_phone: str\n    customer_address: str\n    total_amount: Decimal\n    estimated_ready_time: datetime\n    pizza_details: List[dict]  # Full pizza specifications\n    payment_method: str\n    order_source: str  # \"web\", \"phone\", \"mobile_app\"\n\n    # This rich context allows event handlers to:\n    # - Send personalized notifications\n    # - Update analytics with customer segments\n    # - Route orders to appropriate kitchen stations\n    # - Integrate with delivery systems\n</code></pre>"},{"location":"features/cqrs-mediation/#4-query-optimization","title":"4. Query Optimization","text":"<p>Design queries for specific UI needs to avoid over-fetching:</p> <pre><code># \u2705 Optimized for kitchen display\nclass GetKitchenQueueQuery(Query):\n    status: str = \"cooking\"\n    include_special_instructions: bool = True\n    max_items: int = 10\n\n# \u2705 Optimized for customer mobile app\nclass GetOrderSummaryQuery(Query):\n    order_id: str\n    include_pizza_details: bool = False  # Customer doesn't need full specs\n    include_estimated_time: bool = True\n\n# \u2705 Optimized for management dashboard\nclass GetSalesAnalyticsQuery(Query):\n    date_range: DateRange\n    group_by: str  # \"hour\", \"day\", \"pizza_type\"\n    include_trends: bool = True\n</code></pre>"},{"location":"features/cqrs-mediation/#5-error-handling-strategy","title":"5. Error Handling Strategy","text":"<p>Provide meaningful error messages for different audiences:</p> <pre><code>class PlaceOrderCommandHandler(CommandHandler):\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult:\n        try:\n            # Business validation\n            if not await self._validate_business_hours():\n                return self.bad_request(\n                    \"Sorry, we're closed! Kitchen hours are 11 AM - 10 PM\"\n                )\n\n            if not await self._validate_delivery_area(command.customer_address):\n                return self.bad_request(\n                    \"We don't deliver to that area. Please try pickup instead.\"\n                )\n\n            # Process order...\n\n        except PaymentDeclinedException:\n            return self.bad_request(\n                \"Payment was declined. Please try a different payment method.\"\n            )\n        except KitchenOverloadedException:\n            return self.service_unavailable(\n                \"Kitchen is at capacity. Estimated wait time is 45 minutes.\"\n            )\n        except Exception as ex:\n            # Log technical details but return user-friendly message\n            self.logger.error(f\"Order placement failed: {ex}\")\n            return self.internal_server_error(\n                \"Sorry, we're having technical difficulties. Please try again.\"\n            )\n</code></pre>"},{"location":"features/cqrs-mediation/#key-benefits","title":"\ud83c\udfaf Key Benefits","text":"<p>Using CQRS with Neuroglia in Mario's Pizzeria provides:</p> <p>\u2705 Clear Business Intent - Commands like <code>PlaceOrderCommand</code> clearly express business operations \u2705 Scalable Read Models - Optimize queries for kitchen displays, customer apps, and reports \u2705 Event-Driven Integration - Events enable loose coupling between order, kitchen, and notification systems \u2705 Testable Components - Each handler can be unit tested in isolation \u2705 Cross-Cutting Concerns - Pipeline behaviors handle validation, logging, and caching consistently \u2705 Business Rule Enforcement - Domain logic is centralized in command handlers  </p>"},{"location":"features/cqrs-mediation/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Build Mario's Pizzeria step-by-step</li> <li>Dependency Injection - Service registration and lifetime management</li> <li>Data Access - Repository patterns and persistence</li> <li>MVC Controllers - API endpoints and request handling</li> <li>Resilient Handler Discovery - Robust handler registration for mixed codebases class DeactivateUserCommand: pass</li> </ul>"},{"location":"features/cqrs-mediation/#avoid-multiple-responsibilities","title":"Avoid - Multiple responsibilities","text":"<p>class ManageUserCommand: pass  # Too broad <pre><code>### 2. Immutable Requests\n\nMake commands and queries immutable:\n\n```python\n# Good - Immutable\n@dataclass(frozen=True)\nclass CreateUserCommand:\n    email: str\n    first_name: str\n    last_name: str\n\n# Avoid - Mutable\nclass CreateUserCommand:\n    def __init__(self):\n        self.email = None\n        self.first_name = None\n</code></pre></p>"},{"location":"features/cqrs-mediation/#3-rich-domain-models","title":"3. Rich Domain Models","text":"<p>Use domain events to decouple side effects:</p> <pre><code># Good - Domain events\nclass User:\n    def activate(self):\n        self.is_active = True\n        self.raise_event(UserActivatedEvent(self.id))\n\n# Avoid - Direct coupling\nclass User:\n    def activate(self, email_service: IEmailService):\n        self.is_active = True\n        email_service.send_activation_email(self.email)  # Tight coupling\n</code></pre>"},{"location":"features/cqrs-mediation/#4-validation","title":"4. Validation","text":"<p>Validate inputs at the right level:</p> <pre><code># Domain validation (business rules)\nclass CreateUserCommand:\n    def validate(self) -&gt; ValidationResult:\n        errors = []\n        if not self.email or '@' not in self.email:\n            errors.append(\"Valid email is required\")\n        return ValidationResult(errors)\n\n# Input validation (format/required fields)\nclass CreateUserDto:\n    email: str = Field(..., regex=r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$')\n    first_name: str = Field(..., min_length=1, max_length=50)\n</code></pre>"},{"location":"features/cqrs-mediation/#5-error-handling","title":"5. Error Handling","text":"<p>Use consistent error handling patterns:</p> <pre><code>class CreateUserCommandHandler(CommandHandler):\n    async def handle_async(self, command: CreateUserCommand) -&gt; OperationResult[UserDto]:\n        try:\n            # Business logic\n            user = await self.create_user(command)\n            return self.created(user)\n\n        except EmailAlreadyExistsException:\n            return self.conflict(\"Email already exists\")\n        except InvalidEmailException:\n            return self.bad_request(\"Invalid email format\")\n        except Exception as ex:\n            return self.internal_error(f\"Failed to create user: {ex}\")\n</code></pre>"},{"location":"features/cqrs-mediation/#related-documentation_1","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Basic CQRS usage</li> <li>Architecture Guide - How CQRS fits in the architecture</li> <li>Dependency Injection - DI with handlers</li> <li>Data Access - Repositories and units of work</li> <li>Event Handling - Domain events and integration events</li> </ul>"},{"location":"features/data-access/","title":"\ud83c\udf55 Data Access","text":"<p>Neuroglia provides a flexible data access layer that supports multiple storage backends through a unified repository pattern for Mario's Pizzeria. From storing pizza orders in files to managing kitchen workflows with event sourcing, the framework adapts to your pizzeria's needs.</p> <p>Let's explore how to store orders, manage inventory, and track kitchen operations using different persistence strategies.</p>"},{"location":"features/data-access/#overview","title":"\ud83c\udfaf Overview","text":"<p>The pizzeria data access system provides:</p> <ul> <li>Repository Pattern: Unified interface for orders, pizzas, and customer data</li> <li>Multiple Storage Backends: File-based (development), MongoDB (production), Event Store (kitchen events)</li> <li>Event Sourcing: Complete order lifecycle tracking with EventStoreDB</li> <li>CQRS Support: Separate read models for menus and write models for orders</li> <li>Query Abstractions: Find orders by status, customer, or time period</li> <li>Unit of Work: Transaction management across order processing</li> </ul>"},{"location":"features/data-access/#core-abstractions","title":"\ud83c\udfd7\ufe0f Core Abstractions","text":""},{"location":"features/data-access/#repository-interface-for-pizzeria-entities","title":"Repository Interface for Pizzeria Entities","text":"<p>The base repository interface defines standard CRUD operations for pizzeria data:</p> <pre><code>from abc import ABC, abstractmethod\nfrom typing import Generic, TypeVar, List, Optional\nfrom datetime import datetime, date\n\nTEntity = TypeVar('TEntity')\nTKey = TypeVar('TKey')\n\nclass Repository(Generic[TEntity, TKey], ABC):\n    \"\"\"Base repository interface for pizzeria entities\"\"\"\n\n    @abstractmethod\n    async def get_by_id_async(self, id: TKey) -&gt; Optional[TEntity]:\n        \"\"\"Get entity by ID (order, pizza, customer)\"\"\"\n        pass\n\n    @abstractmethod\n    async def save_async(self, entity: TEntity) -&gt; None:\n        \"\"\"Save entity (create or update)\"\"\"\n        pass\n\n    @abstractmethod\n    async def delete_async(self, id: TKey) -&gt; None:\n        \"\"\"Delete entity by ID\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_all_async(self) -&gt; List[TEntity]:\n        \"\"\"Get all entities\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_async(self, predicate) -&gt; List[TEntity]:\n        \"\"\"Find entities matching predicate\"\"\"\n        pass\n\n# Pizzeria-specific repository interfaces\nclass IOrderRepository(Repository[Order, str], ABC):\n    \"\"\"Order-specific repository operations\"\"\"\n\n    @abstractmethod\n    async def get_by_customer_phone_async(self, phone: str) -&gt; List[Order]:\n        \"\"\"Get orders by customer phone number\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_by_status_async(self, status: str) -&gt; List[Order]:\n        \"\"\"Get orders by status (pending, cooking, ready, delivered)\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_by_date_range_async(self, start_date: date, end_date: date) -&gt; List[Order]:\n        \"\"\"Get orders within date range for reports\"\"\"\n        pass\n\nclass IPizzaRepository(Repository[Pizza, str], ABC):\n    \"\"\"Pizza menu repository operations\"\"\"\n\n    @abstractmethod\n    async def get_by_category_async(self, category: str) -&gt; List[Pizza]:\n        \"\"\"Get pizzas by category (signature, specialty, custom)\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_available_async(self) -&gt; List[Pizza]:\n        \"\"\"Get only available pizzas (not sold out)\"\"\"\n        pass\n</code></pre> <pre><code>from neuroglia.data.abstractions import Queryable\nfrom typing import Callable\nfrom decimal import Decimal\n\nclass QueryablePizzeriaRepository(Repository[TEntity, TKey], Queryable[TEntity]):\n    \"\"\"Repository with advanced querying for pizzeria analytics\"\"\"\n\n    async def where(self, predicate: Callable[[TEntity], bool]) -&gt; List[TEntity]:\n        \"\"\"Filter pizzeria entities by predicate\"\"\"\n        pass\n\n    async def order_by_desc(self, selector: Callable[[TEntity], any]) -&gt; List[TEntity]:\n        \"\"\"Order entities in descending order\"\"\"\n        pass\n\n    async def group_by(self, selector: Callable[[TEntity], any]) -&gt; dict:\n        \"\"\"Group entities for analytics\"\"\"\n        pass\n\n# Example: Advanced order queries\nclass ExtendedOrderRepository(IOrderRepository, QueryablePizzeriaRepository[Order, str]):\n    \"\"\"Order repository with advanced analytics queries\"\"\"\n\n    async def get_top_customers_async(self, limit: int = 10) -&gt; List[dict]:\n        \"\"\"Get top customers by order count\"\"\"\n        orders = await self.get_all_async()\n        customer_counts = {}\n\n        for order in orders:\n            phone = order.customer_phone\n            customer_counts[phone] = customer_counts.get(phone, 0) + 1\n\n        # Sort and limit\n        top_customers = sorted(customer_counts.items(), key=lambda x: x[1], reverse=True)[:limit]\n\n        return [{\"phone\": phone, \"order_count\": count} for phone, count in top_customers]\n\n    async def get_revenue_by_date_async(self, start_date: date, end_date: date) -&gt; List[dict]:\n        \"\"\"Get daily revenue within date range\"\"\"\n        orders = await self.get_by_date_range_async(start_date, end_date)\n        daily_revenue = {}\n\n        for order in orders:\n            order_date = order.order_time.date()\n            if order_date not in daily_revenue:\n                daily_revenue[order_date] = Decimal('0')\n            daily_revenue[order_date] += order.total_amount\n\n        return [{\"date\": date, \"revenue\": revenue} for date, revenue in sorted(daily_revenue.items())]\n</code></pre>"},{"location":"features/data-access/#file-based-storage-for-development","title":"\ud83d\udcc1 File-Based Storage for Development","text":""},{"location":"features/data-access/#file-repository-implementation","title":"File Repository Implementation","text":"<p>Perfect for development and testing of Mario's Pizzeria:</p> <pre><code>import json\nimport os\nfrom pathlib import Path\nfrom typing import List, Optional, Callable\nfrom datetime import datetime, date\n\nclass FileRepository(Repository[TEntity, TKey]):\n    \"\"\"File-based repository using JSON storage\"\"\"\n\n    def __init__(self, entity_type: type, data_dir: str = \"data\"):\n        self.entity_type = entity_type\n        self.entity_name = entity_type.__name__.lower()\n        self.data_dir = Path(data_dir)\n        self.entity_dir = self.data_dir / self.entity_name\n\n        # Ensure directories exist\n        self.entity_dir.mkdir(parents=True, exist_ok=True)\n\n    async def get_by_id_async(self, id: TKey) -&gt; Optional[TEntity]:\n        \"\"\"Get entity from JSON file\"\"\"\n        file_path = self.entity_dir / f\"{id}.json\"\n\n        if not file_path.exists():\n            return None\n\n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                data = json.load(f)\n                return self._dict_to_entity(data)\n        except Exception as e:\n            raise StorageException(f\"Failed to load {self.entity_name} {id}: {e}\")\n\n    async def save_async(self, entity: TEntity) -&gt; None:\n        \"\"\"Save entity to JSON file\"\"\"\n        file_path = self.entity_dir / f\"{entity.id}.json\"\n\n        try:\n            data = self._entity_to_dict(entity)\n            with open(file_path, 'w', encoding='utf-8') as f:\n                json.dump(data, f, indent=2, default=self._json_serializer, ensure_ascii=False)\n        except Exception as e:\n            raise StorageException(f\"Failed to save {self.entity_name} {entity.id}: {e}\")\n\n    async def delete_async(self, id: TKey) -&gt; None:\n        \"\"\"Delete entity JSON file\"\"\"\n        file_path = self.entity_dir / f\"{id}.json\"\n        if file_path.exists():\n            file_path.unlink()\n\n    async def get_all_async(self) -&gt; List[TEntity]:\n        \"\"\"Get all entities from JSON files\"\"\"\n        entities = []\n\n        for file_path in self.entity_dir.glob(\"*.json\"):\n            try:\n                with open(file_path, 'r', encoding='utf-8') as f:\n                    data = json.load(f)\n                    entity = self._dict_to_entity(data)\n                    entities.append(entity)\n            except Exception as e:\n                print(f\"Warning: Failed to load {file_path}: {e}\")\n                continue\n\n        return entities\n\n    async def find_async(self, predicate: Callable[[TEntity], bool]) -&gt; List[TEntity]:\n        \"\"\"Find entities matching predicate\"\"\"\n        all_entities = await self.get_all_async()\n        return [entity for entity in all_entities if predicate(entity)]\n\n    def _entity_to_dict(self, entity: TEntity) -&gt; dict:\n        \"\"\"Convert entity to dictionary for JSON serialization\"\"\"\n        if hasattr(entity, '__dict__'):\n            return entity.__dict__.copy()\n        elif hasattr(entity, '_asdict'):\n            return entity._asdict()\n        else:\n            raise ValueError(f\"Cannot serialize entity of type {type(entity)}\")\n\n    def _dict_to_entity(self, data: dict) -&gt; TEntity:\n        \"\"\"Convert dictionary back to entity\"\"\"\n        return self.entity_type(**data)\n\n    def _json_serializer(self, obj):\n        \"\"\"Handle special types in JSON serialization\"\"\"\n        if isinstance(obj, (datetime, date)):\n            return obj.isoformat()\n        elif hasattr(obj, '__dict__'):\n            return obj.__dict__\n        else:\n            return str(obj)\n\n# Pizzeria-specific file repositories\nclass FileOrderRepository(FileRepository[Order, str], IOrderRepository):\n    \"\"\"File-based order repository for development\"\"\"\n\n    def __init__(self, data_dir: str = \"data\"):\n        super().__init__(Order, data_dir)\n\n    async def get_by_customer_phone_async(self, phone: str) -&gt; List[Order]:\n        \"\"\"Get orders by customer phone\"\"\"\n        return await self.find_async(lambda order: order.customer_phone == phone)\n\n    async def get_by_status_async(self, status: str) -&gt; List[Order]:\n        \"\"\"Get orders by status\"\"\"\n        return await self.find_async(lambda order: order.status == status)\n\n    async def get_by_date_range_async(self, start_date: date, end_date: date) -&gt; List[Order]:\n        \"\"\"Get orders within date range\"\"\"\n        return await self.find_async(lambda order: \n            start_date &lt;= order.order_time.date() &lt;= end_date)\n\nclass FilePizzaRepository(FileRepository[Pizza, str], IPizzaRepository):\n    \"\"\"File-based pizza repository for menu management\"\"\"\n\n    def __init__(self, data_dir: str = \"data\"):\n        super().__init__(Pizza, data_dir)\n\n    async def get_by_category_async(self, category: str) -&gt; List[Pizza]:\n        \"\"\"Get pizzas by category\"\"\"\n        return await self.find_async(lambda pizza: pizza.category == category)\n\n    async def get_available_async(self) -&gt; List[Pizza]:\n        \"\"\"Get available pizzas only\"\"\"\n        return await self.find_async(lambda pizza: pizza.is_available)\n</code></pre>"},{"location":"features/data-access/#mongodb-repository-for-pizzeria","title":"MongoDB Repository for Pizzeria","text":"<p>Built-in MongoDB repository implementation for production pizzeria:</p> <pre><code>from neuroglia.data.infrastructure.mongo import MongoRepository\nfrom motor.motor_asyncio import AsyncIOMotorClient, AsyncIOMotorDatabase\nfrom bson import ObjectId\nfrom typing import Optional, List, Dict, Any\n\nclass MongoOrderRepository(MongoRepository[Order, str], IOrderRepository):\n    \"\"\"MongoDB repository for pizza orders\"\"\"\n\n    def __init__(self, database: AsyncIOMotorDatabase):\n        super().__init__(database, \"orders\")\n\n    async def get_by_customer_phone_async(self, phone: str) -&gt; List[Order]:\n        \"\"\"Get orders by customer phone with index optimization\"\"\"\n        cursor = self.collection.find({\"customer_phone\": phone}).sort(\"order_time\", -1)\n        documents = await cursor.to_list(length=None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def get_by_status_async(self, status: str) -&gt; List[Order]:\n        \"\"\"Get orders by status for kitchen management\"\"\"\n        cursor = self.collection.find({\"status\": status}).sort(\"order_time\", 1)  # FIFO\n        documents = await cursor.to_list(length=None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def get_by_date_range_async(self, start_date: date, end_date: date) -&gt; List[Order]:\n        \"\"\"Get orders within date range for reporting\"\"\"\n        start_datetime = datetime.combine(start_date, datetime.min.time())\n        end_datetime = datetime.combine(end_date, datetime.max.time())\n\n        cursor = self.collection.find({\n            \"order_time\": {\n                \"$gte\": start_datetime,\n                \"$lte\": end_datetime\n            }\n        }).sort(\"order_time\", 1)\n\n        documents = await cursor.to_list(length=None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def get_kitchen_queue_async(self, statuses: List[str]) -&gt; List[Order]:\n        \"\"\"Get orders in kitchen queue (optimized for kitchen display)\"\"\"\n        cursor = self.collection.find(\n            {\"status\": {\"$in\": statuses}},\n            {\"customer_name\": 1, \"pizzas\": 1, \"order_time\": 1, \"status\": 1, \"estimated_ready_time\": 1}\n        ).sort(\"order_time\", 1)\n\n        documents = await cursor.to_list(length=None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def get_daily_revenue_async(self, target_date: date) -&gt; Dict[str, Any]:\n        \"\"\"Get daily revenue aggregation\"\"\"\n        start_datetime = datetime.combine(target_date, datetime.min.time())\n        end_datetime = datetime.combine(target_date, datetime.max.time())\n\n        pipeline = [\n            {\n                \"$match\": {\n                    \"order_time\": {\"$gte\": start_datetime, \"$lte\": end_datetime},\n                    \"status\": {\"$in\": [\"ready\", \"delivered\"]}  # Only completed orders\n                }\n            },\n            {\n                \"$group\": {\n                    \"_id\": None,\n                    \"total_revenue\": {\"$sum\": \"$total_amount\"},\n                    \"order_count\": {\"$sum\": 1},\n                    \"average_order_value\": {\"$avg\": \"$total_amount\"}\n                }\n            }\n        ]\n\n        result = await self.collection.aggregate(pipeline).to_list(length=1)\n        return result[0] if result else {\"total_revenue\": 0, \"order_count\": 0, \"average_order_value\": 0}\n\n    def _entity_to_document(self, order: Order) -&gt; Dict[str, Any]:\n        \"\"\"Convert order entity to MongoDB document\"\"\"\n        doc = {\n            \"_id\": order.id,\n            \"customer_name\": order.customer_name,\n            \"customer_phone\": order.customer_phone,\n            \"customer_address\": order.customer_address,\n            \"pizzas\": [self._pizza_to_dict(pizza) for pizza in order.pizzas],\n            \"status\": order.status,\n            \"order_time\": order.order_time,\n            \"estimated_ready_time\": order.estimated_ready_time,\n            \"total_amount\": float(order.total_amount),  # MongoDB decimal handling\n            \"payment_method\": order.payment_method\n        }\n        return doc\n\n    def _document_to_entity(self, doc: Dict[str, Any]) -&gt; Order:\n        \"\"\"Convert MongoDB document to order entity\"\"\"\n        return Order(\n            id=doc[\"_id\"],\n            customer_name=doc[\"customer_name\"],\n            customer_phone=doc[\"customer_phone\"],\n            customer_address=doc[\"customer_address\"],\n            pizzas=[self._dict_to_pizza(pizza_dict) for pizza_dict in doc[\"pizzas\"]],\n            status=doc[\"status\"],\n            order_time=doc[\"order_time\"],\n            estimated_ready_time=doc.get(\"estimated_ready_time\"),\n            total_amount=Decimal(str(doc[\"total_amount\"])),\n            payment_method=doc.get(\"payment_method\", \"cash\")\n        )\n\nclass MongoPizzaRepository(MongoRepository[Pizza, str], IPizzaRepository):\n    \"\"\"MongoDB repository for pizza menu management\"\"\"\n\n    def __init__(self, database: AsyncIOMotorDatabase):\n        super().__init__(database, \"pizzas\")\n\n    async def get_by_category_async(self, category: str) -&gt; List[Pizza]:\n        \"\"\"Get pizzas by category with caching optimization\"\"\"\n        cursor = self.collection.find({\"category\": category, \"is_available\": True}).sort(\"name\", 1)\n        documents = await cursor.to_list(length=None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def get_available_async(self) -&gt; List[Pizza]:\n        \"\"\"Get all available pizzas for menu display\"\"\"\n        cursor = self.collection.find({\"is_available\": True}).sort([(\"category\", 1), (\"name\", 1)])\n        documents = await cursor.to_list(length=None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def update_availability_async(self, pizza_id: str, is_available: bool) -&gt; None:\n        \"\"\"Update pizza availability (for sold out items)\"\"\"\n        await self.collection.update_one(\n            {\"_id\": pizza_id},\n            {\"$set\": {\"is_available\": is_available, \"updated_at\": datetime.utcnow()}}\n        )\n\n    def _entity_to_document(self, pizza: Pizza) -&gt; Dict[str, Any]:\n        \"\"\"Convert pizza entity to MongoDB document\"\"\"\n        return {\n            \"_id\": pizza.id,\n            \"name\": pizza.name,\n            \"description\": pizza.description,\n            \"category\": pizza.category,\n            \"base_price\": float(pizza.base_price),\n            \"available_toppings\": pizza.available_toppings,\n            \"preparation_time_minutes\": pizza.preparation_time_minutes,\n            \"is_available\": pizza.is_available,\n            \"is_seasonal\": pizza.is_seasonal,\n            \"created_at\": pizza.created_at,\n            \"updated_at\": datetime.utcnow()\n        }\n</code></pre>"},{"location":"features/data-access/#mongodb-indexes-for-performance","title":"MongoDB Indexes for Performance","text":"<p>Create indexes for pizzeria query patterns:</p> <pre><code># Create indexes for optimal pizzeria query performance\nasync def create_pizzeria_indexes():\n    \"\"\"Create MongoDB indexes for pizzeria collections\"\"\"\n\n    # Order collection indexes\n    await orders_collection.create_index(\"customer_phone\")  # Customer lookup\n    await orders_collection.create_index(\"status\")  # Kitchen filtering\n    await orders_collection.create_index(\"order_time\")  # Chronological ordering\n    await orders_collection.create_index([(\"status\", 1), (\"order_time\", 1)])  # Kitchen queue\n    await orders_collection.create_index([(\"order_time\", -1)])  # Recent orders first\n    await orders_collection.create_index(\"estimated_ready_time\")  # Ready time tracking\n\n    # Pizza collection indexes  \n    await pizzas_collection.create_index(\"category\")  # Menu category filtering\n    await pizzas_collection.create_index(\"is_available\")  # Available items only\n    await pizzas_collection.create_index([(\"category\", 1), (\"name\", 1)])  # Sorted menu display\n    await pizzas_collection.create_index(\"is_seasonal\")  # Seasonal items management\n</code></pre>"},{"location":"features/data-access/#repository-registration-with-mongodb","title":"Repository Registration with MongoDB","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\n\ndef create_pizzeria_app():\n    \"\"\"Create Mario's Pizzeria application with MongoDB persistence\"\"\"\n    builder = WebApplicationBuilder()\n\n    # MongoDB configuration\n    mongo_client = AsyncIOMotorClient(\"mongodb://localhost:27017\")\n    database = mongo_client.marios_pizzeria\n\n    # Repository registration\n    builder.services.add_singleton(lambda: database)\n    builder.services.add_scoped(MongoOrderRepository)\n    builder.services.add_scoped(MongoPizzaRepository)\n\n    # Alias interfaces to implementations\n    builder.services.add_scoped(IOrderRepository, lambda sp: sp.get_service(MongoOrderRepository))\n    builder.services.add_scoped(IPizzaRepository, lambda sp: sp.get_service(MongoPizzaRepository))\n\n    app = builder.build()\n    return app\n</code></pre>"},{"location":"features/data-access/#event-sourcing-for-kitchen-workflow","title":"\ud83d\udcca Event Sourcing for Kitchen Workflow","text":""},{"location":"features/data-access/#kitchen-event-store","title":"Kitchen Event Store","text":"<p>Track kitchen workflow with event sourcing patterns:</p> <pre><code>from neuroglia.eventing import DomainEvent\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any\nfrom dataclasses import dataclass\n\n@dataclass\nclass OrderStatusChangedEvent(DomainEvent):\n    \"\"\"Event for tracking order status changes in kitchen\"\"\"\n    order_id: str\n    old_status: str\n    new_status: str\n    changed_by: str\n    change_reason: Optional[str] = None\n    estimated_ready_time: Optional[datetime] = None\n\n@dataclass\nclass PizzaStartedEvent(DomainEvent):\n    \"\"\"Event when pizza preparation begins\"\"\"\n    order_id: str\n    pizza_name: str\n    pizza_index: int\n    started_by: str\n    estimated_completion: datetime\n\n@dataclass\nclass PizzaCompletedEvent(DomainEvent):\n    \"\"\"Event when pizza is finished\"\"\"\n    order_id: str\n    pizza_name: str\n    pizza_index: int\n    completed_by: str\n    actual_completion_time: datetime\n    preparation_duration_minutes: int\n\nclass KitchenWorkflowEventStore:\n    \"\"\"Event store for kitchen workflow tracking\"\"\"\n\n    def __init__(self, event_repository: IEventRepository):\n        self.event_repository = event_repository\n\n    async def record_order_status_change(self, \n                                         order_id: str, \n                                         old_status: str, \n                                         new_status: str,\n                                         changed_by: str,\n                                         change_reason: str = None) -&gt; None:\n        \"\"\"Record order status changes for kitchen analytics\"\"\"\n        event = OrderStatusChangedEvent(\n            order_id=order_id,\n            old_status=old_status,\n            new_status=new_status,\n            changed_by=changed_by,\n            change_reason=change_reason,\n            estimated_ready_time=self._calculate_ready_time(new_status)\n        )\n\n        await self.event_repository.save_event_async(event)\n\n    async def record_pizza_started(self, \n                                   order_id: str, \n                                   pizza_name: str, \n                                   pizza_index: int,\n                                   started_by: str) -&gt; None:\n        \"\"\"Record when pizza preparation begins\"\"\"\n        estimated_completion = datetime.utcnow() + timedelta(\n            minutes=self._get_pizza_prep_time(pizza_name)\n        )\n\n        event = PizzaStartedEvent(\n            order_id=order_id,\n            pizza_name=pizza_name,\n            pizza_index=pizza_index,\n            started_by=started_by,\n            estimated_completion=estimated_completion\n        )\n\n        await self.event_repository.save_event_async(event)\n\n    async def record_pizza_completed(self, \n                                     order_id: str, \n                                     pizza_name: str, \n                                     pizza_index: int,\n                                     completed_by: str,\n                                     start_time: datetime) -&gt; None:\n        \"\"\"Record when pizza is completed\"\"\"\n        completion_time = datetime.utcnow()\n        duration_minutes = int((completion_time - start_time).total_seconds() / 60)\n\n        event = PizzaCompletedEvent(\n            order_id=order_id,\n            pizza_name=pizza_name,\n            pizza_index=pizza_index,\n            completed_by=completed_by,\n            actual_completion_time=completion_time,\n            preparation_duration_minutes=duration_minutes\n        )\n\n        await self.event_repository.save_event_async(event)\n\n    async def get_kitchen_performance_metrics(self, date_range: tuple[date, date]) -&gt; Dict[str, Any]:\n        \"\"\"Get kitchen performance analytics from events\"\"\"\n        start_date, end_date = date_range\n\n        # Query events within date range\n        events = await self.event_repository.get_events_by_date_range_async(start_date, end_date)\n\n        # Calculate metrics\n        pizza_completion_events = [e for e in events if isinstance(e, PizzaCompletedEvent)]\n        status_change_events = [e for e in events if isinstance(e, OrderStatusChangedEvent)]\n\n        return {\n            \"total_pizzas_completed\": len(pizza_completion_events),\n            \"average_prep_time_minutes\": self._calculate_average_prep_time(pizza_completion_events),\n            \"peak_hours\": self._calculate_peak_hours(status_change_events),\n            \"order_completion_rate\": self._calculate_completion_rate(status_change_events),\n            \"staff_performance\": self._calculate_staff_performance(pizza_completion_events)\n        }\n</code></pre> <pre><code>from neuroglia.data import Repository\nfrom typing import List, Dict, Any\nimport json\nfrom pathlib import Path\nfrom datetime import datetime\n\nclass FileEventRepository(Repository[DomainEvent, str]):\n    \"\"\"File-based event repository for development and testing\"\"\"\n\n    def __init__(self, events_directory: str = \"data/events\"):\n        super().__init__()\n        self.events_directory = Path(events_directory)\n        self.events_directory.mkdir(parents=True, exist_ok=True)\n\n    async def save_event_async(self, event: DomainEvent) -&gt; None:\n        \"\"\"Save event to JSON file organized by date\"\"\"\n        event_date = event.occurred_at.date()\n        date_directory = self.events_directory / event_date.strftime(\"%Y-%m-%d\")\n        date_directory.mkdir(exist_ok=True)\n\n        event_file = date_directory / f\"{event.id}.json\"\n\n        event_data = {\n            \"id\": event.id,\n            \"event_type\": event.__class__.__name__,\n            \"occurred_at\": event.occurred_at.isoformat(),\n            \"data\": self._serialize_event_data(event)\n        }\n\n        async with aiofiles.open(event_file, 'w') as f:\n            await f.write(json.dumps(event_data, indent=2))\n\n    async def get_events_by_date_range_async(self, \n                                             start_date: date, \n                                             end_date: date) -&gt; List[DomainEvent]:\n        \"\"\"Get events within date range\"\"\"\n        events = []\n        current_date = start_date\n\n        while current_date &lt;= end_date:\n            date_directory = self.events_directory / current_date.strftime(\"%Y-%m-%d\")\n\n            if date_directory.exists():\n                for event_file in date_directory.glob(\"*.json\"):\n                    async with aiofiles.open(event_file, 'r') as f:\n                        event_data = json.loads(await f.read())\n                        event = self._deserialize_event(event_data)\n                        if event:\n                            events.append(event)\n\n            current_date += timedelta(days=1)\n\n        return sorted(events, key=lambda e: e.occurred_at)\n</code></pre>"},{"location":"features/data-access/#mongodb-event-store","title":"MongoDB Event Store","text":"<p>Production event store with aggregation capabilities:</p> <pre><code>from neuroglia.data.infrastructure.mongo import MongoRepository\nfrom motor.motor_asyncio import AsyncIOMotorDatabase\n\nclass MongoEventRepository(MongoRepository[DomainEvent, str]):\n    \"\"\"MongoDB event repository for production event sourcing\"\"\"\n\n    def __init__(self, database: AsyncIOMotorDatabase):\n        super().__init__(database, \"events\")\n\n    async def save_event_async(self, event: DomainEvent) -&gt; None:\n        \"\"\"Save event with automatic indexing\"\"\"\n        document = {\n            \"_id\": event.id,\n            \"event_type\": event.__class__.__name__,\n            \"occurred_at\": event.occurred_at,\n            \"data\": self._serialize_event_data(event),\n            \"version\": 1,\n            \"metadata\": {\n                \"correlation_id\": getattr(event, 'correlation_id', None),\n                \"causation_id\": getattr(event, 'causation_id', None)\n            }\n        }\n\n        await self.collection.insert_one(document)\n\n    async def get_kitchen_timeline_events(self, \n                                          order_id: str,\n                                          limit: int = 100) -&gt; List[DomainEvent]:\n        \"\"\"Get chronological timeline of kitchen events for an order\"\"\"\n        cursor = self.collection.find(\n            {\n                \"event_type\": {\"$in\": [\"OrderStatusChangedEvent\", \"PizzaStartedEvent\", \"PizzaCompletedEvent\"]},\n                \"data.order_id\": order_id\n            }\n        ).sort(\"occurred_at\", 1).limit(limit)\n\n        documents = await cursor.to_list(length=limit)\n        return [self._deserialize_event(doc) for doc in documents]\n\n    async def get_performance_aggregation(self, \n                                          start_date: datetime,\n                                          end_date: datetime) -&gt; Dict[str, Any]:\n        \"\"\"Get aggregated kitchen performance metrics\"\"\"\n        pipeline = [\n            {\n                \"$match\": {\n                    \"occurred_at\": {\"$gte\": start_date, \"$lte\": end_date},\n                    \"event_type\": \"PizzaCompletedEvent\"\n                }\n            },\n            {\n                \"$group\": {\n                    \"_id\": \"$data.pizza_name\",\n                    \"total_pizzas\": {\"$sum\": 1},\n                    \"avg_prep_time\": {\"$avg\": \"$data.preparation_duration_minutes\"},\n                    \"min_prep_time\": {\"$min\": \"$data.preparation_duration_minutes\"},\n                    \"max_prep_time\": {\"$max\": \"$data.preparation_duration_minutes\"}\n                }\n            },\n            {\n                \"$sort\": {\"total_pizzas\": -1}\n            }\n        ]\n\n        results = await self.collection.aggregate(pipeline).to_list(length=None)\n        return {\n            \"pizza_performance\": results,\n            \"reporting_period\": {\n                \"start\": start_date.isoformat(),\n                \"end\": end_date.isoformat()\n            }\n        }\n</code></pre> <pre><code>from neuroglia.data import IQueryableRepository\nfrom typing import List, Dict, Any, Optional\nfrom datetime import datetime, date, timedelta\n\nclass IAnalyticsRepository(IQueryableRepository[Order, str]):\n    \"\"\"Enhanced queryable interface for pizzeria analytics\"\"\"\n\n    async def get_revenue_by_period_async(self, \n                                          period: str,  # 'daily', 'weekly', 'monthly'\n                                          start_date: date,\n                                          end_date: date) -&gt; Dict[str, Any]:\n        \"\"\"Get revenue metrics grouped by time period\"\"\"\n        pass\n\n    async def get_popular_pizzas_async(self, \n                                       start_date: date,\n                                       end_date: date,\n                                       limit: int = 10) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get most popular pizzas by order count\"\"\"\n        pass\n\n    async def get_customer_insights_async(self,\n                                          customer_phone: str) -&gt; Dict[str, Any]:\n        \"\"\"Get customer ordering patterns and preferences\"\"\"\n        pass\n\n    async def get_peak_hours_analysis_async(self,\n                                            date_range: tuple[date, date]) -&gt; Dict[str, Any]:\n        \"\"\"Analyze order patterns by hour of day\"\"\"\n        pass\n\nclass MongoAnalyticsRepository(MongoOrderRepository, IAnalyticsRepository):\n    \"\"\"MongoDB implementation with advanced analytics capabilities\"\"\"\n\n    async def get_revenue_by_period_async(self, \n                                          period: str,\n                                          start_date: date,\n                                          end_date: date) -&gt; Dict[str, Any]:\n        \"\"\"Get revenue metrics with MongoDB aggregation\"\"\"\n        start_datetime = datetime.combine(start_date, datetime.min.time())\n        end_datetime = datetime.combine(end_date, datetime.max.time())\n\n        # Dynamic grouping based on period\n        group_format = {\n            'daily': {\"$dateToString\": {\"format\": \"%Y-%m-%d\", \"date\": \"$order_time\"}},\n            'weekly': {\"$dateToString\": {\"format\": \"%Y-W%U\", \"date\": \"$order_time\"}},\n            'monthly': {\"$dateToString\": {\"format\": \"%Y-%m\", \"date\": \"$order_time\"}}\n        }\n\n        pipeline = [\n            {\n                \"$match\": {\n                    \"order_time\": {\"$gte\": start_datetime, \"$lte\": end_datetime},\n                    \"status\": {\"$in\": [\"ready\", \"delivered\"]}\n                }\n            },\n            {\n                \"$group\": {\n                    \"_id\": group_format.get(period, group_format['daily']),\n                    \"revenue\": {\"$sum\": \"$total_amount\"},\n                    \"order_count\": {\"$sum\": 1},\n                    \"average_order_value\": {\"$avg\": \"$total_amount\"}\n                }\n            },\n            {\n                \"$sort\": {\"_id\": 1}\n            }\n        ]\n\n        results = await self.collection.aggregate(pipeline).to_list(length=None)\n\n        return {\n            \"period\": period,\n            \"data\": results,\n            \"summary\": {\n                \"total_revenue\": sum(r[\"revenue\"] for r in results),\n                \"total_orders\": sum(r[\"order_count\"] for r in results),\n                \"periods_analyzed\": len(results)\n            }\n        }\n\n    async def get_popular_pizzas_async(self, \n                                       start_date: date,\n                                       end_date: date,\n                                       limit: int = 10) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get most popular pizzas with detailed analytics\"\"\"\n        start_datetime = datetime.combine(start_date, datetime.min.time())\n        end_datetime = datetime.combine(end_date, datetime.max.time())\n\n        pipeline = [\n            {\n                \"$match\": {\n                    \"order_time\": {\"$gte\": start_datetime, \"$lte\": end_datetime},\n                    \"status\": {\"$in\": [\"ready\", \"delivered\"]}\n                }\n            },\n            {\n                \"$unwind\": \"$pizzas\"\n            },\n            {\n                \"$group\": {\n                    \"_id\": \"$pizzas.name\",\n                    \"order_count\": {\"$sum\": 1},\n                    \"total_revenue\": {\"$sum\": \"$pizzas.price\"},\n                    \"avg_price\": {\"$avg\": \"$pizzas.price\"},\n                    \"unique_customers\": {\"$addToSet\": \"$customer_phone\"}\n                }\n            },\n            {\n                \"$project\": {\n                    \"pizza_name\": \"$_id\",\n                    \"order_count\": 1,\n                    \"total_revenue\": 1,\n                    \"avg_price\": 1,\n                    \"unique_customers\": {\"$size\": \"$unique_customers\"},\n                    \"_id\": 0\n                }\n            },\n            {\n                \"$sort\": {\"order_count\": -1}\n            },\n            {\n                \"$limit\": limit\n            }\n        ]\n\n        return await self.collection.aggregate(pipeline).to_list(length=limit)\n\n    async def get_customer_insights_async(self,\n                                          customer_phone: str) -&gt; Dict[str, Any]:\n        \"\"\"Comprehensive customer analytics\"\"\"\n        pipeline = [\n            {\n                \"$match\": {\"customer_phone\": customer_phone}\n            },\n            {\n                \"$group\": {\n                    \"_id\": \"$customer_phone\",\n                    \"total_orders\": {\"$sum\": 1},\n                    \"total_spent\": {\"$sum\": \"$total_amount\"},\n                    \"avg_order_value\": {\"$avg\": \"$total_amount\"},\n                    \"first_order\": {\"$min\": \"$order_time\"},\n                    \"last_order\": {\"$max\": \"$order_time\"},\n                    \"favorite_pizzas\": {\"$push\": \"$pizzas.name\"},\n                    \"payment_methods\": {\"$addToSet\": \"$payment_method\"}\n                }\n            },\n            {\n                \"$project\": {\n                    \"customer_phone\": \"$_id\",\n                    \"total_orders\": 1,\n                    \"total_spent\": 1,\n                    \"avg_order_value\": 1,\n                    \"first_order\": 1,\n                    \"last_order\": 1,\n                    \"customer_lifetime_days\": {\n                        \"$divide\": [\n                            {\"$subtract\": [\"$last_order\", \"$first_order\"]},\n                            86400000  # milliseconds to days\n                        ]\n                    },\n                    \"payment_methods\": 1,\n                    \"_id\": 0\n                }\n            }\n        ]\n\n        results = await self.collection.aggregate(pipeline).to_list(length=1)\n        if not results:\n            return {\"error\": \"Customer not found\"}\n\n        customer_data = results[0]\n\n        # Calculate favorite pizza (most frequent)\n        # This would need additional aggregation pipeline for pizza frequency\n\n        return customer_data\n\n    async def get_peak_hours_analysis_async(self,\n                                            date_range: tuple[date, date]) -&gt; Dict[str, Any]:\n        \"\"\"Analyze order patterns by hour for staffing optimization\"\"\"\n        start_date, end_date = date_range\n        start_datetime = datetime.combine(start_date, datetime.min.time())\n        end_datetime = datetime.combine(end_date, datetime.max.time())\n\n        pipeline = [\n            {\n                \"$match\": {\n                    \"order_time\": {\"$gte\": start_datetime, \"$lte\": end_datetime}\n                }\n            },\n            {\n                \"$group\": {\n                    \"_id\": {\"$hour\": \"$order_time\"},\n                    \"order_count\": {\"$sum\": 1},\n                    \"total_revenue\": {\"$sum\": \"$total_amount\"},\n                    \"avg_order_value\": {\"$avg\": \"$total_amount\"}\n                }\n            },\n            {\n                \"$project\": {\n                    \"hour\": \"$_id\",\n                    \"order_count\": 1,\n                    \"total_revenue\": 1,\n                    \"avg_order_value\": 1,\n                    \"_id\": 0\n                }\n            },\n            {\n                \"$sort\": {\"hour\": 1}\n            }\n        ]\n\n        results = await self.collection.aggregate(pipeline).to_list(length=24)\n\n        # Fill in missing hours with zero values\n        hourly_data = {r[\"hour\"]: r for r in results}\n        complete_data = []\n\n        for hour in range(24):\n            hour_data = hourly_data.get(hour, {\n                \"hour\": hour,\n                \"order_count\": 0,\n                \"total_revenue\": 0.0,\n                \"avg_order_value\": 0.0\n            })\n            complete_data.append(hour_data)\n\n        # Find peak hours (top 3)\n        sorted_by_orders = sorted(complete_data, key=lambda x: x[\"order_count\"], reverse=True)\n        peak_hours = sorted_by_orders[:3]\n\n        return {\n            \"hourly_breakdown\": complete_data,\n            \"peak_hours\": peak_hours,\n            \"analysis_period\": {\n                \"start_date\": start_date.isoformat(),\n                \"end_date\": end_date.isoformat()\n            }\n        }\n</code></pre> <pre><code>import pytest\nfrom unittest.mock import AsyncMock\nfrom datetime import datetime, date, timedelta\nfrom decimal import Decimal\n\nclass TestOrderRepository:\n    \"\"\"Unit tests for order repository implementations\"\"\"\n\n    @pytest.fixture\n    def sample_order(self):\n        \"\"\"Create sample pizza order for testing\"\"\"\n        return Order(\n            id=\"order_123\",\n            customer_name=\"John Doe\",\n            customer_phone=\"+1234567890\",\n            customer_address=\"123 Main St\",\n            pizzas=[\n                Pizza(name=\"Margherita\", price=Decimal(\"12.99\")),\n                Pizza(name=\"Pepperoni\", price=Decimal(\"14.99\"))\n            ],\n            status=\"preparing\",\n            order_time=datetime.utcnow(),\n            total_amount=Decimal(\"27.98\"),\n            payment_method=\"card\"\n        )\n\n    @pytest.fixture\n    def mock_file_repository(self, tmp_path):\n        \"\"\"Create file repository with temporary directory\"\"\"\n        return FileOrderRepository(str(tmp_path / \"orders\"))\n\n    @pytest.mark.asyncio\n    async def test_save_order_creates_file(self, mock_file_repository, sample_order):\n        \"\"\"Test that saving an order creates proper file structure\"\"\"\n        await mock_file_repository.save_async(sample_order)\n\n        # Verify file was created\n        order_file = Path(mock_file_repository.orders_directory) / f\"{sample_order.id}.json\"\n        assert order_file.exists()\n\n        # Verify file content\n        with open(order_file, 'r') as f:\n            order_data = json.load(f)\n            assert order_data[\"customer_name\"] == sample_order.customer_name\n            assert len(order_data[\"pizzas\"]) == 2\n\n    @pytest.mark.asyncio\n    async def test_get_by_customer_phone(self, mock_file_repository, sample_order):\n        \"\"\"Test customer phone lookup functionality\"\"\"\n        await mock_file_repository.save_async(sample_order)\n\n        # Create another order for same customer\n        second_order = Order(\n            id=\"order_456\",\n            customer_name=\"John Doe\",\n            customer_phone=\"+1234567890\",\n            customer_address=\"123 Main St\",\n            pizzas=[Pizza(name=\"Hawaiian\", price=Decimal(\"15.99\"))],\n            status=\"ready\",\n            order_time=datetime.utcnow() + timedelta(hours=1)\n        )\n        await mock_file_repository.save_async(second_order)\n\n        # Test phone lookup\n        customer_orders = await mock_file_repository.get_by_customer_phone_async(\"+1234567890\")\n\n        assert len(customer_orders) == 2\n        # Should be ordered by time (most recent first)\n        assert customer_orders[0].id == \"order_456\"\n        assert customer_orders[1].id == \"order_123\"\n\n    @pytest.mark.asyncio\n    async def test_kitchen_queue_filtering(self, mock_file_repository):\n        \"\"\"Test kitchen queue status filtering\"\"\"\n        # Create orders with different statuses\n        orders = [\n            Order(id=\"order_1\", status=\"preparing\", customer_name=\"Customer 1\"),\n            Order(id=\"order_2\", status=\"cooking\", customer_name=\"Customer 2\"),\n            Order(id=\"order_3\", status=\"ready\", customer_name=\"Customer 3\"),\n            Order(id=\"order_4\", status=\"delivered\", customer_name=\"Customer 4\")\n        ]\n\n        for order in orders:\n            await mock_file_repository.save_async(order)\n\n        # Get kitchen queue (preparing and cooking)\n        kitchen_orders = await mock_file_repository.get_kitchen_queue_async([\"preparing\", \"cooking\"])\n\n        assert len(kitchen_orders) == 2\n        statuses = [order.status for order in kitchen_orders]\n        assert \"preparing\" in statuses\n        assert \"cooking\" in statuses\n        assert \"ready\" not in statuses\n\n@pytest.mark.integration\nclass TestMongoOrderRepository:\n    \"\"\"Integration tests for MongoDB repository\"\"\"\n\n    @pytest.fixture\n    async def mongo_repository(self, mongo_test_client):\n        \"\"\"Create MongoDB repository for testing\"\"\"\n        database = mongo_test_client.test_pizzeria\n        return MongoOrderRepository(database)\n\n    @pytest.mark.asyncio\n    async def test_revenue_aggregation(self, mongo_repository):\n        \"\"\"Test MongoDB revenue aggregation pipeline\"\"\"\n        # Setup test data\n        test_orders = [\n            Order(\n                id=\"order_1\",\n                total_amount=Decimal(\"25.99\"),\n                status=\"delivered\",\n                order_time=datetime(2024, 1, 15, 12, 0)\n            ),\n            Order(\n                id=\"order_2\", \n                total_amount=Decimal(\"18.50\"),\n                status=\"delivered\",\n                order_time=datetime(2024, 1, 15, 18, 0)\n            ),\n            Order(\n                id=\"order_3\",\n                total_amount=Decimal(\"32.00\"),\n                status=\"preparing\",  # Should be excluded\n                order_time=datetime(2024, 1, 15, 19, 0)\n            )\n        ]\n\n        for order in test_orders:\n            await mongo_repository.save_async(order)\n\n        # Test daily revenue calculation\n        revenue_data = await mongo_repository.get_daily_revenue_async(date(2024, 1, 15))\n\n        assert revenue_data[\"total_revenue\"] == 44.49  # Only delivered orders\n        assert revenue_data[\"order_count\"] == 2\n        assert revenue_data[\"average_order_value\"] == 22.245\n\nclass TestEventRepository:\n    \"\"\"Test event repository for kitchen workflow tracking\"\"\"\n\n    @pytest.fixture\n    def sample_kitchen_events(self):\n        \"\"\"Create sample kitchen events for testing\"\"\"\n        return [\n            OrderStatusChangedEvent(\n                order_id=\"order_123\",\n                old_status=\"received\",\n                new_status=\"preparing\",\n                changed_by=\"chef_mario\"\n            ),\n            PizzaStartedEvent(\n                order_id=\"order_123\",\n                pizza_name=\"Margherita\",\n                pizza_index=0,\n                started_by=\"chef_mario\",\n                estimated_completion=datetime.utcnow() + timedelta(minutes=12)\n            )\n        ]\n\n    @pytest.mark.asyncio\n    async def test_event_chronological_ordering(self, file_event_repository, sample_kitchen_events):\n        \"\"\"Test that events are retrieved in chronological order\"\"\"\n        # Save events in random order\n        for event in reversed(sample_kitchen_events):\n            await file_event_repository.save_event_async(event)\n\n        # Retrieve events\n        today = date.today()\n        retrieved_events = await file_event_repository.get_events_by_date_range_async(today, today)\n\n        # Should be ordered by occurrence time\n        assert len(retrieved_events) == 2\n        assert retrieved_events[0].occurred_at &lt;= retrieved_events[1].occurred_at\n\n# Test fixtures for integration testing\n@pytest.fixture\nasync def mongo_test_client():\n    \"\"\"MongoDB test client with cleanup\"\"\"\n    from motor.motor_asyncio import AsyncIOMotorClient\n\n    client = AsyncIOMotorClient(\"mongodb://localhost:27017\")\n\n    # Use test database\n    test_db = client.test_pizzeria\n\n    yield client\n\n    # Cleanup\n    await client.drop_database(\"test_pizzeria\")\n    client.close()\n\n@pytest.fixture\ndef file_event_repository(tmp_path):\n    \"\"\"File event repository with temporary storage\"\"\"\n    return FileEventRepository(str(tmp_path / \"events\"))\n</code></pre>"},{"location":"features/data-access/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started Guide - Complete pizzeria application tutorial</li> <li>CQRS &amp; Mediation - Commands and queries with pizzeria examples  </li> <li>Dependency Injection - Service registration for repositories</li> <li>MVC Controllers - API endpoints using these repositories</li> </ul> <p>This documentation demonstrates data access patterns using Mario's Pizzeria as a consistent example throughout the Neuroglia framework. The patterns shown scale from simple file-based storage for development to MongoDB with advanced analytics for production use.</p>"},{"location":"features/dependency-injection/","title":"\ud83c\udf55 Dependency Injection","text":"<p>Neuroglia provides a lightweight, powerful dependency injection (DI) container that manages service registration, lifetime, and resolution for Mario's Pizzeria and any application built with the framework.</p> <p>Let's see how DI helps organize our pizzeria's services - from repositories that store orders to services that send notifications.</p>"},{"location":"features/dependency-injection/#overview","title":"\ud83c\udfaf Overview","text":"<p>The dependency injection system consists of:</p> <ul> <li>ServiceCollection: Registry for service definitions (our pizzeria's service catalog)</li> <li>ServiceProvider: Container for resolving and managing services (the kitchen that coordinates everything)</li> <li>ServiceLifetime: Controls when services are created and disposed (like kitchen equipment usage patterns)</li> <li>Enhanced Web Application Builder: Simplified registration with multi-app support</li> <li>Automatic Discovery: Services can be automatically discovered and registered</li> </ul>"},{"location":"features/dependency-injection/#service-lifetimes-in-marios-pizzeria","title":"\ud83c\udfd7\ufe0f Service Lifetimes in Mario's Pizzeria","text":""},{"location":"features/dependency-injection/#singleton-shared-equipment","title":"Singleton - Shared Equipment","text":"<p>Created once and reused for the entire pizzeria's lifetime:</p> <pre><code>from neuroglia.dependency_injection.service_provider import ServiceCollection\n\nservices = ServiceCollection()\n\n# Shared resources used by entire pizzeria\nservices.add_singleton(DatabaseConnection)      # Database connection pool\nservices.add_singleton(MenuCacheService)        # Menu data cached for all customers\nservices.add_singleton(KitchenDisplayService)   # Kitchen display board system\nservices.add_singleton(PaymentGateway)          # Payment processing service\nservices.add_singleton(SmsNotificationService) # SMS service for all notifications\n</code></pre> <p>Pizzeria Use Cases: - Database connection pools (shared by all operations) - Menu caching service (menu doesn't change often) - Kitchen display systems (one display board) - Payment gateway connections (shared across all transactions) - SMS/email notification services (one service instance)</p>"},{"location":"features/dependency-injection/#scoped-per-order-services","title":"Scoped - Per-Order Services","text":"<p>Created once per scope (typically per customer order or HTTP request):</p> <pre><code># Services that are specific to each order/request\nservices.add_scoped(OrderRepository)           # Order data access for this request\nservices.add_scoped(PizzeriaOrderService)      # Business logic for this order\nservices.add_scoped(CustomerContextService)    # Customer-specific context\nservices.add_scoped(KitchenWorkflowService)    # Kitchen operations for this order\n</code></pre> <p>Pizzeria Use Cases: - Order repositories (isolated data access per request) - Order processing services (specific to current order) - Customer context services (customer-specific data) - Kitchen workflow coordination (per-order cooking process) - Delivery routing services (per-order logistics)</p>"},{"location":"features/dependency-injection/#transient-per-use-tools","title":"Transient - Per-Use Tools","text":"<p>Created each time they are requested (like individual kitchen tools):</p> <pre><code># Services created fresh each time they're needed\nservices.add_transient(PizzaPriceCalculator)    # Calculate pricing for each pizza\nservices.add_transient(DeliveryTimeEstimator)   # Estimate delivery for each address\nservices.add_transient(LoyaltyPointsCalculator) # Calculate points for each transaction\nservices.add_transient(OrderValidator)          # Validate each order independently\n</code></pre> <ul> <li>Price calculations (fresh calculation each time)</li> <li>Delivery time estimations (stateless calculations)</li> <li>Order validation services (independent validation)</li> <li>Loyalty points calculators (stateless point calculations)</li> <li>Kitchen equipment status checkers (real-time status)</li> </ul>"},{"location":"features/dependency-injection/#registration-patterns-in-marios-pizzeria","title":"\ud83d\udd27 Registration Patterns in Mario's Pizzeria","text":""},{"location":"features/dependency-injection/#interface-and-implementation","title":"Interface and Implementation","text":"<p>Register pizzeria services by interface and implementation for flexibility:</p> <pre><code>from abc import ABC, abstractmethod\nfrom src.domain.order import Order\nfrom src.domain.pizza import Pizza\n\n# Order repository interface\nclass IOrderRepository(ABC):\n    @abstractmethod\n    async def save_async(self, order: Order) -&gt; None:\n        pass\n\n    @abstractmethod\n    async def get_by_id_async(self, order_id: str) -&gt; Optional[Order]:\n        pass\n\n    @abstractmethod\n    async def get_by_status_async(self, status: str) -&gt; List[Order]:\n        pass\n\n# File-based implementation for development\nclass FileOrderRepository(IOrderRepository):\n    def __init__(self, data_dir: str = \"data\"):\n        self.data_dir = Path(data_dir)\n        self.data_dir.mkdir(exist_ok=True)\n\n    async def save_async(self, order: Order) -&gt; None:\n        file_path = self.data_dir / f\"{order.id}.json\"\n        with open(file_path, 'w') as f:\n            json.dump(order.__dict__, f, default=str)\n\n# MongoDB implementation for production\nclass MongoOrderRepository(IOrderRepository):\n    def __init__(self, mongo_client: MongoClient):\n        self.collection = mongo_client.pizzeria.orders\n\n    async def save_async(self, order: Order) -&gt; None:\n        await self.collection.replace_one(\n            {\"_id\": order.id}, \n            order.__dict__, \n            upsert=True\n        )\n\n# Registration - swap implementations easily\nservices.add_scoped(IOrderRepository, FileOrderRepository)  # Development\n# services.add_scoped(IOrderRepository, MongoOrderRepository)  # Production\n</code></pre>"},{"location":"features/dependency-injection/#factory-functions-for-complex-services","title":"Factory Functions for Complex Services","text":"<p>Use factory functions for pizzeria services that need complex initialization:</p> <pre><code>def create_payment_gateway() -&gt; IPaymentGateway:\n    \"\"\"Create payment gateway with proper configuration\"\"\"\n    config = get_payment_config()\n\n    if config.environment == \"development\":\n        return MockPaymentGateway()\n    elif config.provider == \"stripe\":\n        return StripePaymentGateway(config.stripe_api_key)\n    else:\n        return SquarePaymentGateway(config.square_token)\n\ndef create_sms_service() -&gt; ISmsService:\n    \"\"\"Create SMS service with proper credentials\"\"\"\n    settings = get_app_settings()\n\n    return TwilioSmsService(\n        account_sid=settings.twilio_sid,\n        auth_token=settings.twilio_token,\n        from_number=settings.pizzeria_phone\n    )\n\n# Register with factories\nservices.add_singleton(IPaymentGateway, factory=create_payment_gateway)\nservices.add_singleton(ISmsService, factory=create_sms_service)\n</code></pre> <pre><code>from typing import TypeVar, Generic\nfrom neuroglia.data.abstractions import Repository\n\nT = TypeVar('T')\nTKey = TypeVar('TKey')\n\nclass FileRepository(Repository[T, TKey], Generic[T, TKey]):\n    \"\"\"Generic file-based repository for any entity type\"\"\"\n\n    def __init__(self, entity_type: type, data_dir: str = \"data\"):\n        self.entity_type = entity_type\n        self.data_dir = Path(data_dir) / entity_type.__name__.lower()\n        self.data_dir.mkdir(parents=True, exist_ok=True)\n\n# Register repositories for different pizzeria entities\nservices.add_scoped(lambda: FileRepository(Pizza, \"data\"))\nservices.add_scoped(lambda: FileRepository(Order, \"data\"))\nservices.add_scoped(lambda: FileRepository(Customer, \"data\"))\n\n# Or with factory functions for cleaner registration\ndef create_pizza_repository() -&gt; Repository[Pizza, str]:\n    return FileRepository(Pizza, \"data\")\n\ndef create_order_repository() -&gt; Repository[Order, str]:\n    return FileRepository(Order, \"data\")\n\nservices.add_scoped(Repository[Pizza, str], factory=create_pizza_repository)\nservices.add_scoped(Repository[Order, str], factory=create_order_repository)\n</code></pre>"},{"location":"features/dependency-injection/#enhanced-web-application-builder","title":"\ud83d\udd0d Enhanced Web Application Builder","text":"<p>The enhanced builder simplifies service registration for pizzeria applications:</p> <pre><code>from neuroglia.hosting import EnhancedWebApplicationBuilder\nfrom neuroglia.mediation import Mediator\nfrom neuroglia.mapping import Mapper\n\ndef create_pizzeria_app():\n    \"\"\"Create Mario's Pizzeria application with enhanced builder\"\"\"\n\n    # Create enhanced builder with multi-app support\n    builder = EnhancedWebApplicationBuilder()\n\n    # === Repository Layer ===\n    # File-based repositories for development\n    builder.services.add_scoped(lambda: FileRepository(Pizza, \"data\"))\n    builder.services.add_scoped(lambda: FileRepository(Order, \"data\"))\n    builder.services.add_scoped(lambda: FileRepository(Customer, \"data\"))\n\n    # === Application Services ===\n    builder.services.add_scoped(PizzeriaOrderService)\n    builder.services.add_scoped(KitchenManagementService)\n    builder.services.add_scoped(CustomerLoyaltyService)\n    builder.services.add_scoped(DeliveryCoordinationService)\n\n    # === Infrastructure Services ===\n    builder.services.add_singleton(IPaymentGateway, factory=create_payment_gateway)\n    builder.services.add_singleton(ISmsService, factory=create_sms_service)\n    builder.services.add_singleton(MenuCacheService)\n    builder.services.add_singleton(KitchenDisplayService)\n\n    # === Transient Services ===\n    builder.services.add_transient(PizzaPriceCalculator)\n    builder.services.add_transient(DeliveryTimeEstimator)\n    builder.services.add_transient(OrderValidator)\n\n    # === Configure Core Framework Services ===\n    Mediator.configure(builder, [\"src.application\"])\n    Mapper.configure(builder, [\"src\"])\n\n    # === Add Controllers with API Prefix ===\n    builder.add_controllers_with_prefix(\"src.api.controllers\", \"/api\")\n\n    # === OAuth Configuration ===\n    builder.configure_oauth({\n        \"orders:read\": \"Read order information\",\n        \"orders:write\": \"Create and modify orders\", \n        \"kitchen:manage\": \"Manage kitchen operations\",\n        \"admin\": \"Full administrative access\"\n    })\n\n    # === Build Application ===\n    app = builder.build()\n\n    # === Configure Middleware ===\n    app.use_cors()\n    app.use_swagger_ui()\n    app.use_controllers()\n\n    return app\n</code></pre>"},{"location":"features/dependency-injection/#automatic-service-discovery","title":"\ud83d\udd0d Automatic Service Discovery","text":"<p>Neuroglia can automatically discover and register pizzeria services based on conventions:</p>"},{"location":"features/dependency-injection/#module-based-discovery-for-pizzeria","title":"Module-Based Discovery for Pizzeria","text":"<pre><code>from neuroglia.hosting import EnhancedWebApplicationBuilder\n\nbuilder = EnhancedWebApplicationBuilder()\n\n# Automatically discover and register pizzeria services in modules\nbuilder.services.discover_services([\n    \"src.application.services\",      # PizzeriaOrderService, KitchenManagementService\n    \"src.infrastructure.repositories\", # FileOrderRepository, MongoPizzaRepository  \n    \"src.infrastructure.services\",    # TwilioSmsService, StripePaymentGateway\n    \"src.application.handlers\"        # Command and query handlers\n])\n</code></pre>"},{"location":"features/dependency-injection/#attribute-based-registration","title":"Attribute-Based Registration","text":"<p>Use decorators to mark pizzeria services for automatic registration:</p> <pre><code>from neuroglia.dependency_injection import service, ServiceLifetime\n\n# Service decorator automatically registers the class\n@service(ServiceLifetime.SCOPED)\nclass PizzeriaOrderService:\n    \"\"\"Handles pizza order business logic\"\"\"\n\n    def __init__(self, \n                 order_repository: Repository[Order, str],\n                 pizza_repository: Repository[Pizza, str],\n                 notification_service: ISmsService):\n        self.order_repository = order_repository\n        self.pizza_repository = pizza_repository\n        self.notification_service = notification_service\n\n@service(ServiceLifetime.SINGLETON) \nclass MenuCacheService:\n    \"\"\"Caches menu data for fast retrieval\"\"\"\n\n    def __init__(self):\n        self._cache = {}\n        self._cache_expiry = None\n\n@service(ServiceLifetime.TRANSIENT)\nclass PizzaPriceCalculator:\n    \"\"\"Calculates pizza pricing with toppings\"\"\"\n\n    def calculate_total_price(self, pizza: Pizza) -&gt; Decimal:\n        base_price = self._get_size_price(pizza.base_price, pizza.size)\n        toppings_price = Decimal(\"1.50\") * len(pizza.toppings)\n        return base_price + toppings_price\n</code></pre> <pre><code>from neuroglia.dependency_injection import service, ServiceLifetime\n\n# Automatically register notification service implementation\n@service(interface=INotificationService, lifetime=ServiceLifetime.SINGLETON)\nclass TwilioSmsService(INotificationService):\n    \"\"\"SMS notifications via Twilio\"\"\"\n\n    def __init__(self):\n        self.client = self._create_twilio_client()\n\n    async def send_order_confirmation(self, phone: str, order_id: str, ready_time: datetime):\n        message = f\"Order {order_id[:8]} confirmed! Ready by {ready_time.strftime('%H:%M')}\"\n        await self._send_sms(phone, message)\n\n# Automatically register repository implementation  \n@service(interface=IOrderRepository, lifetime=ServiceLifetime.SCOPED)\nclass FileOrderRepository(IOrderRepository):\n    \"\"\"File-based order storage for development\"\"\"\n\n    def __init__(self):\n        self.data_dir = Path(\"data/orders\")\n        self.data_dir.mkdir(parents=True, exist_ok=True)\n\n# The framework automatically wires these together\n@service(lifetime=ServiceLifetime.SCOPED)\nclass PizzeriaOrderService:\n    \"\"\"High-level order processing service\"\"\"\n\n    def __init__(self, \n                 order_repository: IOrderRepository,      # Gets FileOrderRepository\n                 notification_service: INotificationService): # Gets TwilioSmsService\n        self.order_repository = order_repository\n        self.notification_service = notification_service\n</code></pre>"},{"location":"features/dependency-injection/#service-resolution-in-marios-pizzeria","title":"\ud83d\udd04 Service Resolution in Mario's Pizzeria","text":""},{"location":"features/dependency-injection/#manual-resolution-for-advanced-scenarios","title":"Manual Resolution for Advanced Scenarios","text":"<pre><code># Build the service provider\nprovider = services.build_service_provider()\n\n# Resolve pizzeria services manually when needed\norder_service = provider.get_required_service(PizzeriaOrderService)\npayment_gateway = provider.get_service(IPaymentGateway)  # Returns None if not registered\n\n# Get all implementations (useful for plugin architectures)\nall_repositories = provider.get_services(IRepository)  # All repository implementations\nall_calculators = provider.get_services(IPriceCalculator)  # Different pricing strategies\n</code></pre> <p>Services are automatically injected into pizzeria controller constructors:</p> <pre><code>from neuroglia.mvc import ControllerBase\nfrom classy_fastapi.decorators import get, post\n\nclass OrdersController(ControllerBase):\n    \"\"\"Pizza orders API controller with dependency injection\"\"\"\n\n    def __init__(self, \n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator,\n                 order_service: PizzeriaOrderService,        # Automatically injected\n                 payment_service: IPaymentGateway,           # Automatically injected  \n                 notification_service: INotificationService): # Automatically injected\n        super().__init__(service_provider, mapper, mediator)\n        self.order_service = order_service\n        self.payment_service = payment_service\n        self.notification_service = notification_service\n\n    @post(\"/\", response_model=dict, status_code=201)\n    async def place_order(self, order_data: dict) -&gt; dict:\n        # All services are ready to use\n        result = await self.order_service.process_order_async(order_data)\n        return self.process(result)\n\nclass KitchenController(ControllerBase):\n    \"\"\"Kitchen operations controller\"\"\"\n\n    def __init__(self,\n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper, \n                 mediator: Mediator,\n                 kitchen_service: KitchenManagementService,  # Automatically injected\n                 display_service: KitchenDisplayService):    # Automatically injected\n        super().__init__(service_provider, mapper, mediator)\n        self.kitchen_service = kitchen_service\n        self.display_service = display_service\n</code></pre>"},{"location":"features/dependency-injection/#property-injection-for-optional-dependencies","title":"Property Injection for Optional Dependencies","text":"<p>Access optional services through the service provider:</p> <pre><code>class PizzeriaAnalyticsService:\n    \"\"\"Analytics service with optional dependencies\"\"\"\n\n    def __init__(self, \n                 service_provider: ServiceProviderBase,\n                 order_repository: Repository[Order, str]):  # Required dependency\n        self.service_provider = service_provider\n        self.order_repository = order_repository\n\n    async def generate_daily_report(self) -&gt; dict:\n        # Required service - injected via constructor\n        orders = await self.order_repository.get_by_date_range_async(date.today(), date.today())\n\n        # Optional service - resolved when needed\n        email_service = self.service_provider.get_service(IEmailService)\n        if email_service:\n            await email_service.send_daily_report(self._build_report(orders))\n\n        # Another optional service\n        slack_service = self.service_provider.get_service(ISlackService) \n        if slack_service:\n            await slack_service.post_daily_summary(orders)\n\n        return self._build_report(orders)\n</code></pre>"},{"location":"features/dependency-injection/#advanced-patterns","title":"\ud83c\udfad Advanced Patterns","text":""},{"location":"features/dependency-injection/#service-locator-for-cross-cutting-concerns","title":"Service Locator for Cross-Cutting Concerns","text":"<pre><code>class PizzeriaServiceLocator:\n    \"\"\"Service locator for pizzeria-wide services\"\"\"\n\n    _provider: ServiceProviderBase = None\n\n    @classmethod\n    def configure(cls, provider: ServiceProviderBase):\n        cls._provider = provider\n\n    @classmethod\n    def get_notification_service(cls) -&gt; INotificationService:\n        return cls._provider.get_required_service(INotificationService)\n\n    @classmethod\n    def get_cache_service(cls) -&gt; MenuCacheService:\n        return cls._provider.get_required_service(MenuCacheService)\n\n# Usage in domain events\nclass OrderPlacedEvent(DomainEvent):\n    async def notify_kitchen(self):\n        notification_service = PizzeriaServiceLocator.get_notification_service()\n        await notification_service.notify_kitchen_staff(f\"New order: {self.order_id}\")\n</code></pre> <pre><code>def configure_pizzeria_services(builder: EnhancedWebApplicationBuilder, environment: str):\n    \"\"\"Configure services based on pizzeria environment\"\"\"\n\n    if environment == \"development\":\n        # Development services\n        builder.services.add_scoped(IOrderRepository, FileOrderRepository)\n        builder.services.add_scoped(IPizzaRepository, FileRepository)\n        builder.services.add_singleton(IPaymentGateway, MockPaymentGateway)\n        builder.services.add_singleton(ICacheService, MemoryCacheService)\n        builder.services.add_singleton(INotificationService, ConsoleNotificationService)\n\n    elif environment == \"production\":\n        # Production services  \n        builder.services.add_scoped(IOrderRepository, MongoOrderRepository)\n        builder.services.add_scoped(IPizzaRepository, MongoPizzaRepository)\n        builder.services.add_singleton(IPaymentGateway, factory=create_stripe_gateway)\n        builder.services.add_singleton(ICacheService, RedisCacheService)\n        builder.services.add_singleton(INotificationService, TwilioSmsService)\n\n    elif environment == \"testing\":\n        # Testing services\n        builder.services.add_scoped(IOrderRepository, InMemoryOrderRepository)\n        builder.services.add_scoped(IPizzaRepository, InMemoryPizzaRepository)\n        builder.services.add_singleton(IPaymentGateway, MockPaymentGateway)\n        builder.services.add_singleton(ICacheService, NoOpCacheService)\n        builder.services.add_singleton(INotificationService, MockNotificationService)\n\n# Usage\nconfigure_pizzeria_services(builder, os.getenv(\"PIZZERIA_ENVIRONMENT\", \"development\"))\n</code></pre>"},{"location":"features/dependency-injection/#service-decoration-for-cross-cutting-concerns","title":"Service Decoration for Cross-Cutting Concerns","text":"<p>Wrap pizzeria services with additional behavior like logging, caching, or monitoring:</p> <pre><code>class LoggingOrderService(IOrderService):\n    \"\"\"Decorates order service with logging\"\"\"\n\n    def __init__(self, inner: IOrderService, logger: logging.Logger):\n        self.inner = inner\n        self.logger = logger\n\n    async def process_order_async(self, order_data: dict) -&gt; OperationResult:\n        order_id = order_data.get(\"temp_id\", \"unknown\")\n        self.logger.info(f\"Processing order {order_id} for {order_data.get('customer_name')}\")\n\n        start_time = time.time()\n        try:\n            result = await self.inner.process_order_async(order_data)\n            duration = time.time() - start_time\n\n            if result.is_success:\n                self.logger.info(f\"Order {order_id} processed successfully in {duration:.2f}s\")\n            else:\n                self.logger.warning(f\"Order {order_id} processing failed: {result.error_message}\")\n\n            return result\n        except Exception as ex:\n            duration = time.time() - start_time\n            self.logger.error(f\"Order {order_id} processing error in {duration:.2f}s: {ex}\")\n            raise\n\nclass CachingMenuService(IMenuService):\n    \"\"\"Decorates menu service with caching\"\"\"\n\n    def __init__(self, inner: IMenuService, cache: ICacheService):\n        self.inner = inner\n        self.cache = cache\n\n    async def get_menu_async(self, category: Optional[str] = None) -&gt; List[dict]:\n        cache_key = f\"menu:{category or 'all'}\"\n\n        # Check cache first\n        cached_menu = await self.cache.get_async(cache_key)\n        if cached_menu:\n            return cached_menu\n\n        # Get from inner service and cache result\n        menu = await self.inner.get_menu_async(category)\n        await self.cache.set_async(cache_key, menu, expire_minutes=30)\n\n        return menu\n\n# Registration with decoration\ndef configure_decorated_services(builder: EnhancedWebApplicationBuilder):\n    # Register base services\n    builder.services.add_scoped(PizzeriaOrderService)\n    builder.services.add_scoped(MenuService)\n\n    # Add decorations\n    builder.services.decorate(IOrderService, LoggingOrderService)\n    builder.services.decorate(IMenuService, CachingMenuService)\n\n    # The container will resolve: LoggingOrderService -&gt; PizzeriaOrderService\n    # And: CachingMenuService -&gt; MenuService\n</code></pre> <pre><code>from abc import ABC, abstractmethod\n\nclass IPizzeriaPlugin(ABC):\n    \"\"\"Interface for pizzeria plugins\"\"\"\n\n    @abstractmethod\n    def configure_services(self, services: ServiceCollection) -&gt; None:\n        pass\n\nclass DeliveryPlugin(IPizzeriaPlugin):\n    \"\"\"Plugin for delivery services\"\"\"\n\n    def configure_services(self, services: ServiceCollection) -&gt; None:\n        services.add_scoped(DeliveryService)\n        services.add_scoped(DeliveryRouteCalculator)\n        services.add_singleton(DeliveryTrackingService)\n\nclass LoyaltyPlugin(IPizzeriaPlugin):\n    \"\"\"Plugin for loyalty program\"\"\"\n\n    def configure_services(self, services: ServiceCollection) -&gt; None:\n        services.add_scoped(LoyaltyService)\n        services.add_scoped(RewardsCalculator)\n        services.add_singleton(LoyaltyCardService)\n\ndef configure_plugins(builder: EnhancedWebApplicationBuilder, enabled_plugins: List[str]):\n    \"\"\"Configure enabled plugins\"\"\"\n\n    available_plugins = {\n        \"delivery\": DeliveryPlugin(),\n        \"loyalty\": LoyaltyPlugin(),\n        \"analytics\": AnalyticsPlugin()\n    }\n\n    for plugin_name in enabled_plugins:\n        if plugin_name in available_plugins:\n            plugin = available_plugins[plugin_name]\n            plugin.configure_services(builder.services)\n\n# Usage\nenabled_features = [\"delivery\", \"loyalty\"]  # From configuration\nconfigure_plugins(builder, enabled_features)\n</code></pre>"},{"location":"features/dependency-injection/#configuration-integration","title":"\ud83d\udd27 Configuration Integration","text":"<pre><code>from dataclasses import dataclass\nfrom decimal import Decimal\n\n@dataclass\nclass PizzeriaConfig:\n    \"\"\"Main pizzeria configuration\"\"\"\n    name: str\n    phone: str\n    address: str\n    opening_hours: dict\n    delivery_radius_km: float\n\n@dataclass\nclass PaymentConfig:\n    \"\"\"Payment processing configuration\"\"\"\n    stripe_api_key: str\n    square_token: str\n    enable_cash: bool\n    enable_card: bool\n\n@dataclass \nclass NotificationConfig:\n    \"\"\"Notification service configuration\"\"\"\n    twilio_sid: str\n    twilio_token: str\n    from_phone: str\n    enable_sms: bool\n    enable_email: bool\n\n@dataclass\nclass MenuConfig:\n    \"\"\"Menu and pricing configuration\"\"\"\n    base_pizza_price: Decimal\n    topping_price: Decimal\n    size_multipliers: dict\n    tax_rate: Decimal\n\n# Register configurations\nservices.configure(PizzeriaConfig, app_settings.pizzeria)\nservices.configure(PaymentConfig, app_settings.payment)\nservices.configure(NotificationConfig, app_settings.notifications)\nservices.configure(MenuConfig, app_settings.menu)\n\n# Use in services\nclass PizzaPriceCalculator:\n    def __init__(self, menu_config: MenuConfig):\n        self.menu_config = menu_config\n\n    def calculate_pizza_price(self, pizza: Pizza) -&gt; Decimal:\n        base_price = self.menu_config.base_pizza_price\n        size_multiplier = self.menu_config.size_multipliers.get(pizza.size, 1.0)\n        topping_cost = len(pizza.toppings) * self.menu_config.topping_price\n\n        subtotal = (base_price * Decimal(str(size_multiplier))) + topping_cost\n        tax = subtotal * self.menu_config.tax_rate\n\n        return subtotal + tax\n</code></pre>"},{"location":"features/dependency-injection/#options-pattern-for-dynamic-configuration","title":"Options Pattern for Dynamic Configuration","text":"<p>Use the options pattern for configuration that can change at runtime:</p> <pre><code>from neuroglia.configuration import IOptions\n\nclass KitchenManagementService:\n    \"\"\"Kitchen service with configurable options\"\"\"\n\n    def __init__(self, \n                 pizzeria_options: IOptions[PizzeriaConfig],\n                 menu_options: IOptions[MenuConfig]):\n        self.pizzeria_config = pizzeria_options.value\n        self.menu_config = menu_options.value\n\n    async def check_if_within_hours(self) -&gt; bool:\n        current_hour = datetime.now().hour\n        opening_hours = self.pizzeria_config.opening_hours\n\n        return opening_hours[\"open\"] &lt;= current_hour &lt;= opening_hours[\"close\"]\n\n    async def get_max_prep_time(self) -&gt; int:\n        \"\"\"Get maximum preparation time based on current kitchen load\"\"\"\n        # Options can be refreshed from configuration store\n        base_time = self.menu_config.base_prep_time_minutes\n        return base_time  # Could be dynamically adjusted\n</code></pre>"},{"location":"features/dependency-injection/#testing-with-dependency-injection","title":"\ud83e\uddea Testing with Dependency Injection","text":""},{"location":"features/dependency-injection/#unit-testing-with-mocks","title":"Unit Testing with Mocks","text":"<p>Test pizzeria services in isolation using mocks:</p> <pre><code>import pytest\nfrom unittest.mock import Mock, AsyncMock\nfrom src.application.services.pizzeria_order_service import PizzeriaOrderService\nfrom src.domain.order import Order\n\n@pytest.fixture\ndef mock_order_repository():\n    repository = Mock()\n    repository.save_async = AsyncMock()\n    repository.get_by_id_async = AsyncMock()\n    return repository\n\n@pytest.fixture\ndef mock_notification_service():\n    service = Mock()\n    service.send_order_confirmation = AsyncMock()\n    return service\n\n@pytest.mark.asyncio\nasync def test_order_service_processes_order_successfully(\n    mock_order_repository,\n    mock_notification_service\n):\n    # Arrange\n    order_service = PizzeriaOrderService(\n        order_repository=mock_order_repository,\n        notification_service=mock_notification_service\n    )\n\n    order_data = {\n        \"customer_name\": \"John Doe\",\n        \"customer_phone\": \"555-0123\",\n        \"pizza_items\": [{\"pizza_id\": \"margherita\", \"size\": \"large\"}]\n    }\n\n    # Act\n    result = await order_service.process_order_async(order_data)\n\n    # Assert\n    assert result.is_success\n    mock_order_repository.save_async.assert_called_once()\n    mock_notification_service.send_order_confirmation.assert_called_once()\n</code></pre>"},{"location":"features/dependency-injection/#integration-testing-with-test-container","title":"Integration Testing with Test Container","text":"<p>Test with a real service container for integration tests:</p> <pre><code>@pytest.fixture\ndef test_service_provider():\n    \"\"\"Create service provider for integration tests\"\"\"\n\n    services = ServiceCollection()\n\n    # Use in-memory implementations for testing\n    services.add_scoped(IOrderRepository, InMemoryOrderRepository)\n    services.add_scoped(IPizzaRepository, InMemoryPizzaRepository)\n    services.add_singleton(INotificationService, MockNotificationService)\n\n    # Real services\n    services.add_scoped(PizzeriaOrderService)\n    services.add_scoped(KitchenManagementService)\n\n    return services.build_service_provider()\n\n@pytest.mark.asyncio\nasync def test_complete_order_workflow(test_service_provider):\n    \"\"\"Test complete order workflow with real services\"\"\"\n\n    # Get services from container\n    order_service = test_service_provider.get_required_service(PizzeriaOrderService)\n    kitchen_service = test_service_provider.get_required_service(KitchenManagementService)\n\n    # Test complete workflow\n    order_result = await order_service.process_order_async(sample_order_data)\n    assert order_result.is_success\n\n    # Start cooking\n    cooking_result = await kitchen_service.start_cooking_async(order_result.data[\"order_id\"])\n    assert cooking_result.is_success\n</code></pre>"},{"location":"features/dependency-injection/#best-practices","title":"\ud83d\ude80 Best Practices","text":""},{"location":"features/dependency-injection/#1-prefer-constructor-injection","title":"1. Prefer Constructor Injection","text":"<p>Always use constructor injection for required dependencies:</p> <pre><code># \u2705 Good - Constructor injection\nclass OrderService:\n    def __init__(self, \n                 order_repository: IOrderRepository,\n                 notification_service: INotificationService):\n        self.order_repository = order_repository\n        self.notification_service = notification_service\n\n# \u274c Avoid - Service locator pattern  \nclass OrderService:\n    def process_order(self):\n        repository = ServiceLocator.get_service(IOrderRepository)  # Hard to test\n</code></pre>"},{"location":"features/dependency-injection/#2-use-appropriate-lifetimes","title":"2. Use Appropriate Lifetimes","text":"<p>Choose service lifetimes based on usage patterns:</p> <pre><code># \u2705 Singleton for expensive, stateless services\nservices.add_singleton(PaymentGateway)        # Expensive to create\nservices.add_singleton(MenuCacheService)      # Shared state\n\n# \u2705 Scoped for request-specific services  \nservices.add_scoped(OrderRepository)          # Per-request data access\nservices.add_scoped(CustomerContextService)   # Request-specific context\n\n# \u2705 Transient for lightweight, stateless services\nservices.add_transient(PizzaPriceCalculator)  # Stateless calculations\nservices.add_transient(OrderValidator)        # Pure validation logic\n</code></pre>"},{"location":"features/dependency-injection/#3-avoid-service-location","title":"3. Avoid Service Location","text":"<p>Don't use the service provider directly in business logic:</p> <pre><code># \u274c Avoid - Direct service provider usage\nclass OrderService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.service_provider = service_provider\n\n    def process_order(self, order_data):\n        # This makes testing difficult and hides dependencies\n        payment_service = self.service_provider.get_service(IPaymentService)\n\n# \u2705 Good - Explicit dependencies\nclass OrderService:\n    def __init__(self, \n                 order_repository: IOrderRepository,\n                 payment_service: IPaymentService):  # Clear dependencies\n        self.order_repository = order_repository\n        self.payment_service = payment_service\n</code></pre>"},{"location":"features/dependency-injection/#key-benefits","title":"\ud83c\udfaf Key Benefits","text":"<p>Using Neuroglia's DI container in Mario's Pizzeria provides:</p> <p>\u2705 Loose Coupling - Services depend on interfaces, not concrete implementations \u2705 Easy Testing - Mock dependencies for isolated unit tests \u2705 Configuration Flexibility - Swap implementations for different environments \u2705 Automatic Lifetime Management - Framework handles object creation and disposal \u2705 Enhanced Web Application Builder - Simplified setup with multi-app support \u2705 Type Safety - Full type checking and IntelliSense support  </p>"},{"location":"features/dependency-injection/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Build Mario's Pizzeria with DI from the start</li> <li>CQRS &amp; Mediation - How handlers are resolved through DI</li> <li>MVC Controllers - Controller dependency injection patterns  </li> <li>Data Access - Repository pattern and DI integration         if self.options.send_welcome_emails:             # Send email logic             pass <pre><code>## \ud83e\uddea Testing with DI\n\n### Test Service Registration\n\nOverride services for testing:\n\n```python\nimport pytest\nfrom neuroglia.dependency_injection import ServiceCollection\n\n@pytest.fixture\ndef test_services():\n    services = ServiceCollection()\n\n    # Register test implementations\n    services.add_singleton(IUserRepository, InMemoryUserRepository)\n    services.add_singleton(IEmailService, MockEmailService)\n\n    return services.build_service_provider()\n\ndef test_user_creation(test_services):\n    user_service = test_services.get_required_service(UserService)\n    result = user_service.create_user(user_data)\n    assert result.is_success\n</code></pre></li> </ul>"},{"location":"features/dependency-injection/#mock-dependencies","title":"Mock Dependencies","text":"<p>Use mocking frameworks with DI:</p> <pre><code>from unittest.mock import Mock\n\ndef test_user_service_with_mocks():\n    # Arrange\n    mock_repo = Mock(spec=IUserRepository)\n    mock_repo.add_async.return_value = test_user\n\n    services = ServiceCollection()\n    services.add_instance(IUserRepository, mock_repo)\n    provider = services.build_service_provider()\n\n    # Act\n    user_service = provider.get_required_service(UserService)\n    result = await user_service.create_user(user_data)\n\n    # Assert\n    mock_repo.add_async.assert_called_once()\n    assert result.email == test_user.email\n</code></pre>"},{"location":"features/dependency-injection/#framework-integration","title":"\ud83c\udfaa Framework Integration","text":""},{"location":"features/dependency-injection/#web-application-builder","title":"Web Application Builder","text":"<p>The WebApplicationBuilder provides convenient methods for service registration:</p> <pre><code>from neuroglia.hosting.web import WebApplicationBuilder\n\nbuilder = WebApplicationBuilder()\n\n# Configure framework services\nbuilder.services.add_mediation([\"application\"])\nbuilder.services.add_mapping([\"application\", \"domain\"])\nbuilder.services.add_repositories([\"integration.repositories\"])\n\n# Add custom services\nbuilder.services.add_scoped(UserService)\nbuilder.services.add_singleton(EmailService)\n\napp = builder.build()\n</code></pre>"},{"location":"features/dependency-injection/#controller-dependencies","title":"Controller Dependencies","text":"<p>Controllers automatically receive dependencies:</p> <pre><code>class UsersController(ControllerBase):\n    def __init__(self, \n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator,\n                 user_service: UserService,\n                 email_service: EmailService):\n        super().__init__(service_provider, mapper, mediator)\n        self.user_service = user_service\n        self.email_service = email_service\n</code></pre>"},{"location":"features/dependency-injection/#middleware-dependencies","title":"Middleware Dependencies","text":"<p>Middleware can also use dependency injection:</p> <pre><code>class AuthenticationMiddleware:\n    def __init__(self, auth_service: IAuthService):\n        self.auth_service = auth_service\n\n    async def __call__(self, request: Request, call_next):\n        # Use auth_service for authentication logic\n        pass\n</code></pre>"},{"location":"features/dependency-injection/#best-practices_1","title":"\ud83d\ude80 Best Practices","text":""},{"location":"features/dependency-injection/#1-register-by-interface","title":"1. Register by Interface","text":"<p>Always register services by their interface when possible:</p> <pre><code># Good\nservices.add_scoped(IUserRepository, MongoUserRepository)\n\n# Avoid\nservices.add_scoped(MongoUserRepository)\n</code></pre>"},{"location":"features/dependency-injection/#2-use-appropriate-lifetimes_1","title":"2. Use Appropriate Lifetimes","text":"<p>Choose the correct lifetime for your services:</p> <ul> <li>Singleton: Expensive to create, stateless, or application-wide</li> <li>Scoped: Request-specific, maintains state during request</li> <li>Transient: Lightweight, stateless, or disposable</li> </ul>"},{"location":"features/dependency-injection/#3-avoid-service-locator","title":"3. Avoid Service Locator","text":"<p>Prefer constructor injection over service locator:</p> <pre><code># Good - Constructor injection\nclass UserService:\n    def __init__(self, user_repository: IUserRepository):\n        self.user_repository = user_repository\n\n# Avoid - Service locator\nclass UserService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.service_provider = service_provider\n\n    def some_method(self):\n        repo = self.service_provider.get_required_service(IUserRepository)\n</code></pre>"},{"location":"features/dependency-injection/#4-validate-dependencies","title":"4. Validate Dependencies","text":"<p>Ensure all required dependencies are registered:</p> <pre><code>def validate_services(provider: ServiceProviderBase):\n    \"\"\"Validate that all required services are registered\"\"\"\n    required_services = [IUserRepository, IEmailService, ICacheService]\n\n    for service_type in required_services:\n        service = provider.get_service(service_type)\n        if service is None:\n            raise ValueError(f\"Required service {service_type} not registered\")\n</code></pre>"},{"location":"features/dependency-injection/#5-use-factories-for-complex-objects","title":"5. Use Factories for Complex Objects","text":"<p>Use factory functions for services that need complex initialization:</p> <pre><code>def create_user_repository(provider: ServiceProviderBase) -&gt; IUserRepository:\n    config = provider.get_required_service(DatabaseConfig)\n    connection = provider.get_required_service(DatabaseConnection)\n\n    if config.use_caching:\n        cache = provider.get_required_service(ICacheService)\n        return CachedUserRepository(connection, cache)\n    else:\n        return UserRepository(connection)\n\nservices.add_scoped(IUserRepository, factory=create_user_repository)\n</code></pre>"},{"location":"features/dependency-injection/#related-documentation_1","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Basic DI usage</li> <li>Architecture Guide - How DI fits in the architecture</li> <li>CQRS &amp; Mediation - DI with command handlers</li> <li>Data Access - DI with repositories</li> <li>Testing - Testing with dependency injection</li> </ul>"},{"location":"features/event-sourcing/","title":"\ud83c\udfaf Event Sourcing","text":"<p>Event Sourcing is a data storage pattern where state changes are stored as a sequence of immutable events rather than updating data in place. Neuroglia provides comprehensive event sourcing support with EventStoreDB integration, aggregate root patterns, and event-driven projections.</p>"},{"location":"features/event-sourcing/#overview","title":"\ud83c\udfaf Overview","text":"<p>Event Sourcing offers several key benefits:</p> <ul> <li>Complete Audit Trail: Every state change is captured as an immutable event</li> <li>Temporal Queries: Query system state at any point in time</li> <li>Event Replay: Reconstruct current state by replaying events</li> <li>Business Intelligence: Analyze patterns and trends from event streams</li> <li>Debugging: Full visibility into how state changes occurred</li> <li>Scalability: Events can be replayed to create optimized read models</li> </ul>"},{"location":"features/event-sourcing/#core-concepts","title":"\ud83c\udfd7\ufe0f Core Concepts","text":""},{"location":"features/event-sourcing/#events-as-source-of-truth","title":"Events as Source of Truth","text":"<p>In traditional systems, current state is stored directly:</p> <pre><code># Traditional approach - current state only\nclass BankAccount:\n    def __init__(self, id: str, balance: Decimal):\n        self.id = id\n        self.balance = balance  # Current state stored directly\n\n    def withdraw(self, amount: Decimal):\n        self.balance -= amount  # State updated in place\n</code></pre> <p>With Event Sourcing, we store the events that led to the current state:</p> <pre><code># Event Sourcing approach - events as source of truth\nclass BankAccountCreatedEvent(DomainEvent[str]):\n    def __init__(self, account_id: str, initial_balance: Decimal):\n        super().__init__(account_id)\n        self.initial_balance = initial_balance\n\nclass MoneyWithdrawnEvent(DomainEvent[str]):\n    def __init__(self, account_id: str, amount: Decimal):\n        super().__init__(account_id)\n        self.amount = amount\n\nclass BankAccount(AggregateRoot[BankAccountState, str]):\n    def __init__(self, id: str, initial_balance: Decimal):\n        super().__init__()\n        self.state.on(self.register_event(BankAccountCreatedEvent(id, initial_balance)))\n\n    def withdraw(self, amount: Decimal):\n        if self.state.balance &lt; amount:\n            raise InsufficientFundsException()\n        self.state.on(self.register_event(MoneyWithdrawnEvent(self.state.id, amount)))\n</code></pre>"},{"location":"features/event-sourcing/#state-reconstruction-from-events","title":"State Reconstruction from Events","text":"<p>Current state is derived by applying events in sequence using the <code>@dispatch</code> decorator:</p> <pre><code>from neuroglia.data.abstractions import AggregateRoot, DomainEvent\nfrom neuroglia.mapping.mapper import map_to\nfrom decimal import Decimal\nfrom multipledispatch import dispatch\n\nclass BankAccountCreatedDomainEventV1(DomainEvent[str]):\n    def __init__(self, aggregate_id: str, owner_id: str, overdraft_limit: Decimal):\n        super().__init__(aggregate_id)\n        self.owner_id = owner_id\n        self.overdraft_limit = overdraft_limit\n\nclass BankAccountTransactionRecordedDomainEventV1(DomainEvent[str]):\n    def __init__(self, aggregate_id: str, transaction_id: str, amount: Decimal):\n        super().__init__(aggregate_id)\n        self.transaction_id = transaction_id\n        self.amount = amount\n\nclass BankAccountV1(AggregateRoot[str]):\n    def __init__(self, account_id: str = None):\n        super().__init__(account_id)\n        self._balance = Decimal('0.00')\n        self._owner_id = \"\"\n        self._overdraft_limit = Decimal('0.00')\n\n    @property\n    def balance(self) -&gt; Decimal:\n        return self._balance\n\n    @dispatch(BankAccountCreatedDomainEventV1)\n    def state_manager(self, event: BankAccountCreatedDomainEventV1):\n        \"\"\"Handle account creation for state reconstruction\"\"\"\n        self._owner_id = event.owner_id\n        self._overdraft_limit = event.overdraft_limit\n\n    @dispatch(BankAccountTransactionRecordedDomainEventV1)\n    def state_manager(self, event: BankAccountTransactionRecordedDomainEventV1):\n        \"\"\"Handle transaction recording for state reconstruction\"\"\"\n        self._balance += event.amount\n</code></pre>"},{"location":"features/event-sourcing/#aggregate-root-pattern","title":"\ud83d\ude80 Aggregate Root Pattern","text":""},{"location":"features/event-sourcing/#defining-aggregates","title":"Defining Aggregates","text":"<p>Aggregates are domain objects that encapsulate business logic and raise domain events:</p> <pre><code>from neuroglia.data.abstractions import AggregateRoot, AggregateState, DomainEvent\nfrom decimal import Decimal\nfrom datetime import datetime\nimport uuid\n\nclass BankAccountV1(AggregateRoot[BankAccountState, str]):\n    \"\"\"Bank Account aggregate with event sourcing\"\"\"\n\n    def __init__(self, owner: Person, initial_balance: Decimal):\n        super().__init__()\n\n        # Validate business rules\n        if initial_balance &lt; Decimal('0.00'):\n            raise InvalidInitialBalanceException(\"Initial balance cannot be negative\")\n\n        # Register creation event and apply to state\n        self.state.on(self.register_event(BankAccountCreatedDomainEventV1(\n            aggregate_id=str(uuid.uuid4()).replace('-', ''),\n            owner_id=owner.id(),\n            initial_balance=initial_balance,\n            created_at=datetime.utcnow()\n        )))\n\n    def get_available_balance(self) -&gt; Decimal:\n        \"\"\"Get the available balance including overdraft\"\"\"\n        return Decimal(self.state.balance) + Decimal(self.state.overdraft_limit)\n\n    def try_add_transaction(self, transaction: BankTransactionV1) -&gt; bool:\n        \"\"\"Record a financial transaction\"\"\"\n\n        # Business rule validation  \n        if (transaction.type != BankTransactionTypeV1.DEPOSIT and \n            transaction.type != BankTransactionTypeV1.INTEREST and \n            not (transaction.type == BankTransactionTypeV1.TRANSFER and transaction.to_account_id == self.id()) and \n            transaction.amount &gt; self.get_available_balance()):\n            return False\n\n        # Register transaction event and apply to state\n        self.state.on(self.register_event(BankAccountTransactionRecordedDomainEventV1(\n            self.id(), transaction\n        )))\n        return True\n\n    def set_overdraft_limit(self, limit: Decimal):\n        \"\"\"Set the overdraft limit for the account\"\"\"\n        if limit &lt; Decimal('0.00'):\n            raise InvalidOverdraftLimitException(\"Overdraft limit cannot be negative\")\n\n        self.state.on(self.register_event(OverdraftLimitChangedDomainEventV1(\n            aggregate_id=self.state.id,\n            old_limit=self.state.overdraft_limit,\n            new_limit=limit\n        )))\n\n    def close_account(self, reason: str):\n        \"\"\"Close the bank account\"\"\"\n        if self.state.balance != Decimal('0.00'):\n            raise AccountHasBalanceException(\"Cannot close account with non-zero balance\")\n\n        self.state.on(self.register_event(BankAccountClosedDomainEventV1(\n            aggregate_id=self.state.id,\n            reason=reason,\n            final_balance=self.state.balance\n        )))\n</code></pre>"},{"location":"features/event-sourcing/#aggregate-state-management","title":"Aggregate State Management","text":"<p>The aggregate manages its internal state through event application:</p> <pre><code>from multipledispatch import dispatch\nfrom decimal import Decimal\nfrom typing import List\n\nclass BankAccountV1(AggregateRoot[str]):\n    \"\"\"Bank Account aggregate with event sourcing\"\"\"\n\n    def __init__(self, account_id: str = None):\n        super().__init__(account_id)\n        self._balance = Decimal('0.00')\n        self._overdraft_limit = Decimal('0.00')\n        self._owner_id = \"\"\n        self._is_closed = False\n        self._transactions = []\n\n    @property\n    def balance(self) -&gt; Decimal:\n        return self._balance\n\n    @property\n    def owner_id(self) -&gt; str:\n        return self._owner_id\n\n    @property\n    def overdraft_limit(self) -&gt; Decimal:\n        return self._overdraft_limit\n\n    @dispatch(BankAccountCreatedDomainEventV1)\n    def state_manager(self, event: BankAccountCreatedDomainEventV1):\n        \"\"\"Handle account creation\"\"\"\n        self._owner_id = event.owner_id\n        self._overdraft_limit = event.overdraft_limit\n\n    @dispatch(BankAccountTransactionRecordedDomainEventV1)\n    def state_manager(self, event: BankAccountTransactionRecordedDomainEventV1):\n        \"\"\"Handle transaction recording\"\"\"\n        # Update balance based on transaction amount\n        self._balance += event.amount\n        self.last_modified = event.timestamp\n\n    @dispatch(OverdraftLimitChangedDomainEventV1)\n    def on(self, event: OverdraftLimitChangedDomainEventV1):\n        \"\"\"Handle overdraft limit changes\"\"\"\n        self.overdraft_limit = event.new_limit\n        self.last_modified = event.timestamp\n\n    @dispatch(BankAccountClosedDomainEventV1)\n    def on(self, event: BankAccountClosedDomainEventV1):\n        \"\"\"Handle account closure\"\"\"\n        self.is_closed = True\n        self.last_modified = event.timestamp\n</code></pre>"},{"location":"features/event-sourcing/#event-store-configuration","title":"\ud83c\udfea Event Store Configuration","text":""},{"location":"features/event-sourcing/#eventstoredb-setup","title":"EventStoreDB Setup","text":"<p>Configure EventStoreDB as the event storage backend:</p> <pre><code>from neuroglia.data.infrastructure.event_sourcing.event_store import ESEventStore\nfrom neuroglia.data.infrastructure.event_sourcing.abstractions import EventStoreOptions\nfrom neuroglia.hosting.web import WebApplicationBuilder\n\ndef configure_event_store(builder: WebApplicationBuilder):\n    \"\"\"Configure EventStoreDB for event sourcing\"\"\"\n\n    # Event store configuration\n    database_name = \"bankingsystem\"\n    consumer_group = \"banking-api-v1\"\n\n    ESEventStore.configure(\n        builder, \n        EventStoreOptions(\n            database_name=database_name,\n            consumer_group=consumer_group,\n            connection_string=\"esdb://localhost:2113?tls=false\",\n            credentials={\"username\": \"admin\", \"password\": \"changeit\"}\n        )\n    )\n\n    # Configure event sourcing repository for write model\n    EventSourcingRepository.configure(builder, BankAccountV1, str)\n\n    return builder\n</code></pre>"},{"location":"features/event-sourcing/#repository-configuration","title":"Repository Configuration","text":"<p>Set up separate repositories for write and read models:</p> <pre><code>from neuroglia.hosting.configuration.data_access_layer import DataAccessLayer\nfrom neuroglia.data.infrastructure.event_sourcing.event_sourcing_repository import EventSourcingRepository\nfrom neuroglia.data.infrastructure.mongo.mongo_repository import MongoRepository\n\ndef configure_data_access(builder: WebApplicationBuilder):\n    \"\"\"Configure write and read model repositories\"\"\"\n\n    # Write Model: Event-sourced aggregates\n    DataAccessLayer.WriteModel.configure(\n        builder,\n        [\"samples.banking.domain.models\"],  # Domain aggregate modules\n        lambda builder_, entity_type, key_type: EventSourcingRepository.configure(\n            builder_, entity_type, key_type\n        )\n    )\n\n    # Read Model: MongoDB projections\n    DataAccessLayer.ReadModel.configure(\n        builder,\n        [\"samples.banking.integration.models\"],  # Read model modules\n        lambda builder_, entity_type, key_type: MongoRepository.configure(\n            builder_, entity_type, key_type, database_name=\"banking_read_models\"\n        )\n    )\n\n    return builder\n</code></pre>"},{"location":"features/event-sourcing/#event-driven-projections","title":"\ud83d\udcca Event-Driven Projections","text":""},{"location":"features/event-sourcing/#creating-read-model-projections","title":"Creating Read Model Projections","text":"<p>Transform domain events into optimized read models:</p> <pre><code>from neuroglia.eventing import event_handler\n\nclass BankAccountProjectionHandler:\n    \"\"\"Handles domain events to update read model projections\"\"\"\n\n    def __init__(self, read_repository: Repository[BankAccountProjection, str]):\n        self.read_repository = read_repository\n\n    @event_handler(BankAccountCreatedDomainEventV1)\n    async def handle_account_created(self, event: BankAccountCreatedDomainEventV1):\n        \"\"\"Create read model projection when account is created\"\"\"\n\n        projection = BankAccountProjection(\n            id=event.aggregate_id,\n            owner_id=event.owner_id,\n            balance=event.initial_balance,\n            overdraft_limit=Decimal('0.00'),\n            status=\"ACTIVE\",\n            created_at=event.created_at,\n            last_modified=event.created_at,\n            transaction_count=0,\n            last_transaction_at=None\n        )\n\n        await self.read_repository.add_async(projection)\n\n    @event_handler(BankAccountTransactionRecordedDomainEventV1)\n    async def handle_transaction_recorded(self, event: BankAccountTransactionRecordedDomainEventV1):\n        \"\"\"Update projection when transaction is recorded\"\"\"\n\n        projection = await self.read_repository.get_by_id_async(event.aggregate_id)\n        if projection:\n            projection.balance += event.amount\n            projection.transaction_count += 1\n            projection.last_transaction_at = event.timestamp\n            projection.last_modified = event.timestamp\n\n            await self.read_repository.update_async(projection)\n\n    @event_handler(BankAccountClosedDomainEventV1)\n    async def handle_account_closed(self, event: BankAccountClosedDomainEventV1):\n        \"\"\"Update projection when account is closed\"\"\"\n\n        projection = await self.read_repository.get_by_id_async(event.aggregate_id)\n        if projection:\n            projection.status = \"CLOSED\"\n            projection.last_modified = event.timestamp\n\n            await self.read_repository.update_async(projection)\n</code></pre>"},{"location":"features/event-sourcing/#read-model-optimization","title":"Read Model Optimization","text":"<p>Design read models for specific query patterns:</p> <pre><code>@dataclass\nclass BankAccountProjection:\n    \"\"\"Optimized read model for bank account queries\"\"\"\n\n    id: str\n    owner_id: str\n    balance: Decimal\n    overdraft_limit: Decimal\n    status: str  # ACTIVE, CLOSED, SUSPENDED\n    created_at: datetime\n    last_modified: datetime\n    transaction_count: int\n    last_transaction_at: Optional[datetime]\n\n    # Denormalized owner information for efficient queries\n    owner_name: Optional[str] = None\n    owner_email: Optional[str] = None\n\n    # Aggregated transaction data\n    total_debits: Decimal = Decimal('0.00')\n    total_credits: Decimal = Decimal('0.00')\n    largest_transaction: Decimal = Decimal('0.00')\n\n@dataclass\nclass AccountSummaryProjection:\n    \"\"\"Summary projection for dashboard queries\"\"\"\n\n    owner_id: str\n    total_accounts: int\n    total_balance: Decimal\n    active_accounts: int\n    closed_accounts: int\n    last_activity: datetime\n</code></pre>"},{"location":"features/event-sourcing/#temporal-queries","title":"\ud83d\udd70\ufe0f Temporal Queries","text":""},{"location":"features/event-sourcing/#point-in-time-state-reconstruction","title":"Point-in-Time State Reconstruction","text":"<p>Query aggregate state at any specific point in time:</p> <pre><code>class TemporalQueryService:\n    \"\"\"Service for temporal queries on event-sourced aggregates\"\"\"\n\n    def __init__(self, event_store: EventStore, aggregator: Aggregator):\n        self.event_store = event_store\n        self.aggregator = aggregator\n\n    async def get_account_balance_at_date(self, account_id: str, as_of_date: datetime) -&gt; Decimal:\n        \"\"\"Get account balance as it was at a specific date\"\"\"\n\n        stream_id = f\"BankAccount-{account_id}\"\n\n        # Read events up to the specified date\n        events = await self.event_store.read_async(\n            stream_id,\n            direction=StreamReadDirection.FORWARDS,\n            from_position=0,\n            to_date=as_of_date\n        )\n\n        # Reconstruct state at that point in time\n        account = self.aggregator.aggregate(events, BankAccountV1)\n        return account.state.balance if account else Decimal('0.00')\n\n    async def get_transaction_history_between_dates(\n        self, \n        account_id: str, \n        from_date: datetime, \n        to_date: datetime\n    ) -&gt; List[BankTransactionV1]:\n        \"\"\"Get all transactions within a date range\"\"\"\n\n        stream_id = f\"BankAccount-{account_id}\"\n\n        events = await self.event_store.read_async(\n            stream_id,\n            direction=StreamReadDirection.FORWARDS,\n            from_date=from_date,\n            to_date=to_date\n        )\n\n        transactions = []\n        for event_record in events:\n            if isinstance(event_record.data, BankAccountTransactionRecordedDomainEventV1):\n                transaction = BankTransactionV1(\n                    id=event_record.data.transaction_id,\n                    amount=event_record.data.amount,\n                    type=event_record.data.transaction_type,\n                    recorded_at=event_record.data.timestamp\n                )\n                transactions.append(transaction)\n\n        return transactions\n</code></pre>"},{"location":"features/event-sourcing/#business-intelligence-queries","title":"Business Intelligence Queries","text":"<p>Analyze historical data patterns:</p> <pre><code>class BusinessIntelligenceService:\n    \"\"\"Service for analyzing business patterns from events\"\"\"\n\n    def __init__(self, event_store: EventStore):\n        self.event_store = event_store\n\n    async def get_transaction_analytics(\n        self, \n        from_date: datetime, \n        to_date: datetime\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Analyze transaction patterns over time\"\"\"\n\n        # Query all transaction events in date range\n        events = await self.event_store.get_events_by_type_async(\n            BankAccountTransactionRecordedDomainEventV1,\n            from_date=from_date,\n            to_date=to_date\n        )\n\n        if not events:\n            return {\"message\": \"No transactions found in date range\"}\n\n        # Calculate analytics\n        total_transactions = len(events)\n        total_amount = sum(e.amount for e in events)\n        debit_transactions = [e for e in events if e.amount &lt; 0]\n        credit_transactions = [e for e in events if e.amount &gt; 0]\n\n        return {\n            \"period\": {\"from\": from_date.isoformat(), \"to\": to_date.isoformat()},\n            \"total_transactions\": total_transactions,\n            \"total_amount\": float(total_amount),\n            \"average_transaction\": float(total_amount / total_transactions),\n            \"debit_count\": len(debit_transactions),\n            \"credit_count\": len(credit_transactions),\n            \"largest_debit\": float(min(e.amount for e in debit_transactions)) if debit_transactions else 0,\n            \"largest_credit\": float(max(e.amount for e in credit_transactions)) if credit_transactions else 0,\n            \"daily_breakdown\": self._calculate_daily_breakdown(events, from_date, to_date)\n        }\n\n    def _calculate_daily_breakdown(self, events: List[BankAccountTransactionRecordedDomainEventV1], from_date: datetime, to_date: datetime) -&gt; List[Dict]:\n        \"\"\"Calculate daily transaction breakdown\"\"\"\n        daily_data = {}\n\n        for event in events:\n            day_key = event.timestamp.date().isoformat()\n            if day_key not in daily_data:\n                daily_data[day_key] = {\"count\": 0, \"amount\": Decimal('0.00')}\n\n            daily_data[day_key][\"count\"] += 1\n            daily_data[day_key][\"amount\"] += event.amount\n\n        return [\n            {\n                \"date\": date,\n                \"transaction_count\": data[\"count\"],\n                \"total_amount\": float(data[\"amount\"])\n            }\n            for date, data in sorted(daily_data.items())\n        ]\n</code></pre>"},{"location":"features/event-sourcing/#testing-event-sourced-systems","title":"\ud83e\uddea Testing Event-Sourced Systems","text":""},{"location":"features/event-sourcing/#unit-testing-aggregates","title":"Unit Testing Aggregates","text":"<p>Test business logic by verifying events are raised correctly:</p> <pre><code>import pytest\nfrom decimal import Decimal\n\nclass TestBankAccountAggregate:\n    \"\"\"Unit tests for BankAccount aggregate\"\"\"\n\n    def test_account_creation_raises_creation_event(self):\n        \"\"\"Test that creating an account raises the correct event\"\"\"\n        account = BankAccountV1()\n        owner_id = \"john-doe-123\"\n        overdraft_limit = Decimal(\"1000.00\")\n\n        account.create_account(owner_id, overdraft_limit)\n\n        events = account._pending_events\n\n        assert len(events) == 1\n        assert isinstance(events[0], BankAccountCreatedDomainEventV1)\n        assert events[0].owner_id == owner_id\n        assert events[0].overdraft_limit == overdraft_limit\n\n    def test_transaction_recording_updates_balance_and_raises_event(self):\n        \"\"\"Test that recording a transaction updates balance and raises event\"\"\"\n        account = self._create_test_account()\n\n        # Create a transaction using the actual method signature\n        transaction_id = \"trans-123\"\n        amount = Decimal(\"100.00\")\n\n        result = account.try_add_transaction(transaction_id, amount)\n\n        # Verify transaction was accepted\n        assert result == True\n\n        # Verify event was registered\n        events = account._pending_events\n        transaction_events = [e for e in events if isinstance(e, BankAccountTransactionRecordedDomainEventV1)]\n\n        assert len(transaction_events) == 1\n\n    def test_insufficient_funds_raises_exception(self):\n        \"\"\"Test that insufficient funds rejects transaction\"\"\"\n        account = self._create_test_account()\n\n        # Create transaction that exceeds available balance\n        large_transaction = BankTransactionV1(\n            type=BankTransactionTypeV1.WITHDRAWAL,\n            amount=Decimal(\"2000.00\"),  # More than available balance\n            from_account_id=account.id(),\n            to_account_id=None\n        )\n\n        result = account.try_add_transaction(large_transaction)\n\n        # Verify transaction was rejected\n        assert result == False\n\n        # Verify no event was registered\n        events = account._pending_events\n        transaction_events = [e for e in events if isinstance(e, BankAccountTransactionRecordedDomainEventV1)]\n        assert len(transaction_events) == 0\n\n    def test_state_reconstruction_from_events(self):\n        \"\"\"Test that aggregate state can be reconstructed from events\"\"\"\n\n        # Create aggregate\n        account = BankAccountV1()\n\n        # Create and apply events directly to simulate repository loading\n        creation_event = BankAccountCreatedDomainEventV1(\n            aggregate_id=account.id,\n            owner_id=\"owner-123\",\n            overdraft_limit=Decimal(\"500.00\")\n        )\n\n        transaction_event = BankAccountTransactionRecordedDomainEventV1(\n            aggregate_id=account.id,\n            transaction_id=\"trans-123\",\n            amount=Decimal(\"100.00\")\n        )\n\n        # Apply events to reconstruct state\n        account.state_manager(creation_event)\n        account.state_manager(transaction_event)\n\n        # Verify state reconstruction\n        assert account.owner_id == \"owner-123\"\n        assert account.overdraft_limit == Decimal(\"500.00\")\n        assert account.balance == Decimal(\"100.00\")\n\n    def _create_test_account(self) -&gt; BankAccountV1:\n        \"\"\"Helper method to create a test account\"\"\"\n        account = BankAccountV1()\n        account.create_account(\"test-owner\", Decimal(\"1000.00\"))\n        # Clear pending events for clean testing\n        account._pending_events.clear()\n        return account\n</code></pre>"},{"location":"features/event-sourcing/#integration-testing-with-event-store","title":"Integration Testing with Event Store","text":"<p>Test the complete event sourcing workflow:</p> <pre><code>@pytest.mark.integration\nclass TestEventSourcingIntegration:\n    \"\"\"Integration tests for event sourcing workflow\"\"\"\n\n    @pytest.fixture\n    async def event_store(self):\n        \"\"\"Create test event store\"\"\"\n        options = EventStoreOptions(\n            database_name=\"test_banking\",\n            consumer_group=\"test_group\",\n            connection_string=\"esdb://localhost:2113?tls=false\"\n        )\n        # Return configured event store for testing\n        pass\n\n    @pytest.fixture\n    async def repository(self, event_store):\n        \"\"\"Create test repository\"\"\"\n        aggregator = Aggregator()\n        return EventSourcingRepository(event_store, aggregator)\n\n    @pytest.mark.asyncio\n    async def test_complete_aggregate_lifecycle(self, repository):\n        \"\"\"Test complete aggregate lifecycle with persistence\"\"\"\n\n        # Create aggregate\n        owner = Person(\"integration@test.com\", \"Integration\", \"Test\")\n        account = BankAccountV1(owner, Decimal(\"1000.00\"))\n\n        # Save to event store\n        saved_account = await repository.add_async(account)\n        assert saved_account.state.state_version &gt; 0\n\n        # Load from event store\n        loaded_account = await repository.get_async(saved_account.id())\n        assert loaded_account is not None\n        assert loaded_account.state.balance == Decimal(\"1000.00\")\n        assert loaded_account.state.owner_id == owner.id()\n\n        # Modify and save again\n        transaction = BankTransactionV1(\n            type=BankTransactionTypeV1.WITHDRAWAL,\n            amount=Decimal(\"200.00\"),\n            from_account_id=loaded_account.id(),\n            to_account_id=None\n        )\n        loaded_account.try_add_transaction(transaction)\n        updated_account = await repository.update_async(loaded_account)\n\n        # Verify persistence\n        final_account = await repository.get_async(updated_account.id())\n        assert len(final_account.state.transactions) == 1\n\n    @pytest.mark.asyncio\n    async def test_concurrent_modifications_throw_concurrency_exception(self, repository):\n        \"\"\"Test that concurrent modifications are detected\"\"\"\n\n        # Create and save account\n        owner = Person(\"concurrent@test.com\", \"Concurrent\", \"Test\")\n        account = BankAccountV1(owner, Decimal(\"1000.00\"))\n        saved_account = await repository.add_async(account)\n        account_id = saved_account.id()\n\n        # Load same account in two instances\n        account1 = await repository.get_async(account_id)\n        account2 = await repository.get_async(account_id)\n\n        # Modify both\n        transaction1 = BankTransactionV1(BankTransactionTypeV1.WITHDRAWAL, Decimal(\"100.00\"), account_id, None)\n        transaction2 = BankTransactionV1(BankTransactionTypeV1.WITHDRAWAL, Decimal(\"200.00\"), account_id, None)\n\n        account1.try_add_transaction(transaction1)\n        account2.try_add_transaction(transaction2)\n\n        # Save first modification\n        await repository.update_async(account1)\n\n        # Second modification should fail due to concurrency\n        with pytest.raises(ConcurrencyException):\n            await repository.update_async(account2)\n</code></pre>"},{"location":"features/event-sourcing/#advanced-patterns","title":"\ud83d\udd27 Advanced Patterns","text":""},{"location":"features/event-sourcing/#event-versioning","title":"Event Versioning","text":"<p>Handle evolving event schemas over time:</p> <pre><code># V1 Event\n@dataclass\nclass BankAccountCreatedDomainEventV1(DomainEvent[str]):\n    owner_id: str\n    initial_balance: Decimal\n\n# V2 Event - Added account type\n@dataclass  \nclass BankAccountCreatedDomainEventV2(DomainEvent[str]):\n    owner_id: str\n    initial_balance: Decimal\n    account_type: str  # New field\n\n# Event upcasting for backward compatibility\nclass EventUpcaster:\n    def upcast(self, event_data: dict, event_type: str) -&gt; dict:\n        if event_type == \"BankAccountCreatedDomainEventV1\":\n            # Upcast V1 to V2 by adding default account type\n            event_data[\"account_type\"] = \"CHECKING\"\n            return event_data\n        return event_data\n</code></pre>"},{"location":"features/event-sourcing/#snapshots-for-performance","title":"Snapshots for Performance","text":"<p>Optimize performance for long event streams:</p> <pre><code>@dataclass\nclass BankAccountSnapshot:\n    \"\"\"Snapshot of bank account state for performance optimization\"\"\"\n\n    aggregate_id: str\n    version: int\n    balance: Decimal\n    overdraft_limit: Decimal\n    transaction_count: int\n    created_at: datetime\n    snapshot_at: datetime\n\nclass SnapshotRepository:\n    \"\"\"Repository for managing aggregate snapshots\"\"\"\n\n    async def save_snapshot_async(self, aggregate: BankAccountV1) -&gt; None:\n        \"\"\"Save a snapshot of the current aggregate state\"\"\"\n        snapshot = BankAccountSnapshot(\n            aggregate_id=aggregate.state.id,\n            version=aggregate.state.state_version,\n            balance=aggregate.state.balance,\n            overdraft_limit=aggregate.state.overdraft_limit,\n            transaction_count=len(aggregate.state.transactions),\n            created_at=aggregate.state.created_at,\n            snapshot_at=datetime.utcnow()\n        )\n        await self.repository.add_async(snapshot)\n\n    async def load_from_snapshot_async(self, aggregate_id: str) -&gt; Optional[BankAccountV1]:\n        \"\"\"Load aggregate from latest snapshot plus subsequent events\"\"\"\n        snapshot = await self.get_latest_snapshot_async(aggregate_id)\n        if not snapshot:\n            return None\n\n        # Load events since snapshot\n        events = await self.event_store.read_async(\n            f\"BankAccount-{aggregate_id}\",\n            from_version=snapshot.version + 1\n        )\n\n        # Reconstruct aggregate from snapshot + events\n        aggregate = self._create_from_snapshot(snapshot)\n        self._apply_events(aggregate, events)\n\n        return aggregate\n</code></pre>"},{"location":"features/event-sourcing/#saga-pattern-for-distributed-transactions","title":"Saga Pattern for Distributed Transactions","text":"<p>Coordinate long-running business processes:</p> <pre><code>class MoneyTransferSaga:\n    \"\"\"Saga for coordinating money transfers between accounts\"\"\"\n\n    @saga_step\n    async def debit_source_account(self, transfer_id: str, source_account_id: str, amount: Decimal):\n        \"\"\"Step 1: Debit the source account\"\"\"\n        command = DebitAccountCommand(source_account_id, amount, transfer_id)\n        result = await self.mediator.execute_async(command)\n\n        if result.is_success:\n            await self.complete_step(\"debit_source\", transfer_id)\n        else:\n            await self.compensate_transfer(transfer_id, \"Failed to debit source account\")\n\n    @saga_step\n    async def credit_target_account(self, transfer_id: str, target_account_id: str, amount: Decimal):\n        \"\"\"Step 2: Credit the target account\"\"\"\n        command = CreditAccountCommand(target_account_id, amount, transfer_id)\n        result = await self.mediator.execute_async(command)\n\n        if result.is_success:\n            await self.complete_saga(transfer_id)\n        else:\n            await self.compensate_debit(transfer_id, source_account_id, amount)\n\n    @compensating_action\n    async def compensate_debit(self, transfer_id: str, account_id: str, amount: Decimal):\n        \"\"\"Compensate by crediting back the debited amount\"\"\"\n        compensation_command = CreditAccountCommand(account_id, amount, f\"compensation-{transfer_id}\")\n        await self.mediator.execute_async(compensation_command)\n</code></pre>"},{"location":"features/event-sourcing/#monitoring-and-observability","title":"\ud83d\udcca Monitoring and Observability","text":""},{"location":"features/event-sourcing/#event-stream-health-monitoring","title":"Event Stream Health Monitoring","text":"<p>Monitor the health of your event streams:</p> <pre><code>class EventStoreHealthService:\n    \"\"\"Service for monitoring event store health\"\"\"\n\n    async def get_stream_statistics(self, stream_id: str) -&gt; Dict[str, Any]:\n        \"\"\"Get statistics for a specific event stream\"\"\"\n        descriptor = await self.event_store.get_stream_descriptor_async(stream_id)\n\n        return {\n            \"stream_id\": stream_id,\n            \"event_count\": descriptor.length,\n            \"first_event_at\": descriptor.first_event_at.isoformat() if descriptor.first_event_at else None,\n            \"last_event_at\": descriptor.last_event_at.isoformat() if descriptor.last_event_at else None,\n            \"stream_age_days\": (datetime.utcnow() - descriptor.first_event_at).days if descriptor.first_event_at else 0\n        }\n\n    async def detect_problematic_streams(self, max_age_days: int = 30) -&gt; List[str]:\n        \"\"\"Detect streams that haven't had events for a long time\"\"\"\n        all_streams = await self.event_store.list_streams_async()\n        problematic_streams = []\n\n        for stream_id in all_streams:\n            descriptor = await self.event_store.get_stream_descriptor_async(stream_id)\n            if descriptor.last_event_at:\n                age = (datetime.utcnow() - descriptor.last_event_at).days\n                if age &gt; max_age_days:\n                    problematic_streams.append(stream_id)\n\n        return problematic_streams\n</code></pre>"},{"location":"features/event-sourcing/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Data Access - Repository patterns and data persistence</li> <li>CQRS &amp; Mediation - Command/Query separation patterns  </li> <li>Domain Events - Domain event modeling</li> <li>OpenBank Sample - Complete event sourcing implementation</li> <li>Testing Strategies - Testing event-sourced systems</li> </ul>"},{"location":"features/event-sourcing/#best-practices","title":"\ud83c\udfaf Best Practices","text":""},{"location":"features/event-sourcing/#dos","title":"Do's \u2705","text":"<ul> <li>Design events as immutable facts - Events represent what happened, not what should happen</li> <li>Use meaningful event names - Events should clearly describe business occurrences</li> <li>Keep events focused - Each event should represent a single business fact</li> <li>Version your events - Plan for schema evolution from the beginning</li> <li>Test event handlers thoroughly - Ensure state transitions work correctly</li> <li>Monitor stream health - Track stream growth and performance metrics</li> </ul>"},{"location":"features/event-sourcing/#donts","title":"Don'ts \u274c","text":"<ul> <li>Don't modify events - Events are immutable historical facts</li> <li>Don't make events too granular - Avoid events for every minor state change</li> <li>Don't ignore concurrency - Handle concurrent modifications appropriately</li> <li>Don't skip snapshots - Use snapshots for performance with long streams</li> <li>Don't forget about eventual consistency - Read models may lag behind write models</li> <li>Don't ignore event ordering - Event sequence matters for state reconstruction</li> </ul> <p>Event Sourcing provides powerful capabilities for building auditable, scalable, and maintainable systems. The Neuroglia framework makes it straightforward to implement event sourcing patterns while maintaining clean architecture principles.</p>"},{"location":"features/mermaid-diagrams/","title":"\ud83d\udcca Mermaid Diagrams in Documentation","text":"<p>The Neuroglia Python Framework documentation supports Mermaid diagrams for creating visual representations of architecture, workflows, and system interactions.</p>"},{"location":"features/mermaid-diagrams/#overview","title":"\ud83c\udfaf Overview","text":"<p>Mermaid is a powerful diagramming tool that allows you to create diagrams using simple text-based syntax. Our documentation site automatically renders Mermaid diagrams when you include them in markdown files.</p>"},{"location":"features/mermaid-diagrams/#supported-diagram-types","title":"\ud83c\udfd7\ufe0f Supported Diagram Types","text":""},{"location":"features/mermaid-diagrams/#flowcharts","title":"Flowcharts","text":"<p>Perfect for representing decision flows, process flows, and system workflows:</p> <pre><code>graph TD\n    A[User Request] --&gt; B{Authentication}\n    B --&gt;|Valid| C[Route to Controller]\n    B --&gt;|Invalid| D[Return 401]\n    C --&gt; E[Execute Handler]\n    E --&gt; F[Return Response]\n    D --&gt; G[End]\n    F --&gt; G</code></pre>"},{"location":"features/mermaid-diagrams/#sequence-diagrams","title":"Sequence Diagrams","text":"<p>Ideal for showing interaction between components over time:</p> <pre><code>sequenceDiagram\n    participant C as Controller\n    participant M as Mediator\n    participant H as Handler\n    participant R as Repository\n    participant D as Database\n\n    C-&gt;&gt;M: Send Command\n    M-&gt;&gt;H: Route to Handler\n    H-&gt;&gt;R: Query/Save Data\n    R-&gt;&gt;D: Execute SQL\n    D--&gt;&gt;R: Return Result\n    R--&gt;&gt;H: Domain Objects\n    H--&gt;&gt;M: Operation Result\n    M--&gt;&gt;C: Response</code></pre>"},{"location":"features/mermaid-diagrams/#class-diagrams","title":"Class Diagrams","text":"<p>Great for documenting domain models and relationships:</p> <pre><code>classDiagram\n    class Controller {\n        +ServiceProvider service_provider\n        +Mediator mediator\n        +Mapper mapper\n        +process(result) Response\n    }\n\n    class CommandHandler {\n        &lt;&lt;abstract&gt;&gt;\n        +handle_async(command) OperationResult\n    }\n\n    class Entity {\n        +str id\n        +datetime created_at\n        +raise_event(event)\n        +get_uncommitted_events()\n    }\n\n    class Repository {\n        &lt;&lt;interface&gt;&gt;\n        +save_async(entity)\n        +get_by_id_async(id)\n        +delete_async(id)\n    }\n\n    Controller --&gt; CommandHandler : uses\n    CommandHandler --&gt; Entity : manipulates\n    CommandHandler --&gt; Repository : persists through</code></pre>"},{"location":"features/mermaid-diagrams/#architecture-diagrams","title":"Architecture Diagrams","text":"<p>Perfect for system overview and component relationships:</p> <pre><code>graph TB\n    subgraph \"\ud83c\udf10 API Layer\"\n        A[Controllers]\n        B[DTOs]\n        C[Middleware]\n    end\n\n    subgraph \"\ud83d\udcbc Application Layer\"\n        D[Commands/Queries]\n        E[Handlers]\n        F[Services]\n        G[Mediator]\n    end\n\n    subgraph \"\ud83c\udfdb\ufe0f Domain Layer\"\n        H[Entities]\n        I[Value Objects]\n        J[Domain Events]\n        K[Business Rules]\n    end\n\n    subgraph \"\ud83d\udd0c Integration Layer\"\n        L[Repositories]\n        M[External APIs]\n        N[Database]\n        O[Event Bus]\n    end\n\n    A --&gt; G\n    G --&gt; E\n    E --&gt; H\n    E --&gt; L\n    L --&gt; N\n    E --&gt; O\n\n    style A fill:#e1f5fe\n    style G fill:#f3e5f5\n    style H fill:#e8f5e8\n    style L fill:#fff3e0</code></pre>"},{"location":"features/mermaid-diagrams/#state-diagrams","title":"State Diagrams","text":"<p>Useful for modeling entity lifecycle and business processes:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; Draft\n    Draft --&gt; Submitted : submit()\n    Submitted --&gt; Approved : approve()\n    Submitted --&gt; Rejected : reject()\n    Rejected --&gt; Draft : revise()\n    Approved --&gt; Published : publish()\n    Published --&gt; Archived : archive()\n    Archived --&gt; [*]\n\n    state Submitted {\n        [*] --&gt; PendingReview\n        PendingReview --&gt; InReview : assign_reviewer()\n        InReview --&gt; ReviewComplete : complete_review()\n    }</code></pre>"},{"location":"features/mermaid-diagrams/#usage-in-documentation","title":"\ud83d\ude80 Usage in Documentation","text":""},{"location":"features/mermaid-diagrams/#basic-syntax","title":"Basic Syntax","text":"<p>To include a Mermaid diagram in your documentation:</p> <pre><code>```mermaid\ngraph TD\n    A[Start] --&gt; B[Process]\n    B --&gt; C[End]\n```\n</code></pre>"},{"location":"features/mermaid-diagrams/#best-practices","title":"Best Practices","text":"<ol> <li>Use Descriptive Labels: Make node labels clear and meaningful</li> <li>Consistent Styling: Use subgraphs for logical grouping</li> <li>Appropriate Diagram Types: Choose the right diagram for your content</li> <li>Keep It Simple: Don't overcomplicate diagrams</li> <li>Use Colors Wisely: Leverage styling for emphasis</li> </ol>"},{"location":"features/mermaid-diagrams/#advanced-styling","title":"Advanced Styling","text":"<p>You can add custom styling to your diagrams:</p> <pre><code>graph TD\n    A[API Request] --&gt; B[Authentication]\n    B --&gt; C[Authorization]\n    C --&gt; D[Business Logic]\n    D --&gt; E[Data Access]\n    E --&gt; F[Response]\n\n    classDef apiStyle fill:#e3f2fd,stroke:#1976d2,stroke-width:2px\n    classDef processStyle fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\n    classDef dataStyle fill:#e8f5e8,stroke:#388e3c,stroke-width:2px\n\n    class A,F apiStyle\n    class B,C,D processStyle\n    class E dataStyle</code></pre>"},{"location":"features/mermaid-diagrams/#configuration","title":"\ud83d\udd27 Configuration","text":"<p>The documentation site is configured with:</p> <ul> <li>Theme: Auto (follows system dark/light mode)</li> <li>Primary Color: Blue (#1976d2) matching Material theme</li> <li>Auto-refresh: Diagrams update automatically during development</li> <li>High DPI: Support for crisp diagrams on retina displays</li> </ul>"},{"location":"features/mermaid-diagrams/#documentation-standards","title":"\ud83d\udcdd Documentation Standards","text":"<p>When adding Mermaid diagrams to documentation:</p> <ol> <li>Always include a text description before the diagram</li> <li>Use consistent terminology across all diagrams</li> <li>Reference framework concepts (Controllers, Handlers, etc.)</li> <li>Include diagrams in relevant sections of feature documentation</li> <li>Test rendering locally before committing</li> </ol>"},{"location":"features/mermaid-diagrams/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Architecture Overview</li> <li>CQRS &amp; Mediation</li> <li>Dependency Injection</li> <li>Sample Applications</li> </ul>"},{"location":"features/mermaid-diagrams/#external-resources","title":"\ud83d\udcda External Resources","text":"<ul> <li>Mermaid Documentation</li> <li>Mermaid Live Editor</li> <li>MkDocs Material</li> </ul>"},{"location":"features/mvc-controllers/","title":"\ud83d\udd0c MVC Controllers","text":"<p>Neuroglia's MVC system provides powerful class-based API development using Mario's Pizzeria as an example, demonstrating real-world controller patterns with automatic discovery, dependency injection, and comprehensive API design.</p>"},{"location":"features/mvc-controllers/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>Pizza Order Management: OrdersController for handling customer orders</li> <li>Menu Administration: MenuController for pizza and topping management  </li> <li>Kitchen Operations: KitchenController for order preparation workflow</li> <li>Authentication &amp; Authorization: OAuth integration for staff and customer access</li> <li>Error Handling: Comprehensive error responses and validation</li> <li>API Documentation: Automatic OpenAPI generation with pizzeria examples</li> </ul>"},{"location":"features/mvc-controllers/#controller-foundation","title":"\ud83c\udfd7\ufe0f Controller Foundation","text":""},{"location":"features/mvc-controllers/#pizza-order-controller","title":"Pizza Order Controller","text":"<p>The main controller for customer interactions at Mario's Pizzeria:</p> <pre><code>from neuroglia.mvc.controller_base import ControllerBase\nfrom neuroglia.dependency_injection.service_provider import ServiceProviderBase\nfrom neuroglia.mapping.mapper import Mapper\nfrom neuroglia.mediation.mediator import Mediator\nfrom classy_fastapi.decorators import get, post, put, delete\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import HTTPBearer\nfrom typing import List, Optional\nfrom datetime import date\n\nclass OrdersController(ControllerBase):\n    \"\"\"Controller for managing pizza orders at Mario's Pizzeria\"\"\"\n\n    def __init__(self, \n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n        self.security = HTTPBearer(auto_error=False)\n\n    @get(\"/\", \n         response_model=List[OrderDto], \n         summary=\"Get customer orders\",\n         description=\"Retrieve orders for authenticated customer\")\n    async def get_my_orders(self, \n                            token: str = Depends(HTTPBearer()),\n                            limit: int = 10) -&gt; List[OrderDto]:\n        \"\"\"Get orders for authenticated customer\"\"\"\n        try:\n            # Validate customer token and get customer info\n            customer_info = await self._validate_customer_token(token.credentials)\n\n            # Query customer's orders\n            query = GetOrdersByCustomerQuery(\n                customer_phone=customer_info.phone,\n                limit=limit\n            )\n            result = await self.mediator.execute_async(query)\n\n            return self.process(result)\n\n        except Exception as e:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid authentication token\"\n            )\n\n    @get(\"/{order_id}\", \n         response_model=OrderDto,\n         summary=\"Get specific order\",\n         description=\"Get details of a specific pizza order\")\n    async def get_order(self, \n                        order_id: str,\n                        token: str = Depends(HTTPBearer())) -&gt; OrderDto:\n        \"\"\"Get specific order details\"\"\"\n        # Validate customer access to this order\n        customer_info = await self._validate_customer_token(token.credentials)\n\n        query = GetOrderByIdQuery(\n            order_id=order_id,\n            customer_phone=customer_info.phone  # Ensure customer owns order\n        )\n        result = await self.mediator.execute_async(query)\n\n        return self.process(result)\n\n    @post(\"/\", \n          response_model=OrderDto, \n          status_code=201,\n          summary=\"Place pizza order\",\n          description=\"Place a new pizza order with customer details and pizza selection\")\n    async def place_order(self, \n                          order_request: PlaceOrderDto,\n                          token: Optional[str] = Depends(HTTPBearer(auto_error=False))) -&gt; OrderDto:\n        \"\"\"Place a new pizza order\"\"\"\n        try:\n            # If token provided, use customer info; otherwise use order details\n            customer_info = None\n            if token:\n                customer_info = await self._validate_customer_token(token.credentials)\n\n            # Create place order command\n            command = PlaceOrderCommand(\n                customer_name=customer_info.name if customer_info else order_request.customer_name,\n                customer_phone=customer_info.phone if customer_info else order_request.customer_phone,\n                customer_address=order_request.customer_address,\n                pizzas=order_request.pizzas,\n                payment_method=order_request.payment_method,\n                special_instructions=order_request.special_instructions\n            )\n\n            result = await self.mediator.execute_async(command)\n            return self.process(result)\n\n        except ValidationError as e:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=f\"Invalid order data: {str(e)}\"\n            )\n        except Exception as e:\n            raise HTTPException(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                detail=\"Failed to place order. Please try again.\"\n            )\n\n    @put(\"/{order_id}/cancel\", \n         response_model=OrderDto,\n         summary=\"Cancel order\",\n         description=\"Cancel a pizza order if it hasn't started preparation\")\n    async def cancel_order(self, \n                           order_id: str,\n                           cancellation_request: CancelOrderDto,\n                           token: str = Depends(HTTPBearer())) -&gt; OrderDto:\n        \"\"\"Cancel an existing order\"\"\"\n        customer_info = await self._validate_customer_token(token.credentials)\n\n        command = CancelOrderCommand(\n            order_id=order_id,\n            customer_phone=customer_info.phone,\n            cancellation_reason=cancellation_request.reason\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @get(\"/{order_id}/status\",\n         response_model=OrderStatusDto,\n         summary=\"Get order status\",\n         description=\"Get current status and estimated ready time for order\")\n    async def get_order_status(self, \n                               order_id: str,\n                               token: str = Depends(HTTPBearer())) -&gt; OrderStatusDto:\n        \"\"\"Get order status and tracking information\"\"\"\n        customer_info = await self._validate_customer_token(token.credentials)\n\n        query = GetOrderStatusQuery(\n            order_id=order_id,\n            customer_phone=customer_info.phone\n        )\n\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    async def _validate_customer_token(self, token: str) -&gt; CustomerInfo:\n        \"\"\"Validate customer authentication token\"\"\"\n        # In production, this would validate JWT token\n        # For demo purposes, we'll use a simple validation\n        query = ValidateCustomerTokenQuery(token=token)\n        result = await self.mediator.execute_async(query)\n\n        if not result.is_success:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid or expired token\"\n            )\n\n        return result.data\n</code></pre>"},{"location":"features/mvc-controllers/#menu-management-controller","title":"Menu Management Controller","text":"<pre><code>class MenuController(ControllerBase):\n    \"\"\"Controller for managing Mario's Pizzeria menu\"\"\"\n\n    def __init__(self, \n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n    @get(\"/pizzas\", \n         response_model=List[PizzaDto],\n         summary=\"Get pizza menu\",\n         description=\"Get all available pizzas organized by category\")\n    async def get_menu(self, \n                       category: Optional[str] = Query(None, description=\"Filter by pizza category\"),\n                       available_only: bool = Query(True, description=\"Show only available pizzas\")) -&gt; List[PizzaDto]:\n        \"\"\"Get pizza menu with optional filtering\"\"\"\n        query = GetMenuQuery(\n            category=category,\n            available_only=available_only\n        )\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/pizzas/{pizza_id}\", \n         response_model=PizzaDto,\n         summary=\"Get pizza details\",\n         description=\"Get detailed information about a specific pizza\")\n    async def get_pizza(self, pizza_id: str) -&gt; PizzaDto:\n        \"\"\"Get specific pizza details\"\"\"\n        query = GetPizzaByIdQuery(pizza_id=pizza_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/categories\",\n         response_model=List[str],\n         summary=\"Get pizza categories\",\n         description=\"Get all available pizza categories\")\n    async def get_categories(self) -&gt; List[str]:\n        \"\"\"Get all pizza categories\"\"\"\n        query = GetPizzaCategoriesQuery()\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/toppings\",\n         response_model=List[ToppingDto],\n         summary=\"Get available toppings\",\n         description=\"Get all available pizza toppings with prices\")\n    async def get_toppings(self,\n                           vegetarian_only: bool = Query(False, description=\"Show only vegetarian toppings\")) -&gt; List[ToppingDto]:\n        \"\"\"Get available toppings\"\"\"\n        query = GetToppingsQuery(vegetarian_only=vegetarian_only)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    # Admin endpoints (require staff authentication)\n    @post(\"/pizzas\", \n          response_model=PizzaDto, \n          status_code=201,\n          summary=\"Add new pizza (Staff Only)\",\n          description=\"Add a new pizza to the menu\")\n    async def add_pizza(self, \n                        pizza_request: CreatePizzaDto,\n                        staff_token: str = Depends(HTTPBearer())) -&gt; PizzaDto:\n        \"\"\"Add new pizza to menu (staff only)\"\"\"\n        await self._validate_staff_token(staff_token.credentials, required_role=\"manager\")\n\n        command = CreatePizzaCommand(\n            name=pizza_request.name,\n            description=pizza_request.description,\n            category=pizza_request.category,\n            base_price=pizza_request.base_price,\n            available_toppings=pizza_request.available_toppings,\n            preparation_time_minutes=pizza_request.preparation_time_minutes,\n            is_seasonal=pizza_request.is_seasonal\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @put(\"/pizzas/{pizza_id}/availability\", \n         response_model=PizzaDto,\n         summary=\"Update pizza availability (Staff Only)\",\n         description=\"Mark pizza as available or sold out\")\n    async def update_pizza_availability(self, \n                                        pizza_id: str,\n                                        availability_request: UpdateAvailabilityDto,\n                                        staff_token: str = Depends(HTTPBearer())) -&gt; PizzaDto:\n        \"\"\"Update pizza availability\"\"\"\n        await self._validate_staff_token(staff_token.credentials, required_role=\"staff\")\n\n        command = UpdatePizzaAvailabilityCommand(\n            pizza_id=pizza_id,\n            is_available=availability_request.is_available,\n            reason=availability_request.reason\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#kitchen-operations-controller","title":"Kitchen Operations Controller","text":"<pre><code>class KitchenController(ControllerBase):\n    \"\"\"Controller for kitchen operations and order management\"\"\"\n\n    def __init__(self, \n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n    @get(\"/queue\", \n         response_model=List[KitchenOrderDto],\n         summary=\"Get kitchen queue\",\n         description=\"Get orders in kitchen queue ordered by priority\")\n    async def get_kitchen_queue(self,\n                                staff_token: str = Depends(HTTPBearer())) -&gt; List[KitchenOrderDto]:\n        \"\"\"Get orders in kitchen preparation queue\"\"\"\n        await self._validate_staff_token(staff_token.credentials, required_role=\"kitchen\")\n\n        query = GetKitchenQueueQuery(\n            statuses=[\"received\", \"preparing\", \"cooking\"]\n        )\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @put(\"/orders/{order_id}/status\", \n         response_model=OrderDto,\n         summary=\"Update order status\",\n         description=\"Update order status in kitchen workflow\")\n    async def update_order_status(self, \n                                  order_id: str,\n                                  status_update: UpdateOrderStatusDto,\n                                  staff_token: str = Depends(HTTPBearer())) -&gt; OrderDto:\n        \"\"\"Update order status (kitchen staff only)\"\"\"\n        staff_info = await self._validate_staff_token(staff_token.credentials, required_role=\"kitchen\")\n\n        command = UpdateOrderStatusCommand(\n            order_id=order_id,\n            new_status=status_update.status,\n            updated_by=staff_info.staff_id,\n            notes=status_update.notes,\n            estimated_ready_time=status_update.estimated_ready_time\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @post(\"/orders/{order_id}/pizzas/{pizza_index}/start\", \n          response_model=OrderDto,\n          summary=\"Start pizza preparation\",\n          description=\"Mark pizza as started in preparation\")\n    async def start_pizza(self, \n                          order_id: str,\n                          pizza_index: int,\n                          staff_token: str = Depends(HTTPBearer())) -&gt; OrderDto:\n        \"\"\"Start pizza preparation\"\"\"\n        staff_info = await self._validate_staff_token(staff_token.credentials, required_role=\"kitchen\")\n\n        command = StartPizzaPreparationCommand(\n            order_id=order_id,\n            pizza_index=pizza_index,\n            chef_id=staff_info.staff_id\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @post(\"/orders/{order_id}/pizzas/{pizza_index}/complete\", \n          response_model=OrderDto,\n          summary=\"Complete pizza preparation\",\n          description=\"Mark pizza as completed\")\n    async def complete_pizza(self, \n                             order_id: str,\n                             pizza_index: int,\n                             completion_request: CompletePizzaDto,\n                             staff_token: str = Depends(HTTPBearer())) -&gt; OrderDto:\n        \"\"\"Complete pizza preparation\"\"\"\n        staff_info = await self._validate_staff_token(staff_token.credentials, required_role=\"kitchen\")\n\n        command = CompletePizzaPreparationCommand(\n            order_id=order_id,\n            pizza_index=pizza_index,\n            chef_id=staff_info.staff_id,\n            quality_notes=completion_request.quality_notes\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @get(\"/performance\", \n         response_model=KitchenPerformanceDto,\n         summary=\"Get kitchen performance metrics\",\n         description=\"Get kitchen performance analytics\")\n    async def get_performance_metrics(self,\n                                      start_date: date = Query(description=\"Start date for metrics\"),\n                                      end_date: date = Query(description=\"End date for metrics\"),\n                                      staff_token: str = Depends(HTTPBearer())) -&gt; KitchenPerformanceDto:\n        \"\"\"Get kitchen performance metrics\"\"\"\n        await self._validate_staff_token(staff_token.credentials, required_role=\"manager\")\n\n        query = GetKitchenPerformanceQuery(\n            start_date=start_date,\n            end_date=end_date\n        )\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    async def _validate_staff_token(self, token: str, required_role: str) -&gt; StaffInfo:\n        \"\"\"Validate staff authentication and role\"\"\"\n        query = ValidateStaffTokenQuery(\n            token=token,\n            required_role=required_role\n        )\n        result = await self.mediator.execute_async(query)\n\n        if not result.is_success:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=f\"Insufficient permissions. Required role: {required_role}\"\n            )\n\n        return result.data\n</code></pre> <pre><code>class ReportsController(ControllerBase):\n    \"\"\"Controller for pizzeria analytics and reporting\"\"\"\n\n    @get(\"/orders\", \n         response_model=List[OrderReportDto],\n         summary=\"Get order reports\",\n         description=\"Get filtered order data for reporting\")\n    async def get_order_reports(self,\n                                start_date: date = Query(description=\"Report start date\"),\n                                end_date: date = Query(description=\"Report end date\"),\n                                customer_phone: Optional[str] = Query(None, description=\"Filter by customer\"),\n                                status: Optional[str] = Query(None, description=\"Filter by order status\"),\n                                min_amount: Optional[float] = Query(None, ge=0, description=\"Minimum order amount\"),\n                                max_amount: Optional[float] = Query(None, ge=0, description=\"Maximum order amount\"),\n                                limit: int = Query(100, ge=1, le=1000, description=\"Maximum results to return\"),\n                                offset: int = Query(0, ge=0, description=\"Number of results to skip\"),\n                                staff_token: str = Depends(HTTPBearer())) -&gt; List[OrderReportDto]:\n        \"\"\"Get order reports with advanced filtering\"\"\"\n        await self._validate_staff_token(staff_token.credentials, required_role=\"manager\")\n\n        query = GetOrderReportsQuery(\n            start_date=start_date,\n            end_date=end_date,\n            customer_phone=customer_phone,\n            status=status,\n            min_amount=min_amount,\n            max_amount=max_amount,\n            limit=limit,\n            offset=offset\n        )\n\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/revenue\", \n         response_model=RevenueReportDto,\n         summary=\"Get revenue analytics\",\n         description=\"Get revenue breakdown and analytics\")\n    async def get_revenue_report(self,\n                                 period: str = Query(\"daily\", regex=\"^(daily|weekly|monthly)$\"),\n                                 start_date: date = Query(description=\"Analysis start date\"),\n                                 end_date: date = Query(description=\"Analysis end date\"),\n                                 staff_token: str = Depends(HTTPBearer())) -&gt; RevenueReportDto:\n        \"\"\"Get revenue analytics by period\"\"\"\n        await self._validate_staff_token(staff_token.credentials, required_role=\"manager\")\n\n        query = GetRevenueAnalyticsQuery(\n            period=period,\n            start_date=start_date,\n            end_date=end_date\n        )\n\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#request-validation-and-dtos","title":"Request Validation and DTOs","text":"<p>Comprehensive validation for pizzeria data:         \"\"\"Get users with filtering and pagination\"\"\"</p> <pre><code>    query = GetUsersQuery(\n        department=department,\n        active_only=active_only,\n        page=page,\n        page_size=page_size\n    )\n\n    result = await self.mediator.execute_async(query)\n    return self.process(result)\n</code></pre> <p>``` </p>"},{"location":"features/mvc-controllers/#request-body-validation","title":"Request Body Validation","text":"<p>Use Pydantic models for request validation:  <code>python from pydantic import BaseModel, Field, EmailStr from typing import Optional  class CreateUserDto(BaseModel):     email: EmailStr = Field(..., description=\"User's email address\")     first_name: str = Field(..., min_length=1, max_length=50, description=\"First name\")     last_name: str = Field(..., min_length=1, max_length=50, description=\"Last name\")     department: Optional[str] = Field(None, max_length=100, description=\"Department\")      class Config:         schema_extra = {             \"example\": {                 \"email\": \"john.doe@company.com\",                 \"first_name\": \"John\",                 \"last_name\": \"Doe\",                 \"department\": \"Engineering\"             }         }  class UsersController(ControllerBase):      @post(\"/\", response_model=UserDto, status_code=status.HTTP_201_CREATED)     async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:         \"\"\"Create a new user\"\"\"         command = self.mapper.map(create_user_dto, CreateUserCommand)         result = await self.mediator.execute_async(command)         return self.process(result)</code></p>"},{"location":"features/mvc-controllers/#file-uploads","title":"File Uploads","text":"<p>Handle file uploads:</p> <pre><code>from fastapi import UploadFile, File\n\nclass UsersController(ControllerBase):\n\n    @post(\"/{user_id}/avatar\", response_model=UserDto)\n    async def upload_avatar(self, \n                           user_id: str,\n                           file: UploadFile = File(..., description=\"Avatar image\")) -&gt; UserDto:\n        \"\"\"Upload user avatar\"\"\"\n\n        # Validate file type\n        if not file.content_type.startswith('image/'):\n            return self.bad_request(\"File must be an image\")\n\n        # Create command\n        command = UploadUserAvatarCommand(\n            user_id=user_id,\n            file_name=file.filename,\n            file_content=await file.read(),\n            content_type=file.content_type\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#response-headers","title":"Response Headers","text":"<p>Set custom response headers:</p> <pre><code>from fastapi import Response\n\nclass UsersController(ControllerBase):\n\n    @get(\"/{user_id}/export\", response_class=Response)\n    async def export_user_data(self, user_id: str, response: Response):\n        \"\"\"Export user data as CSV\"\"\"\n\n        query = ExportUserDataQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n\n        if not result.is_success:\n            return self.process(result)\n\n        # Set CSV headers\n        response.headers[\"Content-Type\"] = \"text/csv\"\n        response.headers[\"Content-Disposition\"] = f\"attachment; filename=user_{user_id}.csv\"\n\n        return result.data\n</code></pre>"},{"location":"features/mvc-controllers/#controller-configuration","title":"\ud83c\udfaa Controller Configuration","text":""},{"location":"features/mvc-controllers/#custom-routing","title":"Custom Routing","text":"<p>Customize controller routing:</p> <pre><code>class UsersController(ControllerBase):\n    def __init__(self, service_provider, mapper, mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n        # Custom prefix and tags\n        self.router.prefix = \"/users\"\n        self.router.tags = [\"User Management\"]\n\n        # Add custom middleware to this controller\n        self.router.middleware(\"http\")(self.auth_middleware)\n\n    async def auth_middleware(self, request, call_next):\n        \"\"\"Custom authentication middleware for this controller\"\"\"\n        # Authentication logic\n        response = await call_next(request)\n        return response\n</code></pre>"},{"location":"features/mvc-controllers/#nested-controllers","title":"Nested Controllers","text":"<p>Create hierarchical resource structures:</p> <pre><code>class UserAccountsController(ControllerBase):\n    \"\"\"Handles user account operations\"\"\"\n\n    def __init__(self, service_provider, mapper, mediator):\n        super().__init__(service_provider, mapper, mediator)\n        self.router.prefix = \"/users/{user_id}/accounts\"\n\n    @get(\"/\", response_model=List[AccountDto])\n    async def get_user_accounts(self, user_id: str) -&gt; List[AccountDto]:\n        \"\"\"Get all accounts for a user\"\"\"\n        query = GetUserAccountsQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @post(\"/\", response_model=AccountDto, status_code=status.HTTP_201_CREATED)\n    async def create_account(self, user_id: str, create_account_dto: CreateAccountDto) -&gt; AccountDto:\n        \"\"\"Create a new account for a user\"\"\"\n        command = self.mapper.map(create_account_dto, CreateAccountCommand)\n        command.user_id = user_id\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#error-handling","title":"\ud83d\udee1\ufe0f Error Handling","text":""},{"location":"features/mvc-controllers/#built-in-error-responses","title":"Built-in Error Responses","text":"<p>Controllers include standard error responses:</p> <pre><code>class UsersController(ControllerBase):\n\n    @get(\"/{user_id}\", \n         response_model=UserDto,\n         responses=ControllerBase.error_responses)  # Adds 400, 404, 500 responses\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        \"\"\"Get user by ID\"\"\"\n        query = GetUserByIdQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)  # Automatically handles error responses\n</code></pre>"},{"location":"features/mvc-controllers/#custom-error-handling","title":"Custom Error Handling","text":"<p>Add custom error handling:</p> <pre><code>from fastapi import HTTPException\n\nclass UsersController(ControllerBase):\n\n    @post(\"/\", response_model=UserDto, status_code=status.HTTP_201_CREATED)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        \"\"\"Create a new user\"\"\"\n        try:\n            command = self.mapper.map(create_user_dto, CreateUserCommand)\n            result = await self.mediator.execute_async(command)\n            return self.process(result)\n\n        except EmailAlreadyExistsException:\n            raise HTTPException(\n                status_code=status.HTTP_409_CONFLICT,\n                detail=\"A user with this email already exists\"\n            )\n        except ValidationException as ex:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=str(ex)\n            )\n</code></pre>"},{"location":"features/mvc-controllers/#global-error-handling","title":"Global Error Handling","text":"<p>Use middleware for global error handling:</p> <pre><code>from neuroglia.hosting.web import ExceptionHandlingMiddleware\n\n# In main.py\napp.add_middleware(ExceptionHandlingMiddleware, service_provider=app.services)\n</code></pre>"},{"location":"features/mvc-controllers/#authentication-authorization","title":"\ud83d\udd10 Authentication &amp; Authorization","text":""},{"location":"features/mvc-controllers/#dependency-injection-for-auth","title":"Dependency Injection for Auth","text":"<p>Inject authentication services:</p> <pre><code>from fastapi import Depends\nfrom neuroglia.security import IAuthService, AuthUser\n\nclass UsersController(ControllerBase):\n\n    def __init__(self, \n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator,\n                 auth_service: IAuthService):\n        super().__init__(service_provider, mapper, mediator)\n        self.auth_service = auth_service\n\n    @get(\"/profile\", response_model=UserDto)\n    async def get_current_user(self, \n                              current_user: AuthUser = Depends(auth_service.get_current_user)) -&gt; UserDto:\n        \"\"\"Get current user's profile\"\"\"\n        query = GetUserByIdQuery(user_id=current_user.user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#role-based-authorization","title":"Role-based Authorization","text":"<p>Implement role-based access control:</p> <pre><code>from neuroglia.security import require_role\n\nclass UsersController(ControllerBase):\n\n    @get(\"/\", response_model=List[UserDto])\n    @require_role(\"admin\")  # Custom decorator\n    async def get_all_users(self) -&gt; List[UserDto]:\n        \"\"\"Get all users (admin only)\"\"\"\n        query = GetAllUsersQuery()\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @delete(\"/{user_id}\")\n    @require_role([\"admin\", \"manager\"])  # Multiple roles\n    async def delete_user(self, user_id: str):\n        \"\"\"Delete a user (admin or manager only)\"\"\"\n        command = DeleteUserCommand(user_id=user_id)\n        result = await self.mediator.execute_async(command)\n        self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#response-processing","title":"\ud83d\udcca Response Processing","text":""},{"location":"features/mvc-controllers/#the-process-method","title":"The <code>process</code> Method","text":"<p>The <code>process</code> method handles <code>OperationResult</code> objects automatically:</p> <pre><code># OperationResult with data\nresult = OperationResult.success(user_dto)\nreturn self.process(result)  # Returns user_dto with 200 status\n\n# OperationResult with error\nresult = OperationResult.not_found(\"User not found\")\nreturn self.process(result)  # Raises HTTPException with 404 status\n\n# OperationResult created\nresult = OperationResult.created(user_dto)\nreturn self.process(result)  # Returns user_dto with 201 status\n</code></pre>"},{"location":"features/mvc-controllers/#custom-response-processing","title":"Custom Response Processing","text":"<p>Override response processing for special cases:</p> <pre><code>class UsersController(ControllerBase):\n\n    @get(\"/{user_id}\", response_model=UserDto)\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        \"\"\"Get user by ID\"\"\"\n        query = GetUserByIdQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n\n        # Custom processing\n        if not result.is_success:\n            if result.status_code == 404:\n                # Log the attempt\n                self.logger.warning(f\"Attempt to access non-existent user: {user_id}\")\n            return self.process(result)\n\n        # Add custom headers for successful responses\n        response = self.process(result)\n        # Custom logic here\n        return response\n</code></pre>"},{"location":"features/mvc-controllers/#testing-controllers","title":"\ud83e\uddea Testing Controllers","text":""},{"location":"features/mvc-controllers/#unit-testing","title":"Unit Testing","text":"<p>Test controllers with mocked dependencies:</p> <pre><code>import pytest\nfrom unittest.mock import Mock, AsyncMock\n\n@pytest.mark.asyncio\nasync def test_get_user_success():\n    # Arrange\n    mock_mediator = Mock()\n    mock_mediator.execute_async = AsyncMock(return_value=OperationResult.success(test_user_dto))\n\n    controller = UsersController(\n        service_provider=mock_service_provider,\n        mapper=mock_mapper,\n        mediator=mock_mediator\n    )\n\n    # Act\n    result = await controller.get_user(\"user123\")\n\n    # Assert\n    assert result == test_user_dto\n    mock_mediator.execute_async.assert_called_once()\n</code></pre>"},{"location":"features/mvc-controllers/#integration-testing","title":"Integration Testing","text":"<p>Test controllers with TestClient:</p> <pre><code>from fastapi.testclient import TestClient\n\ndef test_create_user_integration():\n    # Arrange\n    client = TestClient(app)\n    user_data = {\n        \"email\": \"test@example.com\",\n        \"first_name\": \"John\",\n        \"last_name\": \"Doe\"\n    }\n\n    # Act\n    response = client.post(\"/api/v1/users\", json=user_data)\n\n    # Assert\n    assert response.status_code == 201\n\n    created_user = response.json()\n    assert created_user[\"email\"] == user_data[\"email\"]\n    assert \"id\" in created_user\n</code></pre>"},{"location":"features/mvc-controllers/#api-testing","title":"API Testing","text":"<p>Test the complete API flow:</p> <pre><code>def test_user_crud_flow():\n    client = TestClient(app)\n\n    # Create user\n    create_response = client.post(\"/api/v1/users\", json=test_user_data)\n    assert create_response.status_code == 201\n    user = create_response.json()\n    user_id = user[\"id\"]\n\n    # Get user\n    get_response = client.get(f\"/api/v1/users/{user_id}\")\n    assert get_response.status_code == 200\n    assert get_response.json()[\"id\"] == user_id\n\n    # Update user\n    update_data = {\"first_name\": \"Jane\"}\n    update_response = client.put(f\"/api/v1/users/{user_id}\", json=update_data)\n    assert update_response.status_code == 200\n    assert update_response.json()[\"first_name\"] == \"Jane\"\n\n    # Delete user\n    delete_response = client.delete(f\"/api/v1/users/{user_id}\")\n    assert delete_response.status_code == 204\n\n    # Verify deletion\n    get_deleted_response = client.get(f\"/api/v1/users/{user_id}\")\n    assert get_deleted_response.status_code == 404\n</code></pre>"},{"location":"features/mvc-controllers/#best-practices","title":"\ud83d\ude80 Best Practices","text":""},{"location":"features/mvc-controllers/#1-keep-controllers-thin","title":"1. Keep Controllers Thin","text":"<p>Controllers should delegate to the application layer:</p> <pre><code># Good - Thin controller\nclass UsersController(ControllerBase):\n    @post(\"/\", response_model=UserDto)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n# Avoid - Business logic in controller\nclass UsersController(ControllerBase):\n    @post(\"/\", response_model=UserDto)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        # Validate email\n        if not self.is_valid_email(create_user_dto.email):\n            raise HTTPException(400, \"Invalid email\")\n\n        # Check if user exists\n        existing = await self.user_repo.get_by_email(create_user_dto.email)\n        if existing:\n            raise HTTPException(409, \"User exists\")\n\n        # Create user\n        user = User(...)\n        # ... more business logic\n</code></pre>"},{"location":"features/mvc-controllers/#2-use-dtos-for-api-contracts","title":"2. Use DTOs for API Contracts","text":"<p>Always use DTOs to define your API contracts:</p> <pre><code># API DTOs\nclass CreateUserDto(BaseModel):\n    email: str\n    first_name: str\n    last_name: str\n\nclass UserDto(BaseModel):\n    id: str\n    email: str\n    first_name: str\n    last_name: str\n    created_at: datetime\n\n# Domain entities stay separate\nclass User(Entity[str]):\n    def __init__(self, email: str, first_name: str, last_name: str):\n        # Domain logic\n        pass\n</code></pre>"},{"location":"features/mvc-controllers/#3-consistent-error-handling","title":"3. Consistent Error Handling","text":"<p>Use consistent patterns for error handling:</p> <pre><code>class UsersController(ControllerBase):\n\n    @get(\"/{user_id}\", \n         response_model=UserDto,\n         responses={\n             404: {\"description\": \"User not found\"},\n             400: {\"description\": \"Invalid user ID format\"}\n         })\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        # Validate input format\n        if not self.is_valid_uuid(user_id):\n            return self.bad_request(\"Invalid user ID format\")\n\n        # Execute query\n        query = GetUserByIdQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n\n        # Process will handle 404 automatically\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#4-document-your-apis","title":"4. Document Your APIs","text":"<p>Provide comprehensive API documentation:</p> <pre><code>class UsersController(ControllerBase):\n\n    @post(\"/\",\n          response_model=UserDto,\n          status_code=status.HTTP_201_CREATED,\n          summary=\"Create a new user\",\n          description=\"Creates a new user account in the system\",\n          response_description=\"The created user\",\n          tags=[\"User Management\"])\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        \"\"\"\n        Create a new user account.\n\n        - **email**: User's email address (must be unique)\n        - **first_name**: User's first name\n        - **last_name**: User's last name\n\n        Returns the created user with generated ID and timestamps.\n        \"\"\"\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#5-version-your-apis","title":"5. Version Your APIs","text":"<p>Plan for API versioning:</p> <pre><code># v1 controller\nclass V1UsersController(ControllerBase):\n    def __init__(self, service_provider, mapper, mediator):\n        super().__init__(service_provider, mapper, mediator)\n```python\nfrom neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.mvc import ControllerDiscovery\n\ndef create_pizzeria_app():\n    \"\"\"Configure Mario's Pizzeria application with controllers\"\"\"\n    builder = WebApplicationBuilder()\n\n    # Configure services\n    builder.services.add_mediator()\n    builder.services.add_auto_mapper()\n\n    # Add controllers with automatic discovery\n    builder.services.add_controllers([\n        \"api.controllers.orders_controller\",\n        \"api.controllers.menu_controller\", \n        \"api.controllers.kitchen_controller\",\n        \"api.controllers.reports_controller\",\n        \"api.controllers.auth_controller\"\n    ])\n\n    # Build application\n    app = builder.build()\n\n    # Configure controller routes with prefixes\n    app.include_router(OrdersController().router, prefix=\"/api/orders\", tags=[\"Orders\"])\n    app.include_router(MenuController().router, prefix=\"/api/menu\", tags=[\"Menu\"])\n    app.include_router(KitchenController().router, prefix=\"/api/kitchen\", tags=[\"Kitchen\"])\n    app.include_router(ReportsController().router, prefix=\"/api/reports\", tags=[\"Reports\"])\n    app.include_router(AuthController().router, prefix=\"/api/auth\", tags=[\"Authentication\"])\n\n    # Add exception handlers\n    app.add_exception_handler(PizzeriaException, pizzeria_exception_handler)\n    app.add_exception_handler(RequestValidationError, validation_exception_handler)\n\n    return app\n\n# Environment-specific controller registration\ndef configure_development_controllers(builder: WebApplicationBuilder):\n    \"\"\"Add development-specific controllers\"\"\"\n    # Add mock data controller for testing\n    builder.services.add_controller(MockDataController)\n\ndef configure_production_controllers(builder: WebApplicationBuilder):\n    \"\"\"Add production-specific controllers\"\"\"\n    # Add monitoring and health check controllers\n    builder.services.add_controller(HealthController)\n    builder.services.add_controller(MetricsController)\n</code></pre>"},{"location":"features/mvc-controllers/#controller-middleware-and-interceptors","title":"Controller Middleware and Interceptors","text":"<p>Add cross-cutting concerns to controllers:</p> <pre><code>from fastapi import Request, Response\nfrom fastapi.middleware.base import BaseHTTPMiddleware\nimport time\nimport logging\n\nclass PizzeriaRequestLoggingMiddleware(BaseHTTPMiddleware):\n    \"\"\"Log all pizzeria API requests\"\"\"\n\n    async def dispatch(self, request: Request, call_next):\n        start_time = time.time()\n\n        # Log incoming request\n        logging.info(f\"Incoming {request.method} {request.url}\")\n\n        # Process request\n        response = await call_next(request)\n\n        # Log response\n        process_time = time.time() - start_time\n        logging.info(f\"Completed {request.method} {request.url} - \"\n                    f\"Status: {response.status_code} - \"\n                    f\"Duration: {process_time:.2f}s\")\n\n        return response\n\nclass OrderValidationMiddleware(BaseHTTPMiddleware):\n    \"\"\"Validate order-related requests\"\"\"\n\n    async def dispatch(self, request: Request, call_next):\n        if request.url.path.startswith(\"/api/orders\"):\n            # Add order-specific validation\n            if request.method == \"POST\":\n                # Validate business hours\n                if not self.is_business_hours():\n                    return JSONResponse(\n                        status_code=400,\n                        content={\"error\": \"Pizzeria is currently closed\"}\n                    )\n\n        return await call_next(request)\n\n    def is_business_hours(self) -&gt; bool:\n        \"\"\"Check if pizzeria is open for orders\"\"\"\n        from datetime import datetime\n        now = datetime.now()\n        return 11 &lt;= now.hour &lt;= 22  # Open 11 AM to 10 PM\n\n# Add middleware to application\napp.add_middleware(PizzeriaRequestLoggingMiddleware)\napp.add_middleware(OrderValidationMiddleware)\n</code></pre>"},{"location":"features/mvc-controllers/#controller-testing-patterns","title":"\ud83e\uddea Controller Testing Patterns","text":""},{"location":"features/mvc-controllers/#unit-testing-controllers","title":"Unit Testing Controllers","text":"<p>Test controllers with mocked dependencies:</p> <pre><code>import pytest\nfrom unittest.mock import AsyncMock, Mock\nfrom fastapi.testclient import TestClient\nfrom neuroglia.mediation import OperationResult\n\nclass TestOrdersController:\n    \"\"\"Unit tests for orders controller\"\"\"\n\n    @pytest.fixture\n    def mock_mediator(self):\n        \"\"\"Mock mediator for testing\"\"\"\n        mediator = AsyncMock()\n        return mediator\n\n    @pytest.fixture\n    def orders_controller(self, mock_mediator):\n        \"\"\"Orders controller with mocked dependencies\"\"\"\n        service_provider = Mock()\n        mapper = Mock()\n\n        controller = OrdersController(service_provider, mapper, mock_mediator)\n        return controller\n\n    @pytest.mark.asyncio\n    async def test_place_order_success(self, orders_controller, mock_mediator):\n        \"\"\"Test successful order placement\"\"\"\n        # Arrange\n        order_request = PlaceOrderDto(\n            customer_name=\"John Doe\",\n            customer_phone=\"+1234567890\",\n            customer_address=\"123 Main St\",\n            pizzas=[PizzaOrderDto(name=\"Margherita\", size=\"large\", quantity=1)],\n            payment_method=\"card\"\n        )\n\n        expected_order = OrderDto(\n            id=\"order_123\",\n            customer_name=\"John Doe\",\n            status=\"received\",\n            total_amount=15.99\n        )\n\n        mock_mediator.execute_async.return_value = OperationResult.success(expected_order)\n\n        # Act\n        result = await orders_controller.place_order(order_request)\n\n        # Assert\n        assert result.id == \"order_123\"\n        assert result.customer_name == \"John Doe\"\n        mock_mediator.execute_async.assert_called_once()\n\n    @pytest.mark.asyncio\n    async def test_place_order_validation_error(self, orders_controller, mock_mediator):\n        \"\"\"Test order placement with validation error\"\"\"\n        # Arrange\n        invalid_order = PlaceOrderDto(\n            customer_name=\"\",  # Invalid empty name\n            customer_phone=\"invalid\",  # Invalid phone\n            customer_address=\"\",  # Invalid empty address\n            pizzas=[],  # No pizzas\n            payment_method=\"invalid\"  # Invalid payment method\n        )\n\n        # Act &amp; Assert\n        with pytest.raises(ValidationError):\n            await orders_controller.place_order(invalid_order)\n\n@pytest.mark.integration\nclass TestOrdersControllerIntegration:\n    \"\"\"Integration tests for orders controller\"\"\"\n\n    @pytest.fixture\n    def test_client(self):\n        \"\"\"Test client for integration testing\"\"\"\n        app = create_pizzeria_app()\n        return TestClient(app)\n\n    def test_get_menu_integration(self, test_client):\n        \"\"\"Test menu retrieval integration\"\"\"\n        response = test_client.get(\"/api/menu/pizzas\")\n\n        assert response.status_code == 200\n        menu = response.json()\n        assert isinstance(menu, list)\n\n        # Validate pizza structure\n        if menu:\n            pizza = menu[0]\n            assert \"id\" in pizza\n            assert \"name\" in pizza\n            assert \"base_price\" in pizza\n\n    def test_place_order_integration(self, test_client):\n        \"\"\"Test order placement integration\"\"\"\n        order_data = {\n            \"customer_name\": \"Integration Test Customer\",\n            \"customer_phone\": \"+1234567890\",\n            \"customer_address\": \"123 Test Street, Test City\",\n            \"pizzas\": [\n                {\n                    \"name\": \"Margherita\",\n                    \"size\": \"large\",\n                    \"toppings\": [\"extra_cheese\"],\n                    \"quantity\": 1\n                }\n            ],\n            \"payment_method\": \"card\"\n        }\n\n        response = test_client.post(\"/api/orders/\", json=order_data)\n\n        assert response.status_code == 201\n        order = response.json()\n        assert order[\"customer_name\"] == \"Integration Test Customer\"\n        assert order[\"status\"] == \"received\"\n        assert \"id\" in order\n</code></pre>"},{"location":"features/mvc-controllers/#api-documentation-generation","title":"\ufffd API Documentation Generation","text":""},{"location":"features/mvc-controllers/#openapi-configuration","title":"OpenAPI Configuration","text":"<p>Configure comprehensive API documentation:</p> <pre><code>from fastapi import FastAPI\nfrom fastapi.openapi.utils import get_openapi\n\ndef create_pizzeria_app_with_docs():\n    \"\"\"Create Mario's Pizzeria app with enhanced documentation\"\"\"\n    app = create_pizzeria_app()\n\n    # Custom OpenAPI schema\n    def custom_openapi():\n        if app.openapi_schema:\n            return app.openapi_schema\n\n        openapi_schema = get_openapi(\n            title=\"Mario's Pizzeria API\",\n            version=\"1.0.0\",\n            description=\"\"\"\n            # \ud83c\udf55 Mario's Pizzeria API\n\n            Welcome to Mario's Pizzeria API! This API provides comprehensive \n            functionality for managing pizza orders, menu items, kitchen workflow, \n            and customer interactions.\n\n            ## Features\n\n            - **Order Management**: Place, track, and manage pizza orders\n            - **Menu Administration**: Manage pizzas, toppings, and availability\n            - **Kitchen Workflow**: Handle order preparation and status updates\n            - **Customer Authentication**: Secure customer account management\n            - **Staff Portal**: Role-based access for staff operations\n            - **Analytics**: Revenue and performance reporting\n\n            ## Authentication\n\n            The API uses OAuth 2.0 with JWT tokens:\n\n            - **Customers**: Phone-based OTP authentication\n            - **Staff**: Username/password with role-based permissions\n\n            ## Rate Limiting\n\n            - **Customers**: 100 requests per hour\n            - **Staff**: 500 requests per hour\n            - **Managers**: Unlimited\n            \"\"\",\n            routes=app.routes,\n        )\n\n        # Add custom tags for better organization\n        openapi_schema[\"tags\"] = [\n            {\n                \"name\": \"Orders\",\n                \"description\": \"Customer order management and tracking\"\n            },\n            {\n                \"name\": \"Menu\",\n                \"description\": \"Pizza menu and item management\"\n            },\n            {\n                \"name\": \"Kitchen\",\n                \"description\": \"Kitchen operations and workflow\"\n            },\n            {\n                \"name\": \"Authentication\",\n                \"description\": \"Customer and staff authentication\"\n            },\n            {\n                \"name\": \"Reports\",\n                \"description\": \"Analytics and reporting (Manager only)\"\n            }\n        ]\n\n        # Add security schemes\n        openapi_schema[\"components\"][\"securitySchemes\"] = {\n            \"BearerAuth\": {\n                \"type\": \"http\",\n                \"scheme\": \"bearer\",\n                \"bearerFormat\": \"JWT\"\n            },\n            \"CustomerAuth\": {\n                \"type\": \"oauth2\",\n                \"flows\": {\n                    \"password\": {\n                        \"tokenUrl\": \"/api/auth/customer/login\",\n                        \"scopes\": {\n                            \"customer\": \"Customer order access\"\n                        }\n                    }\n                }\n            },\n            \"StaffAuth\": {\n                \"type\": \"oauth2\",\n                \"flows\": {\n                    \"password\": {\n                        \"tokenUrl\": \"/api/auth/staff/login\",\n                        \"scopes\": {\n                            \"kitchen\": \"Kitchen operations\",\n                            \"manager\": \"Management functions\"\n                        }\n                    }\n                }\n            }\n        }\n\n        app.openapi_schema = openapi_schema\n        return app.openapi_schema\n\n    app.openapi = custom_openapi\n    return app\n</code></pre>"},{"location":"features/mvc-controllers/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started Guide - Complete pizzeria application tutorial</li> <li>CQRS &amp; Mediation - Command and query handlers used in controllers</li> <li>Dependency Injection - Service registration for controller dependencies</li> <li>Data Access - Repository patterns used by controller commands/queries</li> </ul> <p>This documentation demonstrates MVC controller patterns using Mario's Pizzeria as a consistent example throughout the Neuroglia framework. The examples show real-world API design with authentication, validation, error handling, and comprehensive testing.</p>"},{"location":"features/resilient-handler-discovery/","title":"\ud83d\udee1\ufe0f Resilient Handler Discovery","text":"<p>The Neuroglia framework now includes Resilient Handler Discovery in the Mediator, designed to handle real-world scenarios where packages may have complex dependencies or mixed architectural patterns.</p>"},{"location":"features/resilient-handler-discovery/#problem-solved","title":"\ud83c\udfaf Problem Solved","text":"<p>Previously, <code>Mediator.configure()</code> would fail completely if a package's <code>__init__.py</code> had any import errors, even when the package contained valid handlers that could be imported individually. This blocked automatic discovery in:</p> <ul> <li>Legacy migrations from UseCase patterns to CQRS handlers</li> <li>Mixed codebases with varying dependency graphs  </li> <li>Optional dependencies that may not be available in all environments</li> <li>Modular monoliths with packages containing both new and legacy patterns</li> </ul>"},{"location":"features/resilient-handler-discovery/#how-it-works","title":"\ud83c\udfd7\ufe0f How It Works","text":"<p>The resilient discovery implements a two-stage fallback strategy:</p>"},{"location":"features/resilient-handler-discovery/#stage-1-package-import-original-behavior","title":"Stage 1: Package Import (Original Behavior)","text":"<pre><code># Attempts to import the entire package\nMediator.configure(builder, ['application.runtime_agent.queries'])\n</code></pre> <p>If successful, handlers are discovered and registered normally.</p>"},{"location":"features/resilient-handler-discovery/#stage-2-individual-module-fallback","title":"Stage 2: Individual Module Fallback","text":"<pre><code># If package import fails, falls back to:\n# 1. Discover individual .py files in the package directory\n# 2. Attempt to import each module individually\n# 3. Register handlers from successful imports\n# 4. Skip modules with import failures\n\n# Example fallback discovery:\n# application.runtime_agent.queries.get_worker_query     \u2705 SUCCESS\n# application.runtime_agent.queries.list_workers_query   \u2705 SUCCESS  \n# application.runtime_agent.queries.broken_module        \u274c SKIPPED\n</code></pre>"},{"location":"features/resilient-handler-discovery/#usage-examples","title":"\ud83d\ude80 Usage Examples","text":""},{"location":"features/resilient-handler-discovery/#basic-usage-unchanged","title":"Basic Usage (Unchanged)","text":"<pre><code>from neuroglia.mediation import Mediator\nfrom neuroglia.hosting import WebApplicationBuilder\n\nbuilder = WebApplicationBuilder()\n\n# This now works even if some packages have dependency issues\nMediator.configure(builder, [\n    'application.commands',           # May have legacy UseCase imports\n    'application.queries',            # Clean CQRS handlers\n    'application.event_handlers'      # Mixed dependencies\n])\n\napp = builder.build()\n</code></pre>"},{"location":"features/resilient-handler-discovery/#mixed-legacymodern-codebase","title":"Mixed Legacy/Modern Codebase","text":"<pre><code># Your package structure:\n# application/\n# \u251c\u2500\u2500 __init__.py                    # \u274c Imports missing UseCase class\n# \u251c\u2500\u2500 legacy_use_cases.py           # \u274c Uses old patterns\n# \u2514\u2500\u2500 queries/\n#     \u251c\u2500\u2500 __init__.py               # \u2705 Clean file\n#     \u251c\u2500\u2500 get_user_query.py         # \u2705 Valid QueryHandler\n#     \u2514\u2500\u2500 list_users_query.py       # \u2705 Valid QueryHandler\n\n# This now works! Handlers are discovered from individual modules\nMediator.configure(builder, ['application.queries'])\n</code></pre>"},{"location":"features/resilient-handler-discovery/#debugging-discovery-issues","title":"Debugging Discovery Issues","text":"<pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\n\n# Enable detailed logging to see what's discovered vs skipped\nMediator.configure(builder, ['your.package.name'])\n\n# Sample output:\n# WARNING: Package import failed for 'application.queries': UseCase not found\n# INFO: Attempting fallback: scanning individual modules\n# DEBUG: Discovered submodule: application.queries.get_user_query\n# DEBUG: Discovered submodule: application.queries.list_users_query\n# INFO: Successfully registered 2 handlers from submodule: application.queries.get_user_query\n# INFO: Fallback succeeded: registered 4 handlers from individual modules\n</code></pre>"},{"location":"features/resilient-handler-discovery/#logging-and-diagnostics","title":"\ud83d\udd0d Logging and Diagnostics","text":"<p>The resilient discovery provides comprehensive logging at different levels:</p>"},{"location":"features/resilient-handler-discovery/#info-level-summary-information","title":"INFO Level - Summary Information","text":"<pre><code>INFO: Successfully registered 3 handlers from package: application.commands\nINFO: Fallback succeeded: registered 2 handlers from individual modules in 'application.queries'\nINFO: Handler discovery completed: 5 total handlers registered from 2 module specifications\n</code></pre>"},{"location":"features/resilient-handler-discovery/#warning-level-import-issues","title":"WARNING Level - Import Issues","text":"<pre><code>WARNING: Package import failed for 'application.queries': cannot import name 'UseCase'\nWARNING: No submodules discovered for package: broken.package\nWARNING: Error registering handlers from module application.legacy: circular import\n</code></pre>"},{"location":"features/resilient-handler-discovery/#debug-level-detailed-discovery","title":"DEBUG Level - Detailed Discovery","text":"<pre><code>DEBUG: Attempting to load package: application.queries\nDEBUG: Found 3 potential submodules in application.queries\nDEBUG: Discovered submodule: application.queries.get_user_query\nDEBUG: Successfully registered QueryHandler: GetUserQueryHandler from application.queries.get_user_query\nDEBUG: Skipping submodule 'application.queries.broken_module': ImportError\n</code></pre>"},{"location":"features/resilient-handler-discovery/#best-practices","title":"\ud83e\uddea Best Practices","text":""},{"location":"features/resilient-handler-discovery/#1-incremental-migration-strategy","title":"1. Incremental Migration Strategy","text":"<pre><code># Start with clean packages, gradually add legacy ones\nmodules = [\n    'application.commands.user',      # \u2705 Clean CQRS handlers\n    'application.queries.user',       # \u2705 Clean CQRS handlers  \n    'application.legacy.commands',    # \u26a0\ufe0f  Mixed patterns - will use fallback\n]\n\nMediator.configure(builder, modules)\n</code></pre>"},{"location":"features/resilient-handler-discovery/#2-package-organization","title":"2. Package Organization","text":"<pre><code># Recommended: Separate clean handlers from legacy code\napplication/\n\u251c\u2500\u2500 handlers/              # \u2705 Clean CQRS handlers only\n\u2502   \u251c\u2500\u2500 commands/\n\u2502   \u2514\u2500\u2500 queries/\n\u2514\u2500\u2500 legacy/               # \u26a0\ufe0f  Old patterns with complex dependencies\n    \u251c\u2500\u2500 use_cases/\n    \u2514\u2500\u2500 services/\n</code></pre>"},{"location":"features/resilient-handler-discovery/#3-gradual-cleanup","title":"3. Gradual Cleanup","text":"<pre><code># As you migrate legacy code, packages will automatically\n# switch from fallback discovery to normal discovery\n# No changes needed in configuration!\n\n# Before migration (uses fallback):\n# WARNING: Package import failed, using fallback discovery\n\n# After migration (normal discovery):  \n# INFO: Successfully registered 5 handlers from package: application.commands\n</code></pre>"},{"location":"features/resilient-handler-discovery/#advanced-configuration","title":"\ud83d\udd27 Advanced Configuration","text":""},{"location":"features/resilient-handler-discovery/#individual-module-specification","title":"Individual Module Specification","text":"<p>You can also specify individual modules instead of packages: <pre><code>Mediator.configure(builder, [\n    'application.commands.create_user_command',\n    'application.commands.update_user_command',\n    'application.queries.get_user_query'\n])\n</code></pre></p>"},{"location":"features/resilient-handler-discovery/#error-handling","title":"Error Handling","text":"<pre><code>try:\n    Mediator.configure(builder, ['your.package'])\nexcept Exception as e:\n    # Resilient discovery should prevent most exceptions,\n    # but you can still catch unexpected errors\n    logger.error(f\"Handler discovery failed: {e}\")\n</code></pre>"},{"location":"features/resilient-handler-discovery/#migration-from-manual-registration","title":"\ud83d\udea8 Migration from Manual Registration","text":""},{"location":"features/resilient-handler-discovery/#before-manual-workaround","title":"Before (Manual Workaround)","text":"<pre><code># Old approach - manual registration due to import failures\ntry:\n    from application.queries.get_user_query import GetUserQueryHandler\n    from application.queries.list_users_query import ListUsersQueryHandler\n\n    builder.services.add_scoped(GetUserQueryHandler)\n    builder.services.add_scoped(ListUsersQueryHandler)\n    log.debug(\"Manually registered query handlers\")\nexcept ImportError as e:\n    log.warning(f\"Could not register handlers: {e}\")\n</code></pre>"},{"location":"features/resilient-handler-discovery/#after-automatic-discovery","title":"After (Automatic Discovery)","text":"<pre><code># New approach - automatic resilient discovery\nMediator.configure(builder, ['application.queries'])\n# That's it! No manual registration needed\n</code></pre>"},{"location":"features/resilient-handler-discovery/#important-notes","title":"\u26a0\ufe0f Important Notes","text":""},{"location":"features/resilient-handler-discovery/#backward-compatibility","title":"Backward Compatibility","text":"<ul> <li>100% backward compatible - existing code continues to work unchanged</li> <li>No breaking changes - all existing <code>Mediator.configure()</code> calls work as before</li> <li>Enhanced behavior - only adds fallback capability when needed</li> </ul>"},{"location":"features/resilient-handler-discovery/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Package discovery first - normal path is unchanged and just as fast</li> <li>Fallback only when needed - individual module discovery only triggers on import failures</li> <li>Directory scanning - minimal filesystem operations, cached results</li> <li>Logging overhead - debug logging can be disabled in production</li> </ul>"},{"location":"features/resilient-handler-discovery/#limitations","title":"Limitations","text":"<ul> <li>Directory structure dependent - requires standard Python package layout</li> <li>Search paths - looks in <code>src/</code>, <code>./</code>, and <code>app/</code> directories</li> <li>File system access - requires read permissions to package directories</li> </ul>"},{"location":"features/resilient-handler-discovery/#benefits","title":"\ud83c\udf89 Benefits","text":""},{"location":"features/resilient-handler-discovery/#for-developers","title":"For Developers","text":"<ul> <li>Reduced friction during legacy code migration</li> <li>Automatic discovery without manual registration</li> <li>Clear diagnostics about what was discovered vs skipped</li> <li>Incremental adoption of CQRS patterns</li> </ul>"},{"location":"features/resilient-handler-discovery/#for-projects","title":"For Projects","text":"<ul> <li>Mixed architectural patterns supported</li> <li>Gradual modernization without breaking changes</li> <li>Complex dependency graphs handled gracefully</li> <li>Better development experience with detailed logging</li> </ul>"},{"location":"features/resilient-handler-discovery/#for-teams","title":"For Teams","text":"<ul> <li>Parallel development - teams can work on different parts without breaking discovery</li> <li>Easier onboarding - less manual configuration needed</li> <li>Reduced support burden - fewer \"handler not found\" issues</li> </ul> <p>The resilient discovery makes the Neuroglia framework significantly more robust for real-world codebases with complex dependencies and mixed architectural patterns! \ud83c\udfaf</p>"},{"location":"features/resource-oriented-architecture/","title":"\ud83c\udfaf Resource Oriented Architecture (ROA)","text":"<p>Resource Oriented Architecture is a powerful pattern for building systems that manage resources through their lifecycle, similar to how Kubernetes manages cluster resources. Neuroglia provides comprehensive support for ROA patterns including watchers, controllers, and reconciliation loops.</p>"},{"location":"features/resource-oriented-architecture/#overview","title":"\ud83c\udfaf Overview","text":"<p>ROA provides:</p> <ul> <li>\ud83d\udcca Resource Management: Declarative resource definitions with desired vs actual state</li> <li>\ud83d\udc40 Watchers: Continuous monitoring of resource changes through polling or event streams</li> <li>\ud83c\udfae Controllers: Business logic that responds to resource changes and implements state transitions</li> <li>\ud83d\udd04 Reconciliation: Periodic loops that ensure system consistency and handle drift detection</li> <li>\ud83d\udee1\ufe0f Safety Mechanisms: Timeout handling, error recovery, and corrective actions</li> </ul>"},{"location":"features/resource-oriented-architecture/#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<pre><code>graph TB\n    subgraph \"\ud83d\udcca Resource Layer\"\n        A[Resource Definition]\n        B[Resource Storage]\n        C[Resource Events]\n    end\n\n    subgraph \"\ud83d\udc40 Observation Layer\"\n        D[Watcher] --&gt; E[Event Stream]\n        F[Poller] --&gt; G[Change Detection]\n    end\n\n    subgraph \"\ud83c\udfae Control Layer\"\n        H[Controller] --&gt; I[Business Logic]\n        I --&gt; J[State Transitions]\n        I --&gt; K[Action Execution]\n    end\n\n    subgraph \"\ud83d\udd04 Reconciliation Layer\"\n        L[Reconciliation Loop] --&gt; M[Drift Detection]\n        M --&gt; N[Corrective Actions]\n        N --&gt; O[State Restoration]\n    end\n\n    subgraph \"\ud83d\udee1\ufe0f Safety Layer\"\n        P[Error Handling] --&gt; Q[Retry Logic]\n        Q --&gt; R[Circuit Breaker]\n        R --&gt; S[Timeout Management]\n    end\n\n    A --&gt; B\n    B --&gt; C\n    C --&gt; D\n    C --&gt; F\n    E --&gt; H\n    G --&gt; H\n    H --&gt; L\n    L --&gt; P\n\n    style A fill:#e3f2fd\n    style H fill:#f3e5f5\n    style L fill:#e8f5e8\n    style P fill:#fff3e0</code></pre>"},{"location":"features/resource-oriented-architecture/#core-components","title":"\ud83c\udfd7\ufe0f Core Components","text":""},{"location":"features/resource-oriented-architecture/#resource-definition","title":"Resource Definition","text":"<p>Resources are declarative objects that define desired state:</p> <pre><code>@dataclass\nclass LabInstanceResource:\n    api_version: str = \"lab.neuroglia.com/v1\"\n    kind: str = \"LabInstance\"\n    metadata: Dict[str, Any] = None\n    spec: Dict[str, Any] = None      # Desired state\n    status: Dict[str, Any] = None    # Current state\n</code></pre>"},{"location":"features/resource-oriented-architecture/#watcher-pattern","title":"Watcher Pattern","text":"<p>Watchers continuously monitor resources for changes:</p> <pre><code>class LabInstanceWatcher:\n    async def start_watching(self):\n        while self.is_running:\n            # Poll for changes since last known version\n            changes = self.storage.list_resources(since_version=self.last_resource_version)\n\n            for resource in changes:\n                await self._handle_resource_change(resource)\n\n            await asyncio.sleep(self.poll_interval)\n</code></pre>"},{"location":"features/resource-oriented-architecture/#controller-pattern","title":"Controller Pattern","text":"<p>Controllers respond to resource changes with business logic:</p> <pre><code>class LabInstanceController:\n    async def handle_resource_event(self, resource: LabInstanceResource):\n        current_state = resource.status.get('state')\n\n        if current_state == ResourceState.PENDING.value:\n            await self._start_provisioning(resource)\n        elif current_state == ResourceState.PROVISIONING.value:\n            await self._check_provisioning_status(resource)\n</code></pre>"},{"location":"features/resource-oriented-architecture/#reconciliation-loop","title":"Reconciliation Loop","text":"<p>Reconcilers ensure eventual consistency:</p> <pre><code>class LabInstanceScheduler:\n    async def start_reconciliation(self):\n        while self.is_running:\n            await self._reconcile_all_resources()\n            await asyncio.sleep(self.reconcile_interval)\n\n    async def _reconcile_resource(self, resource):\n        # Check for stuck states, timeouts, and drift\n        # Take corrective actions as needed\n</code></pre>"},{"location":"features/resource-oriented-architecture/#key-patterns","title":"\ud83d\ude80 Key Patterns","text":""},{"location":"features/resource-oriented-architecture/#1-declarative-state-management","title":"1. Declarative State Management","text":"<p>Resources define what should exist, not how to create it:</p> <pre><code># Desired state (spec)\nspec = {\n    'template': 'python-basics',\n    'duration': '60m',\n    'studentEmail': 'student@example.com'\n}\n\n# Current state (status)\nstatus = {\n    'state': 'ready',\n    'endpoint': 'https://lab-instance.example.com',\n    'readyAt': '2025-09-09T21:34:19Z'\n}\n</code></pre>"},{"location":"features/resource-oriented-architecture/#2-event-driven-processing","title":"2. Event-Driven Processing","text":"<p>Watchers detect changes and notify controllers immediately:</p> <pre><code>Resource Change \u2192 Watcher Detection \u2192 Controller Response \u2192 State Update\n</code></pre>"},{"location":"features/resource-oriented-architecture/#3-asynchronous-reconciliation","title":"3. Asynchronous Reconciliation","text":"<p>Controllers handle immediate responses while reconcilers provide safety:</p> <pre><code># Controller: Immediate response to events\nasync def handle_resource_event(self, resource):\n    if resource.state == PENDING:\n        await self.start_provisioning(resource)\n\n# Reconciler: Periodic safety checks\nasync def reconcile_resource(self, resource):\n    if self.is_stuck_provisioning(resource):\n        await self.mark_as_failed(resource)\n</code></pre>"},{"location":"features/resource-oriented-architecture/#4-state-machine-implementation","title":"4. State Machine Implementation","text":"<p>Resources progress through well-defined states:</p> <pre><code>PENDING \u2192 PROVISIONING \u2192 READY \u2192 (cleanup) \u2192 DELETING \u2192 DELETED\n    \u2193                      \u2193\n  FAILED              \u2190 FAILED\n</code></pre>"},{"location":"features/resource-oriented-architecture/#execution-model","title":"\u26a1 Execution Model","text":""},{"location":"features/resource-oriented-architecture/#timing-and-coordination","title":"Timing and Coordination","text":"<ul> <li>Watchers: Poll every 2-5 seconds for near-real-time responsiveness</li> <li>Controllers: Respond immediately to detected changes</li> <li>Reconcilers: Run every 10-30 seconds for consistency checks</li> </ul>"},{"location":"features/resource-oriented-architecture/#concurrent-processing","title":"Concurrent Processing","text":"<p>All components run concurrently:</p> <pre><code>async def main():\n    # Start all components concurrently\n    watcher_task = asyncio.create_task(watcher.start_watching())\n    scheduler_task = asyncio.create_task(scheduler.start_reconciliation())\n\n    # Controllers are event-driven (no separate task needed)\n    watcher.add_event_handler(controller.handle_resource_event)\n</code></pre>"},{"location":"features/resource-oriented-architecture/#safety-and-reliability","title":"\ud83d\udee1\ufe0f Safety and Reliability","text":""},{"location":"features/resource-oriented-architecture/#timeout-handling","title":"Timeout Handling","text":"<p>Reconcilers detect and handle stuck states:</p> <pre><code>if resource.state == PROVISIONING and age &gt; timeout_threshold:\n    await self.mark_as_failed(resource, \"Provisioning timeout\")\n</code></pre>"},{"location":"features/resource-oriented-architecture/#error-recovery","title":"Error Recovery","text":"<p>Controllers and reconcilers implement retry logic:</p> <pre><code>try:\n    await self.provision_lab_instance(resource)\nexcept Exception as e:\n    resource.status['retries'] = resource.status.get('retries', 0) + 1\n    if resource.status['retries'] &lt; max_retries:\n        await self.schedule_retry(resource)\n    else:\n        await self.mark_as_failed(resource, str(e))\n</code></pre>"},{"location":"features/resource-oriented-architecture/#drift-detection","title":"Drift Detection","text":"<p>Reconcilers verify that actual state matches desired state:</p> <pre><code>async def check_drift(self, resource):\n    actual_state = await self.get_actual_infrastructure_state(resource)\n    desired_state = resource.spec\n\n    if actual_state != desired_state:\n        await self.correct_drift(resource, actual_state, desired_state)\n</code></pre>"},{"location":"features/resource-oriented-architecture/#observability","title":"\ud83d\udcca Observability","text":""},{"location":"features/resource-oriented-architecture/#metrics-and-logging","title":"Metrics and Logging","text":"<p>ROA components provide rich observability:</p> <pre><code>logger.info(f\"\ud83d\udd0d Watcher detected change: {resource_id} -&gt; {state}\")\nlogger.info(f\"\ud83c\udfae Controller processing: {resource_id} (state: {state})\")\nlogger.info(f\"\ud83d\udd04 Reconciling {len(resources)} resources\")\nlogger.warning(f\"\u26a0\ufe0f Reconciler: Resource stuck: {resource_id}\")\n</code></pre>"},{"location":"features/resource-oriented-architecture/#resource-versioning","title":"Resource Versioning","text":"<p>Track changes with resource versions:</p> <pre><code>resource.metadata['resourceVersion'] = str(self.next_version())\nresource.metadata['lastModified'] = datetime.now(timezone.utc).isoformat()\n</code></pre>"},{"location":"features/resource-oriented-architecture/#configuration","title":"\ud83d\udd27 Configuration","text":""},{"location":"features/resource-oriented-architecture/#tuning-parameters","title":"Tuning Parameters","text":"<p>Adjust timing for your use case:</p> <pre><code># Development: Fast feedback\nwatcher = LabInstanceWatcher(storage, poll_interval=1.0)\nscheduler = LabInstanceScheduler(storage, reconcile_interval=5.0)\n\n# Production: Balanced performance\nwatcher = LabInstanceWatcher(storage, poll_interval=5.0)\nscheduler = LabInstanceScheduler(storage, reconcile_interval=30.0)\n</code></pre>"},{"location":"features/resource-oriented-architecture/#scaling-considerations","title":"Scaling Considerations","text":"<ul> <li>Multiple Watchers: Use resource sharding for scale</li> <li>Controller Parallelism: Process multiple resources concurrently</li> <li>Reconciler Batching: Group operations for efficiency</li> </ul>"},{"location":"features/resource-oriented-architecture/#use-cases","title":"\ud83c\udfaf Use Cases","text":"<p>ROA is ideal for:</p> <ul> <li>Infrastructure Management: Cloud resources, containers, services</li> <li>Workflow Orchestration: Multi-step processes with dependencies</li> <li>Resource Lifecycle: Provisioning, monitoring, cleanup</li> <li>System Integration: Managing external system state</li> <li>DevOps Automation: CI/CD pipelines, deployment management</li> </ul>"},{"location":"features/resource-oriented-architecture/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\ud83c\udfd7\ufe0f Watcher &amp; Reconciliation Patterns - Detailed pattern explanations</li> <li>\u26a1 Execution Flow - How components coordinate</li> <li>\ud83e\uddea Lab Resource Manager Sample - Complete ROA implementation</li> <li>\ud83c\udfaf CQRS &amp; Mediation - Command/Query patterns used in ROA</li> <li>\ud83d\uddc4\ufe0f Data Access - Repository patterns for resource storage</li> </ul>"},{"location":"features/simple-cqrs/","title":"\ud83c\udfaf Simple CQRS Patterns","text":"<p>This guide shows how to use Neuroglia's simplified CQRS patterns for applications that need clean command/query separation without complex event sourcing or cloud events infrastructure.</p>"},{"location":"features/simple-cqrs/#when-to-use-simple-cqrs","title":"\ud83c\udfaf When to Use Simple CQRS","text":"<p>Use the simple CQRS patterns when you need:</p> <ul> <li>Clean separation of read and write operations</li> <li>Basic validation and business logic handling</li> <li>In-memory testing or simple database operations  </li> <li>Minimal setup without event sourcing complexity</li> <li>Rapid prototyping of business logic</li> </ul> <p>Don't use simple patterns when you need: - Event sourcing and domain events - Cloud events integration - Complex workflow orchestration - Advanced audit trails</p>"},{"location":"features/simple-cqrs/#basic-setup","title":"\ud83c\udfd7\ufe0f Basic Setup","text":""},{"location":"features/simple-cqrs/#minimal-example-5-lines-of-setup","title":"Minimal Example (5 lines of setup)","text":"<pre><code>from neuroglia.mediation import (\n    Command, Query, CommandHandler, QueryHandler,\n    create_simple_app, InMemoryRepository\n)\n\n# One-line app creation\nprovider = create_simple_app(CreateTaskHandler, GetTaskHandler, \n                           repositories=[InMemoryRepository[Task]])\nmediator = provider.get_service(Mediator)\n</code></pre>"},{"location":"features/simple-cqrs/#standard-setup","title":"Standard Setup","text":"<pre><code>from neuroglia.mediation import (\n    add_simple_mediator, register_simple_handlers\n)\nfrom neuroglia.dependency_injection import ServiceCollection\n\n# Create service collection\nservices = ServiceCollection()\n\n# Add simple mediator (no cloud events)\nadd_simple_mediator(services)\n\n# Add repositories\nservices.add_singleton(InMemoryRepository[Task])\n\n# Register handlers\nregister_simple_handlers(services, CreateTaskHandler, GetTaskHandler)\n\n# Build provider\nprovider = services.build()\n</code></pre>"},{"location":"features/simple-cqrs/#complete-working-example","title":"\ud83d\ude80 Complete Working Example","text":""},{"location":"features/simple-cqrs/#1-define-your-models","title":"1. Define Your Models","text":"<pre><code>from dataclasses import dataclass\n\n# Domain model\n@dataclass\nclass Task:\n    id: str\n    title: str\n    completed: bool = False\n\n# DTO for API responses  \n@dataclass\nclass TaskDto:\n    id: str\n    title: str\n    completed: bool\n</code></pre>"},{"location":"features/simple-cqrs/#2-define-commands-and-queries","title":"2. Define Commands and Queries","text":"<pre><code>from neuroglia.mediation import Command, Query\nfrom neuroglia.core.operation_result import OperationResult\n\n@dataclass\nclass CreateTaskCommand(Command[OperationResult[TaskDto]]):\n    title: str\n\n@dataclass  \nclass GetTaskQuery(Query[OperationResult[TaskDto]]):\n    task_id: str\n\n@dataclass\nclass CompleteTaskCommand(Command[OperationResult[TaskDto]]):\n    task_id: str\n</code></pre>"},{"location":"features/simple-cqrs/#3-implement-handlers","title":"3. Implement Handlers","text":"<pre><code>import uuid\nfrom neuroglia.mediation import CommandHandler, QueryHandler\n\nclass CreateTaskHandler(CommandHandler[CreateTaskCommand, OperationResult[TaskDto]]):\n    def __init__(self, repository: InMemoryRepository[Task]):\n        self.repository = repository\n\n    async def handle_async(self, request: CreateTaskCommand) -&gt; OperationResult[TaskDto]:\n        # Validation\n        if not request.title.strip():\n            return self.bad_request(\"Title cannot be empty\")\n\n        # Business logic\n        task = Task(str(uuid.uuid4()), request.title.strip())\n        await self.repository.save_async(task)\n\n        # Return result\n        dto = TaskDto(task.id, task.title, task.completed)\n        return self.created(dto)\n\nclass GetTaskHandler(QueryHandler[GetTaskQuery, OperationResult[TaskDto]]):\n    def __init__(self, repository: InMemoryRepository[Task]):\n        self.repository = repository\n\n    async def handle_async(self, request: GetTaskQuery) -&gt; OperationResult[TaskDto]:\n        task = await self.repository.get_by_id_async(request.task_id)\n\n        if not task:\n            return self.not_found(Task, request.task_id)\n\n        dto = TaskDto(task.id, task.title, task.completed)\n        return self.ok(dto)\n\nclass CompleteTaskHandler(CommandHandler[CompleteTaskCommand, OperationResult[TaskDto]]):\n    def __init__(self, repository: InMemoryRepository[Task]):\n        self.repository = repository\n\n    async def handle_async(self, request: CompleteTaskCommand) -&gt; OperationResult[TaskDto]:\n        task = await self.repository.get_by_id_async(request.task_id)\n\n        if not task:\n            return self.not_found(Task, request.task_id)\n\n        if task.completed:\n            return self.bad_request(\"Task is already completed\")\n\n        # Business logic\n        task.completed = True\n        await self.repository.save_async(task)\n\n        dto = TaskDto(task.id, task.title, task.completed)\n        return self.ok(dto)\n</code></pre>"},{"location":"features/simple-cqrs/#4-create-and-use-your-application","title":"4. Create and Use Your Application","text":"<pre><code>import asyncio\n\nasync def main():\n    # Create app with ultra-simple setup\n    provider = create_simple_app(\n        CreateTaskHandler, \n        GetTaskHandler,\n        CompleteTaskHandler,\n        repositories=[InMemoryRepository[Task]]\n    )\n\n    mediator = provider.get_service(Mediator)\n\n    # Create a task\n    create_result = await mediator.execute_async(\n        CreateTaskCommand(\"Learn Neuroglia CQRS\")\n    )\n\n    if create_result.is_success:\n        print(f\"\u2705 Created: {create_result.data.title}\")\n        task_id = create_result.data.id\n\n        # Complete the task\n        complete_result = await mediator.execute_async(\n            CompleteTaskCommand(task_id)\n        )\n\n        if complete_result.is_success:\n            print(f\"\u2705 Completed: {complete_result.data.title}\")\n\n        # Get the task\n        get_result = await mediator.execute_async(GetTaskQuery(task_id))\n\n        if get_result.is_success:\n            task = get_result.data\n            print(f\"\ud83d\udccb Task: {task.title} (completed: {task.completed})\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"features/simple-cqrs/#key-patterns","title":"\ud83d\udca1 Key Patterns","text":""},{"location":"features/simple-cqrs/#validation-and-error-handling","title":"Validation and Error Handling","text":"<pre><code>async def handle_async(self, request: CreateUserCommand) -&gt; OperationResult[UserDto]:\n    # Input validation\n    if not request.email:\n        return self.bad_request(\"Email is required\")\n\n    if \"@\" not in request.email:\n        return self.bad_request(\"Invalid email format\")\n\n    # Business validation\n    existing_user = await self.repository.get_by_email_async(request.email)\n    if existing_user:\n        return self.conflict(f\"User with email {request.email} already exists\")\n\n    # Success path\n    user = User(str(uuid.uuid4()), request.name, request.email)\n    await self.repository.save_async(user)\n\n    dto = UserDto(user.id, user.name, user.email)\n    return self.created(dto)\n</code></pre>"},{"location":"features/simple-cqrs/#repository-patterns","title":"Repository Patterns","text":"<pre><code># Simple in-memory repository (for testing/prototyping)\nfrom neuroglia.mediation import InMemoryRepository\n\nclass UserRepository(InMemoryRepository[User]):\n    async def get_by_email_async(self, email: str) -&gt; Optional[User]:\n        for user in self._storage.values():\n            if user.email == email:\n                return user\n        return None\n</code></pre>"},{"location":"features/simple-cqrs/#query-result-patterns","title":"Query Result Patterns","text":"<pre><code># Single item query\n@dataclass\nclass GetUserQuery(Query[OperationResult[UserDto]]):\n    user_id: str\n\n# List query\n@dataclass  \nclass ListUsersQuery(Query[OperationResult[List[UserDto]]]):\n    include_inactive: bool = False\n\n# Search query\n@dataclass\nclass SearchUsersQuery(Query[OperationResult[List[UserDto]]]):\n    search_term: str\n    page: int = 1\n    page_size: int = 10\n</code></pre>"},{"location":"features/simple-cqrs/#configuration-options","title":"\ud83d\udd27 Configuration Options","text":""},{"location":"features/simple-cqrs/#simple-application-settings","title":"Simple Application Settings","text":"<p>Instead of the full <code>ApplicationSettings</code>, use <code>SimpleApplicationSettings</code> for basic apps:</p> <pre><code>from neuroglia.mediation import SimpleApplicationSettings\n\n@dataclass\nclass MyAppSettings(SimpleApplicationSettings):\n    app_name: str = \"Task Manager\"\n    max_tasks_per_user: int = 100\n    enable_notifications: bool = True\n</code></pre>"},{"location":"features/simple-cqrs/#environment-integration","title":"Environment Integration","text":"<pre><code>import os\n\nsettings = SimpleApplicationSettings(\n    app_name=os.getenv(\"APP_NAME\", \"My App\"),\n    debug=os.getenv(\"DEBUG\", \"false\").lower() == \"true\",\n    database_url=os.getenv(\"DATABASE_URL\")\n)\n</code></pre>"},{"location":"features/simple-cqrs/#testing-patterns","title":"\ud83e\uddea Testing Patterns","text":""},{"location":"features/simple-cqrs/#unit-testing-handlers","title":"Unit Testing Handlers","text":"<pre><code>import pytest\nfrom unittest.mock import AsyncMock\n\n@pytest.mark.asyncio\nasync def test_create_task_success():\n    # Arrange\n    repository = AsyncMock(spec=InMemoryRepository[Task])\n    handler = CreateTaskHandler(repository)\n    command = CreateTaskCommand(\"Test task\")\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n    assert result.data.title == \"Test task\"\n    repository.save_async.assert_called_once()\n\n@pytest.mark.asyncio\nasync def test_create_task_empty_title():\n    # Arrange\n    repository = AsyncMock(spec=InMemoryRepository[Task])\n    handler = CreateTaskHandler(repository)\n    command = CreateTaskCommand(\"\")\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert not result.is_success\n    assert result.status_code == 400\n    assert \"empty\" in result.error_message.lower()\n</code></pre>"},{"location":"features/simple-cqrs/#integration-testing","title":"Integration Testing","text":"<pre><code>@pytest.mark.asyncio\nasync def test_complete_workflow():\n    # Create application\n    provider = create_simple_app(\n        CreateTaskHandler, \n        GetTaskHandler,\n        CompleteTaskHandler,\n        repositories=[InMemoryRepository[Task]]\n    )\n\n    mediator = provider.get_service(Mediator)\n\n    # Test complete workflow\n    create_result = await mediator.execute_async(CreateTaskCommand(\"Test\"))\n    assert create_result.is_success\n\n    task_id = create_result.data.id\n\n    get_result = await mediator.execute_async(GetTaskQuery(task_id))\n    assert get_result.is_success\n    assert not get_result.data.completed\n\n    complete_result = await mediator.execute_async(CompleteTaskCommand(task_id))\n    assert complete_result.is_success\n    assert complete_result.data.completed\n</code></pre>"},{"location":"features/simple-cqrs/#when-to-upgrade","title":"\ud83d\ude80 When to Upgrade","text":"<p>Consider upgrading to the full Neuroglia framework features when you need:</p>"},{"location":"features/simple-cqrs/#event-sourcing","title":"Event Sourcing","text":"<pre><code># Upgrade to event sourcing when you need:\n# - Complete audit trails\n# - Event replay capabilities  \n# - Complex business workflows\n# - Temporal queries (\"what was the state at time X?\")\n</code></pre>"},{"location":"features/simple-cqrs/#cloud-events","title":"Cloud Events","text":"<pre><code># Upgrade to cloud events when you need:\n# - Microservice integration\n# - Event-driven architecture\n# - Cross-system communication\n# - Reliable event delivery\n</code></pre>"},{"location":"features/simple-cqrs/#domain-events","title":"Domain Events","text":"<pre><code># Upgrade to domain events when you need:\n# - Side effects from business operations\n# - Decoupled business logic\n# - Complex business rules\n# - Integration events\n</code></pre>"},{"location":"features/simple-cqrs/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Framework overview</li> <li>CQRS &amp; Mediation - Advanced CQRS patterns</li> <li>Dependency Injection - Advanced DI patterns</li> <li>Data Access - Repository patterns and persistence</li> </ul>"},{"location":"features/watcher-reconciliation-execution/","title":"How Watcher and Reconciliation Loop Execute","text":"<p>This document provides a detailed explanation of how the Resource Watcher and Reconciliation Loop patterns execute in our Resource Oriented Architecture (ROA) implementation.</p>"},{"location":"features/watcher-reconciliation-execution/#execution-flow-overview","title":"\ud83d\udd04 Execution Flow Overview","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Resource       \u2502    \u2502  Resource       \u2502    \u2502  Background     \u2502\n\u2502  Watcher        \u2502    \u2502  Controller     \u2502    \u2502  Scheduler      \u2502\n\u2502                 \u2502    \u2502                 \u2502    \u2502                 \u2502\n\u2502 \u2022 Polls storage \u2502\u2500\u2500\u2500\u25b6\u2502 \u2022 Reconciles    \u2502\u25c4\u2500\u2500\u25b6\u2502 \u2022 Monitors all  \u2502\n\u2502 \u2022 Detects \u0394     \u2502    \u2502   resources     \u2502    \u2502   resources     \u2502\n\u2502 \u2022 Emits events  \u2502    \u2502 \u2022 Updates state \u2502    \u2502 \u2022 Enforces      \u2502\n\u2502 \u2022 Triggers      \u2502    \u2502 \u2022 Publishes     \u2502    \u2502   lifecycle     \u2502\n\u2502   reconciliation\u2502    \u2502   events        \u2502    \u2502                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                       \u2502                       \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                 \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502    Event Bus &amp;          \u2502\n                    \u2502  Cloud Events           \u2502\n                    \u2502                         \u2502\n                    \u2502 \u2022 Resource created      \u2502\n                    \u2502 \u2022 Resource updated      \u2502\n                    \u2502 \u2022 Status changed        \u2502\n                    \u2502 \u2022 Reconciliation done   \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"features/watcher-reconciliation-execution/#1-resource-watcher-execution","title":"1\ufe0f\u20e3 Resource Watcher Execution","text":""},{"location":"features/watcher-reconciliation-execution/#polling-loop-implementation","title":"Polling Loop Implementation","text":"<pre><code>class ResourceWatcherBase:\n    async def _watch_loop(self, namespace=None, label_selector=None):\n        \"\"\"\n        Main watch loop - executes continuously:\n\n        1. List current resources from storage\n        2. Compare with cached resources\n        3. Detect changes (CREATED, UPDATED, DELETED, STATUS_UPDATED)\n        4. Process each change\n        5. Update cache\n        6. Sleep until next poll\n        \"\"\"\n        while self._watching:\n            try:\n                # STEP 1: Get current state from storage\n                current_resources = await self._list_resources(namespace, label_selector)\n                current_resource_map = {r.id: r for r in current_resources}\n\n                # STEP 2: Detect changes by comparing with cache\n                changes = self._detect_changes(current_resource_map)\n\n                # STEP 3: Process each detected change\n                for change in changes:\n                    await self._process_change(change)\n\n                # STEP 4: Update cache with current state\n                self._resource_cache = current_resource_map\n\n                # STEP 5: Wait before next poll\n                await asyncio.sleep(self.watch_interval)\n\n            except Exception as e:\n                log.error(f\"Error in watch loop: {e}\")\n                await asyncio.sleep(self.watch_interval)\n</code></pre>"},{"location":"features/watcher-reconciliation-execution/#change-detection-algorithm","title":"Change Detection Algorithm","text":"<pre><code>def _detect_changes(self, current_resources):\n    \"\"\"\n    Change detection compares current vs cached state:\n\n    \u2022 CREATED: resource_id in current but not in cache\n    \u2022 DELETED: resource_id in cache but not in current  \n    \u2022 UPDATED: generation increased (spec changed)\n    \u2022 STATUS_UPDATED: status fields changed\n    \"\"\"\n    changes = []\n    current_ids = set(current_resources.keys())\n    cached_ids = set(self._resource_cache.keys())\n\n    # New resources (CREATED)\n    for resource_id in current_ids - cached_ids:\n        changes.append(ResourceChangeEvent(\n            change_type=ResourceChangeType.CREATED,\n            resource=current_resources[resource_id]\n        ))\n\n    # Deleted resources (DELETED)  \n    for resource_id in cached_ids - current_ids:\n        changes.append(ResourceChangeEvent(\n            change_type=ResourceChangeType.DELETED,\n            resource=self._resource_cache[resource_id]\n        ))\n\n    # Modified resources (UPDATED/STATUS_UPDATED)\n    for resource_id in current_ids &amp; cached_ids:\n        current = current_resources[resource_id]\n        cached = self._resource_cache[resource_id]\n\n        # Spec changed (generation incremented)\n        if current.metadata.generation &gt; cached.metadata.generation:\n            changes.append(ResourceChangeEvent(\n                change_type=ResourceChangeType.UPDATED,\n                resource=current,\n                old_resource=cached\n            ))\n        # Status changed\n        elif self._has_status_changed(current, cached):\n            changes.append(ResourceChangeEvent(\n                change_type=ResourceChangeType.STATUS_UPDATED,\n                resource=current,\n                old_resource=cached\n            ))\n\n    return changes\n</code></pre>"},{"location":"features/watcher-reconciliation-execution/#event-processing-and-controller-triggering","title":"Event Processing and Controller Triggering","text":"<pre><code>async def _process_change(self, change):\n    \"\"\"\n    When changes are detected:\n\n    1. Call registered change handlers (like controllers)\n    2. Publish CloudEvents to event bus\n    3. Handle errors gracefully\n    \"\"\"\n    # STEP 1: Call all registered handlers\n    for handler in self._change_handlers:\n        try:\n            if asyncio.iscoroutinefunction(handler):\n                await handler(change)  # Triggers controller reconciliation\n            else:\n                handler(change)\n        except Exception as e:\n            log.error(f\"Change handler failed: {e}\")\n\n    # STEP 2: Publish event to broader system\n    await self._publish_change_event(change)\n\n# Example: Lab Instance Watcher\nclass LabInstanceWatcher(ResourceWatcherBase):\n    def __init__(self, repository, controller, event_publisher):\n        super().__init__(event_publisher)\n        # Register controller as change handler\n        self.add_change_handler(self._handle_resource_change)\n\n    async def _handle_resource_change(self, change):\n        \"\"\"Called automatically when changes detected\"\"\"\n        if change.change_type in [ResourceChangeType.CREATED, ResourceChangeType.UPDATED]:\n            # Trigger reconciliation for new/updated resources\n            await self.controller.reconcile(change.resource)\n        elif change.change_type == ResourceChangeType.DELETED:\n            # Trigger cleanup for deleted resources\n            await self.controller.finalize(change.resource)\n</code></pre>"},{"location":"features/watcher-reconciliation-execution/#2-reconciliation-loop-execution","title":"2\ufe0f\u20e3 Reconciliation Loop Execution","text":""},{"location":"features/watcher-reconciliation-execution/#controller-reconciliation-pattern","title":"Controller Reconciliation Pattern","text":"<pre><code>class ResourceControllerBase:\n    async def reconcile(self, resource):\n        \"\"\"\n        Main reconciliation entry point:\n\n        1. Check if reconciliation is needed\n        2. Execute reconciliation logic with timeout\n        3. Handle results (success, failure, requeue)\n        4. Update resource status\n        5. Emit reconciliation events\n        \"\"\"\n        start_time = datetime.now()\n\n        try:\n            # STEP 1: Check if reconciliation needed\n            if not resource.needs_reconciliation():\n                log.debug(f\"Resource {resource.metadata.name} does not need reconciliation\")\n                return\n\n            # STEP 2: Execute reconciliation with timeout\n            result = await asyncio.wait_for(\n                self._do_reconcile(resource),\n                timeout=self._reconciliation_timeout.total_seconds()\n            )\n\n            # STEP 3: Handle reconciliation result\n            await self._handle_reconciliation_result(resource, result, start_time)\n\n        except asyncio.TimeoutError:\n            await self._handle_reconciliation_error(resource, TimeoutError(), start_time)\n        except Exception as e:\n            await self._handle_reconciliation_error(resource, e, start_time)\n</code></pre>"},{"location":"features/watcher-reconciliation-execution/#lab-instance-controller-implementation","title":"Lab Instance Controller Implementation","text":"<pre><code>class LabInstanceController(ResourceControllerBase):\n    async def _do_reconcile(self, resource: LabInstanceRequest):\n        \"\"\"\n        Lab-specific reconciliation logic:\n\n        \u2022 PENDING \u2192 PROVISIONING: Check if should start\n        \u2022 PROVISIONING \u2192 RUNNING: Start container\n        \u2022 RUNNING \u2192 COMPLETED: Monitor completion\n        \u2022 Handle errors and timeouts\n        \"\"\"\n        current_phase = resource.status.phase\n\n        if current_phase == LabInstancePhase.PENDING:\n            if resource.should_start_now():\n                # Time to start - provision container\n                success = await self._provision_lab_instance(resource)\n                return ReconciliationResult.success() if success else ReconciliationResult.requeue()\n            else:\n                # Not time yet - requeue when it should start\n                remaining_time = resource.get_time_until_start()\n                return ReconciliationResult.requeue_after(remaining_time)\n\n        elif current_phase == LabInstancePhase.PROVISIONING:\n            # Check if container is ready\n            if await self._is_container_ready(resource):\n                resource.transition_to_running()\n                await self._repository.save_async(resource)\n                return ReconciliationResult.success()\n            else:\n                # Still provisioning - check again soon\n                return ReconciliationResult.requeue_after(timedelta(seconds=30))\n\n        elif current_phase == LabInstancePhase.RUNNING:\n            # Monitor for completion or timeout\n            if resource.is_expired():\n                await self._timeout_lab_instance(resource)\n                return ReconciliationResult.success()\n            else:\n                # Check again when it should expire\n                remaining_time = resource.get_remaining_duration()\n                return ReconciliationResult.requeue_after(remaining_time)\n\n        # No action needed for terminal phases\n        return ReconciliationResult.success()\n</code></pre>"},{"location":"features/watcher-reconciliation-execution/#3-background-scheduler-as-reconciliation-loop","title":"3\ufe0f\u20e3 Background Scheduler as Reconciliation Loop","text":""},{"location":"features/watcher-reconciliation-execution/#scheduler-service-implementation","title":"Scheduler Service Implementation","text":"<pre><code>class LabInstanceSchedulerService(HostedService):\n    \"\"\"\n    Background service that acts as a reconciliation loop:\n\n    \u2022 Runs independently of watchers\n    \u2022 Periodically scans all resources\n    \u2022 Applies policies and enforces state\n    \u2022 Handles bulk operations\n    \"\"\"\n\n    async def _run_scheduler_loop(self):\n        \"\"\"Main scheduler loop - runs continuously\"\"\"\n        cleanup_counter = 0\n\n        while self._running:\n            try:\n                # PHASE 1: Process scheduled instances (PENDING \u2192 PROVISIONING)\n                await self._process_scheduled_instances()\n\n                # PHASE 2: Monitor running instances (RUNNING state health)\n                await self._process_running_instances()\n\n                # PHASE 3: Periodic cleanup (expired/failed instances)\n                cleanup_counter += self._scheduler_interval\n                if cleanup_counter &gt;= self._cleanup_interval:\n                    await self._cleanup_expired_instances()\n                    cleanup_counter = 0\n\n                # Wait before next iteration\n                await asyncio.sleep(self._scheduler_interval)\n\n            except Exception as e:\n                log.error(f\"Error in scheduler loop: {e}\")\n                await asyncio.sleep(self._scheduler_interval)\n\n    async def _process_scheduled_instances(self):\n        \"\"\"Reconcile PENDING instances that should start\"\"\"\n        try:\n            # Find all pending instances that are scheduled\n            pending_instances = await self._repository.find_scheduled_pending_async()\n\n            for instance in pending_instances:\n                if instance.should_start_now():\n                    # Move toward desired state: PENDING \u2192 PROVISIONING \u2192 RUNNING\n                    await self._start_lab_instance(instance)\n\n        except Exception as e:\n            log.error(f\"Error processing scheduled instances: {e}\")\n\n    async def _process_running_instances(self):\n        \"\"\"Reconcile RUNNING instances for health/completion\"\"\"\n        try:\n            running_instances = await self._repository.find_running_instances_async()\n\n            for instance in running_instances:\n                # Check actual container state vs desired state\n                container_status = await self._container_service.get_container_status_async(\n                    instance.status.container_id\n                )\n\n                # Reconcile based on actual vs desired state\n                if container_status == \"stopped\":\n                    # Container stopped - instance should complete\n                    await self._complete_lab_instance(instance)\n                elif container_status == \"error\":\n                    # Container errored - instance should fail\n                    await self._fail_lab_instance(instance, \"Container error\")\n                elif instance.is_expired():\n                    # Policy violation - enforce timeout\n                    await self._timeout_lab_instance(instance)\n\n        except Exception as e:\n            log.error(f\"Error processing running instances: {e}\")\n</code></pre>"},{"location":"features/watcher-reconciliation-execution/#4-integration-patterns-and-event-flow","title":"4\ufe0f\u20e3 Integration Patterns and Event Flow","text":""},{"location":"features/watcher-reconciliation-execution/#complete-event-flow-example","title":"Complete Event Flow Example","text":"<pre><code>1. User creates LabInstanceRequest\n   \u2514\u2500 Resource saved to storage\n\n2. Watcher detects CREATED event (next poll cycle)\n   \u251c\u2500 Publishes labinstancerequest.created CloudEvent  \n   \u2514\u2500 Triggers controller.reconcile(resource)\n\n3. Controller reconciliation\n   \u251c\u2500 Checks: resource.should_start_now() \u2192 false (scheduled for later)\n   \u2514\u2500 Returns: ReconciliationResult.requeue_after(delay)\n\n4. Scheduler loop (independent polling)\n   \u251c\u2500 Finds pending instances that should start\n   \u251c\u2500 Calls _start_lab_instance(resource)\n   \u2502  \u251c\u2500 Transitions: PENDING \u2192 PROVISIONING\n   \u2502  \u251c\u2500 Creates container\n   \u2502  \u2514\u2500 Transitions: PROVISIONING \u2192 RUNNING\n   \u2514\u2500 Updates resource status in storage\n\n5. Watcher detects STATUS_UPDATED event\n   \u251c\u2500 Publishes labinstancerequest.status_updated CloudEvent\n   \u2514\u2500 Triggers controller.reconcile(resource) again\n\n6. Controller reconciliation (RUNNING phase)\n   \u251c\u2500 Calculates when instance should expire\n   \u2514\u2500 Returns: ReconciliationResult.requeue_after(remaining_time)\n\n7. Time passes... scheduler monitors container health\n\n8. Container completes/fails/times out\n   \u251c\u2500 Scheduler detects state change\n   \u251c\u2500 Updates resource: RUNNING \u2192 COMPLETED/FAILED/TIMEOUT\n   \u2514\u2500 Cleans up container resources\n\n9. Watcher detects final STATUS_UPDATED event\n   \u251c\u2500 Publishes final CloudEvent\n   \u2514\u2500 Controller reconciliation confirms no action needed\n</code></pre>"},{"location":"features/watcher-reconciliation-execution/#timing-and-coordination","title":"Timing and Coordination","text":"Component Frequency Purpose Watcher 5-10 seconds Detect changes, trigger reactive reconciliation Scheduler 30-60 seconds Proactive reconciliation, policy enforcement Controller Event-driven Handle specific resource changes"},{"location":"features/watcher-reconciliation-execution/#error-handling-and-resilience","title":"Error Handling and Resilience","text":"<pre><code># Watcher error handling\nasync def _watch_loop(self):\n    while self._watching:\n        try:\n            # Process changes\n            pass\n        except Exception as e:\n            log.error(f\"Watch loop error: {e}\")\n            await asyncio.sleep(self.watch_interval)  # Continue watching\n\n# Controller error handling  \nasync def reconcile(self, resource):\n    try:\n        result = await asyncio.wait_for(self._do_reconcile(resource), timeout=300)\n    except asyncio.TimeoutError:\n        # Handle timeout - mark for retry\n        result = ReconciliationResult.requeue()\n    except Exception as e:\n        # Handle error - exponential backoff\n        result = ReconciliationResult.failed(e)\n\n# Scheduler error handling\nasync def _run_scheduler_loop(self):\n    while self._running:\n        try:\n            # Process all phases\n            pass\n        except Exception as e:\n            log.error(f\"Scheduler error: {e}\")\n            await asyncio.sleep(self._scheduler_interval)  # Continue scheduling\n</code></pre>"},{"location":"features/watcher-reconciliation-execution/#observability-and-monitoring","title":"\ud83d\udcca Observability and Monitoring","text":""},{"location":"features/watcher-reconciliation-execution/#key-metrics-to-monitor","title":"Key Metrics to Monitor","text":"<pre><code># Watcher metrics\n{\n    \"watch_loop_iterations\": 1234,\n    \"changes_detected\": 56,\n    \"events_published\": 78,\n    \"cache_hit_ratio\": 0.95,\n    \"average_poll_duration\": \"150ms\"\n}\n\n# Controller metrics  \n{\n    \"reconciliations_total\": 234,\n    \"reconciliations_successful\": 220,\n    \"reconciliations_failed\": 4,\n    \"reconciliations_requeued\": 10,\n    \"average_reconciliation_time\": \"2.3s\"\n}\n\n# Scheduler metrics\n{\n    \"scheduler_loop_iterations\": 567,\n    \"resources_processed\": 890,\n    \"state_transitions\": 123,\n    \"cleanup_operations\": 45,\n    \"average_loop_duration\": \"5.2s\"\n}\n</code></pre> <p>This architecture provides a robust, scalable foundation for declarative resource management that automatically maintains desired state while being resilient to failures and providing comprehensive observability.</p>"},{"location":"features/watcher-reconciliation-patterns/","title":"Resource Watcher and Reconciliation Loop Patterns","text":"<p>This document explains how the Resource Watcher and Reconciliation Loop patterns work in our Resource Oriented Architecture (ROA) implementation, providing the foundation for Kubernetes-style declarative resource management.</p>"},{"location":"features/watcher-reconciliation-patterns/#overview","title":"\ud83c\udfaf Overview","text":"<p>The ROA implementation uses two complementary patterns:</p> <ol> <li>Resource Watcher: Detects changes to resources and emits events</li> <li>Reconciliation Loop: Continuously ensures actual state matches desired state</li> </ol> <p>These patterns work together to provide: - Declarative Management: Specify desired state, controllers make it happen - Event-Driven Processing: React to changes as they occur - Self-Healing: Automatically correct drift from desired state - Extensibility: Pluggable controllers for different resource types</p>"},{"location":"features/watcher-reconciliation-patterns/#resource-watcher-pattern","title":"\ud83d\udd0d Resource Watcher Pattern","text":""},{"location":"features/watcher-reconciliation-patterns/#how-the-watcher-works","title":"How the Watcher Works","text":"<pre><code>class ResourceWatcherBase(Generic[TResourceSpec, TResourceStatus]):\n    \"\"\"\n    The watcher follows a polling pattern:\n    1. Periodically lists resources from storage\n    2. Compares current state with cached state\n    3. Detects changes (CREATED, UPDATED, DELETED, STATUS_UPDATED)\n    4. Emits events for detected changes\n    5. Updates cache with current state\n    \"\"\"\n\n    async def _watch_loop(self, namespace=None, label_selector=None):\n        while self._watching:\n            # 1. Get current resources\n            current_resources = await self._list_resources(namespace, label_selector)\n            current_resource_map = {r.id: r for r in current_resources}\n\n            # 2. Detect changes\n            changes = self._detect_changes(current_resource_map)\n\n            # 3. Process each change\n            for change in changes:\n                await self._process_change(change)\n\n            # 4. Update cache\n            self._resource_cache = current_resource_map\n\n            # 5. Wait before next poll\n            await asyncio.sleep(self.watch_interval)\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#change-detection-logic","title":"Change Detection Logic","text":"<p>The watcher detects four types of changes:</p> <pre><code>def _detect_changes(self, current_resources):\n    changes = []\n    current_ids = set(current_resources.keys())\n    cached_ids = set(self._resource_cache.keys())\n\n    # 1. CREATED: New resources that weren't in cache\n    for resource_id in current_ids - cached_ids:\n        changes.append(ResourceChangeEvent(\n            change_type=ResourceChangeType.CREATED,\n            resource=current_resources[resource_id]\n        ))\n\n    # 2. DELETED: Cached resources no longer present\n    for resource_id in cached_ids - current_ids:\n        changes.append(ResourceChangeEvent(\n            change_type=ResourceChangeType.DELETED,\n            resource=self._resource_cache[resource_id]\n        ))\n\n    # 3. UPDATED: Spec changed (generation increment)\n    # 4. STATUS_UPDATED: Status changed (observed generation, etc.)\n    for resource_id in current_ids &amp; cached_ids:\n        current = current_resources[resource_id]\n        cached = self._resource_cache[resource_id]\n\n        if current.metadata.generation &gt; cached.metadata.generation:\n            # Spec was updated\n            changes.append(ResourceChangeEvent(\n                change_type=ResourceChangeType.UPDATED,\n                resource=current,\n                old_resource=cached\n            ))\n        elif self._has_status_changed(current, cached):\n            # Status was updated\n            changes.append(ResourceChangeEvent(\n                change_type=ResourceChangeType.STATUS_UPDATED,\n                resource=current,\n                old_resource=cached\n            ))\n\n    return changes\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#event-processing-and-publishing","title":"Event Processing and Publishing","text":"<p>When changes are detected, the watcher:</p> <pre><code>async def _process_change(self, change):\n    # 1. Call registered change handlers\n    for handler in self._change_handlers:\n        if asyncio.iscoroutinefunction(handler):\n            await handler(change)\n        else:\n            handler(change)\n\n    # 2. Publish CloudEvent\n    await self._publish_change_event(change)\n\nasync def _publish_change_event(self, change):\n    event_type = f\"{resource.kind.lower()}.{change.change_type.value.lower()}\"\n\n    event = CloudEvent(\n        source=f\"watcher/{resource.kind.lower()}\",\n        type=event_type,  # e.g., \"labinstancerequest.created\"\n        subject=f\"{resource.metadata.namespace}/{resource.metadata.name}\",\n        data={\n            \"resourceUid\": resource.id,\n            \"apiVersion\": resource.api_version,\n            \"kind\": resource.kind,\n            \"changeType\": change.change_type.value,\n            \"generation\": resource.metadata.generation,\n            \"observedGeneration\": resource.status.observed_generation\n        }\n    )\n\n    await self.event_publisher.publish_async(event)\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#reconciliation-loop-pattern","title":"\ud83d\udd04 Reconciliation Loop Pattern","text":""},{"location":"features/watcher-reconciliation-patterns/#how-reconciliation-works","title":"How Reconciliation Works","text":"<pre><code>class ResourceControllerBase(Generic[TResourceSpec, TResourceStatus]):\n    \"\"\"\n    Controllers implement the reconciliation pattern:\n    1. Receive resource change events\n    2. Compare current state with desired state\n    3. Take actions to move toward desired state\n    4. Update resource status\n    5. Emit reconciliation events\n    \"\"\"\n\n    async def reconcile(self, resource):\n        # 1. Check if reconciliation is needed\n        if not resource.needs_reconciliation():\n            return\n\n        # 2. Execute reconciliation with timeout\n        result = await asyncio.wait_for(\n            self._do_reconcile(resource),\n            timeout=self._reconciliation_timeout.total_seconds()\n        )\n\n        # 3. Handle result (success, failure, requeue)\n        await self._handle_reconciliation_result(resource, result)\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#reconciliation-states","title":"Reconciliation States","text":"<p>Controllers can return different reconciliation results:</p> <pre><code>class ReconciliationStatus(Enum):\n    SUCCESS = \"Success\"          # Reconciliation completed successfully\n    FAILED = \"Failed\"            # Reconciliation failed, needs attention\n    REQUEUE = \"Requeue\"          # Retry immediately\n    REQUEUE_AFTER = \"RequeueAfter\"  # Retry after specified delay\n\n# Example usage in controller\nasync def _do_reconcile(self, resource):\n    if resource.status.phase == LabInstancePhase.PENDING:\n        if resource.should_start_now():\n            success = await self._start_lab_instance(resource)\n            return ReconciliationResult.success() if success else ReconciliationResult.requeue()\n        else:\n            # Not time to start yet, check again in 30 seconds\n            return ReconciliationResult.requeue_after(timedelta(seconds=30))\n\n    elif resource.status.phase == LabInstancePhase.RUNNING:\n        if resource.is_expired():\n            await self._stop_lab_instance(resource)\n            return ReconciliationResult.success()\n        else:\n            # Check again when it should expire\n            remaining = resource.get_remaining_duration()\n            return ReconciliationResult.requeue_after(remaining)\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#integration-patterns","title":"\ud83d\udd27 Integration Patterns","text":""},{"location":"features/watcher-reconciliation-patterns/#pattern-1-watcher-controller-integration","title":"Pattern 1: Watcher \u2192 Controller Integration","text":"<pre><code># Watcher detects changes and triggers controller\nclass LabInstanceWatcher(ResourceWatcherBase[LabInstanceRequestSpec, LabInstanceRequestStatus]):\n    def __init__(self, repository, controller, event_publisher):\n        super().__init__(event_publisher)\n        self.repository = repository\n        self.controller = controller\n\n        # Register controller as change handler\n        self.add_change_handler(self._handle_resource_change)\n\n    async def _list_resources(self, namespace=None, label_selector=None):\n        return await self.repository.list_async(namespace=namespace)\n\n    async def _handle_resource_change(self, change):\n        \"\"\"Called when resource changes are detected.\"\"\"\n        resource = change.resource\n\n        if change.change_type in [ResourceChangeType.CREATED, ResourceChangeType.UPDATED]:\n            # Trigger reconciliation for created or updated resources\n            await self.controller.reconcile(resource)\n        elif change.change_type == ResourceChangeType.DELETED:\n            # Trigger finalization for deleted resources\n            await self.controller.finalize(resource)\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#pattern-2-background-scheduler-as-reconciliation-loop","title":"Pattern 2: Background Scheduler as Reconciliation Loop","text":"<pre><code>class LabInstanceSchedulerService(HostedService):\n    \"\"\"\n    Background service that acts as a reconciliation loop:\n    1. Periodically scans all resources\n    2. Identifies resources that need reconciliation\n    3. Applies appropriate actions\n    4. Updates resource status\n    \"\"\"\n\n    async def _run_scheduler_loop(self):\n        while self._running:\n            # Reconciliation phases\n            await self._process_scheduled_instances()  # PENDING \u2192 PROVISIONING\n            await self._process_running_instances()    # RUNNING monitoring\n            await self._cleanup_expired_instances()    # TIMEOUT/CLEANUP\n\n            await asyncio.sleep(self._scheduler_interval)\n\n    async def _process_scheduled_instances(self):\n        \"\"\"Reconcile PENDING resources that should be started.\"\"\"\n        pending_instances = await self.repository.find_by_phase_async(LabInstancePhase.PENDING)\n\n        for instance in pending_instances:\n            if instance.should_start_now():\n                # Move toward desired state: PENDING \u2192 PROVISIONING \u2192 RUNNING\n                await self._start_lab_instance(instance)\n\n    async def _process_running_instances(self):\n        \"\"\"Reconcile RUNNING resources for completion/errors.\"\"\"\n        running_instances = await self.repository.find_by_phase_async(LabInstancePhase.RUNNING)\n\n        for instance in running_instances:\n            # Check actual container state vs desired state\n            container_status = await self.container_service.get_container_status_async(\n                instance.status.container_id\n            )\n\n            if container_status == \"stopped\":\n                # Actual state differs from desired, reconcile\n                await self._complete_lab_instance(instance)\n            elif instance.is_expired():\n                # Policy violation, enforce timeout\n                await self._timeout_lab_instance(instance)\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#pattern-3-event-driven-reconciliation","title":"Pattern 3: Event-Driven Reconciliation","text":"<pre><code>class LabInstanceEventHandler:\n    \"\"\"Handle resource events and trigger reconciliation.\"\"\"\n\n    async def handle_lab_instance_created(self, event):\n        \"\"\"When a lab instance is created, ensure it's properly scheduled.\"\"\"\n        resource_id = event.data[\"resourceUid\"]\n        resource = await self.repository.get_by_id_async(resource_id)\n\n        if resource and resource.status.phase == LabInstancePhase.PENDING:\n            # Ensure resource is in scheduling queue\n            await self.controller.reconcile(resource)\n\n    async def handle_lab_instance_updated(self, event):\n        \"\"\"When a lab instance is updated, re-reconcile.\"\"\"\n        resource_id = event.data[\"resourceUid\"]\n        resource = await self.repository.get_by_id_async(resource_id)\n\n        if resource:\n            await self.controller.reconcile(resource)\n\n    async def handle_container_event(self, event):\n        \"\"\"When container state changes, update resource status.\"\"\"\n        container_id = event.data[\"containerId\"]\n\n        # Find resource with this container\n        instances = await self.repository.find_by_container_id_async(container_id)\n\n        for instance in instances:\n            # Reconcile to reflect new container state\n            await self.controller.reconcile(instance)\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#complete-integration-example","title":"\ud83d\ude80 Complete Integration Example","text":"<p>Here's how all patterns work together:</p> <pre><code># 1. Setup watcher and controller\nwatcher = LabInstanceWatcher(repository, controller, event_publisher)\nscheduler = LabInstanceSchedulerService(repository, container_service, event_bus)\n\n# 2. Start background processes\nawait watcher.watch(namespace=\"default\")\nawait scheduler.start_async()\n\n# 3. Create a resource (triggers CREATED event)\nlab_instance = LabInstanceRequest(...)\nawait repository.save_async(lab_instance)\n\n# 4. Watcher detects CREATED event\n# 5. Watcher calls controller.reconcile(lab_instance)\n# 6. Controller checks if action needed (should_start_now?)\n# 7. If not time yet, controller returns REQUEUE_AFTER\n# 8. Scheduler loop independently checks all PENDING resources\n# 9. When time arrives, scheduler starts the lab instance\n# 10. Status update triggers STATUS_UPDATED event\n# 11. Watcher publishes CloudEvent\n# 12. Other services can react to the event\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#observability-and-monitoring","title":"\ud83d\udcca Observability and Monitoring","text":"<p>Both patterns provide rich observability:</p>"},{"location":"features/watcher-reconciliation-patterns/#watcher-metrics","title":"Watcher Metrics","text":"<pre><code>watcher_metrics = {\n    \"is_watching\": watcher.is_watching(),\n    \"cached_resources\": watcher.get_cached_resource_count(),\n    \"watch_interval\": watcher.watch_interval,\n    \"events_published\": watcher.events_published_count,\n    \"change_handlers\": len(watcher._change_handlers)\n}\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#controller-metrics","title":"Controller Metrics","text":"<pre><code>controller_metrics = {\n    \"reconciliations_total\": controller.reconciliation_count,\n    \"reconciliations_successful\": controller.success_count,\n    \"reconciliations_failed\": controller.failure_count,\n    \"average_reconciliation_duration\": controller.avg_duration,\n    \"pending_reconciliations\": controller.queue_size\n}\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#scheduler-metrics","title":"Scheduler Metrics","text":"<pre><code>scheduler_metrics = {\n    \"running\": scheduler._running,\n    \"scheduler_interval\": scheduler._scheduler_interval,\n    \"instances_by_phase\": {\n        phase.value: await repository.count_by_phase_async(phase)\n        for phase in LabInstancePhase\n    },\n    \"processed_this_cycle\": scheduler.processed_count\n}\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#configuration-and-tuning","title":"\u2699\ufe0f Configuration and Tuning","text":""},{"location":"features/watcher-reconciliation-patterns/#watcher-configuration","title":"Watcher Configuration","text":"<pre><code>watcher = LabInstanceWatcher(\n    repository=repository,\n    controller=controller,\n    event_publisher=event_publisher,\n    watch_interval=5.0  # Poll every 5 seconds\n)\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#controller-configuration","title":"Controller Configuration","text":"<pre><code>controller = LabInstanceController(\n    service_provider=service_provider,\n    event_publisher=event_publisher\n)\ncontroller._reconciliation_timeout = timedelta(minutes=10)\ncontroller._max_retry_attempts = 5\n</code></pre>"},{"location":"features/watcher-reconciliation-patterns/#scheduler-configuration","title":"Scheduler Configuration","text":"<pre><code>scheduler = LabInstanceSchedulerService(\n    repository=repository,\n    container_service=container_service,\n    event_bus=event_bus\n)\nscheduler._scheduler_interval = 30      # 30 second reconciliation loop\nscheduler._cleanup_interval = 300       # 5 minute cleanup cycle\n</code></pre> <p>This architecture provides a robust, observable, and extensible foundation for managing resources in a declarative, Kubernetes-style manner while integrating seamlessly with traditional CQRS patterns.</p>"},{"location":"samples/api_gateway/","title":"\ud83d\ude80 API Gateway Sample Application","text":"<p>The API Gateway sample demonstrates how to build a modern microservice gateway using the Neuroglia framework. This application showcases advanced patterns including OAuth2 authentication, external service integration, background task processing, and cloud event handling.</p>"},{"location":"samples/api_gateway/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>Microservice Gateway Patterns: How to build a centralized API gateway for service orchestration</li> <li>OAuth2 Authentication &amp; Authorization: Implementing JWT-based security with Keycloak integration</li> <li>External Service Integration: Connecting to multiple external APIs with proper abstraction</li> <li>Background Task Processing: Asynchronous task execution with Redis-backed job scheduling</li> <li>Object Storage Integration: File management with MinIO S3-compatible storage</li> <li>Cloud Events: Event-driven communication between microservices</li> <li>Advanced Dependency Injection: Complex service configuration and lifetime management</li> </ul>"},{"location":"samples/api_gateway/#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<pre><code>graph TB\n    subgraph \"API Gateway Service\"\n        A[PromptController] --&gt; B[Mediator]\n        B --&gt; C[Command/Query Handlers]\n        C --&gt; D[Domain Models]\n        C --&gt; E[Integration Services]\n\n        F[OAuth2 Middleware] --&gt; A\n        G[Cloud Event Middleware] --&gt; A\n        H[Exception Handling] --&gt; A\n    end\n\n    subgraph \"External Dependencies\"\n        I[Keycloak OAuth2]\n        J[Redis Cache]\n        K[MinIO Storage]\n        L[External APIs]\n        M[Background Tasks]\n    end\n\n    E --&gt; I\n    E --&gt; J\n    E --&gt; K\n    E --&gt; L\n    C --&gt; M</code></pre> <p>The API Gateway follows a distributed microservice pattern where:</p> <ul> <li>Gateway Layer: Centralized entry point for multiple downstream services</li> <li>Authentication Layer: OAuth2/JWT-based security with external identity provider</li> <li>Integration Layer: Multiple external service clients with proper abstraction</li> <li>DTOs: Data transfer objects for external communication</li> </ul>"},{"location":"samples/api_gateway/#key-features-demonstrated","title":"\ud83d\ude80 Key Features Demonstrated","text":""},{"location":"samples/api_gateway/#1-oauth2-authentication-security","title":"1. OAuth2 Authentication &amp; Security","text":"<pre><code># JWT token validation with Keycloak\n@post(\"/item\", response_model=ItemPromptCommandResponseDto)\nasync def create_new_item_prompt(\n    self, \n    command_dto: CreateNewItemPromptCommandDto, \n    key: str = Depends(validate_mosaic_authentication)\n) -&gt; Any:\n    # Protected endpoint with API key validation\n</code></pre>"},{"location":"samples/api_gateway/#2-multi-service-integration","title":"2. Multi-Service Integration","text":"<pre><code># External service clients\nMinioStorageManager.configure(builder)          # Object storage\nMosaicApiClient.configure(builder)              # External API\nAsyncStringCacheRepository.configure(builder)   # Redis caching\nBackgroundTaskScheduler.configure(builder)      # Async processing\n</code></pre>"},{"location":"samples/api_gateway/#3-advanced-domain-model","title":"3. Advanced Domain Model","text":"<pre><code>@map_to(PromptResponseDto)\n@dataclass\nclass PromptResponse:\n    id: str\n    prompt_id: str\n    content: str\n    status: PromptStatus\n    metadata: dict[str, Any]\n    created_at: datetime.datetime\n</code></pre>"},{"location":"samples/api_gateway/#4-background-task-processing","title":"4. Background Task Processing","text":"<pre><code># Asynchronous task execution\nBackgroundTaskScheduler.configure(builder, [\"application.tasks\"])\n\n# Redis-backed job queue\nbackground_job_store: dict[str, str | int] = {\n    \"redis_host\": \"redis47\", \n    \"redis_port\": 6379, \n    \"redis_db\": 0\n}\n</code></pre>"},{"location":"samples/api_gateway/#5-cloud-events-integration","title":"5. Cloud Events Integration","text":"<pre><code># Event publishing and consumption\nCloudEventIngestor.configure(builder, [\"application.events.integration\"])\nCloudEventPublisher.configure(builder)\napp.add_middleware(CloudEventMiddleware, service_provider=app.services)\n</code></pre>"},{"location":"samples/api_gateway/#configuration-settings","title":"\ud83d\udd27 Configuration &amp; Settings","text":""},{"location":"samples/api_gateway/#application-settings","title":"Application Settings","text":"<pre><code>class AiGatewaySettings(ApplicationSettings):\n    # OAuth2 Configuration\n    jwt_authority: str = \"http://keycloak47/realms/mozart\"\n    jwt_audience: str = \"ai-gateways\"\n    required_scope: str = \"api\"\n\n    # External Service Settings\n    s3_endpoint: str                    # MinIO storage\n    connection_strings: dict[str, str]  # Redis, databases\n    mosaic_api_keys: list[str]         # API authentication\n\n    # Background Processing\n    background_job_store: dict[str, str | int]\n    redis_max_connections: int = 10\n</code></pre>"},{"location":"samples/api_gateway/#service-registration","title":"Service Registration","text":"<pre><code># Core framework services\nMapper.configure(builder, application_modules)\nMediator.configure(builder, application_modules)\nJsonSerializer.configure(builder)\n\n# Custom application services\nAsyncStringCacheRepository.configure(builder, Prompt, str)\nBackgroundTaskScheduler.configure(builder, [\"application.tasks\"])\nMinioStorageManager.configure(builder)\nLocalFileSystemManager.configure(builder)\n\n# External integrations\nbuilder.services.add_singleton(AiGatewaySettings, singleton=app_settings)\n</code></pre>"},{"location":"samples/api_gateway/#testing-strategy","title":"\ud83e\uddea Testing Strategy","text":""},{"location":"samples/api_gateway/#unit-tests","title":"Unit Tests","text":"<pre><code>class TestPromptController:\n    def setup_method(self):\n        self.mock_mediator = Mock(spec=Mediator)\n        self.mock_mapper = Mock(spec=Mapper)\n        self.controller = PromptController(\n            service_provider=Mock(),\n            mapper=self.mock_mapper,\n            mediator=self.mock_mediator\n        )\n\n    @pytest.mark.asyncio\n    async def test_create_prompt_success(self):\n        # Test successful prompt creation\n        command_dto = CreateNewItemPromptCommandDto(content=\"test\")\n        result = await self.controller.create_new_item_prompt(command_dto, \"valid-key\")\n\n        assert result.status == \"created\"\n        self.mock_mediator.execute_async.assert_called_once()\n</code></pre>"},{"location":"samples/api_gateway/#integration-tests","title":"Integration Tests","text":"<pre><code>@pytest.mark.integration\nclass TestApiGatewayIntegration:\n    @pytest.mark.asyncio\n    async def test_full_prompt_workflow(self, test_client):\n        # Test complete workflow from API to external services\n        response = await test_client.post(\n            \"/api/prompts/item\",\n            json={\"content\": \"test prompt\"},\n            headers={\"Authorization\": \"Bearer valid-token\"}\n        )\n\n        assert response.status_code == 201\n        assert \"id\" in response.json()\n</code></pre>"},{"location":"samples/api_gateway/#implementation-details","title":"\ud83d\udcda Implementation Details","text":""},{"location":"samples/api_gateway/#1-controller-layer-apicontrollers","title":"1. Controller Layer (<code>api/controllers/</code>)","text":"<ul> <li>PromptController: Main API endpoints for prompt management</li> <li>AppController: Application health and metadata endpoints</li> <li>InternalController: Internal service endpoints</li> <li>Authentication Schemes: OAuth2 and API key validation</li> </ul>"},{"location":"samples/api_gateway/#2-application-layer-application","title":"2. Application Layer (<code>application/</code>)","text":"<ul> <li>Commands: Write operations (CreateNewPromptCommand)</li> <li>Queries: Read operations (GetPromptByIdQuery)</li> <li>Services: Business logic orchestration</li> <li>Tasks: Background job definitions</li> <li>Events: Integration event handlers</li> </ul>"},{"location":"samples/api_gateway/#3-domain-layer-domain","title":"3. Domain Layer (<code>domain/</code>)","text":"<ul> <li>Prompt: Core domain entity with business rules</li> <li>PromptResponse: Value object for API responses</li> <li>Domain Events: Business event definitions</li> <li>Validation: Domain-specific validation logic</li> </ul>"},{"location":"samples/api_gateway/#4-integration-layer-integration","title":"4. Integration Layer (<code>integration/</code>)","text":"<ul> <li>External API Clients: Mosaic, GenAI, Mozart APIs</li> <li>Storage Services: MinIO object storage, Redis caching</li> <li>Background Services: Task scheduling and execution</li> <li>DTOs: Data transfer objects for external communication</li> </ul>"},{"location":"samples/api_gateway/#background-processing","title":"\ud83d\udd04 Background Processing","text":"<p>The API Gateway demonstrates advanced background processing patterns:</p> <pre><code># Task scheduling configuration\nBackgroundTaskScheduler.configure(builder, [\"application.tasks\"])\n\n# Redis-backed job store\nbuilder.services.add_singleton(AiGatewaySettings, singleton=app_settings)\n\n# Asynchronous task execution\n@task_handler\nclass ProcessPromptTask:\n    async def execute_async(self, prompt_id: str):\n        # Long-running prompt processing\n        prompt = await self.prompt_service.get_by_id(prompt_id)\n        result = await self.genai_client.process_prompt(prompt)\n        await self.storage_service.store_result(result)\n</code></pre>"},{"location":"samples/api_gateway/#external-service-integration","title":"\ud83c\udf10 External Service Integration","text":""},{"location":"samples/api_gateway/#minio-object-storage","title":"MinIO Object Storage","text":"<pre><code>class MinioStorageManager:\n    async def upload_file_async(self, bucket: str, key: str, data: bytes) -&gt; str:\n        # S3-compatible object storage\n        return await self.client.put_object(bucket, key, data)\n</code></pre>"},{"location":"samples/api_gateway/#redis-caching","title":"Redis Caching","text":"<pre><code>class AsyncStringCacheRepository:\n    async def get_async(self, key: str) -&gt; Optional[str]:\n        return await self.redis_client.get(key)\n\n    async def set_async(self, key: str, value: str, ttl: int = None):\n        await self.redis_client.set(key, value, ex=ttl)\n</code></pre>"},{"location":"samples/api_gateway/#external-api-integration","title":"External API Integration","text":"<pre><code>class MosaicApiClient:\n    async def submit_prompt_async(self, prompt: PromptDto) -&gt; PromptResponseDto:\n        # OAuth2 authenticated API calls\n        token = await self.get_access_token()\n        response = await self.http_client.post(\n            \"/api/prompts\",\n            json=prompt.dict(),\n            headers={\"Authorization\": f\"Bearer {token}\"}\n        )\n        return PromptResponseDto.parse_obj(response.json())\n</code></pre>"},{"location":"samples/api_gateway/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"samples/api_gateway/#1-prerequisites","title":"1. Prerequisites","text":"<pre><code># Install dependencies\npip install -r requirements.txt\n\n# Configure external services\ndocker-compose up -d redis keycloak minio\n</code></pre>"},{"location":"samples/api_gateway/#2-configuration","title":"2. Configuration","text":"<pre><code># Set environment variables\nexport JWT_AUTHORITY=\"http://localhost:8080/realms/mozart\"\nexport S3_ENDPOINT=\"http://localhost:9000\"\nexport REDIS_URL=\"redis://localhost:6379\"\n</code></pre>"},{"location":"samples/api_gateway/#3-run-the-application","title":"3. Run the Application","text":"<pre><code># Start the API Gateway\npython samples/api-gateway/main.py\n\n# Access Swagger UI\nopen http://localhost:8000/docs\n</code></pre>"},{"location":"samples/api_gateway/#4-test-the-api","title":"4. Test the API","text":"<pre><code># Get access token from Keycloak\ncurl -X POST http://localhost:8080/realms/mozart/protocol/openid-connect/token \\\n  -H \"Content-Type: application/x-www-form-urlencoded\" \\\n  -d \"grant_type=client_credentials&amp;client_id=ai-gateway&amp;client_secret=secret\"\n\n# Call protected endpoint\ncurl -X POST http://localhost:8000/api/prompts/item \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"content\": \"Generate a sample prompt\"}'\n</code></pre>"},{"location":"samples/api_gateway/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>CQRS &amp; Mediation - Command/Query patterns</li> <li>Dependency Injection - Service configuration</li> <li>Data Access - Repository patterns</li> <li>OpenBank Sample - Event sourcing comparison</li> <li>Desktop Controller Sample - Background services</li> </ul>"},{"location":"samples/api_gateway/#comparison-with-openbank-sample","title":"\ud83d\udd0d Comparison with OpenBank Sample","text":"<p>The API Gateway and OpenBank samples demonstrate different architectural patterns within the Neuroglia framework. Here's a detailed comparison:</p>"},{"location":"samples/api_gateway/#architecture-patterns","title":"Architecture Patterns","text":"Aspect API Gateway OpenBank Primary Pattern Microservice Gateway Event Sourcing + DDD Data Persistence Multi-store (Redis, MinIO, MongoDB) Event Store + Read Models State Management Stateless with caching Event-sourced aggregates External Integration Multiple external APIs Focused domain model Background Processing Async task queues Event-driven projections"},{"location":"samples/api_gateway/#domain-complexity","title":"Domain Complexity","text":""},{"location":"samples/api_gateway/#api-gateway-integration-focused","title":"API Gateway - Integration-Focused","text":"<pre><code># Simple domain model focused on orchestration\n@dataclass\nclass PromptResponse:\n    id: str\n    prompt_id: str\n    content: str\n    status: PromptStatus\n    metadata: dict[str, Any]\n</code></pre>"},{"location":"samples/api_gateway/#openbank-rich-domain-model","title":"OpenBank - Rich Domain Model","text":"<pre><code># Complex aggregate with business rules\nclass BankAccountV1(AggregateRoot[str]):\n    def record_transaction(self, amount: Decimal, transaction_type: BankTransactionTypeV1):\n        # Complex business logic and invariants\n        if transaction_type == BankTransactionTypeV1.DEBIT:\n            if self.state.balance + amount &lt; -self.state.overdraft_limit:\n                raise InsufficientFundsException()\n\n        # Event sourcing\n        self.raise_event(BankAccountTransactionRecordedDomainEventV1(...))\n</code></pre>"},{"location":"samples/api_gateway/#data-persistence-strategy","title":"Data Persistence Strategy","text":""},{"location":"samples/api_gateway/#api-gateway-multi-store-architecture","title":"API Gateway - Multi-Store Architecture","text":"<pre><code># Multiple specialized storage systems\nAsyncStringCacheRepository.configure(builder, Prompt, str)  # Redis caching\nMinioStorageManager.configure(builder)                      # Object storage\nBackgroundTaskScheduler.configure(builder)                 # Job queue\n\n# Standard CRUD operations\nasync def save_prompt(self, prompt: Prompt):\n    await self.cache_repository.set_async(prompt.id, prompt.content)\n    await self.storage_manager.upload_async(prompt.id, prompt.data)\n</code></pre>"},{"location":"samples/api_gateway/#openbank-event-sourcing","title":"OpenBank - Event Sourcing","text":"<pre><code># Event-driven persistence\nESEventStore.configure(builder, EventStoreOptions(database_name, consumer_group))\n\n# Write model: Event sourcing\nDataAccessLayer.WriteModel.configure(\n    builder, \n    [\"samples.openbank.domain.models\"], \n    lambda builder_, entity_type, key_type: EventSourcingRepository.configure(...)\n)\n\n# Read model: Projections\nDataAccessLayer.ReadModel.configure(\n    builder,\n    [\"samples.openbank.integration.models\"], \n    lambda builder_, entity_type, key_type: MongoRepository.configure(...)\n)\n</code></pre>"},{"location":"samples/api_gateway/#authentication-security","title":"Authentication &amp; Security","text":""},{"location":"samples/api_gateway/#api-gateway-oauth2-api-keys","title":"API Gateway - OAuth2 + API Keys","text":"<pre><code># Multiple authentication schemes\n@post(\"/item\", dependencies=[Depends(validate_mosaic_authentication)])\nasync def create_item_prompt(self, command_dto: CreateNewItemPromptCommandDto):\n    # API key validation for external services\n\n@get(\"/status\", dependencies=[Depends(validate_token)])\nasync def get_status(self):\n    # JWT token validation for internal services\n</code></pre>"},{"location":"samples/api_gateway/#openbank-domain-focused-security","title":"OpenBank - Domain-Focused Security","text":"<pre><code># Business rule enforcement\nclass BankAccountV1(AggregateRoot[str]):\n    def record_transaction(self, amount: Decimal, transaction_type: BankTransactionTypeV1):\n        # Domain-level authorization\n        if not self.is_authorized_for_transaction(amount):\n            raise UnauthorizedTransactionException()\n</code></pre>"},{"location":"samples/api_gateway/#external-service-integration_1","title":"External Service Integration","text":""},{"location":"samples/api_gateway/#api-gateway-extensive-integration","title":"API Gateway - Extensive Integration","text":"<pre><code># Multiple external service clients\nclass MosaicApiClient:\n    async def submit_prompt_async(self, prompt: PromptDto) -&gt; PromptResponseDto:\n        token = await self.oauth_client.get_token_async()\n        return await self.http_client.post(\"/api/prompts\", prompt, token)\n\nclass GenAiClient:\n    async def process_prompt_async(self, prompt: str) -&gt; str:\n        return await self.ai_service.generate_response(prompt)\n\nclass MinioStorageManager:\n    async def store_file_async(self, bucket: str, key: str, data: bytes):\n        return await self.s3_client.put_object(bucket, key, data)\n</code></pre>"},{"location":"samples/api_gateway/#openbank-minimal-integration","title":"OpenBank - Minimal Integration","text":"<pre><code># Focused on domain logic, minimal external dependencies\nclass CreateBankAccountCommandHandler:\n    async def handle_async(self, command: CreateBankAccountCommand):\n        # Pure domain logic without external service calls\n        owner = await self.person_repository.get_by_id_async(command.owner_id)\n        account = BankAccountV1(str(uuid.uuid4()), owner, command.initial_balance)\n        await self.account_repository.save_async(account)\n</code></pre>"},{"location":"samples/api_gateway/#background-processing_1","title":"Background Processing","text":""},{"location":"samples/api_gateway/#api-gateway-task-queue-pattern","title":"API Gateway - Task Queue Pattern","text":"<pre><code># Redis-backed job queues\nBackgroundTaskScheduler.configure(builder, [\"application.tasks\"])\n\n@task_handler\nclass ProcessPromptTask:\n    async def execute_async(self, prompt_id: str):\n        prompt = await self.prompt_service.get_by_id(prompt_id)\n        result = await self.genai_client.process_prompt(prompt)\n        await self.storage_service.store_result(result)\n</code></pre>"},{"location":"samples/api_gateway/#openbank-event-driven-projections","title":"OpenBank - Event-Driven Projections","text":"<pre><code># Event handlers for read model updates\nclass BankAccountEventHandler:\n    @event_handler(BankAccountCreatedDomainEventV1)\n    async def handle_account_created(self, event: BankAccountCreatedDomainEventV1):\n        projection = BankAccountProjection.from_event(event)\n        await self.read_model_repository.save_async(projection)\n</code></pre>"},{"location":"samples/api_gateway/#testing-strategies","title":"Testing Strategies","text":""},{"location":"samples/api_gateway/#api-gateway-integration-heavy-testing","title":"API Gateway - Integration-Heavy Testing","text":"<pre><code>@pytest.mark.integration\nclass TestApiGatewayIntegration:\n    async def test_full_prompt_workflow(self, test_client, mock_external_services):\n        # Test complete workflow including external services\n        response = await test_client.post(\"/api/prompts/item\", json=prompt_data)\n\n        # Verify external service calls\n        mock_external_services.genai_client.process_prompt.assert_called_once()\n        mock_external_services.storage_manager.upload.assert_called_once()\n</code></pre>"},{"location":"samples/api_gateway/#openbank-domain-focused-testing","title":"OpenBank - Domain-Focused Testing","text":"<pre><code>class TestBankAccountAggregate:\n    def test_transaction_recording(self):\n        # Pure domain logic testing\n        account = BankAccountV1(\"123\", owner, Decimal(\"1000\"))\n        account.record_transaction(Decimal(\"-100\"), BankTransactionTypeV1.DEBIT)\n\n        # Verify business rules and events\n        assert account.state.balance == Decimal(\"900\")\n        events = account.get_uncommitted_events()\n        assert isinstance(events[-1], BankAccountTransactionRecordedDomainEventV1)\n</code></pre>"},{"location":"samples/api_gateway/#use-case-recommendations","title":"Use Case Recommendations","text":""},{"location":"samples/api_gateway/#choose-api-gateway-pattern-when","title":"Choose API Gateway Pattern when","text":"<ul> <li>\u2705 Building microservice orchestration layers</li> <li>\u2705 Integrating multiple external services</li> <li>\u2705 Need background job processing</li> <li>\u2705 Require complex authentication schemes</li> <li>\u2705 Working with heterogeneous data stores</li> <li>\u2705 Building service mesh entry points</li> </ul>"},{"location":"samples/api_gateway/#choose-event-sourcing-pattern-when","title":"Choose Event Sourcing Pattern when","text":"<ul> <li>\u2705 Need complete audit trails</li> <li>\u2705 Complex business logic and invariants</li> <li>\u2705 Temporal queries are important</li> <li>\u2705 Regulatory compliance requirements</li> <li>\u2705 High consistency requirements</li> <li>\u2705 Rich domain models with behavior</li> </ul>"},{"location":"samples/api_gateway/#framework-features-utilized","title":"Framework Features Utilized","text":"Feature API Gateway Usage OpenBank Usage CQRS/Mediation Service orchestration Domain command/query separation Dependency Injection External service clients Repository abstractions Event Handling Integration events Domain events + projections Data Access Multi-repository pattern Event sourcing + read models Background Processing Async task queues Event-driven handlers Mapping DTO transformations Domain-to-DTO mapping Validation API contract validation Business rule enforcement <p>Both samples showcase different strengths of the Neuroglia framework, demonstrating its flexibility in supporting various architectural patterns while maintaining clean architecture principles.</p>"},{"location":"samples/desktop_controller/","title":"\ud83d\udda5\ufe0f Desktop Controller Sample Application","text":"<p>The Desktop Controller sample demonstrates how to build a remote desktop management system using the Neuroglia framework. This application showcases system integration patterns including SSH-based remote control, background service registration, cloud event publishing, and OAuth2 security for enterprise desktop management.</p>"},{"location":"samples/desktop_controller/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>Remote System Control: SSH-based command execution on host systems</li> <li>Background Service Patterns: Periodic self-registration and heartbeat services  </li> <li>Cloud Event Publishing: Automated service discovery and registration events</li> <li>System Integration: Host system information gathering and state management</li> <li>OAuth2 Security: Enterprise authentication with secure SSH key management</li> <li>File System Integration: Remote file management and data persistence</li> <li>Docker Host Communication: Container-to-host communication patterns</li> </ul>"},{"location":"samples/desktop_controller/#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<pre><code>graph TB\n    subgraph \"Desktop Controller Service\"\n        A[HostController] --&gt; B[Mediator]\n        B --&gt; C[Command/Query Handlers]\n        C --&gt; D[Domain Models]\n        C --&gt; E[SSH Integration Services]\n\n        F[OAuth2 Middleware] --&gt; A\n        G[Background Registrator] --&gt; H[Cloud Event Bus]\n        I[SSH Client] --&gt; J[Docker Host]\n\n        C --&gt; K[File System Repository]\n        K --&gt; I\n    end\n\n    subgraph \"External Dependencies\"\n        L[Keycloak OAuth2]\n        M[Desktop Registry]\n        N[Docker Host/VM]\n        O[Remote File System]\n    end\n\n    F --&gt; L\n    H --&gt; M\n    I --&gt; N\n    K --&gt; O\n\n    style A fill:#e1f5fe\n    style G fill:#f3e5f5\n    style I fill:#fff3e0</code></pre> <p>This architecture enables secure remote control of desktop systems through containerized services that communicate with their host environments via SSH while maintaining enterprise security standards.</p>"},{"location":"samples/desktop_controller/#key-features-demonstrated","title":"\ud83d\ude80 Key Features Demonstrated","text":""},{"location":"samples/desktop_controller/#1-ssh-based-remote-control","title":"1. SSH-Based Remote Control","text":"<pre><code># Secure command execution on host systems\nclass SecuredHost:\n    async def run_command_async(self, command: HostCommand) -&gt; HostCommandResult:\n        stdin, stdout, stderr = await asyncio.to_thread(\n            self.ssh_client.exec_command, command.line\n        )\n\n        exit_status = stdout.channel.recv_exit_status()\n        return HostCommandResult(\n            command=command.line,\n            exit_status=exit_status,\n            stdout=stdout.read().decode(),\n            stderr=stderr.read().decode()\n        )\n</code></pre>"},{"location":"samples/desktop_controller/#2-background-service-registration","title":"2. Background Service Registration","text":"<pre><code># Periodic self-registration with cloud events\nclass DesktopRegistrator(HostedService):\n    async def start_async(self):\n        while not self.cancellation_token.is_cancelled:\n            await self._register_desktop()\n            await asyncio.sleep(self.registration_interval_seconds)\n\n    async def _register_desktop(self):\n        event = DesktopHostRegistrationRequestedIntegrationEventV1(\n            desktop_id=self.desktop_id,\n            host_ip_address=self.host_ip,\n            registration_timestamp=datetime.utcnow()\n        )\n        await self.cloud_event_publisher.publish_async(event)\n</code></pre>"},{"location":"samples/desktop_controller/#3-host-system-information-management","title":"3. Host System Information Management","text":"<pre><code># Domain model for host information\n@dataclass\nclass HostInfo(Entity[str]):\n    desktop_id: str\n    host_ip_address: str\n    host_state: HostState\n    last_seen: datetime\n    is_locked: bool\n    system_info: dict[str, Any]\n\n    def update_system_state(self, new_state: HostState):\n        self.host_state = new_state\n        self.last_seen = datetime.utcnow()\n</code></pre>"},{"location":"samples/desktop_controller/#4-commandquery-pattern-for-remote-operations","title":"4. Command/Query Pattern for Remote Operations","text":"<pre><code># Remote command execution\n@dataclass\nclass SetHostLockCommand(Command):\n    script_name: str = \"/usr/local/bin/lock.sh\"\n\nclass HostLockCommandsHandler(CommandHandler[SetHostLockCommand, OperationResult[Any]]):\n    async def handle_async(self, command: SetHostLockCommand) -&gt; OperationResult[Any]:\n        host_command = HostCommand(line=command.script_name)\n        result = await self.docker_host_command_runner.run_async(host_command)\n\n        if result.exit_status == 0:\n            return self.success(\"Host locked successfully\")\n        return self.bad_request(f\"Lock command failed: {result.stderr}\")\n</code></pre>"},{"location":"samples/desktop_controller/#5-oauth2-with-ssh-security","title":"5. OAuth2 with SSH Security","text":"<pre><code># Dual security: OAuth2 for API + SSH for host access\n@get(\"/info\", dependencies=[Depends(validate_token)])\nasync def get_host_info(self):\n    query = ReadHostInfoQuery()\n    result = await self.mediator.execute_async(query)\n    return self.process(result)\n</code></pre>"},{"location":"samples/desktop_controller/#configuration-settings","title":"\ud83d\udd27 Configuration &amp; Settings","text":""},{"location":"samples/desktop_controller/#application-settings","title":"Application Settings","text":"<pre><code>class DesktopControllerSettings(ApplicationSettings):\n    # OAuth2 Configuration\n    jwt_authority: str = \"http://keycloak47/realms/mozart\"\n    jwt_audience: str = \"desktops\"\n    required_scope: str = \"api\"\n\n    # SSH Configuration\n    docker_host_user_name: str = \"sys-admin\"\n    docker_host_host_name: str = \"host.docker.internal\"\n\n    # File System Configuration\n    remotefs_base_folder: str = \"/tmp\"\n    hostinfo_filename: str = \"hostinfo.json\"\n    userinfo_filename: str = \"userinfo.json\"\n\n    # Registration Configuration\n    desktop_registration_interval: int = 30  # seconds\n</code></pre>"},{"location":"samples/desktop_controller/#ssh-client-configuration","title":"SSH Client Configuration","text":"<pre><code>class SshClientSettings(BaseModel):\n    username: str\n    hostname: str\n    port: int = 22\n    private_key_filename: str = \"/app/id_rsa\"\n\n# SSH key setup required:\n# 1. Generate SSH key pair\n# 2. Mount private key to container at /app/id_rsa\n# 3. Add public key to host's ~/.ssh/authorized_keys\n</code></pre>"},{"location":"samples/desktop_controller/#testing-strategy","title":"\ud83e\uddea Testing Strategy","text":""},{"location":"samples/desktop_controller/#unit-tests","title":"Unit Tests","text":"<pre><code>class TestHostController:\n    def test_host_lock_command_success(self):\n        # Test successful host locking\n        command = SetHostLockCommand(script_name=\"/usr/local/bin/lock.sh\")\n\n        # Mock SSH client response\n        mock_result = HostCommandResult(\n            command=\"/usr/local/bin/lock.sh\",\n            exit_status=0,\n            stdout=\"Host locked\",\n            stderr=\"\"\n        )\n\n        result = await handler.handle_async(command)\n        assert result.is_success\n        assert \"locked successfully\" in result.data\n</code></pre>"},{"location":"samples/desktop_controller/#integration-tests","title":"Integration Tests","text":"<pre><code>class TestDesktopControllerIntegration:\n    @pytest.mark.integration\n    async def test_ssh_host_communication(self):\n        # Test actual SSH communication with test host\n        ssh_client = SecuredHost(test_ssh_settings)\n        command = HostCommand(line=\"echo 'test'\")\n\n        result = await ssh_client.run_command_async(command)\n\n        assert result.exit_status == 0\n        assert \"test\" in result.stdout\n</code></pre>"},{"location":"samples/desktop_controller/#implementation-details","title":"\ud83d\udcda Implementation Details","text":""},{"location":"samples/desktop_controller/#1-controller-layer-apicontrollers","title":"1. Controller Layer (<code>api/controllers/</code>)","text":"<ul> <li>HostController: Host system management and information endpoints</li> <li>UserController: User session and information management</li> <li>HostScriptController: Custom script execution on host systems</li> <li>OAuth2Scheme: Authentication and authorization middleware</li> </ul>"},{"location":"samples/desktop_controller/#2-application-layer-application","title":"2. Application Layer (<code>application/</code>)","text":"<ul> <li>Commands: System control operations (lock, unlock, script execution)</li> <li>Queries: System information retrieval (host info, user info, lock status)</li> <li>Services: Background registration, SSH command execution</li> <li>Events: Integration events for desktop registration</li> </ul>"},{"location":"samples/desktop_controller/#3-domain-layer-domain","title":"3. Domain Layer (<code>domain/</code>)","text":"<ul> <li>HostInfo: Desktop system information and state</li> <li>UserInfo: User session and authentication state</li> <li>HostIsLocked: Lock state management for security</li> <li>Domain Events: System state change notifications</li> </ul>"},{"location":"samples/desktop_controller/#4-integration-layer-integration","title":"4. Integration Layer (<code>integration/</code>)","text":"<ul> <li>SSH Services: Secure host communication via SSH</li> <li>File System Repository: Remote file management</li> <li>Cloud Event Models: External service communication</li> <li>Enums: System state and configuration enumerations</li> </ul>"},{"location":"samples/desktop_controller/#external-service-integration","title":"\ud83c\udf10 External Service Integration","text":""},{"location":"samples/desktop_controller/#ssh-host-communication","title":"SSH Host Communication","text":"<pre><code>class SecuredDockerHost:\n    \"\"\"SSH-based secure communication with Docker host system\"\"\"\n\n    async def execute_system_command(self, command: str) -&gt; CommandResult:\n        ssh_command = HostCommand(line=command)\n        return await self.secured_host.run_command_async(ssh_command)\n</code></pre>"},{"location":"samples/desktop_controller/#cloud-event-publishing","title":"Cloud Event Publishing","text":"<pre><code>class DesktopRegistrationEvent:\n    \"\"\"Periodic registration with external desktop registry\"\"\"\n\n    event_type = \"com.cisco.mozart.desktop.registered.v1\"\n\n    async def publish_registration(self):\n        cloud_event = CloudEvent(\n            type=self.event_type,\n            source=f\"desktop-controller/{self.desktop_id}\",\n            data=DesktopHostRegistrationRequestedIntegrationEventV1(\n                desktop_id=self.desktop_id,\n                host_ip_address=self.get_host_ip(),\n                capabilities=self.get_host_capabilities()\n            )\n        )\n        await self.cloud_event_bus.publish_async(cloud_event)\n</code></pre>"},{"location":"samples/desktop_controller/#remote-file-system-access","title":"Remote File System Access","text":"<pre><code>class RemoteFileSystemRepository:\n    \"\"\"File-based data persistence on host system\"\"\"\n\n    async def save_host_info(self, host_info: HostInfo):\n        json_data = self.json_serializer.serialize(host_info)\n        await self.write_file_async(\"hostinfo.json\", json_data)\n\n    async def write_file_async(self, filename: str, content: str):\n        # Use SSH to write files to host filesystem\n        command = f\"echo '{content}' &gt; {self.base_path}/{filename}\"\n        await self.ssh_client.run_command_async(HostCommand(line=command))\n</code></pre>"},{"location":"samples/desktop_controller/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"samples/desktop_controller/#prerequisites","title":"Prerequisites","text":"<pre><code># 1. Docker and Docker Desktop installed\n# 2. SSH key pair generated\nssh-keygen -t rsa -b 4096 -f ~/.ssh/desktop_controller_key\n\n# 3. Copy public key to target host\nssh-copy-id -i ~/.ssh/desktop_controller_key.pub user@target-host\n</code></pre>"},{"location":"samples/desktop_controller/#running-the-application","title":"Running the Application","text":"<pre><code># 1. Clone and setup\ngit clone &lt;repository&gt;\ncd samples/desktop-controller\n\n# 2. Configure environment\ncp .env.example .env\n# Edit .env with your settings\n\n# 3. Mount SSH private key and run\ndocker run -d \n  -p 8080:80 \n  -v ~/.ssh/desktop_controller_key:/app/id_rsa:ro \n  -e DOCKER_HOST_USER_NAME=sys-admin \n  -e JWT_AUTHORITY=http://your-keycloak/realms/mozart \n  desktop-controller:latest\n\n# 4. Test the API\ncurl -H \"Authorization: Bearer &lt;token&gt;\" \n     http://localhost:8080/api/host/info\n</code></pre>"},{"location":"samples/desktop_controller/#development-setup","title":"Development Setup","text":"<pre><code># 1. Install dependencies\npoetry install\n\n# 2. Configure SSH access\nsudo cp ~/.ssh/desktop_controller_key ./id_rsa\nsudo chmod 600 ./id_rsa\n\n# 3. Start development server\npoetry run python main.py\n\n# 4. Access Swagger UI\nopen http://localhost:8080/docs\n</code></pre>"},{"location":"samples/desktop_controller/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>OAuth2 Security - Authentication patterns</li> <li>Background Services - Hosted service patterns</li> <li>Cloud Events - Event publishing and consumption</li> <li>System Integration - External system communication</li> <li>API Gateway Sample - Service gateway patterns</li> <li>OpenBank Sample - Event sourcing and CQRS patterns</li> </ul>"},{"location":"samples/desktop_controller/#comparison-with-other-samples","title":"\ud83d\udd0d Comparison with Other Samples","text":""},{"location":"samples/desktop_controller/#architecture-patterns","title":"Architecture Patterns","text":""},{"location":"samples/desktop_controller/#desktop-controller-system-integration-focused","title":"Desktop Controller - System Integration Focused","text":"<pre><code># SSH-based system control\nclass HostController(ControllerBase):\n    @post(\"/lock\")\n    async def lock_host(self):\n        command = SetHostLockCommand()\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n# Background service registration\nclass DesktopRegistrator(HostedService):\n    async def start_async(self):\n        while not self.stopping:\n            await self.register_desktop()\n            await asyncio.sleep(30)\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-service-orchestration","title":"API Gateway - Service Orchestration","text":"<pre><code># External API orchestration\nclass PromptController(ControllerBase):\n    @post(\"/prompts\")\n    async def create_prompt(self, dto: CreatePromptDto):\n        command = self.mapper.map(dto, CreatePromptCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-rich-domain-model","title":"OpenBank - Rich Domain Model","text":"<pre><code># Event-sourced business logic\nclass BankAccount(AggregateRoot[str]):\n    def try_add_transaction(self, transaction: BankTransaction) -&gt; bool:\n        if self.can_process_transaction(transaction):\n            self.state.on(self.register_event(TransactionRecorded(transaction)))\n            return True\n        return False\n</code></pre>"},{"location":"samples/desktop_controller/#domain-complexity","title":"Domain Complexity","text":""},{"location":"samples/desktop_controller/#desktop-controller-system-state-management","title":"Desktop Controller - System State Management","text":"<ul> <li>Focus: Host system control and monitoring</li> <li>Entities: HostInfo, UserInfo, SystemState</li> <li>Operations: Lock/unlock, script execution, information gathering</li> <li>State: Current system state with periodic updates</li> </ul>"},{"location":"samples/desktop_controller/#api-gateway-service-integration","title":"API Gateway - Service Integration","text":"<ul> <li>Focus: Request routing and external service coordination</li> <li>Entities: Prompt, PromptResponse, ServiceConfiguration</li> <li>Operations: Create, process, route requests</li> <li>State: Request/response transformation and routing</li> </ul>"},{"location":"samples/desktop_controller/#openbank-business-domain-model","title":"OpenBank - Business Domain Model","text":"<ul> <li>Focus: Financial business rules and transactions</li> <li>Entities: BankAccount, Person, Transaction</li> <li>Operations: Account creation, money transfer, balance inquiry</li> <li>State: Event-sourced business state with full history</li> </ul>"},{"location":"samples/desktop_controller/#data-persistence-strategy","title":"Data Persistence Strategy","text":""},{"location":"samples/desktop_controller/#desktop-controller-file-based-remote-storage","title":"Desktop Controller - File-Based + Remote Storage","text":"<pre><code># File-based persistence on remote host\nclass RemoteFileSystemRepository:\n    async def save_host_info(self, host_info: HostInfo):\n        json_content = self.serializer.serialize(host_info)\n        await self.write_remote_file(\"hostinfo.json\", json_content)\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-multi-store-architecture","title":"API Gateway - Multi-Store Architecture","text":"<pre><code># Multiple storage backends\nservices.add_scoped(MinioStorageManager)      # Object storage\nservices.add_scoped(RedisCache)               # Caching\nservices.add_scoped(MongoRepository)          # Document storage\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-event-sourcing","title":"OpenBank - Event Sourcing","text":"<pre><code># Event store with projections\nclass EventStoreRepository:\n    async def save_async(self, aggregate: AggregateRoot):\n        events = aggregate._pending_events\n        await self.event_store.append_events_async(aggregate.id, events)\n</code></pre>"},{"location":"samples/desktop_controller/#authentication-security","title":"Authentication &amp; Security","text":""},{"location":"samples/desktop_controller/#desktop-controller-oauth2-ssh-keys","title":"Desktop Controller - OAuth2 + SSH Keys","text":"<pre><code># Dual security model\n@get(\"/info\", dependencies=[Depends(validate_token)])\nasync def get_host_info(self):\n    # OAuth2 for API access + SSH for host communication\n    pass\n\n# SSH key management\nclass SshClientSettings:\n    private_key_filename: str = \"/app/id_rsa\"\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-oauth2-api-keys","title":"API Gateway - OAuth2 + API Keys","text":"<pre><code># Multiple authentication schemes\n@post(\"/item\", dependencies=[Depends(validate_oauth2_token)])\nasync def create_item_oauth(self, item_data: ItemDto):\n    pass\n\n@get(\"/health\", dependencies=[Depends(validate_api_key)])\nasync def health_check(self):\n    pass\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-domain-focused-security","title":"OpenBank - Domain-Focused Security","text":"<pre><code># Business rule-based security\nclass BankAccount:\n    def withdraw(self, amount: Decimal, user: Person):\n        if not self.is_owner(user):\n            raise UnauthorizedOperationException()\n        if not self.has_sufficient_funds(amount):\n            raise InsufficientFundsException()\n</code></pre>"},{"location":"samples/desktop_controller/#external-service-integration_1","title":"External Service Integration","text":""},{"location":"samples/desktop_controller/#desktop-controller-system-integration","title":"Desktop Controller - System Integration","text":"<pre><code># Direct system integration via SSH\nclass DockerHostCommandRunner:\n    async def run_async(self, command: HostCommand) -&gt; HostCommandResult:\n        return await self.ssh_client.execute_command(command)\n\n# Cloud event publishing for registration\nclass DesktopRegistrator:\n    async def register_desktop(self):\n        event = DesktopRegistrationEvent(self.host_info)\n        await self.cloud_event_bus.publish_async(event)\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-extensive-integration","title":"API Gateway - Extensive Integration","text":"<pre><code># Multiple external service clients\nservices.add_scoped(MosaicApiClient)\nservices.add_scoped(MinioStorageManager)\nservices.add_scoped(RedisCache)\nservices.add_scoped(GenAiApiClient)\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-minimal-integration","title":"OpenBank - Minimal Integration","text":"<pre><code># Domain-focused with minimal external dependencies\nservices.add_singleton(EventStoreClient)\nservices.add_scoped(MongoRepository)  # For read models\n</code></pre>"},{"location":"samples/desktop_controller/#background-processing","title":"Background Processing","text":""},{"location":"samples/desktop_controller/#desktop-controller-periodic-registration","title":"Desktop Controller - Periodic Registration","text":"<pre><code># Background service for system registration\nclass DesktopRegistrator(HostedService):\n    async def start_async(self):\n        self.registration_task = asyncio.create_task(self.registration_loop())\n\n    async def registration_loop(self):\n        while not self.stopping:\n            await self.register_with_registry()\n            await asyncio.sleep(self.interval)\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-task-queue-pattern","title":"API Gateway - Task Queue Pattern","text":"<pre><code># Redis-backed background task processing\n@dataclass\nclass ProcessPromptTask(BackgroundTask):\n    prompt_id: str\n    user_id: str\n\nclass PromptProcessingService:\n    async def queue_processing_task(self, prompt: Prompt):\n        task = ProcessPromptTask(prompt.id, prompt.user_id)\n        await self.task_scheduler.schedule_async(task)\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-event-driven-projections","title":"OpenBank - Event-Driven Projections","text":"<pre><code># Domain event-driven read model updates\nclass BankAccountProjectionHandler:\n    @dispatch(BankAccountCreatedDomainEventV1)\n    async def handle_async(self, event: BankAccountCreatedDomainEventV1):\n        projection = BankAccountProjection.from_event(event)\n        await self.projection_repository.save_async(projection)\n</code></pre>"},{"location":"samples/desktop_controller/#testing-strategies","title":"Testing Strategies","text":""},{"location":"samples/desktop_controller/#desktop-controller-system-integration-testing","title":"Desktop Controller - System Integration Testing","text":"<pre><code># SSH integration tests\n@pytest.mark.integration\nclass TestSSHIntegration:\n    async def test_host_command_execution(self):\n        ssh_client = SecuredHost(test_settings)\n        result = await ssh_client.run_command_async(HostCommand(\"echo test\"))\n        assert result.exit_status == 0\n        assert \"test\" in result.stdout\n\n# Background service testing\nclass TestDesktopRegistrator:\n    async def test_periodic_registration(self):\n        registrator = DesktopRegistrator(mock_cloud_event_bus)\n        await registrator.start_async()\n        # Verify registration events are published\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-integration-heavy-testing","title":"API Gateway - Integration-Heavy Testing","text":"<pre><code># External service integration tests\n@pytest.mark.integration\nclass TestExternalServices:\n    async def test_mosaic_api_integration(self):\n        client = MosaicApiClient(test_settings)\n        response = await client.get_data_async(\"test-id\")\n        assert response.status_code == 200\n\n# Background task testing\nclass TestTaskProcessing:\n    async def test_prompt_processing_workflow(self):\n        task = ProcessPromptTask(\"prompt-123\", \"user-456\")\n        result = await self.task_processor.process_async(task)\n        assert result.is_success\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-domain-focused-testing","title":"OpenBank - Domain-Focused Testing","text":"<pre><code># Rich domain behavior testing\nclass TestBankAccount:\n    def test_account_creation_raises_creation_event(self):\n        account = BankAccount()\n        account.create_account(\"owner-123\", Decimal(\"1000.00\"))\n\n        events = account._pending_events\n        assert len(events) == 1\n        assert isinstance(events[0], BankAccountCreatedDomainEventV1)\n\n# Event sourcing testing\nclass TestEventStore:\n    async def test_aggregate_reconstruction_from_events(self):\n        events = [creation_event, transaction_event]\n        account = await self.repository.load_from_events(events)\n        assert account.balance == expected_balance\n</code></pre>"},{"location":"samples/desktop_controller/#use-case-recommendations","title":"Use Case Recommendations","text":""},{"location":"samples/desktop_controller/#choose-desktop-controller-pattern-when","title":"Choose Desktop Controller Pattern when","text":"<ul> <li>\u2705 Building system administration and control applications</li> <li>\u2705 Managing remote desktop or VM environments</li> <li>\u2705 Implementing SSH-based automation and control</li> <li>\u2705 Creating enterprise desktop management solutions</li> <li>\u2705 Needing periodic service registration and discovery</li> <li>\u2705 Integrating containerized apps with host systems</li> <li>\u2705 Building secure remote command execution systems</li> </ul>"},{"location":"samples/desktop_controller/#choose-api-gateway-pattern-when","title":"Choose API Gateway Pattern when","text":"<ul> <li>\u2705 Building microservice entry points and orchestration</li> <li>\u2705 Implementing complex external service integration</li> <li>\u2705 Creating service mesh control planes</li> <li>\u2705 Needing advanced authentication and authorization</li> <li>\u2705 Building background task processing systems</li> <li>\u2705 Implementing file storage and caching solutions</li> </ul>"},{"location":"samples/desktop_controller/#choose-event-sourcing-pattern-when","title":"Choose Event Sourcing Pattern when","text":"<ul> <li>\u2705 Rich domain models with behavior</li> <li>\u2705 Complete audit trails and temporal queries</li> <li>\u2705 Event-driven architecture with projections</li> <li>\u2705 Financial or business-critical applications</li> <li>\u2705 CQRS with separate read/write models</li> </ul>"},{"location":"samples/desktop_controller/#framework-features-utilized","title":"Framework Features Utilized","text":"<p>The Desktop Controller sample demonstrates unique aspects of the Neuroglia framework:</p> <ul> <li>Background Services: <code>HostedService</code> for long-running registration tasks</li> <li>SSH Integration: Custom integration services for secure system communication</li> <li>Cloud Event Publishing: External service registration and discovery</li> <li>File-Based Repositories: Remote filesystem data persistence</li> <li>OAuth2 Security: Enterprise authentication with secure key management</li> <li>System Integration Patterns: Container-to-host communication strategies</li> </ul> <p>Both samples showcase different strengths of the Neuroglia framework, demonstrating its flexibility in supporting various architectural patterns while maintaining clean architecture principles.</p>"},{"location":"samples/desktop_controller/#overview","title":"Overview","text":""},{"location":"samples/desktop_controller/#controllers-interactions","title":"Controller's Interactions","text":"<p>TODO</p>"},{"location":"samples/desktop_controller/#controllers-context","title":"Controller's Context","text":"<p>TODO</p>"},{"location":"samples/desktop_controller/#design","title":"Design","text":"<p>TODO</p>"},{"location":"samples/desktop_controller/#development","title":"Development","text":""},{"location":"samples/desktop_controller/#setup","title":"Setup","text":"<pre><code># 0. Prerequisites:\n#    Have Python 3.12 installed\n# \n#    - Create/Activate a local python environment (e.g. with pyenv)\n#      pyenv virtualenv 3.12.2 desktop-controller\n#      pyenv activate desktop-controller\n# \n#    - Start Docker Desktop locally\n#\n# 1. Clone the repository\ncd ~/\n\ngit clone git@....\n\ncd desktop-controller\n\n# pip install pre-commit\npre-commit install\n\n# pip install poetry\npoetry lock &amp;&amp; poetry install \n\n# 2. Start the docker-compose stack\n# sudo apt-get install make\nmake up\n\n# Access Swagger UI\nopen http://localhost:8080/docs\n</code></pre>"},{"location":"samples/desktop_controller/#key-implementation-highlights","title":"\ud83d\udca1 Key Implementation Highlights","text":"<p>The Desktop Controller sample uniquely demonstrates:</p>"},{"location":"samples/desktop_controller/#1-dual-security-architecture","title":"1. Dual Security Architecture","text":"<ul> <li>API Security: OAuth2/JWT for REST API access</li> <li>System Security: SSH key-based authentication for host communication</li> <li>Separation of Concerns: Different security models for different access layers</li> </ul>"},{"location":"samples/desktop_controller/#2-container-to-host-communication","title":"2. Container-to-Host Communication","text":"<ul> <li>SSH Bridge: Secure communication between containerized service and host system</li> <li>Command Execution: Remote shell command execution with result capture</li> <li>File System Access: Remote file management on host filesystem</li> </ul>"},{"location":"samples/desktop_controller/#3-background-service-registration","title":"3. Background Service Registration","text":"<ul> <li>Self-Discovery: Periodic registration with external service registry</li> <li>Cloud Events: Standards-based event publishing for service discovery</li> <li>Heartbeat Pattern: Continuous availability signaling</li> </ul>"},{"location":"samples/desktop_controller/#4-system-integration-patterns","title":"4. System Integration Patterns","text":"<ul> <li>Host Information Gathering: Real-time system state collection</li> <li>Remote Control Operations: Secure desktop management capabilities</li> <li>State Persistence: File-based data storage for inter-application communication</li> </ul> <p>This sample showcases how the Neuroglia framework can effectively bridge containerized microservices with host system management, providing enterprise-grade security and reliability for remote desktop control scenarios.</p> <p>Both the Desktop Controller and other samples demonstrate the framework's versatility in handling diverse architectural patterns - from event-sourced business applications to system integration and service orchestration solutions.</p>"},{"location":"samples/lab-resource-manager/","title":"\ud83e\uddea Lab Resource Manager Sample Application","text":"<p>The Lab Resource Manager demonstrates Resource Oriented Architecture (ROA) patterns using Neuroglia's advanced features. It simulates a system for managing ephemeral lab environments for students, showcasing watchers, controllers, and reconciliation loops.</p>"},{"location":"samples/lab-resource-manager/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>Resource Oriented Architecture: Declarative resource management patterns</li> <li>Watcher Pattern: Continuous monitoring of resource changes</li> <li>Controller Pattern: Event-driven business logic responses</li> <li>Reconciliation Loops: Periodic consistency checks and drift correction</li> <li>State Machine Implementation: Resource lifecycle management</li> <li>Asynchronous Coordination: Multiple concurrent components working together</li> </ul>"},{"location":"samples/lab-resource-manager/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Lab Resource Manager                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502   Watcher       \u2502    \u2502   Controller    \u2502    \u2502  Reconciler     \u2502 \u2502\n\u2502  \u2502   (2s polling)  \u2502\u2500\u2500\u2500\u25b6\u2502   (immediate)   \u2502    \u2502   (10s loop)    \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502           \u2502                       \u2502                       \u2502       \u2502\n\u2502           \u25bc                       \u25bc                       \u25bc       \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502                    Resource Storage                             \u2502 \u2502\n\u2502  \u2502            (Kubernetes-like API with versioning)               \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n</code></pre>"},{"location":"samples/lab-resource-manager/#domain-model","title":"\ud83c\udfaf Domain Model","text":""},{"location":"samples/lab-resource-manager/#labinstance-resource","title":"LabInstance Resource","text":"<p>The core resource representing a student lab environment:</p> <pre><code>@dataclass\nclass LabInstanceResource:\n    api_version: str = \"lab.neuroglia.com/v1\"\n    kind: str = \"LabInstance\" \n    metadata: Dict[str, Any] = None  # Name, namespace, timestamps, versions\n    spec: Dict[str, Any] = None      # Desired state: template, duration, student\n    status: Dict[str, Any] = None    # Current state: phase, endpoint, conditions\n</code></pre>"},{"location":"samples/lab-resource-manager/#resource-states","title":"Resource States","text":"<p>Lab instances progress through a defined lifecycle:</p> <pre><code>PENDING \u2500\u2500\u2192 PROVISIONING \u2500\u2500\u2192 READY \u2500\u2500\u2192 DELETING \u2500\u2500\u2192 DELETED\n   \u2502              \u2502             \u2502\n   \u25bc              \u25bc             \u25bc\nFAILED        FAILED         FAILED\n</code></pre>"},{"location":"samples/lab-resource-manager/#sample-resource","title":"Sample Resource","text":"<pre><code>{\n  \"apiVersion\": \"lab.neuroglia.com/v1\",\n  \"kind\": \"LabInstance\",\n  \"metadata\": {\n    \"name\": \"python-basics-lab\",\n    \"namespace\": \"student-labs\",\n    \"resourceVersion\": \"1\",\n    \"creationTimestamp\": \"2025-09-09T21:34:19Z\"\n  },\n  \"spec\": {\n    \"template\": \"python-basics\",\n    \"studentEmail\": \"student@example.com\",\n    \"duration\": \"60m\",\n    \"environment\": {\n      \"PYTHON_VERSION\": \"3.11\"\n    }\n  },\n  \"status\": {\n    \"state\": \"ready\",\n    \"message\": \"Lab instance is ready\",\n    \"endpoint\": \"https://lab-python-basics.example.com\",\n    \"readyAt\": \"2025-09-09T21:34:25Z\"\n  }\n}\n</code></pre>"},{"location":"samples/lab-resource-manager/#component-implementation","title":"\ud83d\udd27 Component Implementation","text":""},{"location":"samples/lab-resource-manager/#1-watcher-labinstancewatcher","title":"1. Watcher: LabInstanceWatcher","text":"<p>Continuously monitors for resource changes:</p> <pre><code>class LabInstanceWatcher:\n    async def start_watching(self):\n        while self.is_running:\n            # Poll for changes since last known version\n            changes = self.storage.list_resources(since_version=self.last_resource_version)\n\n            for resource in changes:\n                resource_version = int(resource.metadata.get('resourceVersion', '0'))\n                if resource_version &gt; self.last_resource_version:\n                    await self._handle_resource_change(resource)\n                    self.last_resource_version = max(self.last_resource_version, resource_version)\n\n            await asyncio.sleep(self.poll_interval)\n</code></pre> <p>Key Features: - Polls every 2 seconds for near-real-time responsiveness - Uses resource versioning to detect changes efficiently - Notifies multiple event handlers when changes occur - Handles errors gracefully with continued monitoring</p>"},{"location":"samples/lab-resource-manager/#2-controller-labinstancecontroller","title":"2. Controller: LabInstanceController","text":"<p>Implements business logic for state transitions:</p> <pre><code>class LabInstanceController:\n    async def handle_resource_event(self, resource: LabInstanceResource):\n        current_state = resource.status.get('state')\n\n        if current_state == ResourceState.PENDING.value:\n            await self._start_provisioning(resource)\n        elif current_state == ResourceState.PROVISIONING.value:\n            await self._check_provisioning_status(resource)\n        elif current_state == ResourceState.READY.value:\n            await self._monitor_lab_instance(resource)\n</code></pre> <p>Key Features: - Event-driven processing responding immediately to changes - State machine implementation with clear transitions - Business rule enforcement (timeouts, validation, etc.) - Integration with external provisioning systems</p>"},{"location":"samples/lab-resource-manager/#3-reconciler-labinstancescheduler","title":"3. Reconciler: LabInstanceScheduler","text":"<p>Provides safety and eventual consistency:</p> <pre><code>class LabInstanceScheduler:\n    async def start_reconciliation(self):\n        while self.is_running:\n            await self._reconcile_all_resources()\n            await asyncio.sleep(self.reconcile_interval)\n\n    async def _reconcile_resource(self, resource):\n        # Check for stuck states\n        if self._is_stuck_provisioning(resource):\n            await self._mark_as_failed(resource, \"Provisioning timeout\")\n\n        # Check for expiration\n        if self._is_expired(resource):\n            await self._schedule_deletion(resource)\n</code></pre> <p>Key Features: - Runs every 10 seconds scanning all resources - Detects stuck states and takes corrective action - Enforces business policies (lab expiration, cleanup) - Provides safety net for controller failures</p>"},{"location":"samples/lab-resource-manager/#execution-flow","title":"\u26a1 Execution Flow","text":""},{"location":"samples/lab-resource-manager/#1-resource-creation","title":"1. Resource Creation","text":"<pre><code>1. API creates LabInstance resource (state: PENDING)\n2. Storage backend assigns resource version and timestamps\n3. Watcher detects new resource on next poll cycle (\u22642s)\n4. Controller receives sevent and starts provisioning\n5. Resource state transitions to PROVISIONING\n</code></pre>"},{"location":"samples/lab-resource-manager/#2-state-progression","title":"2. State Progression","text":"<pre><code>6. Watcher detects state change to PROVISIONING\n7. Controller checks provisioning status periodically\n8. When provisioning completes, state transitions to READY\n9. Watcher detects READY state\n10. Controller begins monitoring ready lab instance\n</code></pre>"},{"location":"samples/lab-resource-manager/#3-reconciliation-safety","title":"3. Reconciliation Safety","text":"<pre><code>11. Reconciler runs every 10 seconds checking all resources\n12. Detects if any resource is stuck in PROVISIONING too long\n13. Marks stuck resources as FAILED with timeout message\n14. Detects expired READY resources and schedules deletion\n</code></pre>"},{"location":"samples/lab-resource-manager/#running-the-sample","title":"\ud83d\ude80 Running the Sample","text":""},{"location":"samples/lab-resource-manager/#prerequisites","title":"Prerequisites","text":"<pre><code>cd samples/lab-resource-manager\n</code></pre>"},{"location":"samples/lab-resource-manager/#option-1-full-interactive-demo","title":"Option 1: Full Interactive Demo","text":"<pre><code>python run_watcher_demo.py\n</code></pre> <p>This runs the complete demonstration showing: - Resource creation and state transitions - Watcher detecting changes in real-time - Controller responding with business logic - Reconciler providing safety and cleanup</p>"},{"location":"samples/lab-resource-manager/#option-2-simple-patterns-demo","title":"Option 2: Simple Patterns Demo","text":"<pre><code>python simple_demo.py\n</code></pre> <p>A simplified version focusing on the core patterns without framework dependencies.</p>"},{"location":"samples/lab-resource-manager/#expected-output","title":"Expected Output","text":"<pre><code>\ud83c\udfaf Resource Oriented Architecture: Watcher &amp; Reconciliation Demo\n============================================================\n\ud83d\udc40 LabInstance Watcher started\n\ud83d\udd04 LabInstance Scheduler started reconciliation\n\ud83d\udce6 Created resource: student-labs/python-basics-lab\n\ud83d\udd0d Watcher detected change: student-labs/python-basics-lab -&gt; pending\n\ud83c\udfae Controller processing: student-labs/python-basics-lab (state: pending)\n\ud83d\ude80 Starting provisioning for: student-labs/python-basics-lab\n\ud83d\udd04 Updated resource: student-labs/python-basics-lab -&gt; {'status': {'state': 'provisioning'}}\n\ud83d\udd0d Watcher detected change: student-labs/python-basics-lab -&gt; provisioning\n\ud83c\udfae Controller processing: student-labs/python-basics-lab (state: provisioning)\n\ud83d\udd04 Reconciling 2 lab instances\n\u26a0\ufe0f Reconciler: Lab instance stuck in provisioning: student-labs/python-basics-lab\n</code></pre>"},{"location":"samples/lab-resource-manager/#key-implementation-details","title":"\ud83d\udca1 Key Implementation Details","text":""},{"location":"samples/lab-resource-manager/#resource-versioning","title":"Resource Versioning","text":"<p>Each resource change increments the version:</p> <pre><code>def update_resource(self, resource_id: str, updates: Dict[str, Any]):\n    resource = self.resources[resource_id]\n    self.resource_version += 1\n    resource.metadata['resourceVersion'] = str(self.resource_version)\n</code></pre>"},{"location":"samples/lab-resource-manager/#event-handling","title":"Event Handling","text":"<p>Watchers notify multiple handlers:</p> <pre><code>watcher.add_event_handler(controller.handle_resource_event)\nwatcher.add_event_handler(audit_logger.log_change)\nwatcher.add_event_handler(metrics_collector.record_event)\n</code></pre>"},{"location":"samples/lab-resource-manager/#error-resilience","title":"Error Resilience","text":"<p>All components handle errors gracefully:</p> <pre><code>try:\n    await self._provision_lab_instance(resource)\nexcept Exception as e:\n    logger.error(f\"Provisioning failed: {e}\")\n    await self._mark_as_failed(resource, str(e))\n</code></pre>"},{"location":"samples/lab-resource-manager/#concurrent-processing","title":"Concurrent Processing","text":"<p>Components run independently:</p> <pre><code>async def main():\n    watcher_task = asyncio.create_task(watcher.start_watching())\n    scheduler_task = asyncio.create_task(scheduler.start_reconciliation())\n\n    # Both run concurrently until stopped\n    await asyncio.gather(watcher_task, scheduler_task)\n</code></pre>"},{"location":"samples/lab-resource-manager/#design-patterns-demonstrated","title":"\ud83c\udfaf Design Patterns Demonstrated","text":""},{"location":"samples/lab-resource-manager/#1-observer-pattern","title":"1. Observer Pattern","text":"<p>Watchers observe storage and notify controllers of changes.</p>"},{"location":"samples/lab-resource-manager/#2-state-machine","title":"2. State Machine","text":"<p>Resources progress through well-defined states with clear transitions.</p>"},{"location":"samples/lab-resource-manager/#3-command-pattern","title":"3. Command Pattern","text":"<p>Controllers execute commands based on resource state.</p>"},{"location":"samples/lab-resource-manager/#4-strategy-pattern","title":"4. Strategy Pattern","text":"<p>Different provisioning strategies for different lab templates.</p>"},{"location":"samples/lab-resource-manager/#5-circuit-breaker","title":"5. Circuit Breaker","text":"<p>Reconcilers detect failures and prevent cascade issues.</p>"},{"location":"samples/lab-resource-manager/#configuration-options","title":"\ud83d\udd27 Configuration Options","text":""},{"location":"samples/lab-resource-manager/#timing-configuration","title":"Timing Configuration","text":"<pre><code># Development: Fast feedback\nwatcher = LabInstanceWatcher(storage, poll_interval=1.0)\nscheduler = LabInstanceScheduler(storage, reconcile_interval=5.0)\n\n# Production: Optimized performance  \nwatcher = LabInstanceWatcher(storage, poll_interval=5.0)\nscheduler = LabInstanceScheduler(storage, reconcile_interval=30.0)\n</code></pre>"},{"location":"samples/lab-resource-manager/#timeout-configuration","title":"Timeout Configuration","text":"<pre><code>class LabInstanceController:\n    PROVISIONING_TIMEOUT = 300  # 5 minutes\n    MAX_RETRIES = 3\n    RETRY_BACKOFF = 30  # seconds\n</code></pre>"},{"location":"samples/lab-resource-manager/#resource-policies","title":"Resource Policies","text":"<pre><code>class LabInstanceScheduler:\n    DEFAULT_LAB_DURATION = 3600  # 1 hour\n    CLEANUP_GRACE_PERIOD = 300   # 5 minutes\n    MAX_CONCURRENT_PROVISIONS = 10\n</code></pre>"},{"location":"samples/lab-resource-manager/#testing-the-sample","title":"\ud83e\uddea Testing the Sample","text":"<p>The sample includes comprehensive tests:</p> <pre><code># Run all sample tests\npytest samples/lab-resource-manager/tests/\n\n# Test individual components\npytest samples/lab-resource-manager/tests/test_watcher.py\npytest samples/lab-resource-manager/tests/test_controller.py\npytest samples/lab-resource-manager/tests/test_reconciler.py\n</code></pre>"},{"location":"samples/lab-resource-manager/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\ud83c\udfaf Resource Oriented Architecture - Core ROA concepts</li> <li>\ud83c\udfd7\ufe0f Watcher &amp; Reconciliation Patterns - Detailed patterns</li> <li>\u26a1 Execution Flow - Component coordination</li> <li>\ud83c\udfaf CQRS &amp; Mediation - Command/Query handling</li> <li>\ud83d\uddc4\ufe0f Data Access - Storage patterns</li> </ul>"},{"location":"samples/lab-resource-manager/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<p>After exploring this sample:</p> <ol> <li>Extend the Domain: Add more resource types (LabTemplate, StudentSession)</li> <li>Add Persistence: Integrate with MongoDB or Event Store</li> <li>Implement Authentication: Add student authentication and authorization</li> <li>Add Monitoring: Integrate metrics collection and alerting</li> <li>Scale Horizontally: Implement resource sharding for multiple instances</li> </ol>"},{"location":"samples/openbank/","title":"\ud83c\udfe6 OpenBank Sample Application","text":"<p>OpenBank is a comprehensive sample application that demonstrates advanced Neuroglia features including event sourcing, CQRS, domain-driven design, and event-driven architecture. It simulates a simple banking system with persons and accounts.</p>"},{"location":"samples/openbank/#overview","title":"\ud83c\udfaf Overview","text":"<p>The OpenBank sample showcases:</p> <ul> <li>Event Sourcing: Complete event-sourced domain with event store</li> <li>CQRS: Separate command and query models</li> <li>Domain-Driven Design: Rich domain models with business rules</li> <li>Event-Driven Architecture: Domain events and integration events</li> <li>Clean Architecture: Clear separation of layers</li> <li>Repository Pattern: Both write (event sourcing) and read (MongoDB) repositories</li> </ul>"},{"location":"samples/openbank/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    API Layer                                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502  PersonsController \u2502  \u2502 AccountsController \u2502  \u2502  Other APIs  \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Application Layer                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502    Commands     \u2502  \u2502     Queries     \u2502  \u2502     Events     \u2502   \u2502\n\u2502  \u2502   Handlers      \u2502  \u2502    Handlers     \u2502  \u2502   Handlers     \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Domain Layer                                 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502     Person      \u2502  \u2502     Account     \u2502  \u2502    Address     \u2502   \u2502\n\u2502  \u2502   Aggregate     \u2502  \u2502   Aggregate     \u2502  \u2502 Value Object   \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Integration Layer                              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502 Event Store     \u2502  \u2502   MongoDB       \u2502  \u2502  API Clients   \u2502   \u2502\n\u2502  \u2502 Repository      \u2502  \u2502  Repository     \u2502  \u2502                \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"samples/openbank/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"samples/openbank/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+</li> <li>Docker and Docker Compose</li> <li>MongoDB (via Docker)</li> <li>EventStoreDB (via Docker)</li> </ul>"},{"location":"samples/openbank/#setup","title":"Setup","text":"<ol> <li>Start Dependencies:</li> </ol> <pre><code>cd samples/openbank\ndocker-compose up -d mongodb eventstoredb\n</code></pre> <ol> <li>Install Dependencies:</li> </ol> <pre><code>pip install -r requirements.txt\n</code></pre> <ol> <li>Run the Application:</li> </ol> <pre><code>python api/main.py\n</code></pre> <ol> <li> <p>Access the API:</p> </li> <li> <p>API Documentation: http://localhost:8000/api/docs</p> </li> <li>EventStoreDB UI: http://localhost:2113 (admin/changeit)</li> </ol>"},{"location":"samples/openbank/#project-structure","title":"\ud83d\udcc1 Project Structure","text":"<pre><code>samples/openbank/\n\u251c\u2500\u2500 api/\n\u2502   \u251c\u2500\u2500 main.py                     # Application entry point\n\u2502   \u2514\u2500\u2500 controllers/\n\u2502       \u251c\u2500\u2500 persons_controller.py   # Person management API\n\u2502       \u2514\u2500\u2500 accounts_controller.py  # Account management API\n\u251c\u2500\u2500 application/\n\u2502   \u251c\u2500\u2500 commands/\n\u2502   \u2502   \u251c\u2500\u2500 persons/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 register_person_command.py\n\u2502   \u2502   \u2514\u2500\u2500 accounts/\n\u2502   \u2502       \u251c\u2500\u2500 open_account_command.py\n\u2502   \u2502       \u2514\u2500\u2500 deposit_command.py\n\u2502   \u251c\u2500\u2500 queries/\n\u2502   \u2502   \u251c\u2500\u2500 person_by_id.py\n\u2502   \u2502   \u2514\u2500\u2500 account_by_owner.py\n\u2502   \u2514\u2500\u2500 events/\n\u2502       \u251c\u2500\u2500 integration/\n\u2502       \u2502   \u2514\u2500\u2500 person_registered_handler.py\n\u2502       \u2514\u2500\u2500 domain/\n\u251c\u2500\u2500 domain/\n\u2502   \u2514\u2500\u2500 models/\n\u2502       \u251c\u2500\u2500 person.py               # Person aggregate\n\u2502       \u251c\u2500\u2500 account.py              # Account aggregate\n\u2502       \u2514\u2500\u2500 address.py              # Address value object\n\u2514\u2500\u2500 integration/\n    \u251c\u2500\u2500 models/                     # DTOs and read models\n    \u2502   \u251c\u2500\u2500 person.py\n    \u2502   \u2514\u2500\u2500 account.py\n    \u2514\u2500\u2500 commands/                   # API command DTOs\n        \u2514\u2500\u2500 persons/\n            \u2514\u2500\u2500 register_person_command_dto.py\n</code></pre>"},{"location":"samples/openbank/#domain-models","title":"\ud83c\udfdb\ufe0f Domain Models","text":""},{"location":"samples/openbank/#person-aggregate","title":"Person Aggregate","text":"<p>The Person aggregate manages person registration and personal information:</p> <pre><code>from dataclasses import dataclass\nfrom datetime import date\nfrom neuroglia.data.abstractions import AggregateRoot\nfrom samples.openbank.integration import PersonGender\n\n@dataclass\nclass PersonState:\n    \"\"\"Person aggregate state\"\"\"\n    id: str = None\n    first_name: str = None\n    last_name: str = None\n    nationality: str = None\n    gender: PersonGender = None\n    date_of_birth: date = None\n    address: Address = None\n\nclass Person(AggregateRoot[str]):\n    \"\"\"Person aggregate root\"\"\"\n\n    def __init__(self, id: str = None):\n        super().__init__(id)\n        self.state = PersonState()\n\n    def register(self, first_name: str, last_name: str, nationality: str, \n                gender: PersonGender, date_of_birth: date, address: Address):\n        \"\"\"Register a new person\"\"\"\n\n        # Validate business rules\n        if not first_name or not last_name:\n            raise ValueError(\"First name and last name are required\")\n\n        if date_of_birth &gt;= date.today():\n            raise ValueError(\"Date of birth must be in the past\")\n\n        # Raise domain event\n        self.apply(PersonRegisteredEvent(\n            person_id=self.id,\n            first_name=first_name,\n            last_name=last_name,\n            nationality=nationality,\n            gender=gender,\n            date_of_birth=date_of_birth,\n            address=address\n        ))\n\n    def update_address(self, new_address: Address):\n        \"\"\"Update person's address\"\"\"\n        self.apply(PersonAddressUpdatedEvent(\n            person_id=self.id,\n            old_address=self.state.address,\n            new_address=new_address\n        ))\n\n    # Event handlers\n    def on_person_registered(self, event: PersonRegisteredEvent):\n        \"\"\"Handle person registered event\"\"\"\n        self.state.id = event.person_id\n        self.state.first_name = event.first_name\n        self.state.last_name = event.last_name\n        self.state.nationality = event.nationality\n        self.state.gender = event.gender\n        self.state.date_of_birth = event.date_of_birth\n        self.state.address = event.address\n\n    def on_person_address_updated(self, event: PersonAddressUpdatedEvent):\n        \"\"\"Handle address updated event\"\"\"\n        self.state.address = event.new_address\n</code></pre>"},{"location":"samples/openbank/#account-aggregate","title":"Account Aggregate","text":"<p>The Account aggregate manages banking accounts and transactions:</p> <pre><code>from decimal import Decimal\nfrom neuroglia.data.abstractions import AggregateRoot\n\n@dataclass\nclass AccountState:\n    \"\"\"Account aggregate state\"\"\"\n    id: str = None\n    owner_id: str = None\n    account_number: str = None\n    balance: Decimal = Decimal('0.00')\n    currency: str = 'USD'\n    is_active: bool = True\n\nclass Account(AggregateRoot[str]):\n    \"\"\"Account aggregate root\"\"\"\n\n    def __init__(self, id: str = None):\n        super().__init__(id)\n        self.state = AccountState()\n\n    def open(self, owner_id: str, account_number: str, initial_deposit: Decimal = None):\n        \"\"\"Open a new account\"\"\"\n\n        # Validate business rules\n        if not owner_id:\n            raise ValueError(\"Owner ID is required\")\n\n        if not account_number:\n            raise ValueError(\"Account number is required\")\n\n        if initial_deposit and initial_deposit &lt; Decimal('0'):\n            raise ValueError(\"Initial deposit cannot be negative\")\n\n        # Raise domain event\n        self.apply(AccountOpenedEvent(\n            account_id=self.id,\n            owner_id=owner_id,\n            account_number=account_number,\n            initial_deposit=initial_deposit or Decimal('0.00')\n        ))\n\n    def deposit(self, amount: Decimal, description: str = None):\n        \"\"\"Deposit money to the account\"\"\"\n\n        # Validate business rules\n        if amount &lt;= Decimal('0'):\n            raise ValueError(\"Deposit amount must be positive\")\n\n        if not self.state.is_active:\n            raise ValueError(\"Cannot deposit to inactive account\")\n\n        # Raise domain event\n        self.apply(MoneyDepositedEvent(\n            account_id=self.id,\n            amount=amount,\n            description=description,\n            balance_after=self.state.balance + amount\n        ))\n\n    def withdraw(self, amount: Decimal, description: str = None):\n        \"\"\"Withdraw money from the account\"\"\"\n\n        # Validate business rules\n        if amount &lt;= Decimal('0'):\n            raise ValueError(\"Withdrawal amount must be positive\")\n\n        if not self.state.is_active:\n            raise ValueError(\"Cannot withdraw from inactive account\")\n\n        if self.state.balance &lt; amount:\n            raise ValueError(\"Insufficient funds\")\n\n        # Raise domain event\n        self.apply(MoneyWithdrawnEvent(\n            account_id=self.id,\n            amount=amount,\n            description=description,\n            balance_after=self.state.balance - amount\n        ))\n\n    # Event handlers\n    def on_account_opened(self, event: AccountOpenedEvent):\n        \"\"\"Handle account opened event\"\"\"\n        self.state.id = event.account_id\n        self.state.owner_id = event.owner_id\n        self.state.account_number = event.account_number\n        self.state.balance = event.initial_deposit\n\n    def on_money_deposited(self, event: MoneyDepositedEvent):\n        \"\"\"Handle money deposited event\"\"\"\n        self.state.balance = event.balance_after\n\n    def on_money_withdrawn(self, event: MoneyWithdrawnEvent):\n        \"\"\"Handle money withdrawn event\"\"\"\n        self.state.balance = event.balance_after\n</code></pre>"},{"location":"samples/openbank/#application-layer","title":"\ud83d\udcbc Application Layer","text":""},{"location":"samples/openbank/#command-handlers","title":"Command Handlers","text":"<p>Command handlers execute business operations:</p> <pre><code>from neuroglia.mediation.mediator import CommandHandler\nfrom neuroglia.data.infrastructure.abstractions import Repository\n\nclass RegisterPersonCommandHandler(CommandHandler[RegisterPersonCommand, OperationResult[PersonDto]]):\n    \"\"\"Handles person registration commands\"\"\"\n\n    def __init__(self, \n                 mapper: Mapper,\n                 person_repository: Repository[Person, str]):\n        self.mapper = mapper\n        self.person_repository = person_repository\n\n    async def handle_async(self, command: RegisterPersonCommand) -&gt; OperationResult[PersonDto]:\n        try:\n            # Create new person aggregate\n            person = Person(str(uuid.uuid4()))\n\n            # Execute business operation\n            person.register(\n                first_name=command.first_name,\n                last_name=command.last_name,\n                nationality=command.nationality,\n                gender=command.gender,\n                date_of_birth=command.date_of_birth,\n                address=command.address\n            )\n\n            # Save to event store\n            saved_person = await self.person_repository.add_async(person)\n\n            # Map to DTO and return\n            person_dto = self.mapper.map(saved_person.state, PersonDto)\n            return self.created(person_dto)\n\n        except ValueError as ex:\n            return self.bad_request(str(ex))\n        except Exception as ex:\n            return self.internal_error(f\"Failed to register person: {ex}\")\n\nclass DepositCommandHandler(CommandHandler[DepositCommand, OperationResult[AccountDto]]):\n    \"\"\"Handles money deposit commands\"\"\"\n\n    def __init__(self, \n                 mapper: Mapper,\n                 account_repository: Repository[Account, str]):\n        self.mapper = mapper\n        self.account_repository = account_repository\n\n    async def handle_async(self, command: DepositCommand) -&gt; OperationResult[AccountDto]:\n        try:\n            # Load account from event store\n            account = await self.account_repository.get_by_id_async(command.account_id)\n            if account is None:\n                return self.not_found(\"Account not found\")\n\n            # Execute business operation\n            account.deposit(command.amount, command.description)\n\n            # Save changes\n            await self.account_repository.update_async(account)\n\n            # Map to DTO and return\n            account_dto = self.mapper.map(account.state, AccountDto)\n            return self.ok(account_dto)\n\n        except ValueError as ex:\n            return self.bad_request(str(ex))\n        except Exception as ex:\n            return self.internal_error(f\"Failed to deposit money: {ex}\")\n</code></pre>"},{"location":"samples/openbank/#query-handlers","title":"Query Handlers","text":"<p>Query handlers retrieve data for read operations:</p> <pre><code>class GetPersonByIdQueryHandler(QueryHandler[GetPersonByIdQuery, OperationResult[PersonDto]]):\n    \"\"\"Handles person lookup queries\"\"\"\n\n    def __init__(self, \n                 mapper: Mapper,\n                 person_repository: Repository[PersonDto, str]):  # Read model repository\n        self.mapper = mapper\n        self.person_repository = person_repository\n\n    async def handle_async(self, query: GetPersonByIdQuery) -&gt; OperationResult[PersonDto]:\n        person = await self.person_repository.get_by_id_async(query.person_id)\n\n        if person is None:\n            return self.not_found(f\"Person with ID {query.person_id} not found\")\n\n        return self.ok(person)\n\nclass GetAccountsByOwnerQueryHandler(QueryHandler[GetAccountsByOwnerQuery, OperationResult[List[AccountDto]]]):\n    \"\"\"Handles account lookup by owner queries\"\"\"\n\n    def __init__(self, account_repository: Repository[AccountDto, str]):\n        self.account_repository = account_repository\n\n    async def handle_async(self, query: GetAccountsByOwnerQuery) -&gt; OperationResult[List[AccountDto]]:\n        accounts = await self.account_repository.find_by_criteria_async(\n            {\"owner_id\": query.owner_id}\n        )\n        return self.ok(accounts)\n</code></pre>"},{"location":"samples/openbank/#event-handling","title":"\ud83d\udce1 Event Handling","text":""},{"location":"samples/openbank/#domain-events","title":"Domain Events","text":"<p>Domain events represent business events within aggregates:</p> <pre><code>@dataclass\nclass PersonRegisteredEvent(DomainEvent):\n    \"\"\"Event raised when a person is registered\"\"\"\n    person_id: str\n    first_name: str\n    last_name: str\n    nationality: str\n    gender: PersonGender\n    date_of_birth: date\n    address: Address\n\n@dataclass\nclass AccountOpenedEvent(DomainEvent):\n    \"\"\"Event raised when an account is opened\"\"\"\n    account_id: str\n    owner_id: str\n    account_number: str\n    initial_deposit: Decimal\n\n@dataclass\nclass MoneyDepositedEvent(DomainEvent):\n    \"\"\"Event raised when money is deposited\"\"\"\n    account_id: str\n    amount: Decimal\n    description: str\n    balance_after: Decimal\n</code></pre>"},{"location":"samples/openbank/#integration-events","title":"Integration Events","text":"<p>Integration events handle cross-bounded-context communication:</p> <pre><code>class PersonRegisteredIntegrationEventHandler(EventHandler[PersonRegisteredEvent]):\n    \"\"\"Handles person registered events for integration purposes\"\"\"\n\n    def __init__(self, \n                 cloud_event_publisher: CloudEventPublisher,\n                 mapper: Mapper):\n        self.cloud_event_publisher = cloud_event_publisher\n        self.mapper = mapper\n\n    async def handle_async(self, event: PersonRegisteredEvent):\n        # Create integration event\n        integration_event = PersonRegisteredIntegrationEvent(\n            person_id=event.person_id,\n            email=event.email,\n            full_name=f\"{event.first_name} {event.last_name}\",\n            timestamp=datetime.utcnow()\n        )\n\n        # Publish as CloudEvent\n        await self.cloud_event_publisher.publish_async(\n            event_type=\"person.registered.v1\",\n            data=integration_event,\n            source=\"openbank.persons\"\n        )\n</code></pre>"},{"location":"samples/openbank/#data-access","title":"\ud83d\uddc4\ufe0f Data Access","text":""},{"location":"samples/openbank/#event-sourcing-repository","title":"Event Sourcing Repository","text":"<p>The write model uses event sourcing:</p> <pre><code># Configuration in main.py\nfrom neuroglia.data.infrastructure.event_sourcing import EventSourcingRepository\nfrom neuroglia.data.infrastructure.event_sourcing.event_store import ESEventStore\n\n# Configure Event Store\nESEventStore.configure(builder, EventStoreOptions(database_name, consumer_group))\n\n# Configure event sourcing repositories\nDataAccessLayer.WriteModel.configure(\n    builder, \n    [\"samples.openbank.domain.models\"], \n    lambda builder_, entity_type, key_type: EventSourcingRepository.configure(\n        builder_, entity_type, key_type\n    )\n)\n</code></pre>"},{"location":"samples/openbank/#read-model-repository","title":"Read Model Repository","text":"<p>The read model uses MongoDB:</p> <pre><code># Configuration in main.py\nfrom neuroglia.data.infrastructure.mongo import MongoRepository\n\n# Configure MongoDB repositories\nDataAccessLayer.ReadModel.configure(\n    builder,\n    [\"samples.openbank.integration.models\", \"samples.openbank.application.events\"],\n    lambda builder_, entity_type, key_type: MongoRepository.configure(\n        builder_, entity_type, key_type, database_name\n    )\n)\n</code></pre>"},{"location":"samples/openbank/#api-layer","title":"\ud83c\udf10 API Layer","text":""},{"location":"samples/openbank/#controllers","title":"Controllers","text":"<p>Controllers expose the domain through REST APIs:</p> <pre><code>class PersonsController(ControllerBase):\n    \"\"\"Persons management API\"\"\"\n\n    @post(\"/\", response_model=PersonDto, status_code=201)\n    async def register_person(self, command: RegisterPersonCommandDto) -&gt; PersonDto:\n        \"\"\"Register a new person\"\"\"\n        # Map DTO to domain command\n        domain_command = self.mapper.map(command, RegisterPersonCommand)\n\n        # Execute through mediator\n        result = await self.mediator.execute_async(domain_command)\n\n        # Process and return result\n        return self.process(result)\n\n    @get(\"/\", response_model=List[PersonDto])\n    async def list_persons(self) -&gt; List[PersonDto]:\n        \"\"\"List all registered persons\"\"\"\n        query = ListPersonsQuery()\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/{person_id}\", response_model=PersonDto)\n    async def get_person_by_id(self, person_id: str) -&gt; PersonDto:\n        \"\"\"Get person by ID\"\"\"\n        query = GetPersonByIdQuery(person_id=person_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\nclass AccountsController(ControllerBase):\n    \"\"\"Accounts management API\"\"\"\n\n    @post(\"/\", response_model=AccountDto, status_code=201)\n    async def open_account(self, command: OpenAccountCommandDto) -&gt; AccountDto:\n        \"\"\"Open a new account\"\"\"\n        domain_command = self.mapper.map(command, OpenAccountCommand)\n        result = await self.mediator.execute_async(domain_command)\n        return self.process(result)\n\n    @post(\"/{account_id}/deposit\", response_model=AccountDto)\n    async def deposit(self, account_id: str, command: DepositCommandDto) -&gt; AccountDto:\n        \"\"\"Deposit money to account\"\"\"\n        domain_command = self.mapper.map(command, DepositCommand)\n        domain_command.account_id = account_id\n        result = await self.mediator.execute_async(domain_command)\n        return self.process(result)\n\n    @get(\"/by-owner/{owner_id}\", response_model=List[AccountDto])\n    async def get_accounts_by_owner(self, owner_id: str) -&gt; List[AccountDto]:\n        \"\"\"Get all accounts for a person\"\"\"\n        query = GetAccountsByOwnerQuery(owner_id=owner_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"samples/openbank/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"samples/openbank/#unit-tests","title":"Unit Tests","text":"<p>Test domain logic in isolation:</p> <pre><code>def test_person_registration():\n    # Arrange\n    person = Person(\"test-id\")\n    address = Address(\"123 Main St\", \"Anytown\", \"12345\", \"USA\")\n\n    # Act\n    person.register(\n        first_name=\"John\",\n        last_name=\"Doe\",\n        nationality=\"US\",\n        gender=PersonGender.MALE,\n        date_of_birth=date(1990, 1, 1),\n        address=address\n    )\n\n    # Assert\n    assert person.state.first_name == \"John\"\n    assert person.state.last_name == \"Doe\"\n    assert len(person.uncommitted_events) == 1\n    assert isinstance(person.uncommitted_events[0], PersonRegisteredEvent)\n\ndef test_account_deposit():\n    # Arrange\n    account = Account(\"test-account\")\n    account.open(\"owner-id\", \"123456789\", Decimal('100.00'))\n\n    # Act\n    account.deposit(Decimal('50.00'), \"Test deposit\")\n\n    # Assert\n    assert account.state.balance == Decimal('150.00')\n    assert len(account.uncommitted_events) == 2  # Open + Deposit\n</code></pre>"},{"location":"samples/openbank/#integration-tests","title":"Integration Tests","text":"<p>Test the complete flow:</p> <pre><code>@pytest.mark.asyncio\nasync def test_person_registration_flow():\n    # Arrange\n    client = TestClient(app)\n    person_data = {\n        \"first_name\": \"John\",\n        \"last_name\": \"Doe\",\n        \"nationality\": \"US\",\n        \"gender\": \"MALE\",\n        \"date_of_birth\": \"1990-01-01\",\n        \"address\": {\n            \"street\": \"123 Main St\",\n            \"city\": \"Anytown\",\n            \"postal_code\": \"12345\",\n            \"country\": \"USA\"\n        }\n    }\n\n    # Act\n    response = client.post(\"/api/v1/persons\", json=person_data)\n\n    # Assert\n    assert response.status_code == 201\n    person = response.json()\n    assert person[\"first_name\"] == \"John\"\n    assert person[\"last_name\"] == \"Doe\"\n\n    # Verify person can be retrieved\n    get_response = client.get(f\"/api/v1/persons/{person['id']}\")\n    assert get_response.status_code == 200\n</code></pre>"},{"location":"samples/openbank/#running-the-sample","title":"\ud83d\ude80 Running the Sample","text":""},{"location":"samples/openbank/#start-the-application","title":"Start the Application","text":"<ol> <li>Start infrastructure:</li> </ol> <pre><code>docker-compose up -d\n</code></pre> <ol> <li>Run the application:</li> </ol> <pre><code>python api/main.py\n</code></pre>"},{"location":"samples/openbank/#example-api-calls","title":"Example API Calls","text":"<p>Register a Person:</p> <pre><code>curl -X POST \"http://localhost:8000/api/v1/persons\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"first_name\": \"John\",\n    \"last_name\": \"Doe\",\n    \"nationality\": \"US\",\n    \"gender\": \"MALE\",\n    \"date_of_birth\": \"1990-01-01\",\n    \"address\": {\n      \"street\": \"123 Main St\",\n      \"city\": \"Anytown\",\n      \"postal_code\": \"12345\",\n      \"country\": \"USA\"\n    }\n  }'\n</code></pre> <p>Open an Account:</p> <pre><code>curl -X POST \"http://localhost:8000/api/v1/accounts\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"owner_id\": \"PERSON_ID_FROM_ABOVE\",\n    \"account_number\": \"123456789\",\n    \"initial_deposit\": 1000.00\n  }'\n</code></pre> <p>Deposit Money:</p> <pre><code>curl -X POST \"http://localhost:8000/api/v1/accounts/ACCOUNT_ID/deposit\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"amount\": 500.00,\n    \"description\": \"Salary deposit\"\n  }'\n</code></pre>"},{"location":"samples/openbank/#key-learnings","title":"\ud83d\udccb Key Learnings","text":"<p>The OpenBank sample demonstrates:</p> <ol> <li>Event Sourcing: How to store state as a sequence of events</li> <li>CQRS: Separation of write and read models</li> <li>Domain-Driven Design: Rich domain models with business rules</li> <li>Clean Architecture: Clear separation of concerns</li> <li>Event-Driven Architecture: How events enable loose coupling</li> <li>Repository Pattern: Abstract data access for different storage types</li> <li>Integration Events: Cross-bounded-context communication</li> </ol>"},{"location":"samples/openbank/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Basic Neuroglia concepts</li> <li>Architecture Guide - Understanding the architecture</li> <li>Event Sourcing - Event sourcing patterns</li> <li>CQRS &amp; Mediation - Command and query patterns</li> <li>Event Handling - Event-driven architecture</li> </ul>"}]}