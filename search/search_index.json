{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83e\udde0 Neuroglia Python Framework","text":"<p>A lightweight, opinionated Python framework built on FastAPI that enforces clean architecture principles and provides comprehensive tooling for building production-ready microservices.</p>"},{"location":"#whats-included","title":"\ud83d\ude80 What's Included","text":""},{"location":"#framework-core","title":"\ud83c\udfd7\ufe0f Framework Core","text":"<p>Clean architecture patterns with dependency injection, CQRS, event-driven design, and comprehensive testing utilities.</p>"},{"location":"#real-world-samples","title":"\ud83c\udf55 Real-World Samples","text":"<p>Complete production examples like Mario's Pizzeria demonstrating every framework feature in realistic business scenarios.</p>"},{"location":"#cli-tooling","title":"\u2699\ufe0f CLI Tooling","text":"<p>PyNeuroctl command-line interface for managing, testing, and deploying your applications with zero configuration.</p>"},{"location":"#key-features","title":"\u2728 Key Features","text":"<ul> <li>\ud83c\udfaf CQRS &amp; Mediation: Built-in Command Query Responsibility Segregation with mediator pattern</li> <li>\ud83d\udc89 Dependency Injection: Lightweight container with automatic service discovery</li> <li>\ud83d\udd0c MVC Controllers: Class-based controllers with automatic OpenAPI generation</li> <li>\ud83d\udce1 Event-Driven: Native CloudEvents support and domain event handling</li> <li>\ud83d\uddc4\ufe0f Data Access: Repository pattern with file-based, MongoDB, and event sourcing support</li> <li>\ud83e\uddea Testing Utilities: Comprehensive testing patterns for all architectural layers</li> </ul>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"<p>Get started with Neuroglia in minutes:</p> <pre><code># Install the framework\npip install neuroglia\n\n# Create your first app\npyneuroctl new myapp --template pizzeria\ncd myapp\n\n# Run the application\npython main.py\n</code></pre> <p>Visit <code>http://localhost:8000/docs</code> to explore the auto-generated API documentation.</p>"},{"location":"#learn-more","title":"\ud83d\udcda Learn More","text":"<ul> <li>Getting Started - Step-by-step tutorial building your first application</li> <li>Mario's Pizzeria - Complete bounded context with visual architecture diagrams</li> <li>Patterns - Software design patterns and best practices</li> <li>Features - Deep dive into framework capabilities</li> <li>Guides - How-to procedures and troubleshooting</li> </ul>"},{"location":"#perfect-for","title":"\ud83c\udfaf Perfect For","text":"<ul> <li>Microservices: Clean architecture for scalable service development</li> <li>Event-Driven Systems: Built-in CloudEvents and domain event support</li> <li>API Development: FastAPI-based with automatic OpenAPI documentation</li> <li>Domain-Driven Design: Enforce DDD patterns and bounded contexts</li> <li>Clean Code: Opinionated structure that promotes maintainable code</li> </ul>"},{"location":"#architecture-overview","title":"\ud83d\udd27 Architecture Overview","text":"<p>Neuroglia enforces a four-layer clean architecture:</p> <pre><code>\ud83d\udcc1 Your Application\n\u251c\u2500\u2500 \ud83c\udf10 api/          # Controllers, DTOs, Routes\n\u251c\u2500\u2500 \ud83d\udcbc application/  # Commands, Queries, Handlers\n\u251c\u2500\u2500 \ud83c\udfdb\ufe0f domain/       # Entities, Business Rules\n\u2514\u2500\u2500 \ud83d\udd0c integration/ # Repositories, External APIs\n</code></pre> <p>Dependency Rule: Dependencies only flow inward (API \u2192 Application \u2192 Domain \u2190 Integration)</p>"},{"location":"#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ol> <li>Start Learning: Follow the Getting Started Guide</li> <li>See It In Action: Explore Mario's Pizzeria sample</li> <li>Understand Patterns: Review common patterns used throughout</li> <li>Deep Dive: Explore specific framework features</li> </ol> <p>Neuroglia Python Framework - Building better software through better architecture \ud83e\udde0\u2728</p>"},{"location":"_pizzeria_domain/","title":"\ud83c\udf55 Pizzeria Domain Model - Documentation Example","text":"<p>This document defines the unified pizzeria domain model used consistently throughout all Neuroglia documentation.</p>"},{"location":"_pizzeria_domain/#domain-overview","title":"\ud83d\udccb Domain Overview","text":"<p>Mario's Pizzeria is a simple restaurant that:</p> <ul> <li>Takes pizza orders from customers</li> <li>Manages pizza recipes and inventory</li> <li>Cooks pizzas in the kitchen</li> <li>Tracks order status and completion</li> <li>Handles payments and customer notifications</li> </ul>"},{"location":"_pizzeria_domain/#domain-entities","title":"\ud83c\udfd7\ufe0f Domain Entities","text":""},{"location":"_pizzeria_domain/#pizza","title":"Pizza","text":"<pre><code>from dataclasses import dataclass\nfrom typing import List, Optional\nfrom decimal import Decimal\nfrom neuroglia.data.abstractions import Entity\n\n@dataclass\nclass Pizza(Entity[str]):\n    \"\"\"A pizza with toppings and size\"\"\"\n    id: str\n    name: str\n    size: str  # \"small\", \"medium\", \"large\"\n    base_price: Decimal\n    toppings: List[str]\n    preparation_time_minutes: int\n\n    @property\n    def total_price(self) -&gt; Decimal:\n        return self.base_price + (Decimal(\"1.50\") * len(self.toppings))\n</code></pre>"},{"location":"_pizzeria_domain/#order","title":"Order","text":"<pre><code>@dataclass\nclass Order(Entity[str]):\n    \"\"\"A customer pizza order\"\"\"\n    id: str\n    customer_name: str\n    customer_phone: str\n    pizzas: List[Pizza]\n    status: str  # \"pending\", \"cooking\", \"ready\", \"delivered\"\n    order_time: datetime\n    estimated_ready_time: Optional[datetime] = None\n    total_amount: Optional[Decimal] = None\n\n    def __post_init__(self):\n        if self.total_amount is None:\n            self.total_amount = sum(pizza.total_price for pizza in self.pizzas)\n</code></pre>"},{"location":"_pizzeria_domain/#kitchen","title":"Kitchen","text":"<pre><code>@dataclass\nclass Kitchen(Entity[str]):\n    \"\"\"Kitchen state and cooking capacity\"\"\"\n    id: str\n    active_orders: List[str]  # Order IDs being cooked\n    max_concurrent_orders: int = 3\n\n    @property\n    def is_busy(self) -&gt; bool:\n        return len(self.active_orders) &gt;= self.max_concurrent_orders\n</code></pre>"},{"location":"_pizzeria_domain/#value-objects","title":"\ud83d\udcca Value Objects","text":""},{"location":"_pizzeria_domain/#address","title":"Address","text":"<pre><code>@dataclass\nclass Address:\n    street: str\n    city: str\n    zip_code: str\n\n    def __str__(self) -&gt; str:\n        return f\"{self.street}, {self.city} {self.zip_code}\"\n</code></pre>"},{"location":"_pizzeria_domain/#money","title":"Money","text":"<pre><code>@dataclass\nclass Money:\n    amount: Decimal\n    currency: str = \"USD\"\n\n    def __str__(self) -&gt; str:\n        return f\"${self.amount:.2f}\"\n</code></pre>"},{"location":"_pizzeria_domain/#commands-write-operations","title":"\ud83c\udfaf Commands (Write Operations)","text":""},{"location":"_pizzeria_domain/#placeordercommand","title":"PlaceOrderCommand","text":"<pre><code>@dataclass\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    customer_name: str\n    customer_phone: str\n    pizzas: List[PizzaOrderItem]\n    delivery_address: Optional[Address] = None\n</code></pre>"},{"location":"_pizzeria_domain/#startcookingcommand","title":"StartCookingCommand","text":"<pre><code>@dataclass\nclass StartCookingCommand(Command[OperationResult[OrderDto]]):\n    order_id: str\n</code></pre>"},{"location":"_pizzeria_domain/#completeordercommand","title":"CompleteOrderCommand","text":"<pre><code>@dataclass\nclass CompleteOrderCommand(Command[OperationResult[OrderDto]]):\n    order_id: str\n</code></pre>"},{"location":"_pizzeria_domain/#queries-read-operations","title":"\ud83d\udd0d Queries (Read Operations)","text":""},{"location":"_pizzeria_domain/#getorderquery","title":"GetOrderQuery","text":"<pre><code>@dataclass\nclass GetOrderQuery(Query[OperationResult[OrderDto]]):\n    order_id: str\n</code></pre>"},{"location":"_pizzeria_domain/#getmenuquery","title":"GetMenuQuery","text":"<pre><code>@dataclass\nclass GetMenuQuery(Query[OperationResult[List[PizzaDto]]]):\n    pass\n</code></pre>"},{"location":"_pizzeria_domain/#getkitchenstatusquery","title":"GetKitchenStatusQuery","text":"<pre><code>@dataclass\nclass GetKitchenStatusQuery(Query[OperationResult[KitchenStatusDto]]):\n    pass\n</code></pre>"},{"location":"_pizzeria_domain/#events","title":"\ud83d\udce1 Events","text":""},{"location":"_pizzeria_domain/#orderplacedevent","title":"OrderPlacedEvent","text":"<pre><code>@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    order_id: str\n    customer_name: str\n    total_amount: Decimal\n    estimated_ready_time: datetime\n</code></pre>"},{"location":"_pizzeria_domain/#cookingstartedevent","title":"CookingStartedEvent","text":"<pre><code>@dataclass\nclass CookingStartedEvent(DomainEvent):\n    order_id: str\n    started_at: datetime\n</code></pre>"},{"location":"_pizzeria_domain/#orderreadyevent","title":"OrderReadyEvent","text":"<pre><code>@dataclass\nclass OrderReadyEvent(DomainEvent):\n    order_id: str\n    customer_name: str\n    customer_phone: str\n</code></pre>"},{"location":"_pizzeria_domain/#dtos-data-transfer-objects","title":"\ud83d\udccb DTOs (Data Transfer Objects)","text":""},{"location":"_pizzeria_domain/#orderdto","title":"OrderDto","text":"<pre><code>@dataclass\nclass OrderDto:\n    id: str\n    customer_name: str\n    customer_phone: str\n    pizzas: List[PizzaDto]\n    status: str\n    total_amount: str  # Formatted money\n    order_time: str   # ISO datetime\n    estimated_ready_time: Optional[str] = None\n</code></pre>"},{"location":"_pizzeria_domain/#pizzadto","title":"PizzaDto","text":"<pre><code>@dataclass\nclass PizzaDto:\n    id: str\n    name: str\n    size: str\n    toppings: List[str]\n    price: str  # Formatted money\n</code></pre>"},{"location":"_pizzeria_domain/#createorderdto","title":"CreateOrderDto","text":"<pre><code>@dataclass\nclass CreateOrderDto:\n    customer_name: str\n    customer_phone: str\n    pizzas: List[PizzaOrderItem]\n    delivery_address: Optional[AddressDto] = None\n</code></pre>"},{"location":"_pizzeria_domain/#file-based-persistence-structure","title":"\ud83d\uddc2\ufe0f File-Based Persistence Structure","text":"<pre><code>pizzeria_data/\n\u251c\u2500\u2500 orders/\n\u2502   \u251c\u2500\u2500 2024-09-22/           # Orders by date\n\u2502   \u2502   \u251c\u2500\u2500 order_001.json\n\u2502   \u2502   \u251c\u2500\u2500 order_002.json\n\u2502   \u2502   \u2514\u2500\u2500 order_003.json\n\u2502   \u2514\u2500\u2500 index.json            # Order index\n\u251c\u2500\u2500 menu/\n\u2502   \u2514\u2500\u2500 pizzas.json           # Available pizzas\n\u251c\u2500\u2500 kitchen/\n\u2502   \u2514\u2500\u2500 status.json           # Kitchen state\n\u2514\u2500\u2500 customers/\n    \u2514\u2500\u2500 customers.json        # Customer history\n</code></pre>"},{"location":"_pizzeria_domain/#api-endpoints","title":"\ud83c\udf10 API Endpoints","text":""},{"location":"_pizzeria_domain/#orders-api","title":"Orders API","text":"<pre><code>POST   /api/orders           # Place new order\nGET    /api/orders/{id}      # Get order details\nGET    /api/orders           # List orders\nPUT    /api/orders/{id}/cook # Start cooking\nPUT    /api/orders/{id}/ready # Mark ready\n</code></pre>"},{"location":"_pizzeria_domain/#menu-api","title":"Menu API","text":"<pre><code>GET    /api/menu            # Get available pizzas\nGET    /api/menu/{id}       # Get pizza details\n</code></pre>"},{"location":"_pizzeria_domain/#kitchen-api","title":"Kitchen API","text":"<pre><code>GET    /api/kitchen/status  # Get kitchen status\nGET    /api/kitchen/queue   # Get cooking queue\n</code></pre>"},{"location":"_pizzeria_domain/#oauth-scopes","title":"\ud83d\udd10 OAuth Scopes","text":"<pre><code>SCOPES = {\n    \"orders:read\": \"Read order information\",\n    \"orders:write\": \"Create and modify orders\",\n    \"kitchen:read\": \"View kitchen status\",\n    \"kitchen:manage\": \"Manage kitchen operations\",\n    \"menu:read\": \"View menu items\",\n    \"admin\": \"Full administrative access\"\n}\n</code></pre>"},{"location":"_pizzeria_domain/#simple-ui-pages","title":"\ud83c\udfa8 Simple UI Pages","text":"<ol> <li>Menu Page - Display available pizzas with ordering</li> <li>Order Page - Place new orders</li> <li>Status Page - Check order status</li> <li>Kitchen Dashboard - Manage cooking queue (staff only)</li> <li>Admin Panel - Manage menu and view analytics</li> </ol>"},{"location":"_pizzeria_domain/#benefits-of-this-domain","title":"\ud83d\ude80 Benefits of This Domain","text":"<ul> <li>Familiar Context - Everyone understands pizza ordering</li> <li>Clear Bounded Context - Well-defined business operations</li> <li>Rich Domain Logic - Pricing, cooking times, status workflows</li> <li>Event-Driven - Natural events (order placed, cooking started, ready)</li> <li>Multiple User Types - Customers, kitchen staff, managers</li> <li>Simple Data Model - Easy to understand and maintain</li> <li>Realistic Complexity - Enough features to demonstrate patterns without being overwhelming</li> </ul> <p>This domain model will be used consistently across all documentation to provide clear, relatable examples of Neuroglia framework features.</p>"},{"location":"architecture/","title":"\ud83c\udfd7\ufe0f Architecture Guide","text":"<p>\u26a0\ufe0f Deprecated</p> <p>This page is deprecated and will be removed in a future version. The content has been migrated to more focused sections:</p> <pre><code>- **[Clean Architecture Pattern](patterns/clean-architecture.md)** - Four-layer separation and dependency rules\n- **[CQRS Pattern](patterns/cqrs.md)** - Command Query Responsibility Segregation\n- **[Event-Driven Pattern](patterns/event-driven.md)** - Domain events and messaging\n- **[Mario's Pizzeria](mario-pizzeria.md)** - Complete bounded context example\n- **[Features](features/)** - Framework-specific implementation details\n\nPlease use the new structure for the most up-to-date documentation.\n</code></pre> <p>Neuroglia's clean architecture is demonstrated through Mario's Pizzeria, showing how layered architecture promotes separation of concerns, testability, and maintainability in a real-world application.</p>"},{"location":"architecture/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>Clean Architecture Layers: How Mario's Pizzeria separates concerns across API, Application, Domain, and Integration layers</li> <li>Dependency Flow: How pizza order workflow demonstrates the dependency rule in practice</li> <li>CQRS Implementation: How command and query separation works in kitchen operations</li> <li>Event-Driven Design: How domain events coordinate between pizza preparation and customer notifications</li> <li>Testing Strategy: How architecture enables comprehensive testing at every layer</li> </ul>"},{"location":"architecture/#marios-pizzeria-architecture","title":"\ud83c\udf55 Mario's Pizzeria Architecture","text":""},{"location":"architecture/#overview-from-order-to-pizza","title":"Overview: From Order to Pizza","text":"<p>Mario's Pizzeria demonstrates clean architecture through the complete pizza ordering and preparation workflow:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            \ud83c\udf10 API Layer (Controllers)           \u2502  \u2190 Customer &amp; Staff Interface\n\u2502   OrdersController \u2502 MenuController \u2502 Kitchen   \u2502\n\u2502   Authentication   \u2502 Error Handling \u2502 Swagger   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 orchestrates\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502       \ud83d\udcbc Application Layer (CQRS + Events)      \u2502  \u2190 Business Workflow\n\u2502  PlaceOrderCommand \u2502 GetMenuQuery \u2502 Handlers    \u2502\n\u2502  OrderPlacedEvent  \u2502 Kitchen Workflow Pipeline  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 uses\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         \ud83c\udfdb\ufe0f Domain Layer (Business Logic)        \u2502  \u2190 Pizza Business Rules\n\u2502    Order Entity    \u2502    Pizza Entity           \u2502\n\u2502  Kitchen Workflow  \u2502  Pricing Rules            \u2502\n\u2502   Domain Events    \u2502  Business Validation      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 implements\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502      \ud83d\udd0c Integration Layer (External Systems)    \u2502  \u2190 Data &amp; External APIs\n\u2502  Order Repository  \u2502  Payment Gateway          \u2502\n\u2502   File Storage     \u2502  MongoDB \u2502 Event Store    \u2502\n\u2502  SMS Notifications \u2502  Email Service            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#the-dependency-rule-in-action","title":"The Dependency Rule in Action","text":"<p>Pizza order flow demonstrates how dependencies always point inward:</p> <ol> <li>API Layer \u2192 Application Layer: Controller calls <code>PlaceOrderCommand</code></li> <li>Application Layer \u2192 Domain Layer: Handler uses <code>Order</code> entity business logic</li> <li>Integration Layer \u2192 Domain Layer: Repository implements domain <code>IOrderRepository</code> interface</li> <li>Never: Domain layer doesn't know about API controllers or database implementation</li> </ol>"},{"location":"architecture/#layer-details-with-pizza-examples","title":"\ud83c\udfe2 Layer Details with Pizza Examples","text":""},{"location":"architecture/#api-layer-customer-staff-interface","title":"\ud83d\udce1 API Layer: Customer &amp; Staff Interface","text":"<p>Purpose: External interface for Mario's Pizzeria operations</p> <p>Responsibilities:</p> <ul> <li>HTTP endpoints for orders, menu, kitchen operations</li> <li>Customer and staff authentication (OAuth 2.0)</li> <li>Request validation and error handling</li> <li>OpenAPI documentation generation</li> </ul> <p>Key Components:</p> <pre><code># src/api/controllers/orders_controller.py\nclass OrdersController(ControllerBase):\n    \"\"\"Handle customer pizza orders\"\"\"\n\n    @post(\"/\", response_model=OrderDto, status_code=201)\n    async def place_order(self, order_request: PlaceOrderDto) -&gt; OrderDto:\n        \"\"\"Place new pizza order\"\"\"\n        command = PlaceOrderCommand(\n            customer_name=order_request.customer_name,\n            customer_phone=order_request.customer_phone,\n            pizzas=order_request.pizzas,\n            payment_method=order_request.payment_method\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)  # Framework handles success/error response\n\n# src/api/dtos/order_dto.py\nclass PlaceOrderDto(BaseModel):\n    \"\"\"Request DTO for placing pizza orders\"\"\"\n    customer_name: str = Field(..., min_length=2, max_length=100)\n    customer_phone: str = Field(..., regex=r\"^\\+?1?[2-9]\\d{9}$\")\n    customer_address: str = Field(..., min_length=10, max_length=200)\n    pizzas: List[PizzaOrderDto] = Field(..., min_items=1, max_items=20)\n    payment_method: str = Field(..., regex=\"^(cash|card|online)$\")\n</code></pre> <p>Architecture Benefits:</p> <ul> <li> <ul> <li>Framework Independence: Pure business logic with no external dependencies</li> </ul> </li> </ul>"},{"location":"architecture/#integration-layer-external-systems","title":"\ud83d\udd0c Integration Layer: External Systems","text":"<p>Purpose: Handles external system interactions and data persistence</p> <p>Responsibilities:</p> <ul> <li>Data persistence (file storage, MongoDB, event store)</li> <li>External API integration (payment, notifications)</li> <li>Infrastructure concerns (caching, logging)</li> <li>Implements domain interfaces</li> </ul> <p>Integration Components:</p> <pre><code># src/integration/repositories/file_order_repository.py\nclass FileOrderRepository(IOrderRepository):\n    \"\"\"File-based order repository for development\"\"\"\n\n    def __init__(self, orders_directory: str = \"data/orders\"):\n        self.orders_directory = Path(orders_directory)\n        self.orders_directory.mkdir(parents=True, exist_ok=True)\n\n    async def save_async(self, order: Order) -&gt; Order:\n        \"\"\"Save order to JSON file\"\"\"\n        order_file = self.orders_directory / f\"{order.id}.json\"\n\n        order_data = {\n            \"id\": order.id,\n            \"customer_name\": order.customer_name,\n            \"customer_phone\": order.customer_phone,\n            \"customer_address\": order.customer_address,\n            \"pizzas\": [self._pizza_to_dict(pizza) for pizza in order.pizzas],\n            \"status\": order.status.value,\n            \"order_time\": order.order_time.isoformat(),\n            \"total_amount\": float(order.total_amount)\n        }\n\n        async with aiofiles.open(order_file, 'w') as f:\n            await f.write(json.dumps(order_data, indent=2))\n\n        return order\n\n# src/integration/services/payment_service.py\nclass StripePaymentService(IPaymentService):\n    \"\"\"Payment processing using Stripe API\"\"\"\n\n    async def process_payment_async(self,\n                                    amount: Decimal,\n                                    payment_method: str) -&gt; PaymentResult:\n        \"\"\"Process payment through Stripe\"\"\"\n        try:\n            import stripe\n            stripe.api_key = os.getenv(\"STRIPE_SECRET_KEY\")\n\n            # Create payment intent\n            intent = stripe.PaymentIntent.create(\n                amount=int(amount * 100),  # Convert to cents\n                currency=\"usd\",\n                payment_method=payment_method,\n                confirm=True,\n                return_url=\"https://marios-pizzeria.com/payment-success\"\n            )\n\n            return PaymentResult(\n                is_success=True,\n                transaction_id=intent.id,\n                amount_processed=amount\n            )\n\n        except stripe.error.StripeError as e:\n            return PaymentResult(\n                is_success=False,\n                error_message=str(e)\n            )\n\n# src/integration/services/notification_service.py\nclass TwilioNotificationService(INotificationService):\n    \"\"\"SMS notifications using Twilio\"\"\"\n\n    async def send_order_confirmation_async(self, order: Order) -&gt; None:\n        \"\"\"Send order confirmation SMS\"\"\"\n        from twilio.rest import Client\n\n        client = Client(\n            os.getenv(\"TWILIO_ACCOUNT_SID\"),\n            os.getenv(\"TWILIO_AUTH_TOKEN\")\n        )\n\n        message = (f\"Hi {order.customer_name}! Your pizza order #{order.id} \"\n                  f\"has been confirmed. Total: ${order.total_amount}. \"\n                  f\"Estimated ready time: {order.estimated_ready_time.strftime('%I:%M %p')}\")\n\n        await client.messages.create(\n            body=message,\n            from_=os.getenv(\"TWILIO_PHONE_NUMBER\"),\n            to=order.customer_phone\n        )\n\n    async def send_order_ready_notification_async(self, order: Order) -&gt; None:\n        \"\"\"Send order ready SMS\"\"\"\n        message = (f\"\ud83c\udf55 Your order #{order.id} is ready for pickup at Mario's Pizzeria! \"\n                  f\"Please arrive within 15 minutes to keep your pizzas hot.\")\n\n        # Implementation details...\n</code></pre>"},{"location":"architecture/#cqrs-implementation-in-marios-pizzeria","title":"\ud83c\udfaf CQRS Implementation in Mario's Pizzeria","text":""},{"location":"architecture/#command-and-query-separation","title":"Command and Query Separation","text":"<p>Mario's Pizzeria demonstrates CQRS (Command Query Responsibility Segregation):</p> <pre><code># Commands: Change state (Write operations)\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Command to place new pizza order\"\"\"\n    pass\n\nclass UpdateOrderStatusCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Command to update order status in kitchen\"\"\"\n    pass\n\nclass CancelOrderCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Command to cancel existing order\"\"\"\n    pass\n\n# Queries: Read state (Read operations)\nclass GetOrderByIdQuery(Query[OrderDto]):\n    \"\"\"Query to get specific order details\"\"\"\n    pass\n\nclass GetKitchenQueueQuery(Query[List[KitchenOrderDto]]):\n    \"\"\"Query to get orders in kitchen preparation queue\"\"\"\n    pass\n\nclass GetMenuQuery(Query[List[PizzaDto]]):\n    \"\"\"Query to get available pizza menu\"\"\"\n    pass\n</code></pre>"},{"location":"architecture/#benefits-of-cqrs-in-pizzeria-context","title":"Benefits of CQRS in Pizzeria Context","text":"<p>Write Side (Commands):</p> <ul> <li>Order Placement: Validates business rules, processes payments</li> <li>Kitchen Operations: Updates order status, manages workflow</li> <li>Menu Management: Updates pizza availability, pricing</li> </ul> <p>Read Side (Queries):</p> <ul> <li>Customer App: Fast menu browsing, order tracking</li> <li>Kitchen Display: Real-time queue updates</li> <li>Analytics: Revenue reports, performance metrics</li> </ul> <p>Separate Optimization:</p> <ul> <li>Commands use MongoDB for ACID transactions</li> <li>Queries use optimized read models for fast retrieval</li> <li>Analytics use event store for historical data</li> </ul>"},{"location":"architecture/#event-driven-architecture","title":"\ud83d\udcca Event-Driven Architecture","text":""},{"location":"architecture/#domain-events-in-pizza-workflow","title":"Domain Events in Pizza Workflow","text":"<p>Events coordinate between different parts of Mario's Pizzeria:</p> <pre><code># Domain events flow through the system\nOrderPlacedEvent \u2192 KitchenNotificationHandler \u2192 Kitchen Display Update\n                \u2198 CustomerConfirmationHandler \u2192 SMS Confirmation\n                \u2198 InventoryHandler \u2192 Update Pizza Availability\n\nOrderReadyEvent \u2192 CustomerNotificationHandler \u2192 \"Order Ready\" SMS\n               \u2198 DeliveryScheduleHandler \u2192 Schedule Delivery\n\nOrderCompletedEvent \u2192 AnalyticsHandler \u2192 Update Revenue Metrics\n                   \u2198 CustomerHistoryHandler \u2192 Update Customer Profile\n</code></pre>"},{"location":"architecture/#event-handler-examples","title":"Event Handler Examples","text":"<pre><code>class KitchenNotificationHandler(EventHandler[OrderPlacedEvent]):\n    \"\"\"Update kitchen display when new order placed\"\"\"\n\n    async def handle_async(self, event: OrderPlacedEvent):\n        # Add order to kitchen queue\n        command = AddToKitchenQueueCommand(\n            order_id=event.order_id,\n            estimated_ready_time=event.estimated_ready_time\n        )\n        await self.mediator.execute_async(command)\n\nclass CustomerNotificationHandler(EventHandler[OrderReadyEvent]):\n    \"\"\"Notify customer when order is ready\"\"\"\n\n    async def handle_async(self, event: OrderReadyEvent):\n        # Send SMS notification\n        await self.notification_service.send_order_ready_notification_async(\n            order_id=event.order_id,\n            customer_phone=event.customer_phone\n        )\n\nclass RevenueAnalyticsHandler(EventHandler[OrderCompletedEvent]):\n    \"\"\"Update revenue analytics when order completed\"\"\"\n\n    async def handle_async(self, event: OrderCompletedEvent):\n        # Update daily revenue\n        command = UpdateDailyRevenueCommand(\n            date=event.completed_at.date(),\n            amount=event.total_amount,\n            order_count=1\n        )\n        await self.mediator.execute_async(command)\n</code></pre>"},{"location":"architecture/#testing-strategy-across-layers","title":"\ud83e\uddea Testing Strategy Across Layers","text":""},{"location":"architecture/#layer-specific-testing-approaches","title":"Layer-Specific Testing Approaches","text":"<p>Each layer in Mario's Pizzeria has specific testing strategies:</p> <p>API Layer (Controllers):</p> <ul> <li>Unit Tests: Mock mediator, test HTTP status codes and response formatting</li> <li>Integration Tests: Test full HTTP request/response cycle with real dependencies</li> <li>Contract Tests: Validate request/response schemas match OpenAPI spec</li> </ul> <pre><code>@pytest.mark.asyncio\nasync def test_place_order_success(orders_controller, mock_mediator):\n    \"\"\"Test successful order placement through controller\"\"\"\n    # Arrange\n    order_request = PlaceOrderDto(\n        customer_name=\"Test Customer\",\n        customer_phone=\"+1234567890\",\n        pizzas=[PizzaOrderDto(name=\"Margherita\", size=\"large\", quantity=1)]\n    )\n\n    expected_order = OrderDto(id=\"order_123\", status=\"received\")\n    mock_mediator.execute_async.return_value = OperationResult.success(expected_order)\n\n    # Act\n    result = await orders_controller.place_order(order_request)\n\n    # Assert\n    assert result.id == \"order_123\"\n    assert result.status == \"received\"\n</code></pre> <p>Application Layer (Handlers):</p> <ul> <li>Unit Tests: Mock all dependencies (repositories, external services)</li> <li>Behavior Tests: Verify business workflow logic and error handling</li> <li>Event Tests: Validate domain events are raised correctly</li> </ul> <pre><code>@pytest.mark.asyncio\nasync def test_place_order_handler_workflow(mock_order_repo, mock_payment_service):\n    \"\"\"Test complete order placement workflow\"\"\"\n    # Arrange\n    handler = PlaceOrderCommandHandler(mock_order_repo, mock_payment_service, ...)\n    command = PlaceOrderCommand(customer_name=\"Test\", pizzas=[...])\n\n    mock_payment_service.process_payment_async.return_value = PaymentResult(success=True)\n    mock_order_repo.save_async.return_value = Order(id=\"order_123\")\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n    mock_payment_service.process_payment_async.assert_called_once()\n    mock_order_repo.save_async.assert_called_once()\n</code></pre> <p>Domain Layer (Entities &amp; Services):</p> <ul> <li>Unit Tests: Pure business logic testing with no external dependencies</li> <li>Business Rule Tests: Validate invariants and business constraints</li> <li>Event Tests: Ensure domain events are raised for business-significant changes</li> </ul> <pre><code>def test_order_total_calculation():\n    \"\"\"Test pizza order total calculation business logic\"\"\"\n    # Arrange\n    pizzas = [\n        Pizza(\"Margherita\", \"large\", [\"extra_cheese\"]),\n        Pizza(\"Pepperoni\", \"medium\", [])\n    ]\n\n    # Act\n    order = Order.create_new(\"Customer\", \"+1234567890\", \"Address\", pizzas, \"card\")\n\n    # Assert\n    expected_subtotal = Decimal(\"15.99\") + Decimal(\"12.99\")  # Pizza prices\n    expected_tax = expected_subtotal * Decimal(\"0.0875\")     # 8.75% tax\n    expected_delivery = Decimal(\"2.99\")                      # Delivery fee\n    expected_total = expected_subtotal + expected_tax + expected_delivery\n\n    assert order.total_amount == expected_total.quantize(Decimal(\"0.01\"))\n\ndef test_order_status_transition_validation():\n    \"\"\"Test order status transition business rules\"\"\"\n    # Arrange\n    order = Order.create_new(\"Customer\", \"+1234567890\", \"Address\", [], \"card\")\n\n    # Act &amp; Assert - Valid transition\n    order.update_status(OrderStatus.PREPARING, \"chef_mario\")\n    assert order.status == OrderStatus.PREPARING\n\n    # Act &amp; Assert - Invalid transition\n    with pytest.raises(DomainException):\n        order.update_status(OrderStatus.DELIVERED, \"chef_mario\")  # Cannot skip to delivered\n\ndef test_domain_events_raised():\n    \"\"\"Test that domain events are raised correctly\"\"\"\n    # Arrange\n    pizzas = [Pizza(\"Margherita\", \"large\", [])]\n\n    # Act\n    order = Order.create_new(\"Customer\", \"+1234567890\", \"Address\", pizzas, \"card\")\n\n    # Assert\n    events = order.get_uncommitted_events()\n    assert len(events) == 1\n    assert isinstance(events[0], OrderPlacedEvent)\n    assert events[0].order_id == order.id\n</code></pre> <p>Integration Layer (Repositories &amp; Services):</p> <ul> <li>Unit Tests: Mock external dependencies (databases, APIs)</li> <li>Integration Tests: Test against real external systems in controlled environments</li> <li>Contract Tests: Validate external API integrations</li> </ul> <pre><code>@pytest.mark.integration\nasync def test_file_order_repository_roundtrip():\n    \"\"\"Test saving and retrieving orders from file system\"\"\"\n    # Arrange\n    repository = FileOrderRepository(\"test_data/orders\")\n    order = Order.create_new(\"Test Customer\", \"+1234567890\", \"Test Address\", [], \"cash\")\n\n    # Act\n    saved_order = await repository.save_async(order)\n    retrieved_order = await repository.get_by_id_async(saved_order.id)\n\n    # Assert\n    assert retrieved_order is not None\n    assert retrieved_order.customer_name == \"Test Customer\"\n    assert retrieved_order.id == saved_order.id\n\n@pytest.mark.integration\nasync def test_stripe_payment_service():\n    \"\"\"Test payment processing with Stripe (using test API keys)\"\"\"\n    # Arrange\n    payment_service = StripePaymentService()\n    amount = Decimal(\"29.99\")\n\n    # Act\n    result = await payment_service.process_payment_async(amount, \"pm_card_visa\")\n\n    # Assert\n    assert result.is_success\n    assert result.amount_processed == amount\n    assert result.transaction_id is not None\n</code></pre>"},{"location":"architecture/#end-to-end-testing","title":"End-to-End Testing","text":"<p>Full workflow testing across all layers:</p> <pre><code>@pytest.mark.e2e\nasync def test_complete_pizza_order_workflow():\n    \"\"\"Test complete order workflow from API to persistence\"\"\"\n    async with TestClient(create_pizzeria_app()) as client:\n        # 1. Get menu\n        menu_response = await client.get(\"/api/menu/pizzas\")\n        assert menu_response.status_code == 200\n\n        # 2. Place order\n        order_data = {\n            \"customer_name\": \"E2E Test Customer\",\n            \"customer_phone\": \"+1234567890\",\n            \"customer_address\": \"123 Test St\",\n            \"pizzas\": [{\"name\": \"Margherita\", \"size\": \"large\", \"quantity\": 1}],\n            \"payment_method\": \"card\"\n        }\n\n        order_response = await client.post(\"/api/orders/\", json=order_data)\n        assert order_response.status_code == 201\n        order = order_response.json()\n\n        # 3. Update order status (kitchen)\n        status_update = {\"status\": \"preparing\", \"notes\": \"Started preparation\"}\n        status_response = await client.put(\n            f\"/api/kitchen/orders/{order['id']}/status\",\n            json=status_update,\n            headers={\"Authorization\": \"Bearer {kitchen_token}\"}\n        )\n        assert status_response.status_code == 200\n\n        # 4. Verify order status\n        check_response = await client.get(f\"/api/orders/{order['id']}\")\n        updated_order = check_response.json()\n        assert updated_order[\"status\"] == \"preparing\"\n</code></pre>"},{"location":"architecture/#dependency-injection-configuration","title":"\ud83d\udee0\ufe0f Dependency Injection Configuration","text":""},{"location":"architecture/#service-registration-for-marios-pizzeria","title":"Service Registration for Mario's Pizzeria","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\n\ndef configure_pizzeria_services(builder: WebApplicationBuilder):\n    \"\"\"Configure all services for Mario's Pizzeria\"\"\"\n\n    # Domain services\n    builder.services.add_scoped(KitchenWorkflowService)\n    builder.services.add_scoped(PricingService)\n\n    # Application services\n    builder.services.add_mediator()\n    builder.services.add_auto_mapper()\n\n    # Infrastructure services (environment-specific)\n    environment = os.getenv(\"ENVIRONMENT\", \"development\")\n\n    if environment == \"development\":\n        # File-based repositories for development\n        builder.services.add_scoped(IOrderRepository, FileOrderRepository)\n        builder.services.add_scoped(IPizzaRepository, FilePizzaRepository)\n        builder.services.add_scoped(INotificationService, ConsoleNotificationService)\n        builder.services.add_scoped(IPaymentService, MockPaymentService)\n\n    else:  # production\n        # MongoDB repositories for production\n        builder.services.add_scoped(IOrderRepository, MongoOrderRepository)\n        builder.services.add_scoped(IPizzaRepository, MongoPizzaRepository)\n        builder.services.add_scoped(INotificationService, TwilioNotificationService)\n        builder.services.add_scoped(IPaymentService, StripePaymentService)\n\n    # Event handlers\n    builder.services.add_scoped(EventHandler[OrderPlacedEvent], KitchenNotificationHandler)\n    builder.services.add_scoped(EventHandler[OrderReadyEvent], CustomerNotificationHandler)\n    builder.services.add_scoped(EventHandler[OrderCompletedEvent], AnalyticsHandler)\n\n    # Controllers\n    builder.services.add_controllers([\n        \"api.controllers.orders_controller\",\n        \"api.controllers.menu_controller\",\n        \"api.controllers.kitchen_controller\"\n    ])\n</code></pre>"},{"location":"architecture/#benefits-of-this-architecture","title":"\ud83d\ude80 Benefits of This Architecture","text":""},{"location":"architecture/#for-marios-pizzeria-business","title":"For Mario's Pizzeria Business","text":"<ul> <li>Scalability: Can handle increasing order volume by scaling individual layers</li> <li>Maintainability: Business logic changes are isolated to domain layer</li> <li>Testability: Comprehensive testing at every layer ensures reliability</li> <li>Flexibility: Easy to change storage, payment providers, or notification methods</li> <li>Team Productivity: Clear boundaries enable parallel development</li> </ul>"},{"location":"architecture/#for-development-teams","title":"For Development Teams","text":"<ul> <li>Clear Responsibilities: Each layer has well-defined purpose and boundaries</li> <li>Technology Independence: Can swap infrastructure without changing business logic</li> <li>Parallel Development: Teams can work on different layers simultaneously</li> <li>Easy Onboarding: New developers understand system through consistent patterns</li> </ul>"},{"location":"architecture/#for-long-term-maintenance","title":"For Long-Term Maintenance","text":"<ul> <li>Evolution Support: Architecture supports changing business requirements</li> <li>Technology Updates: Infrastructure can be updated without business logic changes</li> <li>Performance Optimization: Each layer can be optimized independently</li> <li>Monitoring &amp; Debugging: Clear separation aids in troubleshooting issues</li> </ul>"},{"location":"architecture/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started Guide - Complete Mario's Pizzeria tutorial</li> <li>CQRS &amp; Mediation - Command and query patterns in depth</li> <li>Dependency Injection - Service registration and DI patterns</li> <li>MVC Controllers - API layer implementation details</li> <li>Data Access - Repository patterns and data persistence</li> </ul> <p>This architecture guide demonstrates clean architecture principles using Mario's Pizzeria as a comprehensive example. The layered approach shown here scales from simple applications to complex enterprise systems while maintaining clear separation of concerns and testability.</p>"},{"location":"architecture/#application-layer-pizza-business-workflow","title":"\ud83d\udcbc Application Layer: Pizza Business Workflow","text":"<p>Purpose: Orchestrates pizza business operations and workflows</p> <p>Responsibilities:</p> <ul> <li>Command and query handling (CQRS)</li> <li>Business workflow coordination</li> <li>Domain event processing</li> <li>Cross-cutting concerns (logging, validation, caching)</li> </ul> <p>Key Components:</p> <pre><code># src/application/commands/place_order_command.py\n@dataclass\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    \"\"\"Command to place a pizza order\"\"\"\n    customer_name: str\n    customer_phone: str\n    customer_address: str\n    pizzas: List[PizzaOrderDto]\n    payment_method: str\n\n# src/application/handlers/place_order_handler.py\nclass PlaceOrderCommandHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    \"\"\"Handles pizza order placement business workflow\"\"\"\n\n    def __init__(self,\n                 order_repository: IOrderRepository,\n                 pizza_repository: IPizzaRepository,\n                 payment_service: IPaymentService,\n                 notification_service: INotificationService,\n                 mapper: Mapper):\n        self.order_repository = order_repository\n        self.pizza_repository = pizza_repository\n        self.payment_service = payment_service\n        self.notification_service = notification_service\n        self.mapper = mapper\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        \"\"\"Execute pizza order placement workflow\"\"\"\n        try:\n            # 1. Validate pizzas are available\n            for pizza_request in command.pizzas:\n                pizza = await self.pizza_repository.get_by_name_async(pizza_request.name)\n                if not pizza or not pizza.is_available:\n                    return self.bad_request(f\"Pizza '{pizza_request.name}' is not available\")\n\n            # 2. Calculate order total using domain logic\n            order = Order.create_new(\n                customer_name=command.customer_name,\n                customer_phone=command.customer_phone,\n                customer_address=command.customer_address,\n                pizzas=command.pizzas,\n                payment_method=command.payment_method\n            )\n\n            # 3. Process payment (integration layer)\n            payment_result = await self.payment_service.process_payment_async(\n                order.total_amount, command.payment_method\n            )\n\n            if not payment_result.is_success:\n                return self.bad_request(\"Payment processing failed\")\n\n            order.mark_payment_processed(payment_result.transaction_id)\n\n            # 4. Save order (integration layer)\n            saved_order = await self.order_repository.save_async(order)\n\n            # 5. Domain event will trigger kitchen notification automatically\n            # (OrderPlacedEvent is raised by Order entity)\n\n            # 6. Send customer confirmation\n            await self.notification_service.send_order_confirmation_async(saved_order)\n\n            # 7. Return success result\n            order_dto = self.mapper.map(saved_order, OrderDto)\n            return self.created(order_dto)\n\n        except Exception as ex:\n            return self.internal_server_error(f\"Failed to place order: {str(ex)}\")\n</code></pre> <p>Architecture Benefits:</p> <ul> <li>Single Responsibility: Each handler has one clear purpose</li> <li>Testability: Easy to unit test handlers with mocked repositories</li> <li>Transaction Management: Clear transaction boundaries</li> <li>Event-Driven: Domain events enable loose coupling</li> </ul>"},{"location":"architecture/#domain-layer-pizza-business-logic","title":"\ud83c\udfdb\ufe0f Domain Layer: Pizza Business Logic","text":"<p>Purpose: Contains core pizza business rules and entities</p> <p>Responsibilities:</p> <ul> <li>Business entities with behavior</li> <li>Domain services for complex business logic</li> <li>Domain events for business-significant occurrences</li> <li>Business rule validation and invariants</li> </ul> <p>Key Components:</p> <p>Key Components:</p> <ul> <li>Controllers: Handle HTTP requests and delegate to application layer</li> <li>DTOs: Data Transfer Objects for API contracts</li> <li>Middleware: Cross-cutting concerns like authentication, logging</li> </ul> <p>Example Structure:</p> <pre><code>api/\n\u251c\u2500\u2500 controllers/\n\u2502   \u251c\u2500\u2500 users_controller.py\n\u2502   \u2514\u2500\u2500 orders_controller.py\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 user_dto.py\n\u2502   \u2514\u2500\u2500 order_dto.py\n\u2514\u2500\u2500 middleware/\n    \u251c\u2500\u2500 auth_middleware.py\n    \u2514\u2500\u2500 logging_middleware.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Keep controllers thin - delegate business logic to application layer</li> <li>Use DTOs to define API contracts</li> <li>Validate input at the API boundary</li> <li>Map between DTOs and domain models</li> </ul>"},{"location":"architecture/#application-layer-srcapplication","title":"\ud83d\udcbc Application Layer (<code>src/application/</code>)","text":"<p>Purpose: Orchestrates business workflows and coordinates domain operations</p> <p>Responsibilities:</p> <ul> <li>Command and query handling</li> <li>Business workflow orchestration</li> <li>Transaction management</li> <li>Event publishing</li> <li>Application services</li> </ul> <p>Key Components:</p> <ul> <li>Commands: Represent actions that change state</li> <li>Queries: Represent read operations</li> <li>Handlers: Process commands and queries</li> <li>Services: Application-specific business logic</li> </ul> <p>Example Structure:</p> <pre><code>application/\n\u251c\u2500\u2500 commands/\n\u2502   \u251c\u2500\u2500 create_user_command.py\n\u2502   \u2514\u2500\u2500 update_user_command.py\n\u251c\u2500\u2500 queries/\n\u2502   \u251c\u2500\u2500 get_user_query.py\n\u2502   \u2514\u2500\u2500 list_users_query.py\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 user_service.py\n\u2502   \u2514\u2500\u2500 notification_service.py\n\u2514\u2500\u2500 events/\n    \u251c\u2500\u2500 user_created_event.py\n    \u2514\u2500\u2500 user_updated_event.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Each command/query should have a single responsibility</li> <li>Use the mediator pattern to decouple handlers</li> <li>Keep application services focused on coordination</li> <li>Publish domain events for side effects</li> </ul>"},{"location":"architecture/#domain-layer-srcdomain","title":"\ud83c\udfdb\ufe0f Domain Layer (<code>src/domain/</code>)","text":"<p>Purpose: Contains the core business logic and rules</p> <p>Responsibilities:</p> <ul> <li>Business entities and aggregates</li> <li>Value objects</li> <li>Domain services</li> <li>Business rules and invariants</li> <li>Domain events</li> </ul> <p>Key Components:</p> <ul> <li>Entities: Objects with identity and lifecycle</li> <li>Value Objects: Immutable objects defined by their attributes</li> <li>Aggregates: Consistency boundaries</li> <li>Domain Services: Business logic that doesn't belong to entities</li> </ul> <p>Example Structure:</p> <pre><code>domain/\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 user.py\n\u2502   \u251c\u2500\u2500 order.py\n\u2502   \u2514\u2500\u2500 address.py\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 pricing_service.py\n\u2502   \u2514\u2500\u2500 validation_service.py\n\u2514\u2500\u2500 events/\n    \u251c\u2500\u2500 user_registered.py\n    \u2514\u2500\u2500 order_placed.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Keep domain models rich with behavior</li> <li>Enforce business invariants</li> <li>Use domain events for decoupling</li> <li>Avoid dependencies on infrastructure</li> </ul>"},{"location":"architecture/#integration-layer-srcintegration","title":"\ud83d\udd0c Integration Layer (<code>src/integration/</code>)","text":"<p>Purpose: Handles external integrations and infrastructure concerns</p> <p>Responsibilities:</p> <ul> <li>Database repositories</li> <li>External API clients</li> <li>Message queue integration</li> <li>File system operations</li> <li>Caching</li> </ul> <p>Key Components:</p> <ul> <li>Repositories: Data access implementations</li> <li>API Clients: External service integrations</li> <li>DTOs: External data contracts</li> <li>Infrastructure Services: Technical concerns</li> </ul> <p>Example Structure:</p> <pre><code>integration/\n\u251c\u2500\u2500 repositories/\n\u2502   \u251c\u2500\u2500 user_repository.py\n\u2502   \u2514\u2500\u2500 order_repository.py\n\u251c\u2500\u2500 clients/\n\u2502   \u251c\u2500\u2500 payment_client.py\n\u2502   \u2514\u2500\u2500 email_client.py\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 user_entity.py\n\u2502   \u2514\u2500\u2500 payment_dto.py\n\u2514\u2500\u2500 services/\n    \u251c\u2500\u2500 cache_service.py\n    \u2514\u2500\u2500 file_service.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Implement domain repository interfaces</li> <li>Handle external failures gracefully</li> <li>Use DTOs for external data contracts</li> <li>Isolate infrastructure concerns</li> </ul>"},{"location":"architecture/#data-flow","title":"\ud83d\udd04 Data Flow","text":""},{"location":"architecture/#command-flow-write-operations","title":"Command Flow (Write Operations)","text":"<ol> <li>Controller receives HTTP request with DTO</li> <li>Controller maps DTO to Command and sends to Mediator</li> <li>Mediator routes Command to appropriate Handler</li> <li>Handler loads domain entities via Repository</li> <li>Handler executes business logic on domain entities</li> <li>Handler saves changes via Repository</li> <li>Handler publishes domain events</li> <li>Handler returns result to Controller</li> <li>Controller maps result to DTO and returns HTTP response</li> </ol> <pre><code>HTTP Request \u2192 Controller \u2192 Command \u2192 Handler \u2192 Domain \u2192 Repository \u2192 Database\n                    \u2193           \u2193        \u2193\n               HTTP Response \u2190 DTO \u2190 Result \u2190 Events\n</code></pre>"},{"location":"architecture/#query-flow-read-operations","title":"Query Flow (Read Operations)","text":"<ol> <li>Controller receives HTTP request with parameters</li> <li>Controller creates Query and sends to Mediator</li> <li>Mediator routes Query to appropriate Handler</li> <li>Handler loads data via Repository or Read Model</li> <li>Handler returns data to Controller</li> <li>Controller maps data to DTO and returns HTTP response</li> </ol> <pre><code>HTTP Request \u2192 Controller \u2192 Query \u2192 Handler \u2192 Repository \u2192 Database\n                    \u2193         \u2193       \u2193\n               HTTP Response \u2190 DTO \u2190 Result\n</code></pre>"},{"location":"architecture/#patterns-implemented","title":"\ud83c\udfad Patterns Implemented","text":""},{"location":"architecture/#1-command-query-responsibility-segregation-cqrs","title":"1. Command Query Responsibility Segregation (CQRS)","text":"<p>Separates read and write operations to optimize performance and scalability:</p> <pre><code># Command (Write)\n@dataclass\nclass CreateUserCommand(Command[OperationResult[UserDto]]):\n    email: str\n    first_name: str\n    last_name: str\n\n# Query (Read)\n@dataclass\nclass GetUserQuery(Query[OperationResult[UserDto]]):\n    user_id: str\n</code></pre>"},{"location":"architecture/#2-mediator-pattern","title":"2. Mediator Pattern","text":"<p>Decouples components by routing requests through a central mediator:</p> <pre><code># In controller\nresult = await self.mediator.execute_async(command)\n</code></pre>"},{"location":"architecture/#3-repository-pattern","title":"3. Repository Pattern","text":"<p>Abstracts data access and provides a consistent interface:</p> <pre><code>class UserRepository(Repository[User, str]):\n    async def add_async(self, user: User) -&gt; User:\n        # Implementation details\n        pass\n</code></pre>"},{"location":"architecture/#4-event-sourcing-optional","title":"4. Event Sourcing (Optional)","text":"<p>Stores state changes as events rather than current state:</p> <pre><code>class User(AggregateRoot[str]):\n    def register(self, email: str, name: str):\n        self.apply(UserRegisteredEvent(email, name))\n</code></pre>"},{"location":"architecture/#5-dependency-injection","title":"5. Dependency Injection","text":"<p>Manages object creation and dependencies:</p> <pre><code># Automatic registration\nbuilder.services.add_scoped(UserService)\n\n# Resolution\nuser_service = provider.get_required_service(UserService)\n</code></pre>"},{"location":"architecture/#testing-architecture","title":"\ud83e\uddea Testing Architecture","text":"<p>The layered architecture makes testing straightforward:</p>"},{"location":"architecture/#unit-tests","title":"Unit Tests","text":"<p>Test individual components in isolation:</p> <pre><code>def test_user_registration():\n    # Arrange\n    command = CreateUserCommand(\"test@example.com\", \"John\", \"Doe\")\n    handler = CreateUserCommandHandler(mock_repository)\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n</code></pre>"},{"location":"architecture/#integration-tests","title":"Integration Tests","text":"<p>Test interactions between layers:</p> <pre><code>def test_create_user_endpoint():\n    # Test API \u2192 Application \u2192 Domain integration\n    response = test_client.post(\"/api/v1/users\", json=user_data)\n    assert response.status_code == 201\n</code></pre>"},{"location":"architecture/#architecture-tests","title":"Architecture Tests","text":"<p>Verify architectural constraints:</p> <pre><code>def test_domain_has_no_infrastructure_dependencies():\n    # Ensure domain layer doesn't depend on infrastructure\n    domain_modules = get_domain_modules()\n    for module in domain_modules:\n        assert not has_infrastructure_imports(module)\n</code></pre>"},{"location":"architecture/#benefits","title":"\ud83d\ude80 Benefits","text":""},{"location":"architecture/#maintainability","title":"Maintainability","text":"<ul> <li>Clear boundaries: Each layer has well-defined responsibilities</li> <li>Loose coupling: Changes in one layer don't affect others</li> <li>High cohesion: Related functionality is grouped together</li> </ul>"},{"location":"architecture/#testability","title":"Testability","text":"<ul> <li>Isolated testing: Each layer can be tested independently</li> <li>Mock dependencies: External dependencies can be easily mocked</li> <li>Fast tests: Business logic tests don't require infrastructure</li> </ul>"},{"location":"architecture/#scalability","title":"Scalability","text":"<ul> <li>CQRS: Read and write models can be optimized separately</li> <li>Event-driven: Asynchronous processing for better performance</li> <li>Microservice ready: Clear boundaries make extraction easier</li> </ul>"},{"location":"architecture/#flexibility","title":"Flexibility","text":"<ul> <li>Technology agnostic: Swap implementations without affecting business logic</li> <li>Framework independence: Business logic isn't tied to web framework</li> <li>Future-proof: Architecture adapts to changing requirements</li> </ul>"},{"location":"getting-started/","title":"\ud83d\ude80 Getting Started with Neuroglia","text":"<p>Welcome to Neuroglia - a lightweight, opinionated Python framework that enforces clean architecture principles and provides comprehensive tooling for building maintainable microservices.</p> <p>Built on FastAPI, Neuroglia emphasizes CQRS, event-driven architecture, dependency injection, and domain-driven design patterns.</p> <p>\ud83c\udfaf Choose Your Learning Path</p> <p>Pick the approach that best fits your current needs and experience level.</p>"},{"location":"getting-started/#what-is-neuroglia","title":"\ud83c\udfd7\ufe0f What is Neuroglia?","text":"<p>Neuroglia is designed around clean architecture principles with strict separation of concerns:</p>"},{"location":"getting-started/#architecture-layers","title":"Architecture Layers","text":"<pre><code>src/\n\u251c\u2500\u2500 api/           # \ud83c\udf10 API Layer (Controllers, DTOs, Routes)\n\u251c\u2500\u2500 application/   # \ud83d\udcbc Application Layer (Commands, Queries, Handlers, Services)\n\u251c\u2500\u2500 domain/        # \ud83c\udfdb\ufe0f Domain Layer (Entities, Value Objects, Business Rules)\n\u2514\u2500\u2500 integration/   # \ud83d\udd0c Integration Layer (External APIs, Repositories, Infrastructure)\n</code></pre>"},{"location":"getting-started/#the-dependency-rule","title":"The Dependency Rule","text":"<p>Dependencies only point inward: API \u2192 Application \u2192 Domain \u2190 Integration</p> <pre><code>flowchart TD\n    API[\"\ud83c\udf10 API Layer&lt;br/&gt;Controllers, DTOs, Routes&lt;br/&gt;&lt;i&gt;Handles HTTP requests&lt;/i&gt;\"]\n    APP[\"\ud83d\udcbc Application Layer&lt;br/&gt;Commands, Queries, Handlers&lt;br/&gt;&lt;i&gt;Orchestrates business logic&lt;/i&gt;\"]\n    DOM[\"\ud83c\udfdb\ufe0f Domain Layer&lt;br/&gt;Entities, Value Objects, Business Rules&lt;br/&gt;&lt;i&gt;Pure business logic&lt;/i&gt;\"]\n    INT[\"\ud83d\udd0c Integration Layer&lt;br/&gt;Repositories, External APIs&lt;br/&gt;&lt;i&gt;Infrastructure concerns&lt;/i&gt;\"]\n\n    API --&gt;|\"depends on\"| APP\n    APP --&gt;|\"depends on\"| DOM\n    INT --&gt;|\"depends on\"| DOM\n\n    style DOM fill:#e1f5fe,stroke:#0277bd,stroke-width:3px\n    style APP fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\n    style API fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px\n    style INT fill:#fff3e0,stroke:#f57c00,stroke-width:2px\n\n    classDef dependencyArrow stroke:#1565c0,stroke-width:3px,color:#1565c0</code></pre> <p>\ud83c\udfaf Key Principle</p> <p>The Domain Layer is at the center and has no dependencies on outer layers. This ensures business logic remains pure and testable, while outer layers can be easily swapped without affecting core functionality.</p>"},{"location":"getting-started/#core-framework-principles","title":"Core Framework Principles","text":"<ul> <li>\ud83c\udfaf CQRS Pattern - Separate commands (write) from queries (read) for clarity and scalability</li> <li>\ud83c\udfdb\ufe0f Domain-Driven Design - Business logic lives in the domain layer, isolated from infrastructure concerns</li> <li>\ud83d\udc89 Dependency Injection - Constructor-based DI with service lifetime management (Singleton, Scoped, Transient)</li> <li>\ud83d\udce1 Event-Driven Architecture - Domain events enable loose coupling and eventual consistency</li> <li>\ud83e\uddea Test-First Development - Framework designed for comprehensive unit and integration testing</li> </ul>"},{"location":"getting-started/#quick-start-options","title":"\ud83d\ude80 Quick Start Options","text":""},{"location":"getting-started/#3-minute-bootstrap","title":"\u26a1 3-Minute Bootstrap","text":"<p>Perfect for: First-time framework validation, quick demos, proof of concepts</p> <p>Get a \"Hello World\" API running in under 3 minutes to validate your environment and see Neuroglia in action.</p> <p>\ud83d\udc49 Start 3-Minute Bootstrap</p> <p>What you'll get: Simple controller, FastAPI integration, basic project structure</p>"},{"location":"getting-started/#local-development-setup","title":"\ud83d\udee0\ufe0f Local Development Setup","text":"<p>Perfect for: Setting up a complete development environment, team onboarding, production-ready tooling</p> <p>Configure a professional development environment with debugging, testing, linting, and database integration.</p> <p>\ud83d\udc49 Set Up Development Environment</p> <p>What you'll get: IDE configuration, Docker services, testing frameworks, debugging setup</p>"},{"location":"getting-started/#complete-tutorial-marios-pizzeria","title":"\ud83c\udf55 Complete Tutorial: Mario's Pizzeria","text":"<p>Perfect for: Learning all framework features, building production applications, comprehensive examples</p> <p>Build a complete pizza ordering system that demonstrates clean architecture, CQRS, event-driven design, authentication, and web development.</p> <p>\ud83d\udc49 Build Mario's Pizzeria</p> <p>What you'll get: Full-stack application with REST API, web UI, authentication, persistence, events</p>"},{"location":"getting-started/#framework-features-overview","title":"\ud83d\udd0d Framework Features Overview","text":"Feature Purpose When to Use Dependency Injection Service container and lifetime management All applications - foundation for testability CQRS &amp; Mediation Command/Query separation with pipeline behaviors Complex business logic, cross-cutting concerns MVC Controllers REST API development with FastAPI integration Web APIs, microservices, external interfaces Data Access Repository pattern with MongoDB, file storage Persistence, data abstraction, testing Event Sourcing Event-driven architecture with domain events Complex domains, audit trails, eventual consistency"},{"location":"getting-started/#documentation-structure","title":"\ud83d\udcda Documentation Structure","text":"<p>Deep dive into clean architecture principles, layer responsibilities, and design patterns used throughout Neuroglia.</p>"},{"location":"getting-started/#feature-documentation","title":"\ud83d\ude80 Feature Documentation","text":"<p>Comprehensive guides for each framework feature with practical examples and best practices.</p>"},{"location":"getting-started/#sample-applications","title":"\ud83d\udccb Sample Applications","text":"<p>Complete, working applications that demonstrate real-world usage patterns:</p> <ul> <li>OpenBank - Banking domain with event sourcing</li> <li>API Gateway - Microservice gateway patterns</li> <li>Desktop Controller - Background services and system integration</li> </ul>"},{"location":"getting-started/#implementation-guides","title":"\ud83d\udee0\ufe0f Implementation Guides","text":"<p>Step-by-step tutorials for common development scenarios and project setup.</p>"},{"location":"getting-started/#framework-philosophy","title":"\ud83e\udd1d Framework Philosophy","text":"<p>Neuroglia is opinionated by design to promote:</p> <ol> <li>Consistency - Unified patterns across all applications</li> <li>Maintainability - Clear separation of concerns and dependencies</li> <li>Testability - Framework designed for comprehensive testing</li> <li>Productivity - Reduce boilerplate while maintaining flexibility</li> <li>Quality - Built-in patterns for error handling, logging, and monitoring</li> </ol>"},{"location":"getting-started/#ready-to-start","title":"\ud83d\ude80 Ready to Start?","text":"<p>Choose your path:</p> <ul> <li>New to the framework? \u2192 \u26a1 3-Minute Bootstrap</li> <li>Setting up your environment? \u2192 \ud83d\udee0\ufe0f Development Setup</li> <li>Want to build something real? \u2192 \ud83c\udf55 Mario's Pizzeria Tutorial</li> <li>Need architectural context? \u2192 \ud83c\udfdb\ufe0f Architecture Guide</li> </ul> <p>\ud83d\udca1 Framework Consistency</p> <p>All documentation examples use the Mario's Pizzeria domain for consistency - once you complete the tutorial, you'll feel at home with any advanced feature documentation.</p>"},{"location":"index_corrupted/","title":"\ud83e\udde0 Neuroglia Python Framework","text":"<p>A lightweight, opinionated Python framework built on FastAPI that enforces clean architecture principles and provides comprehensive tooling for building production-ready microservices.</p>"},{"location":"index_corrupted/#whats-included","title":"\ud83d\ude80 What's Included","text":""},{"location":"index_corrupted/#framework-core","title":"\ud83c\udfd7\ufe0f Framework Core","text":"<p>Clean architecture patterns with dependency injection, CQRS, event-driven design, and comprehensive testing utilities.</p>"},{"location":"index_corrupted/#real-world-samples","title":"\ufffd Real-World Samples","text":"<p>Complete Mario's Pizzeria application demonstrating every framework feature in a production-ready business scenario.</p>"},{"location":"index_corrupted/#cli-tooling","title":"\u2699\ufe0f CLI Tooling","text":"<p>PyNeuroctl command-line interface for managing, testing, and deploying your applications with zero configuration.</p>"},{"location":"index_corrupted/#key-features","title":"\u2728 Key Features","text":"<ul> <li>\ufffd CQRS &amp; Mediation: Built-in Command Query Responsibility Segregation with mediator pattern</li> <li>\ud83d\udc89 Dependency Injection: Lightweight container with automatic service discovery</li> <li>\ud83d\udd0c MVC Controllers: Class-based controllers with automatic OpenAPI generation</li> <li>\ud83d\udce1 Event-Driven: Native CloudEvents support and domain event handling</li> <li>\ud83d\uddc4\ufe0f Data Access: Repository pattern with file-based, MongoDB, and event sourcing support</li> <li>\ud83e\uddea Testing Utilities: Comprehensive testing patterns for all architectural layers</li> </ul>"},{"location":"index_corrupted/#quick-start-your-first-pizzeria-app","title":"\ud83d\ude80 Quick Start: Your First Pizzeria App","text":"<p>Get Mario's Pizzeria running in minutes:</p> <pre><code># Install Neuroglia\npip install neuroglia\n\n# Create a simple pizzeria API\n</code></pre> <pre><code># main.py\nfrom dataclasses import dataclass\nfrom typing import List\nfrom neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.mvc import ControllerBase\nfrom classy_fastapi import get, post\n\n@dataclass\nclass PizzaDto:\n    name: str\n    size: str\n    price: float\n\n@dataclass\nclass OrderDto:\n    id: str\n    customer_name: str\n    pizzas: List[PizzaDto]\n    total: float\n    status: str\n\nclass MenuController(ControllerBase):\n    \"\"\"Mario's menu management\"\"\"\n\n    @get(\"/menu/pizzas\", response_model=List[PizzaDto])\n    async def get_pizzas(self) -&gt; List[PizzaDto]:\n        return [\n            PizzaDto(\"Margherita\", \"large\", 15.99),\n            PizzaDto(\"Pepperoni\", \"large\", 17.99),\n            PizzaDto(\"Quattro Stagioni\", \"large\", 19.99)\n        ]\n\nclass OrdersController(ControllerBase):\n    \"\"\"Mario's order management\"\"\"\n\n    @post(\"/orders\", response_model=OrderDto)\n    async def place_order(self, customer_name: str, pizza_names: List[str]) -&gt; OrderDto:\n        # Simple order creation\n        pizzas = [PizzaDto(name, \"large\", 15.99) for name in pizza_names]\n        total = sum(p.price for p in pizzas)\n\n        return OrderDto(\n            id=\"order_123\",\n            customer_name=customer_name,\n            pizzas=pizzas,\n            total=total,\n            status=\"received\"\n        )\n\ndef create_pizzeria_app():\n    \"\"\"Create Mario's Pizzeria application\"\"\"\n    builder = WebApplicationBuilder()\n\n    # Add controllers\n    builder.services.add_controllers([\"__main__\"])\n\n    app = builder.build()\n    app.use_controllers()\n\n    return app\n\nif __name__ == \"__main__\":\n    app = create_pizzeria_app()\n    app.run()\n</code></pre> <pre><code># Run the pizzeria\npython main.py\n\n# Test the API\ncurl http://localhost:8000/menu/pizzas\ncurl -X POST \"http://localhost:8000/orders?customer_name=Mario\" \\\n     -H \"Content-Type: application/json\" \\\n     -d '[\"Margherita\", \"Pepperoni\"]'\n</code></pre> <p>\ud83d\udc49 Complete Tutorial: Build the Full Pizzeria System</p>"},{"location":"index_corrupted/#architecture-overview","title":"\ufffd\ufe0f Architecture Overview","text":"<p>Mario's Pizzeria demonstrates clean, layered architecture:</p> <pre><code>    \ud83c\udf10 API Layer (Controllers &amp; DTOs)\n         OrdersController, MenuController, KitchenController\n         \u2193 Commands &amp; Queries\n    \ud83d\udcbc Application Layer (CQRS Handlers)\n         PlaceOrderHandler, GetMenuHandler, UpdateOrderStatusHandler\n         \u2193 Domain Operations\n    \ud83c\udfdb\ufe0f Domain Layer (Business Logic)\n         Order, Pizza, Customer entities with business rules\n         \u2191 Repository Interfaces\n    \ud83d\udd0c Integration Layer (Data &amp; External Services)\n         FileOrderRepository, MongoOrderRepository, PaymentService\n</code></pre> <p>Each layer has specific responsibilities:</p> <ul> <li>\ud83c\udf10 API Layer: HTTP endpoints, request/response handling, authentication</li> <li>\ud83d\udcbc Application Layer: Business workflows, command/query processing, event coordination</li> <li>\ud83c\udfdb\ufe0f Domain Layer: Core business rules, entity logic, domain events</li> <li>\ud83d\udd0c Integration Layer: Data persistence, external APIs, infrastructure services</li> </ul> <p>\ud83d\udcd6 Deep Dive: Clean Architecture with Mario's Pizzeria</p>"},{"location":"index_corrupted/#core-features","title":"\ud83c\udfaa Core Features","text":""},{"location":"index_corrupted/#dependency-injection","title":"\ud83d\udc89 Dependency Injection","text":"<p>Powerful service container demonstrated through Mario's Pizzeria:</p> <pre><code># Service registration for pizzeria\nbuilder.services.add_scoped(IOrderRepository, FileOrderRepository)\nbuilder.services.add_scoped(IPaymentService, MockPaymentService)\nbuilder.services.add_mediator()\nbuilder.services.add_controllers([\"api.controllers\"])\n\n# Constructor injection in controllers\nclass OrdersController(ControllerBase):\n    def __init__(self, service_provider: ServiceProviderBase,\n                 mapper: Mapper, mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n    @post(\"/orders\", response_model=OrderDto)\n    async def place_order(self, request: PlaceOrderDto) -&gt; OrderDto:\n        command = self.mapper.map(request, PlaceOrderCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre> <p>\ud83d\udcd6 Dependency Injection with Mario's Pizzeria</p>"},{"location":"index_corrupted/#cqrs-mediation","title":"\ud83c\udfaf CQRS &amp; Mediation","text":"<p>Clean command/query separation demonstrated through pizza ordering:</p> <pre><code># Command for placing orders\n@dataclass\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    customer_name: str\n    customer_phone: str\n    customer_address: str\n    pizzas: List[PizzaOrderDto]\n    payment_method: str\n\n# Handler with business logic\nclass PlaceOrderCommandHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    def __init__(self, order_repository: IOrderRepository,\n                 payment_service: IPaymentService,\n                 mapper: Mapper):\n        self.order_repository = order_repository\n        self.payment_service = payment_service\n        self.mapper = mapper\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        # 1. Create domain entity with business logic\n        pizzas = [Pizza(p.name, p.size, p.extras) for p in command.pizzas]\n        order = Order.create_new(\n            command.customer_name,\n            command.customer_phone,\n            command.customer_address,\n            pizzas,\n            command.payment_method\n        )\n\n        # 2. Process payment\n        payment_result = await self.payment_service.process_payment_async(\n            order.total_amount, command.payment_method\n        )\n        if not payment_result.is_success:\n            return self.bad_request(\"Payment processing failed\")\n\n        # 3. Save order and return result\n        saved_order = await self.order_repository.save_async(order)\n        order_dto = self.mapper.map(saved_order, OrderDto)\n        return self.created(order_dto)\n\n# Query for retrieving menu\n@dataclass\nclass GetMenuQuery(Query[List[PizzaDto]]):\n    category: Optional[str] = None\n\nclass GetMenuQueryHandler(QueryHandler[GetMenuQuery, List[PizzaDto]]):\n    async def handle_async(self, query: GetMenuQuery) -&gt; List[PizzaDto]:\n        # Query logic here\n        pizzas = await self.pizza_repository.get_all_async()\n        if query.category:\n            pizzas = [p for p in pizzas if p.category == query.category]\n        return [self.mapper.map(p, PizzaDto) for p in pizzas]\n\n# Usage in controller\n@post(\"/orders\", response_model=OrderDto)\nasync def place_order(self, request: PlaceOrderDto) -&gt; OrderDto:\n    command = self.mapper.map(request, PlaceOrderCommand)\n    result = await self.mediator.execute_async(command)\n    return self.process(result)\n</code></pre> <p>\ud83d\udcd6 CQRS &amp; Mediation with Mario's Pizzeria</p>"},{"location":"index_corrupted/#mvc-controllers","title":"\ud83d\udd0c MVC Controllers","text":"<p>Class-based controllers with automatic discovery demonstrated through pizzeria APIs:</p> <pre><code>class OrdersController(ControllerBase):\n    \"\"\"Mario's order management endpoint\"\"\"\n\n    @post(\"/orders\", response_model=OrderDto, status_code=201)\n    async def place_order(self, request: PlaceOrderDto) -&gt; OrderDto:\n        \"\"\"Place a new pizza order\"\"\"\n        command = self.mapper.map(request, PlaceOrderCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @get(\"/orders/{order_id}\", response_model=OrderDto)\n    async def get_order(self, order_id: str) -&gt; OrderDto:\n        \"\"\"Get order details by ID\"\"\"\n        query = GetOrderByIdQuery(order_id=order_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\nclass MenuController(ControllerBase):\n    \"\"\"Mario's menu management\"\"\"\n\n    @get(\"/menu/pizzas\", response_model=List[PizzaDto])\n    async def get_pizzas(self, category: Optional[str] = None) -&gt; List[PizzaDto]:\n        \"\"\"Get available pizzas, optionally filtered by category\"\"\"\n        query = GetMenuQuery(category=category)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n# Automatic OpenAPI documentation generation\n# Built-in validation, error handling, and response formatting\n</code></pre> <p>\ud83d\udcd6 MVC Controllers with Mario's Pizzeria</p>"},{"location":"index_corrupted/#event-driven-architecture","title":"\ud83d\udce1 Event-Driven Architecture","text":"<p>Native support for domain events and reactive programming demonstrated through pizzeria operations:</p> <pre><code># Domain events in Mario's Pizzeria\n@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    order_id: str\n    customer_name: str\n    total_amount: Decimal\n    pizzas: List[str]\n\n@dataclass\nclass OrderReadyEvent(DomainEvent):\n    order_id: str\n    customer_phone: str\n    pickup_time: datetime\n\n# Event handlers for pizzeria workflow\nclass KitchenNotificationHandler(EventHandler[OrderPlacedEvent]):\n    \"\"\"Notify kitchen when order is placed\"\"\"\n    async def handle_async(self, event: OrderPlacedEvent):\n        await self.kitchen_service.add_to_queue(event.order_id, event.pizzas)\n\nclass CustomerNotificationHandler(EventHandler[OrderReadyEvent]):\n    \"\"\"Notify customer when order is ready\"\"\"\n    async def handle_async(self, event: OrderReadyEvent):\n        message = f\"Your order {event.order_id} is ready for pickup!\"\n        await self.sms_service.send_message(event.customer_phone, message)\n\n# Events are automatically published when domain entities change\nclass Order(Entity):\n    def update_status(self, new_status: OrderStatus, updated_by: str):\n        self.status = new_status\n        self.last_updated = datetime.now(timezone.utc)\n        self.updated_by = updated_by\n\n        # Raise domain event\n        if new_status == OrderStatus.READY:\n            self.raise_event(OrderReadyEvent(\n                order_id=self.id,\n                customer_phone=self.customer_phone,\n                pickup_time=datetime.utcnow()\n            ))\n</code></pre> <p>\ud83d\udcd6 Event-Driven Architecture with Mario's Pizzeria</p>"},{"location":"index_corrupted/#data-access","title":"\ud83d\uddc4\ufe0f Data Access","text":"<p>Flexible repository pattern with multiple storage backends demonstrated through Mario's Pizzeria:</p> <pre><code># Repository interface for orders\nclass IOrderRepository(Repository[Order, str]):\n    async def get_by_customer_phone_async(self, phone: str) -&gt; List[Order]:\n        pass\n\n    async def get_orders_by_status_async(self, status: OrderStatus) -&gt; List[Order]:\n        pass\n\n# File-based implementation (development)\nclass FileOrderRepository(IOrderRepository):\n    def __init__(self, data_directory: str):\n        self.data_directory = Path(data_directory)\n        self.data_directory.mkdir(exist_ok=True)\n\n    async def save_async(self, order: Order) -&gt; Order:\n        order_data = {\n            \"id\": order.id,\n            \"customer_name\": order.customer_name,\n            \"status\": order.status.value,\n            \"total_amount\": float(order.total_amount),\n            \"created_at\": order.created_at.isoformat()\n        }\n\n        file_path = self.data_directory / f\"{order.id}.json\"\n        with open(file_path, 'w') as f:\n            json.dump(order_data, f, indent=2)\n\n        return order\n\n# MongoDB implementation (production)\nclass MongoOrderRepository(IOrderRepository):\n    def __init__(self, collection: Collection):\n        self.collection = collection\n\n    async def save_async(self, order: Order) -&gt; Order:\n        document = self._order_to_document(order)\n        await self.collection.insert_one(document)\n        return order\n\n    async def get_orders_by_status_async(self, status: OrderStatus) -&gt; List[Order]:\n        cursor = self.collection.find({\"status\": status.value})\n        documents = await cursor.to_list(length=None)\n        return [self._document_to_order(doc) for doc in documents]\n\n# Event sourcing for complex workflows\nclass EventSourcedOrderRepository(IOrderRepository):\n    \"\"\"Track complete order lifecycle through events\"\"\"\n    async def save_async(self, order: Order) -&gt; Order:\n        # Persist domain events instead of just final state\n        events = order.get_uncommitted_events()\n        for event in events:\n            await self.event_store.append_async(order.id, event)\n        return order\n</code></pre> <p>\ud83d\udcd6 Data Access with Mario's Pizzeria</p>"},{"location":"index_corrupted/#object-mapping","title":"\ud83d\udcca Object Mapping","text":"<p>Bidirectional mapping between domain entities and DTOs:</p> <pre><code># Automatic mapping configuration\nbuilder.services.add_auto_mapper()\n\n# Domain entity\nclass Order(Entity):\n    customer_name: str\n    pizzas: List[Pizza]\n    total_amount: Decimal\n    status: OrderStatus\n\n# DTO for API\n@dataclass\nclass OrderDto:\n    id: str\n    customer_name: str\n    pizzas: List[PizzaDto]\n    total_amount: float\n    status: str\n    created_at: str\n\n# Usage in handlers\nclass PlaceOrderCommandHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        # Create domain entity\n        order = Order.create_new(command.customer_name, ...)\n\n        # Save entity\n        saved_order = await self.order_repository.save_async(order)\n\n        # Map to DTO for response\n        order_dto = self.mapper.map(saved_order, OrderDto)\n        return self.created(order_dto)\n</code></pre>"},{"location":"index_corrupted/#learn-through-marios-pizzeria","title":"\ud83c\udf93 Learn Through Mario's Pizzeria","text":"<p>All documentation uses Mario's Pizzeria as a consistent, comprehensive example:</p>"},{"location":"index_corrupted/#complete-business-domain","title":"\ud83c\udf55 Complete Business Domain","text":"<ul> <li>\ud83d\udc65 Customer Management: Registration, authentication, order history</li> <li>\ud83d\udccb Order Processing: Place orders, payment processing, status tracking</li> <li>\ud83c\udf55 Menu Management: Pizzas, ingredients, pricing, categories</li> <li>\ud83d\udc68\u200d\ud83c\udf73 Kitchen Operations: Order queue, preparation workflow, notifications</li> <li>\ud83d\udcca Business Analytics: Sales reports, popular items, customer insights</li> <li>\ud83d\udd10 Staff Authentication: Role-based access for different staff functions</li> </ul>"},{"location":"index_corrupted/#architecture-demonstrated","title":"\ud83c\udfd7\ufe0f Architecture Demonstrated","text":"<p>Each major framework feature is shown through realistic pizzeria scenarios:</p> <ul> <li>\ud83c\udf10 API Layer: RESTful endpoints for customers and staff</li> <li>\ufffd Application Layer: Business workflows like order processing</li> <li>\ud83c\udfdb\ufe0f Domain Layer: Rich business entities with validation and events</li> <li>\ud83d\udd0c Integration Layer: File storage, MongoDB, payment services, SMS notifications</li> </ul>"},{"location":"index_corrupted/#progressive-learning-path","title":"\ud83c\udfaf Progressive Learning Path","text":"<ol> <li>\ud83d\ude80 Getting Started - Build your first pizzeria app step-by-step</li> <li>\ud83c\udfd7\ufe0f Architecture - Understand clean architecture through pizzeria layers</li> <li>\ufffd Dependency Injection - Configure pizzeria services and repositories</li> <li>\ud83c\udfaf CQRS &amp; Mediation - Implement order processing workflows</li> <li>\ufffd MVC Controllers - Build pizzeria API endpoints</li> <li>\ud83d\uddc4\ufe0f Data Access - Persist orders with file and database storage</li> </ol>"},{"location":"index_corrupted/#documentation","title":"\ud83d\udcda Documentation","text":""},{"location":"index_corrupted/#getting-started","title":"\ud83d\ude80 Getting Started","text":"<ul> <li>Quick Start Guide - Build Mario's Pizzeria in 7 steps</li> <li>Architecture Overview - Clean architecture through pizzeria example</li> <li>Project Structure - Organize pizzeria code properly</li> </ul>"},{"location":"index_corrupted/#feature-guides","title":"\ud83c\udfaa Feature Guides","text":"Feature Mario's Pizzeria Example Documentation \ud83c\udfd7\ufe0f Architecture Complete pizzeria system layers \ud83d\udcd6 Guide \ud83d\udc89 Dependency Injection Service registration for pizzeria \ud83d\udcd6 Guide \ud83c\udfaf CQRS &amp; Mediation Order processing commands &amp; queries \ud83d\udcd6 Guide \ud83d\udd0c MVC Controllers Pizzeria API endpoints \ud83d\udcd6 Guide \ud83d\uddc4\ufe0f Data Access Order &amp; menu repositories \ud83d\udcd6 Guide"},{"location":"index_corrupted/#installation-requirements","title":"\ud83d\udee0\ufe0f Installation &amp; Requirements","text":""},{"location":"index_corrupted/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8+ (Python 3.11+ recommended)</li> <li>pip or poetry for dependency management</li> </ul>"},{"location":"index_corrupted/#installation","title":"Installation","text":"<pre><code># Install from PyPI (coming soon)\npip install neuroglia\n\n# Or install from source for development\ngit clone https://github.com/neuroglia-io/python.git\ncd python\npip install -e .\n</code></pre>"},{"location":"index_corrupted/#optional-dependencies","title":"Optional Dependencies","text":"<pre><code># MongoDB support\npip install neuroglia[mongo]\n\n# Event sourcing with EventStoreDB\npip install neuroglia[eventstore]\n\n# All features\npip install neuroglia[all]\n</code></pre>"},{"location":"index_corrupted/#community-support","title":"\ud83e\udd1d Community &amp; Support","text":""},{"location":"index_corrupted/#getting-help","title":"Getting Help","text":"<ul> <li>\ud83d\udcd6 Documentation: Comprehensive guides with Mario's Pizzeria examples</li> <li>\ud83d\udcac GitHub Discussions: Ask questions and share ideas</li> <li>\ud83d\udc1b Issues: Report bugs and request features</li> <li>\ud83d\udce7 Email: Contact maintainers directly</li> </ul>"},{"location":"index_corrupted/#contributing","title":"Contributing","text":"<p>We welcome contributions from the community:</p> <ul> <li>\ud83d\udcdd Documentation - Help improve pizzeria examples and guides</li> <li>\ud83d\udc1b Bug Reports - Help us identify and fix issues</li> <li>\u2728 Features - Propose new framework capabilities</li> <li>\ud83e\uddea Tests - Improve test coverage and quality</li> <li>\ud83d\udd27 Code - Submit PRs with improvements and fixes</li> </ul>"},{"location":"index_corrupted/#roadmap","title":"Roadmap","text":"<p>Upcoming features and improvements:</p> <ul> <li>Enhanced Resource Oriented Architecture - Extended watcher and controller patterns</li> <li>Advanced Event Sourcing - More sophisticated event store integrations</li> <li>Performance Optimizations - Faster startup and runtime performance</li> <li>Additional Storage Backends - PostgreSQL, Redis, and more</li> <li>Extended Authentication - Additional OAuth providers and JWT enhancements</li> <li>Monitoring &amp; Observability - Built-in metrics and distributed tracing</li> </ul>"},{"location":"index_corrupted/#license","title":"\ufffd License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"index_corrupted/#why-choose-neuroglia","title":"\ud83c\udf1f Why Choose Neuroglia?","text":"<p>\u2705 Production Ready: Battle-tested patterns used in real-world applications \u2705 Developer Friendly: Intuitive APIs with consistent Mario's Pizzeria examples \u2705 Highly Testable: Comprehensive testing utilities and patterns built-in \u2705 Scalable Architecture: Clean architecture principles that grow with your needs \u2705 Modern Framework: Leverages latest Python 3.11+ and FastAPI features \u2705 Flexible Design: Use individual components or the complete framework \u2705 Excellent Documentation: Every feature explained through practical examples \u2705 Active Development: Continuously improved with community feedback</p> <p>Ready to build Mario's Pizzeria? Get Started Now \ud83c\udf55 | Data Access | Repository pattern and persistence | \ud83d\udcd6 Guide | | Event Handling | Events, messaging, and reactive programming | \ud83d\udcd6 Guide | | Object Mapping | Automatic object-to-object mapping | \ud83d\udcd6 Guide | | Configuration | Settings and environment management | \ud83d\udcd6 Guide | | Hosting | Web application hosting and lifecycle | \ud83d\udcd6 Guide |</p>"},{"location":"index_corrupted/#requirements","title":"\ud83d\udccb Requirements","text":"<ul> <li>Python 3.11+</li> <li>FastAPI (automatic)</li> <li>Pydantic (automatic)</li> <li>Optional: MongoDB, EventStoreDB, Redis (based on features used)</li> </ul>"},{"location":"index_corrupted/#contributing_1","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions! Here's how you can help:</p> <ul> <li>\ud83d\udc1b Report bugs - Found an issue? Let us know!</li> <li>\ud83d\udca1 Suggest features - Have an idea? We'd love to hear it!</li> <li>\ud83d\udcdd Improve docs - Help make our documentation better</li> <li>\ud83d\udd27 Submit PRs - Code contributions are always welcome</li> </ul> <p>\ud83d\udc49 Contributing Guide</p>"},{"location":"index_corrupted/#license_1","title":"\ud83d\udcc4 License","text":""},{"location":"index_corrupted/#running-background-tasks","title":"Running Background Tasks","text":"<p>Neuroglia integrates with apscheduler for background tasks:</p> <pre><code>from apscheduler.schedulers.asyncio import AsyncIOScheduler\nfrom neuroglia.hosting.abstractions import HostedService\n\nclass BackgroundTaskService(HostedService):\n    def __init__(self):\n        self._scheduler = AsyncIOScheduler()\n\n    async def start_async(self):\n        # Add jobs\n        self._scheduler.add_job(self._process_data, 'interval', minutes=5)\n        self._scheduler.start()\n\n    async def stop_async(self):\n        self._scheduler.shutdown()\n\n    async def _process_data(self):\n        # Task implementation\n        pass\n</code></pre>"},{"location":"index_corrupted/#advanced-features","title":"Advanced Features","text":""},{"location":"index_corrupted/#real-time-communication-with-cloudevents","title":"Real-time Communication with CloudEvents","text":"<pre><code>from neuroglia.eventing.cloud_events.infrastructure import CloudEventIngestor\nfrom neuroglia.eventing.cloud_events.decorators import cloud_event_handler\n\nclass NotificationService:\n    def __init__(self, event_ingestor: CloudEventIngestor):\n        event_ingestor.subscribe(\"user.created\", self._on_user_created)\n\n    @cloud_event_handler\n    async def _on_user_created(self, event_data):\n        # Process user created event\n        user_id = event_data[\"id\"]\n        # Send notification\n</code></pre>"},{"location":"index_corrupted/#custom-repository-implementation","title":"Custom Repository Implementation","text":"<pre><code>from neuroglia.data.infrastructure.abstractions import Repository\n\nclass CustomRepository(Repository[Entity, str]):\n    async def add(self, entity: Entity) -&gt; None:\n        # Custom implementation\n\n    async def update(self, entity: Entity) -&gt; None:\n        # Custom implementation\n\n    async def remove(self, entity: Entity) -&gt; None:\n        # Custom implementation\n\n    async def find_by_id(self, id: str) -&gt; Optional[Entity]:\n        # Custom implementation\n</code></pre>"},{"location":"index_corrupted/#samples","title":"Samples","text":""},{"location":"index_corrupted/#openbank","title":"OpenBank","text":"<p>Implements a simplified Bank that manages Accounts, Users and Transactions with full Event Sourcing, CQRS</p> <p>Explore OpenBank</p>"},{"location":"index_corrupted/#desktop-controller","title":"Desktop Controller","text":"<p>Remotely and securely control custom files or commands on a Desktop running the app as a Docker container...</p> <p>Explore Desktop Controller</p>"},{"location":"index_corrupted/#api-gateway","title":"API Gateway","text":"<p>Expose single entry point for 3rd party clients into an internal layer, like a GenAI stack... Models a Prompt entity, enforces a business logic (e.g. Prompt' state-machine), handles scheduled background task (with persistence), exposes API with multiple Security schemes, ...</p> <p>Explore API Gateway</p>"},{"location":"index_corrupted/#cisco-remote-output-collector","title":"Cisco Remote Output Collector","text":"<p>Statefull microservice that handles complex and custom HTTP Commands which in turn each encapsulates arbitrary interactions with given Cisco Device(s) via Telnet, such as <code>FindPrompt</code>, <code>CollectCommandLineOutput</code>, <code>AddConfiguration</code>, <code>SaveConfiguration</code>, <code>Ping</code>, <code>Traceroute</code>, <code>ClearNatTranslation</code>, <code>CheckReachability</code>, <code>BounceInterface</code>, <code>RunViaTelnetTo</code>, <code>FindSpanningTreeRoot</code>, ... etc.</p> <p>Explore IOS ROC</p> <p>Current state: functional but simple implemention, 100% stateless collection of multiple CLI to a single device via Telnet.</p> <p>TODO:</p> <ul> <li>[ ] Add Session management (defines a Pod for subsequent scenarios) with persistence</li> <li>[ ] Add DeviceConnection and ConnectionManager</li> <li>[ ] Add DeviceDrivers and PromptPatterns libraries</li> <li>[ ] ...</li> </ul>"},{"location":"index_corrupted/#deployment","title":"Deployment","text":""},{"location":"index_corrupted/#docker-deployment","title":"Docker Deployment","text":"<p>The framework is designed to work seamlessly with Docker. A typical Dockerfile might look like:</p> <pre><code>FROM python:3.10-slim\n\nWORKDIR /app\n\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\nCOPY . .\n\nEXPOSE 8000\n\nCMD [\"uvicorn\", \"api.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n</code></pre>"},{"location":"index_corrupted/#environment-configuration","title":"Environment Configuration","text":"<p>Following the 12-Factor App principles, configuration is stored in environment variables:</p> <pre><code>from neuroglia.hosting.abstractions import ApplicationSettings\nfrom pydantic import BaseSettings\n\nclass MyAppSettings(ApplicationSettings):\n    database_url: str\n    api_key: str\n    debug_mode: bool = False\n</code></pre>"},{"location":"index_corrupted/#testing","title":"Testing","text":"<p>The framework supports comprehensive testing with pytest:</p> <pre><code># Example test for a command handler\nasync def test_create_user_command():\n    # Arrange\n    handler = CreateUserCommandHandler(mock_repository)\n    command = CreateUserCommand(\"test\", \"test@example.com\")\n\n    # Act\n    result = await handler.handle(command)\n\n    # Assert\n    assert result is not None\n    assert mock_repository.add.called_once\n</code></pre>"},{"location":"index_corrupted/#best-practices","title":"Best Practices","text":"<ol> <li>Keep Domain Models Pure: Domain models should be free of infrastructure concerns</li> <li>Use Commands for State Changes: All state-changing operations should be modeled as commands</li> <li>Use Queries for Reading Data: All data retrieval should be modeled as queries</li> <li>Leverage Dependency Injection: Always use DI to create loosely coupled components</li> <li>Handle Errors with Problem Details: Use the standard ProblemDetails format for error responses</li> <li>Follow Layered Architecture: Maintain clear boundaries between API, Application, Domain, and Integration layers</li> </ol>"},{"location":"index_corrupted/#conclusion","title":"Conclusion","text":"<p>The Neuroglia Python Framework provides a comprehensive foundation for building clean, maintainable, and feature-rich microservices. By embracing modern architectural patterns like CQRS, Event Sourcing, and Clean Architecture, it helps developers create applications that are easier to understand, test, and evolve over time.</p> <p>For more information, check out the sample applications or contribute to the framework development.</p>"},{"location":"mario-pizzeria/","title":"\ud83c\udf55 Mario's Pizzeria: Complete Bounded Context","text":"<p>Mario's Pizzeria is the comprehensive business domain used throughout the Neuroglia framework documentation. This real-world example demonstrates clean architecture, CQRS patterns, event-driven design, and all framework features through a production-ready pizza ordering system.</p>"},{"location":"mario-pizzeria/#business-overview","title":"\ud83c\udfaf Business Overview","text":"<p>Mario's Pizzeria is a local pizza restaurant that needs a digital ordering system to handle:</p> <ul> <li>Customer Orders: Online pizza ordering with customizations</li> <li>Menu Management: Pizza catalog with sizes, toppings, and pricing</li> <li>Kitchen Operations: Order queue management and preparation workflow</li> <li>Payment Processing: Multiple payment methods and transaction handling</li> <li>Customer Notifications: SMS alerts for order status updates</li> </ul>"},{"location":"mario-pizzeria/#system-architecture","title":"\ud83c\udfd7\ufe0f System Architecture","text":"<p>The pizzeria system demonstrates clean architecture with clear layer separation:</p> <pre><code>C4Context\n    title System Context - Mario's Pizzeria\n\n    Person(customer, \"Customer\", \"Pizza lover who wants to place orders\")\n    Person(kitchen_staff, \"Kitchen Staff\", \"Cooks who prepare orders\")\n    Person(manager, \"Manager\", \"Manages menu and monitors operations\")\n\n    System_Boundary(pizzeria_system, \"Mario's Pizzeria System\") {\n        System(pizzeria_app, \"Pizzeria Application\", \"FastAPI app with clean architecture\")\n    }\n\n    System_Ext(payment_system, \"Payment System\", \"Processes credit card payments\")\n    System_Ext(sms_service, \"SMS Service\", \"Sends order notifications\")\n    SystemDb_Ext(file_storage, \"File Storage\", \"JSON files for development\")\n\n    Rel(customer, pizzeria_app, \"Places orders, checks status\")\n    Rel(kitchen_staff, pizzeria_app, \"Views orders, updates status\")\n    Rel(manager, pizzeria_app, \"Manages menu, monitors operations\")\n\n    Rel(pizzeria_app, payment_system, \"Processes payments\", \"HTTPS\")\n    Rel(pizzeria_app, sms_service, \"Sends notifications\", \"API\")\n    Rel(pizzeria_app, file_storage, \"Stores orders, menu\", \"File I/O\")\n\n    UpdateElementStyle(pizzeria_app, $bgColor=\"#E1F5FE\", $borderColor=\"#01579B\")\n    UpdateElementStyle(customer, $bgColor=\"#FFF3E0\", $borderColor=\"#E65100\")</code></pre>"},{"location":"mario-pizzeria/#main-system-interactions","title":"\ud83d\udd04 Main System Interactions","text":"<p>The following sequence diagram illustrates the complete pizza ordering workflow:</p> <pre><code>sequenceDiagram\n    participant C as Customer\n    participant API as Orders Controller\n    participant M as Mediator\n    participant PH as PlaceOrder Handler\n    participant OR as Order Repository\n    participant PS as Payment Service\n    participant K as Kitchen\n    participant SMS as SMS Service\n\n    Note over C,SMS: Complete Pizza Ordering Workflow\n\n    C-&gt;&gt;+API: POST /orders (pizza order)\n    API-&gt;&gt;+M: Execute PlaceOrderCommand\n    M-&gt;&gt;+PH: Handle command\n\n    PH-&gt;&gt;PH: Validate order &amp; calculate total\n    PH-&gt;&gt;+PS: Process payment\n    PS--&gt;&gt;-PH: Payment successful\n\n    PH-&gt;&gt;+OR: Save order\n    OR--&gt;&gt;-PH: Order saved\n\n    PH-&gt;&gt;PH: Raise OrderPlacedEvent\n    PH--&gt;&gt;-M: Return OrderDto\n    M--&gt;&gt;-API: Return result\n    API--&gt;&gt;-C: 201 Created + OrderDto\n\n    Note over K,SMS: Event-Driven Kitchen Workflow\n\n    M-&gt;&gt;+K: OrderPlacedEvent \u2192 Add to queue\n    K--&gt;&gt;-M: Order queued\n\n    rect rgb(255, 245, 235)\n        Note over K: Kitchen processes order\n        K-&gt;&gt;K: Start cooking\n        K-&gt;&gt;+M: Publish OrderCookingEvent\n        M--&gt;&gt;-K: Event processed\n    end\n\n    rect rgb(240, 255, 240)\n        Note over K: Order ready\n        K-&gt;&gt;+M: Publish OrderReadyEvent\n        M-&gt;&gt;+SMS: Send ready notification\n        SMS-&gt;&gt;C: \"Your order is ready!\"\n        SMS--&gt;&gt;-M: Notification sent\n        M--&gt;&gt;-K: Event processed\n    end\n\n    C-&gt;&gt;+API: GET /orders/{id}\n    API-&gt;&gt;+M: Execute GetOrderQuery\n    M--&gt;&gt;-API: Return OrderDto\n    API--&gt;&gt;-C: Order details</code></pre>"},{"location":"mario-pizzeria/#clean-architecture-layers","title":"\ud83c\udfdb\ufe0f Clean Architecture Layers","text":"<p>Mario's Pizzeria demonstrates the four-layer clean architecture:</p> <pre><code>C4Container\n    title Container Diagram - Mario's Pizzeria Clean Architecture\n\n    Container_Boundary(api_layer, \"\ud83c\udf10 API Layer\") {\n        Container(orders_controller, \"OrdersController\", \"FastAPI\", \"Order management endpoints\")\n        Container(menu_controller, \"MenuController\", \"FastAPI\", \"Menu browsing endpoints\")\n        Container(kitchen_controller, \"KitchenController\", \"FastAPI\", \"Kitchen status endpoints\")\n        Container(order_dto, \"DTOs\", \"Pydantic\", \"Request/Response models\")\n    }\n\n    Container_Boundary(app_layer, \"\ud83d\udcbc Application Layer\") {\n        Container(mediator, \"Mediator\", \"CQRS\", \"Command/Query dispatcher\")\n        Container(place_order_handler, \"PlaceOrderHandler\", \"Command Handler\", \"Order placement logic\")\n        Container(get_menu_handler, \"GetMenuHandler\", \"Query Handler\", \"Menu retrieval logic\")\n        Container(kitchen_handler, \"KitchenHandlers\", \"Event Handlers\", \"Kitchen workflow\")\n    }\n\n    Container_Boundary(domain_layer, \"\ud83c\udfdb\ufe0f Domain Layer\") {\n        Container(order_entity, \"Order\", \"Entity\", \"Order business logic\")\n        Container(pizza_entity, \"Pizza\", \"Entity\", \"Pizza with pricing\")\n        Container(customer_entity, \"Customer\", \"Entity\", \"Customer information\")\n        Container(kitchen_entity, \"Kitchen\", \"Entity\", \"Kitchen capacity\")\n        Container(domain_events, \"Domain Events\", \"Events\", \"OrderPlaced, OrderReady\")\n    }\n\n    Container_Boundary(integration_layer, \"\ud83d\udd0c Integration Layer\") {\n        Container(order_repo, \"OrderRepository\", \"File/Mongo\", \"Order persistence\")\n        Container(payment_service, \"PaymentService\", \"External API\", \"Payment processing\")\n        Container(sms_service, \"SMSService\", \"External API\", \"Customer notifications\")\n    }\n\n    Rel(orders_controller, mediator, \"Sends commands/queries\")\n    Rel(menu_controller, mediator, \"Sends queries\")\n    Rel(kitchen_controller, mediator, \"Sends queries\")\n\n    Rel(mediator, place_order_handler, \"Routes PlaceOrderCommand\")\n    Rel(mediator, get_menu_handler, \"Routes GetMenuQuery\")\n    Rel(mediator, kitchen_handler, \"Routes events\")\n\n    Rel(place_order_handler, order_entity, \"Creates/manipulates\")\n    Rel(place_order_handler, payment_service, \"Processes payments\")\n    Rel(get_menu_handler, pizza_entity, \"Reads menu data\")\n\n    Rel(place_order_handler, order_repo, \"Persists orders\")\n    Rel(kitchen_handler, sms_service, \"Sends notifications\")\n\n    UpdateElementStyle(orders_controller, $bgColor=\"#E3F2FD\")\n    UpdateElementStyle(mediator, $bgColor=\"#F3E5F5\")\n    UpdateElementStyle(order_entity, $bgColor=\"#E8F5E8\")\n    UpdateElementStyle(order_repo, $bgColor=\"#FFF3E0\")</code></pre>"},{"location":"mario-pizzeria/#domain-model","title":"\ud83d\udcca Domain Model","text":"<p>The core business entities and their relationships:</p> <pre><code>classDiagram\n    class Customer {\n        +String id\n        +String name\n        +String email\n        +String phone\n        +String address\n        +updateContactInfo()\n    }\n\n    class Order {\n        +String id\n        +String customerId\n        +List~Pizza~ pizzas\n        +OrderStatus status\n        +Decimal totalAmount\n        +DateTime orderTime\n        +addPizza()\n        +confirmOrder()\n        +startCooking()\n        +markReady()\n        +deliverOrder()\n        +cancelOrder()\n    }\n\n    class Pizza {\n        +String id\n        +String name\n        +PizzaSize size\n        +Decimal basePrice\n        +List~String~ toppings\n        +Decimal totalPrice\n        +addTopping()\n        +removeTopping()\n    }\n\n    class Kitchen {\n        +String id\n        +List~String~ activeOrders\n        +Int maxConcurrentOrders\n        +Int currentCapacity\n        +Bool isAtCapacity\n        +startOrder()\n        +completeOrder()\n    }\n\n    class OrderStatus {\n        &lt;&lt;enumeration&gt;&gt;\n        PENDING\n        CONFIRMED\n        COOKING\n        READY\n        DELIVERED\n        CANCELLED\n    }\n\n    class PizzaSize {\n        &lt;&lt;enumeration&gt;&gt;\n        SMALL\n        MEDIUM\n        LARGE\n    }\n\n    Customer \"1\" --&gt; \"*\" Order : places\n    Order \"1\" --&gt; \"*\" Pizza : contains\n    Order --&gt; OrderStatus : has\n    Pizza --&gt; PizzaSize : has\n    Kitchen \"1\" --&gt; \"*\" Order : processes\n\n    note for Order \"Rich domain entity with\\nbusiness logic and events\"\n    note for Pizza \"Value object with\\npricing calculations\"\n    note for Kitchen \"Aggregate root for\\ncapacity management\"</code></pre>"},{"location":"mario-pizzeria/#cqrs-commands-and-queries","title":"\ud83c\udfaf CQRS Commands and Queries","text":"<p>The system uses CQRS pattern with clear separation between write and read operations:</p>"},{"location":"mario-pizzeria/#commands-write-operations","title":"Commands (Write Operations)","text":"<pre><code>@dataclass\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    customer_name: str\n    customer_phone: str\n    customer_address: str\n    pizzas: List[PizzaOrderDto]\n    payment_method: str\n\n@dataclass\nclass StartCookingCommand(Command[OperationResult[OrderDto]]):\n    order_id: str\n    kitchen_staff_id: str\n\n@dataclass\nclass CompleteOrderCommand(Command[OperationResult[OrderDto]]):\n    order_id: str\n    completion_time: Optional[datetime] = None\n</code></pre>"},{"location":"mario-pizzeria/#queries-read-operations","title":"Queries (Read Operations)","text":"<pre><code>@dataclass\nclass GetOrderByIdQuery(Query[Optional[OrderDto]]):\n    order_id: str\n\n@dataclass\nclass GetMenuQuery(Query[List[PizzaDto]]):\n    category: Optional[str] = None\n\n@dataclass\nclass GetKitchenStatusQuery(Query[KitchenStatusDto]):\n    pass\n\n@dataclass\nclass GetActiveOrdersQuery(Query[List[OrderDto]]):\n    pass\n</code></pre>"},{"location":"mario-pizzeria/#event-driven-workflow","title":"\ud83d\udce1 Event-Driven Workflow","text":"<p>The system uses domain events to handle complex business workflows:</p> <pre><code>flowchart TD\n    A[Customer Places Order] --&gt; B[OrderPlacedEvent]\n    B --&gt; C[Kitchen Queue Updated]\n    B --&gt; D[Payment Processed]\n\n    C --&gt; E[Staff Views Kitchen Queue]\n    E --&gt; F[Staff Starts Cooking]\n    F --&gt; G[OrderCookingEvent]\n\n    G --&gt; H[Update Order Status]\n    G --&gt; I[Start Preparation Timer]\n\n    I --&gt; J[Order Completed]\n    J --&gt; K[OrderReadyEvent]\n\n    K --&gt; L[SMS Notification Sent]\n    K --&gt; M[Kitchen Capacity Freed]\n\n    L --&gt; N[Customer Notified]\n    M --&gt; O[Next Order Can Start]\n\n    style A fill:#FFE0B2\n    style B fill:#E1F5FE\n    style G fill:#E1F5FE\n    style K fill:#E1F5FE\n    style N fill:#C8E6C9</code></pre>"},{"location":"mario-pizzeria/#key-domain-events","title":"Key Domain Events","text":"<ul> <li>OrderPlacedEvent: Triggered when customer places order</li> <li>OrderConfirmedEvent: Triggered when payment is successful</li> <li>OrderCookingEvent: Triggered when kitchen starts preparation</li> <li>OrderReadyEvent: Triggered when order is completed</li> <li>OrderDeliveredEvent: Triggered when order is picked up</li> </ul>"},{"location":"mario-pizzeria/#data-storage-strategy","title":"\ud83d\uddc4\ufe0f Data Storage Strategy","text":"<p>Mario's Pizzeria demonstrates multiple persistence approaches:</p>"},{"location":"mario-pizzeria/#file-based-storage-development","title":"File-Based Storage (Development)","text":"<pre><code>data/\n\u251c\u2500\u2500 orders/\n\u2502   \u251c\u2500\u2500 order_001.json\n\u2502   \u251c\u2500\u2500 order_002.json\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 menu/\n\u2502   \u2514\u2500\u2500 pizzas.json\n\u2514\u2500\u2500 kitchen/\n    \u2514\u2500\u2500 status.json\n</code></pre>"},{"location":"mario-pizzeria/#mongodb-storage-production","title":"MongoDB Storage (Production)","text":"<pre><code>// Orders Collection\n{\n  \"_id\": \"order_001\",\n  \"customer_name\": \"Mario Rossi\",\n  \"customer_phone\": \"+1-555-0123\",\n  \"pizzas\": [\n    {\n      \"name\": \"Margherita\",\n      \"size\": \"large\",\n      \"toppings\": [\"extra cheese\"],\n      \"price\": 15.99\n    }\n  ],\n  \"total_amount\": 15.99,\n  \"status\": \"ready\",\n  \"order_time\": \"2025-09-25T10:30:00Z\"\n}\n</code></pre>"},{"location":"mario-pizzeria/#event-sourcing-advanced","title":"Event Sourcing (Advanced)","text":"<pre><code>Event Store:\n\u251c\u2500\u2500 order_001_stream\n\u2502   \u251c\u2500\u2500 OrderPlacedEvent\n\u2502   \u251c\u2500\u2500 PaymentProcessedEvent\n\u2502   \u251c\u2500\u2500 OrderConfirmedEvent\n\u2502   \u251c\u2500\u2500 CookingStartedEvent\n\u2502   \u2514\u2500\u2500 OrderReadyEvent\n</code></pre>"},{"location":"mario-pizzeria/#api-endpoints","title":"\ud83c\udf10 API Endpoints","text":"<p>Complete RESTful API for all pizzeria operations:</p>"},{"location":"mario-pizzeria/#order-management","title":"Order Management","text":"Method Endpoint Description <code>POST</code> <code>/orders</code> Place new pizza order <code>GET</code> <code>/orders</code> List orders (with status filter) <code>GET</code> <code>/orders/{id}</code> Get specific order details <code>PUT</code> <code>/orders/{id}/status</code> Update order status <code>DELETE</code> <code>/orders/{id}</code> Cancel order"},{"location":"mario-pizzeria/#menu-operations","title":"Menu Operations","text":"Method Endpoint Description <code>GET</code> <code>/menu/pizzas</code> Get available pizzas <code>GET</code> <code>/menu/pizzas/{id}</code> Get pizza details <code>GET</code> <code>/menu/toppings</code> Get available toppings"},{"location":"mario-pizzeria/#kitchen-management","title":"Kitchen Management","text":"Method Endpoint Description <code>GET</code> <code>/kitchen/status</code> Get kitchen capacity status <code>GET</code> <code>/kitchen/queue</code> Get current cooking queue <code>POST</code> <code>/kitchen/orders/{id}/start</code> Start cooking order <code>POST</code> <code>/kitchen/orders/{id}/complete</code> Complete order"},{"location":"mario-pizzeria/#testing-strategy","title":"\ud83e\uddea Testing Strategy","text":"<p>Mario's Pizzeria includes comprehensive testing at all levels:</p>"},{"location":"mario-pizzeria/#unit-tests","title":"Unit Tests","text":"<pre><code>class TestOrderEntity:\n    def test_order_creation(self):\n        order = Order(customer_id=\"cust_1\")\n        assert order.status == OrderStatus.PENDING\n        assert order.total_amount == Decimal('0.00')\n\n    def test_add_pizza_to_order(self):\n        order = Order(customer_id=\"cust_1\")\n        pizza = Pizza(\"Margherita\", PizzaSize.LARGE, Decimal('15.99'))\n\n        order.add_pizza(pizza)\n\n        assert len(order.pizzas) == 1\n        assert order.total_amount == Decimal('15.99')\n\n    def test_order_status_transitions(self):\n        order = Order(customer_id=\"cust_1\")\n        order.add_pizza(Pizza(\"Pepperoni\", PizzaSize.MEDIUM, Decimal('12.99')))\n\n        order.confirm_order()\n        assert order.status == OrderStatus.CONFIRMED\n\n        order.start_cooking()\n        assert order.status == OrderStatus.COOKING\n\n        order.mark_ready()\n        assert order.status == OrderStatus.READY\n</code></pre>"},{"location":"mario-pizzeria/#integration-tests","title":"Integration Tests","text":"<pre><code>class TestOrdersController:\n    async def test_place_order_success(self, test_client):\n        order_data = {\n            \"customer_name\": \"Mario Rossi\",\n            \"customer_phone\": \"+1-555-0123\",\n            \"pizzas\": [{\"name\": \"Margherita\", \"size\": \"large\"}],\n            \"payment_method\": \"credit_card\"\n        }\n\n        response = await test_client.post(\"/orders\", json=order_data)\n\n        assert response.status_code == 201\n        data = response.json()\n        assert data[\"customer_name\"] == \"Mario Rossi\"\n        assert data[\"status\"] == \"confirmed\"\n        assert len(data[\"pizzas\"]) == 1\n\n    async def test_get_kitchen_status(self, test_client):\n        response = await test_client.get(\"/kitchen/status\")\n\n        assert response.status_code == 200\n        data = response.json()\n        assert \"current_capacity\" in data\n        assert \"max_concurrent_orders\" in data\n        assert \"active_orders\" in data\n</code></pre>"},{"location":"mario-pizzeria/#end-to-end-tests","title":"End-to-End Tests","text":"<pre><code>class TestPizzeriaWorkflow:\n    async def test_complete_order_workflow(self, test_client):\n        # 1. Customer places order\n        order_response = await test_client.post(\"/orders\", json=order_data)\n        order_id = order_response.json()[\"id\"]\n\n        # 2. Kitchen starts cooking\n        await test_client.post(f\"/kitchen/orders/{order_id}/start\")\n\n        # 3. Kitchen completes order\n        await test_client.post(f\"/kitchen/orders/{order_id}/complete\")\n\n        # 4. Verify final status\n        final_response = await test_client.get(f\"/orders/{order_id}\")\n        assert final_response.json()[\"status\"] == \"ready\"\n</code></pre>"},{"location":"mario-pizzeria/#getting-started-with-marios-pizzeria","title":"\ud83d\ude80 Getting Started with Mario's Pizzeria","text":"<p>Ready to build the complete pizzeria system? Follow our step-by-step guide:</p> <ol> <li>Set up the project structure</li> <li>Implement domain entities</li> <li>Create CQRS handlers</li> <li>Build API controllers</li> <li>Add data persistence</li> <li>Configure dependency injection</li> <li>Run and test the application</li> </ol> <p>\ud83d\udc49 Start Building Mario's Pizzeria</p>"},{"location":"mario-pizzeria/#deep-dive-topics","title":"\ud83d\udcda Deep Dive Topics","text":"<p>Explore specific aspects of Mario's Pizzeria implementation:</p> <ul> <li>Clean Architecture Patterns - Layer separation and dependency inversion</li> <li>CQRS Implementation - Command/query separation with practical examples</li> <li>Event-Driven Design - Domain events and reactive workflows</li> <li>Repository Pattern - Data access abstraction and testing</li> <li>Dependency Injection - Service container and lifetime management</li> <li>Testing Strategies - Unit, integration, and end-to-end testing</li> </ul> <p>Mario's Pizzeria showcases how all these patterns work together in a real-world application, providing you with practical examples and best practices for building your own production-ready systems.</p>"},{"location":"patterns/","title":"\ud83c\udfaf Patterns and Best Practices","text":"<p>\ud83d\udea7 Under Construction</p> <p>This section is currently being expanded with detailed pattern implementations and Mario's Pizzeria examples. Individual pattern pages with comprehensive code examples and visual diagrams are being developed.</p> <p>Software design patterns and architectural best practices demonstrated through the Neuroglia framework, with real examples from the Mario's Pizzeria sample application.</p>"},{"location":"patterns/#architectural-patterns","title":"\ud83c\udfd7\ufe0f Architectural Patterns","text":""},{"location":"patterns/#clean-architecture","title":"Clean Architecture","text":"<p>Four-layer separation ensuring dependency inversion and testability.</p>"},{"location":"patterns/#cqrs-command-query-responsibility-segregation","title":"CQRS (Command Query Responsibility Segregation)","text":"<p>Separate read and write operations for better scalability and maintainability.</p>"},{"location":"patterns/#event-driven-architecture","title":"Event-Driven Architecture","text":"<p>Decoupled communication through domain events and CloudEvents.</p>"},{"location":"patterns/#repository-pattern","title":"Repository Pattern","text":"<p>Abstract data access for testability and flexibility.</p>"},{"location":"patterns/#domain-driven-design-patterns","title":"\ud83c\udfaf Domain-Driven Design Patterns","text":""},{"location":"patterns/#bounded-context","title":"Bounded Context","text":"<p>Self-contained business domains with clear boundaries.</p>"},{"location":"patterns/#aggregate-root","title":"Aggregate Root","text":"<p>Consistency boundaries within the domain model.</p>"},{"location":"patterns/#domain-events","title":"Domain Events","text":"<p>Business events raised by domain entities.</p>"},{"location":"patterns/#value-objects","title":"Value Objects","text":"<p>Immutable objects that describe characteristics.</p>"},{"location":"patterns/#application-patterns","title":"\ud83d\udcbc Application Patterns","text":""},{"location":"patterns/#mediator-pattern","title":"Mediator Pattern","text":"<p>Central request/response handling through the mediator.</p>"},{"location":"patterns/#command-pattern","title":"Command Pattern","text":"<p>Encapsulate requests as objects for queuing and logging.</p>"},{"location":"patterns/#query-pattern","title":"Query Pattern","text":"<p>Optimized read operations with dedicated query models.</p>"},{"location":"patterns/#pipeline-behaviors","title":"Pipeline Behaviors","text":"<p>Cross-cutting concerns like validation and logging.</p>"},{"location":"patterns/#integration-patterns","title":"\ud83d\udd0c Integration Patterns","text":""},{"location":"patterns/#adapter-pattern","title":"Adapter Pattern","text":"<p>Integrate external systems through adapters.</p>"},{"location":"patterns/#anti-corruption-layer","title":"Anti-Corruption Layer","text":"<p>Protect domain models from external influence.</p>"},{"location":"patterns/#event-sourcing","title":"Event Sourcing","text":"<p>Store state changes as events for auditability.</p>"},{"location":"patterns/#saga-pattern","title":"SAGA Pattern","text":"<p>Manage distributed transactions across services.</p> <p>Complete pattern examples with code snippets coming soon \ud83d\udea7</p>"},{"location":"test-mermaid/","title":"Mermaid Test Page","text":"<p>This page tests Mermaid diagram rendering in MkDocs.</p>"},{"location":"test-mermaid/#basic-flowchart","title":"Basic Flowchart","text":"<pre><code>graph TD\n    A[Start] --&gt; B{Is it working?}\n    B --&gt;|Yes| C[Great!]\n    B --&gt;|No| D[Debug]\n    D --&gt; A\n    C --&gt; E[End]</code></pre>"},{"location":"test-mermaid/#sequence-diagram","title":"Sequence Diagram","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Controller\n    participant Service\n    participant Database\n\n    User-&gt;&gt;Controller: HTTP Request\n    Controller-&gt;&gt;Service: Business Logic\n    Service-&gt;&gt;Database: Query Data\n    Database--&gt;&gt;Service: Result\n    Service--&gt;&gt;Controller: Response\n    Controller--&gt;&gt;User: HTTP Response</code></pre>"},{"location":"test-mermaid/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>graph TB\n    subgraph \"Application Layer\"\n        A[Controllers] --&gt; B[Mediator]\n        B --&gt; C[Command Handlers]\n        B --&gt; D[Query Handlers]\n    end\n\n    subgraph \"Domain Layer\"\n        E[Entities] --&gt; F[Value Objects]\n        E --&gt; G[Domain Events]\n    end\n\n    subgraph \"Integration Layer\"\n        H[Repositories] --&gt; I[External APIs]\n        H --&gt; J[Database]\n    end\n\n    C --&gt; E\n    D --&gt; H\n    A --&gt; B</code></pre>"},{"location":"test-mermaid/#class-diagram","title":"Class Diagram","text":"<pre><code>classDiagram\n    class Controller {\n        +service_provider: ServiceProvider\n        +mediator: Mediator\n        +mapper: Mapper\n        +process(result: OperationResult): Response\n    }\n\n    class CommandHandler {\n        +handle_async(command: Command): OperationResult\n    }\n\n    class QueryHandler {\n        +handle_async(query: Query): Result\n    }\n\n    Controller --&gt; CommandHandler : uses\n    Controller --&gt; QueryHandler : uses\n    CommandHandler --&gt; Entity : creates/modifies\n    QueryHandler --&gt; Repository : reads from</code></pre>"},{"location":"features/","title":"\ud83d\ude80 Framework Features","text":"<p>The Neuroglia Python framework provides a comprehensive set of features designed to support modern microservice development with clean architecture principles. Each feature is designed to work seamlessly together while maintaining loose coupling and high testability.</p>"},{"location":"features/#core-architecture-features","title":"\ud83c\udfaf Core Architecture Features","text":""},{"location":"features/#dependency-injection","title":"\ud83d\udd27 Dependency Injection","text":"<p>Comprehensive IoC container with lifecycle management, service registration, and automatic resolution. Supports singleton, scoped, and transient lifetimes with built-in service discovery patterns.</p> <p>Key Capabilities:</p> <ul> <li>Service registration with multiple lifetimes</li> <li>Constructor injection patterns</li> <li>Service provider resolution</li> <li>Automatic service discovery</li> </ul>"},{"location":"features/#cqrs-mediation","title":"\ud83d\udce1 CQRS &amp; Mediation","text":"<p>Command Query Responsibility Segregation with a powerful mediator pattern that decouples request handling from business logic. Enables clean separation between read and write operations.</p> <p>Key Capabilities:</p> <ul> <li>Command and query separation</li> <li>Pipeline behaviors for cross-cutting concerns</li> <li>Request/response mediation</li> <li>Asynchronous processing support</li> </ul>"},{"location":"features/#mvc-controllers","title":"\ud83c\udf10 MVC Controllers","text":"<p>FastAPI-integrated controller framework that automatically discovers and registers API endpoints. Provides consistent patterns for request handling and response formatting.</p> <p>Key Capabilities:</p> <ul> <li>Automatic controller discovery</li> <li>Consistent API patterns</li> <li>Built-in validation and serialization</li> <li>Integration with dependency injection</li> </ul>"},{"location":"features/#data-access","title":"\ud83d\udcbe Data Access","text":"<p>Flexible data access patterns supporting multiple storage backends including MongoDB, file-based storage, and in-memory repositories. Implements repository and unit of work patterns.</p> <p>Key Capabilities:</p> <ul> <li>Repository pattern implementations</li> <li>Multiple storage backends</li> <li>Async/await data operations</li> <li>Transaction support</li> </ul>"},{"location":"features/#event-integration-features","title":"\ud83d\udd04 Event &amp; Integration Features","text":""},{"location":"features/#event-sourcing","title":"\ud83d\udce8 Event Sourcing","text":"<p>Complete event sourcing implementation with event stores, projections, and replay capabilities. Supports CloudEvents standard for interoperability.</p> <p>Key Capabilities:</p> <ul> <li>Event store implementation</li> <li>Event replay and projections</li> <li>CloudEvents integration</li> <li>Snapshot support</li> </ul>"},{"location":"features/#mermaid-diagrams","title":"\ud83d\udcca Mermaid Diagrams","text":"<p>Built-in support for generating and validating Mermaid diagrams for architecture documentation. Includes diagram validation and preview capabilities.</p> <p>Key Capabilities:</p> <ul> <li>Architecture diagram generation</li> <li>Diagram validation</li> <li>Multiple diagram types</li> <li>Documentation integration</li> </ul>"},{"location":"features/#advanced-architecture-features","title":"\ud83c\udfd7\ufe0f Advanced Architecture Features","text":""},{"location":"features/#resource-oriented-architecture","title":"\ud83c\udfaf Resource Oriented Architecture","text":"<p>Implementation of resource-oriented patterns for building RESTful APIs and microservices. Focuses on resource identification and manipulation through standard HTTP verbs.</p> <p>Key Capabilities:</p> <ul> <li>Resource identification patterns</li> <li>RESTful API design</li> <li>HTTP verb mapping</li> <li>Resource lifecycle management</li> </ul>"},{"location":"features/#serialization","title":"Serialization","text":"<p>Powerful JSON serialization system with automatic type handling, custom encoders, and seamless integration with domain objects.</p> <p>Key Capabilities:</p> <ul> <li>Automatic type conversion (enums, decimals, datetime)</li> <li>Custom JsonEncoder for complex objects</li> <li>Dependency injection integration</li> <li>Comprehensive error handling</li> </ul>"},{"location":"features/#object-mapping","title":"\ud83c\udfaf Object Mapping","text":"<p>Advanced object-to-object mapping with convention-based property matching, custom transformations, and type conversion support.</p> <p>Key Capabilities:</p> <ul> <li>Convention-based automatic mapping</li> <li>Custom mapping configurations</li> <li>Type conversion and validation</li> <li>Mapping profiles and reusable configurations</li> </ul>"},{"location":"features/#reactive-programming","title":"\ud83d\udd04 Reactive Programming","text":"<p>Reactive programming capabilities using Observable patterns with RxPY integration for building event-driven, responsive applications.</p> <p>Key Capabilities:</p> <ul> <li>Observable streams and event processing</li> <li>AsyncRx integration for async/await patterns</li> <li>Background service integration</li> <li>Real-time data flow management</li> </ul>"},{"location":"features/#enhanced-integration-features","title":"\ud83d\ude80 Enhanced Integration Features","text":""},{"location":"features/#background-task-scheduling","title":"\u23f0 Background Task Scheduling","text":"<p>Enterprise-grade background task scheduling with APScheduler integration, Redis persistence, and comprehensive error handling for complex workflow orchestration.</p> <p>Key Capabilities:</p> <ul> <li>APScheduler integration with multiple job stores</li> <li>Redis persistence for distributed scheduling</li> <li>Reactive stream processing for real-time events</li> <li>Circuit breaker patterns and retry policies</li> <li>Comprehensive monitoring and error handling</li> </ul>"},{"location":"features/#redis-cache-repository","title":"\u26a1 Redis Cache Repository","text":"<p>High-performance Redis-based caching repository with async operations, distributed locks, and intelligent cache management for scalable microservices.</p> <p>Key Capabilities:</p> <ul> <li>Async Redis operations with connection pooling</li> <li>Distributed locks for cache consistency</li> <li>Hash-based storage with automatic serialization</li> <li>TTL management and cache invalidation strategies</li> <li>Comprehensive error handling and fallback mechanisms</li> </ul>"},{"location":"features/#http-service-client","title":"\ud83c\udf10 HTTP Service Client","text":"<p>Resilient HTTP client with retry policies, circuit breaker patterns, request/response interceptors, and comprehensive error handling for external API integration.</p> <p>Key Capabilities:</p> <ul> <li>Circuit breaker patterns for fault tolerance</li> <li>Configurable retry policies with exponential backoff</li> <li>Request/response interceptors for cross-cutting concerns</li> <li>Comprehensive error handling and logging</li> <li>Service-specific configuration management</li> </ul>"},{"location":"features/#case-conversion-utilities","title":"\ud83d\udd24 Case Conversion utilities","text":"<p>Comprehensive string and object case conversion utilities supporting snake_case, camelCase, PascalCase, kebab-case, and Title Case transformations with Pydantic integration.</p> <p>Key Capabilities:</p> <ul> <li>Comprehensive case conversion (snake_case \u2194 camelCase \u2194 PascalCase \u2194 kebab-case \u2194 Title Case)</li> <li>Recursive dictionary key transformation for nested objects</li> <li>Pydantic CamelModel base class with automatic alias generation</li> <li>API serialization compatibility for different naming conventions</li> <li>Optional dependency management with graceful fallback</li> </ul>"},{"location":"features/#enhanced-model-validation","title":"\u2705 Enhanced Model Validation","text":"<p>Advanced validation system with business rules, conditional validation, custom validators, and comprehensive error reporting for complex domain logic validation.</p> <p>Key Capabilities:</p> <ul> <li>Business rule validation with fluent API</li> <li>Conditional validation rules that apply based on context</li> <li>Property and entity validators with composite logic</li> <li>Comprehensive error aggregation and field-specific reporting</li> <li>Decorator-based method parameter validation</li> <li>Integration with domain-driven design patterns</li> </ul>"},{"location":"features/#development-testing-features","title":"\ud83e\uddea Development &amp; Testing Features","text":"<p>All features include comprehensive testing support with:</p> <ul> <li>Unit Testing: Isolated testing with mocking support</li> <li>Integration Testing: Full-stack testing capabilities</li> <li>Performance Testing: Built-in performance monitoring</li> <li>Documentation: Comprehensive examples and guides</li> </ul>"},{"location":"features/#feature-integration","title":"\ud83d\udd17 Feature Integration","text":"<p>The framework features are designed to work together seamlessly:</p> <pre><code>graph TB\n    subgraph \"\ud83c\udf10 Presentation Layer\"\n        MVC[MVC Controllers]\n    end\n\n    subgraph \"\ud83d\udcbc Application Layer\"\n        CQRS[CQRS &amp; Mediation]\n        Watcher[Watcher Patterns]\n    end\n\n    subgraph \"\ud83c\udfdb\ufe0f Domain Layer\"\n        Events[Event Sourcing]\n        Resources[Resource Patterns]\n    end\n\n    subgraph \"\ud83d\udd0c Infrastructure Layer\"\n        DI[Dependency Injection]\n        Data[Data Access]\n        Diagrams[Mermaid Diagrams]\n    end\n\n    MVC --&gt; CQRS\n    CQRS --&gt; Events\n    CQRS --&gt; Data\n    Watcher --&gt; Events\n    Watcher --&gt; Resources\n\n    DI -.-&gt; MVC\n    DI -.-&gt; CQRS\n    DI -.-&gt; Data\n\n    style MVC fill:#e3f2fd\n    style CQRS fill:#f3e5f5\n    style Events fill:#e8f5e8\n    style DI fill:#fff3e0</code></pre>"},{"location":"features/#getting-started","title":"\ud83d\ude80 Getting Started","text":"<ol> <li>Start with Dependency Injection - Foundation for all other features</li> <li>Add CQRS &amp; Mediation - Core application patterns</li> <li>Implement MVC Controllers - API layer development</li> <li>Choose Data Access - Persistence strategy</li> <li>Enhance with specialized features - Event sourcing, watchers, etc.</li> </ol>"},{"location":"features/#related-documentation","title":"\ud83d\udcda Related Documentation","text":"<ul> <li>\ud83c\udfaf Architecture Patterns - Design patterns and principles</li> <li>\ud83d\udcd6 Implementation Guides - Step-by-step implementation guides</li> <li>\ud83c\udf55 Mario's Pizzeria - Complete working example</li> <li>\ud83d\udcbc Sample Applications - Real-world implementation examples</li> </ul> <p>Each feature page contains detailed implementation examples, best practices, and integration patterns. The framework is designed to be incrementally adoptable - start with the core features and add specialized capabilities as needed.</p>"},{"location":"features/DOCUMENTATION_UPDATES/","title":"\ud83d\udcdd Documentation Updates Summary","text":""},{"location":"features/DOCUMENTATION_UPDATES/#new-roa-features-added-to-main-readmemd","title":"New ROA Features Added to Main README.md","text":""},{"location":"features/DOCUMENTATION_UPDATES/#key-features-section","title":"\ud83d\ude80 Key Features Section","text":"<ul> <li>Added Resource Oriented Architecture to the key features list</li> <li>Positioned ROA alongside other core features like CQRS, Event-Driven Architecture, etc.</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#documentation-links-section","title":"\ud83d\udcda Documentation Links Section","text":"<ul> <li>Added link to Resource Oriented Architecture documentation</li> <li>Positioned in logical order with other architectural features</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#sample-applications-section","title":"\ud83d\udccb Sample Applications Section","text":"<ul> <li>Added Lab Resource Manager sample with ROA demonstration</li> <li>Includes brief description highlighting key ROA patterns</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#framework-components-table","title":"\ud83c\udfd7\ufe0f Framework Components Table","text":"<ul> <li>Added Resource Oriented Architecture component entry</li> <li>Links to comprehensive ROA documentation</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#new-documentation-files-created","title":"New Documentation Files Created","text":""},{"location":"features/DOCUMENTATION_UPDATES/#1-docsfeaturesresource-oriented-architecturemd","title":"1. <code>docs/features/resource-oriented-architecture.md</code>","text":"<p>Comprehensive ROA feature documentation covering: - Overview of ROA concepts and benefits - Core components: Resources, Watchers, Controllers, Reconcilers - Key patterns: Declarative state, event-driven processing, state machines - Execution model: timing, coordination, concurrent processing - Safety and reliability: timeouts, error recovery, drift detection - Observability: metrics, logging, resource versioning - Configuration and scaling considerations - Use cases and related documentation links</p>"},{"location":"features/DOCUMENTATION_UPDATES/#2-docssampleslab-resource-managermd","title":"2. <code>docs/samples/lab-resource-manager.md</code>","text":"<p>Complete sample application documentation covering: - What developers will learn from the sample - Detailed architecture diagrams - Domain model with LabInstance resources - Component implementation details (Watcher, Controller, Reconciler) - Execution flow explanations - Running instructions with multiple demo options - Key implementation details and design patterns - Configuration options and testing guidance - Next steps for extending the sample</p>"},{"location":"features/DOCUMENTATION_UPDATES/#3-updates-to-docsindexmd","title":"3. Updates to <code>docs/index.md</code>","text":"<p>Enhanced main documentation index with: - ROA added to \"What Makes Neuroglia Special\" features list - New ROA section in Core Features with code examples - Lab Resource Manager added to Sample Applications section</p>"},{"location":"features/DOCUMENTATION_UPDATES/#4-updates-to-mkdocsyml","title":"4. Updates to <code>mkdocs.yml</code>","text":"<p>Enhanced navigation structure with: - Resource Oriented Architecture in Features section - Watcher &amp; Reconciliation Patterns documentation links - Watcher &amp; Reconciliation Execution documentation links - Lab Resource Manager in Sample Applications section</p>"},{"location":"features/DOCUMENTATION_UPDATES/#content-highlights","title":"Content Highlights","text":""},{"location":"features/DOCUMENTATION_UPDATES/#roa-documentation-features","title":"\ud83c\udfaf ROA Documentation Features","text":"<ul> <li>Practical Examples: Real code samples showing patterns in action</li> <li>Architecture Diagrams: Visual representation of component relationships</li> <li>Execution Models: Detailed timing and coordination explanations</li> <li>Safety Mechanisms: Comprehensive error handling and recovery patterns</li> <li>Configuration Guidance: Production-ready tuning recommendations</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#lab-resource-manager-sample-features","title":"\ud83e\uddea Lab Resource Manager Sample Features","text":"<ul> <li>Complete Implementation: Working demonstration with multiple complexity levels</li> <li>Real-time Execution: Live demonstration showing patterns in action</li> <li>Educational Focus: Clear explanations of why and how patterns work</li> <li>Multiple Demo Options: From simple pattern demos to full framework integration</li> <li>Comprehensive Testing: Unit and integration test examples</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#documentation-quality-standards","title":"Documentation Quality Standards","text":""},{"location":"features/DOCUMENTATION_UPDATES/#standards-applied","title":"\u2705 Standards Applied","text":"<ul> <li>Consistent Formatting: Following existing documentation style and emoji usage</li> <li>Cross-References: Proper linking between related documentation sections</li> <li>Code Examples: Working, realistic code samples throughout</li> <li>Progressive Complexity: Simple to advanced examples</li> <li>Practical Focus: Real-world use cases and implementation guidance</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#link-structure","title":"\ud83d\udd17 Link Structure","text":"<ul> <li>Bidirectional Links: Documents reference each other appropriately</li> <li>Logical Navigation: Features \u2192 Samples \u2192 Getting Started flow</li> <li>MkDocs Integration: Proper navigation structure for documentation site</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#impact-on-framework","title":"Impact on Framework","text":""},{"location":"features/DOCUMENTATION_UPDATES/#enhanced-capabilities","title":"\ud83d\udcc8 Enhanced Capabilities","text":"<ul> <li>New Architectural Pattern: ROA adds powerful resource management capabilities</li> <li>Complete Pattern Implementation: Watchers, controllers, and reconcilers working together</li> <li>Real-world Examples: Practical demonstration of complex distributed system patterns</li> <li>Educational Value: Developers can learn advanced patterns through working examples</li> </ul>"},{"location":"features/DOCUMENTATION_UPDATES/#framework-positioning","title":"\ud83c\udfaf Framework Positioning","text":"<ul> <li>Kubernetes-like Patterns: Brings declarative resource management to Python applications</li> <li>Production-Ready: Comprehensive error handling, monitoring, and configuration options</li> <li>Framework Integration: ROA patterns work seamlessly with existing CQRS and DI features</li> </ul> <p>The documentation updates provide comprehensive coverage of the new ROA features while maintaining consistency with existing documentation standards and navigation patterns.</p>"},{"location":"features/background-task-scheduling/","title":"\u23f0 Background Task Scheduling","text":"<p>The Neuroglia framework provides enterprise-grade background task scheduling capabilities through seamless APScheduler integration, enabling complex workflow orchestration with Redis persistence, reactive stream processing, and comprehensive error handling.</p>"},{"location":"features/background-task-scheduling/#overview","title":"\ud83c\udfaf Overview","text":"<p>Background task scheduling is essential for microservices that need to perform operations asynchronously, handle periodic tasks, or respond to events with delayed processing. The framework's implementation provides:</p> <ul> <li>APScheduler Integration: Full integration with Advanced Python Scheduler</li> <li>Redis Persistence: Distributed job persistence across service instances</li> <li>Reactive Processing: Real-time event stream processing</li> <li>Fault Tolerance: Circuit breaker patterns and retry policies</li> <li>Monitoring: Comprehensive job execution monitoring and error handling</li> </ul>"},{"location":"features/background-task-scheduling/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>graph TB\n    subgraph \"\ud83c\udf55 Mario's Pizzeria Application\"\n        OrderService[Order Service]\n        DeliveryService[Delivery Service]\n        KitchenService[Kitchen Service]\n    end\n\n    subgraph \"\u23f0 Background Task Scheduler\"\n        Scheduler[Task Scheduler]\n        JobStore[Redis Job Store]\n        Executor[Task Executor]\n    end\n\n    subgraph \"\ud83d\udd04 Task Types\"\n        Periodic[Periodic Tasks]\n        Delayed[Delayed Tasks]\n        Reactive[Event-Driven Tasks]\n    end\n\n    OrderService --&gt; Scheduler\n    DeliveryService --&gt; Scheduler\n    KitchenService --&gt; Scheduler\n\n    Scheduler --&gt; JobStore\n    Scheduler --&gt; Executor\n\n    Executor --&gt; Periodic\n    Executor --&gt; Delayed\n    Executor --&gt; Reactive\n\n    style Scheduler fill:#e3f2fd\n    style JobStore fill:#ffebee\n    style Executor fill:#e8f5e8</code></pre>"},{"location":"features/background-task-scheduling/#basic-usage","title":"\ud83d\ude80 Basic Usage","text":""},{"location":"features/background-task-scheduling/#service-registration","title":"Service Registration","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.scheduling import BackgroundTaskScheduler\n\ndef create_app():\n    builder = WebApplicationBuilder()\n\n    # Register background task scheduler\n    builder.services.add_background_task_scheduler(\n        redis_url=\"redis://localhost:6379\",\n        job_store_prefix=\"mario_pizzeria\"\n    )\n\n    app = builder.build()\n    return app\n</code></pre>"},{"location":"features/background-task-scheduling/#scheduled-task-definition","title":"Scheduled Task Definition","text":"<pre><code>from neuroglia.scheduling import BackgroundTask, schedule_task\nfrom neuroglia.dependency_injection import ServiceProviderBase\nfrom datetime import datetime, timedelta\n\nclass PizzaOrderService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.service_provider = service_provider\n        self.scheduler = service_provider.get_service(BackgroundTaskScheduler)\n\n    async def schedule_order_reminders(self, order_id: str):\n        \"\"\"Schedule reminder tasks for a pizza order.\"\"\"\n\n        # Schedule preparation reminder (15 minutes)\n        await self.scheduler.schedule_delayed_task(\n            \"order_preparation_reminder\",\n            self.send_preparation_reminder,\n            delay_minutes=15,\n            args=[order_id],\n            tags=[\"order\", \"reminder\"]\n        )\n\n        # Schedule delivery reminder (45 minutes)\n        await self.scheduler.schedule_delayed_task(\n            \"order_delivery_reminder\",\n            self.send_delivery_reminder,\n            delay_minutes=45,\n            args=[order_id],\n            tags=[\"delivery\", \"reminder\"]\n        )\n\n    async def send_preparation_reminder(self, order_id: str):\n        \"\"\"Send preparation reminder to kitchen.\"\"\"\n        print(f\"\ud83c\udf55 Kitchen reminder: Start preparing order {order_id}\")\n\n        # Business logic for kitchen notification\n        kitchen_service = self.service_provider.get_service(KitchenService)\n        await kitchen_service.notify_preparation_due(order_id)\n\n    async def send_delivery_reminder(self, order_id: str):\n        \"\"\"Send delivery reminder to delivery team.\"\"\"\n        print(f\"\ud83d\ude9a Delivery reminder: Order {order_id} ready for delivery\")\n\n        # Business logic for delivery notification\n        delivery_service = self.service_provider.get_service(DeliveryService)\n        await delivery_service.schedule_pickup(order_id)\n</code></pre>"},{"location":"features/background-task-scheduling/#periodic-tasks","title":"\ud83d\udcc5 Periodic Tasks","text":""},{"location":"features/background-task-scheduling/#daily-operations","title":"Daily Operations","text":"<pre><code>@schedule_task(cron=\"0 8 * * *\")  # Daily at 8 AM\nasync def daily_inventory_check():\n    \"\"\"Check pizza ingredient inventory daily.\"\"\"\n    inventory_service = get_service(InventoryService)\n\n    # Check ingredient levels\n    low_ingredients = await inventory_service.get_low_stock_ingredients()\n\n    if low_ingredients:\n        # Schedule reorder tasks\n        for ingredient in low_ingredients:\n            await schedule_ingredient_reorder(ingredient)\n\n    print(f\"\ud83d\udcca Daily inventory check completed: {len(low_ingredients)} items need reordering\")\n\n@schedule_task(cron=\"0 23 * * *\")  # Daily at 11 PM\nasync def daily_sales_report():\n    \"\"\"Generate daily sales report.\"\"\"\n    analytics_service = get_service(AnalyticsService)\n\n    today = datetime.now().date()\n    report = await analytics_service.generate_daily_report(today)\n\n    # Send report to management\n    notification_service = get_service(NotificationService)\n    await notification_service.send_sales_report(report)\n\n    print(f\"\ud83d\udcc8 Daily sales report generated: {report.total_orders} orders, ${report.total_revenue}\")\n</code></pre>"},{"location":"features/background-task-scheduling/#hourly-monitoring","title":"Hourly Monitoring","text":"<pre><code>@schedule_task(cron=\"0 * * * *\")  # Every hour\nasync def hourly_order_monitoring():\n    \"\"\"Monitor order processing efficiency.\"\"\"\n    order_service = get_service(OrderService)\n\n    # Check for delayed orders\n    delayed_orders = await order_service.get_delayed_orders()\n\n    for order in delayed_orders:\n        # Escalate delayed orders\n        await order_service.escalate_delayed_order(order.id)\n\n        # Notify customer\n        notification_service = get_service(NotificationService)\n        await notification_service.send_delay_notification(order.customer_id, order.id)\n\n    print(f\"\ud83d\udd0d Hourly monitoring: {len(delayed_orders)} delayed orders processed\")\n</code></pre>"},{"location":"features/background-task-scheduling/#reactive-task-processing","title":"\ud83d\udd04 Reactive Task Processing","text":""},{"location":"features/background-task-scheduling/#event-driven-scheduling","title":"Event-Driven Scheduling","text":"<pre><code>from neuroglia.eventing import EventHandler, DomainEvent\nfrom neuroglia.scheduling import ReactiveTaskProcessor\n\nclass OrderPlacedEvent(DomainEvent):\n    def __init__(self, order_id: str, customer_id: str, estimated_delivery: datetime):\n        super().__init__()\n        self.order_id = order_id\n        self.customer_id = customer_id\n        self.estimated_delivery = estimated_delivery\n\nclass OrderTaskScheduler(EventHandler[OrderPlacedEvent]):\n    def __init__(self, task_scheduler: BackgroundTaskScheduler):\n        self.task_scheduler = task_scheduler\n\n    async def handle_async(self, event: OrderPlacedEvent):\n        \"\"\"Schedule all tasks related to a new order.\"\"\"\n\n        # Schedule kitchen preparation task\n        prep_time = event.estimated_delivery - timedelta(minutes=30)\n        await self.task_scheduler.schedule_at(\n            \"kitchen_preparation\",\n            self.start_kitchen_preparation,\n            scheduled_time=prep_time,\n            args=[event.order_id]\n        )\n\n        # Schedule delivery dispatch task\n        dispatch_time = event.estimated_delivery - timedelta(minutes=10)\n        await self.task_scheduler.schedule_at(\n            \"delivery_dispatch\",\n            self.dispatch_delivery,\n            scheduled_time=dispatch_time,\n            args=[event.order_id, event.customer_id]\n        )\n\n        # Schedule customer notification task\n        notify_time = event.estimated_delivery - timedelta(minutes=5)\n        await self.task_scheduler.schedule_at(\n            \"customer_notification\",\n            self.notify_customer_ready,\n            scheduled_time=notify_time,\n            args=[event.customer_id, event.order_id]\n        )\n</code></pre>"},{"location":"features/background-task-scheduling/#stream-processing-integration","title":"Stream Processing Integration","text":"<pre><code>from neuroglia.reactive import Observable, StreamProcessor\n\nclass OrderStreamProcessor(StreamProcessor):\n    def __init__(self, task_scheduler: BackgroundTaskScheduler):\n        self.task_scheduler = task_scheduler\n        self.order_stream = Observable.create_subject()\n\n    async def process_order_events(self):\n        \"\"\"Process continuous stream of order events.\"\"\"\n\n        async def handle_order_stream(order_event):\n            if order_event.type == \"order_placed\":\n                await self.schedule_order_workflow(order_event)\n            elif order_event.type == \"order_cancelled\":\n                await self.cancel_order_tasks(order_event.order_id)\n            elif order_event.type == \"order_modified\":\n                await self.reschedule_order_tasks(order_event)\n\n        # Subscribe to order event stream\n        self.order_stream.subscribe(handle_order_stream)\n\n    async def schedule_order_workflow(self, order_event):\n        \"\"\"Schedule complete order workflow.\"\"\"\n        workflow_tasks = [\n            (\"inventory_check\", 0, self.check_inventory),\n            (\"kitchen_queue\", 5, self.add_to_kitchen_queue),\n            (\"preparation_start\", 15, self.start_preparation),\n            (\"quality_check\", 25, self.perform_quality_check),\n            (\"delivery_ready\", 35, self.mark_ready_for_delivery)\n        ]\n\n        for task_name, delay_minutes, task_func in workflow_tasks:\n            await self.task_scheduler.schedule_delayed_task(\n                f\"{task_name}_{order_event.order_id}\",\n                task_func,\n                delay_minutes=delay_minutes,\n                args=[order_event.order_id],\n                tags=[\"workflow\", order_event.order_id]\n            )\n</code></pre>"},{"location":"features/background-task-scheduling/#error-handling-and-resilience","title":"\ud83d\udee1\ufe0f Error Handling and Resilience","text":""},{"location":"features/background-task-scheduling/#circuit-breaker-integration","title":"Circuit Breaker Integration","text":"<pre><code>from neuroglia.scheduling import CircuitBreakerPolicy, RetryPolicy\n\nclass ResilientOrderProcessor:\n    def __init__(self, task_scheduler: BackgroundTaskScheduler):\n        self.task_scheduler = task_scheduler\n\n        # Configure circuit breaker for external services\n        self.circuit_breaker = CircuitBreakerPolicy(\n            failure_threshold=5,\n            recovery_timeout=60,\n            success_threshold=3\n        )\n\n        # Configure retry policy\n        self.retry_policy = RetryPolicy(\n            max_attempts=3,\n            backoff_factor=2.0,\n            max_delay=300\n        )\n\n    @circuit_breaker.apply\n    @retry_policy.apply\n    async def process_payment_task(self, order_id: str, amount: float):\n        \"\"\"Process payment with circuit breaker and retry policies.\"\"\"\n        try:\n            payment_service = get_service(PaymentService)\n            result = await payment_service.charge_customer(order_id, amount)\n\n            if result.success:\n                # Schedule order fulfillment\n                await self.task_scheduler.schedule_immediate_task(\n                    \"order_fulfillment\",\n                    self.fulfill_order,\n                    args=[order_id]\n                )\n            else:\n                # Schedule payment retry\n                await self.task_scheduler.schedule_delayed_task(\n                    \"payment_retry\",\n                    self.retry_payment,\n                    delay_minutes=5,\n                    args=[order_id, amount]\n                )\n\n        except PaymentServiceUnavailableError:\n            # Schedule fallback payment processing\n            await self.task_scheduler.schedule_delayed_task(\n                \"fallback_payment\",\n                self.process_fallback_payment,\n                delay_minutes=10,\n                args=[order_id, amount]\n            )\n</code></pre>"},{"location":"features/background-task-scheduling/#comprehensive-error-monitoring","title":"Comprehensive Error Monitoring","text":"<pre><code>from neuroglia.scheduling import TaskExecutionResult, TaskFailureHandler\n\nclass OrderTaskMonitor(TaskFailureHandler):\n    def __init__(self, notification_service: NotificationService):\n        self.notification_service = notification_service\n\n    async def handle_task_failure(self, task_name: str, exception: Exception, context: dict):\n        \"\"\"Handle task execution failures with comprehensive logging.\"\"\"\n\n        error_details = {\n            \"task_name\": task_name,\n            \"error_type\": type(exception).__name__,\n            \"error_message\": str(exception),\n            \"execution_time\": context.get(\"execution_time\"),\n            \"retry_count\": context.get(\"retry_count\", 0)\n        }\n\n        # Log error details\n        logger.error(f\"Task execution failed: {task_name}\", extra=error_details)\n\n        # Critical task failure notifications\n        if task_name.startswith(\"payment_\") or task_name.startswith(\"order_\"):\n            await self.notification_service.send_critical_alert(\n                f\"Critical task failure: {task_name}\",\n                error_details\n            )\n\n        # Schedule recovery tasks based on failure type\n        if isinstance(exception, InventoryShortageError):\n            await self.schedule_inventory_reorder(context.get(\"order_id\"))\n        elif isinstance(exception, KitchenOverloadError):\n            await self.schedule_order_delay_notification(context.get(\"order_id\"))\n\n    async def handle_task_success(self, task_name: str, result: any, context: dict):\n        \"\"\"Monitor successful task executions.\"\"\"\n\n        # Track task performance metrics\n        execution_time = context.get(\"execution_time\")\n        if execution_time &gt; 30:  # Tasks taking longer than 30 seconds\n            logger.warning(f\"Slow task execution: {task_name} took {execution_time}s\")\n\n        # Update order status based on completed tasks\n        if task_name.startswith(\"delivery_\"):\n            order_id = context.get(\"order_id\")\n            await self.update_order_status(order_id, \"delivered\")\n</code></pre>"},{"location":"features/background-task-scheduling/#advanced-configuration","title":"\ud83d\udd27 Advanced Configuration","text":""},{"location":"features/background-task-scheduling/#redis-job-store-configuration","title":"Redis Job Store Configuration","text":"<pre><code>from neuroglia.scheduling import RedisJobStoreConfig, SchedulerConfig\n\ndef configure_advanced_scheduler():\n    redis_config = RedisJobStoreConfig(\n        host=\"redis://localhost:6379\",\n        db=1,\n        password=\"your_redis_password\",\n        connection_pool_size=20,\n        health_check_interval=30,\n\n        # Job persistence settings\n        job_defaults={\n            'coalesce': True,\n            'max_instances': 3,\n            'misfire_grace_time': 300\n        },\n\n        # Distributed locking\n        distributed_lock_timeout=60,\n        lock_prefix=\"mario_pizzeria_locks\"\n    )\n\n    scheduler_config = SchedulerConfig(\n        job_stores={'redis': redis_config},\n        executors={\n            'default': {'type': 'threadpool', 'max_workers': 20},\n            'processpool': {'type': 'processpool', 'max_workers': 5}\n        },\n        job_defaults={\n            'coalesce': False,\n            'max_instances': 3\n        },\n        timezone='UTC'\n    )\n\n    return scheduler_config\n</code></pre>"},{"location":"features/background-task-scheduling/#custom-task-executors","title":"Custom Task Executors","text":"<pre><code>from neuroglia.scheduling import CustomTaskExecutor\nimport asyncio\n\nclass PizzaOrderExecutor(CustomTaskExecutor):\n    \"\"\"Custom executor optimized for pizza order processing.\"\"\"\n\n    def __init__(self, max_concurrent_orders: int = 10):\n        super().__init__()\n        self.semaphore = asyncio.Semaphore(max_concurrent_orders)\n        self.active_orders = set()\n\n    async def execute_task(self, task_func, *args, **kwargs):\n        \"\"\"Execute task with order-specific resource management.\"\"\"\n        async with self.semaphore:\n            order_id = kwargs.get('order_id') or args[0] if args else None\n\n            if order_id:\n                if order_id in self.active_orders:\n                    # Skip duplicate order processing\n                    return {\"status\": \"skipped\", \"reason\": \"already_processing\"}\n\n                self.active_orders.add(order_id)\n\n            try:\n                # Execute the actual task\n                result = await task_func(*args, **kwargs)\n                return {\"status\": \"completed\", \"result\": result}\n\n            except Exception as e:\n                return {\"status\": \"failed\", \"error\": str(e)}\n\n            finally:\n                if order_id:\n                    self.active_orders.discard(order_id)\n</code></pre>"},{"location":"features/background-task-scheduling/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"features/background-task-scheduling/#unit-testing-with-mocks","title":"Unit Testing with Mocks","text":"<pre><code>import pytest\nfrom unittest.mock import AsyncMock, Mock\nfrom neuroglia.scheduling import BackgroundTaskScheduler\n\nclass TestOrderTaskScheduling:\n\n    @pytest.fixture\n    def mock_scheduler(self):\n        scheduler = Mock(spec=BackgroundTaskScheduler)\n        scheduler.schedule_delayed_task = AsyncMock()\n        scheduler.schedule_at = AsyncMock()\n        return scheduler\n\n    @pytest.fixture\n    def order_service(self, mock_scheduler):\n        return PizzaOrderService(mock_scheduler)\n\n    @pytest.mark.asyncio\n    async def test_schedule_order_reminders(self, order_service, mock_scheduler):\n        \"\"\"Test order reminder scheduling.\"\"\"\n        order_id = \"order_123\"\n\n        await order_service.schedule_order_reminders(order_id)\n\n        # Verify preparation reminder scheduled\n        mock_scheduler.schedule_delayed_task.assert_any_call(\n            \"order_preparation_reminder\",\n            order_service.send_preparation_reminder,\n            delay_minutes=15,\n            args=[order_id],\n            tags=[\"order\", \"reminder\"]\n        )\n\n        # Verify delivery reminder scheduled\n        mock_scheduler.schedule_delayed_task.assert_any_call(\n            \"order_delivery_reminder\",\n            order_service.send_delivery_reminder,\n            delay_minutes=45,\n            args=[order_id],\n            tags=[\"delivery\", \"reminder\"]\n        )\n\n    @pytest.mark.asyncio\n    async def test_reactive_order_processing(self, mock_scheduler):\n        \"\"\"Test reactive task scheduling from events.\"\"\"\n        event = OrderPlacedEvent(\"order_123\", \"customer_456\", datetime.now() + timedelta(hours=1))\n        handler = OrderTaskScheduler(mock_scheduler)\n\n        await handler.handle_async(event)\n\n        # Verify all order-related tasks were scheduled\n        assert mock_scheduler.schedule_at.call_count == 3\n</code></pre>"},{"location":"features/background-task-scheduling/#integration-testing","title":"Integration Testing","text":"<pre><code>@pytest.mark.integration\nclass TestSchedulerIntegration:\n\n    @pytest.fixture\n    async def redis_scheduler(self):\n        scheduler = BackgroundTaskScheduler(\n            redis_url=\"redis://localhost:6379/15\",  # Test database\n            job_store_prefix=\"test_mario_pizzeria\"\n        )\n        await scheduler.start()\n        yield scheduler\n        await scheduler.shutdown()\n        await scheduler.clear_all_jobs()  # Cleanup\n\n    @pytest.mark.asyncio\n    async def test_end_to_end_order_workflow(self, redis_scheduler):\n        \"\"\"Test complete order processing workflow.\"\"\"\n        order_id = \"integration_test_order\"\n        executed_tasks = []\n\n        async def track_task_execution(task_name):\n            executed_tasks.append(task_name)\n\n        # Schedule workflow tasks\n        await redis_scheduler.schedule_immediate_task(\n            \"inventory_check\",\n            track_task_execution,\n            args=[\"inventory_check\"]\n        )\n\n        # Wait for task execution\n        await asyncio.sleep(2)\n\n        assert \"inventory_check\" in executed_tasks\n</code></pre>"},{"location":"features/background-task-scheduling/#monitoring-and-observability","title":"\ud83d\udcca Monitoring and Observability","text":""},{"location":"features/background-task-scheduling/#task-execution-metrics","title":"Task Execution Metrics","text":"<pre><code>from neuroglia.scheduling import TaskMetrics, MetricsCollector\n\nclass PizzaOrderMetrics(MetricsCollector):\n    def __init__(self):\n        self.metrics = TaskMetrics()\n\n    async def collect_order_metrics(self):\n        \"\"\"Collect pizza order processing metrics.\"\"\"\n        return {\n            \"total_orders_processed\": self.metrics.get_counter(\"orders_processed\"),\n            \"average_preparation_time\": self.metrics.get_gauge(\"avg_prep_time\"),\n            \"failed_tasks_count\": self.metrics.get_counter(\"task_failures\"),\n            \"active_tasks\": self.metrics.get_gauge(\"active_tasks\"),\n            \"task_queue_size\": self.metrics.get_gauge(\"queue_size\")\n        }\n\n    async def export_metrics_to_prometheus(self):\n        \"\"\"Export metrics in Prometheus format.\"\"\"\n        metrics = await self.collect_order_metrics()\n\n        prometheus_metrics = []\n        for metric_name, value in metrics.items():\n            prometheus_metrics.append(f\"mario_pizzeria_{metric_name} {value}\")\n\n        return \"\\n\".join(prometheus_metrics)\n</code></pre>"},{"location":"features/background-task-scheduling/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\ud83d\udd27 Dependency Injection - Service registration patterns</li> <li>\ud83d\udce8 Event Sourcing - Event-driven architecture</li> <li>\ud83d\udd04 Reactive Programming - Stream processing</li> <li>\u26a1 Redis Cache Repository - Distributed caching</li> <li>\ud83c\udf10 HTTP Service Client - External service integration</li> </ul> <p>The background task scheduling system provides enterprise-grade capabilities for building resilient, scalable microservices with complex workflow requirements. By leveraging APScheduler with Redis persistence and reactive processing, Mario's Pizzeria can handle high-volume operations with confidence and reliability.</p>"},{"location":"features/case-conversion-utilities/","title":"\ud83d\udd04 Case Conversion Utilities","text":"<p>The Neuroglia framework provides comprehensive case conversion utilities for seamless data transformation between different naming conventions, enabling smooth integration between frontend frameworks, APIs, and backend services with automatic Pydantic model integration.</p>"},{"location":"features/case-conversion-utilities/#overview","title":"\ud83c\udfaf Overview","text":"<p>Modern applications often need to work with multiple naming conventions simultaneously - JavaScript frontends use camelCase, Python backends use snake_case, and APIs might use kebab-case or PascalCase. The framework's case conversion utilities provide:</p> <ul> <li>Comprehensive Case Conversions: Support for all major naming conventions</li> <li>Pydantic Integration: Automatic model field conversion with CamelModel</li> <li>Dictionary Transformations: Deep conversion of nested data structures</li> <li>String Transformations: Individual string case conversions</li> <li>Preservation of Context: Maintains data integrity during conversions</li> <li>Performance Optimized: Efficient conversion algorithms with caching</li> </ul>"},{"location":"features/case-conversion-utilities/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>graph TB\n    subgraph \"\ud83c\udf55 Mario's Pizzeria Application\"\n        FrontendApp[React Frontend&lt;br/&gt;camelCase]\n        MobileApp[Mobile App&lt;br/&gt;camelCase]\n        ApiLayer[REST API&lt;br/&gt;kebab-case]\n        BackendService[Python Backend&lt;br/&gt;snake_case]\n    end\n\n    subgraph \"\ud83d\udd04 Case Conversion Layer\"\n        CaseConverter[Case Converter]\n        CamelModel[Pydantic CamelModel]\n        DictTransformer[Dictionary Transformer]\n        StringConverter[String Converter]\n    end\n\n    subgraph \"\ud83c\udfaf Conversion Types\"\n        SnakeCase[snake_case]\n        CamelCase[camelCase]\n        PascalCase[PascalCase]\n        KebabCase[kebab-case]\n        ScreamingSnake[SCREAMING_SNAKE]\n    end\n\n    FrontendApp --&gt; CaseConverter\n    MobileApp --&gt; CaseConverter\n    ApiLayer --&gt; CaseConverter\n    BackendService --&gt; CaseConverter\n\n    CaseConverter --&gt; CamelModel\n    CaseConverter --&gt; DictTransformer\n    CaseConverter --&gt; StringConverter\n\n    CamelModel --&gt; SnakeCase\n    CamelModel --&gt; CamelCase\n    DictTransformer --&gt; PascalCase\n    DictTransformer --&gt; KebabCase\n    StringConverter --&gt; ScreamingSnake\n\n    style CaseConverter fill:#e3f2fd\n    style CamelModel fill:#e8f5e8\n    style DictTransformer fill:#fff3e0\n    style StringConverter fill:#f3e5f5</code></pre>"},{"location":"features/case-conversion-utilities/#basic-usage","title":"\ud83d\ude80 Basic Usage","text":""},{"location":"features/case-conversion-utilities/#service-registration","title":"Service Registration","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.utilities.case_conversion import CaseConverter\n\ndef create_app():\n    builder = WebApplicationBuilder()\n\n    # Register case conversion utilities\n    builder.services.add_case_conversion_utilities()\n\n    app = builder.build()\n    return app\n</code></pre>"},{"location":"features/case-conversion-utilities/#string-case-conversions","title":"String Case Conversions","text":"<pre><code>from neuroglia.utilities.case_conversion import CaseConverter\n\nclass MenuItemService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.case_converter = service_provider.get_service(CaseConverter)\n\n    def demonstrate_string_conversions(self):\n        \"\"\"Demonstrate various string case conversions.\"\"\"\n\n        original_field = \"pizza_item_name\"\n\n        # Convert to different case formats\n        conversions = {\n            \"camelCase\": self.case_converter.to_camel_case(original_field),\n            \"PascalCase\": self.case_converter.to_pascal_case(original_field),\n            \"kebab-case\": self.case_converter.to_kebab_case(original_field),\n            \"SCREAMING_SNAKE\": self.case_converter.to_screaming_snake_case(original_field),\n            \"Title Case\": self.case_converter.to_title_case(original_field)\n        }\n\n        print(\"\ud83d\udd04 String Case Conversions:\")\n        print(f\"Original: {original_field}\")\n        for case_name, converted in conversions.items():\n            print(f\"{case_name}: {converted}\")\n\n        return conversions\n\n        # Output:\n        # Original: pizza_item_name\n        # camelCase: pizzaItemName\n        # PascalCase: PizzaItemName\n        # kebab-case: pizza-item-name\n        # SCREAMING_SNAKE: PIZZA_ITEM_NAME\n        # Title Case: Pizza Item Name\n\n    def convert_api_field_names(self, api_response: dict) -&gt; dict:\n        \"\"\"Convert API response field names from kebab-case to snake_case.\"\"\"\n\n        # Example API response with kebab-case fields\n        api_data = {\n            \"menu-item-id\": \"margherita_001\",\n            \"display-name\": \"Margherita Pizza\",\n            \"base-price\": 12.99,\n            \"available-sizes\": [\"small\", \"medium\", \"large\"],\n            \"nutritional-info\": {\n                \"calories-per-slice\": 285,\n                \"total-fat-grams\": 10.4,\n                \"protein-grams\": 12.2\n            }\n        }\n\n        # Convert all keys from kebab-case to snake_case\n        converted_data = self.case_converter.convert_dict_keys(\n            api_data,\n            target_case=\"snake_case\"\n        )\n\n        print(\"\ud83c\udf55 API Field Name Conversion:\")\n        print(f\"Original keys: {list(api_data.keys())}\")\n        print(f\"Converted keys: {list(converted_data.keys())}\")\n\n        return converted_data\n\n        # Result:\n        # {\n        #     \"menu_item_id\": \"margherita_001\",\n        #     \"display_name\": \"Margherita Pizza\",\n        #     \"base_price\": 12.99,\n        #     \"available_sizes\": [\"small\", \"medium\", \"large\"],\n        #     \"nutritional_info\": {\n        #         \"calories_per_slice\": 285,\n        #         \"total_fat_grams\": 10.4,\n        #         \"protein_grams\": 12.2\n        #     }\n        # }\n</code></pre>"},{"location":"features/case-conversion-utilities/#pydantic-camelmodel-integration","title":"\ud83d\udce6 Pydantic CamelModel Integration","text":""},{"location":"features/case-conversion-utilities/#automatic-field-conversion-models","title":"Automatic Field Conversion Models","text":"<pre><code>from neuroglia.utilities.case_conversion import CamelModel\nfrom pydantic import Field\nfrom typing import List, Optional\nfrom datetime import datetime\n\nclass PizzaOrderDto(CamelModel):\n    \"\"\"DTO that automatically converts between camelCase and snake_case.\"\"\"\n\n    order_id: str = Field(..., description=\"Unique order identifier\")\n    customer_name: str = Field(..., description=\"Customer full name\")\n    customer_email: str = Field(..., description=\"Customer email address\")\n    phone_number: Optional[str] = Field(None, description=\"Customer phone number\")\n\n    # Complex nested fields\n    delivery_address: 'DeliveryAddressDto' = Field(..., description=\"Delivery address details\")\n    order_items: List['OrderItemDto'] = Field(..., description=\"List of ordered items\")\n\n    # Calculated fields\n    subtotal_amount: float = Field(..., description=\"Subtotal before tax and delivery\")\n    tax_amount: float = Field(..., description=\"Tax amount\")\n    delivery_fee: float = Field(..., description=\"Delivery fee\")\n    total_amount: float = Field(..., description=\"Total order amount\")\n\n    # Timestamps\n    order_placed_at: datetime = Field(..., description=\"When order was placed\")\n    estimated_delivery_time: datetime = Field(..., description=\"Estimated delivery time\")\n\n    # Status and preferences\n    order_status: str = Field(default=\"pending\", description=\"Current order status\")\n    special_instructions: Optional[str] = Field(None, description=\"Special delivery instructions\")\n    is_rush_order: bool = Field(default=False, description=\"Rush order flag\")\n\nclass DeliveryAddressDto(CamelModel):\n    \"\"\"Delivery address with automatic case conversion.\"\"\"\n\n    street_address: str = Field(..., description=\"Street address\")\n    apartment_number: Optional[str] = Field(None, description=\"Apartment/unit number\")\n    city_name: str = Field(..., description=\"City name\")\n    state_code: str = Field(..., description=\"State/province code\")\n    postal_code: str = Field(..., description=\"ZIP/postal code\")\n    country_code: str = Field(default=\"US\", description=\"Country code\")\n\n    # Location metadata\n    is_business_address: bool = Field(default=False, description=\"Business address flag\")\n    delivery_instructions: Optional[str] = Field(None, description=\"Delivery instructions\")\n\nclass OrderItemDto(CamelModel):\n    \"\"\"Individual order item with case conversion.\"\"\"\n\n    menu_item_id: str = Field(..., description=\"Menu item identifier\")\n    item_name: str = Field(..., description=\"Menu item name\")\n    item_size: str = Field(..., description=\"Size selection\")\n    base_price: float = Field(..., description=\"Base item price\")\n\n    # Customizations\n    selected_toppings: List[str] = Field(default_factory=list, description=\"Selected toppings\")\n    removed_ingredients: List[str] = Field(default_factory=list, description=\"Removed ingredients\")\n    special_requests: Optional[str] = Field(None, description=\"Special preparation requests\")\n\n    # Pricing\n    toppings_price: float = Field(default=0.0, description=\"Additional toppings cost\")\n    item_quantity: int = Field(default=1, description=\"Quantity ordered\")\n    line_item_total: float = Field(..., description=\"Total for this line item\")\n\n# Usage demonstration\nclass OrderProcessingService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.case_converter = service_provider.get_service(CaseConverter)\n\n    def process_frontend_order(self, frontend_data: dict) -&gt; PizzaOrderDto:\n        \"\"\"Process order data from JavaScript frontend (camelCase).\"\"\"\n\n        # Frontend sends data in camelCase\n        frontend_order = {\n            \"orderId\": \"ORD_20241201_001\",\n            \"customerName\": \"Mario Rossi\",\n            \"customerEmail\": \"mario.rossi@email.com\",\n            \"phoneNumber\": \"+1-555-0123\",\n            \"deliveryAddress\": {\n                \"streetAddress\": \"123 Pizza Street\",\n                \"apartmentNumber\": \"Apt 2B\",\n                \"cityName\": \"New York\",\n                \"stateCode\": \"NY\",\n                \"postalCode\": \"10001\",\n                \"isBusinessAddress\": False,\n                \"deliveryInstructions\": \"Ring doorbell twice\"\n            },\n            \"orderItems\": [\n                {\n                    \"menuItemId\": \"margherita_large\",\n                    \"itemName\": \"Margherita Pizza\",\n                    \"itemSize\": \"large\",\n                    \"basePrice\": 18.99,\n                    \"selectedToppings\": [\"extra_cheese\", \"fresh_basil\"],\n                    \"removedIngredients\": [],\n                    \"toppingsPrice\": 3.50,\n                    \"itemQuantity\": 2,\n                    \"lineItemTotal\": 44.98\n                }\n            ],\n            \"subtotalAmount\": 44.98,\n            \"taxAmount\": 3.60,\n            \"deliveryFee\": 2.99,\n            \"totalAmount\": 51.57,\n            \"orderPlacedAt\": \"2024-12-01T14:30:00Z\",\n            \"estimatedDeliveryTime\": \"2024-12-01T15:15:00Z\",\n            \"specialInstructions\": \"Please call when arriving\",\n            \"isRushOrder\": True\n        }\n\n        # CamelModel automatically converts camelCase to snake_case for internal processing\n        order_dto = PizzaOrderDto(**frontend_order)\n\n        print(\"\ud83c\udf55 Order processed from frontend:\")\n        print(f\"Order ID: {order_dto.order_id}\")\n        print(f\"Customer: {order_dto.customer_name}\")\n        print(f\"Items: {len(order_dto.order_items)}\")\n        print(f\"Total: ${order_dto.total_amount}\")\n\n        return order_dto\n\n    def send_to_frontend(self, order: PizzaOrderDto) -&gt; dict:\n        \"\"\"Convert order back to camelCase for frontend response.\"\"\"\n\n        # CamelModel automatically converts snake_case to camelCase for API response\n        frontend_response = order.dict(by_alias=True)  # Uses camelCase aliases\n\n        print(\"\ud83d\udce4 Sending to frontend in camelCase:\")\n        print(f\"Keys: {list(frontend_response.keys())}\")\n\n        return frontend_response\n\n        # Response will have camelCase keys:\n        # {\n        #     \"orderId\": \"ORD_20241201_001\",\n        #     \"customerName\": \"Mario Rossi\",\n        #     \"customerEmail\": \"mario.rossi@email.com\",\n        #     \"deliveryAddress\": {...},\n        #     \"orderItems\": [...],\n        #     \"totalAmount\": 51.57,\n        #     ...\n        # }\n</code></pre>"},{"location":"features/case-conversion-utilities/#dictionary-transformations","title":"\ud83d\udd04 Dictionary Transformations","text":""},{"location":"features/case-conversion-utilities/#deep-nested-structure-conversion","title":"Deep Nested Structure Conversion","text":"<pre><code>from neuroglia.utilities.case_conversion import DictCaseConverter\n\nclass MenuManagementService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.dict_converter = service_provider.get_service(DictCaseConverter)\n\n    def process_complex_menu_data(self):\n        \"\"\"Process complex nested menu data with different case conventions.\"\"\"\n\n        # Complex menu structure from external system (mixed case conventions)\n        external_menu_data = {\n            \"restaurantInfo\": {\n                \"restaurant_name\": \"Mario's Pizzeria\",\n                \"businessHours\": {\n                    \"monday-friday\": {\n                        \"opening_time\": \"11:00\",\n                        \"closingTime\": \"22:00\"\n                    },\n                    \"weekend_hours\": {\n                        \"saturday_opening\": \"12:00\",\n                        \"sunday-closing\": \"21:00\"\n                    }\n                },\n                \"contact-information\": {\n                    \"phone_number\": \"+1-555-PIZZA\",\n                    \"emailAddress\": \"orders@mariospizzeria.com\"\n                }\n            },\n            \"menuCategories\": [\n                {\n                    \"category_id\": \"pizzas\",\n                    \"displayName\": \"Artisan Pizzas\",\n                    \"menu-items\": [\n                        {\n                            \"item_id\": \"margherita_classic\",\n                            \"itemName\": \"Classic Margherita\",\n                            \"basePrice\": 16.99,\n                            \"available-sizes\": {\n                                \"small_size\": {\"price\": 12.99, \"diameter_inches\": 10},\n                                \"mediumSize\": {\"price\": 16.99, \"diameter-inches\": 12},\n                                \"large_option\": {\"price\": 21.99, \"diameter_inches\": 14}\n                            },\n                            \"nutritional-data\": {\n                                \"calories_per_slice\": 285,\n                                \"macroNutrients\": {\n                                    \"total_fat\": 10.4,\n                                    \"saturatedFat\": 4.8,\n                                    \"total-carbs\": 36.2,\n                                    \"protein_content\": 12.2\n                                },\n                                \"allergen-info\": {\n                                    \"contains_gluten\": True,\n                                    \"dairy_products\": True,\n                                    \"nut_free\": True\n                                }\n                            }\n                        }\n                    ]\n                }\n            ]\n        }\n\n        # Convert entire structure to consistent snake_case\n        snake_case_menu = self.dict_converter.convert_nested_dict(\n            external_menu_data,\n            target_case=\"snake_case\",\n            preserve_arrays=True,\n            max_depth=10\n        )\n\n        print(\"\ud83d\udc0d Converted to snake_case:\")\n        self.print_menu_structure(snake_case_menu)\n\n        # Convert to camelCase for frontend API\n        camel_case_menu = self.dict_converter.convert_nested_dict(\n            snake_case_menu,\n            target_case=\"camelCase\",\n            preserve_arrays=True\n        )\n\n        print(\"\ud83d\udc2a Converted to camelCase:\")\n        self.print_menu_structure(camel_case_menu)\n\n        # Convert to kebab-case for URL-friendly slugs\n        kebab_case_menu = self.dict_converter.convert_nested_dict(\n            snake_case_menu,\n            target_case=\"kebab-case\",\n            preserve_arrays=True,\n            key_filter=lambda key: key not in ['item_id', 'category_id']  # Preserve IDs\n        )\n\n        return {\n            \"snake_case\": snake_case_menu,\n            \"camelCase\": camel_case_menu,\n            \"kebab-case\": kebab_case_menu\n        }\n\n    def print_menu_structure(self, menu_data: dict, indent: int = 0):\n        \"\"\"Print menu structure with indentation.\"\"\"\n        for key, value in menu_data.items():\n            if isinstance(value, dict):\n                print(\"  \" * indent + f\"\ud83d\udcc1 {key}:\")\n                self.print_menu_structure(value, indent + 1)\n            elif isinstance(value, list) and value and isinstance(value[0], dict):\n                print(\"  \" * indent + f\"\ud83d\udccb {key}: [{len(value)} items]\")\n            else:\n                print(\"  \" * indent + f\"\ud83d\udcc4 {key}: {type(value).__name__}\")\n</code></pre>"},{"location":"features/case-conversion-utilities/#selective-field-conversion","title":"Selective Field Conversion","text":"<pre><code>class CustomerProfileService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.dict_converter = service_provider.get_service(DictCaseConverter)\n\n    def convert_with_field_mapping(self, customer_data: dict) -&gt; dict:\n        \"\"\"Convert customer data with custom field mappings.\"\"\"\n\n        # Original customer data from CRM system\n        crm_customer_data = {\n            \"customer_id\": \"CUST_001\",\n            \"personalInfo\": {\n                \"firstName\": \"Giuseppe\",\n                \"lastName\": \"Verdi\",\n                \"date_of_birth\": \"1985-03-15\",\n                \"email-address\": \"giuseppe.verdi@email.com\"\n            },\n            \"loyaltyProgram\": {\n                \"membership_level\": \"gold\",\n                \"points_balance\": 1250,\n                \"next-reward-threshold\": 1500\n            },\n            \"orderHistory\": {\n                \"total_orders\": 47,\n                \"favorite-items\": [\"margherita\", \"quattro_stagioni\"],\n                \"average_order_value\": 28.75\n            }\n        }\n\n        # Define custom field mappings\n        field_mappings = {\n            \"firstName\": \"given_name\",\n            \"lastName\": \"family_name\",\n            \"email-address\": \"primary_email\",\n            \"membership_level\": \"loyalty_tier\",\n            \"points_balance\": \"reward_points\",\n            \"next-reward-threshold\": \"next_milestone\",\n            \"favorite-items\": \"preferred_menu_items\",\n            \"average_order_value\": \"avg_purchase_amount\"\n        }\n\n        # Convert with custom mappings and case conversion\n        converted_data = self.dict_converter.convert_with_mapping(\n            crm_customer_data,\n            field_mappings=field_mappings,\n            target_case=\"snake_case\",\n            preserve_structure=True\n        )\n\n        print(\"\ud83d\udc64 Customer Data Conversion:\")\n        print(f\"Original keys: {self.get_all_keys(crm_customer_data)}\")\n        print(f\"Converted keys: {self.get_all_keys(converted_data)}\")\n\n        return converted_data\n\n        # Result:\n        # {\n        #     \"customer_id\": \"CUST_001\",\n        #     \"personal_info\": {\n        #         \"given_name\": \"Giuseppe\",\n        #         \"family_name\": \"Verdi\",\n        #         \"date_of_birth\": \"1985-03-15\",\n        #         \"primary_email\": \"giuseppe.verdi@email.com\"\n        #     },\n        #     \"loyalty_program\": {\n        #         \"loyalty_tier\": \"gold\",\n        #         \"reward_points\": 1250,\n        #         \"next_milestone\": 1500\n        #     },\n        #     \"order_history\": {\n        #         \"total_orders\": 47,\n        #         \"preferred_menu_items\": [\"margherita\", \"quattro_stagioni\"],\n        #         \"avg_purchase_amount\": 28.75\n        #     }\n        # }\n\n    def get_all_keys(self, data: dict, keys=None) -&gt; list:\n        \"\"\"Recursively get all keys from nested dictionary.\"\"\"\n        if keys is None:\n            keys = []\n\n        for key, value in data.items():\n            keys.append(key)\n            if isinstance(value, dict):\n                self.get_all_keys(value, keys)\n\n        return keys\n</code></pre>"},{"location":"features/case-conversion-utilities/#advanced-case-conversion-patterns","title":"\ud83c\udfa8 Advanced Case Conversion Patterns","text":""},{"location":"features/case-conversion-utilities/#api-boundary-conversion","title":"API Boundary Conversion","text":"<pre><code>from neuroglia.mvc import ControllerBase\nfrom neuroglia.utilities.case_conversion import ApiCaseConverter\n\nclass PizzaMenuController(ControllerBase):\n    \"\"\"Controller demonstrating automatic case conversion at API boundaries.\"\"\"\n\n    def __init__(self, service_provider: ServiceProviderBase,\n                 mapper: Mapper, mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n        self.api_converter = service_provider.get_service(ApiCaseConverter)\n\n    @get(\"/menu/{category_id}\")\n    async def get_menu_category(self, category_id: str) -&gt; dict:\n        \"\"\"Get menu category with automatic case conversion for API response.\"\"\"\n\n        # Internal service returns snake_case data\n        internal_menu_data = await self.get_internal_menu_data(category_id)\n\n        # Convert to camelCase for frontend consumption\n        api_response = self.api_converter.convert_for_api_response(\n            internal_menu_data,\n            input_case=\"snake_case\",\n            output_case=\"camelCase\"\n        )\n\n        return api_response\n\n    @post(\"/menu/items\")\n    async def create_menu_item(self, menu_item_data: dict) -&gt; dict:\n        \"\"\"Create menu item with automatic request/response conversion.\"\"\"\n\n        # Frontend sends camelCase data\n        print(f\"\ud83d\udce5 Received from frontend: {list(menu_item_data.keys())}\")\n\n        # Convert to snake_case for internal processing\n        internal_data = self.api_converter.convert_for_internal_processing(\n            menu_item_data,\n            input_case=\"camelCase\",\n            output_case=\"snake_case\"\n        )\n\n        print(f\"\ud83d\udd04 Converted for internal use: {list(internal_data.keys())}\")\n\n        # Process internally (snake_case)\n        created_item = await self.create_internal_menu_item(internal_data)\n\n        # Convert response back to camelCase\n        api_response = self.api_converter.convert_for_api_response(\n            created_item,\n            input_case=\"snake_case\",\n            output_case=\"camelCase\"\n        )\n\n        print(f\"\ud83d\udce4 Sending to frontend: {list(api_response.keys())}\")\n\n        return api_response\n\nclass DatabaseIntegrationService:\n    \"\"\"Service demonstrating database field name conversion.\"\"\"\n\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.case_converter = service_provider.get_service(CaseConverter)\n        self.db_converter = service_provider.get_service(DatabaseCaseConverter)\n\n    async def save_order_with_field_mapping(self, order_data: dict):\n        \"\"\"Save order data with database field name conversion.\"\"\"\n\n        # Application uses snake_case\n        application_order = {\n            \"order_id\": \"ORD_001\",\n            \"customer_name\": \"Mario Rossi\",\n            \"order_total\": 45.99,\n            \"delivery_address\": \"123 Main St\",\n            \"order_status\": \"confirmed\",\n            \"created_at\": datetime.utcnow(),\n            \"estimated_delivery\": datetime.utcnow() + timedelta(minutes=30)\n        }\n\n        # Database uses different naming convention\n        database_field_mapping = {\n            \"order_id\": \"ORDER_ID\",\n            \"customer_name\": \"CUSTOMER_FULL_NAME\",\n            \"order_total\": \"TOTAL_AMOUNT_USD\",\n            \"delivery_address\": \"DELIVERY_ADDR_LINE1\",\n            \"order_status\": \"ORDER_STATUS_CODE\",\n            \"created_at\": \"CREATED_TIMESTAMP\",\n            \"estimated_delivery\": \"EST_DELIVERY_TIME\"\n        }\n\n        # Convert for database insertion\n        database_record = self.db_converter.convert_for_database(\n            application_order,\n            field_mapping=database_field_mapping,\n            target_case=\"SCREAMING_SNAKE_CASE\"\n        )\n\n        print(\"\ud83d\udcbe Database Record:\")\n        for db_field, value in database_record.items():\n            print(f\"  {db_field}: {value}\")\n\n        # Simulate database save\n        await self.save_to_database(database_record)\n\n        return database_record\n</code></pre>"},{"location":"features/case-conversion-utilities/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"features/case-conversion-utilities/#case-conversion-testing","title":"Case Conversion Testing","text":"<pre><code>import pytest\nfrom neuroglia.utilities.case_conversion import CaseConverter, CamelModel\n\nclass TestCaseConversions:\n\n    @pytest.fixture\n    def case_converter(self):\n        return CaseConverter()\n\n    def test_string_case_conversions(self, case_converter):\n        \"\"\"Test various string case conversions.\"\"\"\n\n        test_cases = [\n            # (input, expected_camel, expected_pascal, expected_kebab, expected_snake)\n            (\"hello_world\", \"helloWorld\", \"HelloWorld\", \"hello-world\", \"hello_world\"),\n            (\"getUserName\", \"getUserName\", \"GetUserName\", \"get-user-name\", \"get_user_name\"),\n            (\"XML-HTTP-Request\", \"xmlHttpRequest\", \"XmlHttpRequest\", \"xml-http-request\", \"xml_http_request\"),\n            (\"pizza_item_ID\", \"pizzaItemId\", \"PizzaItemId\", \"pizza-item-id\", \"pizza_item_id\"),\n        ]\n\n        for input_str, expected_camel, expected_pascal, expected_kebab, expected_snake in test_cases:\n            assert case_converter.to_camel_case(input_str) == expected_camel\n            assert case_converter.to_pascal_case(input_str) == expected_pascal\n            assert case_converter.to_kebab_case(input_str) == expected_kebab\n            assert case_converter.to_snake_case(input_str) == expected_snake\n\n    def test_nested_dict_conversion(self, case_converter):\n        \"\"\"Test nested dictionary case conversion.\"\"\"\n\n        input_dict = {\n            \"user_name\": \"Mario\",\n            \"contactInfo\": {\n                \"email_address\": \"mario@test.com\",\n                \"phoneNumber\": \"+1234567890\"\n            },\n            \"orderHistory\": [\n                {\n                    \"order_id\": \"001\",\n                    \"totalAmount\": 25.99\n                }\n            ]\n        }\n\n        # Convert to camelCase\n        camel_result = case_converter.convert_dict_keys(input_dict, \"camelCase\")\n\n        assert \"userName\" in camel_result\n        assert \"contactInfo\" in camel_result\n        assert \"emailAddress\" in camel_result[\"contactInfo\"]\n        assert \"phoneNumber\" in camel_result[\"contactInfo\"]\n        assert \"orderId\" in camel_result[\"orderHistory\"][0]\n        assert \"totalAmount\" in camel_result[\"orderHistory\"][0]\n\n    def test_camel_model_integration(self):\n        \"\"\"Test Pydantic CamelModel integration.\"\"\"\n\n        class TestModel(CamelModel):\n            user_name: str\n            email_address: str\n            phone_number: Optional[str] = None\n\n        # Test with camelCase input\n        camel_data = {\n            \"userName\": \"Mario\",\n            \"emailAddress\": \"mario@test.com\",\n            \"phoneNumber\": \"+1234567890\"\n        }\n\n        model = TestModel(**camel_data)\n\n        # Internal representation uses snake_case\n        assert model.user_name == \"Mario\"\n        assert model.email_address == \"mario@test.com\"\n        assert model.phone_number == \"+1234567890\"\n\n        # Export with camelCase aliases\n        exported = model.dict(by_alias=True)\n        assert \"userName\" in exported\n        assert \"emailAddress\" in exported\n        assert \"phoneNumber\" in exported\n\n    @pytest.mark.parametrize(\"input_case,output_case,input_key,expected_key\", [\n        (\"snake_case\", \"camelCase\", \"pizza_item_name\", \"pizzaItemName\"),\n        (\"camelCase\", \"snake_case\", \"pizzaItemName\", \"pizza_item_name\"),\n        (\"kebab-case\", \"PascalCase\", \"pizza-item-name\", \"PizzaItemName\"),\n        (\"PascalCase\", \"kebab-case\", \"PizzaItemName\", \"pizza-item-name\"),\n    ])\n    def test_parametrized_conversions(self, case_converter, input_case, output_case, input_key, expected_key):\n        \"\"\"Test parametrized case conversions.\"\"\"\n\n        result = case_converter.convert_case(input_key, target_case=output_case)\n        assert result == expected_key\n</code></pre>"},{"location":"features/case-conversion-utilities/#integration-testing","title":"Integration Testing","text":"<pre><code>@pytest.mark.integration\nclass TestCaseConversionIntegration:\n\n    @pytest.fixture\n    def pizza_order_data(self):\n        return {\n            \"orderId\": \"ORD_001\",\n            \"customerName\": \"Mario Rossi\",\n            \"pizzaItems\": [\n                {\n                    \"itemName\": \"Margherita\",\n                    \"basePrice\": 16.99,\n                    \"selectedToppings\": [\"extra_cheese\"]\n                }\n            ],\n            \"deliveryAddress\": {\n                \"streetAddress\": \"123 Pizza St\",\n                \"cityName\": \"New York\"\n            }\n        }\n\n    def test_full_order_processing_flow(self, pizza_order_data):\n        \"\"\"Test complete order processing with case conversions.\"\"\"\n\n        # Simulate frontend -&gt; backend -&gt; database flow\n        converter = CaseConverter()\n\n        # Step 1: Convert from frontend camelCase to internal snake_case\n        internal_data = converter.convert_dict_keys(pizza_order_data, \"snake_case\")\n\n        assert \"order_id\" in internal_data\n        assert \"customer_name\" in internal_data\n        assert \"pizza_items\" in internal_data\n        assert \"delivery_address\" in internal_data\n\n        # Step 2: Process internally (would involve business logic)\n        processed_data = {\n            **internal_data,\n            \"order_status\": \"confirmed\",\n            \"total_amount\": 19.99\n        }\n\n        # Step 3: Convert back to camelCase for API response\n        api_response = converter.convert_dict_keys(processed_data, \"camelCase\")\n\n        assert \"orderId\" in api_response\n        assert \"orderStatus\" in api_response\n        assert \"totalAmount\" in api_response\n\n        # Verify data integrity maintained\n        assert api_response[\"customerName\"] == \"Mario Rossi\"\n        assert api_response[\"totalAmount\"] == 19.99\n</code></pre>"},{"location":"features/case-conversion-utilities/#performance-optimization","title":"\ud83d\udcca Performance Optimization","text":""},{"location":"features/case-conversion-utilities/#caching-and-performance","title":"Caching and Performance","text":"<pre><code>from neuroglia.utilities.case_conversion import CachedCaseConverter\nimport time\nfrom typing import Dict\n\nclass PerformanceOptimizedConverter:\n    \"\"\"High-performance case converter with caching and optimization.\"\"\"\n\n    def __init__(self):\n        self.cached_converter = CachedCaseConverter(cache_size=1000)\n        self.conversion_stats = {\n            \"cache_hits\": 0,\n            \"cache_misses\": 0,\n            \"total_conversions\": 0\n        }\n\n    def benchmark_conversions(self, test_data: Dict[str, any], iterations: int = 1000):\n        \"\"\"Benchmark case conversion performance.\"\"\"\n\n        print(f\"\ud83d\ude80 Performance Benchmark ({iterations} iterations)\")\n\n        # Test without caching\n        start_time = time.time()\n        for _ in range(iterations):\n            converter = CaseConverter()  # New instance each time\n            result = converter.convert_dict_keys(test_data, \"camelCase\")\n\n        uncached_time = time.time() - start_time\n\n        # Test with caching\n        start_time = time.time()\n        for _ in range(iterations):\n            result = self.cached_converter.convert_dict_keys(test_data, \"camelCase\")\n\n        cached_time = time.time() - start_time\n\n        performance_improvement = ((uncached_time - cached_time) / uncached_time) * 100\n\n        print(f\"Without caching: {uncached_time:.4f}s\")\n        print(f\"With caching: {cached_time:.4f}s\")\n        print(f\"Performance improvement: {performance_improvement:.1f}%\")\n        print(f\"Cache hit rate: {self.get_cache_hit_rate():.1f}%\")\n\n        return {\n            \"uncached_time\": uncached_time,\n            \"cached_time\": cached_time,\n            \"improvement_percent\": performance_improvement,\n            \"cache_hit_rate\": self.get_cache_hit_rate()\n        }\n\n    def get_cache_hit_rate(self) -&gt; float:\n        \"\"\"Calculate cache hit rate percentage.\"\"\"\n        total = self.conversion_stats[\"cache_hits\"] + self.conversion_stats[\"cache_misses\"]\n        return (self.conversion_stats[\"cache_hits\"] / total * 100) if total &gt; 0 else 0\n</code></pre>"},{"location":"features/case-conversion-utilities/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\ud83d\udd27 Dependency Injection - Service registration patterns</li> <li>\ud83c\udf10 HTTP Service Client - API request/response transformation</li> <li>\ud83d\udcca Enhanced Model Validation - Model field validation</li> <li>\ud83d\udcc1 Data Access - Database field mapping</li> <li>\ud83d\udce8 CQRS &amp; Mediation - Command/query object conversion</li> </ul> <p>The Case Conversion Utilities provide seamless transformation capabilities that enable Mario's Pizzeria to work with multiple naming conventions across different layers of the application. Through comprehensive conversion support and Pydantic integration, the system maintains data consistency while adapting to various API and framework requirements.</p>"},{"location":"features/cqrs-mediation/","title":"\ufffd CQRS &amp; Mediation","text":"<p>Neuroglia implements Command Query Responsibility Segregation (CQRS) through a powerful mediation pattern that decouples your application logic and promotes clean separation between commands (writes) and queries (reads).</p> <p>Let's explore this using Mario's Pizzeria - where commands handle order placement and cooking, while queries retrieve menus and order status.</p>"},{"location":"features/cqrs-mediation/#overview","title":"\ud83c\udfad Overview","text":"<p>The mediation system provides:</p> <ul> <li>Commands: Operations that modify state (place orders, start cooking)</li> <li>Queries: Operations that retrieve data (get menu, check order status)</li> <li>Events: Notifications of state changes (order placed, pizza ready)</li> <li>Handlers: Process commands, queries, and events</li> <li>Mediator: Routes requests to appropriate handlers</li> <li>Pipeline Behaviors: Cross-cutting concerns (validation, logging, caching)</li> </ul>"},{"location":"features/cqrs-mediation/#core-concepts","title":"\ud83c\udfd7\ufe0f Core Concepts","text":""},{"location":"features/cqrs-mediation/#commands","title":"Commands","text":"<p>Commands represent business intentions that change the pizzeria's state:</p> <pre><code>from dataclasses import dataclass\nfrom typing import List\nfrom decimal import Decimal\nfrom neuroglia.mediation.mediator import Command\nfrom neuroglia.core.operation_result import OperationResult\n\n@dataclass\nclass PizzaItem:\n    \"\"\"A pizza item in an order\"\"\"\n    pizza_id: str\n    size: str  # \"small\", \"medium\", \"large\"\n    toppings: List[str]\n    special_instructions: str = \"\"\n\n@dataclass\nclass PlaceOrderCommand(Command[OperationResult]):\n    \"\"\"Command to place a new pizza order\"\"\"\n    customer_name: str\n    customer_phone: str\n    customer_address: str\n    pizza_items: List[PizzaItem]\n    payment_method: str = \"cash\"\n\n@dataclass\nclass StartCookingCommand(Command[OperationResult]):\n    \"\"\"Command to start cooking an order\"\"\"\n    order_id: str\n    kitchen_staff_id: str\n    estimated_cooking_time_minutes: int\n\n@dataclass\nclass MarkPizzaReadyCommand(Command[OperationResult]):\n    \"\"\"Command to mark a pizza as ready\"\"\"\n    order_id: str\n    pizza_index: int  # Which pizza in the order\n    actual_cooking_time_minutes: int\n\n@dataclass\nclass ProcessPaymentCommand(Command[OperationResult]):\n    \"\"\"Command to process payment for an order\"\"\"\n    order_id: str\n    payment_amount: Decimal\n    payment_method: str\n</code></pre>"},{"location":"features/cqrs-mediation/#queries","title":"Queries","text":"<p>Queries retrieve pizzeria data without side effects:</p> <pre><code>from dataclasses import dataclass\nfrom typing import List, Optional\nfrom decimal import Decimal\nfrom neuroglia.mediation.mediator import Query\n\n@dataclass\nclass GetMenuQuery(Query[OperationResult[List[dict]]]):\n    \"\"\"Query to get the pizzeria menu with pricing\"\"\"\n    category: Optional[str] = None  # \"pizza\", \"appetizers\", \"drinks\"\n    include_seasonal: bool = True\n\n@dataclass\nclass GetOrderStatusQuery(Query[OperationResult]):\n    \"\"\"Query to get current order status\"\"\"\n    order_id: str\n\n@dataclass\nclass GetOrdersByCustomerQuery(Query[OperationResult[List[dict]]]):\n    \"\"\"Query to get customer's order history\"\"\"\n    customer_phone: str\n    limit: int = 10\n\n@dataclass\nclass GetKitchenQueueQuery(Query[OperationResult[List[dict]]]):\n    \"\"\"Query to get current kitchen queue for staff\"\"\"\n    status: str = \"cooking\"  # \"pending\", \"cooking\", \"ready\"\n\n@dataclass\nclass GetDailySalesQuery(Query[OperationResult]):\n    \"\"\"Query to get daily sales report\"\"\"\n    date: str  # ISO date format\n    include_details: bool = False\n</code></pre>"},{"location":"features/cqrs-mediation/#events","title":"Events","text":"<p>Events represent important business occurrences in the pizzeria:</p> <pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom neuroglia.data.abstractions import DomainEvent\n\n```python\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom neuroglia.data.abstractions import DomainEvent\n\n@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    \"\"\"Event raised when a customer places an order\"\"\"\n    order_id: str\n    customer_name: str\n    customer_phone: str\n    total_amount: Decimal\n    estimated_ready_time: datetime\n\n@dataclass\nclass CookingStartedEvent(DomainEvent):\n    \"\"\"Event raised when kitchen starts cooking an order\"\"\"\n    order_id: str\n    kitchen_staff_id: str\n    started_at: datetime\n    estimated_completion: datetime\n\n@dataclass\nclass PizzaReadyEvent(DomainEvent):\n    \"\"\"Event raised when a pizza is ready\"\"\"\n    order_id: str\n    pizza_index: int\n    completed_at: datetime\n    actual_cooking_time_minutes: int\n\n@dataclass\nclass OrderCompletedEvent(DomainEvent):\n    \"\"\"Event raised when entire order is ready for pickup/delivery\"\"\"\n    order_id: str\n    completed_at: datetime\n    total_cooking_time_minutes: int\n</code></pre>"},{"location":"features/cqrs-mediation/#handlers","title":"\ud83c\udfaa Handlers","text":""},{"location":"features/cqrs-mediation/#command-handlers","title":"Command Handlers","text":"<p>Command handlers process business operations and enforce business rules:</p> <pre><code>from neuroglia.mediation.mediator import CommandHandler\nfrom neuroglia.mapping.mapper import Mapper\nfrom neuroglia.data.abstractions import Repository\nfrom src.domain.order import Order\nfrom src.domain.pizza import Pizza\n\nclass PlaceOrderCommandHandler(CommandHandler[PlaceOrderCommand, OperationResult]):\n    \"\"\"Handles pizza order placement\"\"\"\n\n    def __init__(self,\n                 order_repository: Repository[Order, str],\n                 pizza_repository: Repository[Pizza, str],\n                 mapper: Mapper,\n                 payment_service: IPaymentService,\n                 notification_service: INotificationService):\n        self.order_repository = order_repository\n        self.pizza_repository = pizza_repository\n        self.mapper = mapper\n        self.payment_service = payment_service\n        self.notification_service = notification_service\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult:\n        try:\n            # Validate pizza availability\n            pizza_ids = [item.pizza_id for item in command.pizza_items]\n            available_pizzas = await self.pizza_repository.get_by_ids_async(pizza_ids)\n\n            if len(available_pizzas) != len(pizza_ids):\n                return self.bad_request(\"One or more pizzas are not available\")\n\n            # Calculate total amount\n            total_amount = Decimal(\"0\")\n            order_pizzas = []\n\n            for item in command.pizza_items:\n                base_pizza = next(p for p in available_pizzas if p.id == item.pizza_id)\n\n                # Create customized pizza\n                customized_pizza = Pizza(\n                    id=\"\",  # Will be generated\n                    name=base_pizza.name,\n                    size=item.size,\n                    base_price=self._get_size_price(base_pizza.base_price, item.size),\n                    toppings=item.toppings,\n                    special_instructions=item.special_instructions\n                )\n\n                order_pizzas.append(customized_pizza)\n                total_amount += customized_pizza.total_price\n\n            # Create order domain entity\n            order = Order.create(\n                customer_name=command.customer_name,\n                customer_phone=command.customer_phone,\n                customer_address=command.customer_address,\n                pizzas=order_pizzas,\n                payment_method=command.payment_method\n            )\n\n            # Save order\n            await self.order_repository.save_async(order)\n\n            # Send confirmation\n            await self.notification_service.send_order_confirmation(\n                order.customer_phone,\n                order.id,\n                order.estimated_ready_time\n            )\n\n            return self.created({\n                \"order_id\": order.id,\n                \"total_amount\": str(total_amount),\n                \"estimated_ready_time\": order.estimated_ready_time.isoformat()\n            })\n\n        except Exception as e:\n            return self.internal_server_error(f\"Failed to place order: {str(e)}\")\n\n    def _get_size_price(self, base_price: Decimal, size: str) -&gt; Decimal:\n        multipliers = {\"small\": Decimal(\"0.8\"), \"medium\": Decimal(\"1.0\"), \"large\": Decimal(\"1.3\")}\n        return base_price * multipliers.get(size, Decimal(\"1.0\"))\n\nclass StartCookingCommandHandler(CommandHandler[StartCookingCommand, OperationResult]):\n    \"\"\"Handles starting to cook an order\"\"\"\n\n    def __init__(self,\n                 order_repository: Repository[Order, str],\n                 kitchen_service: IKitchenService):\n        self.order_repository = order_repository\n        self.kitchen_service = kitchen_service\n\n    async def handle_async(self, command: StartCookingCommand) -&gt; OperationResult:\n        # Get the order\n        order = await self.order_repository.get_by_id_async(command.order_id)\n        if not order:\n            return self.not_found(\"Order not found\")\n\n        # Validate business rules\n        if order.status != \"pending\":\n            return self.bad_request(f\"Cannot start cooking order in {order.status} status\")\n\n        # Start cooking\n        order.start_cooking(\n            kitchen_staff_id=command.kitchen_staff_id,\n            estimated_cooking_time=command.estimated_cooking_time_minutes\n        )\n\n        # Save updated order\n        await self.order_repository.save_async(order)\n\n        # Update kitchen queue\n        await self.kitchen_service.add_to_cooking_queue(order)\n\n        return self.ok({\"message\": f\"Started cooking order {order.id}\"})\n</code></pre> <pre><code>from neuroglia.mediation.mediator import QueryHandler\n\nclass GetMenuQueryHandler(QueryHandler[GetMenuQuery, OperationResult[List[dict]]]):\n    \"\"\"Handles menu retrieval queries\"\"\"\n\n    def __init__(self,\n                 pizza_repository: Repository[Pizza, str],\n                 cache_service: ICacheService):\n        self.pizza_repository = pizza_repository\n        self.cache_service = cache_service\n\n    async def handle_async(self, query: GetMenuQuery) -&gt; OperationResult[List[dict]]:\n        # Check cache first for performance\n        cache_key = f\"menu:{query.category}:{query.include_seasonal}\"\n        cached_menu = await self.cache_service.get_async(cache_key)\n\n        if cached_menu:\n            return self.ok(cached_menu)\n\n        # Get all pizzas\n        pizzas = await self.pizza_repository.get_all_async()\n\n        # Filter by category if specified\n        if query.category:\n            pizzas = [p for p in pizzas if p.category == query.category]\n\n        # Filter seasonal items if not requested\n        if not query.include_seasonal:\n            pizzas = [p for p in pizzas if not p.is_seasonal]\n\n        # Build menu response\n        menu_items = []\n        for pizza in pizzas:\n            menu_items.append({\n                \"id\": pizza.id,\n                \"name\": pizza.name,\n                \"description\": pizza.description,\n                \"base_price\": str(pizza.base_price),\n                \"category\": pizza.category,\n                \"preparation_time_minutes\": pizza.preparation_time_minutes,\n                \"available_sizes\": [\"small\", \"medium\", \"large\"],\n                \"available_toppings\": pizza.available_toppings,\n                \"is_seasonal\": pizza.is_seasonal\n            })\n\n        # Cache for 15 minutes\n        await self.cache_service.set_async(cache_key, menu_items, expire_minutes=15)\n\n        return self.ok(menu_items)\n\nclass GetOrderStatusQueryHandler(QueryHandler[GetOrderStatusQuery, OperationResult]):\n    \"\"\"Handles order status queries\"\"\"\n\n    def __init__(self, order_repository: Repository[Order, str]):\n        self.order_repository = order_repository\n\n    async def handle_async(self, query: GetOrderStatusQuery) -&gt; OperationResult:\n        order = await self.order_repository.get_by_id_async(query.order_id)\n\n        if not order:\n            return self.not_found(f\"Order {query.order_id} not found\")\n\n        return self.ok({\n            \"order_id\": order.id,\n            \"status\": order.status,\n            \"customer_name\": order.customer_name,\n            \"order_time\": order.order_time.isoformat(),\n            \"estimated_ready_time\": order.estimated_ready_time.isoformat() if order.estimated_ready_time else None,\n            \"total_amount\": str(order.total_amount),\n            \"pizzas\": [\n                {\n                    \"name\": pizza.name,\n                    \"size\": pizza.size,\n                    \"toppings\": pizza.toppings,\n                    \"status\": \"cooking\" if order.status == \"cooking\" else \"pending\"\n                }\n                for pizza in order.pizzas\n            ]\n        })\n\nclass GetKitchenQueueQueryHandler(QueryHandler[GetKitchenQueueQuery, OperationResult[List[dict]]]):\n    \"\"\"Handles kitchen queue queries for staff\"\"\"\n\n    def __init__(self, order_repository: Repository[Order, str]):\n        self.order_repository = order_repository\n\n    async def handle_async(self, query: GetKitchenQueueQuery) -&gt; OperationResult[List[dict]]:\n        # Get orders by status\n        orders = await self.order_repository.get_by_status_async(query.status)\n\n        # Sort by order time (FIFO)\n        orders.sort(key=lambda o: o.order_time)\n\n        queue_items = []\n        for order in orders:\n            queue_items.append({\n                \"order_id\": order.id,\n                \"customer_name\": order.customer_name,\n                \"order_time\": order.order_time.isoformat(),\n                \"estimated_ready_time\": order.estimated_ready_time.isoformat() if order.estimated_ready_time else None,\n                \"pizza_count\": len(order.pizzas),\n                \"total_prep_time\": sum(p.preparation_time_minutes for p in order.pizzas),\n                \"special_instructions\": [p.special_instructions for p in order.pizzas if p.special_instructions]\n            })\n\n        return self.ok(queue_items)\n</code></pre> <pre><code>from neuroglia.mediation.mediator import EventHandler\n\nclass OrderPlacedEventHandler(EventHandler[OrderPlacedEvent]):\n    \"\"\"Handles order placed events - sends notifications\"\"\"\n\n    def __init__(self,\n                 notification_service: INotificationService,\n                 analytics_service: IAnalyticsService):\n        self.notification_service = notification_service\n        self.analytics_service = analytics_service\n\n    async def handle_async(self, event: OrderPlacedEvent):\n        # Send SMS confirmation to customer\n        await self.notification_service.send_sms(\n            phone=event.customer_phone,\n            message=f\"Order {event.order_id[:8]} confirmed! \"\n                   f\"Total: ${event.total_amount}. \"\n                   f\"Ready by: {event.estimated_ready_time.strftime('%H:%M')}\"\n        )\n\n        # Notify kitchen staff\n        await self.notification_service.notify_kitchen_staff(\n            f\"New order {event.order_id[:8]} from {event.customer_name}\"\n        )\n\n        # Track order analytics\n        await self.analytics_service.track_order_placed(\n            order_id=event.order_id,\n            amount=event.total_amount,\n            customer_type=\"returning\" if await self._is_returning_customer(event.customer_phone) else \"new\"\n        )\n\nclass CookingStartedEventHandler(EventHandler[CookingStartedEvent]):\n    \"\"\"Handles cooking started events - updates displays\"\"\"\n\n    def __init__(self,\n                 kitchen_display_service: IKitchenDisplayService,\n                 performance_service: IPerformanceService):\n        self.kitchen_display_service = kitchen_display_service\n        self.performance_service = performance_service\n\n    async def handle_async(self, event: CookingStartedEvent):\n        # Update kitchen display board\n        await self.kitchen_display_service.update_order_status(\n            order_id=event.order_id,\n            status=\"cooking\",\n            staff_id=event.kitchen_staff_id,\n            started_at=event.started_at\n        )\n\n        # Track kitchen performance metrics\n        await self.performance_service.track_cooking_start(\n            order_id=event.order_id,\n            staff_id=event.kitchen_staff_id,\n            estimated_completion=event.estimated_completion\n        )\n\nclass PizzaReadyEventHandler(EventHandler[PizzaReadyEvent]):\n    \"\"\"Handles pizza ready events - manages completion tracking\"\"\"\n\n    def __init__(self,\n                 order_service: IOrderService,\n                 performance_service: IPerformanceService):\n        self.order_service = order_service\n        self.performance_service = performance_service\n\n    async def handle_async(self, event: PizzaReadyEvent):\n        # Check if entire order is complete\n        order_complete = await self.order_service.check_if_order_complete(event.order_id)\n\n        if order_complete:\n            # Mark order as ready and notify customer\n            await self.order_service.mark_order_ready(event.order_id)\n\n        # Track pizza cooking performance\n        await self.performance_service.track_pizza_completion(\n            order_id=event.order_id,\n            pizza_index=event.pizza_index,\n            actual_time=event.actual_cooking_time_minutes,\n            completed_at=event.completed_at\n        )\n\nclass OrderCompletedEventHandler(EventHandler[OrderCompletedEvent]):\n    \"\"\"Handles order completion - final notifications\"\"\"\n\n    def __init__(self,\n                 notification_service: INotificationService,\n                 loyalty_service: ILoyaltyService):\n        self.notification_service = notification_service\n        self.loyalty_service = loyalty_service\n\n    async def handle_async(self, event: OrderCompletedEvent):\n        # Get order details for notification\n        order = await self.order_repository.get_by_id_async(event.order_id)\n\n        # Notify customer order is ready\n        await self.notification_service.send_sms(\n            phone=order.customer_phone,\n            message=f\"Your order {event.order_id[:8]} is ready for pickup! \ud83c\udf55\"\n        )\n\n        # Update loyalty points\n        await self.loyalty_service.award_points(\n            customer_phone=order.customer_phone,\n            order_amount=order.total_amount\n        )\n</code></pre>"},{"location":"features/cqrs-mediation/#mediator-usage-in-marios-pizzeria","title":"\ud83d\ude80 Mediator Usage in Mario's Pizzeria","text":""},{"location":"features/cqrs-mediation/#configuration","title":"Configuration","text":"<p>Configure the mediator in your pizzeria application startup:</p> <pre><code>from neuroglia.hosting.web import EnhancedWebApplicationBuilder\nfrom neuroglia.mediation.mediator import Mediator\n\ndef create_pizzeria_app():\n    builder = EnhancedWebApplicationBuilder()\n\n    # Configure mediator with pizzeria handler modules\n    Mediator.configure(builder, [\n        \"src.application.commands\",  # PlaceOrderCommandHandler, StartCookingCommandHandler\n        \"src.application.queries\",   # GetMenuQueryHandler, GetOrderStatusQueryHandler\n        \"src.application.events\"     # OrderPlacedEventHandler, CookingStartedEventHandler\n    ])\n\n    # Register repositories\n    builder.services.add_scoped(lambda: FileRepository(Order, \"data\"))\n    builder.services.add_scoped(lambda: FileRepository(Pizza, \"data\"))\n\n    return builder.build()\n</code></pre>"},{"location":"features/cqrs-mediation/#in-controllers","title":"In Controllers","text":"<p>Use the mediator in your pizzeria API controllers:</p> <pre><code>from neuroglia.mvc.controller_base import ControllerBase\nfrom classy_fastapi.decorators import get, post, put\n\nclass OrdersController(ControllerBase):\n    \"\"\"Pizza orders API controller\"\"\"\n\n    @post(\"/\", response_model=dict, status_code=201)\n    async def place_order(self, order_request: dict) -&gt; dict:\n        # Create command from request\n        command = PlaceOrderCommand(\n            customer_name=order_request[\"customer_name\"],\n            customer_phone=order_request[\"customer_phone\"],\n            customer_address=order_request[\"customer_address\"],\n            pizza_items=[PizzaItem(**item) for item in order_request[\"pizza_items\"]],\n            payment_method=order_request.get(\"payment_method\", \"cash\")\n        )\n\n        # Execute through mediator\n        result = await self.mediator.execute_async(command)\n\n        # Process result and return\n        return self.process(result)\n\n    @get(\"/{order_id}/status\", response_model=dict)\n    async def get_order_status(self, order_id: str) -&gt; dict:\n        # Create query\n        query = GetOrderStatusQuery(order_id=order_id)\n\n        # Execute through mediator\n        result = await self.mediator.execute_async(query)\n\n        # Process result and return\n        return self.process(result)\n\n    @put(\"/{order_id}/cook\", response_model=dict)\n    async def start_cooking(self, order_id: str, cooking_request: dict) -&gt; dict:\n        # Create command\n        command = StartCookingCommand(\n            order_id=order_id,\n            kitchen_staff_id=cooking_request[\"kitchen_staff_id\"],\n            estimated_cooking_time_minutes=cooking_request[\"estimated_cooking_time_minutes\"]\n        )\n\n        # Execute through mediator\n        result = await self.mediator.execute_async(command)\n\n        # Process result and return\n        return self.process(result)\n\nclass MenuController(ControllerBase):\n    \"\"\"Pizza menu API controller\"\"\"\n\n    @get(\"/\", response_model=List[dict])\n    async def get_menu(self, category: Optional[str] = None, include_seasonal: bool = True) -&gt; List[dict]:\n        # Create query\n        query = GetMenuQuery(\n            category=category,\n            include_seasonal=include_seasonal\n        )\n\n        # Execute through mediator\n        result = await self.mediator.execute_async(query)\n\n        # Process result and return\n        return self.process(result)\n\n    @get(\"/\", response_model=List[UserDto])\n    async def search_users(self,\n                          search: str = \"\",\n                          page: int = 1,\n</code></pre>"},{"location":"features/cqrs-mediation/#in-services","title":"In Services","text":"<p>Use the mediator in pizzeria application services:</p> <pre><code>class PizzeriaService:\n    \"\"\"High-level pizzeria operations service\"\"\"\n\n    def __init__(self, mediator: Mediator):\n        self.mediator = mediator\n\n    async def process_online_order(self, order_data: OnlineOrderData) -&gt; dict:\n        \"\"\"Process a complete online order workflow\"\"\"\n\n        # 1. Place the order\n        place_command = PlaceOrderCommand(\n            customer_name=order_data.customer_name,\n            customer_phone=order_data.customer_phone,\n            customer_address=order_data.customer_address,\n            pizza_items=order_data.pizza_items,\n            payment_method=order_data.payment_method\n        )\n\n        place_result = await self.mediator.execute_async(place_command)\n\n        if not place_result.is_success:\n            raise OrderPlacementException(place_result.error_message)\n\n        # 2. Process payment if needed\n        if order_data.payment_method != \"cash\":\n            payment_command = ProcessPaymentCommand(\n                order_id=place_result.data[\"order_id\"],\n                payment_amount=Decimal(place_result.data[\"total_amount\"]),\n                payment_method=order_data.payment_method\n            )\n\n            payment_result = await self.mediator.execute_async(payment_command)\n\n            if not payment_result.is_success:\n                raise PaymentException(payment_result.error_message)\n\n        return place_result.data\n\n    async def get_customer_order_history(self, customer_phone: str) -&gt; List[dict]:\n        \"\"\"Get customer's order history\"\"\"\n        query = GetOrdersByCustomerQuery(\n            customer_phone=customer_phone,\n            limit=10\n        )\n\n        result = await self.mediator.execute_async(query)\n\n        if result.is_success:\n            return result.data\n        else:\n            raise OrderHistoryException(result.error_message)\n</code></pre>"},{"location":"features/cqrs-mediation/#advanced-patterns","title":"\ud83c\udfad Advanced Patterns","text":""},{"location":"features/cqrs-mediation/#pipeline-behaviors","title":"Pipeline Behaviors","text":"<p>Add cross-cutting concerns through pipeline behaviors:</p> <pre><code>from neuroglia.mediation.mediator import PipelineBehavior\nfrom neuroglia.core.operation_result import OperationResult\nfrom typing import Type, Any\nimport logging\nimport time\n\nclass OrderValidationBehavior(PipelineBehavior):\n    \"\"\"Validates pizza orders before processing\"\"\"\n\n    async def handle_async(self, request, next_handler):\n        # Only validate order commands\n        if isinstance(request, PlaceOrderCommand):\n            # Business rule: minimum order amount\n            if not request.pizza_items:\n                return OperationResult.validation_error(\"Order must contain at least one pizza\")\n\n            # Business rule: validate customer info\n            if not request.customer_phone or len(request.customer_phone) &lt; 10:\n                return OperationResult.validation_error(\"Valid phone number required\")\n\n        # Continue to next behavior/handler\n        return await next_handler()\n\nclass KitchenOperationsLoggingBehavior(PipelineBehavior):\n    \"\"\"Logs all kitchen operations for compliance\"\"\"\n\n    def __init__(self, logger: logging.Logger):\n        self.logger = logger\n\n    async def handle_async(self, request, next_handler):\n        request_name = type(request).__name__\n\n        # Log kitchen-related commands with extra detail\n        if isinstance(request, (StartCookingCommand, MarkPizzaReadyCommand)):\n            self.logger.info(f\"Kitchen: {request_name} - Order: {request.order_id}\")\n        else:\n            self.logger.info(f\"Processing {request_name}\")\n\n        start_time = time.time()\n\n        try:\n            result = await next_handler()\n            duration = time.time() - start_time\n\n            self.logger.info(f\"Completed {request_name} in {duration:.3f}s\")\n            return result\n        except Exception as ex:\n            self.logger.error(f\"Failed {request_name}: {ex}\")\n            raise\n\nclass PerformanceMonitoringBehavior(PipelineBehavior):\n    \"\"\"Monitors command/query performance\"\"\"\n\n    def __init__(self, performance_service: IPerformanceService):\n        self.performance_service = performance_service\n\n    async def handle_async(self, request, next_handler):\n        start_time = time.time()\n        request_type = type(request).__name__\n\n        try:\n            result = await next_handler()\n            duration = time.time() - start_time\n\n            # Track performance metrics\n            await self.performance_service.record_operation(\n                operation_type=request_type,\n                duration_seconds=duration,\n                success=True\n            )\n\n            return result\n        except Exception as ex:\n            duration = time.time() - start_time\n\n            await self.performance_service.record_operation(\n                operation_type=request_type,\n                duration_seconds=duration,\n                success=False,\n                error=str(ex)\n            )\n\n            raise\n\n# Register behaviors in application startup\ndef configure_pipeline_behaviors(builder: EnhancedWebApplicationBuilder):\n    \"\"\"Configure pipeline behaviors for pizzeria operations\"\"\"\n\n    builder.services.add_pipeline_behavior(OrderValidationBehavior)\n    builder.services.add_pipeline_behavior(KitchenOperationsLoggingBehavior)\n    builder.services.add_pipeline_behavior(PerformanceMonitoringBehavior)\n</code></pre>"},{"location":"features/cqrs-mediation/#caching-behavior","title":"Caching Behavior","text":"<p>Cache query results for better performance:</p> <pre><code>class QueryCachingBehavior(PipelineBehavior):\n    \"\"\"Caches query results based on query type and parameters\"\"\"\n\n    def __init__(self, cache_service: ICacheService):\n        self.cache_service = cache_service\n\n    async def handle_async(self, request, next_handler):\n        # Only cache queries, not commands\n        if not isinstance(request, Query):\n            return await next_handler()\n\n        # Generate cache key\n        cache_key = self._generate_cache_key(request)\n\n        # Try to get from cache first\n        cached_result = await self.cache_service.get_async(cache_key)\n        if cached_result:\n            return cached_result\n\n        # Execute query\n        result = await next_handler()\n\n        # Cache successful results\n        if result.is_success:\n            # Different TTL based on query type\n            ttl_minutes = self._get_cache_ttl(type(request))\n            await self.cache_service.set_async(cache_key, result, expire_minutes=ttl_minutes)\n\n        return result\n\n    def _generate_cache_key(self, request: Query) -&gt; str:\n        \"\"\"Generate cache key from request\"\"\"\n        request_type = type(request).__name__\n        request_data = str(request.__dict__)\n        return f\"query:{request_type}:{hash(request_data)}\"\n\n    def _get_cache_ttl(self, query_type: Type) -&gt; int:\n        \"\"\"Get cache TTL based on query type\"\"\"\n        cache_strategies = {\n            GetMenuQuery: 30,           # Menu changes infrequently\n            GetOrderStatusQuery: 1,     # Order status changes frequently\n            GetKitchenQueueQuery: 2,    # Kitchen queue changes regularly\n            GetDailySalesQuery: 60      # Sales data can be cached longer\n        }\n        return cache_strategies.get(query_type, 5)  # Default 5 minutes\n</code></pre>"},{"location":"features/cqrs-mediation/#transaction-behavior","title":"Transaction Behavior","text":"<p>Wrap commands in database transactions for consistency:</p> <pre><code>class TransactionBehavior(PipelineBehavior):\n    \"\"\"Wraps commands in database transactions\"\"\"\n\n    def __init__(self, unit_of_work: IUnitOfWork):\n        self.unit_of_work = unit_of_work\n\n    async def handle_async(self, request, next_handler):\n        # Only apply to commands\n        if not isinstance(request, Command):\n            return await next_handler()\n\n        async with self.unit_of_work.begin_transaction():\n            try:\n                result = await next_handler()\n                await self.unit_of_work.commit()\n                return result\n            except Exception:\n                await self.unit_of_work.rollback()\n                raise\n</code></pre>"},{"location":"features/cqrs-mediation/#caching-behavior_1","title":"Caching Behavior","text":"<p>Cache query results:</p> <pre><code>class CachingBehavior(PipelineBehavior):\n    \"\"\"Caches query results\"\"\"\n\n    def __init__(self, cache_service: ICacheService):\n        self.cache_service = cache_service\n\n    async def handle_async(self, request, next_handler):\n        # Only cache queries\n        if not isinstance(request, Query):\n            return await next_handler()\n\n        # Generate cache key\n        cache_key = f\"{type(request).__name__}:{hash(str(request))}\"\n\n        # Try to get from cache\n        cached_result = await self.cache_service.get_async(cache_key)\n        if cached_result:\n            return cached_result\n\n        # Execute query\n        result = await next_handler()\n\n        # Cache successful results\n        if result.is_success:\n            await self.cache_service.set_async(cache_key, result, expiry=timedelta(minutes=5))\n\n        return result\n</code></pre>"},{"location":"features/cqrs-mediation/#domain-events","title":"\ud83c\udfdb\ufe0f Domain Events","text":""},{"location":"features/cqrs-mediation/#publishing-events","title":"Publishing Events","text":"<p>Publish domain events from entities or handlers:</p> <pre><code>class User(AggregateRoot[str]):\n    def create(self, email: str, first_name: str, last_name: str):\n        # Apply business rules\n        self.email = email\n        self.first_name = first_name\n        self.last_name = last_name\n        self.created_at = datetime.now(timezone.utc)\n\n        # Raise domain event\n        self.raise_event(UserCreatedEvent(\n            user_id=self.id,\n            email=self.email,\n            created_at=self.created_at\n        ))\n\nclass CreateUserCommandHandler(CommandHandler[CreateUserCommand, OperationResult[UserDto]]):\n    async def handle_async(self, command: CreateUserCommand) -&gt; OperationResult[UserDto]:\n        # Create user (events are raised automatically)\n        user = User.create(command.email, command.first_name, command.last_name)\n\n        # Save user (this will publish the events)\n        await self.user_repository.add_async(user)\n\n        return self.created(self.mapper.map(user, UserDto))\n</code></pre>"},{"location":"features/cqrs-mediation/#event-dispatching","title":"Event Dispatching","text":"<p>Events are automatically dispatched to registered handlers:</p> <pre><code># Multiple handlers can listen to the same event\nclass UserCreatedEventHandler(EventHandler[UserCreatedEvent]):\n    async def handle_async(self, event: UserCreatedEvent):\n        # Handle audit logging\n        pass\n\nclass WelcomeEmailHandler(EventHandler[UserCreatedEvent]):\n    async def handle_async(self, event: UserCreatedEvent):\n        # Send welcome email\n        pass\n\nclass AnalyticsHandler(EventHandler[UserCreatedEvent]):\n    async def handle_async(self, event: UserCreatedEvent):\n        # Track user registration\n        pass\n</code></pre>"},{"location":"features/cqrs-mediation/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"features/cqrs-mediation/#testing-handlers","title":"Testing Handlers","text":"<p>Test handlers in isolation:</p> <pre><code>import pytest\nfrom unittest.mock import Mock\n\n@pytest.mark.asyncio\nasync def test_create_user_command_handler():\n    # Arrange\n    mock_repository = Mock()\n    mock_mapper = Mock()\n    mock_password_service = Mock()\n    mock_email_service = Mock()\n\n    handler = CreateUserCommandHandler(\n        mock_repository,\n        mock_mapper,\n        mock_password_service,\n        mock_email_service\n```python\nclass OrderTransactionBehavior(PipelineBehavior):\n    \"\"\"Wraps order commands in database transactions\"\"\"\n\n    def __init__(self, unit_of_work: IUnitOfWork):\n        self.unit_of_work = unit_of_work\n\n    async def handle_async(self, request, next_handler):\n        # Only apply transactions to commands that modify data\n        if not isinstance(request, (PlaceOrderCommand, StartCookingCommand, ProcessPaymentCommand)):\n            return await next_handler()\n\n        async with self.unit_of_work.begin_transaction():\n            try:\n                result = await next_handler()\n\n                if result.is_success:\n                    await self.unit_of_work.commit_async()\n                else:\n                    await self.unit_of_work.rollback_async()\n\n                return result\n            except Exception:\n                await self.unit_of_work.rollback_async()\n                raise\n</code></pre>"},{"location":"features/cqrs-mediation/#testing-cqrs-components","title":"\ud83e\uddea Testing CQRS Components","text":""},{"location":"features/cqrs-mediation/#testing-command-handlers","title":"Testing Command Handlers","text":"<pre><code>import pytest\nfrom unittest.mock import Mock, AsyncMock\nfrom src.application.commands.place_order import PlaceOrderCommandHandler, PlaceOrderCommand, PizzaItem\nfrom src.domain.order import Order\nfrom src.domain.pizza import Pizza\n\n@pytest.mark.asyncio\nasync def test_place_order_command_handler_success():\n    # Arrange\n    mock_order_repo = Mock()\n    mock_pizza_repo = Mock()\n    mock_mapper = Mock()\n    mock_payment_service = Mock()\n    mock_notification_service = Mock()\n\n    handler = PlaceOrderCommandHandler(\n        order_repository=mock_order_repo,\n        pizza_repository=mock_pizza_repo,\n        mapper=mock_mapper,\n        payment_service=mock_payment_service,\n        notification_service=mock_notification_service\n    )\n\n    # Mock pizza availability\n    margherita = Pizza(\"margherita\", \"Margherita\", \"medium\", Decimal(\"12.99\"), [], 15)\n    mock_pizza_repo.get_by_ids_async.return_value = [margherita]\n\n    command = PlaceOrderCommand(\n        customer_name=\"John Doe\",\n        customer_phone=\"555-0123\",\n        customer_address=\"123 Pizza St\",\n        pizza_items=[PizzaItem(pizza_id=\"margherita\", size=\"large\", toppings=[\"extra_cheese\"])],\n        payment_method=\"cash\"\n    )\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n    assert \"order_id\" in result.data\n    assert \"total_amount\" in result.data\n    mock_order_repo.save_async.assert_called_once()\n    mock_notification_service.send_order_confirmation.assert_called_once()\n\n@pytest.mark.asyncio\nasync def test_place_order_command_handler_pizza_not_available():\n    # Arrange\n    handler = PlaceOrderCommandHandler(Mock(), Mock(), Mock(), Mock(), Mock())\n    handler.pizza_repository.get_by_ids_async.return_value = []  # No pizzas available\n\n    command = PlaceOrderCommand(\n        customer_name=\"John Doe\",\n        customer_phone=\"555-0123\",\n        customer_address=\"123 Pizza St\",\n        pizza_items=[PizzaItem(pizza_id=\"nonexistent\", size=\"large\", toppings=[])],\n        payment_method=\"cash\"\n    )\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert not result.is_success\n    assert \"not available\" in result.error_message\n</code></pre>"},{"location":"features/cqrs-mediation/#testing-query-handlers","title":"Testing Query Handlers","text":"<pre><code>@pytest.mark.asyncio\nasync def test_get_menu_query_handler():\n    # Arrange\n    mock_pizza_repo = Mock()\n    mock_cache_service = Mock()\n\n    handler = GetMenuQueryHandler(\n        pizza_repository=mock_pizza_repo,\n        cache_service=mock_cache_service\n    )\n\n    # Mock cache miss\n    mock_cache_service.get_async.return_value = None\n\n    # Mock pizza data\n    pizzas = [\n        Pizza(\"margherita\", \"Margherita\", \"medium\", Decimal(\"12.99\"), [], 15),\n        Pizza(\"pepperoni\", \"Pepperoni\", \"medium\", Decimal(\"15.99\"), [\"pepperoni\"], 18)\n    ]\n    mock_pizza_repo.get_all_async.return_value = pizzas\n\n    query = GetMenuQuery(category=None, include_seasonal=True)\n\n    # Act\n    result = await handler.handle_async(query)\n\n    # Assert\n    assert result.is_success\n    assert len(result.data) == 2\n    assert result.data[0][\"name\"] == \"Margherita\"\n    mock_cache_service.set_async.assert_called_once()\n</code></pre>"},{"location":"features/cqrs-mediation/#integration-testing","title":"Integration Testing","text":"<p>Test the complete pizzeria workflow:</p> <pre><code>@pytest.mark.integration\n@pytest.mark.asyncio\nasync def test_complete_order_workflow():\n    \"\"\"Test the complete order placement and cooking workflow\"\"\"\n\n    # Arrange - use test client with real mediator\n    test_client = TestClient(create_pizzeria_app())\n\n    # Create order\n    order_data = {\n        \"customer_name\": \"John Doe\",\n        \"customer_phone\": \"555-0123\",\n        \"customer_address\": \"123 Pizza St\",\n        \"pizza_items\": [\n            {\n                \"pizza_id\": \"margherita\",\n                \"size\": \"large\",\n                \"toppings\": [\"extra_cheese\"],\n                \"special_instructions\": \"Extra crispy\"\n            }\n        ],\n        \"payment_method\": \"cash\"\n    }\n\n    # Act &amp; Assert - Place order\n    response = test_client.post(\"/api/orders\", json=order_data)\n    assert response.status_code == 201\n\n    order_result = response.json()\n    order_id = order_result[\"order_id\"]\n    assert \"total_amount\" in order_result\n    assert \"estimated_ready_time\" in order_result\n\n    # Act &amp; Assert - Check order status\n    status_response = test_client.get(f\"/api/orders/{order_id}/status\")\n    assert status_response.status_code == 200\n\n    status_data = status_response.json()\n    assert status_data[\"status\"] == \"pending\"\n    assert status_data[\"customer_name\"] == \"John Doe\"\n\n    # Act &amp; Assert - Start cooking (kitchen staff)\n    cooking_data = {\n        \"kitchen_staff_id\": \"staff_001\",\n        \"estimated_cooking_time_minutes\": 20\n    }\n\n    cook_response = test_client.put(f\"/api/orders/{order_id}/cook\", json=cooking_data)\n    assert cook_response.status_code == 200\n\n    # Verify status changed\n    final_status = test_client.get(f\"/api/orders/{order_id}/status\")\n    assert final_status.json()[\"status\"] == \"cooking\"\n</code></pre>"},{"location":"features/cqrs-mediation/#best-practices-for-pizzeria-cqrs","title":"\ud83d\ude80 Best Practices for Pizzeria CQRS","text":""},{"location":"features/cqrs-mediation/#1-single-responsibility","title":"1. Single Responsibility","text":"<p>Each command/query should have a single, well-defined business purpose:</p> <pre><code># \u2705 Good - Single responsibility\nclass PlaceOrderCommand: pass          # Only handles order placement\nclass UpdateOrderAddressCommand: pass  # Only updates delivery address\nclass StartCookingCommand: pass        # Only starts cooking process\n\n# \u274c Avoid - Multiple responsibilities\nclass ManageOrderCommand:              # Too broad, unclear purpose\n    action: str  # \"place\", \"update\", \"cook\" - violates SRP\n</code></pre>"},{"location":"features/cqrs-mediation/#2-immutable-commands-and-queries","title":"2. Immutable Commands and Queries","text":"<p>Make your requests immutable using dataclasses with frozen=True:</p> <pre><code>@dataclass(frozen=True)\nclass PlaceOrderCommand(Command[OperationResult]):\n    \"\"\"Immutable command - cannot be modified after creation\"\"\"\n    customer_name: str\n    customer_phone: str\n    pizza_items: tuple[PizzaItem, ...]  # Use tuple for immutability\n\n    def __post_init__(self):\n        # Validate on construction\n        if not self.pizza_items:\n            raise ValueError(\"Order must contain at least one pizza\")\n</code></pre>"},{"location":"features/cqrs-mediation/#3-rich-domain-events","title":"3. Rich Domain Events","text":"<p>Include all relevant context in domain events for downstream processing:</p> <pre><code>@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    \"\"\"Rich event with all necessary context\"\"\"\n    order_id: str\n    customer_name: str\n    customer_phone: str\n    customer_address: str\n    total_amount: Decimal\n    estimated_ready_time: datetime\n    pizza_details: List[dict]  # Full pizza specifications\n    payment_method: str\n    order_source: str  # \"web\", \"phone\", \"mobile_app\"\n\n    # This rich context allows event handlers to:\n    # - Send personalized notifications\n    # - Update analytics with customer segments\n    # - Route orders to appropriate kitchen stations\n    # - Integrate with delivery systems\n</code></pre>"},{"location":"features/cqrs-mediation/#4-query-optimization","title":"4. Query Optimization","text":"<p>Design queries for specific UI needs to avoid over-fetching:</p> <pre><code># \u2705 Optimized for kitchen display\nclass GetKitchenQueueQuery(Query):\n    status: str = \"cooking\"\n    include_special_instructions: bool = True\n    max_items: int = 10\n\n# \u2705 Optimized for customer mobile app\nclass GetOrderSummaryQuery(Query):\n    order_id: str\n    include_pizza_details: bool = False  # Customer doesn't need full specs\n    include_estimated_time: bool = True\n\n# \u2705 Optimized for management dashboard\nclass GetSalesAnalyticsQuery(Query):\n    date_range: DateRange\n    group_by: str  # \"hour\", \"day\", \"pizza_type\"\n    include_trends: bool = True\n</code></pre>"},{"location":"features/cqrs-mediation/#5-error-handling-strategy","title":"5. Error Handling Strategy","text":"<p>Provide meaningful error messages for different audiences:</p> <pre><code>class PlaceOrderCommandHandler(CommandHandler):\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult:\n        try:\n            # Business validation\n            if not await self._validate_business_hours():\n                return self.bad_request(\n                    \"Sorry, we're closed! Kitchen hours are 11 AM - 10 PM\"\n                )\n\n            if not await self._validate_delivery_area(command.customer_address):\n                return self.bad_request(\n                    \"We don't deliver to that area. Please try pickup instead.\"\n                )\n\n            # Process order...\n\n        except PaymentDeclinedException:\n            return self.bad_request(\n                \"Payment was declined. Please try a different payment method.\"\n            )\n        except KitchenOverloadedException:\n            return self.service_unavailable(\n                \"Kitchen is at capacity. Estimated wait time is 45 minutes.\"\n            )\n        except Exception as ex:\n            # Log technical details but return user-friendly message\n            self.logger.error(f\"Order placement failed: {ex}\")\n            return self.internal_server_error(\n                \"Sorry, we're having technical difficulties. Please try again.\"\n            )\n</code></pre>"},{"location":"features/cqrs-mediation/#key-benefits","title":"\ud83c\udfaf Key Benefits","text":"<p>Using CQRS with Neuroglia in Mario's Pizzeria provides:</p> <p>\u2705 Clear Business Intent - Commands like <code>PlaceOrderCommand</code> clearly express business operations \u2705 Scalable Read Models - Optimize queries for kitchen displays, customer apps, and reports \u2705 Event-Driven Integration - Events enable loose coupling between order, kitchen, and notification systems \u2705 Testable Components - Each handler can be unit tested in isolation \u2705 Cross-Cutting Concerns - Pipeline behaviors handle validation, logging, and caching consistently \u2705 Business Rule Enforcement - Domain logic is centralized in command handlers</p>"},{"location":"features/cqrs-mediation/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Build Mario's Pizzeria step-by-step</li> <li>Dependency Injection - Service registration and lifetime management</li> <li>Data Access - Repository patterns and persistence</li> <li>MVC Controllers - API endpoints and request handling</li> <li>Resilient Handler Discovery - Robust handler registration for mixed codebases   class DeactivateUserCommand: pass</li> </ul>"},{"location":"features/cqrs-mediation/#avoid-multiple-responsibilities","title":"Avoid - Multiple responsibilities","text":"<p>class ManageUserCommand: pass # Too broad</p> <pre><code>### 2. Immutable Requests\n\nMake commands and queries immutable:\n\n```python\n# Good - Immutable\n@dataclass(frozen=True)\nclass CreateUserCommand:\n    email: str\n    first_name: str\n    last_name: str\n\n# Avoid - Mutable\nclass CreateUserCommand:\n    def __init__(self):\n        self.email = None\n        self.first_name = None\n</code></pre>"},{"location":"features/cqrs-mediation/#3-rich-domain-models","title":"3. Rich Domain Models","text":"<p>Use domain events to decouple side effects:</p> <pre><code># Good - Domain events\nclass User:\n    def activate(self):\n        self.is_active = True\n        self.raise_event(UserActivatedEvent(self.id))\n\n# Avoid - Direct coupling\nclass User:\n    def activate(self, email_service: IEmailService):\n        self.is_active = True\n        email_service.send_activation_email(self.email)  # Tight coupling\n</code></pre>"},{"location":"features/cqrs-mediation/#4-validation","title":"4. Validation","text":"<p>Validate inputs at the right level:</p> <pre><code># Domain validation (business rules)\nclass CreateUserCommand:\n    def validate(self) -&gt; ValidationResult:\n        errors = []\n        if not self.email or '@' not in self.email:\n            errors.append(\"Valid email is required\")\n        return ValidationResult(errors)\n\n# Input validation (format/required fields)\nclass CreateUserDto:\n    email: str = Field(..., regex=r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$')\n    first_name: str = Field(..., min_length=1, max_length=50)\n</code></pre>"},{"location":"features/cqrs-mediation/#5-error-handling","title":"5. Error Handling","text":"<p>Use consistent error handling patterns:</p> <pre><code>class CreateUserCommandHandler(CommandHandler):\n    async def handle_async(self, command: CreateUserCommand) -&gt; OperationResult[UserDto]:\n        try:\n            # Business logic\n            user = await self.create_user(command)\n            return self.created(user)\n\n        except EmailAlreadyExistsException:\n            return self.conflict(\"Email already exists\")\n        except InvalidEmailException:\n            return self.bad_request(\"Invalid email format\")\n        except Exception as ex:\n            return self.internal_error(f\"Failed to create user: {ex}\")\n</code></pre>"},{"location":"features/cqrs-mediation/#related-documentation_1","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Basic CQRS usage</li> <li>Architecture Guide - How CQRS fits in the architecture</li> <li>Dependency Injection - DI with handlers</li> <li>Data Access - Repositories and units of work</li> <li>Event Handling - Domain events and integration events</li> </ul>"},{"location":"features/data-access/","title":"\ud83c\udf55 Data Access","text":"<p>Neuroglia provides a flexible data access layer that supports multiple storage backends through a unified repository pattern for Mario's Pizzeria. From storing pizza orders in files to managing kitchen workflows with event sourcing, the framework adapts to your pizzeria's needs.</p> <p>Let's explore how to store orders, manage inventory, and track kitchen operations using different persistence strategies.</p>"},{"location":"features/data-access/#overview","title":"\ud83c\udfaf Overview","text":"<p>The pizzeria data access system provides:</p> <ul> <li>Repository Pattern: Unified interface for orders, pizzas, and customer data</li> <li>Multiple Storage Backends: File-based (development), MongoDB (production), Event Store (kitchen events)</li> <li>Event Sourcing: Complete order lifecycle tracking with EventStoreDB</li> <li>CQRS Support: Separate read models for menus and write models for orders</li> <li>Query Abstractions: Find orders by status, customer, or time period</li> <li>Unit of Work: Transaction management across order processing</li> </ul>"},{"location":"features/data-access/#core-abstractions","title":"\ud83c\udfd7\ufe0f Core Abstractions","text":""},{"location":"features/data-access/#repository-interface-for-pizzeria-entities","title":"Repository Interface for Pizzeria Entities","text":"<p>The base repository interface defines standard CRUD operations for pizzeria data:</p> <pre><code>from abc import ABC, abstractmethod\nfrom typing import Generic, TypeVar, List, Optional\nfrom datetime import datetime, date\n\nTEntity = TypeVar('TEntity')\nTKey = TypeVar('TKey')\n\nclass Repository(Generic[TEntity, TKey], ABC):\n    \"\"\"Base repository interface for pizzeria entities\"\"\"\n\n    @abstractmethod\n    async def get_by_id_async(self, id: TKey) -&gt; Optional[TEntity]:\n        \"\"\"Get entity by ID (order, pizza, customer)\"\"\"\n        pass\n\n    @abstractmethod\n    async def save_async(self, entity: TEntity) -&gt; None:\n        \"\"\"Save entity (create or update)\"\"\"\n        pass\n\n    @abstractmethod\n    async def delete_async(self, id: TKey) -&gt; None:\n        \"\"\"Delete entity by ID\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_all_async(self) -&gt; List[TEntity]:\n        \"\"\"Get all entities\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_async(self, predicate) -&gt; List[TEntity]:\n        \"\"\"Find entities matching predicate\"\"\"\n        pass\n\n# Pizzeria-specific repository interfaces\nclass IOrderRepository(Repository[Order, str], ABC):\n    \"\"\"Order-specific repository operations\"\"\"\n\n    @abstractmethod\n    async def get_by_customer_phone_async(self, phone: str) -&gt; List[Order]:\n        \"\"\"Get orders by customer phone number\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_by_status_async(self, status: str) -&gt; List[Order]:\n        \"\"\"Get orders by status (pending, cooking, ready, delivered)\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_by_date_range_async(self, start_date: date, end_date: date) -&gt; List[Order]:\n        \"\"\"Get orders within date range for reports\"\"\"\n        pass\n\nclass IPizzaRepository(Repository[Pizza, str], ABC):\n    \"\"\"Pizza menu repository operations\"\"\"\n\n    @abstractmethod\n    async def get_by_category_async(self, category: str) -&gt; List[Pizza]:\n        \"\"\"Get pizzas by category (signature, specialty, custom)\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_available_async(self) -&gt; List[Pizza]:\n        \"\"\"Get only available pizzas (not sold out)\"\"\"\n        pass\n</code></pre> <pre><code>from neuroglia.data.abstractions import Queryable\nfrom typing import Callable\nfrom decimal import Decimal\n\nclass QueryablePizzeriaRepository(Repository[TEntity, TKey], Queryable[TEntity]):\n    \"\"\"Repository with advanced querying for pizzeria analytics\"\"\"\n\n    async def where(self, predicate: Callable[[TEntity], bool]) -&gt; List[TEntity]:\n        \"\"\"Filter pizzeria entities by predicate\"\"\"\n        pass\n\n    async def order_by_desc(self, selector: Callable[[TEntity], any]) -&gt; List[TEntity]:\n        \"\"\"Order entities in descending order\"\"\"\n        pass\n\n    async def group_by(self, selector: Callable[[TEntity], any]) -&gt; dict:\n        \"\"\"Group entities for analytics\"\"\"\n        pass\n\n# Example: Advanced order queries\nclass ExtendedOrderRepository(IOrderRepository, QueryablePizzeriaRepository[Order, str]):\n    \"\"\"Order repository with advanced analytics queries\"\"\"\n\n    async def get_top_customers_async(self, limit: int = 10) -&gt; List[dict]:\n        \"\"\"Get top customers by order count\"\"\"\n        orders = await self.get_all_async()\n        customer_counts = {}\n\n        for order in orders:\n            phone = order.customer_phone\n            customer_counts[phone] = customer_counts.get(phone, 0) + 1\n\n        # Sort and limit\n        top_customers = sorted(customer_counts.items(), key=lambda x: x[1], reverse=True)[:limit]\n\n        return [{\"phone\": phone, \"order_count\": count} for phone, count in top_customers]\n\n    async def get_revenue_by_date_async(self, start_date: date, end_date: date) -&gt; List[dict]:\n        \"\"\"Get daily revenue within date range\"\"\"\n        orders = await self.get_by_date_range_async(start_date, end_date)\n        daily_revenue = {}\n\n        for order in orders:\n            order_date = order.order_time.date()\n            if order_date not in daily_revenue:\n                daily_revenue[order_date] = Decimal('0')\n            daily_revenue[order_date] += order.total_amount\n\n        return [{\"date\": date, \"revenue\": revenue} for date, revenue in sorted(daily_revenue.items())]\n</code></pre>"},{"location":"features/data-access/#file-based-storage-for-development","title":"\ud83d\udcc1 File-Based Storage for Development","text":""},{"location":"features/data-access/#file-repository-implementation","title":"File Repository Implementation","text":"<p>Perfect for development and testing of Mario's Pizzeria:</p> <pre><code>import json\nimport os\nfrom pathlib import Path\nfrom typing import List, Optional, Callable\nfrom datetime import datetime, date\n\nclass FileRepository(Repository[TEntity, TKey]):\n    \"\"\"File-based repository using JSON storage\"\"\"\n\n    def __init__(self, entity_type: type, data_dir: str = \"data\"):\n        self.entity_type = entity_type\n        self.entity_name = entity_type.__name__.lower()\n        self.data_dir = Path(data_dir)\n        self.entity_dir = self.data_dir / self.entity_name\n\n        # Ensure directories exist\n        self.entity_dir.mkdir(parents=True, exist_ok=True)\n\n    async def get_by_id_async(self, id: TKey) -&gt; Optional[TEntity]:\n        \"\"\"Get entity from JSON file\"\"\"\n        file_path = self.entity_dir / f\"{id}.json\"\n\n        if not file_path.exists():\n            return None\n\n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                data = json.load(f)\n                return self._dict_to_entity(data)\n        except Exception as e:\n            raise StorageException(f\"Failed to load {self.entity_name} {id}: {e}\")\n\n    async def save_async(self, entity: TEntity) -&gt; None:\n        \"\"\"Save entity to JSON file\"\"\"\n        file_path = self.entity_dir / f\"{entity.id}.json\"\n\n        try:\n            data = self._entity_to_dict(entity)\n            with open(file_path, 'w', encoding='utf-8') as f:\n                json.dump(data, f, indent=2, default=self._json_serializer, ensure_ascii=False)\n        except Exception as e:\n            raise StorageException(f\"Failed to save {self.entity_name} {entity.id}: {e}\")\n\n    async def delete_async(self, id: TKey) -&gt; None:\n        \"\"\"Delete entity JSON file\"\"\"\n        file_path = self.entity_dir / f\"{id}.json\"\n        if file_path.exists():\n            file_path.unlink()\n\n    async def get_all_async(self) -&gt; List[TEntity]:\n        \"\"\"Get all entities from JSON files\"\"\"\n        entities = []\n\n        for file_path in self.entity_dir.glob(\"*.json\"):\n            try:\n                with open(file_path, 'r', encoding='utf-8') as f:\n                    data = json.load(f)\n                    entity = self._dict_to_entity(data)\n                    entities.append(entity)\n            except Exception as e:\n                print(f\"Warning: Failed to load {file_path}: {e}\")\n                continue\n\n        return entities\n\n    async def find_async(self, predicate: Callable[[TEntity], bool]) -&gt; List[TEntity]:\n        \"\"\"Find entities matching predicate\"\"\"\n        all_entities = await self.get_all_async()\n        return [entity for entity in all_entities if predicate(entity)]\n\n    def _entity_to_dict(self, entity: TEntity) -&gt; dict:\n        \"\"\"Convert entity to dictionary for JSON serialization\"\"\"\n        if hasattr(entity, '__dict__'):\n            return entity.__dict__.copy()\n        elif hasattr(entity, '_asdict'):\n            return entity._asdict()\n        else:\n            raise ValueError(f\"Cannot serialize entity of type {type(entity)}\")\n\n    def _dict_to_entity(self, data: dict) -&gt; TEntity:\n        \"\"\"Convert dictionary back to entity\"\"\"\n        return self.entity_type(**data)\n\n    def _json_serializer(self, obj):\n        \"\"\"Handle special types in JSON serialization\"\"\"\n        if isinstance(obj, (datetime, date)):\n            return obj.isoformat()\n        elif hasattr(obj, '__dict__'):\n            return obj.__dict__\n        else:\n            return str(obj)\n\n# Pizzeria-specific file repositories\nclass FileOrderRepository(FileRepository[Order, str], IOrderRepository):\n    \"\"\"File-based order repository for development\"\"\"\n\n    def __init__(self, data_dir: str = \"data\"):\n        super().__init__(Order, data_dir)\n\n    async def get_by_customer_phone_async(self, phone: str) -&gt; List[Order]:\n        \"\"\"Get orders by customer phone\"\"\"\n        return await self.find_async(lambda order: order.customer_phone == phone)\n\n    async def get_by_status_async(self, status: str) -&gt; List[Order]:\n        \"\"\"Get orders by status\"\"\"\n        return await self.find_async(lambda order: order.status == status)\n\n    async def get_by_date_range_async(self, start_date: date, end_date: date) -&gt; List[Order]:\n        \"\"\"Get orders within date range\"\"\"\n        return await self.find_async(lambda order:\n            start_date &lt;= order.order_time.date() &lt;= end_date)\n\nclass FilePizzaRepository(FileRepository[Pizza, str], IPizzaRepository):\n    \"\"\"File-based pizza repository for menu management\"\"\"\n\n    def __init__(self, data_dir: str = \"data\"):\n        super().__init__(Pizza, data_dir)\n\n    async def get_by_category_async(self, category: str) -&gt; List[Pizza]:\n        \"\"\"Get pizzas by category\"\"\"\n        return await self.find_async(lambda pizza: pizza.category == category)\n\n    async def get_available_async(self) -&gt; List[Pizza]:\n        \"\"\"Get available pizzas only\"\"\"\n        return await self.find_async(lambda pizza: pizza.is_available)\n</code></pre>"},{"location":"features/data-access/#mongodb-repository-for-pizzeria","title":"MongoDB Repository for Pizzeria","text":"<p>Built-in MongoDB repository implementation for production pizzeria:</p> <pre><code>from neuroglia.data.infrastructure.mongo import MongoRepository\nfrom motor.motor_asyncio import AsyncIOMotorClient, AsyncIOMotorDatabase\nfrom bson import ObjectId\nfrom typing import Optional, List, Dict, Any\n\nclass MongoOrderRepository(MongoRepository[Order, str], IOrderRepository):\n    \"\"\"MongoDB repository for pizza orders\"\"\"\n\n    def __init__(self, database: AsyncIOMotorDatabase):\n        super().__init__(database, \"orders\")\n\n    async def get_by_customer_phone_async(self, phone: str) -&gt; List[Order]:\n        \"\"\"Get orders by customer phone with index optimization\"\"\"\n        cursor = self.collection.find({\"customer_phone\": phone}).sort(\"order_time\", -1)\n        documents = await cursor.to_list(length=None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def get_by_status_async(self, status: str) -&gt; List[Order]:\n        \"\"\"Get orders by status for kitchen management\"\"\"\n        cursor = self.collection.find({\"status\": status}).sort(\"order_time\", 1)  # FIFO\n        documents = await cursor.to_list(length=None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def get_by_date_range_async(self, start_date: date, end_date: date) -&gt; List[Order]:\n        \"\"\"Get orders within date range for reporting\"\"\"\n        start_datetime = datetime.combine(start_date, datetime.min.time())\n        end_datetime = datetime.combine(end_date, datetime.max.time())\n\n        cursor = self.collection.find({\n            \"order_time\": {\n                \"$gte\": start_datetime,\n                \"$lte\": end_datetime\n            }\n        }).sort(\"order_time\", 1)\n\n        documents = await cursor.to_list(length=None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def get_kitchen_queue_async(self, statuses: List[str]) -&gt; List[Order]:\n        \"\"\"Get orders in kitchen queue (optimized for kitchen display)\"\"\"\n        cursor = self.collection.find(\n            {\"status\": {\"$in\": statuses}},\n            {\"customer_name\": 1, \"pizzas\": 1, \"order_time\": 1, \"status\": 1, \"estimated_ready_time\": 1}\n        ).sort(\"order_time\", 1)\n\n        documents = await cursor.to_list(length=None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def get_daily_revenue_async(self, target_date: date) -&gt; Dict[str, Any]:\n        \"\"\"Get daily revenue aggregation\"\"\"\n        start_datetime = datetime.combine(target_date, datetime.min.time())\n        end_datetime = datetime.combine(target_date, datetime.max.time())\n\n        pipeline = [\n            {\n                \"$match\": {\n                    \"order_time\": {\"$gte\": start_datetime, \"$lte\": end_datetime},\n                    \"status\": {\"$in\": [\"ready\", \"delivered\"]}  # Only completed orders\n                }\n            },\n            {\n                \"$group\": {\n                    \"_id\": None,\n                    \"total_revenue\": {\"$sum\": \"$total_amount\"},\n                    \"order_count\": {\"$sum\": 1},\n                    \"average_order_value\": {\"$avg\": \"$total_amount\"}\n                }\n            }\n        ]\n\n        result = await self.collection.aggregate(pipeline).to_list(length=1)\n        return result[0] if result else {\"total_revenue\": 0, \"order_count\": 0, \"average_order_value\": 0}\n\n    def _entity_to_document(self, order: Order) -&gt; Dict[str, Any]:\n        \"\"\"Convert order entity to MongoDB document\"\"\"\n        doc = {\n            \"_id\": order.id,\n            \"customer_name\": order.customer_name,\n            \"customer_phone\": order.customer_phone,\n            \"customer_address\": order.customer_address,\n            \"pizzas\": [self._pizza_to_dict(pizza) for pizza in order.pizzas],\n            \"status\": order.status,\n            \"order_time\": order.order_time,\n            \"estimated_ready_time\": order.estimated_ready_time,\n            \"total_amount\": float(order.total_amount),  # MongoDB decimal handling\n            \"payment_method\": order.payment_method\n        }\n        return doc\n\n    def _document_to_entity(self, doc: Dict[str, Any]) -&gt; Order:\n        \"\"\"Convert MongoDB document to order entity\"\"\"\n        return Order(\n            id=doc[\"_id\"],\n            customer_name=doc[\"customer_name\"],\n            customer_phone=doc[\"customer_phone\"],\n            customer_address=doc[\"customer_address\"],\n            pizzas=[self._dict_to_pizza(pizza_dict) for pizza_dict in doc[\"pizzas\"]],\n            status=doc[\"status\"],\n            order_time=doc[\"order_time\"],\n            estimated_ready_time=doc.get(\"estimated_ready_time\"),\n            total_amount=Decimal(str(doc[\"total_amount\"])),\n            payment_method=doc.get(\"payment_method\", \"cash\")\n        )\n\nclass MongoPizzaRepository(MongoRepository[Pizza, str], IPizzaRepository):\n    \"\"\"MongoDB repository for pizza menu management\"\"\"\n\n    def __init__(self, database: AsyncIOMotorDatabase):\n        super().__init__(database, \"pizzas\")\n\n    async def get_by_category_async(self, category: str) -&gt; List[Pizza]:\n        \"\"\"Get pizzas by category with caching optimization\"\"\"\n        cursor = self.collection.find({\"category\": category, \"is_available\": True}).sort(\"name\", 1)\n        documents = await cursor.to_list(length=None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def get_available_async(self) -&gt; List[Pizza]:\n        \"\"\"Get all available pizzas for menu display\"\"\"\n        cursor = self.collection.find({\"is_available\": True}).sort([(\"category\", 1), (\"name\", 1)])\n        documents = await cursor.to_list(length=None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def update_availability_async(self, pizza_id: str, is_available: bool) -&gt; None:\n        \"\"\"Update pizza availability (for sold out items)\"\"\"\n        await self.collection.update_one(\n            {\"_id\": pizza_id},\n            {\"$set\": {\"is_available\": is_available, \"updated_at\": datetime.utcnow()}}\n        )\n\n    def _entity_to_document(self, pizza: Pizza) -&gt; Dict[str, Any]:\n        \"\"\"Convert pizza entity to MongoDB document\"\"\"\n        return {\n            \"_id\": pizza.id,\n            \"name\": pizza.name,\n            \"description\": pizza.description,\n            \"category\": pizza.category,\n            \"base_price\": float(pizza.base_price),\n            \"available_toppings\": pizza.available_toppings,\n            \"preparation_time_minutes\": pizza.preparation_time_minutes,\n            \"is_available\": pizza.is_available,\n            \"is_seasonal\": pizza.is_seasonal,\n            \"created_at\": pizza.created_at,\n            \"updated_at\": datetime.utcnow()\n        }\n</code></pre>"},{"location":"features/data-access/#mongodb-indexes-for-performance","title":"MongoDB Indexes for Performance","text":"<p>Create indexes for pizzeria query patterns:</p> <pre><code># Create indexes for optimal pizzeria query performance\nasync def create_pizzeria_indexes():\n    \"\"\"Create MongoDB indexes for pizzeria collections\"\"\"\n\n    # Order collection indexes\n    await orders_collection.create_index(\"customer_phone\")  # Customer lookup\n    await orders_collection.create_index(\"status\")  # Kitchen filtering\n    await orders_collection.create_index(\"order_time\")  # Chronological ordering\n    await orders_collection.create_index([(\"status\", 1), (\"order_time\", 1)])  # Kitchen queue\n    await orders_collection.create_index([(\"order_time\", -1)])  # Recent orders first\n    await orders_collection.create_index(\"estimated_ready_time\")  # Ready time tracking\n\n    # Pizza collection indexes\n    await pizzas_collection.create_index(\"category\")  # Menu category filtering\n    await pizzas_collection.create_index(\"is_available\")  # Available items only\n    await pizzas_collection.create_index([(\"category\", 1), (\"name\", 1)])  # Sorted menu display\n    await pizzas_collection.create_index(\"is_seasonal\")  # Seasonal items management\n</code></pre>"},{"location":"features/data-access/#repository-registration-with-mongodb","title":"Repository Registration with MongoDB","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\n\ndef create_pizzeria_app():\n    \"\"\"Create Mario's Pizzeria application with MongoDB persistence\"\"\"\n    builder = WebApplicationBuilder()\n\n    # MongoDB configuration\n    mongo_client = AsyncIOMotorClient(\"mongodb://localhost:27017\")\n    database = mongo_client.marios_pizzeria\n\n    # Repository registration\n    builder.services.add_singleton(lambda: database)\n    builder.services.add_scoped(MongoOrderRepository)\n    builder.services.add_scoped(MongoPizzaRepository)\n\n    # Alias interfaces to implementations\n    builder.services.add_scoped(IOrderRepository, lambda sp: sp.get_service(MongoOrderRepository))\n    builder.services.add_scoped(IPizzaRepository, lambda sp: sp.get_service(MongoPizzaRepository))\n\n    app = builder.build()\n    return app\n</code></pre>"},{"location":"features/data-access/#event-sourcing-for-kitchen-workflow","title":"\ud83d\udcca Event Sourcing for Kitchen Workflow","text":""},{"location":"features/data-access/#kitchen-event-store","title":"Kitchen Event Store","text":"<p>Track kitchen workflow with event sourcing patterns:</p> <pre><code>from neuroglia.eventing import DomainEvent\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any\nfrom dataclasses import dataclass\n\n@dataclass\nclass OrderStatusChangedEvent(DomainEvent):\n    \"\"\"Event for tracking order status changes in kitchen\"\"\"\n    order_id: str\n    old_status: str\n    new_status: str\n    changed_by: str\n    change_reason: Optional[str] = None\n    estimated_ready_time: Optional[datetime] = None\n\n@dataclass\nclass PizzaStartedEvent(DomainEvent):\n    \"\"\"Event when pizza preparation begins\"\"\"\n    order_id: str\n    pizza_name: str\n    pizza_index: int\n    started_by: str\n    estimated_completion: datetime\n\n@dataclass\nclass PizzaCompletedEvent(DomainEvent):\n    \"\"\"Event when pizza is finished\"\"\"\n    order_id: str\n    pizza_name: str\n    pizza_index: int\n    completed_by: str\n    actual_completion_time: datetime\n    preparation_duration_minutes: int\n\nclass KitchenWorkflowEventStore:\n    \"\"\"Event store for kitchen workflow tracking\"\"\"\n\n    def __init__(self, event_repository: IEventRepository):\n        self.event_repository = event_repository\n\n    async def record_order_status_change(self,\n                                         order_id: str,\n                                         old_status: str,\n                                         new_status: str,\n                                         changed_by: str,\n                                         change_reason: str = None) -&gt; None:\n        \"\"\"Record order status changes for kitchen analytics\"\"\"\n        event = OrderStatusChangedEvent(\n            order_id=order_id,\n            old_status=old_status,\n            new_status=new_status,\n            changed_by=changed_by,\n            change_reason=change_reason,\n            estimated_ready_time=self._calculate_ready_time(new_status)\n        )\n\n        await self.event_repository.save_event_async(event)\n\n    async def record_pizza_started(self,\n                                   order_id: str,\n                                   pizza_name: str,\n                                   pizza_index: int,\n                                   started_by: str) -&gt; None:\n        \"\"\"Record when pizza preparation begins\"\"\"\n        estimated_completion = datetime.now(timezone.utc) + timedelta(\n            minutes=self._get_pizza_prep_time(pizza_name)\n        )\n\n        event = PizzaStartedEvent(\n            order_id=order_id,\n            pizza_name=pizza_name,\n            pizza_index=pizza_index,\n            started_by=started_by,\n            estimated_completion=estimated_completion\n        )\n\n        await self.event_repository.save_event_async(event)\n\n    async def record_pizza_completed(self,\n                                     order_id: str,\n                                     pizza_name: str,\n                                     pizza_index: int,\n                                     completed_by: str,\n                                     start_time: datetime) -&gt; None:\n        \"\"\"Record when pizza is completed\"\"\"\n        completion_time = datetime.now(timezone.utc)\n        duration_minutes = int((completion_time - start_time).total_seconds() / 60)\n\n        event = PizzaCompletedEvent(\n            order_id=order_id,\n            pizza_name=pizza_name,\n            pizza_index=pizza_index,\n            completed_by=completed_by,\n            actual_completion_time=completion_time,\n            preparation_duration_minutes=duration_minutes\n        )\n\n        await self.event_repository.save_event_async(event)\n\n    async def get_kitchen_performance_metrics(self, date_range: tuple[date, date]) -&gt; Dict[str, Any]:\n        \"\"\"Get kitchen performance analytics from events\"\"\"\n        start_date, end_date = date_range\n\n        # Query events within date range\n        events = await self.event_repository.get_events_by_date_range_async(start_date, end_date)\n\n        # Calculate metrics\n        pizza_completion_events = [e for e in events if isinstance(e, PizzaCompletedEvent)]\n        status_change_events = [e for e in events if isinstance(e, OrderStatusChangedEvent)]\n\n        return {\n            \"total_pizzas_completed\": len(pizza_completion_events),\n            \"average_prep_time_minutes\": self._calculate_average_prep_time(pizza_completion_events),\n            \"peak_hours\": self._calculate_peak_hours(status_change_events),\n            \"order_completion_rate\": self._calculate_completion_rate(status_change_events),\n            \"staff_performance\": self._calculate_staff_performance(pizza_completion_events)\n        }\n</code></pre> <pre><code>from neuroglia.data import Repository\nfrom typing import List, Dict, Any\nimport json\nfrom pathlib import Path\nfrom datetime import datetime\n\nclass FileEventRepository(Repository[DomainEvent, str]):\n    \"\"\"File-based event repository for development and testing\"\"\"\n\n    def __init__(self, events_directory: str = \"data/events\"):\n        super().__init__()\n        self.events_directory = Path(events_directory)\n        self.events_directory.mkdir(parents=True, exist_ok=True)\n\n    async def save_event_async(self, event: DomainEvent) -&gt; None:\n        \"\"\"Save event to JSON file organized by date\"\"\"\n        event_date = event.occurred_at.date()\n        date_directory = self.events_directory / event_date.strftime(\"%Y-%m-%d\")\n        date_directory.mkdir(exist_ok=True)\n\n        event_file = date_directory / f\"{event.id}.json\"\n\n        event_data = {\n            \"id\": event.id,\n            \"event_type\": event.__class__.__name__,\n            \"occurred_at\": event.occurred_at.isoformat(),\n            \"data\": self._serialize_event_data(event)\n        }\n\n        async with aiofiles.open(event_file, 'w') as f:\n            await f.write(json.dumps(event_data, indent=2))\n\n    async def get_events_by_date_range_async(self,\n                                             start_date: date,\n                                             end_date: date) -&gt; List[DomainEvent]:\n        \"\"\"Get events within date range\"\"\"\n        events = []\n        current_date = start_date\n\n        while current_date &lt;= end_date:\n            date_directory = self.events_directory / current_date.strftime(\"%Y-%m-%d\")\n\n            if date_directory.exists():\n                for event_file in date_directory.glob(\"*.json\"):\n                    async with aiofiles.open(event_file, 'r') as f:\n                        event_data = json.loads(await f.read())\n                        event = self._deserialize_event(event_data)\n                        if event:\n                            events.append(event)\n\n            current_date += timedelta(days=1)\n\n        return sorted(events, key=lambda e: e.occurred_at)\n</code></pre>"},{"location":"features/data-access/#mongodb-event-store","title":"MongoDB Event Store","text":"<p>Production event store with aggregation capabilities:</p> <pre><code>from neuroglia.data.infrastructure.mongo import MongoRepository\nfrom motor.motor_asyncio import AsyncIOMotorDatabase\n\nclass MongoEventRepository(MongoRepository[DomainEvent, str]):\n    \"\"\"MongoDB event repository for production event sourcing\"\"\"\n\n    def __init__(self, database: AsyncIOMotorDatabase):\n        super().__init__(database, \"events\")\n\n    async def save_event_async(self, event: DomainEvent) -&gt; None:\n        \"\"\"Save event with automatic indexing\"\"\"\n        document = {\n            \"_id\": event.id,\n            \"event_type\": event.__class__.__name__,\n            \"occurred_at\": event.occurred_at,\n            \"data\": self._serialize_event_data(event),\n            \"version\": 1,\n            \"metadata\": {\n                \"correlation_id\": getattr(event, 'correlation_id', None),\n                \"causation_id\": getattr(event, 'causation_id', None)\n            }\n        }\n\n        await self.collection.insert_one(document)\n\n    async def get_kitchen_timeline_events(self,\n                                          order_id: str,\n                                          limit: int = 100) -&gt; List[DomainEvent]:\n        \"\"\"Get chronological timeline of kitchen events for an order\"\"\"\n        cursor = self.collection.find(\n            {\n                \"event_type\": {\"$in\": [\"OrderStatusChangedEvent\", \"PizzaStartedEvent\", \"PizzaCompletedEvent\"]},\n                \"data.order_id\": order_id\n            }\n        ).sort(\"occurred_at\", 1).limit(limit)\n\n        documents = await cursor.to_list(length=limit)\n        return [self._deserialize_event(doc) for doc in documents]\n\n    async def get_performance_aggregation(self,\n                                          start_date: datetime,\n                                          end_date: datetime) -&gt; Dict[str, Any]:\n        \"\"\"Get aggregated kitchen performance metrics\"\"\"\n        pipeline = [\n            {\n                \"$match\": {\n                    \"occurred_at\": {\"$gte\": start_date, \"$lte\": end_date},\n                    \"event_type\": \"PizzaCompletedEvent\"\n                }\n            },\n            {\n                \"$group\": {\n                    \"_id\": \"$data.pizza_name\",\n                    \"total_pizzas\": {\"$sum\": 1},\n                    \"avg_prep_time\": {\"$avg\": \"$data.preparation_duration_minutes\"},\n                    \"min_prep_time\": {\"$min\": \"$data.preparation_duration_minutes\"},\n                    \"max_prep_time\": {\"$max\": \"$data.preparation_duration_minutes\"}\n                }\n            },\n            {\n                \"$sort\": {\"total_pizzas\": -1}\n            }\n        ]\n\n        results = await self.collection.aggregate(pipeline).to_list(length=None)\n        return {\n            \"pizza_performance\": results,\n            \"reporting_period\": {\n                \"start\": start_date.isoformat(),\n                \"end\": end_date.isoformat()\n            }\n        }\n</code></pre> <pre><code>from neuroglia.data import IQueryableRepository\nfrom typing import List, Dict, Any, Optional\nfrom datetime import datetime, date, timedelta\n\nclass IAnalyticsRepository(IQueryableRepository[Order, str]):\n    \"\"\"Enhanced queryable interface for pizzeria analytics\"\"\"\n\n    async def get_revenue_by_period_async(self,\n                                          period: str,  # 'daily', 'weekly', 'monthly'\n                                          start_date: date,\n                                          end_date: date) -&gt; Dict[str, Any]:\n        \"\"\"Get revenue metrics grouped by time period\"\"\"\n        pass\n\n    async def get_popular_pizzas_async(self,\n                                       start_date: date,\n                                       end_date: date,\n                                       limit: int = 10) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get most popular pizzas by order count\"\"\"\n        pass\n\n    async def get_customer_insights_async(self,\n                                          customer_phone: str) -&gt; Dict[str, Any]:\n        \"\"\"Get customer ordering patterns and preferences\"\"\"\n        pass\n\n    async def get_peak_hours_analysis_async(self,\n                                            date_range: tuple[date, date]) -&gt; Dict[str, Any]:\n        \"\"\"Analyze order patterns by hour of day\"\"\"\n        pass\n\nclass MongoAnalyticsRepository(MongoOrderRepository, IAnalyticsRepository):\n    \"\"\"MongoDB implementation with advanced analytics capabilities\"\"\"\n\n    async def get_revenue_by_period_async(self,\n                                          period: str,\n                                          start_date: date,\n                                          end_date: date) -&gt; Dict[str, Any]:\n        \"\"\"Get revenue metrics with MongoDB aggregation\"\"\"\n        start_datetime = datetime.combine(start_date, datetime.min.time())\n        end_datetime = datetime.combine(end_date, datetime.max.time())\n\n        # Dynamic grouping based on period\n        group_format = {\n            'daily': {\"$dateToString\": {\"format\": \"%Y-%m-%d\", \"date\": \"$order_time\"}},\n            'weekly': {\"$dateToString\": {\"format\": \"%Y-W%U\", \"date\": \"$order_time\"}},\n            'monthly': {\"$dateToString\": {\"format\": \"%Y-%m\", \"date\": \"$order_time\"}}\n        }\n\n        pipeline = [\n            {\n                \"$match\": {\n                    \"order_time\": {\"$gte\": start_datetime, \"$lte\": end_datetime},\n                    \"status\": {\"$in\": [\"ready\", \"delivered\"]}\n                }\n            },\n            {\n                \"$group\": {\n                    \"_id\": group_format.get(period, group_format['daily']),\n                    \"revenue\": {\"$sum\": \"$total_amount\"},\n                    \"order_count\": {\"$sum\": 1},\n                    \"average_order_value\": {\"$avg\": \"$total_amount\"}\n                }\n            },\n            {\n                \"$sort\": {\"_id\": 1}\n            }\n        ]\n\n        results = await self.collection.aggregate(pipeline).to_list(length=None)\n\n        return {\n            \"period\": period,\n            \"data\": results,\n            \"summary\": {\n                \"total_revenue\": sum(r[\"revenue\"] for r in results),\n                \"total_orders\": sum(r[\"order_count\"] for r in results),\n                \"periods_analyzed\": len(results)\n            }\n        }\n\n    async def get_popular_pizzas_async(self,\n                                       start_date: date,\n                                       end_date: date,\n                                       limit: int = 10) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get most popular pizzas with detailed analytics\"\"\"\n        start_datetime = datetime.combine(start_date, datetime.min.time())\n        end_datetime = datetime.combine(end_date, datetime.max.time())\n\n        pipeline = [\n            {\n                \"$match\": {\n                    \"order_time\": {\"$gte\": start_datetime, \"$lte\": end_datetime},\n                    \"status\": {\"$in\": [\"ready\", \"delivered\"]}\n                }\n            },\n            {\n                \"$unwind\": \"$pizzas\"\n            },\n            {\n                \"$group\": {\n                    \"_id\": \"$pizzas.name\",\n                    \"order_count\": {\"$sum\": 1},\n                    \"total_revenue\": {\"$sum\": \"$pizzas.price\"},\n                    \"avg_price\": {\"$avg\": \"$pizzas.price\"},\n                    \"unique_customers\": {\"$addToSet\": \"$customer_phone\"}\n                }\n            },\n            {\n                \"$project\": {\n                    \"pizza_name\": \"$_id\",\n                    \"order_count\": 1,\n                    \"total_revenue\": 1,\n                    \"avg_price\": 1,\n                    \"unique_customers\": {\"$size\": \"$unique_customers\"},\n                    \"_id\": 0\n                }\n            },\n            {\n                \"$sort\": {\"order_count\": -1}\n            },\n            {\n                \"$limit\": limit\n            }\n        ]\n\n        return await self.collection.aggregate(pipeline).to_list(length=limit)\n\n    async def get_customer_insights_async(self,\n                                          customer_phone: str) -&gt; Dict[str, Any]:\n        \"\"\"Comprehensive customer analytics\"\"\"\n        pipeline = [\n            {\n                \"$match\": {\"customer_phone\": customer_phone}\n            },\n            {\n                \"$group\": {\n                    \"_id\": \"$customer_phone\",\n                    \"total_orders\": {\"$sum\": 1},\n                    \"total_spent\": {\"$sum\": \"$total_amount\"},\n                    \"avg_order_value\": {\"$avg\": \"$total_amount\"},\n                    \"first_order\": {\"$min\": \"$order_time\"},\n                    \"last_order\": {\"$max\": \"$order_time\"},\n                    \"favorite_pizzas\": {\"$push\": \"$pizzas.name\"},\n                    \"payment_methods\": {\"$addToSet\": \"$payment_method\"}\n                }\n            },\n            {\n                \"$project\": {\n                    \"customer_phone\": \"$_id\",\n                    \"total_orders\": 1,\n                    \"total_spent\": 1,\n                    \"avg_order_value\": 1,\n                    \"first_order\": 1,\n                    \"last_order\": 1,\n                    \"customer_lifetime_days\": {\n                        \"$divide\": [\n                            {\"$subtract\": [\"$last_order\", \"$first_order\"]},\n                            86400000  # milliseconds to days\n                        ]\n                    },\n                    \"payment_methods\": 1,\n                    \"_id\": 0\n                }\n            }\n        ]\n\n        results = await self.collection.aggregate(pipeline).to_list(length=1)\n        if not results:\n            return {\"error\": \"Customer not found\"}\n\n        customer_data = results[0]\n\n        # Calculate favorite pizza (most frequent)\n        # This would need additional aggregation pipeline for pizza frequency\n\n        return customer_data\n\n    async def get_peak_hours_analysis_async(self,\n                                            date_range: tuple[date, date]) -&gt; Dict[str, Any]:\n        \"\"\"Analyze order patterns by hour for staffing optimization\"\"\"\n        start_date, end_date = date_range\n        start_datetime = datetime.combine(start_date, datetime.min.time())\n        end_datetime = datetime.combine(end_date, datetime.max.time())\n\n        pipeline = [\n            {\n                \"$match\": {\n                    \"order_time\": {\"$gte\": start_datetime, \"$lte\": end_datetime}\n                }\n            },\n            {\n                \"$group\": {\n                    \"_id\": {\"$hour\": \"$order_time\"},\n                    \"order_count\": {\"$sum\": 1},\n                    \"total_revenue\": {\"$sum\": \"$total_amount\"},\n                    \"avg_order_value\": {\"$avg\": \"$total_amount\"}\n                }\n            },\n            {\n                \"$project\": {\n                    \"hour\": \"$_id\",\n                    \"order_count\": 1,\n                    \"total_revenue\": 1,\n                    \"avg_order_value\": 1,\n                    \"_id\": 0\n                }\n            },\n            {\n                \"$sort\": {\"hour\": 1}\n            }\n        ]\n\n        results = await self.collection.aggregate(pipeline).to_list(length=24)\n\n        # Fill in missing hours with zero values\n        hourly_data = {r[\"hour\"]: r for r in results}\n        complete_data = []\n\n        for hour in range(24):\n            hour_data = hourly_data.get(hour, {\n                \"hour\": hour,\n                \"order_count\": 0,\n                \"total_revenue\": 0.0,\n                \"avg_order_value\": 0.0\n            })\n            complete_data.append(hour_data)\n\n        # Find peak hours (top 3)\n        sorted_by_orders = sorted(complete_data, key=lambda x: x[\"order_count\"], reverse=True)\n        peak_hours = sorted_by_orders[:3]\n\n        return {\n            \"hourly_breakdown\": complete_data,\n            \"peak_hours\": peak_hours,\n            \"analysis_period\": {\n                \"start_date\": start_date.isoformat(),\n                \"end_date\": end_date.isoformat()\n            }\n        }\n</code></pre> <pre><code>import pytest\nfrom unittest.mock import AsyncMock\nfrom datetime import datetime, date, timedelta\nfrom decimal import Decimal\n\nclass TestOrderRepository:\n    \"\"\"Unit tests for order repository implementations\"\"\"\n\n    @pytest.fixture\n    def sample_order(self):\n        \"\"\"Create sample pizza order for testing\"\"\"\n        return Order(\n            id=\"order_123\",\n            customer_name=\"John Doe\",\n            customer_phone=\"+1234567890\",\n            customer_address=\"123 Main St\",\n            pizzas=[\n                Pizza(name=\"Margherita\", price=Decimal(\"12.99\")),\n                Pizza(name=\"Pepperoni\", price=Decimal(\"14.99\"))\n            ],\n            status=\"preparing\",\n            order_time=datetime.utcnow(),\n            total_amount=Decimal(\"27.98\"),\n            payment_method=\"card\"\n        )\n\n    @pytest.fixture\n    def mock_file_repository(self, tmp_path):\n        \"\"\"Create file repository with temporary directory\"\"\"\n        return FileOrderRepository(str(tmp_path / \"orders\"))\n\n    @pytest.mark.asyncio\n    async def test_save_order_creates_file(self, mock_file_repository, sample_order):\n        \"\"\"Test that saving an order creates proper file structure\"\"\"\n        await mock_file_repository.save_async(sample_order)\n\n        # Verify file was created\n        order_file = Path(mock_file_repository.orders_directory) / f\"{sample_order.id}.json\"\n        assert order_file.exists()\n\n        # Verify file content\n        with open(order_file, 'r') as f:\n            order_data = json.load(f)\n            assert order_data[\"customer_name\"] == sample_order.customer_name\n            assert len(order_data[\"pizzas\"]) == 2\n\n    @pytest.mark.asyncio\n    async def test_get_by_customer_phone(self, mock_file_repository, sample_order):\n        \"\"\"Test customer phone lookup functionality\"\"\"\n        await mock_file_repository.save_async(sample_order)\n\n        # Create another order for same customer\n        second_order = Order(\n            id=\"order_456\",\n            customer_name=\"John Doe\",\n            customer_phone=\"+1234567890\",\n            customer_address=\"123 Main St\",\n            pizzas=[Pizza(name=\"Hawaiian\", price=Decimal(\"15.99\"))],\n            status=\"ready\",\n            order_time=datetime.utcnow() + timedelta(hours=1)\n        )\n        await mock_file_repository.save_async(second_order)\n\n        # Test phone lookup\n        customer_orders = await mock_file_repository.get_by_customer_phone_async(\"+1234567890\")\n\n        assert len(customer_orders) == 2\n        # Should be ordered by time (most recent first)\n        assert customer_orders[0].id == \"order_456\"\n        assert customer_orders[1].id == \"order_123\"\n\n    @pytest.mark.asyncio\n    async def test_kitchen_queue_filtering(self, mock_file_repository):\n        \"\"\"Test kitchen queue status filtering\"\"\"\n        # Create orders with different statuses\n        orders = [\n            Order(id=\"order_1\", status=\"preparing\", customer_name=\"Customer 1\"),\n            Order(id=\"order_2\", status=\"cooking\", customer_name=\"Customer 2\"),\n            Order(id=\"order_3\", status=\"ready\", customer_name=\"Customer 3\"),\n            Order(id=\"order_4\", status=\"delivered\", customer_name=\"Customer 4\")\n        ]\n\n        for order in orders:\n            await mock_file_repository.save_async(order)\n\n        # Get kitchen queue (preparing and cooking)\n        kitchen_orders = await mock_file_repository.get_kitchen_queue_async([\"preparing\", \"cooking\"])\n\n        assert len(kitchen_orders) == 2\n        statuses = [order.status for order in kitchen_orders]\n        assert \"preparing\" in statuses\n        assert \"cooking\" in statuses\n        assert \"ready\" not in statuses\n\n@pytest.mark.integration\nclass TestMongoOrderRepository:\n    \"\"\"Integration tests for MongoDB repository\"\"\"\n\n    @pytest.fixture\n    async def mongo_repository(self, mongo_test_client):\n        \"\"\"Create MongoDB repository for testing\"\"\"\n        database = mongo_test_client.test_pizzeria\n        return MongoOrderRepository(database)\n\n    @pytest.mark.asyncio\n    async def test_revenue_aggregation(self, mongo_repository):\n        \"\"\"Test MongoDB revenue aggregation pipeline\"\"\"\n        # Setup test data\n        test_orders = [\n            Order(\n                id=\"order_1\",\n                total_amount=Decimal(\"25.99\"),\n                status=\"delivered\",\n                order_time=datetime(2024, 1, 15, 12, 0)\n            ),\n            Order(\n                id=\"order_2\",\n                total_amount=Decimal(\"18.50\"),\n                status=\"delivered\",\n                order_time=datetime(2024, 1, 15, 18, 0)\n            ),\n            Order(\n                id=\"order_3\",\n                total_amount=Decimal(\"32.00\"),\n                status=\"preparing\",  # Should be excluded\n                order_time=datetime(2024, 1, 15, 19, 0)\n            )\n        ]\n\n        for order in test_orders:\n            await mongo_repository.save_async(order)\n\n        # Test daily revenue calculation\n        revenue_data = await mongo_repository.get_daily_revenue_async(date(2024, 1, 15))\n\n        assert revenue_data[\"total_revenue\"] == 44.49  # Only delivered orders\n        assert revenue_data[\"order_count\"] == 2\n        assert revenue_data[\"average_order_value\"] == 22.245\n\nclass TestEventRepository:\n    \"\"\"Test event repository for kitchen workflow tracking\"\"\"\n\n    @pytest.fixture\n    def sample_kitchen_events(self):\n        \"\"\"Create sample kitchen events for testing\"\"\"\n        return [\n            OrderStatusChangedEvent(\n                order_id=\"order_123\",\n                old_status=\"received\",\n                new_status=\"preparing\",\n                changed_by=\"chef_mario\"\n            ),\n            PizzaStartedEvent(\n                order_id=\"order_123\",\n                pizza_name=\"Margherita\",\n                pizza_index=0,\n                started_by=\"chef_mario\",\n                estimated_completion=datetime.utcnow() + timedelta(minutes=12)\n            )\n        ]\n\n    @pytest.mark.asyncio\n    async def test_event_chronological_ordering(self, file_event_repository, sample_kitchen_events):\n        \"\"\"Test that events are retrieved in chronological order\"\"\"\n        # Save events in random order\n        for event in reversed(sample_kitchen_events):\n            await file_event_repository.save_event_async(event)\n\n        # Retrieve events\n        today = date.today()\n        retrieved_events = await file_event_repository.get_events_by_date_range_async(today, today)\n\n        # Should be ordered by occurrence time\n        assert len(retrieved_events) == 2\n        assert retrieved_events[0].occurred_at &lt;= retrieved_events[1].occurred_at\n\n# Test fixtures for integration testing\n@pytest.fixture\nasync def mongo_test_client():\n    \"\"\"MongoDB test client with cleanup\"\"\"\n    from motor.motor_asyncio import AsyncIOMotorClient\n\n    client = AsyncIOMotorClient(\"mongodb://localhost:27017\")\n\n    # Use test database\n    test_db = client.test_pizzeria\n\n    yield client\n\n    # Cleanup\n    await client.drop_database(\"test_pizzeria\")\n    client.close()\n\n@pytest.fixture\ndef file_event_repository(tmp_path):\n    \"\"\"File event repository with temporary storage\"\"\"\n    return FileEventRepository(str(tmp_path / \"events\"))\n</code></pre>"},{"location":"features/data-access/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started Guide - Complete pizzeria application tutorial</li> <li>CQRS &amp; Mediation - Commands and queries with pizzeria examples</li> <li>Dependency Injection - Service registration for repositories</li> <li>MVC Controllers - API endpoints using these repositories</li> </ul> <p>This documentation demonstrates data access patterns using Mario's Pizzeria as a consistent example throughout the Neuroglia framework. The patterns shown scale from simple file-based storage for development to MongoDB with advanced analytics for production use.</p>"},{"location":"features/dependency-injection/","title":"\ud83c\udf55 Dependency Injection","text":"<p>Neuroglia provides a lightweight, powerful dependency injection (DI) container that manages service registration, lifetime, and resolution for Mario's Pizzeria and any application built with the framework.</p> <p>Let's see how DI helps organize our pizzeria's services - from repositories that store orders to services that send notifications.</p>"},{"location":"features/dependency-injection/#overview","title":"\ud83c\udfaf Overview","text":"<p>The dependency injection system consists of:</p> <ul> <li>ServiceCollection: Registry for service definitions (our pizzeria's service catalog)</li> <li>ServiceProvider: Container for resolving and managing services (the kitchen that coordinates everything)</li> <li>ServiceLifetime: Controls when services are created and disposed (like kitchen equipment usage patterns)</li> <li>Enhanced Web Application Builder: Simplified registration with multi-app support</li> <li>Automatic Discovery: Services can be automatically discovered and registered</li> </ul>"},{"location":"features/dependency-injection/#service-lifetimes-in-marios-pizzeria","title":"\ud83c\udfd7\ufe0f Service Lifetimes in Mario's Pizzeria","text":""},{"location":"features/dependency-injection/#singleton-shared-equipment","title":"Singleton - Shared Equipment","text":"<p>Created once and reused for the entire pizzeria's lifetime:</p> <pre><code>from neuroglia.dependency_injection.service_provider import ServiceCollection\n\nservices = ServiceCollection()\n\n# Shared resources used by entire pizzeria\nservices.add_singleton(DatabaseConnection)      # Database connection pool\nservices.add_singleton(MenuCacheService)        # Menu data cached for all customers\nservices.add_singleton(KitchenDisplayService)   # Kitchen display board system\nservices.add_singleton(PaymentGateway)          # Payment processing service\nservices.add_singleton(SmsNotificationService) # SMS service for all notifications\n</code></pre> <p>Pizzeria Use Cases: - Database connection pools (shared by all operations) - Menu caching service (menu doesn't change often) - Kitchen display systems (one display board) - Payment gateway connections (shared across all transactions) - SMS/email notification services (one service instance)</p>"},{"location":"features/dependency-injection/#scoped-per-order-services","title":"Scoped - Per-Order Services","text":"<p>Created once per scope (typically per customer order or HTTP request):</p> <pre><code># Services that are specific to each order/request\nservices.add_scoped(OrderRepository)           # Order data access for this request\nservices.add_scoped(PizzeriaOrderService)      # Business logic for this order\nservices.add_scoped(CustomerContextService)    # Customer-specific context\nservices.add_scoped(KitchenWorkflowService)    # Kitchen operations for this order\n</code></pre> <p>Pizzeria Use Cases: - Order repositories (isolated data access per request) - Order processing services (specific to current order) - Customer context services (customer-specific data) - Kitchen workflow coordination (per-order cooking process) - Delivery routing services (per-order logistics)</p>"},{"location":"features/dependency-injection/#transient-per-use-tools","title":"Transient - Per-Use Tools","text":"<p>Created each time they are requested (like individual kitchen tools):</p> <pre><code># Services created fresh each time they're needed\nservices.add_transient(PizzaPriceCalculator)    # Calculate pricing for each pizza\nservices.add_transient(DeliveryTimeEstimator)   # Estimate delivery for each address\nservices.add_transient(LoyaltyPointsCalculator) # Calculate points for each transaction\nservices.add_transient(OrderValidator)          # Validate each order independently\n</code></pre> <ul> <li>Price calculations (fresh calculation each time)</li> <li>Delivery time estimations (stateless calculations)</li> <li>Order validation services (independent validation)</li> <li>Loyalty points calculators (stateless point calculations)</li> <li>Kitchen equipment status checkers (real-time status)</li> </ul>"},{"location":"features/dependency-injection/#registration-patterns-in-marios-pizzeria","title":"\ud83d\udd27 Registration Patterns in Mario's Pizzeria","text":""},{"location":"features/dependency-injection/#interface-and-implementation","title":"Interface and Implementation","text":"<p>Register pizzeria services by interface and implementation for flexibility:</p> <pre><code>from abc import ABC, abstractmethod\nfrom src.domain.order import Order\nfrom src.domain.pizza import Pizza\n\n# Order repository interface\nclass IOrderRepository(ABC):\n    @abstractmethod\n    async def save_async(self, order: Order) -&gt; None:\n        pass\n\n    @abstractmethod\n    async def get_by_id_async(self, order_id: str) -&gt; Optional[Order]:\n        pass\n\n    @abstractmethod\n    async def get_by_status_async(self, status: str) -&gt; List[Order]:\n        pass\n\n# File-based implementation for development\nclass FileOrderRepository(IOrderRepository):\n    def __init__(self, data_dir: str = \"data\"):\n        self.data_dir = Path(data_dir)\n        self.data_dir.mkdir(exist_ok=True)\n\n    async def save_async(self, order: Order) -&gt; None:\n        file_path = self.data_dir / f\"{order.id}.json\"\n        with open(file_path, 'w') as f:\n            json.dump(order.__dict__, f, default=str)\n\n# MongoDB implementation for production\nclass MongoOrderRepository(IOrderRepository):\n    def __init__(self, mongo_client: MongoClient):\n        self.collection = mongo_client.pizzeria.orders\n\n    async def save_async(self, order: Order) -&gt; None:\n        await self.collection.replace_one(\n            {\"_id\": order.id}, \n            order.__dict__, \n            upsert=True\n        )\n\n# Registration - swap implementations easily\nservices.add_scoped(IOrderRepository, FileOrderRepository)  # Development\n# services.add_scoped(IOrderRepository, MongoOrderRepository)  # Production\n</code></pre>"},{"location":"features/dependency-injection/#factory-functions-for-complex-services","title":"Factory Functions for Complex Services","text":"<p>Use factory functions for pizzeria services that need complex initialization:</p> <pre><code>def create_payment_gateway() -&gt; IPaymentGateway:\n    \"\"\"Create payment gateway with proper configuration\"\"\"\n    config = get_payment_config()\n\n    if config.environment == \"development\":\n        return MockPaymentGateway()\n    elif config.provider == \"stripe\":\n        return StripePaymentGateway(config.stripe_api_key)\n    else:\n        return SquarePaymentGateway(config.square_token)\n\ndef create_sms_service() -&gt; ISmsService:\n    \"\"\"Create SMS service with proper credentials\"\"\"\n    settings = get_app_settings()\n\n    return TwilioSmsService(\n        account_sid=settings.twilio_sid,\n        auth_token=settings.twilio_token,\n        from_number=settings.pizzeria_phone\n    )\n\n# Register with factories\nservices.add_singleton(IPaymentGateway, factory=create_payment_gateway)\nservices.add_singleton(ISmsService, factory=create_sms_service)\n</code></pre> <pre><code>from typing import TypeVar, Generic\nfrom neuroglia.data.abstractions import Repository\n\nT = TypeVar('T')\nTKey = TypeVar('TKey')\n\nclass FileRepository(Repository[T, TKey], Generic[T, TKey]):\n    \"\"\"Generic file-based repository for any entity type\"\"\"\n\n    def __init__(self, entity_type: type, data_dir: str = \"data\"):\n        self.entity_type = entity_type\n        self.data_dir = Path(data_dir) / entity_type.__name__.lower()\n        self.data_dir.mkdir(parents=True, exist_ok=True)\n\n# Register repositories for different pizzeria entities\nservices.add_scoped(lambda: FileRepository(Pizza, \"data\"))\nservices.add_scoped(lambda: FileRepository(Order, \"data\"))\nservices.add_scoped(lambda: FileRepository(Customer, \"data\"))\n\n# Or with factory functions for cleaner registration\ndef create_pizza_repository() -&gt; Repository[Pizza, str]:\n    return FileRepository(Pizza, \"data\")\n\ndef create_order_repository() -&gt; Repository[Order, str]:\n    return FileRepository(Order, \"data\")\n\nservices.add_scoped(Repository[Pizza, str], factory=create_pizza_repository)\nservices.add_scoped(Repository[Order, str], factory=create_order_repository)\n</code></pre>"},{"location":"features/dependency-injection/#enhanced-web-application-builder","title":"\ud83d\udd0d Enhanced Web Application Builder","text":"<p>The enhanced builder simplifies service registration for pizzeria applications:</p> <pre><code>from neuroglia.hosting import EnhancedWebApplicationBuilder\nfrom neuroglia.mediation import Mediator\nfrom neuroglia.mapping import Mapper\n\ndef create_pizzeria_app():\n    \"\"\"Create Mario's Pizzeria application with enhanced builder\"\"\"\n\n    # Create enhanced builder with multi-app support\n    builder = EnhancedWebApplicationBuilder()\n\n    # === Repository Layer ===\n    # File-based repositories for development\n    builder.services.add_scoped(lambda: FileRepository(Pizza, \"data\"))\n    builder.services.add_scoped(lambda: FileRepository(Order, \"data\"))\n    builder.services.add_scoped(lambda: FileRepository(Customer, \"data\"))\n\n    # === Application Services ===\n    builder.services.add_scoped(PizzeriaOrderService)\n    builder.services.add_scoped(KitchenManagementService)\n    builder.services.add_scoped(CustomerLoyaltyService)\n    builder.services.add_scoped(DeliveryCoordinationService)\n\n    # === Infrastructure Services ===\n    builder.services.add_singleton(IPaymentGateway, factory=create_payment_gateway)\n    builder.services.add_singleton(ISmsService, factory=create_sms_service)\n    builder.services.add_singleton(MenuCacheService)\n    builder.services.add_singleton(KitchenDisplayService)\n\n    # === Transient Services ===\n    builder.services.add_transient(PizzaPriceCalculator)\n    builder.services.add_transient(DeliveryTimeEstimator)\n    builder.services.add_transient(OrderValidator)\n\n    # === Configure Core Framework Services ===\n    Mediator.configure(builder, [\"src.application\"])\n    Mapper.configure(builder, [\"src\"])\n\n    # === Add Controllers with API Prefix ===\n    builder.add_controllers_with_prefix(\"src.api.controllers\", \"/api\")\n\n    # === OAuth Configuration ===\n    builder.configure_oauth({\n        \"orders:read\": \"Read order information\",\n        \"orders:write\": \"Create and modify orders\", \n        \"kitchen:manage\": \"Manage kitchen operations\",\n        \"admin\": \"Full administrative access\"\n    })\n\n    # === Build Application ===\n    app = builder.build()\n\n    # === Configure Middleware ===\n    app.use_cors()\n    app.use_swagger_ui()\n    app.use_controllers()\n\n    return app\n</code></pre>"},{"location":"features/dependency-injection/#automatic-service-discovery","title":"\ud83d\udd0d Automatic Service Discovery","text":"<p>Neuroglia can automatically discover and register pizzeria services based on conventions:</p>"},{"location":"features/dependency-injection/#module-based-discovery-for-pizzeria","title":"Module-Based Discovery for Pizzeria","text":"<pre><code>from neuroglia.hosting import EnhancedWebApplicationBuilder\n\nbuilder = EnhancedWebApplicationBuilder()\n\n# Automatically discover and register pizzeria services in modules\nbuilder.services.discover_services([\n    \"src.application.services\",      # PizzeriaOrderService, KitchenManagementService\n    \"src.infrastructure.repositories\", # FileOrderRepository, MongoPizzaRepository  \n    \"src.infrastructure.services\",    # TwilioSmsService, StripePaymentGateway\n    \"src.application.handlers\"        # Command and query handlers\n])\n</code></pre>"},{"location":"features/dependency-injection/#attribute-based-registration","title":"Attribute-Based Registration","text":"<p>Use decorators to mark pizzeria services for automatic registration:</p> <pre><code>from neuroglia.dependency_injection import service, ServiceLifetime\n\n# Service decorator automatically registers the class\n@service(ServiceLifetime.SCOPED)\nclass PizzeriaOrderService:\n    \"\"\"Handles pizza order business logic\"\"\"\n\n    def __init__(self, \n                 order_repository: Repository[Order, str],\n                 pizza_repository: Repository[Pizza, str],\n                 notification_service: ISmsService):\n        self.order_repository = order_repository\n        self.pizza_repository = pizza_repository\n        self.notification_service = notification_service\n\n@service(ServiceLifetime.SINGLETON) \nclass MenuCacheService:\n    \"\"\"Caches menu data for fast retrieval\"\"\"\n\n    def __init__(self):\n        self._cache = {}\n        self._cache_expiry = None\n\n@service(ServiceLifetime.TRANSIENT)\nclass PizzaPriceCalculator:\n    \"\"\"Calculates pizza pricing with toppings\"\"\"\n\n    def calculate_total_price(self, pizza: Pizza) -&gt; Decimal:\n        base_price = self._get_size_price(pizza.base_price, pizza.size)\n        toppings_price = Decimal(\"1.50\") * len(pizza.toppings)\n        return base_price + toppings_price\n</code></pre> <pre><code>from neuroglia.dependency_injection import service, ServiceLifetime\n\n# Automatically register notification service implementation\n@service(interface=INotificationService, lifetime=ServiceLifetime.SINGLETON)\nclass TwilioSmsService(INotificationService):\n    \"\"\"SMS notifications via Twilio\"\"\"\n\n    def __init__(self):\n        self.client = self._create_twilio_client()\n\n    async def send_order_confirmation(self, phone: str, order_id: str, ready_time: datetime):\n        message = f\"Order {order_id[:8]} confirmed! Ready by {ready_time.strftime('%H:%M')}\"\n        await self._send_sms(phone, message)\n\n# Automatically register repository implementation  \n@service(interface=IOrderRepository, lifetime=ServiceLifetime.SCOPED)\nclass FileOrderRepository(IOrderRepository):\n    \"\"\"File-based order storage for development\"\"\"\n\n    def __init__(self):\n        self.data_dir = Path(\"data/orders\")\n        self.data_dir.mkdir(parents=True, exist_ok=True)\n\n# The framework automatically wires these together\n@service(lifetime=ServiceLifetime.SCOPED)\nclass PizzeriaOrderService:\n    \"\"\"High-level order processing service\"\"\"\n\n    def __init__(self, \n                 order_repository: IOrderRepository,      # Gets FileOrderRepository\n                 notification_service: INotificationService): # Gets TwilioSmsService\n        self.order_repository = order_repository\n        self.notification_service = notification_service\n</code></pre>"},{"location":"features/dependency-injection/#service-resolution-in-marios-pizzeria","title":"\ud83d\udd04 Service Resolution in Mario's Pizzeria","text":""},{"location":"features/dependency-injection/#manual-resolution-for-advanced-scenarios","title":"Manual Resolution for Advanced Scenarios","text":"<pre><code># Build the service provider\nprovider = services.build_service_provider()\n\n# Resolve pizzeria services manually when needed\norder_service = provider.get_required_service(PizzeriaOrderService)\npayment_gateway = provider.get_service(IPaymentGateway)  # Returns None if not registered\n\n# Get all implementations (useful for plugin architectures)\nall_repositories = provider.get_services(IRepository)  # All repository implementations\nall_calculators = provider.get_services(IPriceCalculator)  # Different pricing strategies\n</code></pre> <p>Services are automatically injected into pizzeria controller constructors:</p> <pre><code>from neuroglia.mvc import ControllerBase\nfrom classy_fastapi.decorators import get, post\n\nclass OrdersController(ControllerBase):\n    \"\"\"Pizza orders API controller with dependency injection\"\"\"\n\n    def __init__(self, \n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator,\n                 order_service: PizzeriaOrderService,        # Automatically injected\n                 payment_service: IPaymentGateway,           # Automatically injected  \n                 notification_service: INotificationService): # Automatically injected\n        super().__init__(service_provider, mapper, mediator)\n        self.order_service = order_service\n        self.payment_service = payment_service\n        self.notification_service = notification_service\n\n    @post(\"/\", response_model=dict, status_code=201)\n    async def place_order(self, order_data: dict) -&gt; dict:\n        # All services are ready to use\n        result = await self.order_service.process_order_async(order_data)\n        return self.process(result)\n\nclass KitchenController(ControllerBase):\n    \"\"\"Kitchen operations controller\"\"\"\n\n    def __init__(self,\n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper, \n                 mediator: Mediator,\n                 kitchen_service: KitchenManagementService,  # Automatically injected\n                 display_service: KitchenDisplayService):    # Automatically injected\n        super().__init__(service_provider, mapper, mediator)\n        self.kitchen_service = kitchen_service\n        self.display_service = display_service\n</code></pre>"},{"location":"features/dependency-injection/#property-injection-for-optional-dependencies","title":"Property Injection for Optional Dependencies","text":"<p>Access optional services through the service provider:</p> <pre><code>class PizzeriaAnalyticsService:\n    \"\"\"Analytics service with optional dependencies\"\"\"\n\n    def __init__(self, \n                 service_provider: ServiceProviderBase,\n                 order_repository: Repository[Order, str]):  # Required dependency\n        self.service_provider = service_provider\n        self.order_repository = order_repository\n\n    async def generate_daily_report(self) -&gt; dict:\n        # Required service - injected via constructor\n        orders = await self.order_repository.get_by_date_range_async(date.today(), date.today())\n\n        # Optional service - resolved when needed\n        email_service = self.service_provider.get_service(IEmailService)\n        if email_service:\n            await email_service.send_daily_report(self._build_report(orders))\n\n        # Another optional service\n        slack_service = self.service_provider.get_service(ISlackService) \n        if slack_service:\n            await slack_service.post_daily_summary(orders)\n\n        return self._build_report(orders)\n</code></pre>"},{"location":"features/dependency-injection/#advanced-patterns","title":"\ud83c\udfad Advanced Patterns","text":""},{"location":"features/dependency-injection/#service-locator-for-cross-cutting-concerns","title":"Service Locator for Cross-Cutting Concerns","text":"<pre><code>class PizzeriaServiceLocator:\n    \"\"\"Service locator for pizzeria-wide services\"\"\"\n\n    _provider: ServiceProviderBase = None\n\n    @classmethod\n    def configure(cls, provider: ServiceProviderBase):\n        cls._provider = provider\n\n    @classmethod\n    def get_notification_service(cls) -&gt; INotificationService:\n        return cls._provider.get_required_service(INotificationService)\n\n    @classmethod\n    def get_cache_service(cls) -&gt; MenuCacheService:\n        return cls._provider.get_required_service(MenuCacheService)\n\n# Usage in domain events\nclass OrderPlacedEvent(DomainEvent):\n    async def notify_kitchen(self):\n        notification_service = PizzeriaServiceLocator.get_notification_service()\n        await notification_service.notify_kitchen_staff(f\"New order: {self.order_id}\")\n</code></pre> <pre><code>def configure_pizzeria_services(builder: EnhancedWebApplicationBuilder, environment: str):\n    \"\"\"Configure services based on pizzeria environment\"\"\"\n\n    if environment == \"development\":\n        # Development services\n        builder.services.add_scoped(IOrderRepository, FileOrderRepository)\n        builder.services.add_scoped(IPizzaRepository, FileRepository)\n        builder.services.add_singleton(IPaymentGateway, MockPaymentGateway)\n        builder.services.add_singleton(ICacheService, MemoryCacheService)\n        builder.services.add_singleton(INotificationService, ConsoleNotificationService)\n\n    elif environment == \"production\":\n        # Production services  \n        builder.services.add_scoped(IOrderRepository, MongoOrderRepository)\n        builder.services.add_scoped(IPizzaRepository, MongoPizzaRepository)\n        builder.services.add_singleton(IPaymentGateway, factory=create_stripe_gateway)\n        builder.services.add_singleton(ICacheService, RedisCacheService)\n        builder.services.add_singleton(INotificationService, TwilioSmsService)\n\n    elif environment == \"testing\":\n        # Testing services\n        builder.services.add_scoped(IOrderRepository, InMemoryOrderRepository)\n        builder.services.add_scoped(IPizzaRepository, InMemoryPizzaRepository)\n        builder.services.add_singleton(IPaymentGateway, MockPaymentGateway)\n        builder.services.add_singleton(ICacheService, NoOpCacheService)\n        builder.services.add_singleton(INotificationService, MockNotificationService)\n\n# Usage\nconfigure_pizzeria_services(builder, os.getenv(\"PIZZERIA_ENVIRONMENT\", \"development\"))\n</code></pre>"},{"location":"features/dependency-injection/#service-decoration-for-cross-cutting-concerns","title":"Service Decoration for Cross-Cutting Concerns","text":"<p>Wrap pizzeria services with additional behavior like logging, caching, or monitoring:</p> <pre><code>class LoggingOrderService(IOrderService):\n    \"\"\"Decorates order service with logging\"\"\"\n\n    def __init__(self, inner: IOrderService, logger: logging.Logger):\n        self.inner = inner\n        self.logger = logger\n\n    async def process_order_async(self, order_data: dict) -&gt; OperationResult:\n        order_id = order_data.get(\"temp_id\", \"unknown\")\n        self.logger.info(f\"Processing order {order_id} for {order_data.get('customer_name')}\")\n\n        start_time = time.time()\n        try:\n            result = await self.inner.process_order_async(order_data)\n            duration = time.time() - start_time\n\n            if result.is_success:\n                self.logger.info(f\"Order {order_id} processed successfully in {duration:.2f}s\")\n            else:\n                self.logger.warning(f\"Order {order_id} processing failed: {result.error_message}\")\n\n            return result\n        except Exception as ex:\n            duration = time.time() - start_time\n            self.logger.error(f\"Order {order_id} processing error in {duration:.2f}s: {ex}\")\n            raise\n\nclass CachingMenuService(IMenuService):\n    \"\"\"Decorates menu service with caching\"\"\"\n\n    def __init__(self, inner: IMenuService, cache: ICacheService):\n        self.inner = inner\n        self.cache = cache\n\n    async def get_menu_async(self, category: Optional[str] = None) -&gt; List[dict]:\n        cache_key = f\"menu:{category or 'all'}\"\n\n        # Check cache first\n        cached_menu = await self.cache.get_async(cache_key)\n        if cached_menu:\n            return cached_menu\n\n        # Get from inner service and cache result\n        menu = await self.inner.get_menu_async(category)\n        await self.cache.set_async(cache_key, menu, expire_minutes=30)\n\n        return menu\n\n# Registration with decoration\ndef configure_decorated_services(builder: EnhancedWebApplicationBuilder):\n    # Register base services\n    builder.services.add_scoped(PizzeriaOrderService)\n    builder.services.add_scoped(MenuService)\n\n    # Add decorations\n    builder.services.decorate(IOrderService, LoggingOrderService)\n    builder.services.decorate(IMenuService, CachingMenuService)\n\n    # The container will resolve: LoggingOrderService -&gt; PizzeriaOrderService\n    # And: CachingMenuService -&gt; MenuService\n</code></pre> <pre><code>from abc import ABC, abstractmethod\n\nclass IPizzeriaPlugin(ABC):\n    \"\"\"Interface for pizzeria plugins\"\"\"\n\n    @abstractmethod\n    def configure_services(self, services: ServiceCollection) -&gt; None:\n        pass\n\nclass DeliveryPlugin(IPizzeriaPlugin):\n    \"\"\"Plugin for delivery services\"\"\"\n\n    def configure_services(self, services: ServiceCollection) -&gt; None:\n        services.add_scoped(DeliveryService)\n        services.add_scoped(DeliveryRouteCalculator)\n        services.add_singleton(DeliveryTrackingService)\n\nclass LoyaltyPlugin(IPizzeriaPlugin):\n    \"\"\"Plugin for loyalty program\"\"\"\n\n    def configure_services(self, services: ServiceCollection) -&gt; None:\n        services.add_scoped(LoyaltyService)\n        services.add_scoped(RewardsCalculator)\n        services.add_singleton(LoyaltyCardService)\n\ndef configure_plugins(builder: EnhancedWebApplicationBuilder, enabled_plugins: List[str]):\n    \"\"\"Configure enabled plugins\"\"\"\n\n    available_plugins = {\n        \"delivery\": DeliveryPlugin(),\n        \"loyalty\": LoyaltyPlugin(),\n        \"analytics\": AnalyticsPlugin()\n    }\n\n    for plugin_name in enabled_plugins:\n        if plugin_name in available_plugins:\n            plugin = available_plugins[plugin_name]\n            plugin.configure_services(builder.services)\n\n# Usage\nenabled_features = [\"delivery\", \"loyalty\"]  # From configuration\nconfigure_plugins(builder, enabled_features)\n</code></pre>"},{"location":"features/dependency-injection/#configuration-integration","title":"\ud83d\udd27 Configuration Integration","text":"<pre><code>from dataclasses import dataclass\nfrom decimal import Decimal\n\n@dataclass\nclass PizzeriaConfig:\n    \"\"\"Main pizzeria configuration\"\"\"\n    name: str\n    phone: str\n    address: str\n    opening_hours: dict\n    delivery_radius_km: float\n\n@dataclass\nclass PaymentConfig:\n    \"\"\"Payment processing configuration\"\"\"\n    stripe_api_key: str\n    square_token: str\n    enable_cash: bool\n    enable_card: bool\n\n@dataclass \nclass NotificationConfig:\n    \"\"\"Notification service configuration\"\"\"\n    twilio_sid: str\n    twilio_token: str\n    from_phone: str\n    enable_sms: bool\n    enable_email: bool\n\n@dataclass\nclass MenuConfig:\n    \"\"\"Menu and pricing configuration\"\"\"\n    base_pizza_price: Decimal\n    topping_price: Decimal\n    size_multipliers: dict\n    tax_rate: Decimal\n\n# Register configurations\nservices.configure(PizzeriaConfig, app_settings.pizzeria)\nservices.configure(PaymentConfig, app_settings.payment)\nservices.configure(NotificationConfig, app_settings.notifications)\nservices.configure(MenuConfig, app_settings.menu)\n\n# Use in services\nclass PizzaPriceCalculator:\n    def __init__(self, menu_config: MenuConfig):\n        self.menu_config = menu_config\n\n    def calculate_pizza_price(self, pizza: Pizza) -&gt; Decimal:\n        base_price = self.menu_config.base_pizza_price\n        size_multiplier = self.menu_config.size_multipliers.get(pizza.size, 1.0)\n        topping_cost = len(pizza.toppings) * self.menu_config.topping_price\n\n        subtotal = (base_price * Decimal(str(size_multiplier))) + topping_cost\n        tax = subtotal * self.menu_config.tax_rate\n\n        return subtotal + tax\n</code></pre>"},{"location":"features/dependency-injection/#options-pattern-for-dynamic-configuration","title":"Options Pattern for Dynamic Configuration","text":"<p>Use the options pattern for configuration that can change at runtime:</p> <pre><code>from neuroglia.configuration import IOptions\n\nclass KitchenManagementService:\n    \"\"\"Kitchen service with configurable options\"\"\"\n\n    def __init__(self, \n                 pizzeria_options: IOptions[PizzeriaConfig],\n                 menu_options: IOptions[MenuConfig]):\n        self.pizzeria_config = pizzeria_options.value\n        self.menu_config = menu_options.value\n\n    async def check_if_within_hours(self) -&gt; bool:\n        current_hour = datetime.now().hour\n        opening_hours = self.pizzeria_config.opening_hours\n\n        return opening_hours[\"open\"] &lt;= current_hour &lt;= opening_hours[\"close\"]\n\n    async def get_max_prep_time(self) -&gt; int:\n        \"\"\"Get maximum preparation time based on current kitchen load\"\"\"\n        # Options can be refreshed from configuration store\n        base_time = self.menu_config.base_prep_time_minutes\n        return base_time  # Could be dynamically adjusted\n</code></pre>"},{"location":"features/dependency-injection/#testing-with-dependency-injection","title":"\ud83e\uddea Testing with Dependency Injection","text":""},{"location":"features/dependency-injection/#unit-testing-with-mocks","title":"Unit Testing with Mocks","text":"<p>Test pizzeria services in isolation using mocks:</p> <pre><code>import pytest\nfrom unittest.mock import Mock, AsyncMock\nfrom src.application.services.pizzeria_order_service import PizzeriaOrderService\nfrom src.domain.order import Order\n\n@pytest.fixture\ndef mock_order_repository():\n    repository = Mock()\n    repository.save_async = AsyncMock()\n    repository.get_by_id_async = AsyncMock()\n    return repository\n\n@pytest.fixture\ndef mock_notification_service():\n    service = Mock()\n    service.send_order_confirmation = AsyncMock()\n    return service\n\n@pytest.mark.asyncio\nasync def test_order_service_processes_order_successfully(\n    mock_order_repository,\n    mock_notification_service\n):\n    # Arrange\n    order_service = PizzeriaOrderService(\n        order_repository=mock_order_repository,\n        notification_service=mock_notification_service\n    )\n\n    order_data = {\n        \"customer_name\": \"John Doe\",\n        \"customer_phone\": \"555-0123\",\n        \"pizza_items\": [{\"pizza_id\": \"margherita\", \"size\": \"large\"}]\n    }\n\n    # Act\n    result = await order_service.process_order_async(order_data)\n\n    # Assert\n    assert result.is_success\n    mock_order_repository.save_async.assert_called_once()\n    mock_notification_service.send_order_confirmation.assert_called_once()\n</code></pre>"},{"location":"features/dependency-injection/#integration-testing-with-test-container","title":"Integration Testing with Test Container","text":"<p>Test with a real service container for integration tests:</p> <pre><code>@pytest.fixture\ndef test_service_provider():\n    \"\"\"Create service provider for integration tests\"\"\"\n\n    services = ServiceCollection()\n\n    # Use in-memory implementations for testing\n    services.add_scoped(IOrderRepository, InMemoryOrderRepository)\n    services.add_scoped(IPizzaRepository, InMemoryPizzaRepository)\n    services.add_singleton(INotificationService, MockNotificationService)\n\n    # Real services\n    services.add_scoped(PizzeriaOrderService)\n    services.add_scoped(KitchenManagementService)\n\n    return services.build_service_provider()\n\n@pytest.mark.asyncio\nasync def test_complete_order_workflow(test_service_provider):\n    \"\"\"Test complete order workflow with real services\"\"\"\n\n    # Get services from container\n    order_service = test_service_provider.get_required_service(PizzeriaOrderService)\n    kitchen_service = test_service_provider.get_required_service(KitchenManagementService)\n\n    # Test complete workflow\n    order_result = await order_service.process_order_async(sample_order_data)\n    assert order_result.is_success\n\n    # Start cooking\n    cooking_result = await kitchen_service.start_cooking_async(order_result.data[\"order_id\"])\n    assert cooking_result.is_success\n</code></pre>"},{"location":"features/dependency-injection/#best-practices","title":"\ud83d\ude80 Best Practices","text":""},{"location":"features/dependency-injection/#1-prefer-constructor-injection","title":"1. Prefer Constructor Injection","text":"<p>Always use constructor injection for required dependencies:</p> <pre><code># \u2705 Good - Constructor injection\nclass OrderService:\n    def __init__(self, \n                 order_repository: IOrderRepository,\n                 notification_service: INotificationService):\n        self.order_repository = order_repository\n        self.notification_service = notification_service\n\n# \u274c Avoid - Service locator pattern  \nclass OrderService:\n    def process_order(self):\n        repository = ServiceLocator.get_service(IOrderRepository)  # Hard to test\n</code></pre>"},{"location":"features/dependency-injection/#2-use-appropriate-lifetimes","title":"2. Use Appropriate Lifetimes","text":"<p>Choose service lifetimes based on usage patterns:</p> <pre><code># \u2705 Singleton for expensive, stateless services\nservices.add_singleton(PaymentGateway)        # Expensive to create\nservices.add_singleton(MenuCacheService)      # Shared state\n\n# \u2705 Scoped for request-specific services  \nservices.add_scoped(OrderRepository)          # Per-request data access\nservices.add_scoped(CustomerContextService)   # Request-specific context\n\n# \u2705 Transient for lightweight, stateless services\nservices.add_transient(PizzaPriceCalculator)  # Stateless calculations\nservices.add_transient(OrderValidator)        # Pure validation logic\n</code></pre>"},{"location":"features/dependency-injection/#3-avoid-service-location","title":"3. Avoid Service Location","text":"<p>Don't use the service provider directly in business logic:</p> <pre><code># \u274c Avoid - Direct service provider usage\nclass OrderService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.service_provider = service_provider\n\n    def process_order(self, order_data):\n        # This makes testing difficult and hides dependencies\n        payment_service = self.service_provider.get_service(IPaymentService)\n\n# \u2705 Good - Explicit dependencies\nclass OrderService:\n    def __init__(self, \n                 order_repository: IOrderRepository,\n                 payment_service: IPaymentService):  # Clear dependencies\n        self.order_repository = order_repository\n        self.payment_service = payment_service\n</code></pre>"},{"location":"features/dependency-injection/#key-benefits","title":"\ud83c\udfaf Key Benefits","text":"<p>Using Neuroglia's DI container in Mario's Pizzeria provides:</p> <p>\u2705 Loose Coupling - Services depend on interfaces, not concrete implementations \u2705 Easy Testing - Mock dependencies for isolated unit tests \u2705 Configuration Flexibility - Swap implementations for different environments \u2705 Automatic Lifetime Management - Framework handles object creation and disposal \u2705 Enhanced Web Application Builder - Simplified setup with multi-app support \u2705 Type Safety - Full type checking and IntelliSense support  </p>"},{"location":"features/dependency-injection/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Build Mario's Pizzeria with DI from the start</li> <li>CQRS &amp; Mediation - How handlers are resolved through DI</li> <li>MVC Controllers - Controller dependency injection patterns  </li> <li>Data Access - Repository pattern and DI integration         if self.options.send_welcome_emails:             # Send email logic             pass <pre><code>## \ud83e\uddea Testing with DI\n\n### Test Service Registration\n\nOverride services for testing:\n\n```python\nimport pytest\nfrom neuroglia.dependency_injection import ServiceCollection\n\n@pytest.fixture\ndef test_services():\n    services = ServiceCollection()\n\n    # Register test implementations\n    services.add_singleton(IUserRepository, InMemoryUserRepository)\n    services.add_singleton(IEmailService, MockEmailService)\n\n    return services.build_service_provider()\n\ndef test_user_creation(test_services):\n    user_service = test_services.get_required_service(UserService)\n    result = user_service.create_user(user_data)\n    assert result.is_success\n</code></pre></li> </ul>"},{"location":"features/dependency-injection/#mock-dependencies","title":"Mock Dependencies","text":"<p>Use mocking frameworks with DI:</p> <pre><code>from unittest.mock import Mock\n\ndef test_user_service_with_mocks():\n    # Arrange\n    mock_repo = Mock(spec=IUserRepository)\n    mock_repo.add_async.return_value = test_user\n\n    services = ServiceCollection()\n    services.add_instance(IUserRepository, mock_repo)\n    provider = services.build_service_provider()\n\n    # Act\n    user_service = provider.get_required_service(UserService)\n    result = await user_service.create_user(user_data)\n\n    # Assert\n    mock_repo.add_async.assert_called_once()\n    assert result.email == test_user.email\n</code></pre>"},{"location":"features/dependency-injection/#framework-integration","title":"\ud83c\udfaa Framework Integration","text":""},{"location":"features/dependency-injection/#web-application-builder","title":"Web Application Builder","text":"<p>The WebApplicationBuilder provides convenient methods for service registration:</p> <pre><code>from neuroglia.hosting.web import WebApplicationBuilder\n\nbuilder = WebApplicationBuilder()\n\n# Configure framework services\nbuilder.services.add_mediation([\"application\"])\nbuilder.services.add_mapping([\"application\", \"domain\"])\nbuilder.services.add_repositories([\"integration.repositories\"])\n\n# Add custom services\nbuilder.services.add_scoped(UserService)\nbuilder.services.add_singleton(EmailService)\n\napp = builder.build()\n</code></pre>"},{"location":"features/dependency-injection/#controller-dependencies","title":"Controller Dependencies","text":"<p>Controllers automatically receive dependencies:</p> <pre><code>class UsersController(ControllerBase):\n    def __init__(self, \n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator,\n                 user_service: UserService,\n                 email_service: EmailService):\n        super().__init__(service_provider, mapper, mediator)\n        self.user_service = user_service\n        self.email_service = email_service\n</code></pre>"},{"location":"features/dependency-injection/#middleware-dependencies","title":"Middleware Dependencies","text":"<p>Middleware can also use dependency injection:</p> <pre><code>class AuthenticationMiddleware:\n    def __init__(self, auth_service: IAuthService):\n        self.auth_service = auth_service\n\n    async def __call__(self, request: Request, call_next):\n        # Use auth_service for authentication logic\n        pass\n</code></pre>"},{"location":"features/dependency-injection/#best-practices_1","title":"\ud83d\ude80 Best Practices","text":""},{"location":"features/dependency-injection/#1-register-by-interface","title":"1. Register by Interface","text":"<p>Always register services by their interface when possible:</p> <pre><code># Good\nservices.add_scoped(IUserRepository, MongoUserRepository)\n\n# Avoid\nservices.add_scoped(MongoUserRepository)\n</code></pre>"},{"location":"features/dependency-injection/#2-use-appropriate-lifetimes_1","title":"2. Use Appropriate Lifetimes","text":"<p>Choose the correct lifetime for your services:</p> <ul> <li>Singleton: Expensive to create, stateless, or application-wide</li> <li>Scoped: Request-specific, maintains state during request</li> <li>Transient: Lightweight, stateless, or disposable</li> </ul>"},{"location":"features/dependency-injection/#3-avoid-service-locator","title":"3. Avoid Service Locator","text":"<p>Prefer constructor injection over service locator:</p> <pre><code># Good - Constructor injection\nclass UserService:\n    def __init__(self, user_repository: IUserRepository):\n        self.user_repository = user_repository\n\n# Avoid - Service locator\nclass UserService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.service_provider = service_provider\n\n    def some_method(self):\n        repo = self.service_provider.get_required_service(IUserRepository)\n</code></pre>"},{"location":"features/dependency-injection/#4-validate-dependencies","title":"4. Validate Dependencies","text":"<p>Ensure all required dependencies are registered:</p> <pre><code>def validate_services(provider: ServiceProviderBase):\n    \"\"\"Validate that all required services are registered\"\"\"\n    required_services = [IUserRepository, IEmailService, ICacheService]\n\n    for service_type in required_services:\n        service = provider.get_service(service_type)\n        if service is None:\n            raise ValueError(f\"Required service {service_type} not registered\")\n</code></pre>"},{"location":"features/dependency-injection/#5-use-factories-for-complex-objects","title":"5. Use Factories for Complex Objects","text":"<p>Use factory functions for services that need complex initialization:</p> <pre><code>def create_user_repository(provider: ServiceProviderBase) -&gt; IUserRepository:\n    config = provider.get_required_service(DatabaseConfig)\n    connection = provider.get_required_service(DatabaseConnection)\n\n    if config.use_caching:\n        cache = provider.get_required_service(ICacheService)\n        return CachedUserRepository(connection, cache)\n    else:\n        return UserRepository(connection)\n\nservices.add_scoped(IUserRepository, factory=create_user_repository)\n</code></pre>"},{"location":"features/dependency-injection/#related-documentation_1","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Basic DI usage</li> <li>Architecture Guide - How DI fits in the architecture</li> <li>CQRS &amp; Mediation - DI with command handlers</li> <li>Data Access - DI with repositories</li> <li>Testing - Testing with dependency injection</li> </ul>"},{"location":"features/enhanced-model-validation/","title":"\ud83d\udcca Enhanced Model Validation","text":"<p>The Neuroglia framework provides comprehensive model validation capabilities with business rule enforcement, custom validators, and sophisticated exception handling, enabling robust data integrity across all application layers with contextual validation and error reporting.</p>"},{"location":"features/enhanced-model-validation/#overview","title":"\ud83c\udfaf Overview","text":"<p>Modern applications require sophisticated validation beyond basic type checking - business rules, cross-field validation, conditional logic, and contextual constraints. The framework's enhanced validation system provides:</p> <ul> <li>Business Rule Validation: Domain-specific validation logic</li> <li>Custom Validators: Reusable validation components</li> <li>Cross-Field Validation: Dependencies between model fields</li> <li>Contextual Validation: Different rules based on context</li> <li>Rich Error Reporting: Detailed validation error messages</li> <li>Performance Optimized: Efficient validation with early termination</li> </ul>"},{"location":"features/enhanced-model-validation/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>graph TB\n    subgraph \"\ud83c\udf55 Mario's Pizzeria Models\"\n        OrderModel[Pizza Order Model]\n        CustomerModel[Customer Model]\n        MenuModel[Menu Item Model]\n        InventoryModel[Inventory Model]\n    end\n\n    subgraph \"\ud83d\udcca Enhanced Validation Layer\"\n        ValidationEngine[Validation Engine]\n        BusinessRules[Business Rule Validators]\n        CustomValidators[Custom Validators]\n        ContextValidators[Context-Aware Validators]\n    end\n\n    subgraph \"\ud83c\udfaf Validation Types\"\n        FieldValidation[Field Validation]\n        CrossFieldValidation[Cross-Field Validation]\n        ConditionalValidation[Conditional Validation]\n        BusinessLogicValidation[Business Logic Validation]\n    end\n\n    subgraph \"\ud83d\udccb Error Handling\"\n        ValidationExceptions[Validation Exceptions]\n        ErrorAggregation[Error Aggregation]\n        ContextualMessages[Contextual Messages]\n    end\n\n    OrderModel --&gt; ValidationEngine\n    CustomerModel --&gt; ValidationEngine\n    MenuModel --&gt; ValidationEngine\n    InventoryModel --&gt; ValidationEngine\n\n    ValidationEngine --&gt; BusinessRules\n    ValidationEngine --&gt; CustomValidators\n    ValidationEngine --&gt; ContextValidators\n\n    BusinessRules --&gt; FieldValidation\n    CustomValidators --&gt; CrossFieldValidation\n    ContextValidators --&gt; ConditionalValidation\n    ValidationEngine --&gt; BusinessLogicValidation\n\n    ValidationEngine --&gt; ValidationExceptions\n    ValidationExceptions --&gt; ErrorAggregation\n    ErrorAggregation --&gt; ContextualMessages\n\n    style ValidationEngine fill:#e3f2fd\n    style BusinessRules fill:#e8f5e8\n    style CustomValidators fill:#fff3e0\n    style ContextValidators fill:#f3e5f5</code></pre>"},{"location":"features/enhanced-model-validation/#basic-usage","title":"\ud83d\ude80 Basic Usage","text":""},{"location":"features/enhanced-model-validation/#service-registration","title":"Service Registration","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.validation import EnhancedModelValidator, ValidationConfig\n\ndef create_app():\n    builder = WebApplicationBuilder()\n\n    # Register enhanced model validation\n    validation_config = ValidationConfig(\n        strict_mode=True,\n        fail_fast=False,  # Collect all validation errors\n        include_field_context=True,\n        custom_error_messages=True\n    )\n\n    builder.services.add_enhanced_model_validation(validation_config)\n\n    app = builder.build()\n    return app\n</code></pre>"},{"location":"features/enhanced-model-validation/#basic-field-validation","title":"Basic Field Validation","text":"<pre><code>from neuroglia.validation import BusinessRuleValidator, ValidationContext\nfrom pydantic import BaseModel, Field, validator\nfrom typing import List, Optional\nfrom datetime import datetime, time\nfrom decimal import Decimal\n\nclass PizzaOrderModel(BaseModel):\n    \"\"\"Pizza order with comprehensive validation.\"\"\"\n\n    order_id: str = Field(..., min_length=3, max_length=20,\n                         description=\"Unique order identifier\")\n    customer_id: str = Field(..., min_length=5, max_length=50,\n                            description=\"Customer identifier\")\n\n    # Order items with business validation\n    order_items: List['OrderItemModel'] = Field(..., min_items=1, max_items=20,\n                                               description=\"Items in the order\")\n\n    # Financial fields with precision validation\n    subtotal: Decimal = Field(..., ge=0, decimal_places=2,\n                             description=\"Order subtotal\")\n    tax_amount: Decimal = Field(..., ge=0, decimal_places=2,\n                               description=\"Tax amount\")\n    delivery_fee: Decimal = Field(default=Decimal('0.00'), ge=0, decimal_places=2,\n                                 description=\"Delivery fee\")\n    total_amount: Decimal = Field(..., ge=0, decimal_places=2,\n                                 description=\"Total order amount\")\n\n    # Timing validation\n    order_placed_at: datetime = Field(..., description=\"Order placement time\")\n    requested_delivery_time: Optional[datetime] = Field(None,\n                                                       description=\"Requested delivery time\")\n\n    # Special requirements\n    special_instructions: Optional[str] = Field(None, max_length=500,\n                                              description=\"Special instructions\")\n    is_rush_order: bool = Field(default=False, description=\"Rush order flag\")\n\n    @validator('order_id')\n    def validate_order_id_format(cls, v):\n        \"\"\"Validate order ID format.\"\"\"\n        import re\n        if not re.match(r'^ORD_\\d{8}_\\d{3}$', v):\n            raise ValueError('Order ID must follow format: ORD_YYYYMMDD_XXX')\n        return v\n\n    @validator('requested_delivery_time')\n    def validate_delivery_time(cls, v, values):\n        \"\"\"Validate requested delivery time.\"\"\"\n        if v is None:\n            return v\n\n        order_placed_at = values.get('order_placed_at')\n        if order_placed_at and v &lt;= order_placed_at:\n            raise ValueError('Delivery time must be after order placement')\n\n        # Business rule: delivery must be within next 4 hours\n        if order_placed_at:\n            max_delivery_time = order_placed_at + timedelta(hours=4)\n            if v &gt; max_delivery_time:\n                raise ValueError('Delivery time cannot be more than 4 hours from now')\n\n        # Business rule: no deliveries between 2 AM and 10 AM\n        delivery_hour = v.hour\n        if 2 &lt;= delivery_hour &lt; 10:\n            raise ValueError('Deliveries not available between 2 AM and 10 AM')\n\n        return v\n\n    @validator('total_amount')\n    def validate_total_calculation(cls, v, values):\n        \"\"\"Validate total amount calculation.\"\"\"\n        subtotal = values.get('subtotal', Decimal('0'))\n        tax_amount = values.get('tax_amount', Decimal('0'))\n        delivery_fee = values.get('delivery_fee', Decimal('0'))\n\n        expected_total = subtotal + tax_amount + delivery_fee\n\n        if abs(v - expected_total) &gt; Decimal('0.01'):  # Allow 1 cent rounding difference\n            raise ValueError(\n                f'Total amount {v} does not match calculated total {expected_total}'\n            )\n\n        return v\n\n    @validator('order_items')\n    def validate_order_items_business_rules(cls, v):\n        \"\"\"Validate business rules for order items.\"\"\"\n        if not v:\n            raise ValueError('Order must contain at least one item')\n\n        # Business rule: maximum 5 of same item\n        item_counts = {}\n        for item in v:\n            key = f\"{item.menu_item_id}_{item.size}\"\n            item_counts[key] = item_counts.get(key, 0) + item.quantity\n            if item_counts[key] &gt; 5:\n                raise ValueError(f'Cannot order more than 5 of the same item: {item.item_name}')\n\n        # Business rule: rush orders limited to 3 items total\n        is_rush = any(getattr(cls, 'is_rush_order', False) for cls in [cls])\n        if is_rush and len(v) &gt; 3:\n            raise ValueError('Rush orders are limited to 3 items maximum')\n\n        return v\n\nclass OrderItemModel(BaseModel):\n    \"\"\"Individual order item with validation.\"\"\"\n\n    menu_item_id: str = Field(..., min_length=3, max_length=50)\n    item_name: str = Field(..., min_length=1, max_length=100)\n    size: str = Field(..., regex=r'^(small|medium|large|xl)$')\n    base_price: Decimal = Field(..., gt=0, decimal_places=2)\n\n    # Customizations\n    selected_toppings: List[str] = Field(default_factory=list, max_items=10)\n    removed_ingredients: List[str] = Field(default_factory=list, max_items=5)\n\n    # Quantity and pricing\n    quantity: int = Field(..., ge=1, le=10, description=\"Item quantity\")\n    toppings_price: Decimal = Field(default=Decimal('0.00'), ge=0, decimal_places=2)\n    line_total: Decimal = Field(..., ge=0, decimal_places=2)\n\n    @validator('selected_toppings')\n    def validate_toppings(cls, v):\n        \"\"\"Validate topping selections.\"\"\"\n        if len(v) != len(set(v)):\n            raise ValueError('Duplicate toppings are not allowed')\n\n        # Business rule: premium toppings limit\n        premium_toppings = ['truffle', 'caviar', 'gold_flakes']\n        premium_count = sum(1 for topping in v if topping in premium_toppings)\n        if premium_count &gt; 2:\n            raise ValueError('Maximum 2 premium toppings allowed per item')\n\n        return v\n\n    @validator('line_total')\n    def validate_line_total(cls, v, values):\n        \"\"\"Validate line total calculation.\"\"\"\n        base_price = values.get('base_price', Decimal('0'))\n        toppings_price = values.get('toppings_price', Decimal('0'))\n        quantity = values.get('quantity', 1)\n\n        expected_total = (base_price + toppings_price) * quantity\n\n        if abs(v - expected_total) &gt; Decimal('0.01'):\n            raise ValueError(\n                f'Line total {v} does not match calculated total {expected_total}'\n            )\n\n        return v\n</code></pre>"},{"location":"features/enhanced-model-validation/#business-rule-validators","title":"\ud83c\udfd7\ufe0f Business Rule Validators","text":""},{"location":"features/enhanced-model-validation/#custom-business-logic-validation","title":"Custom Business Logic Validation","text":"<pre><code>from neuroglia.validation import BusinessRuleValidator, ValidationResult\n\nclass PizzaOrderBusinessValidator(BusinessRuleValidator):\n    \"\"\"Comprehensive business rule validation for pizza orders.\"\"\"\n\n    def __init__(self, service_provider: ServiceProviderBase):\n        super().__init__(service_provider)\n        self.inventory_service = service_provider.get_service(InventoryService)\n        self.customer_service = service_provider.get_service(CustomerService)\n        self.menu_service = service_provider.get_service(MenuService)\n\n    async def validate_order_business_rules(self, order: PizzaOrderModel,\n                                          context: ValidationContext) -&gt; ValidationResult:\n        \"\"\"Validate comprehensive business rules for pizza orders.\"\"\"\n\n        errors = []\n        warnings = []\n\n        # Rule 1: Customer validation\n        customer_validation = await self.validate_customer_eligibility(order.customer_id)\n        if not customer_validation.is_valid:\n            errors.extend(customer_validation.errors)\n\n        # Rule 2: Inventory availability\n        inventory_validation = await self.validate_inventory_availability(order.order_items)\n        if not inventory_validation.is_valid:\n            errors.extend(inventory_validation.errors)\n\n        # Rule 3: Menu item availability\n        menu_validation = await self.validate_menu_items(order.order_items, context)\n        if not menu_validation.is_valid:\n            errors.extend(menu_validation.errors)\n        warnings.extend(menu_validation.warnings)\n\n        # Rule 4: Order timing validation\n        timing_validation = self.validate_order_timing(order, context)\n        if not timing_validation.is_valid:\n            errors.extend(timing_validation.errors)\n\n        # Rule 5: Financial validation\n        financial_validation = await self.validate_financial_constraints(order)\n        if not financial_validation.is_valid:\n            errors.extend(financial_validation.errors)\n\n        return ValidationResult(\n            is_valid=len(errors) == 0,\n            errors=errors,\n            warnings=warnings,\n            context=context\n        )\n\n    async def validate_customer_eligibility(self, customer_id: str) -&gt; ValidationResult:\n        \"\"\"Validate customer is eligible to place orders.\"\"\"\n\n        customer = await self.customer_service.get_customer_async(customer_id)\n        errors = []\n\n        if not customer:\n            errors.append(ValidationError(\n                field=\"customer_id\",\n                message=\"Customer not found\",\n                code=\"CUSTOMER_NOT_FOUND\"\n            ))\n            return ValidationResult(is_valid=False, errors=errors)\n\n        # Check customer account status\n        if customer.status == \"suspended\":\n            errors.append(ValidationError(\n                field=\"customer_id\",\n                message=\"Customer account is suspended\",\n                code=\"CUSTOMER_SUSPENDED\"\n            ))\n\n        # Check outstanding balance\n        if customer.outstanding_balance &gt; Decimal('100.00'):\n            errors.append(ValidationError(\n                field=\"customer_id\",\n                message=f\"Outstanding balance of ${customer.outstanding_balance} exceeds limit\",\n                code=\"OUTSTANDING_BALANCE_LIMIT\"\n            ))\n\n        # Check daily order limit\n        today_orders = await self.customer_service.get_today_order_count(customer_id)\n        if today_orders &gt;= 10:\n            errors.append(ValidationError(\n                field=\"customer_id\",\n                message=\"Daily order limit exceeded (10 orders per day)\",\n                code=\"DAILY_ORDER_LIMIT\"\n            ))\n\n        return ValidationResult(is_valid=len(errors) == 0, errors=errors)\n\n    async def validate_inventory_availability(self, order_items: List[OrderItemModel]) -&gt; ValidationResult:\n        \"\"\"Validate ingredient availability for all order items.\"\"\"\n\n        errors = []\n\n        for item in order_items:\n            # Get recipe ingredients for menu item\n            recipe = await self.menu_service.get_recipe_async(item.menu_item_id)\n            if not recipe:\n                errors.append(ValidationError(\n                    field=f\"order_items[{item.menu_item_id}]\",\n                    message=f\"Recipe not found for item: {item.item_name}\",\n                    code=\"RECIPE_NOT_FOUND\"\n                ))\n                continue\n\n            # Check base ingredients\n            for ingredient in recipe.base_ingredients:\n                required_quantity = ingredient.quantity * item.quantity\n                available_quantity = await self.inventory_service.get_available_quantity(\n                    ingredient.ingredient_id\n                )\n\n                if available_quantity &lt; required_quantity:\n                    errors.append(ValidationError(\n                        field=f\"order_items[{item.menu_item_id}].quantity\",\n                        message=f\"Insufficient {ingredient.name}: need {required_quantity}, have {available_quantity}\",\n                        code=\"INSUFFICIENT_INVENTORY\"\n                    ))\n\n            # Check topping availability\n            for topping_id in item.selected_toppings:\n                topping_quantity = await self.inventory_service.get_available_quantity(topping_id)\n                required_quantity = item.quantity  # 1 unit per pizza\n\n                if topping_quantity &lt; required_quantity:\n                    errors.append(ValidationError(\n                        field=f\"order_items[{item.menu_item_id}].selected_toppings\",\n                        message=f\"Topping '{topping_id}' not available in sufficient quantity\",\n                        code=\"TOPPING_UNAVAILABLE\"\n                    ))\n\n        return ValidationResult(is_valid=len(errors) == 0, errors=errors)\n\n    async def validate_menu_items(self, order_items: List[OrderItemModel],\n                                context: ValidationContext) -&gt; ValidationResult:\n        \"\"\"Validate menu item availability and special conditions.\"\"\"\n\n        errors = []\n        warnings = []\n\n        for item in order_items:\n            menu_item = await self.menu_service.get_menu_item_async(item.menu_item_id)\n\n            if not menu_item:\n                errors.append(ValidationError(\n                    field=f\"order_items[{item.menu_item_id}]\",\n                    message=f\"Menu item not found: {item.menu_item_id}\",\n                    code=\"MENU_ITEM_NOT_FOUND\"\n                ))\n                continue\n\n            # Check if item is available\n            if not menu_item.is_available:\n                errors.append(ValidationError(\n                    field=f\"order_items[{item.menu_item_id}]\",\n                    message=f\"Menu item is currently unavailable: {item.item_name}\",\n                    code=\"MENU_ITEM_UNAVAILABLE\"\n                ))\n\n            # Check size availability\n            if item.size not in menu_item.available_sizes:\n                errors.append(ValidationError(\n                    field=f\"order_items[{item.menu_item_id}].size\",\n                    message=f\"Size '{item.size}' not available for {item.item_name}\",\n                    code=\"SIZE_UNAVAILABLE\"\n                ))\n\n            # Check seasonal availability\n            if menu_item.is_seasonal and not self.is_in_season(menu_item, context.current_date):\n                warnings.append(ValidationWarning(\n                    field=f\"order_items[{item.menu_item_id}]\",\n                    message=f\"'{item.item_name}' is a seasonal item and may not be available\",\n                    code=\"SEASONAL_ITEM_WARNING\"\n                ))\n\n            # Validate price matches current menu price\n            current_price = menu_item.get_price_for_size(item.size)\n            if abs(item.base_price - current_price) &gt; Decimal('0.01'):\n                errors.append(ValidationError(\n                    field=f\"order_items[{item.menu_item_id}].base_price\",\n                    message=f\"Price mismatch: expected {current_price}, got {item.base_price}\",\n                    code=\"PRICE_MISMATCH\"\n                ))\n\n        return ValidationResult(\n            is_valid=len(errors) == 0,\n            errors=errors,\n            warnings=warnings\n        )\n\n    def validate_order_timing(self, order: PizzaOrderModel,\n                            context: ValidationContext) -&gt; ValidationResult:\n        \"\"\"Validate order timing constraints.\"\"\"\n\n        errors = []\n        current_time = context.current_datetime\n\n        # Check restaurant hours\n        restaurant_hours = self.get_restaurant_hours(current_time.weekday())\n        current_hour = current_time.hour\n\n        if not (restaurant_hours.open_hour &lt;= current_hour &lt; restaurant_hours.close_hour):\n            errors.append(ValidationError(\n                field=\"order_placed_at\",\n                message=f\"Restaurant is closed. Hours: {restaurant_hours.open_hour}:00 - {restaurant_hours.close_hour}:00\",\n                code=\"RESTAURANT_CLOSED\"\n            ))\n\n        # Rush order timing validation\n        if order.is_rush_order:\n            # Rush orders not allowed in last hour before closing\n            if current_hour &gt;= restaurant_hours.close_hour - 1:\n                errors.append(ValidationError(\n                    field=\"is_rush_order\",\n                    message=\"Rush orders not available in the last hour before closing\",\n                    code=\"RUSH_ORDER_TOO_LATE\"\n                ))\n\n            # Check rush order capacity\n            current_rush_orders = context.get(\"current_rush_orders\", 0)\n            if current_rush_orders &gt;= 5:  # Max 5 rush orders at once\n                errors.append(ValidationError(\n                    field=\"is_rush_order\",\n                    message=\"Rush order capacity exceeded. Please try again later.\",\n                    code=\"RUSH_ORDER_CAPACITY_EXCEEDED\"\n                ))\n\n        return ValidationResult(is_valid=len(errors) == 0, errors=errors)\n\n    async def validate_financial_constraints(self, order: PizzaOrderModel) -&gt; ValidationResult:\n        \"\"\"Validate financial business rules.\"\"\"\n\n        errors = []\n\n        # Minimum order value\n        minimum_order = Decimal('10.00')\n        if order.subtotal &lt; minimum_order:\n            errors.append(ValidationError(\n                field=\"subtotal\",\n                message=f\"Minimum order value is ${minimum_order}\",\n                code=\"MINIMUM_ORDER_NOT_MET\"\n            ))\n\n        # Maximum single order value (fraud prevention)\n        maximum_order = Decimal('500.00')\n        if order.total_amount &gt; maximum_order:\n            errors.append(ValidationError(\n                field=\"total_amount\",\n                message=f\"Maximum single order value is ${maximum_order}\",\n                code=\"MAXIMUM_ORDER_EXCEEDED\"\n            ))\n\n        # Rush order surcharge validation\n        if order.is_rush_order:\n            expected_rush_fee = order.subtotal * Decimal('0.20')  # 20% surcharge\n            if abs(order.delivery_fee - expected_rush_fee) &gt; Decimal('0.01'):\n                errors.append(ValidationError(\n                    field=\"delivery_fee\",\n                    message=f\"Rush order delivery fee should be ${expected_rush_fee}\",\n                    code=\"RUSH_DELIVERY_FEE_INCORRECT\"\n                ))\n\n        return ValidationResult(is_valid=len(errors) == 0, errors=errors)\n</code></pre>"},{"location":"features/enhanced-model-validation/#context-aware-validation","title":"\ud83c\udfaf Context-Aware Validation","text":""},{"location":"features/enhanced-model-validation/#dynamic-validation-based-on-context","title":"Dynamic Validation Based on Context","text":"<pre><code>from neuroglia.validation import ContextAwareValidator, ValidationContext\n\nclass CustomerRegistrationValidator(ContextAwareValidator):\n    \"\"\"Context-aware validation for customer registration.\"\"\"\n\n    async def validate_customer_registration(self, customer_data: dict,\n                                           context: ValidationContext) -&gt; ValidationResult:\n        \"\"\"Validate customer registration with context-specific rules.\"\"\"\n\n        errors = []\n        warnings = []\n\n        # Different validation rules based on registration source\n        registration_source = context.get(\"registration_source\", \"web\")\n\n        if registration_source == \"mobile_app\":\n            # Mobile app requires phone verification\n            mobile_validation = await self.validate_mobile_app_requirements(customer_data)\n            errors.extend(mobile_validation.errors)\n\n        elif registration_source == \"social_login\":\n            # Social login has different email validation\n            social_validation = await self.validate_social_login_requirements(customer_data)\n            errors.extend(social_validation.errors)\n\n        elif registration_source == \"in_store\":\n            # In-store registration allows relaxed validation\n            store_validation = await self.validate_in_store_requirements(customer_data)\n            warnings.extend(store_validation.warnings)\n\n        # Location-based validation\n        customer_location = context.get(\"customer_location\")\n        if customer_location:\n            location_validation = await self.validate_location_requirements(\n                customer_data, customer_location\n            )\n            errors.extend(location_validation.errors)\n\n        # Time-based validation (different rules for peak hours)\n        current_hour = context.current_datetime.hour\n        if 11 &lt;= current_hour &lt;= 14:  # Lunch rush\n            # Expedited validation during peak hours\n            peak_validation = self.validate_peak_hour_registration(customer_data)\n            if not peak_validation.is_valid:\n                # Convert some errors to warnings during peak hours\n                warnings.extend([\n                    ValidationWarning(\n                        field=error.field,\n                        message=f\"Peak hours: {error.message}\",\n                        code=f\"PEAK_{error.code}\"\n                    ) for error in peak_validation.errors\n                ])\n\n        return ValidationResult(\n            is_valid=len(errors) == 0,\n            errors=errors,\n            warnings=warnings,\n            context=context\n        )\n\n    async def validate_mobile_app_requirements(self, customer_data: dict) -&gt; ValidationResult:\n        \"\"\"Validate requirements specific to mobile app registration.\"\"\"\n\n        errors = []\n\n        # Phone number is required for mobile registration\n        if not customer_data.get(\"phone_number\"):\n            errors.append(ValidationError(\n                field=\"phone_number\",\n                message=\"Phone number is required for mobile registration\",\n                code=\"MOBILE_PHONE_REQUIRED\"\n            ))\n\n        # Push notification consent\n        if not customer_data.get(\"accepts_push_notifications\"):\n            errors.append(ValidationError(\n                field=\"accepts_push_notifications\",\n                message=\"Push notification consent required for mobile app\",\n                code=\"PUSH_CONSENT_REQUIRED\"\n            ))\n\n        return ValidationResult(is_valid=len(errors) == 0, errors=errors)\n\n    async def validate_location_requirements(self, customer_data: dict,\n                                           location: dict) -&gt; ValidationResult:\n        \"\"\"Validate location-specific requirements.\"\"\"\n\n        errors = []\n\n        # Check if we deliver to this location\n        is_in_delivery_zone = await self.check_delivery_zone(location)\n        if not is_in_delivery_zone:\n            errors.append(ValidationError(\n                field=\"address\",\n                message=\"Sorry, we don't deliver to this location yet\",\n                code=\"OUTSIDE_DELIVERY_ZONE\"\n            ))\n\n        # State-specific validation (e.g., age verification requirements)\n        state = location.get(\"state\")\n        if state in [\"CA\", \"NY\"]:  # States with stricter requirements\n            if not customer_data.get(\"date_of_birth\"):\n                errors.append(ValidationError(\n                    field=\"date_of_birth\",\n                    message=f\"Date of birth required for registration in {state}\",\n                    code=\"STATE_DOB_REQUIRED\"\n                ))\n\n        return ValidationResult(is_valid=len(errors) == 0, errors=errors)\n</code></pre>"},{"location":"features/enhanced-model-validation/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"features/enhanced-model-validation/#comprehensive-validation-testing","title":"Comprehensive Validation Testing","text":"<pre><code>import pytest\nfrom decimal import Decimal\nfrom datetime import datetime, timedelta\nfrom neuroglia.validation import ValidationContext, ValidationResult\n\nclass TestPizzaOrderValidation:\n\n    @pytest.fixture\n    def valid_order_data(self):\n        return {\n            \"order_id\": \"ORD_20241201_001\",\n            \"customer_id\": \"CUST_12345\",\n            \"order_items\": [\n                {\n                    \"menu_item_id\": \"margherita_large\",\n                    \"item_name\": \"Margherita Pizza\",\n                    \"size\": \"large\",\n                    \"base_price\": Decimal(\"18.99\"),\n                    \"selected_toppings\": [\"extra_cheese\"],\n                    \"removed_ingredients\": [],\n                    \"quantity\": 1,\n                    \"toppings_price\": Decimal(\"2.50\"),\n                    \"line_total\": Decimal(\"21.49\")\n                }\n            ],\n            \"subtotal\": Decimal(\"21.49\"),\n            \"tax_amount\": Decimal(\"1.72\"),\n            \"delivery_fee\": Decimal(\"2.99\"),\n            \"total_amount\": Decimal(\"26.20\"),\n            \"order_placed_at\": datetime.utcnow(),\n            \"requested_delivery_time\": datetime.utcnow() + timedelta(minutes=45),\n            \"special_instructions\": \"Ring doorbell\",\n            \"is_rush_order\": False\n        }\n\n    @pytest.fixture\n    def validation_context(self):\n        return ValidationContext(\n            current_datetime=datetime.utcnow(),\n            current_date=datetime.utcnow().date(),\n            user_context={\"customer_id\": \"CUST_12345\"},\n            request_context={\"source\": \"web_app\"}\n        )\n\n    def test_valid_order_passes_validation(self, valid_order_data):\n        \"\"\"Test that a valid order passes all validation.\"\"\"\n\n        order = PizzaOrderModel(**valid_order_data)\n\n        # Should not raise any validation errors\n        assert order.order_id == \"ORD_20241201_001\"\n        assert order.total_amount == Decimal(\"26.20\")\n        assert len(order.order_items) == 1\n\n    def test_invalid_order_id_format(self, valid_order_data):\n        \"\"\"Test order ID format validation.\"\"\"\n\n        valid_order_data[\"order_id\"] = \"INVALID_FORMAT\"\n\n        with pytest.raises(ValueError) as exc_info:\n            PizzaOrderModel(**valid_order_data)\n\n        assert \"Order ID must follow format\" in str(exc_info.value)\n\n    def test_total_calculation_validation(self, valid_order_data):\n        \"\"\"Test total amount calculation validation.\"\"\"\n\n        # Set incorrect total\n        valid_order_data[\"total_amount\"] = Decimal(\"99.99\")\n\n        with pytest.raises(ValueError) as exc_info:\n            PizzaOrderModel(**valid_order_data)\n\n        assert \"Total amount\" in str(exc_info.value)\n        assert \"does not match calculated total\" in str(exc_info.value)\n\n    def test_delivery_time_validation(self, valid_order_data):\n        \"\"\"Test delivery time business rules.\"\"\"\n\n        # Set delivery time in the past\n        valid_order_data[\"requested_delivery_time\"] = datetime.utcnow() - timedelta(hours=1)\n\n        with pytest.raises(ValueError) as exc_info:\n            PizzaOrderModel(**valid_order_data)\n\n        assert \"Delivery time must be after order placement\" in str(exc_info.value)\n\n    def test_delivery_time_early_hours_restriction(self, valid_order_data):\n        \"\"\"Test early hours delivery restriction.\"\"\"\n\n        # Set delivery time at 3 AM (restricted hours)\n        tomorrow_3am = datetime.utcnow().replace(hour=3, minute=0, second=0) + timedelta(days=1)\n        valid_order_data[\"requested_delivery_time\"] = tomorrow_3am\n\n        with pytest.raises(ValueError) as exc_info:\n            PizzaOrderModel(**valid_order_data)\n\n        assert \"not available between 2 AM and 10 AM\" in str(exc_info.value)\n\n    def test_maximum_item_quantity_validation(self, valid_order_data):\n        \"\"\"Test maximum quantity validation.\"\"\"\n\n        # Set quantity above limit\n        valid_order_data[\"order_items\"][0][\"quantity\"] = 15\n        valid_order_data[\"order_items\"][0][\"line_total\"] = Decimal(\"322.35\")  # Adjust total\n        valid_order_data[\"subtotal\"] = Decimal(\"322.35\")\n        valid_order_data[\"total_amount\"] = Decimal(\"350.00\")  # Adjust totals\n\n        with pytest.raises(ValueError) as exc_info:\n            PizzaOrderModel(**valid_order_data)\n\n        assert \"quantity\" in str(exc_info.value)\n\n    def test_duplicate_toppings_validation(self, valid_order_data):\n        \"\"\"Test duplicate toppings validation.\"\"\"\n\n        # Add duplicate toppings\n        valid_order_data[\"order_items\"][0][\"selected_toppings\"] = [\n            \"extra_cheese\", \"extra_cheese\", \"pepperoni\"\n        ]\n\n        with pytest.raises(ValueError) as exc_info:\n            PizzaOrderModel(**valid_order_data)\n\n        assert \"Duplicate toppings are not allowed\" in str(exc_info.value)\n\n    @pytest.mark.asyncio\n    async def test_business_rule_validation(self, valid_order_data, validation_context):\n        \"\"\"Test comprehensive business rule validation.\"\"\"\n\n        # Mock services\n        business_validator = PizzaOrderBusinessValidator(mock_service_provider())\n\n        order = PizzaOrderModel(**valid_order_data)\n        result = await business_validator.validate_order_business_rules(order, validation_context)\n\n        # Should pass basic validation (with mocked services)\n        assert isinstance(result, ValidationResult)\n\n    def test_line_total_calculation_validation(self, valid_order_data):\n        \"\"\"Test line total calculation validation.\"\"\"\n\n        # Set incorrect line total\n        valid_order_data[\"order_items\"][0][\"line_total\"] = Decimal(\"99.99\")\n        # Keep other totals consistent to isolate this validation\n\n        with pytest.raises(ValueError) as exc_info:\n            PizzaOrderModel(**valid_order_data)\n\n        assert \"Line total\" in str(exc_info.value)\n        assert \"does not match calculated total\" in str(exc_info.value)\n\ndef mock_service_provider():\n    \"\"\"Create mock service provider for testing.\"\"\"\n    from unittest.mock import Mock\n\n    service_provider = Mock()\n\n    # Mock inventory service\n    inventory_service = Mock()\n    inventory_service.get_available_quantity = Mock(return_value=100)  # Always available\n\n    # Mock customer service\n    customer_service = Mock()\n    mock_customer = Mock()\n    mock_customer.status = \"active\"\n    mock_customer.outstanding_balance = Decimal(\"0.00\")\n    customer_service.get_customer_async = Mock(return_value=mock_customer)\n    customer_service.get_today_order_count = Mock(return_value=0)\n\n    # Mock menu service\n    menu_service = Mock()\n    mock_recipe = Mock()\n    mock_recipe.base_ingredients = []\n    menu_service.get_recipe_async = Mock(return_value=mock_recipe)\n\n    mock_menu_item = Mock()\n    mock_menu_item.is_available = True\n    mock_menu_item.available_sizes = [\"small\", \"medium\", \"large\"]\n    mock_menu_item.is_seasonal = False\n    mock_menu_item.get_price_for_size = Mock(return_value=Decimal(\"18.99\"))\n    menu_service.get_menu_item_async = Mock(return_value=mock_menu_item)\n\n    service_provider.get_service.side_effect = lambda service_type: {\n        'InventoryService': inventory_service,\n        'CustomerService': customer_service,\n        'MenuService': menu_service\n    }.get(service_type.__name__ if hasattr(service_type, '__name__') else str(service_type))\n\n    return service_provider\n</code></pre>"},{"location":"features/enhanced-model-validation/#performance-testing","title":"Performance Testing","text":"<pre><code>import time\nimport pytest\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass TestValidationPerformance:\n\n    def test_validation_performance(self, valid_order_data):\n        \"\"\"Test validation performance with large datasets.\"\"\"\n\n        # Create 100 order variations\n        orders_data = []\n        for i in range(100):\n            order_data = valid_order_data.copy()\n            order_data[\"order_id\"] = f\"ORD_20241201_{i:03d}\"\n            orders_data.append(order_data)\n\n        # Time validation\n        start_time = time.time()\n\n        valid_orders = []\n        for order_data in orders_data:\n            try:\n                order = PizzaOrderModel(**order_data)\n                valid_orders.append(order)\n            except ValueError:\n                pass  # Skip invalid orders\n\n        end_time = time.time()\n        duration = end_time - start_time\n\n        print(f\"\u2705 Validated {len(valid_orders)} orders in {duration:.3f}s\")\n        print(f\"\ud83d\udcca Average validation time: {(duration/len(orders_data)*1000):.1f}ms per order\")\n\n        # Performance assertion\n        assert duration &lt; 1.0, f\"Validation took too long: {duration:.3f}s\"\n        assert len(valid_orders) == 100, \"Some valid orders failed validation\"\n</code></pre>"},{"location":"features/enhanced-model-validation/#error-aggregation-and-reporting","title":"\ud83d\udcca Error Aggregation and Reporting","text":""},{"location":"features/enhanced-model-validation/#comprehensive-error-handling","title":"Comprehensive Error Handling","text":"<pre><code>from neuroglia.validation import ValidationErrorAggregator, ValidationReport\n\nclass OrderValidationService:\n    \"\"\"Service for comprehensive order validation with detailed reporting.\"\"\"\n\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.business_validator = service_provider.get_service(PizzaOrderBusinessValidator)\n        self.error_aggregator = ValidationErrorAggregator()\n\n    async def validate_order_comprehensively(self, order_data: dict,\n                                           context: ValidationContext) -&gt; ValidationReport:\n        \"\"\"Perform comprehensive validation with detailed error reporting.\"\"\"\n\n        validation_report = ValidationReport()\n\n        try:\n            # Step 1: Basic model validation\n            validation_report.add_step(\"Model Validation\")\n            order_model = PizzaOrderModel(**order_data)\n            validation_report.mark_step_success(\"Model Validation\")\n\n        except ValueError as e:\n            validation_report.mark_step_failed(\"Model Validation\", str(e))\n            return validation_report\n\n        # Step 2: Business rule validation\n        validation_report.add_step(\"Business Rules Validation\")\n        business_result = await self.business_validator.validate_order_business_rules(\n            order_model, context\n        )\n\n        if business_result.is_valid:\n            validation_report.mark_step_success(\"Business Rules Validation\")\n        else:\n            validation_report.mark_step_failed(\n                \"Business Rules Validation\",\n                business_result.errors\n            )\n            validation_report.add_warnings(business_result.warnings)\n\n        # Step 3: Context-specific validation\n        validation_report.add_step(\"Context Validation\")\n        context_result = await self.validate_context_specific_rules(order_model, context)\n\n        if context_result.is_valid:\n            validation_report.mark_step_success(\"Context Validation\")\n        else:\n            validation_report.mark_step_failed(\"Context Validation\", context_result.errors)\n\n        # Generate comprehensive report\n        validation_report.finalize()\n\n        print(\"\ud83d\udccb Validation Report:\")\n        print(f\"Overall Status: {'\u2705 VALID' if validation_report.is_valid else '\u274c INVALID'}\")\n        print(f\"Total Errors: {len(validation_report.all_errors)}\")\n        print(f\"Total Warnings: {len(validation_report.all_warnings)}\")\n\n        if validation_report.all_errors:\n            print(\"\\n\ud83d\udea8 Validation Errors:\")\n            for error in validation_report.all_errors:\n                print(f\"  \u2022 {error.field}: {error.message} ({error.code})\")\n\n        if validation_report.all_warnings:\n            print(\"\\n\u26a0\ufe0f Validation Warnings:\")\n            for warning in validation_report.all_warnings:\n                print(f\"  \u2022 {warning.field}: {warning.message} ({warning.code})\")\n\n        return validation_report\n</code></pre>"},{"location":"features/enhanced-model-validation/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\ud83d\udd27 Dependency Injection - Service registration for validators</li> <li>\ud83d\udd04 Case Conversion Utilities - Model field transformations</li> <li>\ud83d\udce8 CQRS &amp; Mediation - Command validation patterns</li> <li>\ud83c\udf10 HTTP Service Client - Request/response validation</li> <li>\ud83d\udcc1 Data Access - Data persistence validation</li> </ul> <p>The Enhanced Model Validation system provides comprehensive data integrity enforcement throughout Mario's Pizzeria application. Through business rules, contextual validation, and detailed error reporting, the system ensures reliable operations while providing clear feedback for resolution of validation issues.</p>"},{"location":"features/event-sourcing/","title":"\ud83c\udfaf Event Sourcing","text":"<p>Event Sourcing is a data storage pattern where state changes are stored as a sequence of immutable events rather than updating data in place. Neuroglia provides comprehensive event sourcing support with EventStoreDB integration, aggregate root patterns, and event-driven projections.</p>"},{"location":"features/event-sourcing/#overview","title":"\ud83c\udfaf Overview","text":"<p>Event Sourcing offers several key benefits:</p> <ul> <li>Complete Audit Trail: Every state change is captured as an immutable event</li> <li>Temporal Queries: Query system state at any point in time</li> <li>Event Replay: Reconstruct current state by replaying events</li> <li>Business Intelligence: Analyze patterns and trends from event streams</li> <li>Debugging: Full visibility into how state changes occurred</li> <li>Scalability: Events can be replayed to create optimized read models</li> </ul>"},{"location":"features/event-sourcing/#core-concepts","title":"\ud83c\udfd7\ufe0f Core Concepts","text":""},{"location":"features/event-sourcing/#events-as-source-of-truth","title":"Events as Source of Truth","text":"<p>In traditional systems, current state is stored directly:</p> <pre><code># Traditional approach - current state only\nclass BankAccount:\n    def __init__(self, id: str, balance: Decimal):\n        self.id = id\n        self.balance = balance  # Current state stored directly\n\n    def withdraw(self, amount: Decimal):\n        self.balance -= amount  # State updated in place\n</code></pre> <p>With Event Sourcing, we store the events that led to the current state:</p> <pre><code># Event Sourcing approach - events as source of truth\nclass BankAccountCreatedEvent(DomainEvent[str]):\n    def __init__(self, account_id: str, initial_balance: Decimal):\n        super().__init__(account_id)\n        self.initial_balance = initial_balance\n\nclass MoneyWithdrawnEvent(DomainEvent[str]):\n    def __init__(self, account_id: str, amount: Decimal):\n        super().__init__(account_id)\n        self.amount = amount\n\nclass BankAccount(AggregateRoot[BankAccountState, str]):\n    def __init__(self, id: str, initial_balance: Decimal):\n        super().__init__()\n        self.state.on(self.register_event(BankAccountCreatedEvent(id, initial_balance)))\n\n    def withdraw(self, amount: Decimal):\n        if self.state.balance &lt; amount:\n            raise InsufficientFundsException()\n        self.state.on(self.register_event(MoneyWithdrawnEvent(self.state.id, amount)))\n</code></pre>"},{"location":"features/event-sourcing/#state-reconstruction-from-events","title":"State Reconstruction from Events","text":"<p>Current state is derived by applying events in sequence using the <code>@dispatch</code> decorator:</p> <pre><code>from neuroglia.data.abstractions import AggregateRoot, DomainEvent\nfrom neuroglia.mapping.mapper import map_to\nfrom decimal import Decimal\nfrom multipledispatch import dispatch\n\nclass BankAccountCreatedDomainEventV1(DomainEvent[str]):\n    def __init__(self, aggregate_id: str, owner_id: str, overdraft_limit: Decimal):\n        super().__init__(aggregate_id)\n        self.owner_id = owner_id\n        self.overdraft_limit = overdraft_limit\n\nclass BankAccountTransactionRecordedDomainEventV1(DomainEvent[str]):\n    def __init__(self, aggregate_id: str, transaction_id: str, amount: Decimal):\n        super().__init__(aggregate_id)\n        self.transaction_id = transaction_id\n        self.amount = amount\n\nclass BankAccountV1(AggregateRoot[str]):\n    def __init__(self, account_id: str = None):\n        super().__init__(account_id)\n        self._balance = Decimal('0.00')\n        self._owner_id = \"\"\n        self._overdraft_limit = Decimal('0.00')\n\n    @property\n    def balance(self) -&gt; Decimal:\n        return self._balance\n\n    @dispatch(BankAccountCreatedDomainEventV1)\n    def state_manager(self, event: BankAccountCreatedDomainEventV1):\n        \"\"\"Handle account creation for state reconstruction\"\"\"\n        self._owner_id = event.owner_id\n        self._overdraft_limit = event.overdraft_limit\n\n    @dispatch(BankAccountTransactionRecordedDomainEventV1)\n    def state_manager(self, event: BankAccountTransactionRecordedDomainEventV1):\n        \"\"\"Handle transaction recording for state reconstruction\"\"\"\n        self._balance += event.amount\n</code></pre>"},{"location":"features/event-sourcing/#aggregate-root-pattern","title":"\ud83d\ude80 Aggregate Root Pattern","text":""},{"location":"features/event-sourcing/#defining-aggregates","title":"Defining Aggregates","text":"<p>Aggregates are domain objects that encapsulate business logic and raise domain events:</p> <pre><code>from neuroglia.data.abstractions import AggregateRoot, AggregateState, DomainEvent\nfrom decimal import Decimal\nfrom datetime import datetime\nimport uuid\n\nclass BankAccountV1(AggregateRoot[BankAccountState, str]):\n    \"\"\"Bank Account aggregate with event sourcing\"\"\"\n\n    def __init__(self, owner: Person, initial_balance: Decimal):\n        super().__init__()\n\n        # Validate business rules\n        if initial_balance &lt; Decimal('0.00'):\n            raise InvalidInitialBalanceException(\"Initial balance cannot be negative\")\n\n        # Register creation event and apply to state\n        self.state.on(self.register_event(BankAccountCreatedDomainEventV1(\n            aggregate_id=str(uuid.uuid4()).replace('-', ''),\n            owner_id=owner.id(),\n            initial_balance=initial_balance,\n            created_at=datetime.utcnow()\n        )))\n\n    def get_available_balance(self) -&gt; Decimal:\n        \"\"\"Get the available balance including overdraft\"\"\"\n        return Decimal(self.state.balance) + Decimal(self.state.overdraft_limit)\n\n    def try_add_transaction(self, transaction: BankTransactionV1) -&gt; bool:\n        \"\"\"Record a financial transaction\"\"\"\n\n        # Business rule validation  \n        if (transaction.type != BankTransactionTypeV1.DEPOSIT and \n            transaction.type != BankTransactionTypeV1.INTEREST and \n            not (transaction.type == BankTransactionTypeV1.TRANSFER and transaction.to_account_id == self.id()) and \n            transaction.amount &gt; self.get_available_balance()):\n            return False\n\n        # Register transaction event and apply to state\n        self.state.on(self.register_event(BankAccountTransactionRecordedDomainEventV1(\n            self.id(), transaction\n        )))\n        return True\n\n    def set_overdraft_limit(self, limit: Decimal):\n        \"\"\"Set the overdraft limit for the account\"\"\"\n        if limit &lt; Decimal('0.00'):\n            raise InvalidOverdraftLimitException(\"Overdraft limit cannot be negative\")\n\n        self.state.on(self.register_event(OverdraftLimitChangedDomainEventV1(\n            aggregate_id=self.state.id,\n            old_limit=self.state.overdraft_limit,\n            new_limit=limit\n        )))\n\n    def close_account(self, reason: str):\n        \"\"\"Close the bank account\"\"\"\n        if self.state.balance != Decimal('0.00'):\n            raise AccountHasBalanceException(\"Cannot close account with non-zero balance\")\n\n        self.state.on(self.register_event(BankAccountClosedDomainEventV1(\n            aggregate_id=self.state.id,\n            reason=reason,\n            final_balance=self.state.balance\n        )))\n</code></pre>"},{"location":"features/event-sourcing/#aggregate-state-management","title":"Aggregate State Management","text":"<p>The aggregate manages its internal state through event application:</p> <pre><code>from multipledispatch import dispatch\nfrom decimal import Decimal\nfrom typing import List\n\nclass BankAccountV1(AggregateRoot[str]):\n    \"\"\"Bank Account aggregate with event sourcing\"\"\"\n\n    def __init__(self, account_id: str = None):\n        super().__init__(account_id)\n        self._balance = Decimal('0.00')\n        self._overdraft_limit = Decimal('0.00')\n        self._owner_id = \"\"\n        self._is_closed = False\n        self._transactions = []\n\n    @property\n    def balance(self) -&gt; Decimal:\n        return self._balance\n\n    @property\n    def owner_id(self) -&gt; str:\n        return self._owner_id\n\n    @property\n    def overdraft_limit(self) -&gt; Decimal:\n        return self._overdraft_limit\n\n    @dispatch(BankAccountCreatedDomainEventV1)\n    def state_manager(self, event: BankAccountCreatedDomainEventV1):\n        \"\"\"Handle account creation\"\"\"\n        self._owner_id = event.owner_id\n        self._overdraft_limit = event.overdraft_limit\n\n    @dispatch(BankAccountTransactionRecordedDomainEventV1)\n    def state_manager(self, event: BankAccountTransactionRecordedDomainEventV1):\n        \"\"\"Handle transaction recording\"\"\"\n        # Update balance based on transaction amount\n        self._balance += event.amount\n        self.last_modified = event.timestamp\n\n    @dispatch(OverdraftLimitChangedDomainEventV1)\n    def on(self, event: OverdraftLimitChangedDomainEventV1):\n        \"\"\"Handle overdraft limit changes\"\"\"\n        self.overdraft_limit = event.new_limit\n        self.last_modified = event.timestamp\n\n    @dispatch(BankAccountClosedDomainEventV1)\n    def on(self, event: BankAccountClosedDomainEventV1):\n        \"\"\"Handle account closure\"\"\"\n        self.is_closed = True\n        self.last_modified = event.timestamp\n</code></pre>"},{"location":"features/event-sourcing/#event-store-configuration","title":"\ud83c\udfea Event Store Configuration","text":""},{"location":"features/event-sourcing/#eventstoredb-setup","title":"EventStoreDB Setup","text":"<p>Configure EventStoreDB as the event storage backend:</p> <pre><code>from neuroglia.data.infrastructure.event_sourcing.event_store import ESEventStore\nfrom neuroglia.data.infrastructure.event_sourcing.abstractions import EventStoreOptions\nfrom neuroglia.hosting.web import WebApplicationBuilder\n\ndef configure_event_store(builder: WebApplicationBuilder):\n    \"\"\"Configure EventStoreDB for event sourcing\"\"\"\n\n    # Event store configuration\n    database_name = \"bankingsystem\"\n    consumer_group = \"banking-api-v1\"\n\n    ESEventStore.configure(\n        builder, \n        EventStoreOptions(\n            database_name=database_name,\n            consumer_group=consumer_group,\n            connection_string=\"esdb://localhost:2113?tls=false\",\n            credentials={\"username\": \"admin\", \"password\": \"changeit\"}\n        )\n    )\n\n    # Configure event sourcing repository for write model\n    EventSourcingRepository.configure(builder, BankAccountV1, str)\n\n    return builder\n</code></pre>"},{"location":"features/event-sourcing/#repository-configuration","title":"Repository Configuration","text":"<p>Set up separate repositories for write and read models:</p> <pre><code>from neuroglia.hosting.configuration.data_access_layer import DataAccessLayer\nfrom neuroglia.data.infrastructure.event_sourcing.event_sourcing_repository import EventSourcingRepository\nfrom neuroglia.data.infrastructure.mongo.mongo_repository import MongoRepository\n\ndef configure_data_access(builder: WebApplicationBuilder):\n    \"\"\"Configure write and read model repositories\"\"\"\n\n    # Write Model: Event-sourced aggregates\n    DataAccessLayer.WriteModel.configure(\n        builder,\n        [\"samples.banking.domain.models\"],  # Domain aggregate modules\n        lambda builder_, entity_type, key_type: EventSourcingRepository.configure(\n            builder_, entity_type, key_type\n        )\n    )\n\n    # Read Model: MongoDB projections\n    DataAccessLayer.ReadModel.configure(\n        builder,\n        [\"samples.banking.integration.models\"],  # Read model modules\n        lambda builder_, entity_type, key_type: MongoRepository.configure(\n            builder_, entity_type, key_type, database_name=\"banking_read_models\"\n        )\n    )\n\n    return builder\n</code></pre>"},{"location":"features/event-sourcing/#event-driven-projections","title":"\ud83d\udcca Event-Driven Projections","text":""},{"location":"features/event-sourcing/#creating-read-model-projections","title":"Creating Read Model Projections","text":"<p>Transform domain events into optimized read models:</p> <pre><code>from neuroglia.eventing import event_handler\n\nclass BankAccountProjectionHandler:\n    \"\"\"Handles domain events to update read model projections\"\"\"\n\n    def __init__(self, read_repository: Repository[BankAccountProjection, str]):\n        self.read_repository = read_repository\n\n    @event_handler(BankAccountCreatedDomainEventV1)\n    async def handle_account_created(self, event: BankAccountCreatedDomainEventV1):\n        \"\"\"Create read model projection when account is created\"\"\"\n\n        projection = BankAccountProjection(\n            id=event.aggregate_id,\n            owner_id=event.owner_id,\n            balance=event.initial_balance,\n            overdraft_limit=Decimal('0.00'),\n            status=\"ACTIVE\",\n            created_at=event.created_at,\n            last_modified=event.created_at,\n            transaction_count=0,\n            last_transaction_at=None\n        )\n\n        await self.read_repository.add_async(projection)\n\n    @event_handler(BankAccountTransactionRecordedDomainEventV1)\n    async def handle_transaction_recorded(self, event: BankAccountTransactionRecordedDomainEventV1):\n        \"\"\"Update projection when transaction is recorded\"\"\"\n\n        projection = await self.read_repository.get_by_id_async(event.aggregate_id)\n        if projection:\n            projection.balance += event.amount\n            projection.transaction_count += 1\n            projection.last_transaction_at = event.timestamp\n            projection.last_modified = event.timestamp\n\n            await self.read_repository.update_async(projection)\n\n    @event_handler(BankAccountClosedDomainEventV1)\n    async def handle_account_closed(self, event: BankAccountClosedDomainEventV1):\n        \"\"\"Update projection when account is closed\"\"\"\n\n        projection = await self.read_repository.get_by_id_async(event.aggregate_id)\n        if projection:\n            projection.status = \"CLOSED\"\n            projection.last_modified = event.timestamp\n\n            await self.read_repository.update_async(projection)\n</code></pre>"},{"location":"features/event-sourcing/#read-model-optimization","title":"Read Model Optimization","text":"<p>Design read models for specific query patterns:</p> <pre><code>@dataclass\nclass BankAccountProjection:\n    \"\"\"Optimized read model for bank account queries\"\"\"\n\n    id: str\n    owner_id: str\n    balance: Decimal\n    overdraft_limit: Decimal\n    status: str  # ACTIVE, CLOSED, SUSPENDED\n    created_at: datetime\n    last_modified: datetime\n    transaction_count: int\n    last_transaction_at: Optional[datetime]\n\n    # Denormalized owner information for efficient queries\n    owner_name: Optional[str] = None\n    owner_email: Optional[str] = None\n\n    # Aggregated transaction data\n    total_debits: Decimal = Decimal('0.00')\n    total_credits: Decimal = Decimal('0.00')\n    largest_transaction: Decimal = Decimal('0.00')\n\n@dataclass\nclass AccountSummaryProjection:\n    \"\"\"Summary projection for dashboard queries\"\"\"\n\n    owner_id: str\n    total_accounts: int\n    total_balance: Decimal\n    active_accounts: int\n    closed_accounts: int\n    last_activity: datetime\n</code></pre>"},{"location":"features/event-sourcing/#temporal-queries","title":"\ud83d\udd70\ufe0f Temporal Queries","text":""},{"location":"features/event-sourcing/#point-in-time-state-reconstruction","title":"Point-in-Time State Reconstruction","text":"<p>Query aggregate state at any specific point in time:</p> <pre><code>class TemporalQueryService:\n    \"\"\"Service for temporal queries on event-sourced aggregates\"\"\"\n\n    def __init__(self, event_store: EventStore, aggregator: Aggregator):\n        self.event_store = event_store\n        self.aggregator = aggregator\n\n    async def get_account_balance_at_date(self, account_id: str, as_of_date: datetime) -&gt; Decimal:\n        \"\"\"Get account balance as it was at a specific date\"\"\"\n\n        stream_id = f\"BankAccount-{account_id}\"\n\n        # Read events up to the specified date\n        events = await self.event_store.read_async(\n            stream_id,\n            direction=StreamReadDirection.FORWARDS,\n            from_position=0,\n            to_date=as_of_date\n        )\n\n        # Reconstruct state at that point in time\n        account = self.aggregator.aggregate(events, BankAccountV1)\n        return account.state.balance if account else Decimal('0.00')\n\n    async def get_transaction_history_between_dates(\n        self, \n        account_id: str, \n        from_date: datetime, \n        to_date: datetime\n    ) -&gt; List[BankTransactionV1]:\n        \"\"\"Get all transactions within a date range\"\"\"\n\n        stream_id = f\"BankAccount-{account_id}\"\n\n        events = await self.event_store.read_async(\n            stream_id,\n            direction=StreamReadDirection.FORWARDS,\n            from_date=from_date,\n            to_date=to_date\n        )\n\n        transactions = []\n        for event_record in events:\n            if isinstance(event_record.data, BankAccountTransactionRecordedDomainEventV1):\n                transaction = BankTransactionV1(\n                    id=event_record.data.transaction_id,\n                    amount=event_record.data.amount,\n                    type=event_record.data.transaction_type,\n                    recorded_at=event_record.data.timestamp\n                )\n                transactions.append(transaction)\n\n        return transactions\n</code></pre>"},{"location":"features/event-sourcing/#business-intelligence-queries","title":"Business Intelligence Queries","text":"<p>Analyze historical data patterns:</p> <pre><code>class BusinessIntelligenceService:\n    \"\"\"Service for analyzing business patterns from events\"\"\"\n\n    def __init__(self, event_store: EventStore):\n        self.event_store = event_store\n\n    async def get_transaction_analytics(\n        self, \n        from_date: datetime, \n        to_date: datetime\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Analyze transaction patterns over time\"\"\"\n\n        # Query all transaction events in date range\n        events = await self.event_store.get_events_by_type_async(\n            BankAccountTransactionRecordedDomainEventV1,\n            from_date=from_date,\n            to_date=to_date\n        )\n\n        if not events:\n            return {\"message\": \"No transactions found in date range\"}\n\n        # Calculate analytics\n        total_transactions = len(events)\n        total_amount = sum(e.amount for e in events)\n        debit_transactions = [e for e in events if e.amount &lt; 0]\n        credit_transactions = [e for e in events if e.amount &gt; 0]\n\n        return {\n            \"period\": {\"from\": from_date.isoformat(), \"to\": to_date.isoformat()},\n            \"total_transactions\": total_transactions,\n            \"total_amount\": float(total_amount),\n            \"average_transaction\": float(total_amount / total_transactions),\n            \"debit_count\": len(debit_transactions),\n            \"credit_count\": len(credit_transactions),\n            \"largest_debit\": float(min(e.amount for e in debit_transactions)) if debit_transactions else 0,\n            \"largest_credit\": float(max(e.amount for e in credit_transactions)) if credit_transactions else 0,\n            \"daily_breakdown\": self._calculate_daily_breakdown(events, from_date, to_date)\n        }\n\n    def _calculate_daily_breakdown(self, events: List[BankAccountTransactionRecordedDomainEventV1], from_date: datetime, to_date: datetime) -&gt; List[Dict]:\n        \"\"\"Calculate daily transaction breakdown\"\"\"\n        daily_data = {}\n\n        for event in events:\n            day_key = event.timestamp.date().isoformat()\n            if day_key not in daily_data:\n                daily_data[day_key] = {\"count\": 0, \"amount\": Decimal('0.00')}\n\n            daily_data[day_key][\"count\"] += 1\n            daily_data[day_key][\"amount\"] += event.amount\n\n        return [\n            {\n                \"date\": date,\n                \"transaction_count\": data[\"count\"],\n                \"total_amount\": float(data[\"amount\"])\n            }\n            for date, data in sorted(daily_data.items())\n        ]\n</code></pre>"},{"location":"features/event-sourcing/#testing-event-sourced-systems","title":"\ud83e\uddea Testing Event-Sourced Systems","text":""},{"location":"features/event-sourcing/#unit-testing-aggregates","title":"Unit Testing Aggregates","text":"<p>Test business logic by verifying events are raised correctly:</p> <pre><code>import pytest\nfrom decimal import Decimal\n\nclass TestBankAccountAggregate:\n    \"\"\"Unit tests for BankAccount aggregate\"\"\"\n\n    def test_account_creation_raises_creation_event(self):\n        \"\"\"Test that creating an account raises the correct event\"\"\"\n        account = BankAccountV1()\n        owner_id = \"john-doe-123\"\n        overdraft_limit = Decimal(\"1000.00\")\n\n        account.create_account(owner_id, overdraft_limit)\n\n        events = account._pending_events\n\n        assert len(events) == 1\n        assert isinstance(events[0], BankAccountCreatedDomainEventV1)\n        assert events[0].owner_id == owner_id\n        assert events[0].overdraft_limit == overdraft_limit\n\n    def test_transaction_recording_updates_balance_and_raises_event(self):\n        \"\"\"Test that recording a transaction updates balance and raises event\"\"\"\n        account = self._create_test_account()\n\n        # Create a transaction using the actual method signature\n        transaction_id = \"trans-123\"\n        amount = Decimal(\"100.00\")\n\n        result = account.try_add_transaction(transaction_id, amount)\n\n        # Verify transaction was accepted\n        assert result == True\n\n        # Verify event was registered\n        events = account._pending_events\n        transaction_events = [e for e in events if isinstance(e, BankAccountTransactionRecordedDomainEventV1)]\n\n        assert len(transaction_events) == 1\n\n    def test_insufficient_funds_raises_exception(self):\n        \"\"\"Test that insufficient funds rejects transaction\"\"\"\n        account = self._create_test_account()\n\n        # Create transaction that exceeds available balance\n        large_transaction = BankTransactionV1(\n            type=BankTransactionTypeV1.WITHDRAWAL,\n            amount=Decimal(\"2000.00\"),  # More than available balance\n            from_account_id=account.id(),\n            to_account_id=None\n        )\n\n        result = account.try_add_transaction(large_transaction)\n\n        # Verify transaction was rejected\n        assert result == False\n\n        # Verify no event was registered\n        events = account._pending_events\n        transaction_events = [e for e in events if isinstance(e, BankAccountTransactionRecordedDomainEventV1)]\n        assert len(transaction_events) == 0\n\n    def test_state_reconstruction_from_events(self):\n        \"\"\"Test that aggregate state can be reconstructed from events\"\"\"\n\n        # Create aggregate\n        account = BankAccountV1()\n\n        # Create and apply events directly to simulate repository loading\n        creation_event = BankAccountCreatedDomainEventV1(\n            aggregate_id=account.id,\n            owner_id=\"owner-123\",\n            overdraft_limit=Decimal(\"500.00\")\n        )\n\n        transaction_event = BankAccountTransactionRecordedDomainEventV1(\n            aggregate_id=account.id,\n            transaction_id=\"trans-123\",\n            amount=Decimal(\"100.00\")\n        )\n\n        # Apply events to reconstruct state\n        account.state_manager(creation_event)\n        account.state_manager(transaction_event)\n\n        # Verify state reconstruction\n        assert account.owner_id == \"owner-123\"\n        assert account.overdraft_limit == Decimal(\"500.00\")\n        assert account.balance == Decimal(\"100.00\")\n\n    def _create_test_account(self) -&gt; BankAccountV1:\n        \"\"\"Helper method to create a test account\"\"\"\n        account = BankAccountV1()\n        account.create_account(\"test-owner\", Decimal(\"1000.00\"))\n        # Clear pending events for clean testing\n        account._pending_events.clear()\n        return account\n</code></pre>"},{"location":"features/event-sourcing/#integration-testing-with-event-store","title":"Integration Testing with Event Store","text":"<p>Test the complete event sourcing workflow:</p> <pre><code>@pytest.mark.integration\nclass TestEventSourcingIntegration:\n    \"\"\"Integration tests for event sourcing workflow\"\"\"\n\n    @pytest.fixture\n    async def event_store(self):\n        \"\"\"Create test event store\"\"\"\n        options = EventStoreOptions(\n            database_name=\"test_banking\",\n            consumer_group=\"test_group\",\n            connection_string=\"esdb://localhost:2113?tls=false\"\n        )\n        # Return configured event store for testing\n        pass\n\n    @pytest.fixture\n    async def repository(self, event_store):\n        \"\"\"Create test repository\"\"\"\n        aggregator = Aggregator()\n        return EventSourcingRepository(event_store, aggregator)\n\n    @pytest.mark.asyncio\n    async def test_complete_aggregate_lifecycle(self, repository):\n        \"\"\"Test complete aggregate lifecycle with persistence\"\"\"\n\n        # Create aggregate\n        owner = Person(\"integration@test.com\", \"Integration\", \"Test\")\n        account = BankAccountV1(owner, Decimal(\"1000.00\"))\n\n        # Save to event store\n        saved_account = await repository.add_async(account)\n        assert saved_account.state.state_version &gt; 0\n\n        # Load from event store\n        loaded_account = await repository.get_async(saved_account.id())\n        assert loaded_account is not None\n        assert loaded_account.state.balance == Decimal(\"1000.00\")\n        assert loaded_account.state.owner_id == owner.id()\n\n        # Modify and save again\n        transaction = BankTransactionV1(\n            type=BankTransactionTypeV1.WITHDRAWAL,\n            amount=Decimal(\"200.00\"),\n            from_account_id=loaded_account.id(),\n            to_account_id=None\n        )\n        loaded_account.try_add_transaction(transaction)\n        updated_account = await repository.update_async(loaded_account)\n\n        # Verify persistence\n        final_account = await repository.get_async(updated_account.id())\n        assert len(final_account.state.transactions) == 1\n\n    @pytest.mark.asyncio\n    async def test_concurrent_modifications_throw_concurrency_exception(self, repository):\n        \"\"\"Test that concurrent modifications are detected\"\"\"\n\n        # Create and save account\n        owner = Person(\"concurrent@test.com\", \"Concurrent\", \"Test\")\n        account = BankAccountV1(owner, Decimal(\"1000.00\"))\n        saved_account = await repository.add_async(account)\n        account_id = saved_account.id()\n\n        # Load same account in two instances\n        account1 = await repository.get_async(account_id)\n        account2 = await repository.get_async(account_id)\n\n        # Modify both\n        transaction1 = BankTransactionV1(BankTransactionTypeV1.WITHDRAWAL, Decimal(\"100.00\"), account_id, None)\n        transaction2 = BankTransactionV1(BankTransactionTypeV1.WITHDRAWAL, Decimal(\"200.00\"), account_id, None)\n\n        account1.try_add_transaction(transaction1)\n        account2.try_add_transaction(transaction2)\n\n        # Save first modification\n        await repository.update_async(account1)\n\n        # Second modification should fail due to concurrency\n        with pytest.raises(ConcurrencyException):\n            await repository.update_async(account2)\n</code></pre>"},{"location":"features/event-sourcing/#advanced-patterns","title":"\ud83d\udd27 Advanced Patterns","text":""},{"location":"features/event-sourcing/#event-versioning","title":"Event Versioning","text":"<p>Handle evolving event schemas over time:</p> <pre><code># V1 Event\n@dataclass\nclass BankAccountCreatedDomainEventV1(DomainEvent[str]):\n    owner_id: str\n    initial_balance: Decimal\n\n# V2 Event - Added account type\n@dataclass  \nclass BankAccountCreatedDomainEventV2(DomainEvent[str]):\n    owner_id: str\n    initial_balance: Decimal\n    account_type: str  # New field\n\n# Event upcasting for backward compatibility\nclass EventUpcaster:\n    def upcast(self, event_data: dict, event_type: str) -&gt; dict:\n        if event_type == \"BankAccountCreatedDomainEventV1\":\n            # Upcast V1 to V2 by adding default account type\n            event_data[\"account_type\"] = \"CHECKING\"\n            return event_data\n        return event_data\n</code></pre>"},{"location":"features/event-sourcing/#snapshots-for-performance","title":"Snapshots for Performance","text":"<p>Optimize performance for long event streams:</p> <pre><code>@dataclass\nclass BankAccountSnapshot:\n    \"\"\"Snapshot of bank account state for performance optimization\"\"\"\n\n    aggregate_id: str\n    version: int\n    balance: Decimal\n    overdraft_limit: Decimal\n    transaction_count: int\n    created_at: datetime\n    snapshot_at: datetime\n\nclass SnapshotRepository:\n    \"\"\"Repository for managing aggregate snapshots\"\"\"\n\n    async def save_snapshot_async(self, aggregate: BankAccountV1) -&gt; None:\n        \"\"\"Save a snapshot of the current aggregate state\"\"\"\n        snapshot = BankAccountSnapshot(\n            aggregate_id=aggregate.state.id,\n            version=aggregate.state.state_version,\n            balance=aggregate.state.balance,\n            overdraft_limit=aggregate.state.overdraft_limit,\n            transaction_count=len(aggregate.state.transactions),\n            created_at=aggregate.state.created_at,\n            snapshot_at=datetime.utcnow()\n        )\n        await self.repository.add_async(snapshot)\n\n    async def load_from_snapshot_async(self, aggregate_id: str) -&gt; Optional[BankAccountV1]:\n        \"\"\"Load aggregate from latest snapshot plus subsequent events\"\"\"\n        snapshot = await self.get_latest_snapshot_async(aggregate_id)\n        if not snapshot:\n            return None\n\n        # Load events since snapshot\n        events = await self.event_store.read_async(\n            f\"BankAccount-{aggregate_id}\",\n            from_version=snapshot.version + 1\n        )\n\n        # Reconstruct aggregate from snapshot + events\n        aggregate = self._create_from_snapshot(snapshot)\n        self._apply_events(aggregate, events)\n\n        return aggregate\n</code></pre>"},{"location":"features/event-sourcing/#saga-pattern-for-distributed-transactions","title":"Saga Pattern for Distributed Transactions","text":"<p>Coordinate long-running business processes:</p> <pre><code>class MoneyTransferSaga:\n    \"\"\"Saga for coordinating money transfers between accounts\"\"\"\n\n    @saga_step\n    async def debit_source_account(self, transfer_id: str, source_account_id: str, amount: Decimal):\n        \"\"\"Step 1: Debit the source account\"\"\"\n        command = DebitAccountCommand(source_account_id, amount, transfer_id)\n        result = await self.mediator.execute_async(command)\n\n        if result.is_success:\n            await self.complete_step(\"debit_source\", transfer_id)\n        else:\n            await self.compensate_transfer(transfer_id, \"Failed to debit source account\")\n\n    @saga_step\n    async def credit_target_account(self, transfer_id: str, target_account_id: str, amount: Decimal):\n        \"\"\"Step 2: Credit the target account\"\"\"\n        command = CreditAccountCommand(target_account_id, amount, transfer_id)\n        result = await self.mediator.execute_async(command)\n\n        if result.is_success:\n            await self.complete_saga(transfer_id)\n        else:\n            await self.compensate_debit(transfer_id, source_account_id, amount)\n\n    @compensating_action\n    async def compensate_debit(self, transfer_id: str, account_id: str, amount: Decimal):\n        \"\"\"Compensate by crediting back the debited amount\"\"\"\n        compensation_command = CreditAccountCommand(account_id, amount, f\"compensation-{transfer_id}\")\n        await self.mediator.execute_async(compensation_command)\n</code></pre>"},{"location":"features/event-sourcing/#monitoring-and-observability","title":"\ud83d\udcca Monitoring and Observability","text":""},{"location":"features/event-sourcing/#event-stream-health-monitoring","title":"Event Stream Health Monitoring","text":"<p>Monitor the health of your event streams:</p> <pre><code>class EventStoreHealthService:\n    \"\"\"Service for monitoring event store health\"\"\"\n\n    async def get_stream_statistics(self, stream_id: str) -&gt; Dict[str, Any]:\n        \"\"\"Get statistics for a specific event stream\"\"\"\n        descriptor = await self.event_store.get_stream_descriptor_async(stream_id)\n\n        return {\n            \"stream_id\": stream_id,\n            \"event_count\": descriptor.length,\n            \"first_event_at\": descriptor.first_event_at.isoformat() if descriptor.first_event_at else None,\n            \"last_event_at\": descriptor.last_event_at.isoformat() if descriptor.last_event_at else None,\n            \"stream_age_days\": (datetime.utcnow() - descriptor.first_event_at).days if descriptor.first_event_at else 0\n        }\n\n    async def detect_problematic_streams(self, max_age_days: int = 30) -&gt; List[str]:\n        \"\"\"Detect streams that haven't had events for a long time\"\"\"\n        all_streams = await self.event_store.list_streams_async()\n        problematic_streams = []\n\n        for stream_id in all_streams:\n            descriptor = await self.event_store.get_stream_descriptor_async(stream_id)\n            if descriptor.last_event_at:\n                age = (datetime.utcnow() - descriptor.last_event_at).days\n                if age &gt; max_age_days:\n                    problematic_streams.append(stream_id)\n\n        return problematic_streams\n</code></pre>"},{"location":"features/event-sourcing/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Data Access - Repository patterns and data persistence</li> <li>CQRS &amp; Mediation - Command/Query separation patterns  </li> <li>Domain Events - Domain event modeling</li> <li>OpenBank Sample - Complete event sourcing implementation</li> <li>Testing Strategies - Testing event-sourced systems</li> </ul>"},{"location":"features/event-sourcing/#best-practices","title":"\ud83c\udfaf Best Practices","text":""},{"location":"features/event-sourcing/#dos","title":"Do's \u2705","text":"<ul> <li>Design events as immutable facts - Events represent what happened, not what should happen</li> <li>Use meaningful event names - Events should clearly describe business occurrences</li> <li>Keep events focused - Each event should represent a single business fact</li> <li>Version your events - Plan for schema evolution from the beginning</li> <li>Test event handlers thoroughly - Ensure state transitions work correctly</li> <li>Monitor stream health - Track stream growth and performance metrics</li> </ul>"},{"location":"features/event-sourcing/#donts","title":"Don'ts \u274c","text":"<ul> <li>Don't modify events - Events are immutable historical facts</li> <li>Don't make events too granular - Avoid events for every minor state change</li> <li>Don't ignore concurrency - Handle concurrent modifications appropriately</li> <li>Don't skip snapshots - Use snapshots for performance with long streams</li> <li>Don't forget about eventual consistency - Read models may lag behind write models</li> <li>Don't ignore event ordering - Event sequence matters for state reconstruction</li> </ul> <p>Event Sourcing provides powerful capabilities for building auditable, scalable, and maintainable systems. The Neuroglia framework makes it straightforward to implement event sourcing patterns while maintaining clean architecture principles.</p>"},{"location":"features/http-service-client/","title":"\ud83c\udf10 HTTP Service Client","text":"<p>The Neuroglia framework provides enterprise-grade HTTP client capabilities with advanced resilience patterns, enabling reliable communication with external services through circuit breakers, retry policies, and comprehensive request/response interception.</p>"},{"location":"features/http-service-client/#overview","title":"\ud83c\udfaf Overview","text":"<p>Modern microservices rely heavily on external service communication for payment processing, third-party APIs, and inter-service coordination. The framework's HTTP client implementation provides:</p> <ul> <li>Circuit Breaker Pattern: Protection against cascading failures</li> <li>Retry Policies: Configurable retry strategies with exponential backoff</li> <li>Request/Response Interception: Middleware for authentication, logging, and monitoring</li> <li>Connection Pooling: Optimized HTTP connection management</li> <li>Timeout Management: Configurable timeouts for different scenarios</li> <li>Request/Response Validation: Automatic data validation and transformation</li> </ul>"},{"location":"features/http-service-client/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>graph TB\n    subgraph \"\ud83c\udf55 Mario's Pizzeria Services\"\n        OrderService[Order Service]\n        PaymentService[Payment Service]\n        DeliveryService[Delivery Service]\n        NotificationService[Notification Service]\n    end\n\n    subgraph \"\ud83c\udf10 HTTP Service Client\"\n        HttpClient[HTTP Client Manager]\n        CircuitBreaker[Circuit Breaker]\n        RetryPolicy[Retry Policy]\n        Interceptors[Request/Response Interceptors]\n    end\n\n    subgraph \"\ud83d\udd0c External Services\"\n        PaymentGateway[Payment Gateway API]\n        DeliveryAPI[Delivery Tracking API]\n        EmailService[Email Service API]\n        SMSService[SMS Service API]\n    end\n\n    OrderService --&gt; HttpClient\n    PaymentService --&gt; HttpClient\n    DeliveryService --&gt; HttpClient\n    NotificationService --&gt; HttpClient\n\n    HttpClient --&gt; CircuitBreaker\n    HttpClient --&gt; RetryPolicy\n    HttpClient --&gt; Interceptors\n\n    CircuitBreaker --&gt; PaymentGateway\n    CircuitBreaker --&gt; DeliveryAPI\n    CircuitBreaker --&gt; EmailService\n    CircuitBreaker --&gt; SMSService\n\n    style HttpClient fill:#e3f2fd\n    style CircuitBreaker fill:#ffebee\n    style RetryPolicy fill:#e8f5e8\n    style Interceptors fill:#fff3e0</code></pre>"},{"location":"features/http-service-client/#basic-usage","title":"\ud83d\ude80 Basic Usage","text":""},{"location":"features/http-service-client/#service-registration","title":"Service Registration","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.http import HttpServiceClient, HttpClientConfig\n\ndef create_app():\n    builder = WebApplicationBuilder()\n\n    # Register HTTP service client\n    http_config = HttpClientConfig(\n        base_timeout=30.0,\n        connection_timeout=5.0,\n        max_connections=100,\n        max_connections_per_host=20,\n        enable_circuit_breaker=True,\n        enable_retry_policy=True\n    )\n\n    builder.services.add_http_service_client(http_config)\n\n    app = builder.build()\n    return app\n</code></pre>"},{"location":"features/http-service-client/#simple-http-operations","title":"Simple HTTP Operations","text":"<pre><code>from neuroglia.http import HttpServiceClient\nfrom neuroglia.dependency_injection import ServiceProviderBase\nfrom typing import Optional\n\nclass PaymentGatewayService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.http_client = service_provider.get_service(HttpServiceClient)\n        self.base_url = \"https://api.payment-gateway.com/v1\"\n        self.api_key = \"your_api_key_here\"\n\n    async def charge_customer(self, order_id: str, amount: float, currency: str = \"USD\") -&gt; dict:\n        \"\"\"Charge customer payment through external gateway.\"\"\"\n\n        payment_request = {\n            \"order_id\": order_id,\n            \"amount\": amount,\n            \"currency\": currency,\n            \"description\": f\"Mario's Pizzeria Order {order_id}\",\n            \"metadata\": {\n                \"restaurant\": \"marios_pizzeria\",\n                \"order_type\": \"online\"\n            }\n        }\n\n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\",\n            \"X-Idempotency-Key\": f\"order_{order_id}\"\n        }\n\n        try:\n            response = await self.http_client.post_async(\n                url=f\"{self.base_url}/charges\",\n                json=payment_request,\n                headers=headers,\n                timeout=15.0\n            )\n\n            if response.is_success:\n                print(f\"\ud83d\udcb3 Payment successful for order {order_id}: ${amount}\")\n                return response.json()\n            else:\n                print(f\"\u274c Payment failed for order {order_id}: {response.status_code}\")\n                raise PaymentProcessingError(f\"Payment failed: {response.text}\")\n\n        except Exception as e:\n            print(f\"\ud83d\udca5 Payment service error: {e}\")\n            raise PaymentServiceUnavailableError(f\"Cannot process payment: {e}\")\n\n    async def refund_payment(self, charge_id: str, amount: Optional[float] = None) -&gt; dict:\n        \"\"\"Process refund through payment gateway.\"\"\"\n\n        refund_request = {\n            \"charge_id\": charge_id,\n            \"reason\": \"customer_request\"\n        }\n\n        if amount:\n            refund_request[\"amount\"] = amount\n\n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n\n        response = await self.http_client.post_async(\n            url=f\"{self.base_url}/refunds\",\n            json=refund_request,\n            headers=headers\n        )\n\n        if response.is_success:\n            refund_data = response.json()\n            print(f\"\ud83d\udcb0 Refund processed: {refund_data['refund_id']}\")\n            return refund_data\n        else:\n            raise RefundProcessingError(f\"Refund failed: {response.text}\")\n</code></pre>"},{"location":"features/http-service-client/#circuit-breaker-pattern","title":"\ud83d\udd04 Circuit Breaker Pattern","text":""},{"location":"features/http-service-client/#resilient-external-service-integration","title":"Resilient External Service Integration","text":"<pre><code>from neuroglia.http import CircuitBreakerPolicy, CircuitBreakerState\n\nclass DeliveryTrackingService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.http_client = service_provider.get_service(HttpServiceClient)\n        self.base_url = \"https://api.delivery-service.com/v2\"\n\n        # Configure circuit breaker for delivery API\n        self.circuit_breaker = CircuitBreakerPolicy(\n            failure_threshold=5,        # Open after 5 failures\n            recovery_timeout=60,        # Try recovery after 60 seconds\n            success_threshold=3,        # Close after 3 successful calls\n            timeout=10.0               # Individual request timeout\n        )\n\n    @circuit_breaker.apply\n    async def create_delivery_request(self, order_id: str, delivery_address: dict) -&gt; dict:\n        \"\"\"Create delivery request with circuit breaker protection.\"\"\"\n\n        delivery_request = {\n            \"order_id\": order_id,\n            \"pickup_address\": {\n                \"street\": \"123 Pizza Street\",\n                \"city\": \"Pizza City\",\n                \"zip\": \"12345\"\n            },\n            \"delivery_address\": delivery_address,\n            \"priority\": \"standard\",\n            \"special_instructions\": \"Handle with care - hot pizza!\"\n        }\n\n        try:\n            response = await self.http_client.post_async(\n                url=f\"{self.base_url}/deliveries\",\n                json=delivery_request,\n                timeout=self.circuit_breaker.timeout\n            )\n\n            if response.is_success:\n                delivery_data = response.json()\n                print(f\"\ud83d\ude9a Delivery scheduled: {delivery_data['tracking_id']}\")\n                return delivery_data\n            else:\n                raise DeliveryServiceError(f\"Delivery creation failed: {response.status_code}\")\n\n        except Exception as e:\n            print(f\"\ud83d\udd34 Delivery service unavailable: {e}\")\n            # Circuit breaker will handle this failure\n            raise\n\n    async def get_delivery_status(self, tracking_id: str) -&gt; dict:\n        \"\"\"Get delivery status with fallback handling.\"\"\"\n\n        if self.circuit_breaker.state == CircuitBreakerState.OPEN:\n            # Circuit is open - use fallback\n            return await self.get_fallback_delivery_status(tracking_id)\n\n        try:\n            response = await self.http_client.get_async(\n                url=f\"{self.base_url}/deliveries/{tracking_id}\",\n                timeout=5.0\n            )\n\n            if response.is_success:\n                return response.json()\n            else:\n                return await self.get_fallback_delivery_status(tracking_id)\n\n        except Exception:\n            return await self.get_fallback_delivery_status(tracking_id)\n\n    async def get_fallback_delivery_status(self, tracking_id: str) -&gt; dict:\n        \"\"\"Fallback delivery status when service is unavailable.\"\"\"\n        print(f\"\ud83d\udccb Using fallback status for delivery {tracking_id}\")\n\n        return {\n            \"tracking_id\": tracking_id,\n            \"status\": \"in_transit\",\n            \"estimated_delivery\": \"Service temporarily unavailable\",\n            \"fallback\": True\n        }\n</code></pre>"},{"location":"features/http-service-client/#retry-policies","title":"\ud83d\udd04 Retry Policies","text":""},{"location":"features/http-service-client/#configurable-retry-strategies","title":"Configurable Retry Strategies","text":"<pre><code>from neuroglia.http import RetryPolicy, ExponentialBackoff, RetryCondition\n\nclass NotificationService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.http_client = service_provider.get_service(HttpServiceClient)\n\n        # Configure retry policy for notifications\n        self.retry_policy = RetryPolicy(\n            max_attempts=3,\n            backoff_strategy=ExponentialBackoff(\n                initial_delay=1.0,\n                max_delay=30.0,\n                backoff_factor=2.0\n            ),\n            retry_conditions=[\n                RetryCondition.on_timeout(),\n                RetryCondition.on_status_codes([429, 502, 503, 504]),\n                RetryCondition.on_exceptions([ConnectionError, TimeoutError])\n            ]\n        )\n\n    @retry_policy.apply\n    async def send_order_confirmation_email(self, customer_email: str, order_details: dict) -&gt; bool:\n        \"\"\"Send order confirmation email with retry policy.\"\"\"\n\n        email_request = {\n            \"to\": customer_email,\n            \"subject\": f\"\ud83c\udf55 Order Confirmation - #{order_details['order_id']}\",\n            \"template\": \"order_confirmation\",\n            \"variables\": {\n                \"customer_name\": order_details['customer_name'],\n                \"order_id\": order_details['order_id'],\n                \"items\": order_details['items'],\n                \"total_amount\": order_details['total_amount'],\n                \"estimated_delivery\": order_details['estimated_delivery']\n            }\n        }\n\n        response = await self.http_client.post_async(\n            url=\"https://api.email-service.com/v1/send\",\n            json=email_request,\n            headers={\n                \"Authorization\": f\"Bearer {self.get_email_api_key()}\",\n                \"Content-Type\": \"application/json\"\n            },\n            timeout=10.0\n        )\n\n        if response.is_success:\n            print(f\"\ud83d\udce7 Order confirmation sent to {customer_email}\")\n            return True\n        else:\n            error_msg = f\"Failed to send email: {response.status_code} - {response.text}\"\n            print(f\"\u274c {error_msg}\")\n            raise EmailDeliveryError(error_msg)\n\n    @retry_policy.apply\n    async def send_sms_notification(self, phone_number: str, message: str) -&gt; bool:\n        \"\"\"Send SMS notification with retry policy.\"\"\"\n\n        sms_request = {\n            \"to\": phone_number,\n            \"message\": message,\n            \"from\": \"Mario's Pizzeria\"\n        }\n\n        response = await self.http_client.post_async(\n            url=\"https://api.sms-service.com/v1/messages\",\n            json=sms_request,\n            headers={\n                \"Authorization\": f\"Bearer {self.get_sms_api_key()}\",\n                \"Content-Type\": \"application/json\"\n            }\n        )\n\n        if response.is_success:\n            print(f\"\ud83d\udcf1 SMS sent to {phone_number}\")\n            return True\n        else:\n            raise SMSDeliveryError(f\"SMS failed: {response.status_code}\")\n</code></pre>"},{"location":"features/http-service-client/#requestresponse-interception","title":"\ud83d\udd0d Request/Response Interception","text":""},{"location":"features/http-service-client/#middleware-for-cross-cutting-concerns","title":"Middleware for Cross-Cutting Concerns","text":"<pre><code>from neuroglia.http import RequestInterceptor, ResponseInterceptor, HttpContext\n\nclass AuthenticationInterceptor(RequestInterceptor):\n    \"\"\"Add authentication to all external service requests.\"\"\"\n\n    async def intercept_request(self, request: HttpRequest, context: HttpContext) -&gt; HttpRequest:\n        # Add API key based on service\n        if \"payment-gateway.com\" in request.url:\n            request.headers[\"Authorization\"] = f\"Bearer {self.get_payment_api_key()}\"\n        elif \"delivery-service.com\" in request.url:\n            request.headers[\"X-API-Key\"] = self.get_delivery_api_key()\n        elif \"email-service.com\" in request.url:\n            request.headers[\"Authorization\"] = f\"Bearer {self.get_email_api_key()}\"\n\n        # Add common headers\n        request.headers[\"User-Agent\"] = \"MariosPizzeria/1.0\"\n        request.headers[\"X-Request-ID\"] = context.correlation_id\n\n        return request\n\n    def get_payment_api_key(self) -&gt; str:\n        return \"payment_api_key_here\"\n\n    def get_delivery_api_key(self) -&gt; str:\n        return \"delivery_api_key_here\"\n\n    def get_email_api_key(self) -&gt; str:\n        return \"email_api_key_here\"\n\nclass LoggingInterceptor(RequestInterceptor, ResponseInterceptor):\n    \"\"\"Log all HTTP requests and responses.\"\"\"\n\n    async def intercept_request(self, request: HttpRequest, context: HttpContext) -&gt; HttpRequest:\n        print(f\"\ud83c\udf10 HTTP Request: {request.method} {request.url}\")\n        print(f\"\ud83d\udccb Headers: {dict(request.headers)}\")\n\n        if request.json:\n            print(f\"\ud83d\udcc4 Request Body: {request.json}\")\n\n        context.start_time = time.time()\n        return request\n\n    async def intercept_response(self, response: HttpResponse, context: HttpContext) -&gt; HttpResponse:\n        duration = time.time() - context.start_time\n\n        print(f\"\ud83d\udce8 HTTP Response: {response.status_code} ({duration:.2f}s)\")\n        print(f\"\ud83d\udcc4 Response Size: {len(response.content)} bytes\")\n\n        if not response.is_success:\n            print(f\"\u274c Error Response: {response.text}\")\n\n        return response\n\nclass RateLimitInterceptor(RequestInterceptor):\n    \"\"\"Handle rate limiting with backoff.\"\"\"\n\n    def __init__(self):\n        self.rate_limit_trackers = {}\n\n    async def intercept_request(self, request: HttpRequest, context: HttpContext) -&gt; HttpRequest:\n        service_key = self.extract_service_key(request.url)\n\n        # Check if we're rate limited\n        if self.is_rate_limited(service_key):\n            wait_time = self.get_rate_limit_wait_time(service_key)\n            print(f\"\u23f3 Rate limited for {service_key}, waiting {wait_time}s\")\n            await asyncio.sleep(wait_time)\n\n        return request\n\n    async def intercept_response(self, response: HttpResponse, context: HttpContext) -&gt; HttpResponse:\n        if response.status_code == 429:  # Too Many Requests\n            service_key = self.extract_service_key(context.request.url)\n            self.handle_rate_limit_response(service_key, response)\n\n        return response\n\n    def extract_service_key(self, url: str) -&gt; str:\n        \"\"\"Extract service identifier from URL.\"\"\"\n        if \"payment-gateway.com\" in url:\n            return \"payment_gateway\"\n        elif \"delivery-service.com\" in url:\n            return \"delivery_service\"\n        elif \"email-service.com\" in url:\n            return \"email_service\"\n        return \"unknown\"\n\n    def is_rate_limited(self, service_key: str) -&gt; bool:\n        \"\"\"Check if service is currently rate limited.\"\"\"\n        tracker = self.rate_limit_trackers.get(service_key)\n        if not tracker:\n            return False\n\n        return time.time() &lt; tracker[\"retry_after\"]\n\n    def handle_rate_limit_response(self, service_key: str, response: HttpResponse):\n        \"\"\"Handle rate limit response headers.\"\"\"\n        retry_after = response.headers.get(\"Retry-After\", \"60\")\n\n        self.rate_limit_trackers[service_key] = {\n            \"retry_after\": time.time() + int(retry_after),\n            \"limit_exceeded_at\": time.time()\n        }\n</code></pre>"},{"location":"features/http-service-client/#registering-interceptors","title":"Registering Interceptors","text":"<pre><code>def configure_http_interceptors(services: ServiceCollection):\n    \"\"\"Configure HTTP client interceptors.\"\"\"\n\n    # Register interceptors in order of execution\n    services.add_singleton(AuthenticationInterceptor)\n    services.add_singleton(LoggingInterceptor)\n    services.add_singleton(RateLimitInterceptor)\n\n    # Configure HTTP client with interceptors\n    http_config = HttpClientConfig(\n        request_interceptors=[\n            AuthenticationInterceptor,\n            RateLimitInterceptor,\n            LoggingInterceptor\n        ],\n        response_interceptors=[\n            LoggingInterceptor,\n            RateLimitInterceptor\n        ]\n    )\n\n    services.add_http_service_client(http_config)\n</code></pre>"},{"location":"features/http-service-client/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"features/http-service-client/#unit-testing-with-http-mocks","title":"Unit Testing with HTTP Mocks","text":"<pre><code>import pytest\nfrom unittest.mock import AsyncMock, Mock\nfrom neuroglia.http import HttpServiceClient, HttpResponse\n\nclass TestPaymentGatewayService:\n\n    @pytest.fixture\n    def mock_http_client(self):\n        client = Mock(spec=HttpServiceClient)\n        client.post_async = AsyncMock()\n        client.get_async = AsyncMock()\n        return client\n\n    @pytest.fixture\n    def payment_service(self, mock_http_client):\n        service_provider = Mock()\n        service_provider.get_service.return_value = mock_http_client\n        return PaymentGatewayService(service_provider)\n\n    @pytest.mark.asyncio\n    async def test_successful_payment(self, payment_service, mock_http_client):\n        \"\"\"Test successful payment processing.\"\"\"\n\n        # Mock successful response\n        mock_response = Mock(spec=HttpResponse)\n        mock_response.is_success = True\n        mock_response.json.return_value = {\n            \"charge_id\": \"ch_123456\",\n            \"status\": \"succeeded\",\n            \"amount\": 25.99\n        }\n        mock_http_client.post_async.return_value = mock_response\n\n        # Test payment\n        result = await payment_service.charge_customer(\"order_123\", 25.99)\n\n        # Verify request was made correctly\n        mock_http_client.post_async.assert_called_once()\n        call_args = mock_http_client.post_async.call_args\n\n        assert \"charges\" in call_args[1][\"url\"]\n        assert call_args[1][\"json\"][\"amount\"] == 25.99\n        assert call_args[1][\"json\"][\"order_id\"] == \"order_123\"\n\n        # Verify response\n        assert result[\"charge_id\"] == \"ch_123456\"\n        assert result[\"status\"] == \"succeeded\"\n\n    @pytest.mark.asyncio\n    async def test_payment_failure(self, payment_service, mock_http_client):\n        \"\"\"Test payment processing failure.\"\"\"\n\n        # Mock failed response\n        mock_response = Mock(spec=HttpResponse)\n        mock_response.is_success = False\n        mock_response.status_code = 402\n        mock_response.text = \"Insufficient funds\"\n        mock_http_client.post_async.return_value = mock_response\n\n        # Test payment failure\n        with pytest.raises(PaymentProcessingError) as exc_info:\n            await payment_service.charge_customer(\"order_123\", 25.99)\n\n        assert \"Payment failed\" in str(exc_info.value)\n\n    @pytest.mark.asyncio\n    async def test_service_unavailable(self, payment_service, mock_http_client):\n        \"\"\"Test handling of service unavailability.\"\"\"\n\n        # Mock connection error\n        mock_http_client.post_async.side_effect = ConnectionError(\"Service unavailable\")\n\n        # Test service unavailable handling\n        with pytest.raises(PaymentServiceUnavailableError) as exc_info:\n            await payment_service.charge_customer(\"order_123\", 25.99)\n\n        assert \"Cannot process payment\" in str(exc_info.value)\n</code></pre>"},{"location":"features/http-service-client/#integration-testing-with-test-servers","title":"Integration Testing with Test Servers","text":"<pre><code>@pytest.mark.integration\nclass TestHttpServiceIntegration:\n\n    @pytest.fixture\n    async def test_server(self):\n        \"\"\"Start test HTTP server for integration testing.\"\"\"\n        from aiohttp import web\n        from aiohttp.test_utils import TestServer\n\n        async def payment_handler(request):\n            data = await request.json()\n\n            if data.get(\"amount\", 0) &lt;= 0:\n                return web.json_response(\n                    {\"error\": \"Invalid amount\"},\n                    status=400\n                )\n\n            return web.json_response({\n                \"charge_id\": \"ch_test_123\",\n                \"status\": \"succeeded\",\n                \"amount\": data[\"amount\"]\n            })\n\n        async def rate_limit_handler(request):\n            return web.json_response(\n                {\"error\": \"Rate limit exceeded\"},\n                status=429,\n                headers={\"Retry-After\": \"5\"}\n            )\n\n        app = web.Application()\n        app.router.add_post(\"/charges\", payment_handler)\n        app.router.add_post(\"/rate-limited\", rate_limit_handler)\n\n        server = TestServer(app)\n        await server.start_server()\n        yield server\n        await server.close()\n\n    @pytest.fixture\n    def http_client(self):\n        config = HttpClientConfig(\n            base_timeout=5.0,\n            enable_circuit_breaker=True,\n            enable_retry_policy=True\n        )\n        return HttpServiceClient(config)\n\n    @pytest.mark.asyncio\n    async def test_end_to_end_payment(self, test_server, http_client):\n        \"\"\"Test end-to-end payment processing.\"\"\"\n\n        payment_data = {\n            \"order_id\": \"integration_test_order\",\n            \"amount\": 19.99,\n            \"currency\": \"USD\"\n        }\n\n        response = await http_client.post_async(\n            url=f\"{test_server.make_url('/charges')}\",\n            json=payment_data,\n            timeout=10.0\n        )\n\n        assert response.is_success\n        result = response.json()\n        assert result[\"status\"] == \"succeeded\"\n        assert result[\"amount\"] == 19.99\n\n    @pytest.mark.asyncio\n    async def test_circuit_breaker_behavior(self, test_server, http_client):\n        \"\"\"Test circuit breaker with failing service.\"\"\"\n\n        # Make multiple requests to trigger circuit breaker\n        for i in range(6):  # Trigger failure threshold\n            try:\n                await http_client.post_async(\n                    url=f\"{test_server.make_url('/rate-limited')}\",\n                    json={\"test\": \"data\"},\n                    timeout=1.0\n                )\n            except Exception:\n                pass  # Expected failures\n\n        # Circuit should now be open - next request should fail fast\n        start_time = time.time()\n\n        with pytest.raises(Exception):  # Circuit breaker should fail fast\n            await http_client.post_async(\n                url=f\"{test_server.make_url('/rate-limited')}\",\n                json={\"test\": \"data\"}\n            )\n\n        duration = time.time() - start_time\n        assert duration &lt; 0.1  # Should fail fast, not wait for timeout\n</code></pre>"},{"location":"features/http-service-client/#monitoring-and-observability","title":"\ud83d\udcca Monitoring and Observability","text":""},{"location":"features/http-service-client/#http-client-metrics","title":"HTTP Client Metrics","text":"<pre><code>from neuroglia.http import HttpMetrics, MetricsCollector\n\nclass HttpServiceMonitor:\n    def __init__(self, http_client: HttpServiceClient):\n        self.http_client = http_client\n        self.metrics = HttpMetrics()\n\n    async def track_request_metrics(self, service_name: str, endpoint: str,\n                                  status_code: int, duration: float):\n        \"\"\"Track HTTP request metrics.\"\"\"\n\n        # Increment counters\n        await self.metrics.increment_counter(f\"http_requests_total\", {\n            \"service\": service_name,\n            \"endpoint\": endpoint,\n            \"status_code\": status_code\n        })\n\n        # Track response times\n        await self.metrics.observe_histogram(f\"http_request_duration_seconds\", duration, {\n            \"service\": service_name,\n            \"endpoint\": endpoint\n        })\n\n        # Track error rates\n        if status_code &gt;= 400:\n            await self.metrics.increment_counter(f\"http_errors_total\", {\n                \"service\": service_name,\n                \"status_code\": status_code\n            })\n\n    async def get_service_health_summary(self) -&gt; dict:\n        \"\"\"Get HTTP service health summary.\"\"\"\n\n        total_requests = await self.metrics.get_counter(\"http_requests_total\")\n        total_errors = await self.metrics.get_counter(\"http_errors_total\")\n        avg_duration = await self.metrics.get_gauge(\"http_request_duration_seconds\")\n\n        error_rate = (total_errors / total_requests) if total_requests &gt; 0 else 0\n\n        return {\n            \"total_requests\": total_requests,\n            \"total_errors\": total_errors,\n            \"error_rate\": error_rate,\n            \"average_response_time\": avg_duration,\n            \"circuit_breaker_states\": await self.get_circuit_breaker_states()\n        }\n\n    async def get_circuit_breaker_states(self) -&gt; dict:\n        \"\"\"Get current circuit breaker states for all services.\"\"\"\n        return {\n            \"payment_gateway\": \"closed\",\n            \"delivery_service\": \"half_open\",\n            \"email_service\": \"closed\",\n            \"sms_service\": \"open\"\n        }\n</code></pre>"},{"location":"features/http-service-client/#advanced-configuration","title":"\ud83d\udd27 Advanced Configuration","text":""},{"location":"features/http-service-client/#connection-pool-and-performance-tuning","title":"Connection Pool and Performance Tuning","text":"<pre><code>from neuroglia.http import HttpClientConfig, ConnectionPoolConfig\n\ndef create_optimized_http_config():\n    connection_config = ConnectionPoolConfig(\n        # Connection limits\n        max_connections=200,\n        max_connections_per_host=50,\n\n        # Timeouts\n        connection_timeout=5.0,\n        request_timeout=30.0,\n        pool_timeout=10.0,\n\n        # Keep-alive settings\n        keep_alive_timeout=75.0,\n        keep_alive_max_requests=1000,\n\n        # SSL/TLS settings\n        ssl_verify=True,\n        ssl_cert_file=None,\n        ssl_key_file=None,\n\n        # Compression\n        enable_compression=True,\n        compression_threshold=1024\n    )\n\n    http_config = HttpClientConfig(\n        connection_pool=connection_config,\n\n        # Default timeouts\n        base_timeout=30.0,\n        connection_timeout=5.0,\n\n        # Resilience patterns\n        enable_circuit_breaker=True,\n        circuit_breaker_config={\n            \"failure_threshold\": 5,\n            \"recovery_timeout\": 60,\n            \"success_threshold\": 3\n        },\n\n        enable_retry_policy=True,\n        retry_policy_config={\n            \"max_attempts\": 3,\n            \"backoff_factor\": 2.0,\n            \"max_delay\": 60.0\n        },\n\n        # Request/Response settings\n        max_response_size=10 * 1024 * 1024,  # 10MB\n        enable_request_compression=True,\n        enable_response_decompression=True,\n\n        # Security\n        allowed_redirect_count=3,\n        trust_env_proxy_settings=True\n    )\n\n    return http_config\n</code></pre>"},{"location":"features/http-service-client/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\u23f0 Background Task Scheduling - Scheduling external API calls</li> <li>\u26a1 Redis Cache Repository - Caching API responses</li> <li>\ud83d\udd27 Dependency Injection - Service registration patterns</li> <li>\ud83d\udcca Enhanced Model Validation - Request/response validation</li> <li>\ud83d\udce8 Event Sourcing - Event-driven external service integration</li> </ul> <p>The HTTP Service Client provides enterprise-grade capabilities for reliable external service communication. Through circuit breakers, retry policies, and comprehensive interception, Mario's Pizzeria can confidently integrate with payment gateways, delivery services, and notification providers while maintaining system resilience and performance.</p>"},{"location":"features/mermaid-diagrams/","title":"\ud83d\udcca Mermaid Diagrams in Documentation","text":"<p>The Neuroglia Python Framework documentation supports Mermaid diagrams for creating visual representations of architecture, workflows, and system interactions.</p>"},{"location":"features/mermaid-diagrams/#overview","title":"\ud83c\udfaf Overview","text":"<p>Mermaid is a powerful diagramming tool that allows you to create diagrams using simple text-based syntax. Our documentation site automatically renders Mermaid diagrams when you include them in markdown files.</p>"},{"location":"features/mermaid-diagrams/#supported-diagram-types","title":"\ud83c\udfd7\ufe0f Supported Diagram Types","text":""},{"location":"features/mermaid-diagrams/#flowcharts","title":"Flowcharts","text":"<p>Perfect for representing decision flows, process flows, and system workflows:</p> <pre><code>graph TD\n    A[User Request] --&gt; B{Authentication}\n    B --&gt;|Valid| C[Route to Controller]\n    B --&gt;|Invalid| D[Return 401]\n    C --&gt; E[Execute Handler]\n    E --&gt; F[Return Response]\n    D --&gt; G[End]\n    F --&gt; G</code></pre>"},{"location":"features/mermaid-diagrams/#sequence-diagrams","title":"Sequence Diagrams","text":"<p>Ideal for showing interaction between components over time:</p> <pre><code>sequenceDiagram\n    participant C as Controller\n    participant M as Mediator\n    participant H as Handler\n    participant R as Repository\n    participant D as Database\n\n    C-&gt;&gt;M: Send Command\n    M-&gt;&gt;H: Route to Handler\n    H-&gt;&gt;R: Query/Save Data\n    R-&gt;&gt;D: Execute SQL\n    D--&gt;&gt;R: Return Result\n    R--&gt;&gt;H: Domain Objects\n    H--&gt;&gt;M: Operation Result\n    M--&gt;&gt;C: Response</code></pre>"},{"location":"features/mermaid-diagrams/#class-diagrams","title":"Class Diagrams","text":"<p>Great for documenting domain models and relationships:</p> <pre><code>classDiagram\n    class Controller {\n        +ServiceProvider service_provider\n        +Mediator mediator\n        +Mapper mapper\n        +process(result) Response\n    }\n\n    class CommandHandler {\n        &lt;&lt;abstract&gt;&gt;\n        +handle_async(command) OperationResult\n    }\n\n    class Entity {\n        +str id\n        +datetime created_at\n        +raise_event(event)\n        +get_uncommitted_events()\n    }\n\n    class Repository {\n        &lt;&lt;interface&gt;&gt;\n        +save_async(entity)\n        +get_by_id_async(id)\n        +delete_async(id)\n    }\n\n    Controller --&gt; CommandHandler : uses\n    CommandHandler --&gt; Entity : manipulates\n    CommandHandler --&gt; Repository : persists through</code></pre>"},{"location":"features/mermaid-diagrams/#architecture-diagrams","title":"Architecture Diagrams","text":"<p>Perfect for system overview and component relationships:</p> <pre><code>graph TB\n    subgraph \"\ud83c\udf10 API Layer\"\n        A[Controllers]\n        B[DTOs]\n        C[Middleware]\n    end\n\n    subgraph \"\ud83d\udcbc Application Layer\"\n        D[Commands/Queries]\n        E[Handlers]\n        F[Services]\n        G[Mediator]\n    end\n\n    subgraph \"\ud83c\udfdb\ufe0f Domain Layer\"\n        H[Entities]\n        I[Value Objects]\n        J[Domain Events]\n        K[Business Rules]\n    end\n\n    subgraph \"\ud83d\udd0c Integration Layer\"\n        L[Repositories]\n        M[External APIs]\n        N[Database]\n        O[Event Bus]\n    end\n\n    A --&gt; G\n    G --&gt; E\n    E --&gt; H\n    E --&gt; L\n    L --&gt; N\n    E --&gt; O\n\n    style A fill:#e1f5fe\n    style G fill:#f3e5f5\n    style H fill:#e8f5e8\n    style L fill:#fff3e0</code></pre>"},{"location":"features/mermaid-diagrams/#state-diagrams","title":"State Diagrams","text":"<p>Useful for modeling entity lifecycle and business processes:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; Draft\n    Draft --&gt; Submitted : submit()\n    Submitted --&gt; Approved : approve()\n    Submitted --&gt; Rejected : reject()\n    Rejected --&gt; Draft : revise()\n    Approved --&gt; Published : publish()\n    Published --&gt; Archived : archive()\n    Archived --&gt; [*]\n\n    state Submitted {\n        [*] --&gt; PendingReview\n        PendingReview --&gt; InReview : assign_reviewer()\n        InReview --&gt; ReviewComplete : complete_review()\n    }</code></pre>"},{"location":"features/mermaid-diagrams/#usage-in-documentation","title":"\ud83d\ude80 Usage in Documentation","text":""},{"location":"features/mermaid-diagrams/#basic-syntax","title":"Basic Syntax","text":"<p>To include a Mermaid diagram in your documentation:</p> <pre><code>```mermaid\ngraph TD\n    A[Start] --&gt; B[Process]\n    B --&gt; C[End]\n```\n</code></pre>"},{"location":"features/mermaid-diagrams/#best-practices","title":"Best Practices","text":"<ol> <li>Use Descriptive Labels: Make node labels clear and meaningful</li> <li>Consistent Styling: Use subgraphs for logical grouping</li> <li>Appropriate Diagram Types: Choose the right diagram for your content</li> <li>Keep It Simple: Don't overcomplicate diagrams</li> <li>Use Colors Wisely: Leverage styling for emphasis</li> </ol>"},{"location":"features/mermaid-diagrams/#advanced-styling","title":"Advanced Styling","text":"<p>You can add custom styling to your diagrams:</p> <pre><code>graph TD\n    A[API Request] --&gt; B[Authentication]\n    B --&gt; C[Authorization]\n    C --&gt; D[Business Logic]\n    D --&gt; E[Data Access]\n    E --&gt; F[Response]\n\n    classDef apiStyle fill:#e3f2fd,stroke:#1976d2,stroke-width:2px\n    classDef processStyle fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\n    classDef dataStyle fill:#e8f5e8,stroke:#388e3c,stroke-width:2px\n\n    class A,F apiStyle\n    class B,C,D processStyle\n    class E dataStyle</code></pre>"},{"location":"features/mermaid-diagrams/#configuration","title":"\ud83d\udd27 Configuration","text":"<p>The documentation site is configured with:</p> <ul> <li>Theme: Auto (follows system dark/light mode)</li> <li>Primary Color: Blue (#1976d2) matching Material theme</li> <li>Auto-refresh: Diagrams update automatically during development</li> <li>High DPI: Support for crisp diagrams on retina displays</li> </ul>"},{"location":"features/mermaid-diagrams/#documentation-standards","title":"\ud83d\udcdd Documentation Standards","text":"<p>When adding Mermaid diagrams to documentation:</p> <ol> <li>Always include a text description before the diagram</li> <li>Use consistent terminology across all diagrams</li> <li>Reference framework concepts (Controllers, Handlers, etc.)</li> <li>Include diagrams in relevant sections of feature documentation</li> <li>Test rendering locally before committing</li> </ol>"},{"location":"features/mermaid-diagrams/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Architecture Overview</li> <li>CQRS &amp; Mediation</li> <li>Dependency Injection</li> <li>Sample Applications</li> </ul>"},{"location":"features/mermaid-diagrams/#external-resources","title":"\ud83d\udcda External Resources","text":"<ul> <li>Mermaid Documentation</li> <li>Mermaid Live Editor</li> <li>MkDocs Material</li> </ul>"},{"location":"features/mvc-controllers/","title":"\ud83d\udd0c MVC Controllers","text":"<p>Neuroglia's MVC system provides powerful class-based API development using Mario's Pizzeria as an example, demonstrating real-world controller patterns with automatic discovery, dependency injection, and comprehensive API design.</p>"},{"location":"features/mvc-controllers/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>Pizza Order Management: OrdersController for handling customer orders</li> <li>Menu Administration: MenuController for pizza and topping management  </li> <li>Kitchen Operations: KitchenController for order preparation workflow</li> <li>Authentication &amp; Authorization: OAuth integration for staff and customer access</li> <li>Error Handling: Comprehensive error responses and validation</li> <li>API Documentation: Automatic OpenAPI generation with pizzeria examples</li> </ul>"},{"location":"features/mvc-controllers/#controller-foundation","title":"\ud83c\udfd7\ufe0f Controller Foundation","text":""},{"location":"features/mvc-controllers/#pizza-order-controller","title":"Pizza Order Controller","text":"<p>The main controller for customer interactions at Mario's Pizzeria:</p> <pre><code>from neuroglia.mvc.controller_base import ControllerBase\nfrom neuroglia.dependency_injection.service_provider import ServiceProviderBase\nfrom neuroglia.mapping.mapper import Mapper\nfrom neuroglia.mediation.mediator import Mediator\nfrom classy_fastapi.decorators import get, post, put, delete\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import HTTPBearer\nfrom typing import List, Optional\nfrom datetime import date\n\nclass OrdersController(ControllerBase):\n    \"\"\"Controller for managing pizza orders at Mario's Pizzeria\"\"\"\n\n    def __init__(self, \n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n        self.security = HTTPBearer(auto_error=False)\n\n    @get(\"/\", \n         response_model=List[OrderDto], \n         summary=\"Get customer orders\",\n         description=\"Retrieve orders for authenticated customer\")\n    async def get_my_orders(self, \n                            token: str = Depends(HTTPBearer()),\n                            limit: int = 10) -&gt; List[OrderDto]:\n        \"\"\"Get orders for authenticated customer\"\"\"\n        try:\n            # Validate customer token and get customer info\n            customer_info = await self._validate_customer_token(token.credentials)\n\n            # Query customer's orders\n            query = GetOrdersByCustomerQuery(\n                customer_phone=customer_info.phone,\n                limit=limit\n            )\n            result = await self.mediator.execute_async(query)\n\n            return self.process(result)\n\n        except Exception as e:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid authentication token\"\n            )\n\n    @get(\"/{order_id}\", \n         response_model=OrderDto,\n         summary=\"Get specific order\",\n         description=\"Get details of a specific pizza order\")\n    async def get_order(self, \n                        order_id: str,\n                        token: str = Depends(HTTPBearer())) -&gt; OrderDto:\n        \"\"\"Get specific order details\"\"\"\n        # Validate customer access to this order\n        customer_info = await self._validate_customer_token(token.credentials)\n\n        query = GetOrderByIdQuery(\n            order_id=order_id,\n            customer_phone=customer_info.phone  # Ensure customer owns order\n        )\n        result = await self.mediator.execute_async(query)\n\n        return self.process(result)\n\n    @post(\"/\", \n          response_model=OrderDto, \n          status_code=201,\n          summary=\"Place pizza order\",\n          description=\"Place a new pizza order with customer details and pizza selection\")\n    async def place_order(self, \n                          order_request: PlaceOrderDto,\n                          token: Optional[str] = Depends(HTTPBearer(auto_error=False))) -&gt; OrderDto:\n        \"\"\"Place a new pizza order\"\"\"\n        try:\n            # If token provided, use customer info; otherwise use order details\n            customer_info = None\n            if token:\n                customer_info = await self._validate_customer_token(token.credentials)\n\n            # Create place order command\n            command = PlaceOrderCommand(\n                customer_name=customer_info.name if customer_info else order_request.customer_name,\n                customer_phone=customer_info.phone if customer_info else order_request.customer_phone,\n                customer_address=order_request.customer_address,\n                pizzas=order_request.pizzas,\n                payment_method=order_request.payment_method,\n                special_instructions=order_request.special_instructions\n            )\n\n            result = await self.mediator.execute_async(command)\n            return self.process(result)\n\n        except ValidationError as e:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=f\"Invalid order data: {str(e)}\"\n            )\n        except Exception as e:\n            raise HTTPException(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                detail=\"Failed to place order. Please try again.\"\n            )\n\n    @put(\"/{order_id}/cancel\", \n         response_model=OrderDto,\n         summary=\"Cancel order\",\n         description=\"Cancel a pizza order if it hasn't started preparation\")\n    async def cancel_order(self, \n                           order_id: str,\n                           cancellation_request: CancelOrderDto,\n                           token: str = Depends(HTTPBearer())) -&gt; OrderDto:\n        \"\"\"Cancel an existing order\"\"\"\n        customer_info = await self._validate_customer_token(token.credentials)\n\n        command = CancelOrderCommand(\n            order_id=order_id,\n            customer_phone=customer_info.phone,\n            cancellation_reason=cancellation_request.reason\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @get(\"/{order_id}/status\",\n         response_model=OrderStatusDto,\n         summary=\"Get order status\",\n         description=\"Get current status and estimated ready time for order\")\n    async def get_order_status(self, \n                               order_id: str,\n                               token: str = Depends(HTTPBearer())) -&gt; OrderStatusDto:\n        \"\"\"Get order status and tracking information\"\"\"\n        customer_info = await self._validate_customer_token(token.credentials)\n\n        query = GetOrderStatusQuery(\n            order_id=order_id,\n            customer_phone=customer_info.phone\n        )\n\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    async def _validate_customer_token(self, token: str) -&gt; CustomerInfo:\n        \"\"\"Validate customer authentication token\"\"\"\n        # In production, this would validate JWT token\n        # For demo purposes, we'll use a simple validation\n        query = ValidateCustomerTokenQuery(token=token)\n        result = await self.mediator.execute_async(query)\n\n        if not result.is_success:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid or expired token\"\n            )\n\n        return result.data\n</code></pre>"},{"location":"features/mvc-controllers/#menu-management-controller","title":"Menu Management Controller","text":"<pre><code>class MenuController(ControllerBase):\n    \"\"\"Controller for managing Mario's Pizzeria menu\"\"\"\n\n    def __init__(self, \n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n    @get(\"/pizzas\", \n         response_model=List[PizzaDto],\n         summary=\"Get pizza menu\",\n         description=\"Get all available pizzas organized by category\")\n    async def get_menu(self, \n                       category: Optional[str] = Query(None, description=\"Filter by pizza category\"),\n                       available_only: bool = Query(True, description=\"Show only available pizzas\")) -&gt; List[PizzaDto]:\n        \"\"\"Get pizza menu with optional filtering\"\"\"\n        query = GetMenuQuery(\n            category=category,\n            available_only=available_only\n        )\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/pizzas/{pizza_id}\", \n         response_model=PizzaDto,\n         summary=\"Get pizza details\",\n         description=\"Get detailed information about a specific pizza\")\n    async def get_pizza(self, pizza_id: str) -&gt; PizzaDto:\n        \"\"\"Get specific pizza details\"\"\"\n        query = GetPizzaByIdQuery(pizza_id=pizza_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/categories\",\n         response_model=List[str],\n         summary=\"Get pizza categories\",\n         description=\"Get all available pizza categories\")\n    async def get_categories(self) -&gt; List[str]:\n        \"\"\"Get all pizza categories\"\"\"\n        query = GetPizzaCategoriesQuery()\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/toppings\",\n         response_model=List[ToppingDto],\n         summary=\"Get available toppings\",\n         description=\"Get all available pizza toppings with prices\")\n    async def get_toppings(self,\n                           vegetarian_only: bool = Query(False, description=\"Show only vegetarian toppings\")) -&gt; List[ToppingDto]:\n        \"\"\"Get available toppings\"\"\"\n        query = GetToppingsQuery(vegetarian_only=vegetarian_only)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    # Admin endpoints (require staff authentication)\n    @post(\"/pizzas\", \n          response_model=PizzaDto, \n          status_code=201,\n          summary=\"Add new pizza (Staff Only)\",\n          description=\"Add a new pizza to the menu\")\n    async def add_pizza(self, \n                        pizza_request: CreatePizzaDto,\n                        staff_token: str = Depends(HTTPBearer())) -&gt; PizzaDto:\n        \"\"\"Add new pizza to menu (staff only)\"\"\"\n        await self._validate_staff_token(staff_token.credentials, required_role=\"manager\")\n\n        command = CreatePizzaCommand(\n            name=pizza_request.name,\n            description=pizza_request.description,\n            category=pizza_request.category,\n            base_price=pizza_request.base_price,\n            available_toppings=pizza_request.available_toppings,\n            preparation_time_minutes=pizza_request.preparation_time_minutes,\n            is_seasonal=pizza_request.is_seasonal\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @put(\"/pizzas/{pizza_id}/availability\", \n         response_model=PizzaDto,\n         summary=\"Update pizza availability (Staff Only)\",\n         description=\"Mark pizza as available or sold out\")\n    async def update_pizza_availability(self, \n                                        pizza_id: str,\n                                        availability_request: UpdateAvailabilityDto,\n                                        staff_token: str = Depends(HTTPBearer())) -&gt; PizzaDto:\n        \"\"\"Update pizza availability\"\"\"\n        await self._validate_staff_token(staff_token.credentials, required_role=\"staff\")\n\n        command = UpdatePizzaAvailabilityCommand(\n            pizza_id=pizza_id,\n            is_available=availability_request.is_available,\n            reason=availability_request.reason\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#kitchen-operations-controller","title":"Kitchen Operations Controller","text":"<pre><code>class KitchenController(ControllerBase):\n    \"\"\"Controller for kitchen operations and order management\"\"\"\n\n    def __init__(self, \n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n    @get(\"/queue\", \n         response_model=List[KitchenOrderDto],\n         summary=\"Get kitchen queue\",\n         description=\"Get orders in kitchen queue ordered by priority\")\n    async def get_kitchen_queue(self,\n                                staff_token: str = Depends(HTTPBearer())) -&gt; List[KitchenOrderDto]:\n        \"\"\"Get orders in kitchen preparation queue\"\"\"\n        await self._validate_staff_token(staff_token.credentials, required_role=\"kitchen\")\n\n        query = GetKitchenQueueQuery(\n            statuses=[\"received\", \"preparing\", \"cooking\"]\n        )\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @put(\"/orders/{order_id}/status\", \n         response_model=OrderDto,\n         summary=\"Update order status\",\n         description=\"Update order status in kitchen workflow\")\n    async def update_order_status(self, \n                                  order_id: str,\n                                  status_update: UpdateOrderStatusDto,\n                                  staff_token: str = Depends(HTTPBearer())) -&gt; OrderDto:\n        \"\"\"Update order status (kitchen staff only)\"\"\"\n        staff_info = await self._validate_staff_token(staff_token.credentials, required_role=\"kitchen\")\n\n        command = UpdateOrderStatusCommand(\n            order_id=order_id,\n            new_status=status_update.status,\n            updated_by=staff_info.staff_id,\n            notes=status_update.notes,\n            estimated_ready_time=status_update.estimated_ready_time\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @post(\"/orders/{order_id}/pizzas/{pizza_index}/start\", \n          response_model=OrderDto,\n          summary=\"Start pizza preparation\",\n          description=\"Mark pizza as started in preparation\")\n    async def start_pizza(self, \n                          order_id: str,\n                          pizza_index: int,\n                          staff_token: str = Depends(HTTPBearer())) -&gt; OrderDto:\n        \"\"\"Start pizza preparation\"\"\"\n        staff_info = await self._validate_staff_token(staff_token.credentials, required_role=\"kitchen\")\n\n        command = StartPizzaPreparationCommand(\n            order_id=order_id,\n            pizza_index=pizza_index,\n            chef_id=staff_info.staff_id\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @post(\"/orders/{order_id}/pizzas/{pizza_index}/complete\", \n          response_model=OrderDto,\n          summary=\"Complete pizza preparation\",\n          description=\"Mark pizza as completed\")\n    async def complete_pizza(self, \n                             order_id: str,\n                             pizza_index: int,\n                             completion_request: CompletePizzaDto,\n                             staff_token: str = Depends(HTTPBearer())) -&gt; OrderDto:\n        \"\"\"Complete pizza preparation\"\"\"\n        staff_info = await self._validate_staff_token(staff_token.credentials, required_role=\"kitchen\")\n\n        command = CompletePizzaPreparationCommand(\n            order_id=order_id,\n            pizza_index=pizza_index,\n            chef_id=staff_info.staff_id,\n            quality_notes=completion_request.quality_notes\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @get(\"/performance\", \n         response_model=KitchenPerformanceDto,\n         summary=\"Get kitchen performance metrics\",\n         description=\"Get kitchen performance analytics\")\n    async def get_performance_metrics(self,\n                                      start_date: date = Query(description=\"Start date for metrics\"),\n                                      end_date: date = Query(description=\"End date for metrics\"),\n                                      staff_token: str = Depends(HTTPBearer())) -&gt; KitchenPerformanceDto:\n        \"\"\"Get kitchen performance metrics\"\"\"\n        await self._validate_staff_token(staff_token.credentials, required_role=\"manager\")\n\n        query = GetKitchenPerformanceQuery(\n            start_date=start_date,\n            end_date=end_date\n        )\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    async def _validate_staff_token(self, token: str, required_role: str) -&gt; StaffInfo:\n        \"\"\"Validate staff authentication and role\"\"\"\n        query = ValidateStaffTokenQuery(\n            token=token,\n            required_role=required_role\n        )\n        result = await self.mediator.execute_async(query)\n\n        if not result.is_success:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=f\"Insufficient permissions. Required role: {required_role}\"\n            )\n\n        return result.data\n</code></pre> <pre><code>class ReportsController(ControllerBase):\n    \"\"\"Controller for pizzeria analytics and reporting\"\"\"\n\n    @get(\"/orders\", \n         response_model=List[OrderReportDto],\n         summary=\"Get order reports\",\n         description=\"Get filtered order data for reporting\")\n    async def get_order_reports(self,\n                                start_date: date = Query(description=\"Report start date\"),\n                                end_date: date = Query(description=\"Report end date\"),\n                                customer_phone: Optional[str] = Query(None, description=\"Filter by customer\"),\n                                status: Optional[str] = Query(None, description=\"Filter by order status\"),\n                                min_amount: Optional[float] = Query(None, ge=0, description=\"Minimum order amount\"),\n                                max_amount: Optional[float] = Query(None, ge=0, description=\"Maximum order amount\"),\n                                limit: int = Query(100, ge=1, le=1000, description=\"Maximum results to return\"),\n                                offset: int = Query(0, ge=0, description=\"Number of results to skip\"),\n                                staff_token: str = Depends(HTTPBearer())) -&gt; List[OrderReportDto]:\n        \"\"\"Get order reports with advanced filtering\"\"\"\n        await self._validate_staff_token(staff_token.credentials, required_role=\"manager\")\n\n        query = GetOrderReportsQuery(\n            start_date=start_date,\n            end_date=end_date,\n            customer_phone=customer_phone,\n            status=status,\n            min_amount=min_amount,\n            max_amount=max_amount,\n            limit=limit,\n            offset=offset\n        )\n\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/revenue\", \n         response_model=RevenueReportDto,\n         summary=\"Get revenue analytics\",\n         description=\"Get revenue breakdown and analytics\")\n    async def get_revenue_report(self,\n                                 period: str = Query(\"daily\", regex=\"^(daily|weekly|monthly)$\"),\n                                 start_date: date = Query(description=\"Analysis start date\"),\n                                 end_date: date = Query(description=\"Analysis end date\"),\n                                 staff_token: str = Depends(HTTPBearer())) -&gt; RevenueReportDto:\n        \"\"\"Get revenue analytics by period\"\"\"\n        await self._validate_staff_token(staff_token.credentials, required_role=\"manager\")\n\n        query = GetRevenueAnalyticsQuery(\n            period=period,\n            start_date=start_date,\n            end_date=end_date\n        )\n\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#request-validation-and-dtos","title":"Request Validation and DTOs","text":"<p>Comprehensive validation for pizzeria data:         \"\"\"Get users with filtering and pagination\"\"\"</p> <pre><code>    query = GetUsersQuery(\n        department=department,\n        active_only=active_only,\n        page=page,\n        page_size=page_size\n    )\n\n    result = await self.mediator.execute_async(query)\n    return self.process(result)\n</code></pre> <p>``` </p>"},{"location":"features/mvc-controllers/#request-body-validation","title":"Request Body Validation","text":"<p>Use Pydantic models for request validation:  <code>python from pydantic import BaseModel, Field, EmailStr from typing import Optional  class CreateUserDto(BaseModel):     email: EmailStr = Field(..., description=\"User's email address\")     first_name: str = Field(..., min_length=1, max_length=50, description=\"First name\")     last_name: str = Field(..., min_length=1, max_length=50, description=\"Last name\")     department: Optional[str] = Field(None, max_length=100, description=\"Department\")      class Config:         schema_extra = {             \"example\": {                 \"email\": \"john.doe@company.com\",                 \"first_name\": \"John\",                 \"last_name\": \"Doe\",                 \"department\": \"Engineering\"             }         }  class UsersController(ControllerBase):      @post(\"/\", response_model=UserDto, status_code=status.HTTP_201_CREATED)     async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:         \"\"\"Create a new user\"\"\"         command = self.mapper.map(create_user_dto, CreateUserCommand)         result = await self.mediator.execute_async(command)         return self.process(result)</code></p>"},{"location":"features/mvc-controllers/#file-uploads","title":"File Uploads","text":"<p>Handle file uploads:</p> <pre><code>from fastapi import UploadFile, File\n\nclass UsersController(ControllerBase):\n\n    @post(\"/{user_id}/avatar\", response_model=UserDto)\n    async def upload_avatar(self, \n                           user_id: str,\n                           file: UploadFile = File(..., description=\"Avatar image\")) -&gt; UserDto:\n        \"\"\"Upload user avatar\"\"\"\n\n        # Validate file type\n        if not file.content_type.startswith('image/'):\n            return self.bad_request(\"File must be an image\")\n\n        # Create command\n        command = UploadUserAvatarCommand(\n            user_id=user_id,\n            file_name=file.filename,\n            file_content=await file.read(),\n            content_type=file.content_type\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#response-headers","title":"Response Headers","text":"<p>Set custom response headers:</p> <pre><code>from fastapi import Response\n\nclass UsersController(ControllerBase):\n\n    @get(\"/{user_id}/export\", response_class=Response)\n    async def export_user_data(self, user_id: str, response: Response):\n        \"\"\"Export user data as CSV\"\"\"\n\n        query = ExportUserDataQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n\n        if not result.is_success:\n            return self.process(result)\n\n        # Set CSV headers\n        response.headers[\"Content-Type\"] = \"text/csv\"\n        response.headers[\"Content-Disposition\"] = f\"attachment; filename=user_{user_id}.csv\"\n\n        return result.data\n</code></pre>"},{"location":"features/mvc-controllers/#controller-configuration","title":"\ud83c\udfaa Controller Configuration","text":""},{"location":"features/mvc-controllers/#custom-routing","title":"Custom Routing","text":"<p>Customize controller routing:</p> <pre><code>class UsersController(ControllerBase):\n    def __init__(self, service_provider, mapper, mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n        # Custom prefix and tags\n        self.router.prefix = \"/users\"\n        self.router.tags = [\"User Management\"]\n\n        # Add custom middleware to this controller\n        self.router.middleware(\"http\")(self.auth_middleware)\n\n    async def auth_middleware(self, request, call_next):\n        \"\"\"Custom authentication middleware for this controller\"\"\"\n        # Authentication logic\n        response = await call_next(request)\n        return response\n</code></pre>"},{"location":"features/mvc-controllers/#nested-controllers","title":"Nested Controllers","text":"<p>Create hierarchical resource structures:</p> <pre><code>class UserAccountsController(ControllerBase):\n    \"\"\"Handles user account operations\"\"\"\n\n    def __init__(self, service_provider, mapper, mediator):\n        super().__init__(service_provider, mapper, mediator)\n        self.router.prefix = \"/users/{user_id}/accounts\"\n\n    @get(\"/\", response_model=List[AccountDto])\n    async def get_user_accounts(self, user_id: str) -&gt; List[AccountDto]:\n        \"\"\"Get all accounts for a user\"\"\"\n        query = GetUserAccountsQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @post(\"/\", response_model=AccountDto, status_code=status.HTTP_201_CREATED)\n    async def create_account(self, user_id: str, create_account_dto: CreateAccountDto) -&gt; AccountDto:\n        \"\"\"Create a new account for a user\"\"\"\n        command = self.mapper.map(create_account_dto, CreateAccountCommand)\n        command.user_id = user_id\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#error-handling","title":"\ud83d\udee1\ufe0f Error Handling","text":""},{"location":"features/mvc-controllers/#built-in-error-responses","title":"Built-in Error Responses","text":"<p>Controllers include standard error responses:</p> <pre><code>class UsersController(ControllerBase):\n\n    @get(\"/{user_id}\", \n         response_model=UserDto,\n         responses=ControllerBase.error_responses)  # Adds 400, 404, 500 responses\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        \"\"\"Get user by ID\"\"\"\n        query = GetUserByIdQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)  # Automatically handles error responses\n</code></pre>"},{"location":"features/mvc-controllers/#custom-error-handling","title":"Custom Error Handling","text":"<p>Add custom error handling:</p> <pre><code>from fastapi import HTTPException\n\nclass UsersController(ControllerBase):\n\n    @post(\"/\", response_model=UserDto, status_code=status.HTTP_201_CREATED)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        \"\"\"Create a new user\"\"\"\n        try:\n            command = self.mapper.map(create_user_dto, CreateUserCommand)\n            result = await self.mediator.execute_async(command)\n            return self.process(result)\n\n        except EmailAlreadyExistsException:\n            raise HTTPException(\n                status_code=status.HTTP_409_CONFLICT,\n                detail=\"A user with this email already exists\"\n            )\n        except ValidationException as ex:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=str(ex)\n            )\n</code></pre>"},{"location":"features/mvc-controllers/#global-error-handling","title":"Global Error Handling","text":"<p>Use middleware for global error handling:</p> <pre><code>from neuroglia.hosting.web import ExceptionHandlingMiddleware\n\n# In main.py\napp.add_middleware(ExceptionHandlingMiddleware, service_provider=app.services)\n</code></pre>"},{"location":"features/mvc-controllers/#authentication-authorization","title":"\ud83d\udd10 Authentication &amp; Authorization","text":""},{"location":"features/mvc-controllers/#dependency-injection-for-auth","title":"Dependency Injection for Auth","text":"<p>Inject authentication services:</p> <pre><code>from fastapi import Depends\nfrom neuroglia.security import IAuthService, AuthUser\n\nclass UsersController(ControllerBase):\n\n    def __init__(self, \n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator,\n                 auth_service: IAuthService):\n        super().__init__(service_provider, mapper, mediator)\n        self.auth_service = auth_service\n\n    @get(\"/profile\", response_model=UserDto)\n    async def get_current_user(self, \n                              current_user: AuthUser = Depends(auth_service.get_current_user)) -&gt; UserDto:\n        \"\"\"Get current user's profile\"\"\"\n        query = GetUserByIdQuery(user_id=current_user.user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#role-based-authorization","title":"Role-based Authorization","text":"<p>Implement role-based access control:</p> <pre><code>from neuroglia.security import require_role\n\nclass UsersController(ControllerBase):\n\n    @get(\"/\", response_model=List[UserDto])\n    @require_role(\"admin\")  # Custom decorator\n    async def get_all_users(self) -&gt; List[UserDto]:\n        \"\"\"Get all users (admin only)\"\"\"\n        query = GetAllUsersQuery()\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @delete(\"/{user_id}\")\n    @require_role([\"admin\", \"manager\"])  # Multiple roles\n    async def delete_user(self, user_id: str):\n        \"\"\"Delete a user (admin or manager only)\"\"\"\n        command = DeleteUserCommand(user_id=user_id)\n        result = await self.mediator.execute_async(command)\n        self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#response-processing","title":"\ud83d\udcca Response Processing","text":""},{"location":"features/mvc-controllers/#the-process-method","title":"The <code>process</code> Method","text":"<p>The <code>process</code> method handles <code>OperationResult</code> objects automatically:</p> <pre><code># OperationResult with data\nresult = OperationResult.success(user_dto)\nreturn self.process(result)  # Returns user_dto with 200 status\n\n# OperationResult with error\nresult = OperationResult.not_found(\"User not found\")\nreturn self.process(result)  # Raises HTTPException with 404 status\n\n# OperationResult created\nresult = OperationResult.created(user_dto)\nreturn self.process(result)  # Returns user_dto with 201 status\n</code></pre>"},{"location":"features/mvc-controllers/#custom-response-processing","title":"Custom Response Processing","text":"<p>Override response processing for special cases:</p> <pre><code>class UsersController(ControllerBase):\n\n    @get(\"/{user_id}\", response_model=UserDto)\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        \"\"\"Get user by ID\"\"\"\n        query = GetUserByIdQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n\n        # Custom processing\n        if not result.is_success:\n            if result.status_code == 404:\n                # Log the attempt\n                self.logger.warning(f\"Attempt to access non-existent user: {user_id}\")\n            return self.process(result)\n\n        # Add custom headers for successful responses\n        response = self.process(result)\n        # Custom logic here\n        return response\n</code></pre>"},{"location":"features/mvc-controllers/#testing-controllers","title":"\ud83e\uddea Testing Controllers","text":""},{"location":"features/mvc-controllers/#unit-testing","title":"Unit Testing","text":"<p>Test controllers with mocked dependencies:</p> <pre><code>import pytest\nfrom unittest.mock import Mock, AsyncMock\n\n@pytest.mark.asyncio\nasync def test_get_user_success():\n    # Arrange\n    mock_mediator = Mock()\n    mock_mediator.execute_async = AsyncMock(return_value=OperationResult.success(test_user_dto))\n\n    controller = UsersController(\n        service_provider=mock_service_provider,\n        mapper=mock_mapper,\n        mediator=mock_mediator\n    )\n\n    # Act\n    result = await controller.get_user(\"user123\")\n\n    # Assert\n    assert result == test_user_dto\n    mock_mediator.execute_async.assert_called_once()\n</code></pre>"},{"location":"features/mvc-controllers/#integration-testing","title":"Integration Testing","text":"<p>Test controllers with TestClient:</p> <pre><code>from fastapi.testclient import TestClient\n\ndef test_create_user_integration():\n    # Arrange\n    client = TestClient(app)\n    user_data = {\n        \"email\": \"test@example.com\",\n        \"first_name\": \"John\",\n        \"last_name\": \"Doe\"\n    }\n\n    # Act\n    response = client.post(\"/api/v1/users\", json=user_data)\n\n    # Assert\n    assert response.status_code == 201\n\n    created_user = response.json()\n    assert created_user[\"email\"] == user_data[\"email\"]\n    assert \"id\" in created_user\n</code></pre>"},{"location":"features/mvc-controllers/#api-testing","title":"API Testing","text":"<p>Test the complete API flow:</p> <pre><code>def test_user_crud_flow():\n    client = TestClient(app)\n\n    # Create user\n    create_response = client.post(\"/api/v1/users\", json=test_user_data)\n    assert create_response.status_code == 201\n    user = create_response.json()\n    user_id = user[\"id\"]\n\n    # Get user\n    get_response = client.get(f\"/api/v1/users/{user_id}\")\n    assert get_response.status_code == 200\n    assert get_response.json()[\"id\"] == user_id\n\n    # Update user\n    update_data = {\"first_name\": \"Jane\"}\n    update_response = client.put(f\"/api/v1/users/{user_id}\", json=update_data)\n    assert update_response.status_code == 200\n    assert update_response.json()[\"first_name\"] == \"Jane\"\n\n    # Delete user\n    delete_response = client.delete(f\"/api/v1/users/{user_id}\")\n    assert delete_response.status_code == 204\n\n    # Verify deletion\n    get_deleted_response = client.get(f\"/api/v1/users/{user_id}\")\n    assert get_deleted_response.status_code == 404\n</code></pre>"},{"location":"features/mvc-controllers/#best-practices","title":"\ud83d\ude80 Best Practices","text":""},{"location":"features/mvc-controllers/#1-keep-controllers-thin","title":"1. Keep Controllers Thin","text":"<p>Controllers should delegate to the application layer:</p> <pre><code># Good - Thin controller\nclass UsersController(ControllerBase):\n    @post(\"/\", response_model=UserDto)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n# Avoid - Business logic in controller\nclass UsersController(ControllerBase):\n    @post(\"/\", response_model=UserDto)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        # Validate email\n        if not self.is_valid_email(create_user_dto.email):\n            raise HTTPException(400, \"Invalid email\")\n\n        # Check if user exists\n        existing = await self.user_repo.get_by_email(create_user_dto.email)\n        if existing:\n            raise HTTPException(409, \"User exists\")\n\n        # Create user\n        user = User(...)\n        # ... more business logic\n</code></pre>"},{"location":"features/mvc-controllers/#2-use-dtos-for-api-contracts","title":"2. Use DTOs for API Contracts","text":"<p>Always use DTOs to define your API contracts:</p> <pre><code># API DTOs\nclass CreateUserDto(BaseModel):\n    email: str\n    first_name: str\n    last_name: str\n\nclass UserDto(BaseModel):\n    id: str\n    email: str\n    first_name: str\n    last_name: str\n    created_at: datetime\n\n# Domain entities stay separate\nclass User(Entity[str]):\n    def __init__(self, email: str, first_name: str, last_name: str):\n        # Domain logic\n        pass\n</code></pre>"},{"location":"features/mvc-controllers/#3-consistent-error-handling","title":"3. Consistent Error Handling","text":"<p>Use consistent patterns for error handling:</p> <pre><code>class UsersController(ControllerBase):\n\n    @get(\"/{user_id}\", \n         response_model=UserDto,\n         responses={\n             404: {\"description\": \"User not found\"},\n             400: {\"description\": \"Invalid user ID format\"}\n         })\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        # Validate input format\n        if not self.is_valid_uuid(user_id):\n            return self.bad_request(\"Invalid user ID format\")\n\n        # Execute query\n        query = GetUserByIdQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n\n        # Process will handle 404 automatically\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#4-document-your-apis","title":"4. Document Your APIs","text":"<p>Provide comprehensive API documentation:</p> <pre><code>class UsersController(ControllerBase):\n\n    @post(\"/\",\n          response_model=UserDto,\n          status_code=status.HTTP_201_CREATED,\n          summary=\"Create a new user\",\n          description=\"Creates a new user account in the system\",\n          response_description=\"The created user\",\n          tags=[\"User Management\"])\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        \"\"\"\n        Create a new user account.\n\n        - **email**: User's email address (must be unique)\n        - **first_name**: User's first name\n        - **last_name**: User's last name\n\n        Returns the created user with generated ID and timestamps.\n        \"\"\"\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#5-version-your-apis","title":"5. Version Your APIs","text":"<p>Plan for API versioning:</p> <pre><code># v1 controller\nclass V1UsersController(ControllerBase):\n    def __init__(self, service_provider, mapper, mediator):\n        super().__init__(service_provider, mapper, mediator)\n```python\nfrom neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.mvc import ControllerDiscovery\n\ndef create_pizzeria_app():\n    \"\"\"Configure Mario's Pizzeria application with controllers\"\"\"\n    builder = WebApplicationBuilder()\n\n    # Configure services\n    builder.services.add_mediator()\n    builder.services.add_auto_mapper()\n\n    # Add controllers with automatic discovery\n    builder.services.add_controllers([\n        \"api.controllers.orders_controller\",\n        \"api.controllers.menu_controller\", \n        \"api.controllers.kitchen_controller\",\n        \"api.controllers.reports_controller\",\n        \"api.controllers.auth_controller\"\n    ])\n\n    # Build application\n    app = builder.build()\n\n    # Configure controller routes with prefixes\n    app.include_router(OrdersController().router, prefix=\"/api/orders\", tags=[\"Orders\"])\n    app.include_router(MenuController().router, prefix=\"/api/menu\", tags=[\"Menu\"])\n    app.include_router(KitchenController().router, prefix=\"/api/kitchen\", tags=[\"Kitchen\"])\n    app.include_router(ReportsController().router, prefix=\"/api/reports\", tags=[\"Reports\"])\n    app.include_router(AuthController().router, prefix=\"/api/auth\", tags=[\"Authentication\"])\n\n    # Add exception handlers\n    app.add_exception_handler(PizzeriaException, pizzeria_exception_handler)\n    app.add_exception_handler(RequestValidationError, validation_exception_handler)\n\n    return app\n\n# Environment-specific controller registration\ndef configure_development_controllers(builder: WebApplicationBuilder):\n    \"\"\"Add development-specific controllers\"\"\"\n    # Add mock data controller for testing\n    builder.services.add_controller(MockDataController)\n\ndef configure_production_controllers(builder: WebApplicationBuilder):\n    \"\"\"Add production-specific controllers\"\"\"\n    # Add monitoring and health check controllers\n    builder.services.add_controller(HealthController)\n    builder.services.add_controller(MetricsController)\n</code></pre>"},{"location":"features/mvc-controllers/#controller-middleware-and-interceptors","title":"Controller Middleware and Interceptors","text":"<p>Add cross-cutting concerns to controllers:</p> <pre><code>from fastapi import Request, Response\nfrom fastapi.middleware.base import BaseHTTPMiddleware\nimport time\nimport logging\n\nclass PizzeriaRequestLoggingMiddleware(BaseHTTPMiddleware):\n    \"\"\"Log all pizzeria API requests\"\"\"\n\n    async def dispatch(self, request: Request, call_next):\n        start_time = time.time()\n\n        # Log incoming request\n        logging.info(f\"Incoming {request.method} {request.url}\")\n\n        # Process request\n        response = await call_next(request)\n\n        # Log response\n        process_time = time.time() - start_time\n        logging.info(f\"Completed {request.method} {request.url} - \"\n                    f\"Status: {response.status_code} - \"\n                    f\"Duration: {process_time:.2f}s\")\n\n        return response\n\nclass OrderValidationMiddleware(BaseHTTPMiddleware):\n    \"\"\"Validate order-related requests\"\"\"\n\n    async def dispatch(self, request: Request, call_next):\n        if request.url.path.startswith(\"/api/orders\"):\n            # Add order-specific validation\n            if request.method == \"POST\":\n                # Validate business hours\n                if not self.is_business_hours():\n                    return JSONResponse(\n                        status_code=400,\n                        content={\"error\": \"Pizzeria is currently closed\"}\n                    )\n\n        return await call_next(request)\n\n    def is_business_hours(self) -&gt; bool:\n        \"\"\"Check if pizzeria is open for orders\"\"\"\n        from datetime import datetime\n        now = datetime.now()\n        return 11 &lt;= now.hour &lt;= 22  # Open 11 AM to 10 PM\n\n# Add middleware to application\napp.add_middleware(PizzeriaRequestLoggingMiddleware)\napp.add_middleware(OrderValidationMiddleware)\n</code></pre>"},{"location":"features/mvc-controllers/#controller-testing-patterns","title":"\ud83e\uddea Controller Testing Patterns","text":""},{"location":"features/mvc-controllers/#unit-testing-controllers","title":"Unit Testing Controllers","text":"<p>Test controllers with mocked dependencies:</p> <pre><code>import pytest\nfrom unittest.mock import AsyncMock, Mock\nfrom fastapi.testclient import TestClient\nfrom neuroglia.mediation import OperationResult\n\nclass TestOrdersController:\n    \"\"\"Unit tests for orders controller\"\"\"\n\n    @pytest.fixture\n    def mock_mediator(self):\n        \"\"\"Mock mediator for testing\"\"\"\n        mediator = AsyncMock()\n        return mediator\n\n    @pytest.fixture\n    def orders_controller(self, mock_mediator):\n        \"\"\"Orders controller with mocked dependencies\"\"\"\n        service_provider = Mock()\n        mapper = Mock()\n\n        controller = OrdersController(service_provider, mapper, mock_mediator)\n        return controller\n\n    @pytest.mark.asyncio\n    async def test_place_order_success(self, orders_controller, mock_mediator):\n        \"\"\"Test successful order placement\"\"\"\n        # Arrange\n        order_request = PlaceOrderDto(\n            customer_name=\"John Doe\",\n            customer_phone=\"+1234567890\",\n            customer_address=\"123 Main St\",\n            pizzas=[PizzaOrderDto(name=\"Margherita\", size=\"large\", quantity=1)],\n            payment_method=\"card\"\n        )\n\n        expected_order = OrderDto(\n            id=\"order_123\",\n            customer_name=\"John Doe\",\n            status=\"received\",\n            total_amount=15.99\n        )\n\n        mock_mediator.execute_async.return_value = OperationResult.success(expected_order)\n\n        # Act\n        result = await orders_controller.place_order(order_request)\n\n        # Assert\n        assert result.id == \"order_123\"\n        assert result.customer_name == \"John Doe\"\n        mock_mediator.execute_async.assert_called_once()\n\n    @pytest.mark.asyncio\n    async def test_place_order_validation_error(self, orders_controller, mock_mediator):\n        \"\"\"Test order placement with validation error\"\"\"\n        # Arrange\n        invalid_order = PlaceOrderDto(\n            customer_name=\"\",  # Invalid empty name\n            customer_phone=\"invalid\",  # Invalid phone\n            customer_address=\"\",  # Invalid empty address\n            pizzas=[],  # No pizzas\n            payment_method=\"invalid\"  # Invalid payment method\n        )\n\n        # Act &amp; Assert\n        with pytest.raises(ValidationError):\n            await orders_controller.place_order(invalid_order)\n\n@pytest.mark.integration\nclass TestOrdersControllerIntegration:\n    \"\"\"Integration tests for orders controller\"\"\"\n\n    @pytest.fixture\n    def test_client(self):\n        \"\"\"Test client for integration testing\"\"\"\n        app = create_pizzeria_app()\n        return TestClient(app)\n\n    def test_get_menu_integration(self, test_client):\n        \"\"\"Test menu retrieval integration\"\"\"\n        response = test_client.get(\"/api/menu/pizzas\")\n\n        assert response.status_code == 200\n        menu = response.json()\n        assert isinstance(menu, list)\n\n        # Validate pizza structure\n        if menu:\n            pizza = menu[0]\n            assert \"id\" in pizza\n            assert \"name\" in pizza\n            assert \"base_price\" in pizza\n\n    def test_place_order_integration(self, test_client):\n        \"\"\"Test order placement integration\"\"\"\n        order_data = {\n            \"customer_name\": \"Integration Test Customer\",\n            \"customer_phone\": \"+1234567890\",\n            \"customer_address\": \"123 Test Street, Test City\",\n            \"pizzas\": [\n                {\n                    \"name\": \"Margherita\",\n                    \"size\": \"large\",\n                    \"toppings\": [\"extra_cheese\"],\n                    \"quantity\": 1\n                }\n            ],\n            \"payment_method\": \"card\"\n        }\n\n        response = test_client.post(\"/api/orders/\", json=order_data)\n\n        assert response.status_code == 201\n        order = response.json()\n        assert order[\"customer_name\"] == \"Integration Test Customer\"\n        assert order[\"status\"] == \"received\"\n        assert \"id\" in order\n</code></pre>"},{"location":"features/mvc-controllers/#api-documentation-generation","title":"\ufffd API Documentation Generation","text":""},{"location":"features/mvc-controllers/#openapi-configuration","title":"OpenAPI Configuration","text":"<p>Configure comprehensive API documentation:</p> <pre><code>from fastapi import FastAPI\nfrom fastapi.openapi.utils import get_openapi\n\ndef create_pizzeria_app_with_docs():\n    \"\"\"Create Mario's Pizzeria app with enhanced documentation\"\"\"\n    app = create_pizzeria_app()\n\n    # Custom OpenAPI schema\n    def custom_openapi():\n        if app.openapi_schema:\n            return app.openapi_schema\n\n        openapi_schema = get_openapi(\n            title=\"Mario's Pizzeria API\",\n            version=\"1.0.0\",\n            description=\"\"\"\n            # \ud83c\udf55 Mario's Pizzeria API\n\n            Welcome to Mario's Pizzeria API! This API provides comprehensive \n            functionality for managing pizza orders, menu items, kitchen workflow, \n            and customer interactions.\n\n            ## Features\n\n            - **Order Management**: Place, track, and manage pizza orders\n            - **Menu Administration**: Manage pizzas, toppings, and availability\n            - **Kitchen Workflow**: Handle order preparation and status updates\n            - **Customer Authentication**: Secure customer account management\n            - **Staff Portal**: Role-based access for staff operations\n            - **Analytics**: Revenue and performance reporting\n\n            ## Authentication\n\n            The API uses OAuth 2.0 with JWT tokens:\n\n            - **Customers**: Phone-based OTP authentication\n            - **Staff**: Username/password with role-based permissions\n\n            ## Rate Limiting\n\n            - **Customers**: 100 requests per hour\n            - **Staff**: 500 requests per hour\n            - **Managers**: Unlimited\n            \"\"\",\n            routes=app.routes,\n        )\n\n        # Add custom tags for better organization\n        openapi_schema[\"tags\"] = [\n            {\n                \"name\": \"Orders\",\n                \"description\": \"Customer order management and tracking\"\n            },\n            {\n                \"name\": \"Menu\",\n                \"description\": \"Pizza menu and item management\"\n            },\n            {\n                \"name\": \"Kitchen\",\n                \"description\": \"Kitchen operations and workflow\"\n            },\n            {\n                \"name\": \"Authentication\",\n                \"description\": \"Customer and staff authentication\"\n            },\n            {\n                \"name\": \"Reports\",\n                \"description\": \"Analytics and reporting (Manager only)\"\n            }\n        ]\n\n        # Add security schemes\n        openapi_schema[\"components\"][\"securitySchemes\"] = {\n            \"BearerAuth\": {\n                \"type\": \"http\",\n                \"scheme\": \"bearer\",\n                \"bearerFormat\": \"JWT\"\n            },\n            \"CustomerAuth\": {\n                \"type\": \"oauth2\",\n                \"flows\": {\n                    \"password\": {\n                        \"tokenUrl\": \"/api/auth/customer/login\",\n                        \"scopes\": {\n                            \"customer\": \"Customer order access\"\n                        }\n                    }\n                }\n            },\n            \"StaffAuth\": {\n                \"type\": \"oauth2\",\n                \"flows\": {\n                    \"password\": {\n                        \"tokenUrl\": \"/api/auth/staff/login\",\n                        \"scopes\": {\n                            \"kitchen\": \"Kitchen operations\",\n                            \"manager\": \"Management functions\"\n                        }\n                    }\n                }\n            }\n        }\n\n        app.openapi_schema = openapi_schema\n        return app.openapi_schema\n\n    app.openapi = custom_openapi\n    return app\n</code></pre>"},{"location":"features/mvc-controllers/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started Guide - Complete pizzeria application tutorial</li> <li>CQRS &amp; Mediation - Command and query handlers used in controllers</li> <li>Dependency Injection - Service registration for controller dependencies</li> <li>Data Access - Repository patterns used by controller commands/queries</li> </ul> <p>This documentation demonstrates MVC controller patterns using Mario's Pizzeria as a consistent example throughout the Neuroglia framework. The examples show real-world API design with authentication, validation, error handling, and comprehensive testing.</p>"},{"location":"features/object-mapping/","title":"\ud83c\udfaf Object Mapping","text":"<p>Neuroglia's object mapping system provides powerful and flexible capabilities for transforming objects between types. Whether converting domain entities to DTOs, mapping API requests to commands, or transforming data between layers, the Mapper class handles complex object-to-object conversions with ease.</p> <p>!!! info \"\ud83c\udfaf What You'll Learn\" - Automatic property mapping with convention-based matching - Custom mapping configurations and transformations - Type conversion and validation - Integration with Mario's Pizzeria domain objects</p>"},{"location":"features/object-mapping/#overview","title":"\ud83c\udfaf Overview","text":"<p>Neuroglia's mapping system offers:</p> <ul> <li>\ud83d\udd04 Automatic Mapping - Convention-based property matching with intelligent type conversion</li> <li>\ud83c\udfa8 Custom Configurations - Fine-grained control over property mappings and transformations</li> <li>\ud83d\udccb Mapping Profiles - Reusable mapping configurations organized in profiles</li> <li>\ud83d\udd27 Type Conversion - Built-in converters for common type transformations</li> <li>\ud83d\udc89 DI Integration - Service-based mapper with configurable profiles</li> </ul>"},{"location":"features/object-mapping/#key-benefits","title":"Key Benefits","text":"<ul> <li>Productivity: Eliminate repetitive mapping code with automatic conventions</li> <li>Type Safety: Strongly-typed mappings with compile-time validation</li> <li>Flexibility: Custom transformations for complex mapping scenarios</li> <li>Testability: Easy mocking and testing of mapping logic</li> <li>Performance: Efficient mapping with minimal reflection overhead</li> </ul>"},{"location":"features/object-mapping/#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<pre><code>flowchart TD\n    A[\"\ud83c\udfaf Source Object&lt;br/&gt;Domain Entity\"]\n    B[\"\ud83d\udd04 Mapper&lt;br/&gt;Main Mapping Service\"]\n    C[\"\ud83d\udccb Mapping Profiles&lt;br/&gt;Configuration Sets\"]\n    D[\"\ud83c\udfa8 Type Converters&lt;br/&gt;Custom Transformations\"]\n\n    subgraph \"\ud83d\udd27 Mapping Pipeline\"\n        E[\"Property Matching\"]\n        F[\"Type Conversion\"]\n        G[\"Custom Logic\"]\n        H[\"Validation\"]\n    end\n\n    subgraph \"\ud83c\udfaf Target Types\"\n        I[\"DTOs\"]\n        J[\"Commands\"]\n        K[\"View Models\"]\n        L[\"API Responses\"]\n    end\n\n    A --&gt; B\n    B --&gt; C\n    B --&gt; D\n    B --&gt; E\n    E --&gt; F\n    F --&gt; G\n    G --&gt; H\n\n    H --&gt; I\n    H --&gt; J\n    H --&gt; K\n    H --&gt; L\n\n    style B fill:#e1f5fe,stroke:#0277bd,stroke-width:3px\n    style C fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\n    style D fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px\n\n    classDef pipeline fill:#fff3e0,stroke:#f57c00,stroke-width:2px\n    class E,F,G,H pipeline\n\n    classDef targets fill:#e3f2fd,stroke:#1976d2,stroke-width:1px\n    class I,J,K,L targets</code></pre>"},{"location":"features/object-mapping/#basic-usage-in-marios-pizzeria","title":"\ud83c\udf55 Basic Usage in Mario's Pizzeria","text":""},{"location":"features/object-mapping/#entity-to-dto-mapping","title":"Entity to DTO Mapping","text":"<p>Let's see how Mario's Pizzeria uses mapping for API responses:</p> <pre><code>from neuroglia.mapping.mapper import Mapper\nfrom dataclasses import dataclass\nfrom decimal import Decimal\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import List\n\n# Domain Entities\nclass OrderStatus(str, Enum):\n    PENDING = \"pending\"\n    COOKING = \"cooking\"\n    READY = \"ready\"\n    DELIVERED = \"delivered\"\n\n@dataclass\nclass Pizza:\n    id: str\n    name: str\n    size: str\n    base_price: Decimal\n    toppings: List[str]\n    preparation_time_minutes: int\n\n    @property\n    def total_price(self) -&gt; Decimal:\n        return self.base_price + (Decimal(\"1.50\") * len(self.toppings))\n\n@dataclass\nclass Order:\n    id: str\n    customer_name: str\n    customer_phone: str\n    pizzas: List[Pizza]\n    status: OrderStatus\n    order_time: datetime\n    estimated_ready_time: datetime\n    total_amount: Decimal\n\n# DTOs for API responses\n@dataclass\nclass PizzaDto:\n    id: str\n    name: str\n    size: str\n    price: str  # String representation for API\n    toppings: List[str]\n    prep_time: int\n\n@dataclass\nclass OrderDto:\n    id: str\n    customer: str  # Different property name\n    phone: str\n    items: List[PizzaDto]  # Different property name\n    status: str\n    ordered_at: str  # ISO string format\n    ready_at: str\n    total: str\n\n# Using the Mapper\nclass OrderService:\n    def __init__(self, mapper: Mapper):\n        self.mapper = mapper\n\n    def get_order_dto(self, order: Order) -&gt; OrderDto:\n        \"\"\"Convert domain order to API DTO\"\"\"\n        return self.mapper.map(order, OrderDto)\n\n    def get_pizza_dto(self, pizza: Pizza) -&gt; PizzaDto:\n        \"\"\"Convert domain pizza to API DTO\"\"\"\n        return self.mapper.map(pizza, PizzaDto)\n\n# Example usage\nmapper = Mapper()\n\n# Configure mapping between Order and OrderDto\nmapper.create_map(Order, OrderDto) \\\n    .map_member(\"customer\", lambda ctx: ctx.source.customer_name) \\\n    .map_member(\"phone\", lambda ctx: ctx.source.customer_phone) \\\n    .map_member(\"items\", lambda ctx: [mapper.map(p, PizzaDto) for p in ctx.source.pizzas]) \\\n    .map_member(\"ordered_at\", lambda ctx: ctx.source.order_time.isoformat()) \\\n    .map_member(\"ready_at\", lambda ctx: ctx.source.estimated_ready_time.isoformat()) \\\n    .map_member(\"total\", lambda ctx: str(ctx.source.total_amount))\n\n# Configure mapping between Pizza and PizzaDto\nmapper.create_map(Pizza, PizzaDto) \\\n    .map_member(\"price\", lambda ctx: str(ctx.source.total_price)) \\\n    .map_member(\"prep_time\", lambda ctx: ctx.source.preparation_time_minutes)\n\n# Map objects\norder = create_sample_order()\norder_dto = mapper.map(order, OrderDto)\n\nprint(f\"Order {order_dto.id} for {order_dto.customer}\")\n# Output: Order order-123 for Mario Luigi\n</code></pre>"},{"location":"features/object-mapping/#mapping-configurations","title":"\ud83c\udfa8 Mapping Configurations","text":""},{"location":"features/object-mapping/#convention-based-mapping","title":"Convention-Based Mapping","text":"<p>The mapper automatically matches properties with the same names:</p> <pre><code>@dataclass\nclass Customer:\n    id: str\n    name: str\n    email: str\n    phone: str\n\n@dataclass\nclass CustomerDto:\n    id: str      # Automatically mapped\n    name: str    # Automatically mapped\n    email: str   # Automatically mapped\n    phone: str   # Automatically mapped\n\n# Simple mapping - no configuration needed\nmapper = Mapper()\ncustomer = Customer(\"123\", \"Luigi Mario\", \"luigi@pizzeria.com\", \"+1-555-LUIGI\")\ncustomer_dto = mapper.map(customer, CustomerDto)\n</code></pre>"},{"location":"features/object-mapping/#custom-member-mapping","title":"Custom Member Mapping","text":"<p>For properties that don't match by name or need transformation:</p> <pre><code>@dataclass\nclass Address:\n    street_address: str\n    city_name: str\n    postal_code: str\n    country_name: str\n\n@dataclass\nclass AddressDto:\n    address_line: str    # Combined field\n    city: str           # Different name\n    zip_code: str       # Different name\n    country: str        # Different name\n\n# Configure custom mappings\nmapper.create_map(Address, AddressDto) \\\n    .map_member(\"address_line\", lambda ctx: ctx.source.street_address) \\\n    .map_member(\"city\", lambda ctx: ctx.source.city_name) \\\n    .map_member(\"zip_code\", lambda ctx: ctx.source.postal_code) \\\n    .map_member(\"country\", lambda ctx: ctx.source.country_name)\n</code></pre>"},{"location":"features/object-mapping/#type-conversion","title":"Type Conversion","text":"<p>Automatic conversion between compatible types:</p> <pre><code>@dataclass\nclass MenuItem:\n    name: str\n    price: Decimal       # Decimal type\n    available: bool\n    category_id: int\n\n@dataclass\nclass MenuItemDto:\n    name: str\n    price: float         # Converted to float\n    available: str       # Converted to string\n    category_id: str     # Converted to string\n\n# Automatic type conversion\nmapper = Mapper()\nitem = MenuItem(\"Margherita\", Decimal(\"15.99\"), True, 1)\nitem_dto = mapper.map(item, MenuItemDto)\n\nassert item_dto.price == 15.99\nassert item_dto.available == \"True\"\nassert item_dto.category_id == \"1\"\n</code></pre>"},{"location":"features/object-mapping/#mapping-profiles","title":"\ud83d\udccb Mapping Profiles","text":"<p>Organize related mappings in reusable profiles:</p> <pre><code>from neuroglia.mapping.mapper import MappingProfile\n\nclass PizzeriaMappingProfile(MappingProfile):\n    \"\"\"Mapping profile for Mario's Pizzeria domain objects\"\"\"\n\n    def configure(self):\n        # Order mappings\n        self.create_map(Order, OrderDto) \\\n            .map_member(\"customer\", lambda ctx: ctx.source.customer_name) \\\n            .map_member(\"phone\", lambda ctx: ctx.source.customer_phone) \\\n            .map_member(\"items\", lambda ctx: self.map_list(ctx.source.pizzas, PizzaDto)) \\\n            .map_member(\"ordered_at\", lambda ctx: ctx.source.order_time.isoformat()) \\\n            .map_member(\"total\", lambda ctx: str(ctx.source.total_amount))\n\n        # Pizza mappings\n        self.create_map(Pizza, PizzaDto) \\\n            .map_member(\"price\", lambda ctx: str(ctx.source.total_price)) \\\n            .map_member(\"prep_time\", lambda ctx: ctx.source.preparation_time_minutes)\n\n        # Customer mappings\n        self.create_map(Customer, CustomerDto)  # Convention-based\n\n        # Address mappings\n        self.create_map(Address, AddressDto) \\\n            .map_member(\"address_line\", lambda ctx: f\"{ctx.source.street_address}\") \\\n            .map_member(\"city\", lambda ctx: ctx.source.city_name) \\\n            .map_member(\"zip_code\", lambda ctx: ctx.source.postal_code)\n\n# Register profile with mapper\nmapper = Mapper()\nmapper.add_profile(PizzeriaMappingProfile())\n</code></pre>"},{"location":"features/object-mapping/#advanced-mapping-patterns","title":"\ud83d\udd27 Advanced Mapping Patterns","text":""},{"location":"features/object-mapping/#collection-mapping","title":"Collection Mapping","text":"<pre><code>from typing import List, Dict\n\n@dataclass\nclass Menu:\n    sections: List[MenuSection]\n    featured_items: Dict[str, Pizza]\n\n@dataclass\nclass MenuDto:\n    sections: List[MenuSectionDto]\n    featured: Dict[str, PizzaDto]\n\n# Configure collection mappings\nmapper.create_map(Menu, MenuDto) \\\n    .map_member(\"sections\", lambda ctx: mapper.map_list(ctx.source.sections, MenuSectionDto)) \\\n    .map_member(\"featured\", lambda ctx: {\n        k: mapper.map(v, PizzaDto)\n        for k, v in ctx.source.featured_items.items()\n    })\n</code></pre>"},{"location":"features/object-mapping/#conditional-mapping","title":"Conditional Mapping","text":"<pre><code>@dataclass\nclass OrderSummaryDto:\n    id: str\n    customer: str\n    status: str\n    total: str\n    special_instructions: str  # Only for certain statuses\n\n# Conditional member mapping\nmapper.create_map(Order, OrderSummaryDto) \\\n    .map_member(\"special_instructions\", lambda ctx:\n        getattr(ctx.source, 'special_instructions', '')\n        if ctx.source.status in [OrderStatus.COOKING, OrderStatus.READY]\n        else None\n    )\n</code></pre>"},{"location":"features/object-mapping/#flattening-complex-objects","title":"Flattening Complex Objects","text":"<pre><code>@dataclass\nclass OrderWithCustomer:\n    id: str\n    customer: Customer\n    pizzas: List[Pizza]\n    status: OrderStatus\n\n@dataclass\nclass FlatOrderDto:\n    order_id: str\n    customer_name: str      # Flattened from customer\n    customer_email: str     # Flattened from customer\n    pizza_count: int        # Computed field\n    status: str\n\n# Flattening mapping\nmapper.create_map(OrderWithCustomer, FlatOrderDto) \\\n    .map_member(\"order_id\", lambda ctx: ctx.source.id) \\\n    .map_member(\"customer_name\", lambda ctx: ctx.source.customer.name) \\\n    .map_member(\"customer_email\", lambda ctx: ctx.source.customer.email) \\\n    .map_member(\"pizza_count\", lambda ctx: len(ctx.source.pizzas))\n</code></pre>"},{"location":"features/object-mapping/#testing-object-mapping","title":"\ud83e\uddea Testing Object Mapping","text":""},{"location":"features/object-mapping/#unit-testing-patterns","title":"Unit Testing Patterns","text":"<pre><code>import pytest\nfrom neuroglia.mapping.mapper import Mapper\n\nclass TestPizzeriaMapping:\n\n    def setup_method(self):\n        self.mapper = Mapper()\n        self.mapper.add_profile(PizzeriaMappingProfile())\n\n    def test_pizza_to_dto_mapping(self):\n        \"\"\"Test Pizza to PizzaDto mapping\"\"\"\n        # Arrange\n        pizza = Pizza(\n            id=\"pizza-123\",\n            name=\"Margherita\",\n            size=\"large\",\n            base_price=Decimal(\"15.99\"),\n            toppings=[\"basil\", \"mozzarella\"],\n            preparation_time_minutes=18\n        )\n\n        # Act\n        pizza_dto = self.mapper.map(pizza, PizzaDto)\n\n        # Assert\n        assert pizza_dto.id == \"pizza-123\"\n        assert pizza_dto.name == \"Margherita\"\n        assert pizza_dto.price == \"18.99\"  # base_price + toppings\n        assert pizza_dto.prep_time == 18\n        assert pizza_dto.toppings == [\"basil\", \"mozzarella\"]\n\n    def test_order_to_dto_mapping_preserves_structure(self):\n        \"\"\"Test complex Order to OrderDto mapping\"\"\"\n        # Arrange\n        order = create_sample_order_with_multiple_pizzas()\n\n        # Act\n        order_dto = self.mapper.map(order, OrderDto)\n\n        # Assert\n        assert order_dto.id == order.id\n        assert order_dto.customer == order.customer_name\n        assert len(order_dto.items) == len(order.pizzas)\n        assert order_dto.total == str(order.total_amount)\n\n    def test_mapping_handles_none_values(self):\n        \"\"\"Test mapping with None values\"\"\"\n        # Arrange\n        customer = Customer(\n            id=\"123\",\n            name=\"Test Customer\",\n            email=None,  # None value\n            phone=\"+1-555-TEST\"\n        )\n\n        # Act\n        customer_dto = self.mapper.map(customer, CustomerDto)\n\n        # Assert\n        assert customer_dto.email is None\n        assert customer_dto.name == \"Test Customer\"\n\n    def test_collection_mapping_preserves_order(self):\n        \"\"\"Test that collection mapping preserves order\"\"\"\n        # Arrange\n        pizzas = [\n            create_pizza(\"Margherita\"),\n            create_pizza(\"Pepperoni\"),\n            create_pizza(\"Hawaiian\")\n        ]\n\n        # Act\n        pizza_dtos = self.mapper.map_list(pizzas, PizzaDto)\n\n        # Assert\n        assert len(pizza_dtos) == 3\n        assert pizza_dtos[0].name == \"Margherita\"\n        assert pizza_dtos[1].name == \"Pepperoni\"\n        assert pizza_dtos[2].name == \"Hawaiian\"\n</code></pre>"},{"location":"features/object-mapping/#real-world-use-cases","title":"\ud83c\udfaf Real-World Use Cases","text":""},{"location":"features/object-mapping/#1-api-controller-integration","title":"1. API Controller Integration","text":"<pre><code>from neuroglia.mvc import ControllerBase\nfrom fastapi import HTTPException\n\nclass OrdersController(ControllerBase):\n    def __init__(self,\n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator,\n                 order_service: OrderService):\n        super().__init__(service_provider, mapper, mediator)\n        self.order_service = order_service\n\n    @get(\"/{order_id}\")\n    async def get_order(self, order_id: str) -&gt; OrderDto:\n        \"\"\"Get order by ID with automatic DTO mapping\"\"\"\n        order = await self.order_service.get_by_id_async(order_id)\n\n        if not order:\n            raise HTTPException(status_code=404, detail=\"Order not found\")\n\n        # Map domain entity to DTO\n        return self.mapper.map(order, OrderDto)\n\n    @post(\"/\")\n    async def create_order(self, create_order_request: CreateOrderRequest) -&gt; OrderDto:\n        \"\"\"Create new order with request mapping\"\"\"\n        # Map request to command\n        command = self.mapper.map(create_order_request, CreateOrderCommand)\n\n        # Execute command\n        result = await self.mediator.execute_async(command)\n\n        if not result.is_success:\n            raise HTTPException(status_code=400, detail=result.error_message)\n\n        # Map result to DTO\n        return self.mapper.map(result.value, OrderDto)\n</code></pre>"},{"location":"features/object-mapping/#2-commandquery-mapping","title":"2. Command/Query Mapping","text":"<pre><code>from neuroglia.mediation import Command, CommandHandler\n\n@dataclass\nclass CreateOrderRequest:\n    customer_name: str\n    customer_phone: str\n    pizza_requests: List[PizzaRequest]\n\n@dataclass\nclass CreateOrderCommand(Command[Order]):\n    customer_name: str\n    customer_phone: str\n    pizza_items: List[PizzaOrderItem]\n\n# Map request to command\nclass OrderMappingProfile(MappingProfile):\n    def configure(self):\n        self.create_map(CreateOrderRequest, CreateOrderCommand) \\\n            .map_member(\"pizza_items\", lambda ctx:\n                [self.map(req, PizzaOrderItem) for req in ctx.source.pizza_requests]\n            )\n</code></pre>"},{"location":"features/object-mapping/#3-event-data-transformation","title":"3. Event Data Transformation","text":"<pre><code>from neuroglia.eventing import DomainEvent\n\n@dataclass\nclass OrderStatusChangedEvent(DomainEvent):\n    order_id: str\n    old_status: str\n    new_status: str\n    customer_email: str\n    notification_data: dict\n\nclass OrderEventService:\n    def __init__(self, mapper: Mapper):\n        self.mapper = mapper\n\n    def create_status_change_event(self, order: Order, old_status: OrderStatus) -&gt; OrderStatusChangedEvent:\n        \"\"\"Create event with mapped data\"\"\"\n\n        # Map order data to event notification data\n        notification_data = {\n            \"order_summary\": self.mapper.map(order, OrderSummaryDto),\n            \"estimated_time\": order.estimated_ready_time.isoformat(),\n            \"total_amount\": str(order.total_amount)\n        }\n\n        return OrderStatusChangedEvent(\n            order_id=order.id,\n            old_status=old_status.value,\n            new_status=order.status.value,\n            customer_email=order.customer.email,\n            notification_data=notification_data\n        )\n</code></pre>"},{"location":"features/object-mapping/#performance-optimization","title":"\ud83d\udd0d Performance Optimization","text":""},{"location":"features/object-mapping/#mapping-performance-tips","title":"Mapping Performance Tips","text":"<pre><code>class OptimizedMappingService:\n    def __init__(self, mapper: Mapper):\n        self.mapper = mapper\n        # Pre-compile mappings for better performance\n        self._initialize_mappings()\n\n    def _initialize_mappings(self):\n        \"\"\"Pre-configure frequently used mappings\"\"\"\n        # Frequently used mappings\n        self.mapper.create_map(Order, OrderDto)\n        self.mapper.create_map(Pizza, PizzaDto)\n        self.mapper.create_map(Customer, CustomerDto)\n\n        # Warm up mapper with sample objects\n        sample_order = create_sample_order()\n        self.mapper.map(sample_order, OrderDto)\n\n    def bulk_map_orders(self, orders: List[Order]) -&gt; List[OrderDto]:\n        \"\"\"Efficiently map large collections\"\"\"\n        return [self.mapper.map(order, OrderDto) for order in orders]\n\n    def map_with_caching(self, source: Any, target_type: Type[T]) -&gt; T:\n        \"\"\"Map with result caching for immutable objects\"\"\"\n        cache_key = f\"{type(source)}-{target_type}-{hash(source)}\"\n\n        if cache_key not in self._mapping_cache:\n            self._mapping_cache[cache_key] = self.mapper.map(source, target_type)\n\n        return self._mapping_cache[cache_key]\n</code></pre>"},{"location":"features/object-mapping/#integration-with-other-features","title":"\ud83d\udd04 Integration with Other Features","text":""},{"location":"features/object-mapping/#mapping-with-serialization","title":"Mapping with Serialization","text":"<pre><code>class OrderApiService:\n    def __init__(self, mapper: Mapper, serializer: JsonSerializer):\n        self.mapper = mapper\n        self.serializer = serializer\n\n    def export_orders_json(self, orders: List[Order]) -&gt; str:\n        \"\"\"Export orders as JSON with DTO mapping\"\"\"\n        # Map to DTOs first\n        order_dtos = self.mapper.map_list(orders, OrderDto)\n\n        # Then serialize\n        return self.serializer.serialize_to_text(order_dtos)\n\n    def import_orders_json(self, json_data: str) -&gt; List[Order]:\n        \"\"\"Import orders from JSON with DTO mapping\"\"\"\n        # Deserialize to DTOs\n        order_dtos = self.serializer.deserialize_from_text(json_data, List[OrderDto])\n\n        # Map to domain entities\n        return self.mapper.map_list(order_dtos, Order)\n</code></pre>"},{"location":"features/object-mapping/#dependency-injection-integration","title":"\ud83d\ude80 Dependency Injection Integration","text":""},{"location":"features/object-mapping/#configuring-mapper-in-di-container","title":"Configuring Mapper in DI Container","text":"<pre><code>from neuroglia.hosting import WebApplicationBuilder\n\ndef configure_mapping(builder: WebApplicationBuilder):\n    \"\"\"Configure object mapping services\"\"\"\n\n    # Register mapper as singleton\n    mapper = Mapper()\n\n    # Add mapping profiles\n    mapper.add_profile(PizzeriaMappingProfile())\n    mapper.add_profile(CustomerMappingProfile())\n    mapper.add_profile(EventMappingProfile())\n\n    builder.services.add_singleton(Mapper, lambda: mapper)\n\n    # Register mapping services\n    builder.services.add_scoped(OrderMappingService)\n    builder.services.add_scoped(CustomerMappingService)\n\n# Usage in controllers\nclass MenuController(ControllerBase):\n    def __init__(self,\n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,  # Injected automatically\n                 mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n</code></pre>"},{"location":"features/object-mapping/#integration-points","title":"\ud83d\udd17 Integration Points","text":""},{"location":"features/object-mapping/#framework-integration","title":"Framework Integration","text":"<p>Object mapping integrates seamlessly with:</p> <ul> <li>Serialization - Map objects before serialization/after deserialization</li> <li>CQRS &amp; Mediation - Map requests to commands and queries</li> <li>MVC Controllers - Automatic request/response mapping</li> <li>Event Sourcing - Transform domain events to external formats</li> </ul>"},{"location":"features/object-mapping/#next-steps","title":"\ud83d\udcda Next Steps","text":"<p>Explore related Neuroglia features:</p> <ul> <li>Serialization - Convert mapped objects to JSON</li> <li>CQRS &amp; Mediation - Use mapping in command/query handlers</li> <li>MVC Controllers - Automatic API object mapping</li> <li>Getting Started Guide - Complete pizzeria implementation</li> </ul> <p>\ud83c\udfaf Best Practice</p> <p>Organize related mappings in profiles and register the Mapper as a singleton in your DI container for optimal performance and maintainability.</p>"},{"location":"features/reactive-programming/","title":"\ud83d\udd04 Reactive Programming","text":"<p>Neuroglia's reactive programming capabilities enable asynchronous event-driven architectures using Observable patterns. Built on RxPY integration, the framework provides powerful tools for handling event streams, background processing, and real-time data flows in Mario's Pizzeria and other applications.</p> <p>!!! info What You'll Learn - Reactive patterns with AsyncRx and Observable streams - Event stream processing and subscription management</p> <ul> <li>Reactive patterns with AsyncRx and Observable streams</li> <li>Event stream processing and subscription management</li> <li>Integration with background services and event sourcing</li> <li>Real-time data flows in pizzeria order processing</li> </ul>"},{"location":"features/reactive-programming/#overview","title":"\ud83c\udfaf Overview","text":"<p>Neuroglia's reactive programming system offers:</p> <ul> <li>\ud83c\udf0a Observable Streams - RxPY-based event streams for asynchronous data processing</li> <li>\ud83d\udd04 AsyncRx Integration - Bridge between async/await and reactive patterns</li> <li>\ud83d\udce1 Event Subscription - Flexible subscription and disposal mechanisms</li> <li>\u26a1 Real-time Processing - Live data streams and immediate event handling</li> <li>\ud83c\udfed Background Services - Long-running reactive processes</li> </ul>"},{"location":"features/reactive-programming/#key-benefits","title":"Key Benefits","text":"<ul> <li>Responsiveness: React to events as they happen with minimal latency</li> <li>Scalability: Handle high-throughput event streams efficiently</li> <li>Decoupling: Loose coupling between event producers and consumers</li> <li>Composability: Chain and transform event streams declaratively</li> <li>Error Handling: Built-in resilience and retry mechanisms</li> </ul>"},{"location":"features/reactive-programming/#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<pre><code>flowchart TD\n    subgraph \"\ud83d\udd04 Reactive Layer\"\n        A[\"\ud83d\udce1 Event Sources&lt;br/&gt;Domain Events, External APIs\"]\n        B[\"\ud83c\udf0a Observable Streams&lt;br/&gt;RxPY Integration\"]\n        C[\"\ud83d\udd04 AsyncRx Bridge&lt;br/&gt;Async/Await Integration\"]\n        D[\"\ud83d\udccb Stream Processing&lt;br/&gt;Filter, Map, Reduce\"]\n    end\n\n    subgraph \"\ud83c\udfaf Event Processing Pipeline\"\n        E[\"\ud83d\udd0d Event Filtering&lt;br/&gt;Business Logic\"]\n        F[\"\ud83d\udd04 Event Transformation&lt;br/&gt;Data Mapping\"]\n        G[\"\ud83c\udfad Event Aggregation&lt;br/&gt;State Updates\"]\n        H[\"\ud83d\udce4 Event Distribution&lt;br/&gt;Multiple Handlers\"]\n    end\n\n    subgraph \"\ud83c\udfed Background Services\"\n        I[\"\ud83d\udcca Event Store Reconciliation&lt;br/&gt;Read Model Updates\"]\n        J[\"\ud83d\udd14 Notification Services&lt;br/&gt;Real-time Alerts\"]\n        K[\"\ud83d\udcc8 Analytics Processing&lt;br/&gt;Business Intelligence\"]\n        L[\"\ud83e\uddf9 Maintenance Tasks&lt;br/&gt;Scheduled Operations\"]\n    end\n\n    A --&gt; B\n    B --&gt; C\n    C --&gt; D\n    D --&gt; E\n    E --&gt; F\n    F --&gt; G\n    G --&gt; H\n\n    H --&gt; I\n    H --&gt; J\n    H --&gt; K\n    H --&gt; L\n\n    style B fill:#e1f5fe,stroke:#0277bd,stroke-width:3px\n    style C fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\n    style D fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px\n\n    classDef pipeline fill:#fff3e0,stroke:#f57c00,stroke-width:2px\n    class E,F,G,H pipeline\n\n    classDef services fill:#fce4ec,stroke:#ad1457,stroke-width:2px\n    class I,J,K,L services</code></pre>"},{"location":"features/reactive-programming/#basic-usage-in-marios-pizzeria","title":"\ud83c\udf55 Basic Usage in Mario's Pizzeria","text":""},{"location":"features/reactive-programming/#real-time-order-processing","title":"Real-time Order Processing","text":"<p>Let's see how Mario's Pizzeria uses reactive patterns for live order tracking:</p> <pre><code>import asyncio\nfrom typing import List, Callable\nfrom rx.subject.subject import Subject\nfrom rx.core.typing import Disposable\nfrom neuroglia.reactive import AsyncRx\nfrom neuroglia.eventing import DomainEvent\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom enum import Enum\n\n# Domain Events for Reactive Processing\nclass OrderStatus(str, Enum):\n    PLACED = \"placed\"\n    CONFIRMED = \"confirmed\"\n    COOKING = \"cooking\"\n    READY = \"ready\"\n    DELIVERED = \"delivered\"\n\n@dataclass\nclass OrderStatusChangedEvent(DomainEvent):\n    order_id: str\n    previous_status: OrderStatus\n    new_status: OrderStatus\n    timestamp: datetime\n    estimated_completion: datetime\n\n@dataclass\nclass KitchenCapacityEvent(DomainEvent):\n    available_ovens: int\n    current_orders: int\n    estimated_wait_minutes: int\n\n# Reactive Order Processing Service\nclass ReactiveOrderProcessor:\n    def __init__(self):\n        # Observable streams for different event types\n        self.order_status_stream = Subject()\n        self.kitchen_capacity_stream = Subject()\n        self.customer_notification_stream = Subject()\n\n        # Subscription management\n        self.subscriptions: List[Disposable] = []\n\n        # Setup reactive processing pipelines\n        self._setup_order_tracking()\n        self._setup_kitchen_monitoring()\n        self._setup_customer_notifications()\n\n    def _setup_order_tracking(self):\n        \"\"\"Setup reactive order status tracking\"\"\"\n        subscription = AsyncRx.subscribe(\n            self.order_status_stream,\n            lambda event: asyncio.create_task(self._process_order_status_change(event))\n        )\n        self.subscriptions.append(subscription)\n\n    def _setup_kitchen_monitoring(self):\n        \"\"\"Setup reactive kitchen capacity monitoring\"\"\"\n        subscription = AsyncRx.subscribe(\n            self.kitchen_capacity_stream,\n            lambda event: asyncio.create_task(self._update_kitchen_dashboard(event))\n        )\n        self.subscriptions.append(subscription)\n\n    def _setup_customer_notifications(self):\n        \"\"\"Setup reactive customer notification processing\"\"\"\n        subscription = AsyncRx.subscribe(\n            self.customer_notification_stream,\n            lambda event: asyncio.create_task(self._send_customer_update(event))\n        )\n        self.subscriptions.append(subscription)\n\n    # Event Publishers\n    def publish_order_status_change(self, event: OrderStatusChangedEvent):\n        \"\"\"Publish order status change to reactive stream\"\"\"\n        self.order_status_stream.on_next(event)\n\n        # Trigger customer notification based on status\n        if event.new_status in [OrderStatus.READY, OrderStatus.DELIVERED]:\n            self.customer_notification_stream.on_next(event)\n\n    def publish_kitchen_capacity_update(self, event: KitchenCapacityEvent):\n        \"\"\"Publish kitchen capacity update to reactive stream\"\"\"\n        self.kitchen_capacity_stream.on_next(event)\n\n    # Event Handlers\n    async def _process_order_status_change(self, event: OrderStatusChangedEvent):\n        \"\"\"Process order status changes reactively\"\"\"\n        print(f\"\ud83d\udd04 Processing order {event.order_id}: {event.previous_status} \u2192 {event.new_status}\")\n\n        # Update order tracking dashboard\n        await self._update_order_dashboard(event)\n\n        # Update estimated delivery times for other orders\n        if event.new_status == OrderStatus.COOKING:\n            await self._recalculate_delivery_estimates(event)\n\n        # Trigger kitchen workflow updates\n        if event.new_status == OrderStatus.CONFIRMED:\n            await self._notify_kitchen_new_order(event)\n\n    async def _update_kitchen_dashboard(self, event: KitchenCapacityEvent):\n        \"\"\"Update kitchen capacity dashboard reactively\"\"\"\n        print(f\"\ud83d\udc68\u200d\ud83c\udf73 Kitchen Update: {event.available_ovens} ovens, {event.current_orders} orders\")\n\n        # Update real-time kitchen display\n        await self._refresh_kitchen_display(event)\n\n        # Adjust order acceptance if capacity is low\n        if event.available_ovens == 0:\n            await self._enable_queue_mode()\n\n    async def _send_customer_update(self, event: OrderStatusChangedEvent):\n        \"\"\"Send customer notifications reactively\"\"\"\n        print(f\"\ud83d\udcf1 Notifying customer about order {event.order_id}: {event.new_status}\")\n\n        # Send SMS/email notification\n        await self._send_notification(event)\n\n        # Update customer mobile app\n        await self._update_mobile_app(event)\n\n# Example Usage\nasync def demonstrate_reactive_order_processing():\n    \"\"\"Demonstrate reactive order processing in action\"\"\"\n    processor = ReactiveOrderProcessor()\n\n    # Simulate order lifecycle events\n    events = [\n        OrderStatusChangedEvent(\n            order_id=\"ORDER-123\",\n            previous_status=OrderStatus.PLACED,\n            new_status=OrderStatus.CONFIRMED,\n            timestamp=datetime.now(),\n            estimated_completion=datetime.now()\n        ),\n        KitchenCapacityEvent(\n            available_ovens=2,\n            current_orders=5,\n            estimated_wait_minutes=15\n        ),\n        OrderStatusChangedEvent(\n            order_id=\"ORDER-123\",\n            previous_status=OrderStatus.CONFIRMED,\n            new_status=OrderStatus.COOKING,\n            timestamp=datetime.now(),\n            estimated_completion=datetime.now()\n        )\n    ]\n\n    # Publish events to reactive streams\n    for event in events:\n        if isinstance(event, OrderStatusChangedEvent):\n            processor.publish_order_status_change(event)\n        elif isinstance(event, KitchenCapacityEvent):\n            processor.publish_kitchen_capacity_update(event)\n\n        # Small delay to see reactive processing\n        await asyncio.sleep(0.1)\n\n    # Cleanup\n    for subscription in processor.subscriptions:\n        subscription.dispose()\n\n# Run the demonstration\nif __name__ == \"__main__\":\n    asyncio.run(demonstrate_reactive_order_processing())\n</code></pre>"},{"location":"features/reactive-programming/#event-stream-processing","title":"\ud83c\udf0a Event Stream Processing","text":""},{"location":"features/reactive-programming/#stream-transformations-and-filtering","title":"Stream Transformations and Filtering","text":"<pre><code>from rx import operators as ops\nfrom typing import AsyncIterable, Dict, Any\n\nclass PizzeriaEventStreamProcessor:\n    def __init__(self):\n        self.order_events_stream = Subject()\n        self.processed_events_stream = Subject()\n\n        # Setup stream processing pipeline\n        self._setup_event_processing_pipeline()\n\n    def _setup_event_processing_pipeline(self):\n        \"\"\"Setup complex event processing with transformations\"\"\"\n\n        # Filter and transform order events\n        filtered_stream = self.order_events_stream.pipe(\n            # Filter only high-priority orders\n            ops.filter(lambda event: self._is_high_priority_order(event)),\n\n            # Transform events to include additional context\n            ops.map(lambda event: self._enrich_event_with_context(event)),\n\n            # Group events by order ID\n            ops.group_by(lambda event: event.order_id),\n\n            # Buffer events for batch processing\n            ops.buffer_with_time(timespan=5.0),  # 5-second windows\n\n            # Process only non-empty buffers\n            ops.filter(lambda events: len(events) &gt; 0)\n        )\n\n        # Subscribe to processed stream\n        AsyncRx.subscribe(\n            filtered_stream,\n            lambda events: asyncio.create_task(self._process_event_batch(events))\n        )\n\n    def _is_high_priority_order(self, event: OrderStatusChangedEvent) -&gt; bool:\n        \"\"\"Filter for high-priority orders (VIP customers, large orders, etc.)\"\"\"\n        # Business logic for priority determination\n        return (\n            hasattr(event, 'customer_tier') and event.customer_tier == 'VIP' or\n            hasattr(event, 'order_value') and event.order_value &gt; 100.0\n        )\n\n    def _enrich_event_with_context(self, event: OrderStatusChangedEvent) -&gt; Dict[str, Any]:\n        \"\"\"Enrich events with additional context for processing\"\"\"\n        return {\n            'original_event': event,\n            'processing_timestamp': datetime.now(),\n            'priority_score': self._calculate_priority_score(event),\n            'estimated_impact': self._estimate_kitchen_impact(event)\n        }\n\n    async def _process_event_batch(self, events: List[Dict[str, Any]]):\n        \"\"\"Process batched events for efficiency\"\"\"\n        print(f\"\ud83d\udd04 Processing batch of {len(events)} high-priority events\")\n\n        # Aggregate processing for better performance\n        order_ids = [e['original_event'].order_id for e in events]\n        await self._batch_update_order_priorities(order_ids)\n\n        # Send consolidated notifications\n        await self._send_batch_notifications(events)\n</code></pre>"},{"location":"features/reactive-programming/#background-services-with-reactive-patterns","title":"\ud83c\udfed Background Services with Reactive Patterns","text":""},{"location":"features/reactive-programming/#event-store-reconciliation","title":"Event Store Reconciliation","text":"<pre><code>from neuroglia.hosting.abstractions import HostedService\nfrom neuroglia.data.infrastructure.event_sourcing import EventStore\nfrom rx.core.typing import Disposable\n\nclass ReactiveEventStoreReconciliator(HostedService):\n    \"\"\"Reactive service for reconciling read models from event store\"\"\"\n\n    def __init__(self, event_store: EventStore, mediator: Mediator):\n        self.event_store = event_store\n        self.mediator = mediator\n        self.subscription: Optional[Disposable] = None\n\n    async def start_async(self):\n        \"\"\"Start reactive event store reconciliation\"\"\"\n        print(\"\ud83d\udd04 Starting reactive event store reconciliation\")\n\n        # Subscribe to event store stream\n        observable = await self.event_store.observe_async('$all')\n        self.subscription = AsyncRx.subscribe(\n            observable,\n            lambda event: asyncio.create_task(self._process_event_record(event))\n        )\n\n    async def stop_async(self):\n        \"\"\"Stop reactive reconciliation\"\"\"\n        if self.subscription:\n            self.subscription.dispose()\n        print(\"\u23f9\ufe0f Stopped reactive event store reconciliation\")\n\n    async def _process_event_record(self, event_record):\n        \"\"\"Process individual event records reactively\"\"\"\n        try:\n            # Deserialize domain event\n            domain_event = self._deserialize_event(event_record)\n\n            # Route to appropriate read model updaters\n            if isinstance(domain_event, OrderStatusChangedEvent):\n                await self._update_order_read_models(domain_event)\n            elif isinstance(domain_event, KitchenCapacityEvent):\n                await self._update_kitchen_read_models(domain_event)\n\n            # Acknowledge event processing\n            await event_record.ack_async()\n\n        except Exception as ex:\n            print(f\"\u274c Error processing event record: {ex}\")\n            await event_record.nack_async()\n\n    async def _update_order_read_models(self, event: OrderStatusChangedEvent):\n        \"\"\"Update order-related read models\"\"\"\n        # Update order status projection\n        update_command = UpdateOrderProjectionCommand(\n            order_id=event.order_id,\n            status=event.new_status,\n            timestamp=event.timestamp\n        )\n        await self.mediator.execute_async(update_command)\n\n        # Update customer order history\n        history_command = UpdateCustomerOrderHistoryCommand(\n            order_id=event.order_id,\n            status_change=event\n        )\n        await self.mediator.execute_async(history_command)\n</code></pre>"},{"location":"features/reactive-programming/#reactive-background-task-scheduler","title":"Reactive Background Task Scheduler","text":"<pre><code>from apscheduler.schedulers.asyncio import AsyncIOScheduler\nfrom rx.subject.subject import Subject\n\nclass ReactiveBackgroundTaskScheduler(HostedService):\n    \"\"\"Reactive background task scheduler for pizzeria operations\"\"\"\n\n    def __init__(self, scheduler: AsyncIOScheduler):\n        self.scheduler = scheduler\n        self.task_request_stream = Subject()\n        self.task_completion_stream = Subject()\n        self.subscription: Optional[Disposable] = None\n\n    async def start_async(self):\n        \"\"\"Start reactive task scheduling\"\"\"\n        print(\"\u26a1 Starting reactive background task scheduler\")\n\n        self.scheduler.start()\n\n        # Subscribe to task request stream\n        self.subscription = AsyncRx.subscribe(\n            self.task_request_stream,\n            lambda task: asyncio.create_task(self._process_task_request(task))\n        )\n\n    async def stop_async(self):\n        \"\"\"Stop reactive task scheduling\"\"\"\n        if self.subscription:\n            self.subscription.dispose()\n        self.scheduler.shutdown(wait=False)\n        print(\"\u23f9\ufe0f Stopped reactive background task scheduler\")\n\n    def schedule_reactive_task(self, task_descriptor: 'TaskDescriptor'):\n        \"\"\"Schedule a task through reactive stream\"\"\"\n        self.task_request_stream.on_next(task_descriptor)\n\n    async def _process_task_request(self, task_descriptor: 'TaskDescriptor'):\n        \"\"\"Process task requests reactively\"\"\"\n        try:\n            # Create task instance\n            task_instance = self._create_task_instance(task_descriptor)\n\n            # Schedule with APScheduler\n            job = self.scheduler.add_job(\n                func=self._execute_task_with_completion_tracking,\n                args=[task_instance, task_descriptor],\n                trigger='date',\n                run_date=task_descriptor.scheduled_time,\n                id=task_descriptor.id\n            )\n\n            print(f\"\ud83d\udcc5 Scheduled task {task_descriptor.name} for {task_descriptor.scheduled_time}\")\n\n        except Exception as ex:\n            print(f\"\u274c Error scheduling task {task_descriptor.name}: {ex}\")\n\n    async def _execute_task_with_completion_tracking(self, task_instance, task_descriptor):\n        \"\"\"Execute task and track completion reactively\"\"\"\n        try:\n            # Execute the actual task\n            result = await task_instance.execute_async()\n\n            # Publish completion event\n            completion_event = TaskCompletionEvent(\n                task_id=task_descriptor.id,\n                task_name=task_descriptor.name,\n                status='completed',\n                result=result,\n                completed_at=datetime.now()\n            )\n            self.task_completion_stream.on_next(completion_event)\n\n        except Exception as ex:\n            # Publish failure event\n            failure_event = TaskCompletionEvent(\n                task_id=task_descriptor.id,\n                task_name=task_descriptor.name,\n                status='failed',\n                error=str(ex),\n                completed_at=datetime.now()\n            )\n            self.task_completion_stream.on_next(failure_event)\n\n# Example background tasks for Mario's Pizzeria\n@dataclass\nclass TaskDescriptor:\n    id: str\n    name: str\n    task_type: str\n    scheduled_time: datetime\n    parameters: Dict[str, Any]\n\nclass InventoryCheckTask:\n    \"\"\"Reactive background task for inventory checking\"\"\"\n\n    async def execute_async(self) -&gt; Dict[str, Any]:\n        \"\"\"Execute inventory check with reactive notifications\"\"\"\n        print(\"\ud83d\udce6 Executing reactive inventory check\")\n\n        # Simulate inventory checking\n        await asyncio.sleep(1)\n\n        # Return results that can trigger other reactive processes\n        return {\n            'low_stock_items': ['mozzarella', 'tomato_sauce'],\n            'reorder_required': True,\n            'next_check_time': datetime.now() + timedelta(hours=4)\n        }\n\nclass OvenMaintenanceTask:\n    \"\"\"Reactive background task for oven maintenance\"\"\"\n\n    async def execute_async(self) -&gt; Dict[str, Any]:\n        \"\"\"Execute oven maintenance with reactive status updates\"\"\"\n        print(\"\ud83d\udd27 Executing reactive oven maintenance\")\n\n        # Simulate maintenance process\n        maintenance_steps = [\n            'temperature_calibration',\n            'cleaning_cycle',\n            'performance_test'\n        ]\n\n        results = {}\n        for step in maintenance_steps:\n            print(f\"   Performing {step}...\")\n            await asyncio.sleep(0.5)  # Simulate work\n            results[step] = 'completed'\n\n        return {\n            'maintenance_completed': True,\n            'oven_status': 'operational',\n            'next_maintenance': datetime.now() + timedelta(days=7)\n        }\n</code></pre>"},{"location":"features/reactive-programming/#testing-reactive-components","title":"\ud83e\uddea Testing Reactive Components","text":""},{"location":"features/reactive-programming/#unit-testing-patterns","title":"Unit Testing Patterns","text":"<pre><code>import pytest\nfrom unittest.mock import Mock, AsyncMock\nfrom rx.subject.subject import Subject\nfrom rx.core.typing import Disposable\n\nclass TestReactiveOrderProcessor:\n\n    def setup_method(self):\n        self.processor = ReactiveOrderProcessor()\n        self.mock_notifications = []\n\n        # Mock external dependencies\n        self.processor._send_notification = AsyncMock()\n        self.processor._update_mobile_app = AsyncMock()\n        self.processor._refresh_kitchen_display = AsyncMock()\n\n    @pytest.mark.asyncio\n    async def test_order_status_change_triggers_processing(self):\n        \"\"\"Test that order status changes trigger reactive processing\"\"\"\n        # Arrange\n        event = OrderStatusChangedEvent(\n            order_id=\"TEST-001\",\n            previous_status=OrderStatus.PLACED,\n            new_status=OrderStatus.CONFIRMED,\n            timestamp=datetime.now(),\n            estimated_completion=datetime.now()\n        )\n\n        # Act\n        self.processor.publish_order_status_change(event)\n        await asyncio.sleep(0.1)  # Allow reactive processing\n\n        # Assert\n        # Verify reactive handlers were called\n        assert len(self.processor.subscriptions) &gt; 0\n\n    @pytest.mark.asyncio\n    async def test_kitchen_capacity_update_triggers_dashboard(self):\n        \"\"\"Test kitchen capacity updates trigger dashboard updates\"\"\"\n        # Arrange\n        event = KitchenCapacityEvent(\n            available_ovens=1,\n            current_orders=8,\n            estimated_wait_minutes=25\n        )\n\n        # Act\n        self.processor.publish_kitchen_capacity_update(event)\n        await asyncio.sleep(0.1)  # Allow reactive processing\n\n        # Assert\n        self.processor._refresh_kitchen_display.assert_called()\n\n    @pytest.mark.asyncio\n    async def test_reactive_stream_subscription_management(self):\n        \"\"\"Test proper subscription lifecycle management\"\"\"\n        # Arrange\n        initial_subscription_count = len(self.processor.subscriptions)\n\n        # Act - Create additional reactive subscription\n        test_stream = Subject()\n        test_subscription = AsyncRx.subscribe(\n            test_stream,\n            lambda x: asyncio.create_task(self._test_handler(x))\n        )\n        self.processor.subscriptions.append(test_subscription)\n\n        # Assert\n        assert len(self.processor.subscriptions) == initial_subscription_count + 1\n\n        # Cleanup\n        test_subscription.dispose()\n        self.processor.subscriptions.remove(test_subscription)\n\n        assert len(self.processor.subscriptions) == initial_subscription_count\n\n    async def _test_handler(self, event):\n        \"\"\"Test event handler for reactive processing\"\"\"\n        self.mock_notifications.append(event)\n\nclass TestReactiveEventStoreReconciliator:\n\n    def setup_method(self):\n        self.mock_event_store = Mock()\n        self.mock_mediator = Mock()\n        self.reconciliator = ReactiveEventStoreReconciliator(\n            self.mock_event_store,\n            self.mock_mediator\n        )\n\n    @pytest.mark.asyncio\n    async def test_start_creates_subscription(self):\n        \"\"\"Test that starting the service creates event store subscription\"\"\"\n        # Arrange\n        mock_observable = Mock()\n        self.mock_event_store.observe_async.return_value = mock_observable\n\n        # Act\n        await self.reconciliator.start_async()\n\n        # Assert\n        self.mock_event_store.observe_async.assert_called_once_with('$all')\n        assert self.reconciliator.subscription is not None\n\n    @pytest.mark.asyncio\n    async def test_stop_disposes_subscription(self):\n        \"\"\"Test that stopping the service properly disposes subscription\"\"\"\n        # Arrange\n        mock_subscription = Mock()\n        self.reconciliator.subscription = mock_subscription\n\n        # Act\n        await self.reconciliator.stop_async()\n\n        # Assert\n        mock_subscription.dispose.assert_called_once()\n</code></pre>"},{"location":"features/reactive-programming/#real-world-integration-patterns","title":"\ud83c\udfaf Real-World Integration Patterns","text":""},{"location":"features/reactive-programming/#1-event-driven-order-pipeline","title":"1. Event-Driven Order Pipeline","text":"<pre><code>class ReactiveOrderPipeline:\n    \"\"\"Complete reactive pipeline for order processing\"\"\"\n\n    def __init__(self, mediator: Mediator, event_store: EventStore):\n        self.mediator = mediator\n        self.event_store = event_store\n\n        # Reactive streams for different stages\n        self.order_placement_stream = Subject()\n        self.payment_processing_stream = Subject()\n        self.kitchen_workflow_stream = Subject()\n        self.delivery_tracking_stream = Subject()\n\n        self._setup_reactive_pipeline()\n\n    def _setup_reactive_pipeline(self):\n        \"\"\"Setup complete reactive order processing pipeline\"\"\"\n\n        # Order placement \u2192 Payment processing\n        AsyncRx.subscribe(\n            self.order_placement_stream,\n            lambda order: self.payment_processing_stream.on_next(order)\n        )\n\n        # Payment processing \u2192 Kitchen workflow\n        AsyncRx.subscribe(\n            self.payment_processing_stream.pipe(\n                ops.filter(lambda order: order.payment_status == 'confirmed')\n            ),\n            lambda order: self.kitchen_workflow_stream.on_next(order)\n        )\n\n        # Kitchen workflow \u2192 Delivery tracking\n        AsyncRx.subscribe(\n            self.kitchen_workflow_stream.pipe(\n                ops.filter(lambda order: order.status == OrderStatus.READY)\n            ),\n            lambda order: self.delivery_tracking_stream.on_next(order)\n        )\n\n        # Final delivery processing\n        AsyncRx.subscribe(\n            self.delivery_tracking_stream,\n            lambda order: asyncio.create_task(self._complete_order_delivery(order))\n        )\n\n    async def process_new_order(self, order: 'Order'):\n        \"\"\"Process new order through reactive pipeline\"\"\"\n        self.order_placement_stream.on_next(order)\n</code></pre>"},{"location":"features/reactive-programming/#2-real-time-analytics-dashboard","title":"2. Real-time Analytics Dashboard","text":"<pre><code>class ReactiveAnalyticsDashboard:\n    \"\"\"Reactive analytics dashboard for pizzeria metrics\"\"\"\n\n    def __init__(self):\n        self.metrics_stream = Subject()\n        self.dashboard_updates = Subject()\n\n        # Setup reactive metrics processing\n        self._setup_metrics_processing()\n\n    def _setup_metrics_processing(self):\n        \"\"\"Setup reactive metrics aggregation and dashboard updates\"\"\"\n\n        # Aggregate metrics in time windows\n        windowed_metrics = self.metrics_stream.pipe(\n            ops.buffer_with_time(timespan=60.0),  # 1-minute windows\n            ops.filter(lambda metrics: len(metrics) &gt; 0),\n            ops.map(lambda metrics: self._aggregate_metrics(metrics))\n        )\n\n        # Update dashboard reactively\n        AsyncRx.subscribe(\n            windowed_metrics,\n            lambda aggregated: self.dashboard_updates.on_next(aggregated)\n        )\n\n        # Setup dashboard update handler\n        AsyncRx.subscribe(\n            self.dashboard_updates,\n            lambda update: asyncio.create_task(self._update_dashboard(update))\n        )\n\n    def publish_metric(self, metric_name: str, value: float, timestamp: datetime):\n        \"\"\"Publish metric to reactive stream\"\"\"\n        self.metrics_stream.on_next({\n            'name': metric_name,\n            'value': value,\n            'timestamp': timestamp\n        })\n\n    async def _update_dashboard(self, aggregated_metrics):\n        \"\"\"Update dashboard with aggregated metrics\"\"\"\n        print(f\"\ud83d\udcca Dashboard Update: {aggregated_metrics}\")\n        # Update real-time dashboard, WebSocket connections, etc.\n</code></pre>"},{"location":"features/reactive-programming/#integration-with-framework-features","title":"\ud83d\udd04 Integration with Framework Features","text":""},{"location":"features/reactive-programming/#event-sourcing-integration","title":"Event Sourcing Integration","text":"<p>Reactive programming integrates seamlessly with Neuroglia's event sourcing:</p> <pre><code>class ReactiveEventSourcingService:\n    \"\"\"Integration between reactive streams and event sourcing\"\"\"\n\n    def __init__(self, event_store: EventStore):\n        self.event_store = event_store\n        self.domain_event_stream = Subject()\n\n        # Setup event sourcing reactive pipeline\n        self._setup_event_sourcing_integration()\n\n    def _setup_event_sourcing_integration(self):\n        \"\"\"Integrate reactive streams with event sourcing\"\"\"\n\n        # Process domain events reactively\n        AsyncRx.subscribe(\n            self.domain_event_stream,\n            lambda event: asyncio.create_task(self._persist_domain_event(event))\n        )\n\n    async def _persist_domain_event(self, domain_event: DomainEvent):\n        \"\"\"Persist domain events and trigger read model updates\"\"\"\n        # Store event in event store\n        await self.event_store.append_async(\n            stream_id=f\"order-{domain_event.aggregate_id}\",\n            events=[domain_event]\n        )\n\n        # Trigger reactive read model reconciliation\n        # (handled by ReactiveEventStoreReconciliator)\n</code></pre>"},{"location":"features/reactive-programming/#dependency-injection-integration","title":"\ud83d\ude80 Dependency Injection Integration","text":""},{"location":"features/reactive-programming/#configuring-reactive-services","title":"Configuring Reactive Services","text":"<pre><code>from neuroglia.hosting import WebApplicationBuilder\n\ndef configure_reactive_services(builder: WebApplicationBuilder):\n    \"\"\"Configure reactive programming services\"\"\"\n\n    # Register reactive services\n    builder.services.add_singleton(ReactiveOrderProcessor)\n    builder.services.add_singleton(ReactiveEventStoreReconciliator)\n    builder.services.add_singleton(ReactiveBackgroundTaskScheduler)\n    builder.services.add_singleton(ReactiveAnalyticsDashboard)\n\n    # Register hosted services for background processing\n    builder.services.add_hosted_service(ReactiveEventStoreReconciliator)\n    builder.services.add_hosted_service(ReactiveBackgroundTaskScheduler)\n\n# Usage in application startup\ndef create_pizzeria_app():\n    builder = WebApplicationBuilder()\n\n    # Configure reactive services\n    configure_reactive_services(builder)\n\n    # Other configurations...\n\n    return builder.build()\n</code></pre>"},{"location":"features/reactive-programming/#integration-points","title":"\ud83d\udd17 Integration Points","text":""},{"location":"features/reactive-programming/#framework-integration","title":"Framework Integration","text":"<p>Reactive programming integrates with:</p> <ul> <li>Event Sourcing - Reactive event store reconciliation</li> <li>CQRS &amp; Mediation - Reactive command/query processing</li> <li>Serialization - Reactive data transformation</li> <li>Object Mapping - Stream-based object conversions</li> </ul>"},{"location":"features/reactive-programming/#next-steps","title":"\ud83d\udcda Next Steps","text":"<p>Explore related Neuroglia features:</p> <ul> <li>Event Sourcing - Event store integration with reactive patterns</li> <li>CQRS &amp; Mediation - Reactive command/query handling</li> <li>Dependency Injection - Service registration for reactive components</li> <li>Getting Started Guide - Complete reactive pizzeria implementation</li> </ul> <p>\ud83d\udd04 Best Practice</p> <p>Use reactive programming for event-driven architectures, real-time data processing, and background services. Always properly manage subscriptions and dispose of them during application shutdown to prevent memory leaks.</p>"},{"location":"features/redis-cache-repository/","title":"\u26a1 Redis Cache Repository","text":"<p>The Neuroglia framework provides high-performance distributed caching through Redis integration, enabling scalable data access patterns with advanced features like distributed locking, hash-based storage, and automatic expiration management.</p>"},{"location":"features/redis-cache-repository/#overview","title":"\ud83c\udfaf Overview","text":"<p>Redis caching is essential for modern microservices that need fast data access, session management, and distributed coordination. The framework's Redis implementation provides:</p> <ul> <li>Distributed Caching: Shared cache across multiple service instances</li> <li>Advanced Data Structures: Strings, hashes, lists, sets, and sorted sets</li> <li>Distributed Locking: Coordination across service instances</li> <li>Automatic Expiration: TTL-based cache invalidation</li> <li>Connection Pooling: Optimized Redis connection management</li> <li>Circuit Breaker: Resilience against Redis unavailability</li> </ul>"},{"location":"features/redis-cache-repository/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>graph TB\n    subgraph \"\ud83c\udf55 Mario's Pizzeria Services\"\n        OrderService[Order Service]\n        MenuService[Menu Service]\n        CustomerService[Customer Service]\n        InventoryService[Inventory Service]\n    end\n\n    subgraph \"\u26a1 Redis Cache Layer\"\n        RedisCache[Redis Cache Repository]\n        DistributedLock[Distributed Lock Manager]\n        ConnectionPool[Connection Pool]\n    end\n\n    subgraph \"\ud83d\udcbe Redis Data Structures\"\n        Strings[String Cache]\n        Hashes[Hash Storage]\n        Sets[Set Operations]\n        SortedSets[Sorted Sets]\n    end\n\n    subgraph \"\ud83d\uddc4\ufe0f Data Sources\"\n        MenuDB[(Menu Database)]\n        OrderDB[(Order Database)]\n        CustomerDB[(Customer Database)]\n    end\n\n    OrderService --&gt; RedisCache\n    MenuService --&gt; RedisCache\n    CustomerService --&gt; RedisCache\n    InventoryService --&gt; RedisCache\n\n    RedisCache --&gt; DistributedLock\n    RedisCache --&gt; ConnectionPool\n\n    ConnectionPool --&gt; Strings\n    ConnectionPool --&gt; Hashes\n    ConnectionPool --&gt; Sets\n    ConnectionPool --&gt; SortedSets\n\n    RedisCache -.-&gt;|Cache Miss| MenuDB\n    RedisCache -.-&gt;|Cache Miss| OrderDB\n    RedisCache -.-&gt;|Cache Miss| CustomerDB\n\n    style RedisCache fill:#e3f2fd\n    style DistributedLock fill:#ffebee\n    style ConnectionPool fill:#e8f5e8</code></pre>"},{"location":"features/redis-cache-repository/#basic-usage","title":"\ud83d\ude80 Basic Usage","text":""},{"location":"features/redis-cache-repository/#service-registration","title":"Service Registration","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.data.redis import RedisRepository, RedisConfig\n\ndef create_app():\n    builder = WebApplicationBuilder()\n\n    # Register Redis cache repository\n    redis_config = RedisConfig(\n        host=\"localhost\",\n        port=6379,\n        db=0,\n        password=\"your_redis_password\",\n        connection_pool_size=20,\n        health_check_interval=30\n    )\n\n    builder.services.add_redis_repository(redis_config)\n\n    app = builder.build()\n    return app\n</code></pre>"},{"location":"features/redis-cache-repository/#simple-cache-operations","title":"Simple Cache Operations","text":"<pre><code>from neuroglia.data.redis import RedisRepository\nfrom neuroglia.dependency_injection import ServiceProviderBase\nimport json\nfrom datetime import timedelta\n\nclass MenuCacheService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.redis = service_provider.get_service(RedisRepository)\n        self.cache_prefix = \"mario_pizzeria:menu\"\n\n    async def cache_menu_item(self, item_id: str, menu_item: dict, ttl_hours: int = 24):\n        \"\"\"Cache a menu item with automatic expiration.\"\"\"\n        cache_key = f\"{self.cache_prefix}:item:{item_id}\"\n        cache_value = json.dumps(menu_item)\n\n        await self.redis.set_async(\n            key=cache_key,\n            value=cache_value,\n            expiration=timedelta(hours=ttl_hours)\n        )\n\n        print(f\"\ud83c\udf55 Cached menu item: {menu_item['name']} (expires in {ttl_hours}h)\")\n\n    async def get_cached_menu_item(self, item_id: str) -&gt; dict:\n        \"\"\"Retrieve cached menu item.\"\"\"\n        cache_key = f\"{self.cache_prefix}:item:{item_id}\"\n\n        cached_value = await self.redis.get_async(cache_key)\n\n        if cached_value:\n            return json.loads(cached_value)\n\n        # Cache miss - load from database\n        menu_item = await self.load_menu_item_from_db(item_id)\n        if menu_item:\n            await self.cache_menu_item(item_id, menu_item)\n\n        return menu_item\n\n    async def invalidate_menu_cache(self, item_id: str = None):\n        \"\"\"Invalidate menu cache entries.\"\"\"\n        if item_id:\n            # Invalidate specific item\n            cache_key = f\"{self.cache_prefix}:item:{item_id}\"\n            await self.redis.delete_async(cache_key)\n        else:\n            # Invalidate all menu items\n            pattern = f\"{self.cache_prefix}:item:*\"\n            await self.redis.delete_pattern_async(pattern)\n\n        print(f\"\ud83d\uddd1\ufe0f Menu cache invalidated: {item_id or 'all items'}\")\n</code></pre>"},{"location":"features/redis-cache-repository/#hash-based-storage","title":"\ud83d\udce6 Hash-Based Storage","text":""},{"location":"features/redis-cache-repository/#customer-session-management","title":"Customer Session Management","text":"<pre><code>from neuroglia.data.redis import RedisHashRepository\n\nclass CustomerSessionService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.redis = service_provider.get_service(RedisRepository)\n        self.session_prefix = \"mario_pizzeria:sessions\"\n\n    async def create_customer_session(self, customer_id: str, session_data: dict):\n        \"\"\"Create customer session using Redis hash.\"\"\"\n        session_key = f\"{self.session_prefix}:{customer_id}\"\n\n        # Store session data as hash fields\n        session_fields = {\n            \"customer_id\": customer_id,\n            \"login_time\": str(datetime.utcnow()),\n            \"cart_items\": json.dumps(session_data.get(\"cart_items\", [])),\n            \"preferences\": json.dumps(session_data.get(\"preferences\", {})),\n            \"last_activity\": str(datetime.utcnow())\n        }\n\n        await self.redis.hset_async(session_key, session_fields)\n        await self.redis.expire_async(session_key, timedelta(hours=4))  # 4-hour session\n\n        print(f\"\ud83d\udc64 Created session for customer {customer_id}\")\n\n    async def update_customer_cart(self, customer_id: str, cart_items: list):\n        \"\"\"Update customer cart in session.\"\"\"\n        session_key = f\"{self.session_prefix}:{customer_id}\"\n\n        # Update specific hash fields\n        updates = {\n            \"cart_items\": json.dumps(cart_items),\n            \"last_activity\": str(datetime.utcnow())\n        }\n\n        await self.redis.hset_async(session_key, updates)\n        print(f\"\ud83d\uded2 Updated cart for customer {customer_id}: {len(cart_items)} items\")\n\n    async def get_customer_session(self, customer_id: str) -&gt; dict:\n        \"\"\"Retrieve complete customer session.\"\"\"\n        session_key = f\"{self.session_prefix}:{customer_id}\"\n\n        session_data = await self.redis.hgetall_async(session_key)\n\n        if not session_data:\n            return None\n\n        # Deserialize JSON fields\n        return {\n            \"customer_id\": session_data.get(\"customer_id\"),\n            \"login_time\": session_data.get(\"login_time\"),\n            \"cart_items\": json.loads(session_data.get(\"cart_items\", \"[]\")),\n            \"preferences\": json.loads(session_data.get(\"preferences\", \"{}\")),\n            \"last_activity\": session_data.get(\"last_activity\")\n        }\n\n    async def get_customer_cart(self, customer_id: str) -&gt; list:\n        \"\"\"Get only the cart items from customer session.\"\"\"\n        session_key = f\"{self.session_prefix}:{customer_id}\"\n\n        cart_json = await self.redis.hget_async(session_key, \"cart_items\")\n        return json.loads(cart_json) if cart_json else []\n</code></pre>"},{"location":"features/redis-cache-repository/#distributed-locking","title":"\ud83d\udd12 Distributed Locking","text":""},{"location":"features/redis-cache-repository/#order-processing-coordination","title":"Order Processing Coordination","text":"<pre><code>from neuroglia.data.redis import DistributedLock, LockTimeoutError\nimport asyncio\n\nclass OrderProcessingService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.redis = service_provider.get_service(RedisRepository)\n        self.lock_timeout = 30  # 30 seconds\n\n    async def process_order_safely(self, order_id: str):\n        \"\"\"Process order with distributed locking to prevent race conditions.\"\"\"\n        lock_key = f\"mario_pizzeria:order_lock:{order_id}\"\n\n        async with DistributedLock(self.redis, lock_key, timeout=self.lock_timeout):\n            try:\n                # Critical section - only one service instance can process this order\n                order = await self.get_order(order_id)\n\n                if order.status != \"pending\":\n                    print(f\"\u26a0\ufe0f Order {order_id} already processed\")\n                    return\n\n                # Process the order\n                await self.validate_inventory(order)\n                await self.charge_customer(order)\n                await self.update_order_status(order_id, \"processing\")\n                await self.notify_kitchen(order)\n\n                print(f\"\u2705 Order {order_id} processed successfully\")\n\n            except InventoryShortageError as e:\n                await self.handle_inventory_shortage(order_id, e)\n            except PaymentError as e:\n                await self.handle_payment_failure(order_id, e)\n\n    async def coordinate_inventory_update(self, ingredient_id: str, quantity_change: int):\n        \"\"\"Update inventory with distributed coordination.\"\"\"\n        lock_key = f\"mario_pizzeria:inventory_lock:{ingredient_id}\"\n\n        try:\n            async with DistributedLock(self.redis, lock_key, timeout=10):\n                # Get current inventory\n                current_stock = await self.get_ingredient_stock(ingredient_id)\n\n                # Validate the change\n                new_stock = current_stock + quantity_change\n                if new_stock &lt; 0:\n                    raise InsufficientInventoryError(\n                        f\"Cannot reduce {ingredient_id} by {abs(quantity_change)}. \"\n                        f\"Current stock: {current_stock}\"\n                    )\n\n                # Update inventory atomically\n                await self.update_ingredient_stock(ingredient_id, new_stock)\n\n                # Update cache\n                await self.cache_ingredient_stock(ingredient_id, new_stock)\n\n                print(f\"\ud83d\udce6 Inventory updated: {ingredient_id} = {new_stock}\")\n\n        except LockTimeoutError:\n            print(f\"\u23f0 Could not acquire inventory lock for {ingredient_id}\")\n            raise ConcurrentUpdateError(\"Inventory update failed due to concurrent access\")\n</code></pre>"},{"location":"features/redis-cache-repository/#kitchen-queue-management","title":"Kitchen Queue Management","text":"<pre><code>class KitchenQueueService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.redis = service_provider.get_service(RedisRepository)\n        self.queue_key = \"mario_pizzeria:kitchen_queue\"\n        self.processing_key = \"mario_pizzeria:kitchen_processing\"\n\n    async def add_order_to_queue(self, order_id: str, priority: int = 0):\n        \"\"\"Add order to kitchen queue with priority.\"\"\"\n        # Use Redis sorted set for priority queue\n        order_data = {\n            \"order_id\": order_id,\n            \"queued_at\": datetime.utcnow().isoformat(),\n            \"priority\": priority\n        }\n\n        await self.redis.zadd_async(\n            self.queue_key,\n            {json.dumps(order_data): priority}\n        )\n\n        print(f\"\ud83d\udc68\u200d\ud83c\udf73 Added order {order_id} to kitchen queue (priority: {priority})\")\n\n    async def get_next_order(self, kitchen_station_id: str) -&gt; dict:\n        \"\"\"Get next order for kitchen processing with distributed coordination.\"\"\"\n        lock_key = f\"mario_pizzeria:queue_lock\"\n\n        async with DistributedLock(self.redis, lock_key, timeout=5):\n            # Get highest priority order\n            orders = await self.redis.zrange_async(\n                self.queue_key,\n                0, 0,\n                desc=True,\n                withscores=True\n            )\n\n            if not orders:\n                return None\n\n            order_json, priority = orders[0]\n            order_data = json.loads(order_json)\n\n            # Move from queue to processing\n            await self.redis.zrem_async(self.queue_key, order_json)\n\n            processing_data = {\n                **order_data,\n                \"kitchen_station\": kitchen_station_id,\n                \"started_at\": datetime.utcnow().isoformat()\n            }\n\n            await self.redis.hset_async(\n                self.processing_key,\n                order_data[\"order_id\"],\n                json.dumps(processing_data)\n            )\n\n            return order_data\n\n    async def complete_order_processing(self, order_id: str):\n        \"\"\"Mark order processing as complete.\"\"\"\n        await self.redis.hdel_async(self.processing_key, order_id)\n        print(f\"\u2705 Order {order_id} processing completed\")\n</code></pre>"},{"location":"features/redis-cache-repository/#advanced-data-structures","title":"\ud83d\udcca Advanced Data Structures","text":""},{"location":"features/redis-cache-repository/#real-time-analytics-with-sorted-sets","title":"Real-time Analytics with Sorted Sets","text":"<pre><code>class PizzaAnalyticsService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.redis = service_provider.get_service(RedisRepository)\n        self.analytics_prefix = \"mario_pizzeria:analytics\"\n\n    async def track_popular_pizzas(self, pizza_name: str):\n        \"\"\"Track pizza popularity using sorted sets.\"\"\"\n        popularity_key = f\"{self.analytics_prefix}:pizza_popularity\"\n\n        # Increment pizza order count\n        await self.redis.zincrby_async(popularity_key, 1, pizza_name)\n\n        # Keep only top 50 pizzas\n        await self.redis.zremrangebyrank_async(popularity_key, 0, -51)\n\n    async def get_top_pizzas(self, limit: int = 10) -&gt; list:\n        \"\"\"Get most popular pizzas.\"\"\"\n        popularity_key = f\"{self.analytics_prefix}:pizza_popularity\"\n\n        top_pizzas = await self.redis.zrevrange_async(\n            popularity_key,\n            0,\n            limit - 1,\n            withscores=True\n        )\n\n        return [\n            {\"name\": pizza.decode(), \"order_count\": int(score)}\n            for pizza, score in top_pizzas\n        ]\n\n    async def track_hourly_orders(self, hour: int):\n        \"\"\"Track orders per hour using hash.\"\"\"\n        today = datetime.now().date().isoformat()\n        hourly_key = f\"{self.analytics_prefix}:hourly:{today}\"\n\n        await self.redis.hincrby_async(hourly_key, str(hour), 1)\n        await self.redis.expire_async(hourly_key, timedelta(days=7))  # Keep for a week\n\n    async def get_hourly_distribution(self, date: str = None) -&gt; dict:\n        \"\"\"Get order distribution by hour.\"\"\"\n        if not date:\n            date = datetime.now().date().isoformat()\n\n        hourly_key = f\"{self.analytics_prefix}:hourly:{date}\"\n        hourly_data = await self.redis.hgetall_async(hourly_key)\n\n        return {\n            int(hour): int(count)\n            for hour, count in hourly_data.items()\n        }\n</code></pre>"},{"location":"features/redis-cache-repository/#set-operations-for-customer-segmentation","title":"Set Operations for Customer Segmentation","text":"<pre><code>class CustomerSegmentationService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.redis = service_provider.get_service(RedisRepository)\n        self.segment_prefix = \"mario_pizzeria:segments\"\n\n    async def add_customer_to_segment(self, customer_id: str, segment: str):\n        \"\"\"Add customer to marketing segment.\"\"\"\n        segment_key = f\"{self.segment_prefix}:{segment}\"\n        await self.redis.sadd_async(segment_key, customer_id)\n\n        # Set segment expiration (30 days)\n        await self.redis.expire_async(segment_key, timedelta(days=30))\n\n    async def get_segment_customers(self, segment: str) -&gt; set:\n        \"\"\"Get all customers in a segment.\"\"\"\n        segment_key = f\"{self.segment_prefix}:{segment}\"\n        return await self.redis.smembers_async(segment_key)\n\n    async def find_overlapping_customers(self, segment1: str, segment2: str) -&gt; set:\n        \"\"\"Find customers in both segments.\"\"\"\n        key1 = f\"{self.segment_prefix}:{segment1}\"\n        key2 = f\"{self.segment_prefix}:{segment2}\"\n\n        return await self.redis.sinter_async([key1, key2])\n\n    async def create_targeted_campaign(self, segments: list, campaign_id: str):\n        \"\"\"Create campaign targeting multiple segments.\"\"\"\n        segment_keys = [f\"{self.segment_prefix}:{seg}\" for seg in segments]\n        campaign_key = f\"{self.segment_prefix}:campaign:{campaign_id}\"\n\n        # Union of all target segments\n        await self.redis.sunionstore_async(campaign_key, segment_keys)\n\n        # Campaign expires in 7 days\n        await self.redis.expire_async(campaign_key, timedelta(days=7))\n\n        target_count = await self.redis.scard_async(campaign_key)\n        print(f\"\ud83c\udfaf Campaign {campaign_id} targets {target_count} customers\")\n\n        return target_count\n</code></pre>"},{"location":"features/redis-cache-repository/#circuit-breaker-and-resilience","title":"\ud83d\udee1\ufe0f Circuit Breaker and Resilience","text":""},{"location":"features/redis-cache-repository/#resilient-cache-operations","title":"Resilient Cache Operations","text":"<pre><code>from neuroglia.data.redis import CircuitBreakerPolicy, CacheException\n\nclass ResilientMenuService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.redis = service_provider.get_service(RedisRepository)\n        self.circuit_breaker = CircuitBreakerPolicy(\n            failure_threshold=5,\n            recovery_timeout=60,\n            success_threshold=3\n        )\n        self.fallback_cache = {}  # In-memory fallback\n\n    @circuit_breaker.apply\n    async def get_menu_with_fallback(self, menu_id: str) -&gt; dict:\n        \"\"\"Get menu with circuit breaker and fallback.\"\"\"\n        try:\n            # Try Redis cache first\n            cache_key = f\"mario_pizzeria:menu:{menu_id}\"\n            cached_menu = await self.redis.get_async(cache_key)\n\n            if cached_menu:\n                menu_data = json.loads(cached_menu)\n                # Update fallback cache\n                self.fallback_cache[menu_id] = menu_data\n                return menu_data\n\n            # Cache miss - load from database\n            menu_data = await self.load_menu_from_database(menu_id)\n\n            # Cache in Redis\n            await self.redis.set_async(\n                cache_key,\n                json.dumps(menu_data),\n                expiration=timedelta(hours=6)\n            )\n\n            # Update fallback cache\n            self.fallback_cache[menu_id] = menu_data\n            return menu_data\n\n        except CacheException as e:\n            print(f\"\u26a0\ufe0f Redis unavailable, using fallback cache: {e}\")\n\n            # Use fallback cache\n            if menu_id in self.fallback_cache:\n                return self.fallback_cache[menu_id]\n\n            # Last resort - load from database\n            return await self.load_menu_from_database(menu_id)\n\n    async def warm_fallback_cache(self):\n        \"\"\"Pre-load frequently accessed items into fallback cache.\"\"\"\n        popular_menus = [\"margherita\", \"pepperoni\", \"quattro_stagioni\"]\n\n        for menu_id in popular_menus:\n            try:\n                menu_data = await self.get_menu_with_fallback(menu_id)\n                self.fallback_cache[menu_id] = menu_data\n            except Exception as e:\n                print(f\"Failed to warm cache for {menu_id}: {e}\")\n</code></pre>"},{"location":"features/redis-cache-repository/#advanced-configuration","title":"\ud83d\udd27 Advanced Configuration","text":""},{"location":"features/redis-cache-repository/#connection-pool-and-performance-tuning","title":"Connection Pool and Performance Tuning","text":"<pre><code>from neuroglia.data.redis import RedisConfig, ConnectionPoolConfig\n\ndef create_optimized_redis_config():\n    connection_config = ConnectionPoolConfig(\n        max_connections=50,\n        retry_on_timeout=True,\n        health_check_interval=30,\n\n        # Connection timeouts\n        socket_timeout=2.0,\n        socket_connect_timeout=2.0,\n\n        # Connection pooling\n        connection_pool_class_kwargs={\n            'max_connections_per_pool': 50,\n            'retry_on_timeout': True,\n            'socket_keepalive': True,\n            'socket_keepalive_options': {},\n        },\n\n        # Cluster configuration (if using Redis Cluster)\n        skip_full_coverage_check=True,\n        decode_responses=True\n    )\n\n    redis_config = RedisConfig(\n        host=\"redis://localhost:6379\",\n        connection_pool=connection_config,\n\n        # Performance settings\n        retry_policy={\n            'retries': 3,\n            'retry_delay': 0.1,\n            'backoff_factor': 2,\n            'max_retry_delay': 1.0\n        },\n\n        # Monitoring\n        enable_metrics=True,\n        metrics_prefix=\"mario_pizzeria_redis\",\n\n        # Security\n        ssl_cert_reqs=None,\n        ssl_ca_certs=None,\n        ssl_keyfile=None,\n        ssl_certfile=None\n    )\n\n    return redis_config\n</code></pre>"},{"location":"features/redis-cache-repository/#custom-serialization-strategies","title":"Custom Serialization Strategies","text":"<pre><code>from neuroglia.data.redis import SerializationStrategy\nimport pickle\nimport msgpack\n\nclass CustomSerializationService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.redis = service_provider.get_service(RedisRepository)\n\n    async def cache_with_msgpack(self, key: str, data: dict):\n        \"\"\"Cache data using MessagePack serialization.\"\"\"\n        serialized = msgpack.packb(data)\n        await self.redis.set_async(key, serialized)\n\n    async def get_with_msgpack(self, key: str) -&gt; dict:\n        \"\"\"Retrieve data with MessagePack deserialization.\"\"\"\n        serialized = await self.redis.get_async(key)\n        if serialized:\n            return msgpack.unpackb(serialized, raw=False)\n        return None\n\n    async def cache_complex_object(self, key: str, obj):\n        \"\"\"Cache complex Python objects using pickle.\"\"\"\n        serialized = pickle.dumps(obj)\n        await self.redis.set_async(key, serialized)\n\n    async def get_complex_object(self, key: str):\n        \"\"\"Retrieve complex Python objects.\"\"\"\n        serialized = await self.redis.get_async(key)\n        if serialized:\n            return pickle.loads(serialized)\n        return None\n</code></pre>"},{"location":"features/redis-cache-repository/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"features/redis-cache-repository/#unit-testing-with-redis-mock","title":"Unit Testing with Redis Mock","text":"<pre><code>import pytest\nfrom unittest.mock import AsyncMock, Mock\nfrom neuroglia.data.redis import RedisRepository\n\nclass TestMenuCacheService:\n\n    @pytest.fixture\n    def mock_redis(self):\n        redis = Mock(spec=RedisRepository)\n        redis.get_async = AsyncMock()\n        redis.set_async = AsyncMock()\n        redis.delete_async = AsyncMock()\n        redis.hget_async = AsyncMock()\n        redis.hset_async = AsyncMock()\n        return redis\n\n    @pytest.fixture\n    def menu_service(self, mock_redis):\n        service_provider = Mock()\n        service_provider.get_service.return_value = mock_redis\n        return MenuCacheService(service_provider)\n\n    @pytest.mark.asyncio\n    async def test_cache_menu_item(self, menu_service, mock_redis):\n        \"\"\"Test menu item caching.\"\"\"\n        menu_item = {\"name\": \"Margherita\", \"price\": 12.99}\n\n        await menu_service.cache_menu_item(\"margherita\", menu_item)\n\n        mock_redis.set_async.assert_called_once()\n        call_args = mock_redis.set_async.call_args\n        assert \"mario_pizzeria:menu:item:margherita\" in call_args[1][\"key\"]\n\n    @pytest.mark.asyncio\n    async def test_cache_hit(self, menu_service, mock_redis):\n        \"\"\"Test successful cache retrieval.\"\"\"\n        cached_data = '{\"name\": \"Margherita\", \"price\": 12.99}'\n        mock_redis.get_async.return_value = cached_data\n\n        result = await menu_service.get_cached_menu_item(\"margherita\")\n\n        assert result[\"name\"] == \"Margherita\"\n        assert result[\"price\"] == 12.99\n\n    @pytest.mark.asyncio\n    async def test_cache_miss(self, menu_service, mock_redis):\n        \"\"\"Test cache miss behavior.\"\"\"\n        mock_redis.get_async.return_value = None\n        menu_service.load_menu_item_from_db = AsyncMock(\n            return_value={\"name\": \"Pepperoni\", \"price\": 15.99}\n        )\n\n        result = await menu_service.get_cached_menu_item(\"pepperoni\")\n\n        assert result[\"name\"] == \"Pepperoni\"\n        # Should cache the loaded data\n        mock_redis.set_async.assert_called()\n</code></pre>"},{"location":"features/redis-cache-repository/#integration-testing-with-redis","title":"Integration Testing with Redis","text":"<pre><code>@pytest.mark.integration\nclass TestRedisIntegration:\n\n    @pytest.fixture\n    async def redis_repository(self):\n        config = RedisConfig(\n            host=\"redis://localhost:6379/15\",  # Test database\n            connection_pool_size=5\n        )\n        redis = RedisRepository(config)\n        await redis.connect()\n        yield redis\n        await redis.flushdb()  # Clean up\n        await redis.disconnect()\n\n    @pytest.mark.asyncio\n    async def test_distributed_locking(self, redis_repository):\n        \"\"\"Test distributed locking behavior.\"\"\"\n        lock_key = \"test_lock\"\n\n        # Acquire lock\n        lock = DistributedLock(redis_repository, lock_key, timeout=5)\n\n        async with lock:\n            # Lock should be held\n            assert await redis_repository.exists_async(lock_key)\n\n        # Lock should be released\n        assert not await redis_repository.exists_async(lock_key)\n\n    @pytest.mark.asyncio\n    async def test_hash_operations(self, redis_repository):\n        \"\"\"Test Redis hash operations.\"\"\"\n        hash_key = \"test_hash\"\n\n        # Set hash fields\n        fields = {\"field1\": \"value1\", \"field2\": \"value2\"}\n        await redis_repository.hset_async(hash_key, fields)\n\n        # Get specific field\n        value = await redis_repository.hget_async(hash_key, \"field1\")\n        assert value == \"value1\"\n\n        # Get all fields\n        all_fields = await redis_repository.hgetall_async(hash_key)\n        assert all_fields == fields\n</code></pre>"},{"location":"features/redis-cache-repository/#monitoring-and-performance","title":"\ud83d\udcca Monitoring and Performance","text":""},{"location":"features/redis-cache-repository/#cache-performance-metrics","title":"Cache Performance Metrics","text":"<pre><code>from neuroglia.data.redis import CacheMetrics\n\nclass CachePerformanceMonitor:\n    def __init__(self, redis: RedisRepository):\n        self.redis = redis\n        self.metrics = CacheMetrics()\n\n    async def track_cache_operation(self, operation: str, key: str, hit: bool = None):\n        \"\"\"Track cache operation metrics.\"\"\"\n        await self.metrics.increment_counter(f\"cache_operations_{operation}\")\n\n        if hit is not None:\n            status = \"hit\" if hit else \"miss\"\n            await self.metrics.increment_counter(f\"cache_{status}\")\n            await self.metrics.set_gauge(\"cache_hit_ratio\", self.calculate_hit_ratio())\n\n    async def get_performance_summary(self) -&gt; dict:\n        \"\"\"Get cache performance summary.\"\"\"\n        return {\n            \"total_operations\": await self.metrics.get_counter(\"cache_operations_total\"),\n            \"cache_hits\": await self.metrics.get_counter(\"cache_hit\"),\n            \"cache_misses\": await self.metrics.get_counter(\"cache_miss\"),\n            \"hit_ratio\": await self.metrics.get_gauge(\"cache_hit_ratio\"),\n            \"active_connections\": await self.redis.connection_pool.created_connections,\n            \"memory_usage\": await self.redis.memory_usage()\n        }\n\n    def calculate_hit_ratio(self) -&gt; float:\n        \"\"\"Calculate cache hit ratio.\"\"\"\n        hits = self.metrics.get_counter(\"cache_hit\")\n        misses = self.metrics.get_counter(\"cache_miss\")\n        total = hits + misses\n\n        return (hits / total) if total &gt; 0 else 0.0\n</code></pre>"},{"location":"features/redis-cache-repository/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\u23f0 Background Task Scheduling - Distributed job coordination</li> <li>\ud83d\udd27 Dependency Injection - Service registration patterns</li> <li>\ud83c\udf10 HTTP Service Client - External service caching</li> <li>\ud83d\udcca Enhanced Model Validation - Data validation caching</li> <li>\ud83d\udcc1 Data Access - Repository patterns</li> </ul> <p>The Redis Cache Repository provides enterprise-grade caching capabilities that enable Mario's Pizzeria to handle high-volume operations with optimal performance. Through distributed locking, advanced data structures, and comprehensive resilience patterns, the system ensures reliable and scalable caching across all service instances.</p>"},{"location":"features/resilient-handler-discovery/","title":"\ud83d\udee1\ufe0f Resilient Handler Discovery","text":"<p>The Neuroglia framework now includes Resilient Handler Discovery in the Mediator, designed to handle real-world scenarios where packages may have complex dependencies or mixed architectural patterns.</p>"},{"location":"features/resilient-handler-discovery/#problem-solved","title":"\ud83c\udfaf Problem Solved","text":"<p>Previously, <code>Mediator.configure()</code> would fail completely if a package's <code>__init__.py</code> had any import errors, even when the package contained valid handlers that could be imported individually. This blocked automatic discovery in:</p> <ul> <li>Legacy migrations from UseCase patterns to CQRS handlers</li> <li>Mixed codebases with varying dependency graphs</li> <li>Optional dependencies that may not be available in all environments</li> <li>Modular monoliths with packages containing both new and legacy patterns</li> </ul>"},{"location":"features/resilient-handler-discovery/#how-it-works","title":"\ud83c\udfd7\ufe0f How It Works","text":"<p>The resilient discovery implements a two-stage fallback strategy:</p>"},{"location":"features/resilient-handler-discovery/#stage-1-package-import-original-behavior","title":"Stage 1: Package Import (Original Behavior)","text":"<pre><code># Attempts to import the entire package\nMediator.configure(builder, ['application.runtime_agent.queries'])\n</code></pre> <p>If successful, handlers are discovered and registered normally.</p>"},{"location":"features/resilient-handler-discovery/#stage-2-individual-module-fallback","title":"Stage 2: Individual Module Fallback","text":"<pre><code># If package import fails, falls back to:\n# 1. Discover individual .py files in the package directory\n# 2. Attempt to import each module individually\n# 3. Register handlers from successful imports\n# 4. Skip modules with import failures\n\n# Example fallback discovery:\n# application.runtime_agent.queries.get_worker_query     \u2705 SUCCESS\n# application.runtime_agent.queries.list_workers_query   \u2705 SUCCESS\n# application.runtime_agent.queries.broken_module        \u274c SKIPPED\n</code></pre>"},{"location":"features/resilient-handler-discovery/#usage-examples","title":"\ud83d\ude80 Usage Examples","text":""},{"location":"features/resilient-handler-discovery/#basic-usage-unchanged","title":"Basic Usage (Unchanged)","text":"<pre><code>from neuroglia.mediation import Mediator\nfrom neuroglia.hosting import WebApplicationBuilder\n\nbuilder = WebApplicationBuilder()\n\n# This now works even if some packages have dependency issues\nMediator.configure(builder, [\n    'application.commands',           # May have legacy UseCase imports\n    'application.queries',            # Clean CQRS handlers\n    'application.event_handlers'      # Mixed dependencies\n])\n\napp = builder.build()\n</code></pre>"},{"location":"features/resilient-handler-discovery/#mixed-legacymodern-codebase","title":"Mixed Legacy/Modern Codebase","text":"<pre><code># Your package structure:\n# application/\n# \u251c\u2500\u2500 __init__.py                    # \u274c Imports missing UseCase class\n# \u251c\u2500\u2500 legacy_use_cases.py           # \u274c Uses old patterns\n# \u2514\u2500\u2500 queries/\n#     \u251c\u2500\u2500 __init__.py               # \u2705 Clean file\n#     \u251c\u2500\u2500 get_user_query.py         # \u2705 Valid QueryHandler\n#     \u2514\u2500\u2500 list_users_query.py       # \u2705 Valid QueryHandler\n\n# This now works! Handlers are discovered from individual modules\nMediator.configure(builder, ['application.queries'])\n</code></pre>"},{"location":"features/resilient-handler-discovery/#debugging-discovery-issues","title":"Debugging Discovery Issues","text":"<pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\n\n# Enable detailed logging to see what's discovered vs skipped\nMediator.configure(builder, ['your.package.name'])\n\n# Sample output:\n# WARNING: Package import failed for 'application.queries': UseCase not found\n# INFO: Attempting fallback: scanning individual modules\n# DEBUG: Discovered submodule: application.queries.get_user_query\n# DEBUG: Discovered submodule: application.queries.list_users_query\n# INFO: Successfully registered 2 handlers from submodule: application.queries.get_user_query\n# INFO: Fallback succeeded: registered 4 handlers from individual modules\n</code></pre>"},{"location":"features/resilient-handler-discovery/#logging-and-diagnostics","title":"\ud83d\udd0d Logging and Diagnostics","text":"<p>The resilient discovery provides comprehensive logging at different levels:</p>"},{"location":"features/resilient-handler-discovery/#info-level-summary-information","title":"INFO Level - Summary Information","text":"<pre><code>INFO: Successfully registered 3 handlers from package: application.commands\nINFO: Fallback succeeded: registered 2 handlers from individual modules in 'application.queries'\nINFO: Handler discovery completed: 5 total handlers registered from 2 module specifications\n</code></pre>"},{"location":"features/resilient-handler-discovery/#warning-level-import-issues","title":"WARNING Level - Import Issues","text":"<pre><code>WARNING: Package import failed for 'application.queries': cannot import name 'UseCase'\nWARNING: No submodules discovered for package: broken.package\nWARNING: Error registering handlers from module application.legacy: circular import\n</code></pre>"},{"location":"features/resilient-handler-discovery/#debug-level-detailed-discovery","title":"DEBUG Level - Detailed Discovery","text":"<pre><code>DEBUG: Attempting to load package: application.queries\nDEBUG: Found 3 potential submodules in application.queries\nDEBUG: Discovered submodule: application.queries.get_user_query\nDEBUG: Successfully registered QueryHandler: GetUserQueryHandler from application.queries.get_user_query\nDEBUG: Skipping submodule 'application.queries.broken_module': ImportError\n</code></pre>"},{"location":"features/resilient-handler-discovery/#best-practices","title":"\ud83e\uddea Best Practices","text":""},{"location":"features/resilient-handler-discovery/#1-incremental-migration-strategy","title":"1. Incremental Migration Strategy","text":"<pre><code># Start with clean packages, gradually add legacy ones\nmodules = [\n    'application.commands.user',      # \u2705 Clean CQRS handlers\n    'application.queries.user',       # \u2705 Clean CQRS handlers\n    'application.legacy.commands',    # \u26a0\ufe0f  Mixed patterns - will use fallback\n]\n\nMediator.configure(builder, modules)\n</code></pre>"},{"location":"features/resilient-handler-discovery/#2-package-organization","title":"2. Package Organization","text":"<pre><code># Recommended: Separate clean handlers from legacy code\napplication/\n\u251c\u2500\u2500 handlers/              # \u2705 Clean CQRS handlers only\n\u2502   \u251c\u2500\u2500 commands/\n\u2502   \u2514\u2500\u2500 queries/\n\u2514\u2500\u2500 legacy/               # \u26a0\ufe0f  Old patterns with complex dependencies\n    \u251c\u2500\u2500 use_cases/\n    \u2514\u2500\u2500 services/\n</code></pre>"},{"location":"features/resilient-handler-discovery/#3-gradual-cleanup","title":"3. Gradual Cleanup","text":"<pre><code># As you migrate legacy code, packages will automatically\n# switch from fallback discovery to normal discovery\n# No changes needed in configuration!\n\n# Before migration (uses fallback):\n# WARNING: Package import failed, using fallback discovery\n\n# After migration (normal discovery):\n# INFO: Successfully registered 5 handlers from package: application.commands\n</code></pre>"},{"location":"features/resilient-handler-discovery/#advanced-configuration","title":"\ud83d\udd27 Advanced Configuration","text":""},{"location":"features/resilient-handler-discovery/#individual-module-specification","title":"Individual Module Specification","text":"<p>You can also specify individual modules instead of packages:</p> <pre><code>Mediator.configure(builder, [\n    'application.commands.create_user_command',\n    'application.commands.update_user_command',\n    'application.queries.get_user_query'\n])\n</code></pre>"},{"location":"features/resilient-handler-discovery/#error-handling","title":"Error Handling","text":"<pre><code>try:\n    Mediator.configure(builder, ['your.package'])\nexcept Exception as e:\n    # Resilient discovery should prevent most exceptions,\n    # but you can still catch unexpected errors\n    logger.error(f\"Handler discovery failed: {e}\")\n</code></pre>"},{"location":"features/resilient-handler-discovery/#migration-from-manual-registration","title":"\ud83d\udea8 Migration from Manual Registration","text":""},{"location":"features/resilient-handler-discovery/#before-manual-workaround","title":"Before (Manual Workaround)","text":"<pre><code># Old approach - manual registration due to import failures\ntry:\n    from application.queries.get_user_query import GetUserQueryHandler\n    from application.queries.list_users_query import ListUsersQueryHandler\n\n    builder.services.add_scoped(GetUserQueryHandler)\n    builder.services.add_scoped(ListUsersQueryHandler)\n    log.debug(\"Manually registered query handlers\")\nexcept ImportError as e:\n    log.warning(f\"Could not register handlers: {e}\")\n</code></pre>"},{"location":"features/resilient-handler-discovery/#after-automatic-discovery","title":"After (Automatic Discovery)","text":"<pre><code># New approach - automatic resilient discovery\nMediator.configure(builder, ['application.queries'])\n# That's it! No manual registration needed\n</code></pre>"},{"location":"features/resilient-handler-discovery/#important-notes","title":"\u26a0\ufe0f Important Notes","text":""},{"location":"features/resilient-handler-discovery/#backward-compatibility","title":"Backward Compatibility","text":"<ul> <li>100% backward compatible - existing code continues to work unchanged</li> <li>No breaking changes - all existing <code>Mediator.configure()</code> calls work as before</li> <li>Enhanced behavior - only adds fallback capability when needed</li> </ul>"},{"location":"features/resilient-handler-discovery/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Package discovery first - normal path is unchanged and just as fast</li> <li>Fallback only when needed - individual module discovery only triggers on import failures</li> <li>Directory scanning - minimal filesystem operations, cached results</li> <li>Logging overhead - debug logging can be disabled in production</li> </ul>"},{"location":"features/resilient-handler-discovery/#limitations","title":"Limitations","text":"<ul> <li>Directory structure dependent - requires standard Python package layout</li> <li>Search paths - looks in <code>src/</code>, <code>./</code>, and <code>app/</code> directories</li> <li>File system access - requires read permissions to package directories</li> </ul>"},{"location":"features/resilient-handler-discovery/#benefits","title":"\ud83c\udf89 Benefits","text":""},{"location":"features/resilient-handler-discovery/#for-developers","title":"For Developers","text":"<ul> <li>Reduced friction during legacy code migration</li> <li>Automatic discovery without manual registration</li> <li>Clear diagnostics about what was discovered vs skipped</li> <li>Incremental adoption of CQRS patterns</li> </ul>"},{"location":"features/resilient-handler-discovery/#for-projects","title":"For Projects","text":"<ul> <li>Mixed architectural patterns supported</li> <li>Gradual modernization without breaking changes</li> <li>Complex dependency graphs handled gracefully</li> <li>Better development experience with detailed logging</li> </ul>"},{"location":"features/resilient-handler-discovery/#for-teams","title":"For Teams","text":"<ul> <li>Parallel development - teams can work on different parts without breaking discovery</li> <li>Easier onboarding - less manual configuration needed</li> <li>Reduced support burden - fewer \"handler not found\" issues</li> </ul> <p>The resilient discovery makes the Neuroglia framework significantly more robust for real-world codebases with complex dependencies and mixed architectural patterns! \ud83c\udfaf</p>"},{"location":"features/serialization/","title":"\ud83d\udd04 Serialization &amp; Deserialization","text":"<p>Neuroglia provides powerful and flexible serialization capabilities for converting objects to and from various formats like JSON. The framework includes built-in serializers with automatic type handling, custom converters, and seamless integration with the dependency injection system.</p> <p>!!! info \"\ud83c\udfaf What You'll Learn\" - JSON serialization with automatic type handling - Custom serializers and converters - Integration with Mario's Pizzeria domain objects - Best practices for data transformation</p>"},{"location":"features/serialization/#overview","title":"\ud83c\udfaf Overview","text":"<p>Neuroglia's serialization system offers:</p> <ul> <li>\ud83d\udd04 Automatic Type Handling - Seamless conversion of complex objects, enums, and collections</li> <li>\ud83d\udcc5 Built-in Type Support - Native handling of dates, decimals, UUIDs, and custom types</li> <li>\ud83c\udfa8 Custom Converters - Extensible system for specialized serialization logic</li> <li>\ud83d\udc89 DI Integration - Service-based serializers with configurable lifetimes</li> <li>\ud83e\uddea Test-Friendly - Easy mocking and testing of serialization logic</li> </ul>"},{"location":"features/serialization/#key-benefits","title":"Key Benefits","text":"<ul> <li>Type Safety: Strongly-typed deserialization with validation</li> <li>Performance: Efficient JSON processing with minimal overhead</li> <li>Flexibility: Support for custom serialization logic and converters</li> <li>Consistency: Unified serialization patterns across the application</li> </ul>"},{"location":"features/serialization/#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<pre><code>flowchart TD\n    A[\"\ud83c\udfaf Client Code&lt;br/&gt;Business Objects\"]\n    B[\"\ud83d\udd04 JsonSerializer&lt;br/&gt;Main Serialization Service\"]\n    C[\"\ud83d\udccb JsonEncoder&lt;br/&gt;Custom Type Handling\"]\n    D[\"\ud83c\udfa8 Type Converters&lt;br/&gt;Specialized Logic\"]\n\n    subgraph \"\ud83d\udce6 Serialization Pipeline\"\n        E[\"Object \u2192 JSON\"]\n        F[\"JSON \u2192 Object\"]\n        G[\"Type Detection\"]\n        H[\"Recursive Processing\"]\n    end\n\n    subgraph \"\ud83c\udfaf Formats\"\n        I[\"JSON String\"]\n        J[\"Byte Array\"]\n        K[\"Stream Data\"]\n    end\n\n    A --&gt; B\n    B --&gt; C\n    B --&gt; D\n    B --&gt; E\n    B --&gt; F\n    E --&gt; G\n    F --&gt; H\n\n    E --&gt; I\n    E --&gt; J\n    F --&gt; I\n    F --&gt; J\n\n    style B fill:#e1f5fe,stroke:#0277bd,stroke-width:3px\n    style C fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\n    style D fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px\n\n    classDef pipeline fill:#fff3e0,stroke:#f57c00,stroke-width:2px\n    class E,F,G,H pipeline</code></pre>"},{"location":"features/serialization/#basic-usage-in-marios-pizzeria","title":"\ud83c\udf55 Basic Usage in Mario's Pizzeria","text":""},{"location":"features/serialization/#pizza-order-serialization","title":"Pizza Order Serialization","text":"<p>Let's see how Mario's Pizzeria uses serialization for order processing:</p> <pre><code>from neuroglia.serialization.json import JsonSerializer\nfrom neuroglia.dependency_injection import ServiceCollection\nfrom decimal import Decimal\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom enum import Enum\n\n# Domain objects from Mario's Pizzeria\nclass OrderStatus(str, Enum):\n    PENDING = \"pending\"\n    COOKING = \"cooking\"\n    READY = \"ready\"\n    DELIVERED = \"delivered\"\n\n@dataclass\nclass Pizza:\n    id: str\n    name: str\n    size: str\n    base_price: Decimal\n    toppings: list[str]\n\n@dataclass\nclass Order:\n    id: str\n    customer_name: str\n    customer_phone: str\n    pizzas: list[Pizza]\n    status: OrderStatus\n    order_time: datetime\n    total_amount: Decimal\n\n# Using JsonSerializer\nclass OrderService:\n    def __init__(self, serializer: JsonSerializer):\n        self.serializer = serializer\n\n    def serialize_order(self, order: Order) -&gt; str:\n        \"\"\"Convert order to JSON for storage or API responses\"\"\"\n        return self.serializer.serialize_to_text(order)\n\n    def deserialize_order(self, json_data: str) -&gt; Order:\n        \"\"\"Convert JSON back to Order object\"\"\"\n        return self.serializer.deserialize_from_text(json_data, Order)\n\n# Example usage\nserializer = JsonSerializer()\norder = Order(\n    id=\"order-123\",\n    customer_name=\"Mario Luigi\",\n    customer_phone=\"+1-555-PIZZA\",\n    pizzas=[\n        Pizza(\"pizza-1\", \"Margherita\", \"large\", Decimal(\"15.99\"), [\"basil\", \"mozzarella\"])\n    ],\n    status=OrderStatus.PENDING,\n    order_time=datetime.now(),\n    total_amount=Decimal(\"17.49\")\n)\n\n# Serialize to JSON\njson_order = serializer.serialize_to_text(order)\nprint(json_order)\n# Output: {\"id\": \"order-123\", \"customer_name\": \"Mario Luigi\", ...}\n\n# Deserialize back to object\nrestored_order = serializer.deserialize_from_text(json_order, Order)\nassert restored_order.customer_name == \"Mario Luigi\"\nassert restored_order.status == OrderStatus.PENDING\n</code></pre>"},{"location":"features/serialization/#custom-json-encoder","title":"\ud83c\udfa8 Custom JSON Encoder","text":"<p>Neuroglia includes a custom <code>JsonEncoder</code> that handles special types automatically:</p> <pre><code>from neuroglia.serialization.json import JsonEncoder\nimport json\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom enum import Enum\n\nclass PizzaSize(str, Enum):\n    SMALL = \"small\"\n    MEDIUM = \"medium\"\n    LARGE = \"large\"\n\n# The JsonEncoder automatically handles these types:\ndata = {\n    \"order_time\": datetime.now(),       # \u2192 ISO format string\n    \"total_amount\": Decimal(\"15.99\"),   # \u2192 string representation\n    \"size\": PizzaSize.LARGE,           # \u2192 enum name\n    \"custom_object\": Pizza(...)         # \u2192 object's __dict__\n}\n\njson_string = json.dumps(data, cls=JsonEncoder)\n</code></pre>"},{"location":"features/serialization/#encoder-features","title":"Encoder Features","text":"<p>The <code>JsonEncoder</code> provides:</p> <ul> <li>DateTime Conversion: Automatic ISO format serialization</li> <li>Enum Handling: Uses enum names for consistent serialization</li> <li>Decimal Support: Preserves precision for monetary values</li> <li>Object Filtering: Excludes private attributes and None values</li> <li>Fallback Handling: Safe string conversion for unknown types</li> </ul>"},{"location":"features/serialization/#advanced-serialization-patterns","title":"\ud83d\udd27 Advanced Serialization Patterns","text":""},{"location":"features/serialization/#1-nested-object-serialization","title":"1. Nested Object Serialization","text":"<pre><code>@dataclass\nclass Customer:\n    id: str\n    name: str\n    email: str\n    addresses: list[Address]\n\n@dataclass\nclass Address:\n    street: str\n    city: str\n    postal_code: str\n\n# Automatic recursive serialization\ncustomer = Customer(\n    id=\"cust-123\",\n    name=\"Luigi Mario\",\n    email=\"luigi@pizzeria.com\",\n    addresses=[\n        Address(\"123 Main St\", \"Pizza City\", \"12345\"),\n        Address(\"456 Oak Ave\", \"Pepperoni Town\", \"67890\")\n    ]\n)\n\nserializer = JsonSerializer()\njson_data = serializer.serialize_to_text(customer)\nrestored_customer = serializer.deserialize_from_text(json_data, Customer)\n</code></pre>"},{"location":"features/serialization/#2-generic-type-handling","title":"2. Generic Type Handling","text":"<pre><code>from typing import List, Dict, Optional\n\n@dataclass\nclass MenuSection:\n    name: str\n    pizzas: List[Pizza]\n    metadata: Dict[str, str]\n    featured_pizza: Optional[Pizza] = None\n\n# Serializer handles generic types automatically\nmenu_section = MenuSection(\n    name=\"Classic Pizzas\",\n    pizzas=[margherita_pizza, pepperoni_pizza],\n    metadata={\"category\": \"traditional\", \"popularity\": \"high\"},\n    featured_pizza=margherita_pizza\n)\n\n# Serialization preserves type information\njson_data = serializer.serialize_to_text(menu_section)\nrestored_section = serializer.deserialize_from_text(json_data, MenuSection)\n</code></pre>"},{"location":"features/serialization/#3-integration-with-dependency-injection","title":"3. Integration with Dependency Injection","text":"<pre><code>from neuroglia.hosting import WebApplicationBuilder\n\ndef configure_serialization(builder: WebApplicationBuilder):\n    \"\"\"Configure serialization services\"\"\"\n\n    # Register JsonSerializer as singleton\n    builder.services.add_singleton(JsonSerializer)\n\n    # Use in controllers\n    class OrdersController(ControllerBase):\n        def __init__(self,\n                     service_provider: ServiceProviderBase,\n                     mapper: Mapper,\n                     mediator: Mediator,\n                     serializer: JsonSerializer):  # Injected automatically\n            super().__init__(service_provider, mapper, mediator)\n            self.serializer = serializer\n\n        @post(\"/export\")\n        async def export_orders(self) -&gt; str:\n            \"\"\"Export all orders as JSON\"\"\"\n            orders = await self.get_all_orders()\n            return self.serializer.serialize_to_text(orders)\n</code></pre>"},{"location":"features/serialization/#testing-serialization","title":"\ud83e\uddea Testing Serialization","text":""},{"location":"features/serialization/#unit-testing-patterns","title":"Unit Testing Patterns","text":"<pre><code>import pytest\nfrom neuroglia.serialization.json import JsonSerializer\n\nclass TestPizzaOrderSerialization:\n\n    def setup_method(self):\n        self.serializer = JsonSerializer()\n\n    def test_order_serialization_round_trip(self):\n        \"\"\"Test complete serialization/deserialization cycle\"\"\"\n        # Arrange\n        original_order = create_test_order()\n\n        # Act\n        json_data = self.serializer.serialize_to_text(original_order)\n        restored_order = self.serializer.deserialize_from_text(json_data, Order)\n\n        # Assert\n        assert restored_order.id == original_order.id\n        assert restored_order.customer_name == original_order.customer_name\n        assert restored_order.status == original_order.status\n        assert len(restored_order.pizzas) == len(original_order.pizzas)\n\n    def test_handles_none_values_gracefully(self):\n        \"\"\"Test serialization with None values\"\"\"\n        # Arrange\n        order = Order(\n            id=\"test-order\",\n            customer_name=\"Test Customer\",\n            customer_phone=None,  # None value\n            pizzas=[],\n            status=OrderStatus.PENDING,\n            order_time=datetime.now(),\n            total_amount=Decimal(\"0.00\")\n        )\n\n        # Act &amp; Assert\n        json_data = self.serializer.serialize_to_text(order)\n        restored_order = self.serializer.deserialize_from_text(json_data, Order)\n\n        assert restored_order.customer_phone is None\n\n    def test_decimal_precision_preserved(self):\n        \"\"\"Test that decimal precision is maintained\"\"\"\n        # Arrange\n        pizza = Pizza(\n            id=\"test-pizza\",\n            name=\"Test Pizza\",\n            size=\"medium\",\n            base_price=Decimal(\"12.99\"),\n            toppings=[]\n        )\n\n        # Act\n        json_data = self.serializer.serialize_to_text(pizza)\n        restored_pizza = self.serializer.deserialize_from_text(json_data, Pizza)\n\n        # Assert\n        assert restored_pizza.base_price == Decimal(\"12.99\")\n        assert isinstance(restored_pizza.base_price, Decimal)\n</code></pre>"},{"location":"features/serialization/#real-world-use-cases","title":"\ud83c\udfaf Real-World Use Cases","text":""},{"location":"features/serialization/#1-api-response-serialization","title":"1. API Response Serialization","text":"<pre><code>from fastapi import FastAPI\nfrom fastapi.responses import JSONResponse\n\nclass MenuController(ControllerBase):\n\n    @get(\"/menu\")\n    async def get_menu(self) -&gt; JSONResponse:\n        \"\"\"Get pizzeria menu as JSON\"\"\"\n        menu_items = await self.get_menu_items()\n\n        # Serialize complex menu structure\n        json_data = self.serializer.serialize_to_text(menu_items)\n\n        return JSONResponse(\n            content=json_data,\n            media_type=\"application/json\"\n        )\n</code></pre>"},{"location":"features/serialization/#2-event-payload-serialization","title":"2. Event Payload Serialization","text":"<pre><code>from neuroglia.eventing import DomainEvent\n\n@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    order_id: str\n    customer_email: str\n    order_details: Order\n\nclass OrderEventHandler:\n    def __init__(self, serializer: JsonSerializer):\n        self.serializer = serializer\n\n    async def handle_order_placed(self, event: OrderPlacedEvent):\n        \"\"\"Handle order placed event with serialization\"\"\"\n\n        # Serialize event for external systems\n        event_json = self.serializer.serialize_to_text(event)\n\n        # Send to message queue, webhook, etc.\n        await self.send_to_external_system(event_json)\n\n        # Log structured event data\n        logger.info(\"Order placed\", extra={\n            \"event_data\": event_json,\n            \"order_id\": event.order_id\n        })\n</code></pre>"},{"location":"features/serialization/#3-configuration-and-settings","title":"3. Configuration and Settings","text":"<pre><code>@dataclass\nclass PizzeriaConfig:\n    name: str\n    address: Address\n    operating_hours: Dict[str, str]\n    menu_sections: List[MenuSection]\n    pricing_rules: Dict[str, Decimal]\n\nclass ConfigurationService:\n    def __init__(self, serializer: JsonSerializer):\n        self.serializer = serializer\n\n    def load_config(self, config_path: str) -&gt; PizzeriaConfig:\n        \"\"\"Load pizzeria configuration from JSON file\"\"\"\n        with open(config_path, 'r') as f:\n            json_data = f.read()\n\n        return self.serializer.deserialize_from_text(json_data, PizzeriaConfig)\n\n    def save_config(self, config: PizzeriaConfig, config_path: str):\n        \"\"\"Save pizzeria configuration to JSON file\"\"\"\n        json_data = self.serializer.serialize_to_text(config)\n\n        with open(config_path, 'w') as f:\n            f.write(json_data)\n</code></pre>"},{"location":"features/serialization/#error-handling-and-validation","title":"\ud83d\udd0d Error Handling and Validation","text":""},{"location":"features/serialization/#robust-serialization-patterns","title":"Robust Serialization Patterns","text":"<pre><code>from typing import Union\nimport logging\n\nclass SafeSerializationService:\n    def __init__(self, serializer: JsonSerializer):\n        self.serializer = serializer\n        self.logger = logging.getLogger(__name__)\n\n    def safe_serialize(self, obj: Any) -&gt; Union[str, None]:\n        \"\"\"Safely serialize object with error handling\"\"\"\n        try:\n            return self.serializer.serialize_to_text(obj)\n        except Exception as e:\n            self.logger.error(f\"Serialization failed for {type(obj)}: {e}\")\n            return None\n\n    def safe_deserialize(self, json_data: str, target_type: Type[T]) -&gt; Union[T, None]:\n        \"\"\"Safely deserialize with validation\"\"\"\n        try:\n            if not json_data or not json_data.strip():\n                return None\n\n            result = self.serializer.deserialize_from_text(json_data, target_type)\n\n            # Additional validation\n            if hasattr(result, 'validate'):\n                result.validate()\n\n            return result\n\n        except json.JSONDecodeError as e:\n            self.logger.error(f\"Invalid JSON format: {e}\")\n            return None\n        except Exception as e:\n            self.logger.error(f\"Deserialization failed: {e}\")\n            return None\n</code></pre>"},{"location":"features/serialization/#performance-considerations","title":"\ud83d\ude80 Performance Considerations","text":""},{"location":"features/serialization/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Reuse Serializer Instances: Register as singleton in DI container</li> <li>Minimize Object Creation: Use object pooling for high-frequency serialization</li> <li>Stream Processing: Use byte arrays for large data sets</li> <li>Selective Serialization: Exclude unnecessary fields to reduce payload size</li> </ol> <pre><code># Performance-optimized serialization\nclass OptimizedOrderService:\n    def __init__(self, serializer: JsonSerializer):\n        self.serializer = serializer\n        self._byte_buffer = bytearray(8192)  # Reusable buffer\n\n    def serialize_order_summary(self, order: Order) -&gt; str:\n        \"\"\"Serialize only essential order information\"\"\"\n        summary = {\n            \"id\": order.id,\n            \"customer_name\": order.customer_name,\n            \"status\": order.status.value,\n            \"total_amount\": str(order.total_amount),\n            \"pizza_count\": len(order.pizzas)\n        }\n        return self.serializer.serialize_to_text(summary)\n</code></pre>"},{"location":"features/serialization/#integration-points","title":"\ud83d\udd17 Integration Points","text":""},{"location":"features/serialization/#framework-integration","title":"Framework Integration","text":"<p>Serialization integrates seamlessly with:</p> <ul> <li>Object Mapping - Automatic DTO conversion before serialization</li> <li>MVC Controllers - Automatic request/response serialization</li> <li>Event Sourcing - Event payload serialization for persistence</li> <li>Data Access - Document serialization for MongoDB storage</li> </ul>"},{"location":"features/serialization/#next-steps","title":"\ud83d\udcda Next Steps","text":"<p>Explore related Neuroglia features:</p> <ul> <li>Object Mapping - Transform objects before serialization</li> <li>MVC Controllers - Automatic API serialization</li> <li>Event Sourcing - Event payload handling</li> <li>Getting Started Guide - Complete pizzeria implementation</li> </ul> <p>\ud83c\udfaf Best Practice</p> <p>Always register <code>JsonSerializer</code> as a singleton in your DI container for optimal performance and consistent behavior across your application.</p>"},{"location":"features/simple-cqrs/","title":"\ud83c\udfaf Simple CQRS Patterns","text":"<p>This guide shows how to use Neuroglia's simplified CQRS patterns for applications that need clean command/query separation without complex event sourcing or cloud events infrastructure.</p>"},{"location":"features/simple-cqrs/#when-to-use-simple-cqrs","title":"\ud83c\udfaf When to Use Simple CQRS","text":"<p>Use the simple CQRS patterns when you need:</p> <ul> <li>Clean separation of read and write operations</li> <li>Basic validation and business logic handling</li> <li>In-memory testing or simple database operations  </li> <li>Minimal setup without event sourcing complexity</li> <li>Rapid prototyping of business logic</li> </ul> <p>Don't use simple patterns when you need: - Event sourcing and domain events - Cloud events integration - Complex workflow orchestration - Advanced audit trails</p>"},{"location":"features/simple-cqrs/#basic-setup","title":"\ud83c\udfd7\ufe0f Basic Setup","text":""},{"location":"features/simple-cqrs/#minimal-example-5-lines-of-setup","title":"Minimal Example (5 lines of setup)","text":"<pre><code>from neuroglia.mediation import (\n    Command, Query, CommandHandler, QueryHandler,\n    create_simple_app, InMemoryRepository\n)\n\n# One-line app creation\nprovider = create_simple_app(CreateTaskHandler, GetTaskHandler, \n                           repositories=[InMemoryRepository[Task]])\nmediator = provider.get_service(Mediator)\n</code></pre>"},{"location":"features/simple-cqrs/#standard-setup","title":"Standard Setup","text":"<pre><code>from neuroglia.mediation import (\n    add_simple_mediator, register_simple_handlers\n)\nfrom neuroglia.dependency_injection import ServiceCollection\n\n# Create service collection\nservices = ServiceCollection()\n\n# Add simple mediator (no cloud events)\nadd_simple_mediator(services)\n\n# Add repositories\nservices.add_singleton(InMemoryRepository[Task])\n\n# Register handlers\nregister_simple_handlers(services, CreateTaskHandler, GetTaskHandler)\n\n# Build provider\nprovider = services.build()\n</code></pre>"},{"location":"features/simple-cqrs/#complete-working-example","title":"\ud83d\ude80 Complete Working Example","text":""},{"location":"features/simple-cqrs/#1-define-your-models","title":"1. Define Your Models","text":"<pre><code>from dataclasses import dataclass\n\n# Domain model\n@dataclass\nclass Task:\n    id: str\n    title: str\n    completed: bool = False\n\n# DTO for API responses  \n@dataclass\nclass TaskDto:\n    id: str\n    title: str\n    completed: bool\n</code></pre>"},{"location":"features/simple-cqrs/#2-define-commands-and-queries","title":"2. Define Commands and Queries","text":"<pre><code>from neuroglia.mediation import Command, Query\nfrom neuroglia.core.operation_result import OperationResult\n\n@dataclass\nclass CreateTaskCommand(Command[OperationResult[TaskDto]]):\n    title: str\n\n@dataclass  \nclass GetTaskQuery(Query[OperationResult[TaskDto]]):\n    task_id: str\n\n@dataclass\nclass CompleteTaskCommand(Command[OperationResult[TaskDto]]):\n    task_id: str\n</code></pre>"},{"location":"features/simple-cqrs/#3-implement-handlers","title":"3. Implement Handlers","text":"<pre><code>import uuid\nfrom neuroglia.mediation import CommandHandler, QueryHandler\n\nclass CreateTaskHandler(CommandHandler[CreateTaskCommand, OperationResult[TaskDto]]):\n    def __init__(self, repository: InMemoryRepository[Task]):\n        self.repository = repository\n\n    async def handle_async(self, request: CreateTaskCommand) -&gt; OperationResult[TaskDto]:\n        # Validation\n        if not request.title.strip():\n            return self.bad_request(\"Title cannot be empty\")\n\n        # Business logic\n        task = Task(str(uuid.uuid4()), request.title.strip())\n        await self.repository.save_async(task)\n\n        # Return result\n        dto = TaskDto(task.id, task.title, task.completed)\n        return self.created(dto)\n\nclass GetTaskHandler(QueryHandler[GetTaskQuery, OperationResult[TaskDto]]):\n    def __init__(self, repository: InMemoryRepository[Task]):\n        self.repository = repository\n\n    async def handle_async(self, request: GetTaskQuery) -&gt; OperationResult[TaskDto]:\n        task = await self.repository.get_by_id_async(request.task_id)\n\n        if not task:\n            return self.not_found(Task, request.task_id)\n\n        dto = TaskDto(task.id, task.title, task.completed)\n        return self.ok(dto)\n\nclass CompleteTaskHandler(CommandHandler[CompleteTaskCommand, OperationResult[TaskDto]]):\n    def __init__(self, repository: InMemoryRepository[Task]):\n        self.repository = repository\n\n    async def handle_async(self, request: CompleteTaskCommand) -&gt; OperationResult[TaskDto]:\n        task = await self.repository.get_by_id_async(request.task_id)\n\n        if not task:\n            return self.not_found(Task, request.task_id)\n\n        if task.completed:\n            return self.bad_request(\"Task is already completed\")\n\n        # Business logic\n        task.completed = True\n        await self.repository.save_async(task)\n\n        dto = TaskDto(task.id, task.title, task.completed)\n        return self.ok(dto)\n</code></pre>"},{"location":"features/simple-cqrs/#4-create-and-use-your-application","title":"4. Create and Use Your Application","text":"<pre><code>import asyncio\n\nasync def main():\n    # Create app with ultra-simple setup\n    provider = create_simple_app(\n        CreateTaskHandler, \n        GetTaskHandler,\n        CompleteTaskHandler,\n        repositories=[InMemoryRepository[Task]]\n    )\n\n    mediator = provider.get_service(Mediator)\n\n    # Create a task\n    create_result = await mediator.execute_async(\n        CreateTaskCommand(\"Learn Neuroglia CQRS\")\n    )\n\n    if create_result.is_success:\n        print(f\"\u2705 Created: {create_result.data.title}\")\n        task_id = create_result.data.id\n\n        # Complete the task\n        complete_result = await mediator.execute_async(\n            CompleteTaskCommand(task_id)\n        )\n\n        if complete_result.is_success:\n            print(f\"\u2705 Completed: {complete_result.data.title}\")\n\n        # Get the task\n        get_result = await mediator.execute_async(GetTaskQuery(task_id))\n\n        if get_result.is_success:\n            task = get_result.data\n            print(f\"\ud83d\udccb Task: {task.title} (completed: {task.completed})\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"features/simple-cqrs/#key-patterns","title":"\ud83d\udca1 Key Patterns","text":""},{"location":"features/simple-cqrs/#validation-and-error-handling","title":"Validation and Error Handling","text":"<pre><code>async def handle_async(self, request: CreateUserCommand) -&gt; OperationResult[UserDto]:\n    # Input validation\n    if not request.email:\n        return self.bad_request(\"Email is required\")\n\n    if \"@\" not in request.email:\n        return self.bad_request(\"Invalid email format\")\n\n    # Business validation\n    existing_user = await self.repository.get_by_email_async(request.email)\n    if existing_user:\n        return self.conflict(f\"User with email {request.email} already exists\")\n\n    # Success path\n    user = User(str(uuid.uuid4()), request.name, request.email)\n    await self.repository.save_async(user)\n\n    dto = UserDto(user.id, user.name, user.email)\n    return self.created(dto)\n</code></pre>"},{"location":"features/simple-cqrs/#repository-patterns","title":"Repository Patterns","text":"<pre><code># Simple in-memory repository (for testing/prototyping)\nfrom neuroglia.mediation import InMemoryRepository\n\nclass UserRepository(InMemoryRepository[User]):\n    async def get_by_email_async(self, email: str) -&gt; Optional[User]:\n        for user in self._storage.values():\n            if user.email == email:\n                return user\n        return None\n</code></pre>"},{"location":"features/simple-cqrs/#query-result-patterns","title":"Query Result Patterns","text":"<pre><code># Single item query\n@dataclass\nclass GetUserQuery(Query[OperationResult[UserDto]]):\n    user_id: str\n\n# List query\n@dataclass  \nclass ListUsersQuery(Query[OperationResult[List[UserDto]]]):\n    include_inactive: bool = False\n\n# Search query\n@dataclass\nclass SearchUsersQuery(Query[OperationResult[List[UserDto]]]):\n    search_term: str\n    page: int = 1\n    page_size: int = 10\n</code></pre>"},{"location":"features/simple-cqrs/#configuration-options","title":"\ud83d\udd27 Configuration Options","text":""},{"location":"features/simple-cqrs/#simple-application-settings","title":"Simple Application Settings","text":"<p>Instead of the full <code>ApplicationSettings</code>, use <code>SimpleApplicationSettings</code> for basic apps:</p> <pre><code>from neuroglia.mediation import SimpleApplicationSettings\n\n@dataclass\nclass MyAppSettings(SimpleApplicationSettings):\n    app_name: str = \"Task Manager\"\n    max_tasks_per_user: int = 100\n    enable_notifications: bool = True\n</code></pre>"},{"location":"features/simple-cqrs/#environment-integration","title":"Environment Integration","text":"<pre><code>import os\n\nsettings = SimpleApplicationSettings(\n    app_name=os.getenv(\"APP_NAME\", \"My App\"),\n    debug=os.getenv(\"DEBUG\", \"false\").lower() == \"true\",\n    database_url=os.getenv(\"DATABASE_URL\")\n)\n</code></pre>"},{"location":"features/simple-cqrs/#testing-patterns","title":"\ud83e\uddea Testing Patterns","text":""},{"location":"features/simple-cqrs/#unit-testing-handlers","title":"Unit Testing Handlers","text":"<pre><code>import pytest\nfrom unittest.mock import AsyncMock\n\n@pytest.mark.asyncio\nasync def test_create_task_success():\n    # Arrange\n    repository = AsyncMock(spec=InMemoryRepository[Task])\n    handler = CreateTaskHandler(repository)\n    command = CreateTaskCommand(\"Test task\")\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n    assert result.data.title == \"Test task\"\n    repository.save_async.assert_called_once()\n\n@pytest.mark.asyncio\nasync def test_create_task_empty_title():\n    # Arrange\n    repository = AsyncMock(spec=InMemoryRepository[Task])\n    handler = CreateTaskHandler(repository)\n    command = CreateTaskCommand(\"\")\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert not result.is_success\n    assert result.status_code == 400\n    assert \"empty\" in result.error_message.lower()\n</code></pre>"},{"location":"features/simple-cqrs/#integration-testing","title":"Integration Testing","text":"<pre><code>@pytest.mark.asyncio\nasync def test_complete_workflow():\n    # Create application\n    provider = create_simple_app(\n        CreateTaskHandler, \n        GetTaskHandler,\n        CompleteTaskHandler,\n        repositories=[InMemoryRepository[Task]]\n    )\n\n    mediator = provider.get_service(Mediator)\n\n    # Test complete workflow\n    create_result = await mediator.execute_async(CreateTaskCommand(\"Test\"))\n    assert create_result.is_success\n\n    task_id = create_result.data.id\n\n    get_result = await mediator.execute_async(GetTaskQuery(task_id))\n    assert get_result.is_success\n    assert not get_result.data.completed\n\n    complete_result = await mediator.execute_async(CompleteTaskCommand(task_id))\n    assert complete_result.is_success\n    assert complete_result.data.completed\n</code></pre>"},{"location":"features/simple-cqrs/#when-to-upgrade","title":"\ud83d\ude80 When to Upgrade","text":"<p>Consider upgrading to the full Neuroglia framework features when you need:</p>"},{"location":"features/simple-cqrs/#event-sourcing","title":"Event Sourcing","text":"<pre><code># Upgrade to event sourcing when you need:\n# - Complete audit trails\n# - Event replay capabilities  \n# - Complex business workflows\n# - Temporal queries (\"what was the state at time X?\")\n</code></pre>"},{"location":"features/simple-cqrs/#cloud-events","title":"Cloud Events","text":"<pre><code># Upgrade to cloud events when you need:\n# - Microservice integration\n# - Event-driven architecture\n# - Cross-system communication\n# - Reliable event delivery\n</code></pre>"},{"location":"features/simple-cqrs/#domain-events","title":"Domain Events","text":"<pre><code># Upgrade to domain events when you need:\n# - Side effects from business operations\n# - Decoupled business logic\n# - Complex business rules\n# - Integration events\n</code></pre>"},{"location":"features/simple-cqrs/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Framework overview</li> <li>CQRS &amp; Mediation - Advanced CQRS patterns</li> <li>Dependency Injection - Advanced DI patterns</li> <li>Data Access - Repository patterns and persistence</li> </ul>"},{"location":"guides/","title":"\ud83d\udcda Guides and How-To's","text":"<p>\ud83d\udea7 Under Construction</p> <p>This section is currently being developed with step-by-step guides and practical examples. Individual guide pages with detailed procedures and troubleshooting tips are being created.</p> <p>Practical procedures and troubleshooting guides for developing with the Neuroglia framework.</p>"},{"location":"guides/#getting-started-guides","title":"\ud83d\ude80 Getting Started Guides","text":""},{"location":"guides/#project-setup","title":"Project Setup","text":"<ul> <li>Creating new projects with <code>pyneuroctl</code></li> <li>Setting up development environment</li> <li>Configuring IDE support</li> </ul>"},{"location":"guides/#testing-setup","title":"Testing Setup","text":"<ul> <li>Unit testing strategies</li> <li>Integration testing patterns</li> <li>Test data management</li> </ul>"},{"location":"guides/#development-guides","title":"\ud83c\udfd7\ufe0f Development Guides","text":""},{"location":"guides/#building-apis","title":"Building APIs","text":"<ul> <li>Creating controllers and endpoints</li> <li>Request/response modeling</li> <li>Authentication and authorization</li> </ul>"},{"location":"guides/#data-management","title":"Data Management","text":"<ul> <li>Repository implementation</li> <li>Database integration</li> <li>Event sourcing setup</li> </ul>"},{"location":"guides/#event-driven-development","title":"Event-Driven Development","text":"<ul> <li>Domain event design</li> <li>Event handlers</li> <li>CloudEvents integration</li> </ul>"},{"location":"guides/#operations-guides","title":"\ud83d\udd27 Operations Guides","text":""},{"location":"guides/#deployment","title":"Deployment","text":"<ul> <li>Docker containerization</li> <li>Kubernetes deployment</li> <li>Environment configuration</li> </ul>"},{"location":"guides/#monitoring","title":"Monitoring","text":"<ul> <li>Logging configuration</li> <li>Health checks</li> <li>Performance monitoring</li> </ul>"},{"location":"guides/#troubleshooting","title":"\ud83d\udc1b Troubleshooting","text":""},{"location":"guides/#common-issues","title":"Common Issues","text":"<ul> <li>Dependency injection problems</li> <li>Mediator configuration</li> <li>Database connectivity</li> </ul>"},{"location":"guides/#debugging-techniques","title":"Debugging Techniques","text":"<ul> <li>Testing strategies</li> <li>Logging best practices</li> <li>Performance profiling</li> </ul> <p>Detailed guides with step-by-step instructions coming soon \ud83d\udea7</p>"},{"location":"guides/3-min-bootstrap/","title":"\u26a1 3-Minute Bootstrap: Hello World","text":"<p>Get up and running with Neuroglia in under 3 minutes! This quick-start guide gets you from zero to a working API in the fastest way possible.</p> <p>\ud83c\udfaf What You'll Build</p> <p>A minimal \"Hello Pizzeria\" API with one endpoint that demonstrates the basic framework setup.</p>"},{"location":"guides/3-min-bootstrap/#quick-setup","title":"\ud83d\ude80 Quick Setup","text":""},{"location":"guides/3-min-bootstrap/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8+ installed</li> <li>pip package manager</li> </ul>"},{"location":"guides/3-min-bootstrap/#installation","title":"Installation","text":"<pre><code># Create new directory\nmkdir hello-pizzeria &amp;&amp; cd hello-pizzeria\n\n# Install Neuroglia\npip install neuroglia-python[web]\n</code></pre>"},{"location":"guides/3-min-bootstrap/#create-your-first-api","title":"\ud83d\udcdd Create Your First API","text":"<p>Create <code>main.py</code>:</p> <pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.mvc import ControllerBase\nfrom classy_fastapi.decorators import get\n\nclass HelloController(ControllerBase):\n    \"\"\"Simple hello world controller\"\"\"\n\n    @get(\"/hello\")\n    async def hello_world(self) -&gt; dict:\n        \"\"\"Say hello to Mario's Pizzeria!\"\"\"\n        return {\n            \"message\": \"Welcome to Mario's Pizzeria! \ud83c\udf55\",\n            \"status\": \"We're open for business!\",\n            \"framework\": \"Neuroglia Python\"\n        }\n\ndef create_app():\n    \"\"\"Create the web application\"\"\"\n    builder = WebApplicationBuilder()\n\n    # Add controllers\n    services = builder.services\n    services.add_controllers([HelloController])\n\n    # Build app\n    app = builder.build()\n    app.use_controllers()\n\n    return app\n\nif __name__ == \"__main__\":\n    import uvicorn\n    app = create_app()\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre>"},{"location":"guides/3-min-bootstrap/#run-your-api","title":"\ud83c\udfc3\u200d\u2642\ufe0f Run Your API","text":"<pre><code>python main.py\n</code></pre>"},{"location":"guides/3-min-bootstrap/#test-your-api","title":"\ud83c\udf89 Test Your API","text":"<p>Open your browser and visit:</p> <ul> <li>API Endpoint: http://localhost:8000/hello</li> <li>API Documentation: http://localhost:8000/docs</li> </ul> <p>You should see:</p> <pre><code>{\n  \"message\": \"Welcome to Mario's Pizzeria! \ud83c\udf55\",\n  \"status\": \"We're open for business!\",\n  \"framework\": \"Neuroglia Python\"\n}\n</code></pre>"},{"location":"guides/3-min-bootstrap/#what-youve-accomplished","title":"\u2705 What You've Accomplished","text":"<p>In just 3 minutes, you've created:</p> <ul> <li>\u2705 A working FastAPI application with Neuroglia</li> <li>\u2705 Automatic API documentation (Swagger UI)</li> <li>\u2705 Controller-based routing with clean architecture</li> <li>\u2705 Dependency injection container setup</li> </ul>"},{"location":"guides/3-min-bootstrap/#next-steps","title":"\ud83d\udd04 Next Steps","text":"<p>Now that you have the basics working:</p> <ol> <li>\ud83d\udee0\ufe0f Local Development Setup - Set up a proper development environment</li> <li>\ud83c\udf55 Mario's Pizzeria Tutorial - Build a complete application (1 hour)</li> <li>\ud83c\udfaf Architecture Patterns - Learn the design principles</li> <li>\ud83d\ude80 Framework Features - Explore advanced capabilities</li> </ol>"},{"location":"guides/3-min-bootstrap/#key-concepts-introduced","title":"\ud83d\udd17 Key Concepts Introduced","text":"<p>This hello world example demonstrates:</p> <ul> <li>Controller Pattern - Web request handling</li> <li>Dependency Injection - Service container setup</li> <li>WebApplicationBuilder - Application bootstrapping</li> </ul> <p>\ud83c\udfaf Pro Tip</p> <p>This is just the beginning! The framework includes powerful features like CQRS, event sourcing, and advanced data access patterns. Continue with the Local Development Setup to explore more.</p>"},{"location":"guides/local-development/","title":"\ud83d\udee0\ufe0f Local Development Environment Setup","text":"<p>Set up a complete local development environment for productive Neuroglia development. This guide covers tooling, IDE setup, debugging, and best practices for building maintainable applications.</p> <p>\ud83c\udfaf What You'll Set Up</p> <p>A professional development environment with debugging, testing, linting, and database integration.</p>"},{"location":"guides/local-development/#prerequisites","title":"\ud83d\udccb Prerequisites","text":""},{"location":"guides/local-development/#system-requirements","title":"System Requirements","text":"<ul> <li>Python 3.8+ with pip</li> <li>Git for version control</li> <li>Docker &amp; Docker Compose for services (MongoDB, Redis, etc.)</li> <li>VS Code or PyCharm (recommended IDEs)</li> </ul>"},{"location":"guides/local-development/#verify-installation","title":"Verify Installation","text":"<pre><code>python --version  # Should be 3.8+\npip --version\ngit --version\ndocker --version\ndocker-compose --version\n</code></pre>"},{"location":"guides/local-development/#project-setup","title":"\ud83d\ude80 Project Setup","text":""},{"location":"guides/local-development/#1-create-project-structure","title":"1. Create Project Structure","text":"<pre><code># Create project directory\nmkdir my-neuroglia-app &amp;&amp; cd my-neuroglia-app\n\n# Initialize git repository\ngit init\n\n# Create standard project structure\nmkdir -p src/{api,application,domain,integration}\nmkdir -p src/api/{controllers,dtos}\nmkdir -p src/application/{commands,queries,handlers}\nmkdir -p src/domain/{entities,events,repositories}\nmkdir -p src/integration/{repositories,services}\nmkdir -p tests/{unit,integration,fixtures}\nmkdir -p docs\ntouch README.md\n</code></pre>"},{"location":"guides/local-development/#2-python-environment-setup","title":"2. Python Environment Setup","text":"<p>Option A: Using Poetry (Recommended)</p> <pre><code># Install Poetry if not already installed\ncurl -sSL https://install.python-poetry.org | python3 -\n\n# Initialize Poetry project\npoetry init\n\n# Add Neuroglia and development dependencies\npoetry add neuroglia-python[web]\npoetry add --group dev pytest pytest-asyncio pytest-cov black flake8 mypy\n\n# Create virtual environment and activate\npoetry install\npoetry shell\n</code></pre> <p>Option B: Using venv</p> <pre><code># Create virtual environment\npython -m venv venv\n\n# Activate virtual environment\n# On macOS/Linux:\nsource venv/bin/activate\n# On Windows:\n# venv\\Scripts\\activate\n\n# Install dependencies\npip install neuroglia-python[web]\npip install pytest pytest-asyncio pytest-cov black flake8 mypy\n</code></pre>"},{"location":"guides/local-development/#3-development-configuration-files","title":"3. Development Configuration Files","text":"<p>pyproject.toml (Poetry users):</p> <pre><code>[tool.poetry]\nname = \"my-neuroglia-app\"\nversion = \"0.1.0\"\ndescription = \"My Neuroglia Application\"\nauthors = [\"Your Name &lt;your.email@example.com&gt;\"]\n\n[tool.poetry.dependencies]\npython = \"^3.8\"\nneuroglia-python = {extras = [\"web\"], version = \"^1.0.0\"}\n\n[tool.poetry.group.dev.dependencies]\npytest = \"^7.0.0\"\npytest-asyncio = \"^0.20.0\"\npytest-cov = \"^4.0.0\"\nblack = \"^22.0.0\"\nflake8 = \"^5.0.0\"\nmypy = \"^1.0.0\"\n\n[tool.black]\nline-length = 88\ntarget-version = ['py38']\n\n[tool.mypy]\npython_version = \"3.8\"\nwarn_return_any = true\nwarn_unused_configs = true\ndisallow_untyped_defs = true\n</code></pre> <p>requirements.txt (venv users):</p> <pre><code>neuroglia-python[web]&gt;=1.0.0\npytest&gt;=7.0.0\npytest-asyncio&gt;=0.20.0\npytest-cov&gt;=4.0.0\nblack&gt;=22.0.0\nflake8&gt;=5.0.0\nmypy&gt;=1.0.0\n</code></pre> <p>pytest.ini:</p> <pre><code>[tool:pytest]\ntestpaths = tests\npython_files = test_*.py\npython_classes = Test*\npython_functions = test_*\nasyncio_mode = auto\naddopts = --cov=src --cov-report=html --cov-report=term\n</code></pre>"},{"location":"guides/local-development/#ide-configuration","title":"\ud83d\udd27 IDE Configuration","text":""},{"location":"guides/local-development/#vs-code-setup","title":"VS Code Setup","text":"<p>Install Extensions:</p> <pre><code># Install VS Code extensions\ncode --install-extension ms-python.python\ncode --install-extension ms-python.black-formatter\ncode --install-extension ms-python.flake8\ncode --install-extension ms-python.mypy-type-checker\ncode --install-extension bradlc.vscode-tailwindcss\ncode --install-extension ms-vscode.vscode-json\n</code></pre> <p>.vscode/settings.json:</p> <pre><code>{\n  \"python.defaultInterpreterPath\": \"./venv/bin/python\",\n  \"python.linting.enabled\": true,\n  \"python.linting.flake8Enabled\": true,\n  \"python.formatting.provider\": \"black\",\n  \"python.testing.pytestEnabled\": true,\n  \"python.testing.pytestArgs\": [\"tests\"],\n  \"editor.formatOnSave\": true,\n  \"editor.codeActionsOnSave\": {\n    \"source.organizeImports\": true\n  }\n}\n</code></pre> <p>.vscode/launch.json (for debugging):</p> <pre><code>{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"Python: FastAPI\",\n      \"type\": \"python\",\n      \"request\": \"launch\",\n      \"program\": \"${workspaceFolder}/src/main.py\",\n      \"console\": \"integratedTerminal\",\n      \"env\": {\n        \"PYTHONPATH\": \"${workspaceFolder}/src\"\n      }\n    },\n    {\n      \"name\": \"Python: Pytest\",\n      \"type\": \"python\",\n      \"request\": \"launch\",\n      \"module\": \"pytest\",\n      \"args\": [\"tests\", \"-v\"],\n      \"console\": \"integratedTerminal\"\n    }\n  ]\n}\n</code></pre>"},{"location":"guides/local-development/#docker-development-services","title":"\ud83d\udc33 Docker Development Services","text":"<p>docker-compose.dev.yml:</p> <pre><code>version: \"3.8\"\n\nservices:\n  mongodb:\n    image: mongo:5.0\n    ports:\n      - \"27017:27017\"\n    environment:\n      MONGO_INITDB_ROOT_USERNAME: admin\n      MONGO_INITDB_ROOT_PASSWORD: password\n    volumes:\n      - mongodb_data:/data/db\n    networks:\n      - neuroglia-dev\n\n  redis:\n    image: redis:7-alpine\n    ports:\n      - \"6379:6379\"\n    networks:\n      - neuroglia-dev\n\n  mailhog:\n    image: mailhog/mailhog\n    ports:\n      - \"1025:1025\" # SMTP\n      - \"8025:8025\" # Web UI\n    networks:\n      - neuroglia-dev\n\nvolumes:\n  mongodb_data:\n\nnetworks:\n  neuroglia-dev:\n    driver: bridge\n</code></pre> <p>Start development services:</p> <pre><code>docker-compose -f docker-compose.dev.yml up -d\n</code></pre>"},{"location":"guides/local-development/#testing-setup","title":"\ud83e\uddea Testing Setup","text":"<p>tests/conftest.py:</p> <pre><code>import pytest\nfrom neuroglia.dependency_injection import ServiceCollection\nfrom neuroglia.mediation import Mediator\n\n@pytest.fixture\ndef service_collection():\n    \"\"\"Create a fresh service collection for testing\"\"\"\n    return ServiceCollection()\n\n@pytest.fixture\ndef service_provider(service_collection):\n    \"\"\"Create a service provider for testing\"\"\"\n    service_collection.add_mediator()\n    return service_collection.build_provider()\n\n@pytest.fixture\ndef mediator(service_provider):\n    \"\"\"Get mediator instance for testing\"\"\"\n    return service_provider.get_service(Mediator)\n</code></pre> <p>tests/unit/test_example.py:</p> <pre><code>import pytest\nfrom src.domain.entities.example import ExampleEntity\n\nclass TestExampleEntity:\n    def test_entity_creation(self):\n        \"\"\"Test entity can be created successfully\"\"\"\n        entity = ExampleEntity(name=\"Test\")\n        assert entity.name == \"Test\"\n        assert entity.id is not None\n\n    @pytest.mark.asyncio\n    async def test_async_operation(self):\n        \"\"\"Test async operations work correctly\"\"\"\n        # Add async test logic here\n        pass\n</code></pre>"},{"location":"guides/local-development/#development-workflow","title":"\ud83c\udfc3\u200d\u2642\ufe0f Development Workflow","text":""},{"location":"guides/local-development/#daily-development-commands","title":"Daily Development Commands","text":"<pre><code># Start development services\ndocker-compose -f docker-compose.dev.yml up -d\n\n# Activate virtual environment (if using venv)\nsource venv/bin/activate  # or `poetry shell`\n\n# Run your application\npython src/main.py\n\n# Run tests\npytest\n\n# Run tests with coverage\npytest --cov=src --cov-report=html\n\n# Format code\nblack src tests\n\n# Lint code\nflake8 src tests\n\n# Type checking\nmypy src\n</code></pre>"},{"location":"guides/local-development/#git-hooks-setup","title":"Git Hooks Setup","text":"<p>.pre-commit-config.yaml:</p> <pre><code>repos:\n  - repo: https://github.com/psf/black\n    rev: 22.3.0\n    hooks:\n      - id: black\n        language_version: python3.8\n\n  - repo: https://github.com/pycqa/flake8\n    rev: 5.0.4\n    hooks:\n      - id: flake8\n\n  - repo: https://github.com/pre-commit/mirrors-mypy\n    rev: v1.0.0\n    hooks:\n      - id: mypy\n</code></pre> <p>Install pre-commit:</p> <pre><code>pip install pre-commit\npre-commit install\n</code></pre>"},{"location":"guides/local-development/#debugging-and-monitoring","title":"\ud83d\udd0d Debugging and Monitoring","text":""},{"location":"guides/local-development/#application-logging","title":"Application Logging","text":"<p>src/config/logging.py:</p> <pre><code>import logging\nimport sys\nfrom pathlib import Path\n\ndef setup_logging(log_level: str = \"INFO\"):\n    \"\"\"Configure application logging\"\"\"\n\n    # Create logs directory\n    Path(\"logs\").mkdir(exist_ok=True)\n\n    # Configure logging\n    logging.basicConfig(\n        level=getattr(logging, log_level.upper()),\n        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n        handlers=[\n            logging.FileHandler('logs/app.log'),\n            logging.StreamHandler(sys.stdout)\n        ]\n    )\n\n    # Configure third-party loggers\n    logging.getLogger(\"uvicorn\").setLevel(logging.INFO)\n    logging.getLogger(\"fastapi\").setLevel(logging.INFO)\n</code></pre>"},{"location":"guides/local-development/#environment-configuration","title":"Environment Configuration","text":"<p>.env.development:</p> <pre><code># Application\nAPP_NAME=My Neuroglia App\nAPP_VERSION=0.1.0\nDEBUG=true\nLOG_LEVEL=DEBUG\n\n# Database\nMONGODB_URL=mongodb://admin:password@localhost:27017\nREDIS_URL=redis://localhost:6379\n\n# External Services\nSMTP_HOST=localhost\nSMTP_PORT=1025\n</code></pre>"},{"location":"guides/local-development/#environment-validation","title":"\u2705 Environment Validation","text":"<p>Create a validation script to ensure everything is set up correctly:</p> <p>scripts/validate-env.py:</p> <pre><code>#!/usr/bin/env python3\n\"\"\"Validate development environment setup\"\"\"\n\nimport sys\nimport subprocess\nfrom pathlib import Path\n\ndef check_python_version():\n    \"\"\"Check Python version\"\"\"\n    if sys.version_info &lt; (3, 8):\n        print(\"\u274c Python 3.8+ required\")\n        return False\n    print(f\"\u2705 Python {sys.version_info.major}.{sys.version_info.minor}\")\n    return True\n\ndef check_dependencies():\n    \"\"\"Check if required packages are installed\"\"\"\n    try:\n        import neuroglia\n        print(\"\u2705 Neuroglia installed\")\n        return True\n    except ImportError:\n        print(\"\u274c Neuroglia not installed\")\n        return False\n\ndef check_docker():\n    \"\"\"Check if Docker services are running\"\"\"\n    try:\n        result = subprocess.run(\n            [\"docker\", \"ps\"],\n            capture_output=True,\n            text=True,\n            check=True\n        )\n        if \"mongo\" in result.stdout and \"redis\" in result.stdout:\n            print(\"\u2705 Docker services running\")\n            return True\n        else:\n            print(\"\u26a0\ufe0f  Docker services not all running\")\n            return False\n    except (subprocess.CalledProcessError, FileNotFoundError):\n        print(\"\u274c Docker not available\")\n        return False\n\nif __name__ == \"__main__\":\n    checks = [\n        check_python_version(),\n        check_dependencies(),\n        check_docker()\n    ]\n\n    if all(checks):\n        print(\"\\n\ud83c\udf89 Development environment is ready!\")\n    else:\n        print(\"\\n\u274c Some issues need to be resolved\")\n        sys.exit(1)\n</code></pre> <p>Run validation:</p> <pre><code>python scripts/validate-env.py\n</code></pre>"},{"location":"guides/local-development/#next-steps","title":"\ud83d\udd04 Next Steps","text":"<p>Your development environment is now ready! Continue with:</p> <ol> <li>\u26a1 3-Minute Bootstrap - Quick hello world setup</li> <li>\ud83c\udf55 Mario's Pizzeria Tutorial - Build a complete application</li> <li>\ud83c\udfaf Architecture Patterns - Learn design principles</li> <li>\ud83d\ude80 Framework Features - Explore advanced capabilities</li> </ol>"},{"location":"guides/local-development/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Dependency Injection Setup - Advanced DI configuration</li> <li>Testing Strategies - Comprehensive testing approaches</li> <li>Project Structure - Detailed project organization</li> </ul> <p>\ud83c\udfaf Pro Tip</p> <p>Bookmark this page! You'll refer back to these commands and configurations throughout your development journey.</p>"},{"location":"guides/mario-pizzeria-tutorial/","title":"\ud83c\udf55 Mario's Pizzeria Tutorial","text":"<p>Build a complete pizza ordering system that demonstrates all of Neuroglia's features in a familiar, easy-to-understand context. This comprehensive tutorial covers clean architecture, CQRS, event-driven design, and web development.</p> <p>\ud83c\udfaf What You'll Build</p> <p>A complete pizzeria application with REST API, web UI, authentication, file-based persistence, and event-driven architecture.</p>"},{"location":"guides/mario-pizzeria-tutorial/#what-youll-build","title":"\ud83d\udccb What You'll Build","text":"<p>By the end of this guide, you'll have a complete pizzeria application with:</p> <ul> <li>\ud83c\udf10 REST API with automatic Swagger documentation</li> <li>\ud83c\udfa8 Simple Web UI for customers and kitchen staff</li> <li>\ud83d\udd10 OAuth Authentication for secure access</li> <li>\ud83d\udcbe File-based persistence using the repository pattern</li> <li>\ud83d\udce1 Event-driven architecture with domain events</li> <li>\ud83c\udfd7\ufe0f Clean Architecture with CQRS and dependency injection</li> </ul>"},{"location":"guides/mario-pizzeria-tutorial/#quick-setup","title":"\u26a1 Quick Setup","text":""},{"location":"guides/mario-pizzeria-tutorial/#installation","title":"Installation","text":"<pre><code>pip install neuroglia-python[web]\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#project-structure","title":"Project Structure","text":"<pre><code>marios-pizzeria/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 main.py                    # Application entry point\n\u2502   \u251c\u2500\u2500 domain/\n\u2502   \u2502   \u251c\u2500\u2500 pizza.py              # Pizza entity\n\u2502   \u2502   \u251c\u2500\u2500 order.py              # Order entity\n\u2502   \u2502   \u2514\u2500\u2500 events.py             # Domain events\n\u2502   \u251c\u2500\u2500 application/\n\u2502   \u2502   \u251c\u2500\u2500 commands/             # Order placement, cooking\n\u2502   \u2502   \u2514\u2500\u2500 queries/              # Menu, order status\n\u2502   \u251c\u2500\u2500 infrastructure/\n\u2502   \u2502   \u251c\u2500\u2500 repositories/         # File-based persistence\n\u2502   \u2502   \u2514\u2500\u2500 auth.py              # OAuth configuration\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u2514\u2500\u2500 controllers/         # REST endpoints\n\u2502   \u251c\u2500\u2500 web/\n\u2502   \u2502   \u2514\u2500\u2500 static/              # Simple HTML/CSS/JS\n\u2502   \u2514\u2500\u2500 data/                    # JSON files storage\n\u2514\u2500\u2500 requirements.txt\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#step-1-domain-model","title":"\ud83c\udfd7\ufe0f Step 1: Domain Model","text":"<p>src/domain/pizza.py</p> <pre><code>from dataclasses import dataclass\nfrom decimal import Decimal\nfrom typing import List\nfrom neuroglia.data.abstractions import Entity\n\n@dataclass\nclass Pizza(Entity[str]):\n    \"\"\"A pizza with toppings and pricing\"\"\"\n    id: str\n    name: str\n    size: str  # \"small\", \"medium\", \"large\"\n    base_price: Decimal\n    toppings: List[str]\n    preparation_time_minutes: int\n\n    @property\n    def total_price(self) -&gt; Decimal:\n        \"\"\"Calculate total price with toppings\"\"\"\n        return self.base_price + (Decimal(\"1.50\") * len(self.toppings))\n\n    def __post_init__(self):\n        if not self.id:\n            import uuid\n            self.id = str(uuid.uuid4())\n</code></pre> <p>src/domain/order.py</p> <pre><code>from dataclasses import dataclass, field\nfrom datetime import datetime, timedelta\nfrom decimal import Decimal\nfrom typing import List, Optional\nfrom neuroglia.data.abstractions import Entity\nfrom .pizza import Pizza\nfrom .events import OrderPlacedEvent\n\n@dataclass\nclass Order(Entity[str]):\n    \"\"\"A customer pizza order\"\"\"\n    id: str\n    customer_name: str\n    customer_phone: str\n    pizzas: List[Pizza]\n    status: str = \"pending\"  # pending, cooking, ready, delivered\n    order_time: datetime = field(default_factory=datetime.utcnow)\n    estimated_ready_time: Optional[datetime] = None\n    total_amount: Optional[Decimal] = None\n\n    def __post_init__(self):\n        if not self.id:\n            import uuid\n            self.id = str(uuid.uuid4())\n\n        if self.total_amount is None:\n            self.total_amount = sum(pizza.total_price for pizza in self.pizzas)\n\n        if self.estimated_ready_time is None:\n            prep_time = max(pizza.preparation_time_minutes for pizza in self.pizzas)\n            self.estimated_ready_time = self.order_time + timedelta(minutes=prep_time)\n\n        # Raise domain event when order is placed\n        if self.status == \"pending\":\n            self.raise_event(OrderPlacedEvent(\n                order_id=self.id,\n                customer_name=self.customer_name,\n                total_amount=self.total_amount,\n                estimated_ready_time=self.estimated_ready_time\n            ))\n\n    def start_cooking(self):\n        \"\"\"Start cooking this order\"\"\"\n        if self.status != \"pending\":\n            raise ValueError(\"Only pending orders can start cooking\")\n        self.status = \"cooking\"\n\n    def mark_ready(self):\n        \"\"\"Mark order as ready for pickup/delivery\"\"\"\n        if self.status != \"cooking\":\n            raise ValueError(\"Only cooking orders can be marked ready\")\n        self.status = \"ready\"\n</code></pre> <p>src/domain/events.py</p> <pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom neuroglia.data.abstractions import DomainEvent\n\n@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    \"\"\"Event raised when a new order is placed\"\"\"\n    order_id: str\n    customer_name: str\n    total_amount: Decimal\n    estimated_ready_time: datetime\n\n    def __post_init__(self):\n        super().__init__(self.order_id)\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#step-2-commands-and-queries","title":"\ud83c\udfaf Step 2: Commands and Queries","text":"<p>src/application/commands/place_order.py</p> <pre><code>from dataclasses import dataclass\nfrom typing import List\nfrom neuroglia.mediation import Command, CommandHandler\nfrom neuroglia.core import OperationResult\nfrom neuroglia.data.abstractions import Repository\nfrom src.domain.order import Order\nfrom src.domain.pizza import Pizza\n\n@dataclass\nclass PizzaOrderItem:\n    \"\"\"Item in a pizza order\"\"\"\n    pizza_id: str\n    size: str\n    toppings: List[str]\n\n@dataclass\nclass PlaceOrderCommand(Command[OperationResult]):\n    \"\"\"Command to place a new pizza order\"\"\"\n    customer_name: str\n    customer_phone: str\n    pizza_items: List[PizzaOrderItem]\n\nclass PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult]):\n    \"\"\"Handler for placing pizza orders\"\"\"\n\n    def __init__(self,\n                 order_repository: Repository[Order, str],\n                 pizza_repository: Repository[Pizza, str]):\n        self.order_repository = order_repository\n        self.pizza_repository = pizza_repository\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult:\n        try:\n            # Build pizzas for the order\n            pizzas = []\n            for item in command.pizza_items:\n                # Get base pizza\n                base_pizza = await self.pizza_repository.get_by_id_async(item.pizza_id)\n                if not base_pizza:\n                    return self.bad_request(f\"Pizza {item.pizza_id} not found\")\n\n                # Create customized pizza\n                pizza = Pizza(\n                    id=\"\",  # Will be generated\n                    name=base_pizza.name,\n                    size=item.size,\n                    base_price=base_pizza.base_price,\n                    toppings=item.toppings,\n                    preparation_time_minutes=base_pizza.preparation_time_minutes\n                )\n                pizzas.append(pizza)\n\n            # Create the order\n            order = Order(\n                id=\"\",  # Will be generated\n                customer_name=command.customer_name,\n                customer_phone=command.customer_phone,\n                pizzas=pizzas\n            )\n\n            # Save the order\n            await self.order_repository.save_async(order)\n\n            return self.created({\n                \"order_id\": order.id,\n                \"total_amount\": str(order.total_amount),\n                \"estimated_ready_time\": order.estimated_ready_time.isoformat()\n            })\n\n        except Exception as e:\n            return self.internal_server_error(f\"Failed to place order: {str(e)}\")\n</code></pre> <p>src/application/queries/get_menu.py</p> <pre><code>from dataclasses import dataclass\nfrom typing import List\nfrom neuroglia.mediation import Query, QueryHandler\nfrom neuroglia.core import OperationResult\nfrom neuroglia.data.abstractions import Repository\nfrom src.domain.pizza import Pizza\n\n@dataclass\nclass GetMenuQuery(Query[OperationResult[List[dict]]]):\n    \"\"\"Query to get the pizzeria menu\"\"\"\n    pass\n\nclass GetMenuHandler(QueryHandler[GetMenuQuery, OperationResult[List[dict]]]):\n    \"\"\"Handler for getting the pizzeria menu\"\"\"\n\n    def __init__(self, pizza_repository: Repository[Pizza, str]):\n        self.pizza_repository = pizza_repository\n\n    async def handle_async(self, query: GetMenuQuery) -&gt; OperationResult[List[dict]]:\n        try:\n            pizzas = await self.pizza_repository.get_all_async()\n\n            menu_items = []\n            for pizza in pizzas:\n                menu_items.append({\n                    \"id\": pizza.id,\n                    \"name\": pizza.name,\n                    \"base_price\": str(pizza.base_price),\n                    \"preparation_time_minutes\": pizza.preparation_time_minutes,\n                    \"sizes\": [\"small\", \"medium\", \"large\"],\n                    \"available_toppings\": [\n                        \"pepperoni\", \"mushrooms\", \"bell_peppers\",\n                        \"onions\", \"sausage\", \"extra_cheese\"\n                    ]\n                })\n\n            return self.ok(menu_items)\n\n        except Exception as e:\n            return self.internal_server_error(f\"Failed to get menu: {str(e)}\")\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#step-3-file-based-repository","title":"\ud83d\udcbe Step 3: File-Based Repository","text":"<p>src/infrastructure/repositories/file_repository.py</p> <pre><code>import json\nimport os\nfrom pathlib import Path\nfrom typing import List, Optional, TypeVar, Generic\nfrom neuroglia.data.abstractions import Repository\n\nT = TypeVar('T')\nTKey = TypeVar('TKey')\n\nclass FileRepository(Repository[T, TKey], Generic[T, TKey]):\n    \"\"\"Simple file-based repository using JSON storage\"\"\"\n\n    def __init__(self, entity_type: type, data_dir: str = \"data\"):\n        self.entity_type = entity_type\n        self.data_dir = Path(data_dir)\n        self.entity_dir = self.data_dir / entity_type.__name__.lower()\n\n        # Ensure directory exists\n        self.entity_dir.mkdir(parents=True, exist_ok=True)\n\n    async def save_async(self, entity: T) -&gt; None:\n        \"\"\"Save entity to JSON file\"\"\"\n        file_path = self.entity_dir / f\"{entity.id}.json\"\n\n        # Convert entity to dict for JSON serialization\n        entity_dict = self._entity_to_dict(entity)\n\n        with open(file_path, 'w') as f:\n            json.dump(entity_dict, f, indent=2, default=str)\n\n    async def get_by_id_async(self, id: TKey) -&gt; Optional[T]:\n        \"\"\"Get entity by ID from JSON file\"\"\"\n        file_path = self.entity_dir / f\"{id}.json\"\n\n        if not file_path.exists():\n            return None\n\n        with open(file_path, 'r') as f:\n            entity_dict = json.load(f)\n\n        return self._dict_to_entity(entity_dict)\n\n    async def get_all_async(self) -&gt; List[T]:\n        \"\"\"Get all entities from JSON files\"\"\"\n        entities = []\n\n        for file_path in self.entity_dir.glob(\"*.json\"):\n            with open(file_path, 'r') as f:\n                entity_dict = json.load(f)\n                entities.append(self._dict_to_entity(entity_dict))\n\n        return entities\n\n    async def delete_async(self, id: TKey) -&gt; None:\n        \"\"\"Delete entity JSON file\"\"\"\n        file_path = self.entity_dir / f\"{id}.json\"\n        if file_path.exists():\n            file_path.unlink()\n\n    def _entity_to_dict(self, entity: T) -&gt; dict:\n        \"\"\"Convert entity to dictionary for JSON serialization\"\"\"\n        if hasattr(entity, '__dict__'):\n            return entity.__dict__\n        return entity._asdict() if hasattr(entity, '_asdict') else dict(entity)\n\n    def _dict_to_entity(self, data: dict) -&gt; T:\n        \"\"\"Convert dictionary back to entity\"\"\"\n        return self.entity_type(**data)\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#step-4-rest-api-controllers","title":"\ud83c\udf10 Step 4: REST API Controllers","text":"<p>src/api/controllers/orders_controller.py</p> <pre><code>from typing import List\nfrom fastapi import status, Depends\nfrom classy_fastapi.decorators import get, post, put\nfrom neuroglia.mvc import ControllerBase\nfrom neuroglia.dependency_injection import ServiceProviderBase\nfrom neuroglia.mediation import Mediator\nfrom neuroglia.mapping import Mapper\n\nfrom src.application.commands.place_order import PlaceOrderCommand, PizzaOrderItem\nfrom src.application.queries.get_menu import GetMenuQuery\nfrom src.infrastructure.auth import get_current_user\n\nclass OrdersController(ControllerBase):\n    \"\"\"Pizza orders API controller\"\"\"\n\n    def __init__(self, service_provider: ServiceProviderBase, mapper: Mapper, mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n    @post(\"/\", response_model=dict, status_code=status.HTTP_201_CREATED)\n    async def place_order(self, request: dict) -&gt; dict:\n        \"\"\"Place a new pizza order\"\"\"\n        command = PlaceOrderCommand(\n            customer_name=request[\"customer_name\"],\n            customer_phone=request[\"customer_phone\"],\n            pizza_items=[\n                PizzaOrderItem(**item) for item in request[\"pizza_items\"]\n            ]\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @get(\"/{order_id}\", response_model=dict)\n    async def get_order(self, order_id: str) -&gt; dict:\n        \"\"\"Get order details by ID\"\"\"\n        # This would use a GetOrderQuery - simplified for brevity\n        return {\"order_id\": order_id, \"status\": \"pending\"}\n\n    @put(\"/{order_id}/cook\", response_model=dict)\n    async def start_cooking(self, order_id: str, current_user = Depends(get_current_user)) -&gt; dict:\n        \"\"\"Start cooking an order (kitchen staff only)\"\"\"\n        # This would use a StartCookingCommand - simplified for brevity\n        return {\"order_id\": order_id, \"status\": \"cooking\"}\n\nclass MenuController(ControllerBase):\n    \"\"\"Pizza menu API controller\"\"\"\n\n    def __init__(self, service_provider: ServiceProviderBase, mapper: Mapper, mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n    @get(\"/\", response_model=List[dict])\n    async def get_menu(self) -&gt; List[dict]:\n        \"\"\"Get the pizzeria menu\"\"\"\n        query = GetMenuQuery()\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#step-5-oauth-authentication","title":"\ud83d\udd10 Step 5: OAuth Authentication","text":"<p>src/infrastructure/auth.py</p> <pre><code>from typing import Optional\nfrom fastapi import HTTPException, Depends, status\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom neuroglia.core import OperationResult\n\n# Simple OAuth configuration\nOAUTH_SCOPES = {\n    \"orders:read\": \"Read order information\",\n    \"orders:write\": \"Create and modify orders\",\n    \"kitchen:manage\": \"Manage kitchen operations\",\n    \"admin\": \"Full administrative access\"\n}\n\n# Simple token validation (in production, use proper OAuth provider)\nVALID_TOKENS = {\n    \"customer_token\": {\"user\": \"customer\", \"scopes\": [\"orders:read\", \"orders:write\"]},\n    \"staff_token\": {\"user\": \"kitchen_staff\", \"scopes\": [\"orders:read\", \"kitchen:manage\"]},\n    \"admin_token\": {\"user\": \"admin\", \"scopes\": [\"admin\"]}\n}\n\nsecurity = HTTPBearer()\n\nasync def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)) -&gt; dict:\n    \"\"\"Validate token and return user info\"\"\"\n    token = credentials.credentials\n\n    if token not in VALID_TOKENS:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid authentication token\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n    return VALID_TOKENS[token]\n\ndef require_scope(required_scope: str):\n    \"\"\"Decorator to require specific OAuth scope\"\"\"\n    def check_scope(current_user: dict = Depends(get_current_user)):\n        user_scopes = current_user.get(\"scopes\", [])\n        if required_scope not in user_scopes and \"admin\" not in user_scopes:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=f\"Insufficient permissions. Required scope: {required_scope}\"\n            )\n        return current_user\n    return check_scope\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#step-6-simple-web-ui","title":"\ud83c\udfa8 Step 6: Simple Web UI","text":"<p>src/web/static/index.html</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;Mario's Pizzeria&lt;/title&gt;\n    &lt;style&gt;\n      body {\n        font-family: Arial, sans-serif;\n        max-width: 800px;\n        margin: 0 auto;\n        padding: 20px;\n      }\n      .pizza-card {\n        border: 1px solid #ddd;\n        border-radius: 8px;\n        padding: 15px;\n        margin: 10px 0;\n      }\n      .order-form {\n        background: #f5f5f5;\n        padding: 20px;\n        border-radius: 8px;\n        margin: 20px 0;\n      }\n      button {\n        background: #e74c3c;\n        color: white;\n        border: none;\n        padding: 10px 20px;\n        border-radius: 4px;\n        cursor: pointer;\n      }\n      button:hover {\n        background: #c0392b;\n      }\n      input,\n      select {\n        padding: 8px;\n        margin: 5px;\n        border: 1px solid #ddd;\n        border-radius: 4px;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;\ud83c\udf55 Welcome to Mario's Pizzeria&lt;/h1&gt;\n\n    &lt;div id=\"menu-section\"&gt;\n      &lt;h2&gt;Our Menu&lt;/h2&gt;\n      &lt;div id=\"menu-items\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;div class=\"order-form\"&gt;\n      &lt;h2&gt;Place Your Order&lt;/h2&gt;\n      &lt;form id=\"order-form\"&gt;\n        &lt;div&gt;\n          &lt;input type=\"text\" id=\"customer-name\" placeholder=\"Your Name\" required /&gt;\n          &lt;input type=\"tel\" id=\"customer-phone\" placeholder=\"Phone Number\" required /&gt;\n        &lt;/div&gt;\n        &lt;div id=\"pizza-selection\"&gt;&lt;/div&gt;\n        &lt;button type=\"submit\"&gt;Place Order&lt;/button&gt;\n      &lt;/form&gt;\n    &lt;/div&gt;\n\n    &lt;div id=\"order-status\" style=\"display: none;\"&gt;\n      &lt;h2&gt;Order Status&lt;/h2&gt;\n      &lt;div id=\"status-details\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n      // Load menu on page load\n      document.addEventListener(\"DOMContentLoaded\", loadMenu);\n\n      async function loadMenu() {\n        try {\n          const response = await fetch(\"/api/menu\");\n          const menu = await response.json();\n          displayMenu(menu);\n        } catch (error) {\n          console.error(\"Failed to load menu:\", error);\n        }\n      }\n\n      function displayMenu(menu) {\n        const menuContainer = document.getElementById(\"menu-items\");\n        menuContainer.innerHTML = menu\n          .map(\n            pizza =&gt; `\n                &lt;div class=\"pizza-card\"&gt;\n                    &lt;h3&gt;${pizza.name}&lt;/h3&gt;\n                    &lt;p&gt;Base Price: $${pizza.base_price}&lt;/p&gt;\n                    &lt;p&gt;Prep Time: ${pizza.preparation_time_minutes} minutes&lt;/p&gt;\n                    &lt;button onclick=\"addToOrder('${pizza.id}', '${pizza.name}')\"&gt;Add to Order&lt;/button&gt;\n                &lt;/div&gt;\n            `\n          )\n          .join(\"\");\n      }\n\n      function addToOrder(pizzaId, pizzaName) {\n        const selection = document.getElementById(\"pizza-selection\");\n        selection.innerHTML += `\n                &lt;div class=\"pizza-selection\"&gt;\n                    &lt;span&gt;${pizzaName}&lt;/span&gt;\n                    &lt;select name=\"size\"&gt;\n                        &lt;option value=\"small\"&gt;Small&lt;/option&gt;\n                        &lt;option value=\"medium\"&gt;Medium&lt;/option&gt;\n                        &lt;option value=\"large\"&gt;Large&lt;/option&gt;\n                    &lt;/select&gt;\n                    &lt;select name=\"toppings\" multiple&gt;\n                        &lt;option value=\"pepperoni\"&gt;Pepperoni&lt;/option&gt;\n                        &lt;option value=\"mushrooms\"&gt;Mushrooms&lt;/option&gt;\n                        &lt;option value=\"bell_peppers\"&gt;Bell Peppers&lt;/option&gt;\n                    &lt;/select&gt;\n                    &lt;input type=\"hidden\" name=\"pizza_id\" value=\"${pizzaId}\"&gt;\n                &lt;/div&gt;\n            `;\n      }\n\n      document.getElementById(\"order-form\").addEventListener(\"submit\", async e =&gt; {\n        e.preventDefault();\n\n        const formData = new FormData(e.target);\n        const order = {\n          customer_name: formData.get(\"customer-name\"),\n          customer_phone: formData.get(\"customer-phone\"),\n          pizza_items: Array.from(document.querySelectorAll(\".pizza-selection\")).map(item =&gt; ({\n            pizza_id: item.querySelector('[name=\"pizza_id\"]').value,\n            size: item.querySelector('[name=\"size\"]').value,\n            toppings: Array.from(item.querySelectorAll('[name=\"toppings\"] option:checked')).map(opt =&gt; opt.value),\n          })),\n        };\n\n        try {\n          const response = await fetch(\"/api/orders\", {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(order),\n          });\n\n          const result = await response.json();\n          showOrderStatus(result);\n        } catch (error) {\n          alert(\"Failed to place order: \" + error.message);\n        }\n      });\n\n      function showOrderStatus(order) {\n        document.getElementById(\"order-status\").style.display = \"block\";\n        document.getElementById(\"status-details\").innerHTML = `\n                &lt;p&gt;&lt;strong&gt;Order ID:&lt;/strong&gt; ${order.order_id}&lt;/p&gt;\n                &lt;p&gt;&lt;strong&gt;Total:&lt;/strong&gt; $${order.total_amount}&lt;/p&gt;\n                &lt;p&gt;&lt;strong&gt;Estimated Ready Time:&lt;/strong&gt; ${new Date(\n                  order.estimated_ready_time\n                ).toLocaleTimeString()}&lt;/p&gt;\n            `;\n      }\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#step-7-application-setup","title":"\ud83d\ude80 Step 7: Application Setup","text":"<p>src/main.py</p> <pre><code>import logging\nfrom pathlib import Path\nfrom neuroglia.hosting import EnhancedWebApplicationBuilder\nfrom neuroglia.mediation import Mediator\nfrom neuroglia.mapping import Mapper\n\nfrom src.domain.pizza import Pizza\nfrom src.domain.order import Order\nfrom src.infrastructure.repositories.file_repository import FileRepository\nfrom src.application.commands.place_order import PlaceOrderHandler\nfrom src.application.queries.get_menu import GetMenuHandler\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlog = logging.getLogger(__name__)\n\ndef create_app():\n    \"\"\"Create and configure Mario's Pizzeria application\"\"\"\n\n    # Create enhanced web application builder\n    builder = EnhancedWebApplicationBuilder()\n\n    # Register repositories\n    builder.services.add_singleton(lambda: FileRepository(Pizza, \"data\"))\n    builder.services.add_singleton(lambda: FileRepository(Order, \"data\"))\n\n    # Register command/query handlers\n    builder.services.add_scoped(PlaceOrderHandler)\n    builder.services.add_scoped(GetMenuHandler)\n\n    # Configure mediation\n    Mediator.configure(builder, [\"src.application\"])\n\n    # Configure object mapping\n    Mapper.configure(builder, [\"src\"])\n\n    # Add controllers with API prefix\n    builder.add_controllers_with_prefix(\"src.api.controllers\", \"/api\")\n\n    # Build the application\n    app = builder.build()\n\n    # Add static file serving for the web UI\n    from fastapi.staticfiles import StaticFiles\n    app.mount(\"/\", StaticFiles(directory=\"src/web/static\", html=True), name=\"static\")\n\n    # Add middleware for CORS (if needed)\n    from fastapi.middleware.cors import CORSMiddleware\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n\n    return app\n\nasync def setup_sample_data():\n    \"\"\"Create sample pizza menu\"\"\"\n    pizza_repo = FileRepository(Pizza, \"data\")\n\n    # Check if data already exists\n    existing_pizzas = await pizza_repo.get_all_async()\n    if existing_pizzas:\n        return\n\n    # Create sample pizzas\n    sample_pizzas = [\n        Pizza(\"margherita\", \"Margherita\", \"medium\", Decimal(\"12.99\"), [], 15),\n        Pizza(\"pepperoni\", \"Pepperoni\", \"medium\", Decimal(\"15.99\"), [\"pepperoni\"], 18),\n        Pizza(\"supreme\", \"Supreme\", \"medium\", Decimal(\"18.99\"), [\"pepperoni\", \"mushrooms\", \"bell_peppers\"], 22)\n    ]\n\n    for pizza in sample_pizzas:\n        await pizza_repo.save_async(pizza)\n\n    log.info(\"Sample pizza menu created\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    import uvicorn\n\n    # Setup sample data\n    asyncio.run(setup_sample_data())\n\n    # Create and run the application\n    app = create_app()\n\n    log.info(\"\ud83c\udf55 Starting Mario's Pizzeria...\")\n    log.info(\"\ud83c\udf10 Web UI: http://localhost:8000\")\n    log.info(\"\ud83d\udcda API Docs: http://localhost:8000/docs\")\n\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre>"},{"location":"guides/mario-pizzeria-tutorial/#youre-done","title":"\ud83c\udf89 You're Done!","text":"<p>Run your pizzeria:</p> <pre><code>cd marios-pizzeria\npython src/main.py\n</code></pre> <p>Visit your application:</p> <ul> <li>Web UI: http://localhost:8000</li> <li>API Documentation: http://localhost:8000/docs</li> <li>API Endpoints: http://localhost:8000/api</li> </ul>"},{"location":"guides/mario-pizzeria-tutorial/#what-youve-built","title":"\ud83d\udd0d What You've Built","text":"<p>\u2705 Complete Web Application with UI and API \u2705 Clean Architecture with domain, application, and infrastructure layers \u2705 CQRS Pattern with commands and queries \u2705 Event-Driven Design with domain events \u2705 File-Based Persistence using the repository pattern \u2705 OAuth Authentication for secure endpoints \u2705 Enhanced Web Application Builder with multi-app support \u2705 Automatic API Documentation with Swagger UI</p>"},{"location":"guides/mario-pizzeria-tutorial/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<p>Now that you've built a complete application, explore advanced Neuroglia features:</p>"},{"location":"guides/mario-pizzeria-tutorial/#architecture-deep-dives","title":"\ud83c\udfdb\ufe0f Architecture Deep Dives","text":"<ul> <li>Architecture Overview - Clean architecture principles and layer separation</li> <li>CQRS &amp; Mediation - Advanced command/query patterns and pipeline behaviors</li> <li>Dependency Injection - Advanced DI patterns and service lifetimes</li> </ul>"},{"location":"guides/mario-pizzeria-tutorial/#advanced-features","title":"\ud83d\ude80 Advanced Features","text":"<ul> <li>Event Sourcing - Complete event-driven architecture with event stores</li> <li>Data Access - MongoDB and other persistence options beyond file storage</li> <li>MVC Controllers - Advanced controller patterns and API design</li> </ul>"},{"location":"guides/mario-pizzeria-tutorial/#sample-applications","title":"\ud83d\udccb Sample Applications","text":"<ul> <li>OpenBank Sample - Banking domain with event sourcing</li> <li>API Gateway Sample - Microservice gateway patterns</li> <li>Desktop Controller Sample - Background services and system integration</li> </ul>"},{"location":"guides/mario-pizzeria-tutorial/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\u26a1 3-Minute Bootstrap - Quick hello world setup</li> <li>\ud83d\udee0\ufe0f Local Development Setup - Complete development environment</li> <li>\ud83c\udfaf Getting Started Overview - Choose your learning path</li> </ul> <p>\ud83c\udf89 Congratulations!</p> <p>You've built a complete, production-ready application using Neuroglia! All other documentation examples use this same pizzeria domain for consistency - you'll feel right at home exploring advanced features.</p>"},{"location":"guides/project-setup/","title":"\ud83d\ude80 Project Setup Guide","text":"<p>\ud83d\udea7 Under Construction</p> <p>This guide is currently being developed with comprehensive setup procedures and troubleshooting tips. More detailed examples and best practices are being added.</p> <p>Complete guide for setting up new Neuroglia Python Framework projects, from initial creation to deployment-ready applications.</p>"},{"location":"guides/project-setup/#overview","title":"\ud83c\udfaf Overview","text":"<p>This guide walks you through creating a new Neuroglia project using the Mario's Pizzeria example, covering project structure, dependency management, and initial configuration.</p>"},{"location":"guides/project-setup/#prerequisites","title":"\ud83d\udccb Prerequisites","text":"<p>Before starting, ensure you have:</p> <ul> <li>Python 3.9+ installed</li> <li>Poetry for dependency management</li> <li>Git for version control</li> <li>VS Code or preferred IDE</li> </ul> <pre><code># Verify Python version\npython --version  # Should be 3.9 or higher\n\n# Install Poetry if not already installed\ncurl -sSL https://install.python-poetry.org | python3 -\n\n# Verify Poetry installation\npoetry --version\n</code></pre>"},{"location":"guides/project-setup/#creating-a-new-project","title":"\ud83c\udfd7\ufe0f Creating a New Project","text":""},{"location":"guides/project-setup/#option-1-using-pyneuroctl-recommended","title":"Option 1: Using PyNeuroctl (Recommended)","text":"<pre><code># Install the CLI tool\npip install neuroglia-cli\n\n# Create new project from pizzeria template\npyneuroctl new my-pizzeria --template pizzeria\ncd my-pizzeria\n\n# Install dependencies\npoetry install\n\n# Run the application\npoetry run python main.py\n</code></pre>"},{"location":"guides/project-setup/#option-2-manual-setup","title":"Option 2: Manual Setup","text":"<pre><code># Create project directory\nmkdir my-pizzeria &amp;&amp; cd my-pizzeria\n\n# Initialize Poetry project\npoetry init --name my-pizzeria --description \"Pizza ordering system\"\n\n# Add Neuroglia framework\npoetry add neuroglia\n\n# Add development dependencies\npoetry add --group dev pytest pytest-asyncio httpx\n\n# Create project structure\nmkdir -p src/{api,application,domain,integration}\nmkdir -p tests/{unit,integration}\n</code></pre>"},{"location":"guides/project-setup/#project-structure","title":"\ud83d\udcc1 Project Structure","text":"<p>Create the clean architecture structure:</p> <pre><code>my-pizzeria/\n\u251c\u2500\u2500 pyproject.toml              # Project configuration\n\u251c\u2500\u2500 main.py                     # Application entry point\n\u251c\u2500\u2500 README.md                   # Project documentation\n\u251c\u2500\u2500 .env                        # Environment variables\n\u251c\u2500\u2500 .gitignore                  # Git ignore patterns\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 api/                    # \ud83c\udf10 API Layer\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 controllers/        # REST endpoints\n\u2502   \u2502   \u2514\u2500\u2500 dtos/              # Request/response models\n\u2502   \u251c\u2500\u2500 application/            # \ud83d\udcbc Application Layer\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 commands/          # Write operations\n\u2502   \u2502   \u251c\u2500\u2500 queries/           # Read operations\n\u2502   \u2502   \u251c\u2500\u2500 handlers/          # Business logic\n\u2502   \u2502   \u2514\u2500\u2500 services/          # Application services\n\u2502   \u251c\u2500\u2500 domain/                # \ud83c\udfdb\ufe0f Domain Layer\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 entities/          # Business entities\n\u2502   \u2502   \u251c\u2500\u2500 events/            # Domain events\n\u2502   \u2502   \u2514\u2500\u2500 repositories/      # Repository interfaces\n\u2502   \u2514\u2500\u2500 integration/           # \ud83d\udd0c Integration Layer\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 repositories/      # Data access implementations\n\u2502       \u2514\u2500\u2500 services/          # External service integrations\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 conftest.py           # Test configuration\n\u2502   \u251c\u2500\u2500 unit/                 # Unit tests\n\u2502   \u2514\u2500\u2500 integration/          # Integration tests\n\u2514\u2500\u2500 docs/                     # Project documentation\n</code></pre>"},{"location":"guides/project-setup/#configuration-setup","title":"\u2699\ufe0f Configuration Setup","text":""},{"location":"guides/project-setup/#1-environment-configuration","title":"1. Environment Configuration","text":"<p>Create <code>.env</code> file:</p> <pre><code># Application Settings\nAPP_NAME=My Pizzeria\nAPP_VERSION=1.0.0\nDEBUG=true\n\n# Server Configuration\nHOST=0.0.0.0\nPORT=8000\n\n# Database Configuration\nDATABASE_TYPE=mongodb\nMONGODB_CONNECTION_STRING=mongodb://localhost:27017/pizzeria\n\n# External Services\nSMS_SERVICE_API_KEY=your_sms_api_key\nEMAIL_SERVICE_API_KEY=your_email_api_key\nPAYMENT_GATEWAY_API_KEY=your_payment_api_key\n\n# Logging\nLOG_LEVEL=INFO\nLOG_FORMAT=json\n</code></pre>"},{"location":"guides/project-setup/#2-project-configuration","title":"2. Project Configuration","text":"<p>Update <code>pyproject.toml</code>:</p> <pre><code>[tool.poetry]\nname = \"my-pizzeria\"\nversion = \"1.0.0\"\ndescription = \"Pizza ordering system built with Neuroglia\"\nauthors = [\"Your Name &lt;your.email@example.com&gt;\"]\npackages = [{include = \"src\"}]\n\n[tool.poetry.dependencies]\npython = \"^3.9\"\nneuroglia = \"^0.3.0\"\nfastapi = \"^0.104.0\"\nuvicorn = \"^0.24.0\"\nmotor = \"^3.3.0\"  # MongoDB async driver\npydantic-settings = \"^2.0.0\"\n\n[tool.poetry.group.dev.dependencies]\npytest = \"^7.4.0\"\npytest-asyncio = \"^0.21.0\"\nhttpx = \"^0.25.0\"\npytest-cov = \"^4.1.0\"\nblack = \"^23.0.0\"\nisort = \"^5.12.0\"\nmypy = \"^1.6.0\"\n\n[tool.pytest.ini_options]\nasyncio_mode = \"auto\"\ntestpaths = [\"tests\"]\npython_files = [\"test_*.py\", \"*_test.py\"]\n\n[tool.black]\nline-length = 100\ntarget-version = ['py39']\n\n[tool.isort]\nprofile = \"black\"\nmulti_line_output = 3\nline_length = 100\n\n[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n</code></pre>"},{"location":"guides/project-setup/#initial-implementation","title":"\ud83c\udf55 Initial Implementation","text":""},{"location":"guides/project-setup/#1-application-entry-point","title":"1. Application Entry Point","text":"<p>Create <code>main.py</code>:</p> <pre><code>import asyncio\nfrom src.startup import create_app\n\nasync def main():\n    \"\"\"Application entry point\"\"\"\n    app = await create_app()\n\n    import uvicorn\n    uvicorn.run(\n        app,\n        host=\"0.0.0.0\",\n        port=8000,\n        reload=True  # Development only\n    )\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"guides/project-setup/#2-application-startup","title":"2. Application Startup","text":"<p>Create <code>src/startup.py</code>:</p> <pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.dependency_injection import ServiceCollection\nfrom src.api.controllers.orders_controller import OrdersController\nfrom src.application.handlers.place_order_handler import PlaceOrderHandler\nfrom src.integration.repositories.mongo_order_repository import MongoOrderRepository\n\nasync def create_app():\n    \"\"\"Configure and build the application\"\"\"\n    builder = WebApplicationBuilder()\n\n    # Configure services\n    configure_services(builder.services)\n\n    # Build application\n    app = builder.build()\n\n    # Configure middleware\n    configure_middleware(app)\n\n    return app\n\ndef configure_services(services: ServiceCollection):\n    \"\"\"Configure dependency injection\"\"\"\n    # Add framework services\n    services.add_mediator()\n    services.add_controllers([\n        \"src.api.controllers\"\n    ])\n\n    # Add application services\n    services.add_scoped(PlaceOrderHandler)\n\n    # Add repositories\n    services.add_scoped(MongoOrderRepository)\n\n    # Add external services\n    # services.add_scoped(SMSService)\n    # services.add_scoped(PaymentService)\n\ndef configure_middleware(app):\n    \"\"\"Configure application middleware\"\"\"\n    # Add CORS if needed\n    # app.add_middleware(CORSMiddleware, ...)\n\n    # Add authentication if needed\n    # app.add_middleware(AuthenticationMiddleware, ...)\n\n    pass\n</code></pre>"},{"location":"guides/project-setup/#3-first-domain-entity","title":"3. First Domain Entity","text":"<p>Create <code>src/domain/entities/order.py</code>:</p> <pre><code>from dataclasses import dataclass\nfrom decimal import Decimal\nfrom datetime import datetime\nfrom typing import List, Optional\nfrom enum import Enum\nfrom neuroglia.domain import Entity\nfrom src.domain.events.order_events import OrderPlacedEvent\n\nclass OrderStatus(Enum):\n    PENDING = \"pending\"\n    CONFIRMED = \"confirmed\"\n    PREPARING = \"preparing\"\n    READY = \"ready\"\n    DELIVERED = \"delivered\"\n    CANCELLED = \"cancelled\"\n\n@dataclass\nclass OrderItem:\n    pizza_name: str\n    size: str\n    quantity: int\n    price: Decimal\n\nclass Order(Entity):\n    def __init__(self,\n                 customer_id: str,\n                 items: List[OrderItem],\n                 delivery_address: str,\n                 special_instructions: Optional[str] = None):\n        super().__init__()\n        self.customer_id = customer_id\n        self.items = items\n        self.delivery_address = delivery_address\n        self.special_instructions = special_instructions\n        self.status = OrderStatus.PENDING\n        self.total = self._calculate_total()\n        self.created_at = datetime.now(timezone.utc)\n        self.updated_at = self.created_at\n\n        # Raise domain event\n        self.raise_event(OrderPlacedEvent(\n            order_id=self.id,\n            customer_id=customer_id,\n            total=self.total,\n            items=items\n        ))\n\n    def _calculate_total(self) -&gt; Decimal:\n        \"\"\"Calculate order total with tax\"\"\"\n        subtotal = sum(item.price * item.quantity for item in self.items)\n        tax = subtotal * Decimal('0.08')  # 8% tax\n        return subtotal + tax\n\n    def confirm(self):\n        \"\"\"Confirm the order\"\"\"\n        if self.status != OrderStatus.PENDING:\n            raise ValueError(\"Only pending orders can be confirmed\")\n        self.status = OrderStatus.CONFIRMED\n        self.updated_at = datetime.now(timezone.utc)\n</code></pre>"},{"location":"guides/project-setup/#4-first-command-handler","title":"4. First Command Handler","text":"<p>Create <code>src/application/handlers/place_order_handler.py</code>:</p> <pre><code>from dataclasses import dataclass\nfrom typing import List\nfrom neuroglia.mediation import Command, CommandHandler\nfrom neuroglia.core import OperationResult\nfrom src.domain.entities.order import Order, OrderItem\nfrom src.api.dtos.order_dto import OrderDto\n\n@dataclass\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    customer_id: str\n    items: List[OrderItem]\n    delivery_address: str\n    special_instructions: str = None\n\nclass PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    def __init__(self, order_repository):\n        self._repository = order_repository\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        try:\n            # Create domain entity\n            order = Order(\n                customer_id=command.customer_id,\n                items=command.items,\n                delivery_address=command.delivery_address,\n                special_instructions=command.special_instructions\n            )\n\n            # Persist order\n            await self._repository.save_async(order)\n\n            # Return success result\n            dto = OrderDto(\n                id=order.id,\n                customer_id=order.customer_id,\n                total=order.total,\n                status=order.status.value,\n                created_at=order.created_at\n            )\n\n            return self.created(dto)\n\n        except Exception as ex:\n            return self.internal_server_error(f\"Failed to place order: {str(ex)}\")\n</code></pre>"},{"location":"guides/project-setup/#5-first-controller","title":"5. First Controller","text":"<p>Create <code>src/api/controllers/orders_controller.py</code>:</p> <pre><code>from fastapi import HTTPException\nfrom neuroglia.mvc import ControllerBase\nfrom classy_fastapi import post\nfrom src.application.handlers.place_order_handler import PlaceOrderCommand\nfrom src.api.dtos.place_order_request import PlaceOrderRequest\nfrom src.api.dtos.order_dto import OrderDto\n\nclass OrdersController(ControllerBase):\n\n    @post(\"/orders\", response_model=OrderDto, status_code=201)\n    async def place_order(self, request: PlaceOrderRequest) -&gt; OrderDto:\n        \"\"\"Place a new pizza order\"\"\"\n        command = PlaceOrderCommand(\n            customer_id=request.customer_id,\n            items=request.items,\n            delivery_address=request.delivery_address,\n            special_instructions=request.special_instructions\n        )\n\n        result = await self.mediator.execute_async(command)\n\n        if result.is_success:\n            return result.data\n        else:\n            raise HTTPException(\n                status_code=result.status_code,\n                detail=result.error_message\n            )\n</code></pre>"},{"location":"guides/project-setup/#testing-setup","title":"\ud83e\uddea Testing Setup","text":""},{"location":"guides/project-setup/#1-test-configuration","title":"1. Test Configuration","text":"<p>Create <code>tests/conftest.py</code>:</p> <pre><code>import pytest\nfrom unittest.mock import Mock\nfrom neuroglia.dependency_injection import ServiceCollection\nfrom src.startup import configure_services\n\n@pytest.fixture\ndef service_collection():\n    \"\"\"Provide a configured service collection for testing\"\"\"\n    services = ServiceCollection()\n    configure_services(services)\n    return services\n\n@pytest.fixture\ndef mock_order_repository():\n    \"\"\"Provide a mocked order repository\"\"\"\n    return Mock()\n\n@pytest.fixture\ndef sample_order_items():\n    \"\"\"Provide sample order items for testing\"\"\"\n    from src.domain.entities.order import OrderItem\n    from decimal import Decimal\n\n    return [\n        OrderItem(\n            pizza_name=\"Margherita\",\n            size=\"Large\",\n            quantity=1,\n            price=Decimal('15.99')\n        ),\n        OrderItem(\n            pizza_name=\"Pepperoni\",\n            size=\"Medium\",\n            quantity=2,\n            price=Decimal('12.99')\n        )\n    ]\n</code></pre>"},{"location":"guides/project-setup/#2-first-unit-test","title":"2. First Unit Test","text":"<p>Create <code>tests/unit/test_place_order_handler.py</code>:</p> <pre><code>import pytest\nfrom decimal import Decimal\nfrom src.application.handlers.place_order_handler import PlaceOrderHandler, PlaceOrderCommand\n\nclass TestPlaceOrderHandler:\n    def setup_method(self):\n        self.mock_repository = Mock()\n        self.handler = PlaceOrderHandler(self.mock_repository)\n\n    @pytest.mark.asyncio\n    async def test_place_order_success(self, sample_order_items):\n        # Arrange\n        command = PlaceOrderCommand(\n            customer_id=\"123\",\n            items=sample_order_items,\n            delivery_address=\"123 Pizza St\"\n        )\n\n        # Act\n        result = await self.handler.handle_async(command)\n\n        # Assert\n        assert result.is_success\n        assert result.data.customer_id == \"123\"\n        self.mock_repository.save_async.assert_called_once()\n</code></pre>"},{"location":"guides/project-setup/#running-the-application","title":"\ud83d\ude80 Running the Application","text":""},{"location":"guides/project-setup/#development-mode","title":"Development Mode","text":"<pre><code># Install dependencies\npoetry install\n\n# Run with hot reload\npoetry run python main.py\n\n# Or using uvicorn directly\npoetry run uvicorn src.main:app --reload\n</code></pre>"},{"location":"guides/project-setup/#testing","title":"Testing","text":"<pre><code># Run all tests\npoetry run pytest\n\n# Run with coverage\npoetry run pytest --cov=src\n\n# Run specific test file\npoetry run pytest tests/unit/test_place_order_handler.py -v\n</code></pre>"},{"location":"guides/project-setup/#code-quality","title":"Code Quality","text":"<pre><code># Format code\npoetry run black src tests\n\n# Sort imports\npoetry run isort src tests\n\n# Type checking\npoetry run mypy src\n</code></pre>"},{"location":"guides/project-setup/#next-steps","title":"\ud83d\udd27 Next Steps","text":"<p>After basic setup, consider:</p> <ol> <li>API Development Guide - Add more endpoints</li> <li>Testing Guide - Comprehensive testing strategies</li> <li>Database Integration Guide - Connect to real databases</li> <li>Deployment Guide - Deploy to production</li> </ol>"},{"location":"guides/project-setup/#troubleshooting","title":"\ud83c\udd98 Troubleshooting","text":""},{"location":"guides/project-setup/#common-issues","title":"Common Issues","text":"<p>Import Errors</p> <pre><code># Ensure proper Python path\nexport PYTHONPATH=\"${PYTHONPATH}:${PWD}/src\"\n</code></pre> <p>Poetry Issues</p> <pre><code># Reset poetry environment\npoetry env remove python\npoetry install\n</code></pre> <p>Missing Dependencies</p> <pre><code># Update lock file\npoetry update\n</code></pre>"},{"location":"guides/project-setup/#related-guides","title":"\ud83d\udd17 Related Guides","text":"<ul> <li>Testing Setup - Comprehensive testing strategies</li> <li>API Development - Building REST endpoints</li> <li>Database Integration - Data persistence setup</li> </ul> <p>This guide provides the foundation for building production-ready Neuroglia applications using proven architectural patterns. \ud83d\ude80</p>"},{"location":"guides/testing-setup/","title":"\ud83e\uddea Testing Setup Guide","text":"<p>\ud83d\udea7 Under Construction</p> <p>This guide is currently being developed with comprehensive testing strategies and examples. More detailed test patterns and best practices are being added.</p> <p>Complete guide for setting up comprehensive testing in Neuroglia applications, covering unit tests, integration tests, and testing best practices.</p>"},{"location":"guides/testing-setup/#overview","title":"\ud83c\udfaf Overview","text":"<p>Testing is crucial for maintaining high-quality Neuroglia applications. This guide demonstrates testing strategies using Mario's Pizzeria as an example, covering all architectural layers.</p>"},{"location":"guides/testing-setup/#testing-strategy","title":"\ud83c\udfd7\ufe0f Testing Strategy","text":""},{"location":"guides/testing-setup/#testing-pyramid","title":"Testing Pyramid","text":"<pre><code>flowchart TD\n    subgraph \"\ud83e\uddea Testing Pyramid\"\n        E2E[End-to-End Tests&lt;br/&gt;\ud83c\udf10 Full Application Flow]\n        Integration[Integration Tests&lt;br/&gt;\ud83d\udd0c Component Interaction]\n        Unit[Unit Tests&lt;br/&gt;\u26a1 Individual Components]\n    end\n\n    E2E --&gt; Integration\n    Integration --&gt; Unit\n\n    Unit -.-&gt;|\"Most Tests\"| Fast[Fast Execution]\n    Integration -.-&gt;|\"Moderate Tests\"| Medium[Medium Execution]\n    E2E -.-&gt;|\"Few Tests\"| Slow[Slower Execution]</code></pre>"},{"location":"guides/testing-setup/#layer-specific-testing","title":"Layer-Specific Testing","text":"<ul> <li>Domain Layer: Pure unit tests for business logic</li> <li>Application Layer: Handler tests with mocked dependencies</li> <li>API Layer: Integration tests with test client</li> <li>Integration Layer: Repository and service tests</li> </ul>"},{"location":"guides/testing-setup/#test-setup","title":"\ud83d\udd27 Test Setup","text":""},{"location":"guides/testing-setup/#dependencies","title":"Dependencies","text":"<pre><code>[tool.poetry.group.dev.dependencies]\npytest = \"^7.4.0\"\npytest-asyncio = \"^0.21.0\"\npytest-cov = \"^4.1.0\"\nhttpx = \"^0.25.0\"\npytest-mock = \"^3.12.0\"\nfaker = \"^19.0.0\"\n</code></pre>"},{"location":"guides/testing-setup/#configuration","title":"Configuration","text":"<p>Create <code>pytest.ini</code>:</p> <pre><code>[tool:pytest]\nasyncio_mode = auto\ntestpaths = tests\npython_files = test_*.py *_test.py\npython_classes = Test*\npython_functions = test_*\naddopts =\n    --strict-markers\n    --strict-config\n    --cov=src\n    --cov-report=html\n    --cov-report=term-missing\n    --cov-fail-under=90\nmarkers =\n    unit: Unit tests\n    integration: Integration tests\n    e2e: End-to-end tests\n    slow: Slow running tests\n</code></pre>"},{"location":"guides/testing-setup/#unit-testing","title":"\ud83c\udfaf Unit Testing","text":""},{"location":"guides/testing-setup/#domain-entity-tests","title":"Domain Entity Tests","text":"<pre><code># tests/unit/domain/test_order.py\nimport pytest\nfrom decimal import Decimal\nfrom src.domain.entities.order import Order, OrderItem, OrderStatus\n\nclass TestOrder:\n    def test_order_creation_calculates_total_with_tax(self):\n        # Arrange\n        items = [\n            OrderItem(\"Margherita\", \"Large\", 1, Decimal('15.99')),\n            OrderItem(\"Pepperoni\", \"Medium\", 2, Decimal('12.99'))\n        ]\n\n        # Act\n        order = Order(\"customer-123\", items, \"123 Pizza St\")\n\n        # Assert\n        expected_subtotal = Decimal('41.97')  # 15.99 + (2 * 12.99)\n        expected_tax = expected_subtotal * Decimal('0.08')\n        expected_total = expected_subtotal + expected_tax\n\n        assert order.total == expected_total\n        assert order.status == OrderStatus.PENDING\n\n    def test_order_raises_domain_event(self):\n        # Arrange\n        items = [OrderItem(\"Margherita\", \"Large\", 1, Decimal('15.99'))]\n\n        # Act\n        order = Order(\"customer-123\", items, \"123 Pizza St\")\n        events = order.get_uncommitted_events()\n\n        # Assert\n        assert len(events) == 1\n        assert events[0].order_id == order.id\n        assert events[0].customer_id == \"customer-123\"\n</code></pre>"},{"location":"guides/testing-setup/#command-handler-tests","title":"Command Handler Tests","text":"<pre><code># tests/unit/application/test_place_order_handler.py\nimport pytest\nfrom unittest.mock import Mock, AsyncMock\nfrom decimal import Decimal\nfrom src.application.handlers.place_order_handler import PlaceOrderHandler, PlaceOrderCommand\nfrom src.domain.entities.order import OrderItem\n\nclass TestPlaceOrderHandler:\n    def setup_method(self):\n        self.mock_repository = Mock()\n        self.mock_repository.save_async = AsyncMock()\n        self.handler = PlaceOrderHandler(self.mock_repository)\n\n    @pytest.mark.asyncio\n    async def test_place_order_success(self):\n        # Arrange\n        items = [OrderItem(\"Margherita\", \"Large\", 1, Decimal('15.99'))]\n        command = PlaceOrderCommand(\n            customer_id=\"customer-123\",\n            items=items,\n            delivery_address=\"123 Pizza St\"\n        )\n\n        # Act\n        result = await self.handler.handle_async(command)\n\n        # Assert\n        assert result.is_success\n        assert result.data.customer_id == \"customer-123\"\n        self.mock_repository.save_async.assert_called_once()\n\n    @pytest.mark.asyncio\n    async def test_place_order_repository_error(self):\n        # Arrange\n        self.mock_repository.save_async.side_effect = Exception(\"Database error\")\n        command = PlaceOrderCommand(\n            customer_id=\"customer-123\",\n            items=[OrderItem(\"Margherita\", \"Large\", 1, Decimal('15.99'))],\n            delivery_address=\"123 Pizza St\"\n        )\n\n        # Act\n        result = await self.handler.handle_async(command)\n\n        # Assert\n        assert not result.is_success\n        assert \"Database error\" in result.error_message\n</code></pre>"},{"location":"guides/testing-setup/#integration-testing","title":"\ud83d\udd0c Integration Testing","text":""},{"location":"guides/testing-setup/#controller-integration-tests","title":"Controller Integration Tests","text":"<pre><code># tests/integration/api/test_orders_controller.py\nimport pytest\nfrom httpx import AsyncClient\nfrom src.main import create_app\n\nclass TestOrdersController:\n    @pytest.fixture\n    async def test_app(self):\n        app = await create_app()\n        return app\n\n    @pytest.fixture\n    async def test_client(self, test_app):\n        async with AsyncClient(app=test_app, base_url=\"http://test\") as client:\n            yield client\n\n    @pytest.mark.asyncio\n    async def test_place_order_success(self, test_client):\n        # Arrange\n        order_data = {\n            \"customer_id\": \"customer-123\",\n            \"items\": [\n                {\n                    \"pizza_name\": \"Margherita\",\n                    \"size\": \"Large\",\n                    \"quantity\": 1,\n                    \"price\": 15.99\n                }\n            ],\n            \"delivery_address\": \"123 Pizza St\"\n        }\n\n        # Act\n        response = await test_client.post(\"/orders\", json=order_data)\n\n        # Assert\n        assert response.status_code == 201\n        data = response.json()\n        assert data[\"customer_id\"] == \"customer-123\"\n        assert \"id\" in data\n\n    @pytest.mark.asyncio\n    async def test_place_order_validation_error(self, test_client):\n        # Arrange - Invalid data (missing required fields)\n        invalid_data = {\"customer_id\": \"customer-123\"}\n\n        # Act\n        response = await test_client.post(\"/orders\", json=invalid_data)\n\n        # Assert\n        assert response.status_code == 422  # Validation error\n</code></pre>"},{"location":"guides/testing-setup/#repository-integration-tests","title":"Repository Integration Tests","text":"<pre><code># tests/integration/repositories/test_mongo_order_repository.py\nimport pytest\nfrom motor.motor_asyncio import AsyncIOMotorClient\nfrom src.integration.repositories.mongo_order_repository import MongoOrderRepository\nfrom src.domain.entities.order import Order, OrderItem\nfrom decimal import Decimal\n\n@pytest.mark.integration\nclass TestMongoOrderRepository:\n    @pytest.fixture\n    async def mongo_client(self):\n        client = AsyncIOMotorClient(\"mongodb://localhost:27017\")\n        yield client\n        # Cleanup\n        await client.test_pizzeria.orders.drop()\n        client.close()\n\n    @pytest.fixture\n    def repository(self, mongo_client):\n        collection = mongo_client.test_pizzeria.orders\n        return MongoOrderRepository(collection)\n\n    @pytest.mark.asyncio\n    async def test_save_and_retrieve_order(self, repository):\n        # Arrange\n        items = [OrderItem(\"Margherita\", \"Large\", 1, Decimal('15.99'))]\n        order = Order(\"customer-123\", items, \"123 Pizza St\")\n\n        # Act\n        await repository.save_async(order)\n        retrieved = await repository.get_by_id_async(order.id)\n\n        # Assert\n        assert retrieved is not None\n        assert retrieved.customer_id == \"customer-123\"\n        assert len(retrieved.items) == 1\n        assert retrieved.items[0].pizza_name == \"Margherita\"\n\n    @pytest.mark.asyncio\n    async def test_find_by_customer(self, repository):\n        # Arrange\n        items = [OrderItem(\"Margherita\", \"Large\", 1, Decimal('15.99'))]\n        order1 = Order(\"customer-123\", items, \"123 Pizza St\")\n        order2 = Order(\"customer-123\", items, \"456 Pizza Ave\")\n        order3 = Order(\"customer-456\", items, \"789 Pizza Blvd\")\n\n        await repository.save_async(order1)\n        await repository.save_async(order2)\n        await repository.save_async(order3)\n\n        # Act\n        customer_orders = await repository.find_by_customer_async(\"customer-123\")\n\n        # Assert\n        assert len(customer_orders) == 2\n        assert all(order.customer_id == \"customer-123\" for order in customer_orders)\n</code></pre>"},{"location":"guides/testing-setup/#end-to-end-testing","title":"\ud83c\udf10 End-to-End Testing","text":""},{"location":"guides/testing-setup/#full-workflow-tests","title":"Full Workflow Tests","text":"<pre><code># tests/e2e/test_pizza_ordering_workflow.py\nimport pytest\nfrom httpx import AsyncClient\nfrom src.main import create_app\n\n@pytest.mark.e2e\nclass TestPizzaOrderingWorkflow:\n    @pytest.fixture\n    async def test_client(self):\n        app = await create_app()\n        async with AsyncClient(app=app, base_url=\"http://test\") as client:\n            yield client\n\n    @pytest.mark.asyncio\n    async def test_complete_order_workflow(self, test_client):\n        # 1. Get menu\n        menu_response = await test_client.get(\"/menu\")\n        assert menu_response.status_code == 200\n        menu = menu_response.json()\n        assert len(menu) &gt; 0\n\n        # 2. Place order\n        order_data = {\n            \"customer_id\": \"customer-123\",\n            \"items\": [\n                {\n                    \"pizza_name\": menu[0][\"name\"],\n                    \"size\": \"Large\",\n                    \"quantity\": 1,\n                    \"price\": menu[0][\"price\"]\n                }\n            ],\n            \"delivery_address\": \"123 Pizza St\"\n        }\n\n        order_response = await test_client.post(\"/orders\", json=order_data)\n        assert order_response.status_code == 201\n        order = order_response.json()\n        order_id = order[\"id\"]\n\n        # 3. Check order status\n        status_response = await test_client.get(f\"/orders/{order_id}\")\n        assert status_response.status_code == 200\n        status_data = status_response.json()\n        assert status_data[\"id\"] == order_id\n        assert status_data[\"status\"] == \"pending\"\n\n        # 4. Get customer order history\n        history_response = await test_client.get(\n            f\"/orders?customer_id=customer-123\"\n        )\n        assert history_response.status_code == 200\n        history = history_response.json()\n        assert len(history) &gt;= 1\n        assert any(o[\"id\"] == order_id for o in history)\n</code></pre>"},{"location":"guides/testing-setup/#test-fixtures-and-factories","title":"\ud83c\udfad Test Fixtures and Factories","text":""},{"location":"guides/testing-setup/#data-factories","title":"Data Factories","text":"<pre><code># tests/factories.py\nfrom faker import Faker\nfrom decimal import Decimal\nfrom src.domain.entities.order import Order, OrderItem\n\nfake = Faker()\n\nclass OrderFactory:\n    @staticmethod\n    def create_order_item(\n        pizza_name: str = None,\n        size: str = \"Large\",\n        quantity: int = 1,\n        price: Decimal = None\n    ) -&gt; OrderItem:\n        return OrderItem(\n            pizza_name=pizza_name or fake.word(),\n            size=size,\n            quantity=quantity,\n            price=price or Decimal(str(fake.pydecimal(left_digits=2, right_digits=2, positive=True)))\n        )\n\n    @staticmethod\n    def create_order(\n        customer_id: str = None,\n        items: list = None,\n        delivery_address: str = None\n    ) -&gt; Order:\n        return Order(\n            customer_id=customer_id or fake.uuid4(),\n            items=items or [OrderFactory.create_order_item()],\n            delivery_address=delivery_address or fake.address()\n        )\n\n# Usage in tests\ndef test_order_with_factory():\n    order = OrderFactory.create_order(\n        customer_id=\"test-customer\",\n        items=[\n            OrderFactory.create_order_item(\"Margherita\", \"Large\", 2, Decimal('15.99'))\n        ]\n    )\n    assert order.customer_id == \"test-customer\"\n</code></pre>"},{"location":"guides/testing-setup/#shared-fixtures","title":"Shared Fixtures","text":"<pre><code># tests/conftest.py\nimport pytest\nfrom unittest.mock import Mock\nfrom src.domain.entities.order import OrderItem\nfrom decimal import Decimal\n\n@pytest.fixture\ndef sample_pizza_items():\n    return [\n        OrderItem(\"Margherita\", \"Large\", 1, Decimal('15.99')),\n        OrderItem(\"Pepperoni\", \"Medium\", 2, Decimal('12.99')),\n        OrderItem(\"Vegetarian\", \"Small\", 1, Decimal('10.99'))\n    ]\n\n@pytest.fixture\ndef mock_order_repository():\n    repository = Mock()\n    repository.save_async = Mock()\n    repository.get_by_id_async = Mock()\n    repository.find_by_customer_async = Mock()\n    return repository\n\n@pytest.fixture\ndef mock_sms_service():\n    service = Mock()\n    service.send_async = Mock()\n    return service\n</code></pre>"},{"location":"guides/testing-setup/#coverage-and-quality","title":"\ud83d\udcca Coverage and Quality","text":""},{"location":"guides/testing-setup/#coverage-configuration","title":"Coverage Configuration","text":"<pre><code># Run tests with coverage\npoetry run pytest --cov=src --cov-report=html --cov-report=term\n\n# Coverage configuration in pyproject.toml\n[tool.coverage.run]\nsource = [\"src\"]\nomit = [\n    \"src/__init__.py\",\n    \"src/main.py\",\n    \"*/tests/*\",\n]\n\n[tool.coverage.report]\nexclude_lines = [\n    \"pragma: no cover\",\n    \"def __repr__\",\n    \"raise AssertionError\",\n    \"raise NotImplementedError\",\n    \"if __name__ == .__main__.:\",\n]\n</code></pre>"},{"location":"guides/testing-setup/#test-execution","title":"\ud83d\ude80 Test Execution","text":""},{"location":"guides/testing-setup/#running-tests","title":"Running Tests","text":"<pre><code># All tests\npoetry run pytest\n\n# Unit tests only\npoetry run pytest tests/unit -m unit\n\n# Integration tests only\npoetry run pytest tests/integration -m integration\n\n# E2E tests only\npoetry run pytest tests/e2e -m e2e\n\n# Specific test file\npoetry run pytest tests/unit/test_order.py -v\n\n# With coverage\npoetry run pytest --cov=src --cov-report=html\n</code></pre>"},{"location":"guides/testing-setup/#continuous-integration","title":"Continuous Integration","text":"<pre><code># .github/workflows/test.yml\nname: Tests\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    services:\n      mongodb:\n        image: mongo:5.0\n        ports:\n          - 27017:27017\n\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v4\n        with:\n          python-version: \"3.9\"\n\n      - name: Install Poetry\n        run: pip install poetry\n\n      - name: Install dependencies\n        run: poetry install\n\n      - name: Run tests\n        run: poetry run pytest --cov=src --cov-report=xml\n\n      - name: Upload coverage\n        uses: codecov/codecov-action@v3\n</code></pre>"},{"location":"guides/testing-setup/#related-guides","title":"\ud83d\udd17 Related Guides","text":"<ul> <li>Project Setup - Initial project configuration</li> <li>API Development - Testing API endpoints</li> <li>Database Integration - Testing data access</li> </ul> <p>This guide establishes comprehensive testing practices that ensure high-quality, maintainable Neuroglia applications. \ud83e\uddea</p>"},{"location":"patterns/","title":"\ud83c\udfaf Architecture Patterns","text":"<p>Architecture patterns form the foundation of maintainable, scalable software systems. The Neuroglia framework implements and promotes proven architectural patterns that support clean code principles, testability, and long-term maintainability.</p>"},{"location":"patterns/#core-architectural-patterns","title":"\ud83c\udfdb\ufe0f Core Architectural Patterns","text":""},{"location":"patterns/#clean-architecture","title":"\ud83c\udfd7\ufe0f Clean Architecture","text":"<p>The foundation pattern that organizes code into layers with clear dependency rules. Demonstrates the four-layer architecture with Mario's Pizzeria as a comprehensive example.</p> <p>Key Concepts:</p> <ul> <li>Domain-driven layer separation</li> <li>Dependency inversion principle</li> <li>Business logic isolation</li> <li>Infrastructure abstraction</li> </ul> <p>What You'll Learn:</p> <ul> <li>Four-layer architecture implementation</li> <li>Dependency flow and injection patterns</li> <li>Domain entity design with business logic</li> <li>Integration layer abstraction</li> </ul>"},{"location":"patterns/#cqrs-command-query-responsibility-segregation","title":"\ud83d\udce1 CQRS (Command Query Responsibility Segregation)","text":"<p>Separates read and write operations for optimal performance and scalability. Demonstrates command handlers for writes and query handlers for optimized reads.</p> <p>Key Concepts:</p> <ul> <li>Command/Query separation</li> <li>Optimized read models</li> <li>Write model integrity</li> <li>Performance optimization</li> </ul> <p>What You'll Learn:</p> <ul> <li>Command and query pattern implementation</li> <li>Handler-based request processing</li> <li>Read model optimization strategies</li> <li>Event integration with CQRS</li> </ul>"},{"location":"patterns/#event-driven-architecture","title":"\ud83d\udd04 Event-Driven Architecture","text":"<p>Implements reactive systems using domain events and event handlers. Shows how to build loosely coupled systems that respond to business events.</p> <p>Key Concepts:</p> <ul> <li>Domain event patterns</li> <li>Event handlers and workflows</li> <li>Asynchronous processing</li> <li>System decoupling</li> </ul> <p>What You'll Learn:</p> <ul> <li>Domain event design and publishing</li> <li>Event handler implementation</li> <li>Kitchen workflow automation</li> <li>CloudEvents integration</li> </ul>"},{"location":"patterns/#repository-pattern","title":"\ud83d\udcbe Repository Pattern","text":"<p>Abstracts data access logic with multiple storage implementations. Demonstrates file-based, MongoDB, and in-memory repositories with consistent interfaces.</p> <p>Key Concepts:</p> <ul> <li>Data access abstraction</li> <li>Storage implementation flexibility</li> <li>Consistent query interfaces</li> <li>Testing with mock repositories</li> </ul> <p>What You'll Learn:</p> <ul> <li>Repository interface design</li> <li>Multiple storage backend implementation</li> <li>Async data access patterns</li> <li>Repository testing strategies</li> </ul>"},{"location":"patterns/#resource-oriented-architecture","title":"\ud83c\udf10 Resource-Oriented Architecture","text":"<p>Resource-oriented design principles for building RESTful APIs and resource-centric applications. Focuses on identifying resources, defining operations, and implementing HTTP-based interactions.</p> <p>Key Concepts:</p> <ul> <li>Resource identification and modeling</li> <li>RESTful API design principles</li> <li>HTTP verb mapping and semantics</li> <li>Resource lifecycle management</li> </ul> <p>What You'll Learn:</p> <ul> <li>Resource-oriented design principles</li> <li>RESTful API architecture patterns</li> <li>HTTP protocol integration</li> <li>Resource state management</li> </ul>"},{"location":"patterns/#watcher-reconciliation-patterns","title":"\ud83d\udc40 Watcher &amp; Reconciliation Patterns","text":"<p>Kubernetes-inspired patterns for watching resource changes and implementing reconciliation loops. Essential for building reactive systems and operators.</p> <p>Key Concepts:</p> <ul> <li>Resource state observation</li> <li>Reconciliation loop patterns</li> <li>Event-driven state management</li> <li>Declarative resource management</li> </ul> <p>What You'll Learn:</p> <ul> <li>Resource watching implementation</li> <li>Reconciliation loop design</li> <li>Event-driven update patterns</li> <li>State synchronization strategies</li> </ul>"},{"location":"patterns/#watcher-reconciliation-execution","title":"\u26a1 Watcher &amp; Reconciliation Execution","text":"<p>Execution engine for watcher and reconciliation patterns with support for error handling, retries, and monitoring.</p> <p>Key Concepts:</p> <ul> <li>Execution orchestration</li> <li>Error handling and recovery</li> <li>Performance monitoring</li> <li>Reliable state persistence</li> </ul> <p>What You'll Learn:</p> <ul> <li>Execution pipeline design</li> <li>Error handling strategies</li> <li>Monitoring and observability</li> <li>Performance optimization</li> </ul>"},{"location":"patterns/#marios-pizzeria-unified-example","title":"\ud83c\udf55 Mario's Pizzeria: Unified Example","text":"<p>All patterns use Mario's Pizzeria as a consistent domain example, showing how patterns work together in a real-world system:</p> <pre><code>graph TB\n    subgraph \"\ud83c\udfd7\ufe0f Clean Architecture Layers\"\n        API[\ud83c\udf10 API Layer&lt;br/&gt;Controllers &amp; DTOs]\n        APP[\ud83d\udcbc Application Layer&lt;br/&gt;Commands &amp; Queries]\n        DOM[\ud83c\udfdb\ufe0f Domain Layer&lt;br/&gt;Entities &amp; Events]\n        INT[\ud83d\udd0c Integration Layer&lt;br/&gt;Repositories &amp; Services]\n    end\n\n    subgraph \"\ud83d\udce1 CQRS Implementation\"\n        CMD[Commands&lt;br/&gt;PlaceOrder, StartCooking]\n        QRY[Queries&lt;br/&gt;GetOrder, GetMenu]\n    end\n\n    subgraph \"\ud83d\udd04 Event-Driven Flow\"\n        EVT[Domain Events&lt;br/&gt;OrderPlaced, OrderReady]\n        HDL[Event Handlers&lt;br/&gt;Kitchen, Notifications]\n    end\n\n    subgraph \"\ud83d\udcbe Data Access\"\n        REPO[Repositories&lt;br/&gt;Order, Menu, Customer]\n        STOR[Storage&lt;br/&gt;File, MongoDB, Memory]\n    end\n\n    API --&gt; APP\n    APP --&gt; DOM\n    APP --&gt; INT\n\n    APP --&gt; CMD\n    APP --&gt; QRY\n\n    DOM --&gt; EVT\n    EVT --&gt; HDL\n\n    INT --&gt; REPO\n    REPO --&gt; STOR\n\n    style API fill:#e3f2fd\n    style APP fill:#f3e5f5\n    style DOM fill:#e8f5e8\n    style INT fill:#fff3e0</code></pre>"},{"location":"patterns/#pattern-integration","title":"\ud83d\ude80 Pattern Integration","text":""},{"location":"patterns/#how-patterns-work-together","title":"How Patterns Work Together","text":"<ol> <li>Clean Architecture provides the structural foundation</li> <li>CQRS organizes application layer responsibilities</li> <li>Event-Driven enables reactive domain workflows</li> <li>Repository abstracts infrastructure concerns</li> <li>Resource-Oriented defines API contract and interaction patterns</li> <li>Watcher &amp; Reconciliation enables reactive resource management</li> </ol>"},{"location":"patterns/#implementation-order","title":"Implementation Order","text":"<pre><code>flowchart LR\n    A[1. Clean Architecture&lt;br/&gt;\ud83c\udfd7\ufe0f Layer Structure] --&gt; B[2. CQRS Patterns&lt;br/&gt;\ud83d\udce1 Commands &amp; Queries]\n    B --&gt; C[3. Event-Driven&lt;br/&gt;\ud83d\udd04 Domain Events]\n    C --&gt; D[4. Repository Pattern&lt;br/&gt;\ud83d\udcbe Data Access]\n    D --&gt; E[5. Resource-Oriented&lt;br/&gt;\ud83c\udf10 API Design]\n    E --&gt; F[6. Watcher Patterns&lt;br/&gt;\ud83d\udc40 Reactive Management]\n\n    style A fill:#e8f5e8\n    style B fill:#e3f2fd\n    style C fill:#fff3e0\n    style D fill:#f3e5f5\n    style E fill:#e1f5fe\n    style F fill:#fce4ec</code></pre>"},{"location":"patterns/#business-domain-examples","title":"\ud83c\udfaf Business Domain Examples","text":"<p>Each pattern demonstrates practical implementation through Mario's Pizzeria scenarios:</p> <ul> <li>Order Processing: Complete workflow from placement to delivery</li> <li>Menu Management: Product catalog with pricing and availability</li> <li>Kitchen Operations: Queue management and cooking workflows</li> <li>Customer Communications: Event-driven notifications</li> <li>Payment Processing: External service integration patterns</li> </ul>"},{"location":"patterns/#testing-strategies","title":"\ud83e\uddea Testing Strategies","text":"<p>All patterns include comprehensive testing approaches:</p> <ul> <li>Unit Testing: Isolated component testing with mocks</li> <li>Integration Testing: Cross-layer interaction testing</li> <li>End-to-End Testing: Complete workflow validation</li> <li>Performance Testing: Scalability and response time validation</li> </ul>"},{"location":"patterns/#pattern-learning-path","title":"\ud83d\udcda Pattern Learning Path","text":""},{"location":"patterns/#beginner-path","title":"Beginner Path","text":"<ol> <li>Start with Clean Architecture fundamentals</li> <li>Understand layer separation and dependency rules</li> <li>Implement basic CRUD operations</li> </ol>"},{"location":"patterns/#intermediate-path","title":"Intermediate Path","text":"<ol> <li>Add CQRS for read/write separation</li> <li>Implement Repository Pattern for data access</li> <li>Create comprehensive test coverage</li> </ol>"},{"location":"patterns/#advanced-path","title":"Advanced Path","text":"<ol> <li>Integrate Event-Driven Architecture</li> <li>Build reactive workflows and sagas</li> <li>Implement complex business scenarios</li> </ol>"},{"location":"patterns/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\ud83d\ude80 Framework Features - Implementation-specific features</li> <li>\ud83d\udcd6 Implementation Guides - Step-by-step tutorials</li> <li>\ud83c\udf55 Mario's Pizzeria - Complete system example</li> <li>\ud83d\udcbc Sample Applications - Production-ready examples</li> </ul> <p>These patterns form the architectural foundation for building maintainable, testable, and scalable applications. Each pattern page includes detailed code examples, Mermaid diagrams, and practical implementation guidance using the Mario's Pizzeria domain.</p>"},{"location":"patterns/clean-architecture/","title":"\ud83c\udfd7\ufe0f Clean Architecture Pattern","text":"<p>\ud83d\udea7 Under Construction</p> <p>This page is currently being developed with comprehensive examples from Mario's Pizzeria. More detailed implementations and code samples are being added.</p> <p>The Clean Architecture pattern enforces a layered approach where dependencies only flow inward, ensuring testability, maintainability, and independence from external concerns.</p>"},{"location":"patterns/clean-architecture/#understanding-clean-architecture","title":"\ud83c\udf93 Understanding Clean Architecture","text":"<p>Before diving into code, it's helpful to understand the architectural principles that guide Neuroglia:</p>"},{"location":"patterns/clean-architecture/#the-dependency-rule","title":"The Dependency Rule","text":"<pre><code>graph TD\n    A[\ud83c\udf10 API Layer&lt;br/&gt;Controllers, DTOs] --&gt; B[\ud83d\udcbc Application Layer&lt;br/&gt;Commands, Queries, Handlers]\n    B --&gt; C[\ud83c\udfdb\ufe0f Domain Layer&lt;br/&gt;Entities, Business Rules]\n    D[\ud83d\udd0c Integration Layer&lt;br/&gt;Repositories, External APIs] --&gt; C\n\n    style C fill:#e1f5fe\n    style B fill:#f3e5f5\n    style A fill:#e8f5e8\n    style D fill:#fff3e0</code></pre> <p>Key principle: Inner layers never depend on outer layers. This enables:</p> <ul> <li>Testability - Easy to mock external dependencies</li> <li>Flexibility - Swap implementations without affecting business logic</li> <li>Maintainability - Changes in infrastructure don't break business rules</li> <li>Domain Focus - Business logic stays pure and framework-agnostic</li> </ul>"},{"location":"patterns/clean-architecture/#cqrs-in-practice","title":"CQRS in Practice","text":"<pre><code>graph LR\n    A[Client Request] --&gt; B{Command or Query?}\n    B --&gt;|Write Operation| C[Command Handler]\n    B --&gt;|Read Operation| D[Query Handler]\n    C --&gt; E[Domain Logic]\n    E --&gt; F[Repository]\n    D --&gt; G[Read Model]\n\n    style C fill:#ffcdd2\n    style D fill:#c8e6c9\n    style E fill:#e1f5fe</code></pre> <p>Commands (Write): Create, Update, Delete operations that change system state Queries (Read): Retrieve operations that return data without side effects</p> <p>This separation enables:</p> <ul> <li>Performance Optimization - Different models for reads vs writes</li> <li>Scalability - Scale read and write operations independently</li> <li>Clarity - Clear intent whether operation changes state</li> <li>Event Sourcing - Natural fit for event-driven architectures</li> </ul>"},{"location":"patterns/clean-architecture/#overview","title":"\ud83c\udfaf Overview","text":"<p>Clean Architecture organizes code into four distinct layers, with the Mario's Pizzeria system serving as our primary example of how this pattern enables scalable, maintainable applications.</p> <pre><code>C4Container\n    title Clean Architecture - Mario's Pizzeria System\n\n    Container_Boundary(api, \"\ud83c\udf10 API Layer\") {\n        Container(orders_controller, \"Orders Controller\", \"FastAPI\", \"REST endpoints for pizza orders\")\n        Container(menu_controller, \"Menu Controller\", \"FastAPI\", \"Menu management and retrieval\")\n        Container(kitchen_controller, \"Kitchen Controller\", \"FastAPI\", \"Kitchen workflow management\")\n    }\n\n    Container_Boundary(app, \"\ud83d\udcbc Application Layer\") {\n        Container(mediator, \"Mediator\", \"CQRS\", \"Command/Query routing\")\n        Container(handlers, \"Command/Query Handlers\", \"Business Logic\", \"Order processing, menu queries\")\n        Container(pipeline, \"Pipeline Behaviors\", \"Cross-cutting\", \"Validation, logging, caching\")\n    }\n\n    Container_Boundary(domain, \"\ud83c\udfdb\ufe0f Domain Layer\") {\n        Container(entities, \"Pizza Entities\", \"Domain Models\", \"Order, Pizza, Customer entities\")\n        Container(events, \"Domain Events\", \"Business Events\", \"OrderPlaced, PizzaReady events\")\n        Container(rules, \"Business Rules\", \"Domain Logic\", \"Pricing, validation rules\")\n    }\n\n    Container_Boundary(integration, \"\ud83d\udd0c Integration Layer\") {\n        Container(repos, \"Repositories\", \"Data Access\", \"Order, Menu data persistence\")\n        Container(external, \"External Services\", \"Third-party\", \"Payment, SMS notifications\")\n        Container(storage, \"Data Storage\", \"Persistence\", \"MongoDB, File System\")\n    }\n\n    Rel(orders_controller, mediator, \"sends commands/queries\")\n    Rel(menu_controller, mediator, \"sends queries\")\n    Rel(kitchen_controller, mediator, \"sends commands\")\n\n    Rel(mediator, handlers, \"routes to\")\n    Rel(handlers, entities, \"uses\")\n    Rel(handlers, events, \"publishes\")\n\n    Rel(handlers, repos, \"persists via\")\n    Rel(repos, storage, \"stores in\")\n    Rel(handlers, external, \"integrates with\")</code></pre>"},{"location":"patterns/clean-architecture/#benefits","title":"\u2705 Benefits","text":""},{"location":"patterns/clean-architecture/#1-testability","title":"1. Testability","text":"<p>Each layer can be tested independently using mocks and stubs:</p> <pre><code># Testing Order Handler without database dependencies\nclass TestPlaceOrderHandler:\n    def setup_method(self):\n        self.mock_repository = Mock(spec=OrderRepository)\n        self.mock_payment = Mock(spec=PaymentService)\n        self.handler = PlaceOrderHandler(self.mock_repository, self.mock_payment)\n\n    async def test_place_order_success(self):\n        # Arrange\n        command = PlaceOrderCommand(customer_id=\"123\", pizzas=[\"margherita\"])\n\n        # Act\n        result = await self.handler.handle_async(command)\n\n        # Assert\n        assert result.is_success\n        self.mock_repository.save_async.assert_called_once()\n</code></pre>"},{"location":"patterns/clean-architecture/#2-independence","title":"2. Independence","text":"<p>Business logic in the domain layer is completely independent of frameworks, databases, and external services.</p>"},{"location":"patterns/clean-architecture/#3-maintainability","title":"3. Maintainability","text":"<p>Changes to external systems (databases, APIs) don't affect business logic.</p>"},{"location":"patterns/clean-architecture/#data-flow","title":"\ud83d\udd04 Data Flow","text":"<p>The pizza ordering workflow demonstrates clean architecture data flow:</p> <pre><code>sequenceDiagram\n    participant Customer\n    participant API as OrdersController\n    participant Med as Mediator\n    participant Handler as PlaceOrderHandler\n    participant Domain as Order Entity\n    participant Repo as OrderRepository\n    participant DB as MongoDB\n\n    Customer-&gt;&gt;+API: POST /orders (pizza order)\n    Note over API: \ud83c\udf10 API Layer - HTTP endpoint\n\n    API-&gt;&gt;+Med: Execute PlaceOrderCommand\n    Note over Med: \ud83d\udcbc Application Layer - CQRS routing\n\n    Med-&gt;&gt;+Handler: Handle command\n    Note over Handler: \ud83d\udcbc Application Layer - Business workflow\n\n    Handler-&gt;&gt;+Domain: Create Order entity\n    Note over Domain: \ud83c\udfdb\ufe0f Domain Layer - Business rules\n    Domain--&gt;&gt;-Handler: Order with domain events\n\n    Handler-&gt;&gt;+Repo: Save order\n    Note over Repo: \ud83d\udd0c Integration Layer - Data access\n    Repo-&gt;&gt;+DB: Insert document\n    Note over DB: \ud83d\udd0c Integration Layer - Persistence\n    DB--&gt;&gt;-Repo: Success\n    Repo--&gt;&gt;-Handler: Order saved\n\n    Handler--&gt;&gt;-Med: OrderDto result\n    Med--&gt;&gt;-API: Success response\n    API--&gt;&gt;-Customer: 201 Created + OrderDto</code></pre>"},{"location":"patterns/clean-architecture/#use-cases","title":"\ud83c\udfaf Use Cases","text":"<p>Clean Architecture is ideal for:</p> <ul> <li>Complex Business Logic: When domain rules are intricate (pricing, promotions, kitchen workflows)</li> <li>Multiple Interfaces: Supporting web APIs, mobile apps, and admin panels</li> <li>Long-term Maintenance: Systems that need to evolve over time</li> <li>Team Collaboration: Clear boundaries enable parallel development</li> </ul>"},{"location":"patterns/clean-architecture/#implementation-in-marios-pizzeria","title":"\ud83c\udf55 Implementation in Mario's Pizzeria","text":""},{"location":"patterns/clean-architecture/#domain-layer-core-business","title":"Domain Layer (Core Business)","text":"<pre><code># domain/entities/order.py\nclass Order(Entity):\n    def __init__(self, customer_id: str, items: List[OrderItem]):\n        super().__init__()\n        self.customer_id = customer_id\n        self.items = items\n        self.status = OrderStatus.PENDING\n        self.total = self._calculate_total()\n\n        # Domain event for business workflow\n        self.raise_event(OrderPlacedEvent(\n            order_id=self.id,\n            customer_id=customer_id,\n            total=self.total\n        ))\n\n    def _calculate_total(self) -&gt; Decimal:\n        \"\"\"Business rule: Calculate order total with tax\"\"\"\n        subtotal = sum(item.price for item in self.items)\n        tax = subtotal * Decimal('0.08')  # 8% tax\n        return subtotal + tax\n</code></pre>"},{"location":"patterns/clean-architecture/#application-layer-use-cases","title":"Application Layer (Use Cases)","text":"<pre><code># application/handlers/place_order_handler.py\nclass PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    def __init__(self,\n                 order_repository: OrderRepository,\n                 payment_service: PaymentService,\n                 mapper: Mapper):\n        self._repository = order_repository\n        self._payment = payment_service\n        self._mapper = mapper\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        # Create domain entity (business logic)\n        order = Order(command.customer_id, command.items)\n\n        # Process payment (external integration)\n        payment_result = await self._payment.process_async(order.total)\n        if not payment_result.success:\n            return self.bad_request(\"Payment failed\")\n\n        # Persist order (data access)\n        await self._repository.save_async(order)\n\n        # Return result\n        dto = self._mapper.map(order, OrderDto)\n        return self.created(dto)\n</code></pre>"},{"location":"patterns/clean-architecture/#api-layer-interface","title":"API Layer (Interface)","text":"<pre><code># api/controllers/orders_controller.py\nclass OrdersController(ControllerBase):\n    @post(\"/\", response_model=OrderDto, status_code=201)\n    async def place_order(self, request: PlaceOrderRequest) -&gt; OrderDto:\n        command = self.mapper.map(request, PlaceOrderCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"patterns/clean-architecture/#integration-layer-external-concerns","title":"Integration Layer (External Concerns)","text":"<pre><code># integration/repositories/mongo_order_repository.py\nclass MongoOrderRepository(Repository[Order, str]):\n    def __init__(self, collection: Collection):\n        self._collection = collection\n\n    async def save_async(self, order: Order) -&gt; None:\n        document = {\n            \"_id\": order.id,\n            \"customer_id\": order.customer_id,\n            \"items\": [{\"name\": item.name, \"price\": float(item.price)}\n                     for item in order.items],\n            \"total\": float(order.total),\n            \"status\": order.status.value\n        }\n        await self._collection.insert_one(document)\n</code></pre>"},{"location":"patterns/clean-architecture/#related-patterns","title":"\ud83d\udd17 Related Patterns","text":"<ul> <li>CQRS Pattern - Separates commands and queries within the application layer</li> <li>Event-Driven Pattern - Uses domain events for decoupled communication</li> <li>Repository Pattern - Abstracts data access in the integration layer</li> </ul> <p>This pattern guide demonstrates Clean Architecture using Mario's Pizzeria as a practical example. The four-layer approach shown here scales from simple applications to complex enterprise systems. \ud83c\udfd7\ufe0f</p>"},{"location":"patterns/cqrs/","title":"\ud83c\udfaf CQRS Pattern","text":"<p>\ud83d\udea7 Under Construction</p> <p>This page is currently being developed with comprehensive examples from Mario's Pizzeria. More detailed implementations and code samples are being added.</p> <p>Command Query Responsibility Segregation (CQRS) separates read and write operations into distinct models, enabling optimized data access patterns and scalable architecture.</p>"},{"location":"patterns/cqrs/#overview","title":"\ud83c\udfaf Overview","text":"<p>CQRS divides your application's operations into two distinct paths: Commands for writes (state changes) and Queries for reads (data retrieval). Mario's Pizzeria demonstrates this pattern through its order management and menu systems.</p> <pre><code>flowchart TD\n    Client[Customer/Staff]\n\n    subgraph \"\ud83c\udfaf CQRS Separation\"\n        subgraph Commands[\"\ud83d\udcdd Write Side (Commands)\"]\n            PlaceOrder[PlaceOrderCommand]\n            UpdateMenu[UpdateMenuCommand]\n            ProcessPayment[ProcessPaymentCommand]\n        end\n\n        subgraph Queries[\"\ud83d\udcd6 Read Side (Queries)\"]\n            GetMenu[GetMenuQuery]\n            GetOrder[GetOrderByIdQuery]\n            GetOrderHistory[GetOrderHistoryQuery]\n        end\n    end\n\n    subgraph Mediator[\"\ud83c\udfad Mediator\"]\n        CommandHandlers[Command Handlers]\n        QueryHandlers[Query Handlers]\n    end\n\n    subgraph Storage[\"\ud83d\udcbe Data Storage\"]\n        WriteDB[(Write Database&lt;br/&gt;MongoDB)]\n        ReadDB[(Read Models&lt;br/&gt;Optimized Views)]\n        EventStore[(Event Store&lt;br/&gt;Order History)]\n    end\n\n    Client --&gt;|\"\ud83c\udf55 Place Order\"| PlaceOrder\n    Client --&gt;|\"\ud83d\udccb Get Menu\"| GetMenu\n    Client --&gt;|\"\ud83d\udcca Order Status\"| GetOrder\n\n    PlaceOrder --&gt; CommandHandlers\n    GetMenu --&gt; QueryHandlers\n    GetOrder --&gt; QueryHandlers\n\n    CommandHandlers --&gt;|\"\ud83d\udcbe Persist\"| WriteDB\n    CommandHandlers --&gt;|\"\ud83d\udce1 Events\"| EventStore\n    QueryHandlers --&gt;|\"\ud83d\udd0d Read\"| ReadDB\n\n    WriteDB -.-&gt;|\"\ud83d\udd04 Sync\"| ReadDB\n    EventStore -.-&gt;|\"\ud83d\udcc8 Project\"| ReadDB</code></pre>"},{"location":"patterns/cqrs/#benefits","title":"\u2705 Benefits","text":""},{"location":"patterns/cqrs/#1-optimized-performance","title":"1. Optimized Performance","text":"<p>Different models for reads and writes enable performance optimization:</p> <pre><code># Write Model - Normalized for consistency\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    customer_id: str\n    items: List[OrderItemDto]\n    delivery_address: AddressDto\n    payment_method: PaymentMethodDto\n\n# Read Model - Denormalized for speed\nclass OrderSummaryDto:\n    order_id: str\n    customer_name: str  # Denormalized\n    total_amount: Decimal\n    status: str\n    estimated_delivery: datetime\n    items_count: int  # Pre-calculated\n</code></pre>"},{"location":"patterns/cqrs/#2-independent-scaling","title":"2. Independent Scaling","text":"<p>Read and write sides can scale independently based on usage patterns:</p> <pre><code># Heavy read operations don't impact write performance\nclass GetPopularPizzasQuery(Query[List[PopularPizzaDto]]):\n    time_period: str = \"last_30_days\"\n    limit: int = 10\n\n# Complex writes don't slow down simple reads\nclass ProcessOrderWorkflowCommand(Command[OperationResult]):\n    order_id: str\n    # Complex business logic with multiple validations\n</code></pre>"},{"location":"patterns/cqrs/#3-clear-separation-of-concerns","title":"3. Clear Separation of Concerns","text":"<p>Commands handle business logic while queries focus on data presentation.</p>"},{"location":"patterns/cqrs/#data-flow","title":"\ud83d\udd04 Data Flow","text":"<p>The pizza ordering process demonstrates CQRS data flow:</p> <pre><code>sequenceDiagram\n    participant Customer\n    participant API as API Controller\n    participant Med as Mediator\n    participant CH as Command Handler\n    participant QH as Query Handler\n    participant WDB as Write DB\n    participant RDB as Read DB\n    participant ES as Event Store\n\n    Note over Customer,ES: \ud83d\udcdd Command Flow (Write)\n    Customer-&gt;&gt;+API: Place Pizza Order\n    API-&gt;&gt;+Med: PlaceOrderCommand\n    Med-&gt;&gt;+CH: Route to handler\n\n    CH-&gt;&gt;CH: Validate business rules\n    CH-&gt;&gt;+WDB: Save normalized order\n    WDB--&gt;&gt;-CH: Order persisted\n\n    CH-&gt;&gt;+ES: Store OrderPlacedEvent\n    ES--&gt;&gt;-CH: Event saved\n\n    CH--&gt;&gt;-Med: Success result\n    Med--&gt;&gt;-API: OrderDto\n    API--&gt;&gt;-Customer: 201 Created\n\n    Note over Customer,ES: \ud83d\udcd6 Query Flow (Read)\n    Customer-&gt;&gt;+API: Get Order Status\n    API-&gt;&gt;+Med: GetOrderByIdQuery\n    Med-&gt;&gt;+QH: Route to handler\n\n    QH-&gt;&gt;+RDB: Read denormalized view\n    RDB--&gt;&gt;-QH: Order summary\n\n    QH--&gt;&gt;-Med: OrderSummaryDto\n    Med--&gt;&gt;-API: Result\n    API--&gt;&gt;-Customer: 200 OK\n\n    Note over WDB,RDB: \ud83d\udd04 Background Sync\n    ES-&gt;&gt;RDB: Project events to read models\n    WDB-&gt;&gt;RDB: Sync latest changes</code></pre>"},{"location":"patterns/cqrs/#use-cases","title":"\ud83c\udfaf Use Cases","text":"<p>CQRS is particularly effective for:</p> <ul> <li>High-Traffic Applications: Different read/write performance requirements</li> <li>Complex Business Logic: Commands handle intricate workflows</li> <li>Reporting Systems: Optimized read models for analytics</li> <li>Event-Driven Systems: Natural fit with event sourcing</li> </ul>"},{"location":"patterns/cqrs/#implementation-in-marios-pizzeria","title":"\ud83c\udf55 Implementation in Mario's Pizzeria","text":""},{"location":"patterns/cqrs/#commands-write-operations","title":"Commands (Write Operations)","text":"<pre><code># Command: Place a pizza order\n@dataclass\nclass PlaceOrderCommand(Command[OperationResult[OrderDto]]):\n    customer_id: str\n    pizzas: List[PizzaSelectionDto]\n    delivery_address: str\n    payment_method: str\n    special_instructions: Optional[str] = None\n\nclass PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    def __init__(self,\n                 order_repository: OrderRepository,\n                 payment_service: PaymentService,\n                 inventory_service: InventoryService):\n        self._order_repo = order_repository\n        self._payment = payment_service\n        self._inventory = inventory_service\n\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        try:\n            # 1. Validate business rules\n            if not await self._inventory.check_availability(command.pizzas):\n                return self.bad_request(\"Some pizzas are not available\")\n\n            # 2. Create domain entity\n            order = Order.create(\n                customer_id=command.customer_id,\n                pizzas=command.pizzas,\n                delivery_address=command.delivery_address\n            )\n\n            # 3. Process payment\n            payment_result = await self._payment.charge_async(\n                order.total, command.payment_method\n            )\n            if not payment_result.success:\n                return self.bad_request(\"Payment failed\")\n\n            # 4. Persist order\n            await self._order_repo.save_async(order)\n\n            # 5. Return result\n            dto = self.mapper.map(order, OrderDto)\n            return self.created(dto)\n\n        except Exception as ex:\n            return self.internal_server_error(f\"Order placement failed: {str(ex)}\")\n</code></pre>"},{"location":"patterns/cqrs/#queries-read-operations","title":"Queries (Read Operations)","text":"<pre><code># Query: Get menu with pricing\n@dataclass\nclass GetMenuQuery(Query[List[MenuItemDto]]):\n    category: Optional[str] = None\n    include_unavailable: bool = False\n\nclass GetMenuHandler(QueryHandler[GetMenuQuery, List[MenuItemDto]]):\n    def __init__(self, menu_read_repository: MenuReadRepository):\n        self._menu_repo = menu_read_repository\n\n    async def handle_async(self, query: GetMenuQuery) -&gt; List[MenuItemDto]:\n        # Optimized read from denormalized menu view\n        menu_items = await self._menu_repo.get_menu_items_async(\n            category=query.category,\n            include_unavailable=query.include_unavailable\n        )\n\n        return [self.mapper.map(item, MenuItemDto) for item in menu_items]\n\n# Query: Get order history with analytics\n@dataclass\nclass GetOrderHistoryQuery(Query[OrderHistoryDto]):\n    customer_id: str\n    page: int = 1\n    page_size: int = 10\n\nclass GetOrderHistoryHandler(QueryHandler[GetOrderHistoryQuery, OrderHistoryDto]):\n    async def handle_async(self, query: GetOrderHistoryQuery) -&gt; OrderHistoryDto:\n        # Read from optimized history view with pre-calculated stats\n        history = await self._order_read_repo.get_customer_history_async(\n            customer_id=query.customer_id,\n            page=query.page,\n            page_size=query.page_size\n        )\n\n        return OrderHistoryDto(\n            orders=history.orders,\n            total_orders=history.total_count,\n            total_spent=history.lifetime_value,  # Pre-calculated\n            favorite_pizzas=history.top_pizzas,  # Pre-calculated\n            page=query.page,\n            page_size=query.page_size\n        )\n</code></pre>"},{"location":"patterns/cqrs/#controller-integration","title":"Controller Integration","text":"<pre><code># Controllers use mediator to route commands and queries\nclass OrdersController(ControllerBase):\n\n    @post(\"/\", response_model=OrderDto, status_code=201)\n    async def place_order(self, request: PlaceOrderRequest) -&gt; OrderDto:\n        # Route to command handler\n        command = self.mapper.map(request, PlaceOrderCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @get(\"/{order_id}\", response_model=OrderDto)\n    async def get_order(self, order_id: str) -&gt; OrderDto:\n        # Route to query handler\n        query = GetOrderByIdQuery(order_id=order_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/\", response_model=List[OrderSummaryDto])\n    async def get_orders(self,\n                        customer_id: Optional[str] = None,\n                        status: Optional[str] = None) -&gt; List[OrderSummaryDto]:\n        # Route to query handler with filters\n        query = GetOrdersQuery(customer_id=customer_id, status=status)\n        result = await self.mediator.execute_async(query)\n        return result\n</code></pre>"},{"location":"patterns/cqrs/#read-model-optimization","title":"Read Model Optimization","text":"<pre><code># Optimized read models for different use cases\nclass OrderSummaryDto:\n    \"\"\"Lightweight order summary for lists\"\"\"\n    order_id: str\n    customer_name: str  # Denormalized\n    total: Decimal\n    status: OrderStatus\n    order_date: datetime\n    estimated_delivery: datetime\n\nclass OrderDetailDto:\n    \"\"\"Complete order details for single order view\"\"\"\n    order_id: str\n    customer: CustomerDto  # Full customer details\n    items: List[OrderItemDetailDto]  # Expanded item details\n    payment: PaymentDetailDto\n    delivery: DeliveryDetailDto\n    timeline: List[OrderEventDto]  # Order history\n    total_breakdown: OrderTotalDto  # Tax, discounts, etc.\n</code></pre>"},{"location":"patterns/cqrs/#testing-cqrs","title":"\ud83e\uddea Testing CQRS","text":"<pre><code># Test commands and queries separately\nclass TestPlaceOrderCommand:\n    async def test_place_order_success(self):\n        # Arrange\n        handler = PlaceOrderHandler(mock_repo, mock_payment, mock_inventory)\n        command = PlaceOrderCommand(\n            customer_id=\"123\",\n            pizzas=[PizzaSelectionDto(name=\"Margherita\", size=\"Large\")]\n        )\n\n        # Act\n        result = await handler.handle_async(command)\n\n        # Assert\n        assert result.is_success\n        mock_repo.save_async.assert_called_once()\n\nclass TestGetMenuQuery:\n    async def test_get_menu_filters_by_category(self):\n        # Arrange\n        handler = GetMenuHandler(mock_read_repo)\n        query = GetMenuQuery(category=\"Pizza\")\n\n        # Act\n        result = await handler.handle_async(query)\n\n        # Assert\n        assert len(result) &gt; 0\n        assert all(item.category == \"Pizza\" for item in result)\n</code></pre>"},{"location":"patterns/cqrs/#related-patterns","title":"\ud83d\udd17 Related Patterns","text":"<ul> <li>Clean Architecture - CQRS fits naturally in the application layer</li> <li>Event-Driven Pattern - Commands often produce events</li> <li>Repository Pattern - Separate repositories for reads and writes</li> </ul> <p>This pattern guide demonstrates CQRS using Mario's Pizzeria's order and menu management systems. The separation of commands and queries enables optimized, scalable data access patterns. \ud83c\udfaf</p>"},{"location":"patterns/event-driven/","title":"\ud83d\udce1 Event-Driven Architecture Pattern","text":"<p>\ud83d\udea7 Under Construction</p> <p>This page is currently being developed with comprehensive examples from Mario's Pizzeria. More detailed implementations and code samples are being added.</p> <p>Event-Driven Architecture uses events to communicate between decoupled components, enabling loose coupling, scalability, and reactive system behavior.</p>"},{"location":"patterns/event-driven/#overview","title":"\ud83c\udfaf Overview","text":"<p>Event-Driven Architecture (EDA) promotes loose coupling through asynchronous event communication. Mario's Pizzeria demonstrates this pattern through domain events that coordinate kitchen operations, customer notifications, and order tracking.</p> <pre><code>flowchart TD\n    subgraph \"\ud83c\udf55 Mario's Pizzeria Event Flow\"\n        Customer[Customer]\n\n        subgraph Domain[\"\ud83c\udfdb\ufe0f Domain Events\"]\n            OrderPlaced[OrderPlacedEvent]\n            PaymentProcessed[PaymentProcessedEvent]\n            OrderCooking[OrderCookingStartedEvent]\n            OrderReady[OrderReadyEvent]\n            OrderDelivered[OrderDeliveredEvent]\n        end\n\n        subgraph Handlers[\"\ud83d\udce1 Event Handlers\"]\n            KitchenHandler[Kitchen Workflow Handler]\n            NotificationHandler[SMS Notification Handler]\n            InventoryHandler[Inventory Update Handler]\n            AnalyticsHandler[Analytics Handler]\n            EmailHandler[Email Confirmation Handler]\n        end\n\n        subgraph External[\"\ud83d\udd0c External Systems\"]\n            Kitchen[Kitchen Display]\n            SMS[SMS Service]\n            Email[Email Service]\n            Analytics[Analytics DB]\n            Inventory[Inventory System]\n        end\n    end\n\n    Customer --&gt;|\"Place Order\"| OrderPlaced\n\n    OrderPlaced --&gt; KitchenHandler\n    OrderPlaced --&gt; NotificationHandler\n    OrderPlaced --&gt; InventoryHandler\n    OrderPlaced --&gt; EmailHandler\n\n    KitchenHandler --&gt;|\"Start Cooking\"| OrderCooking\n    KitchenHandler --&gt; Kitchen\n\n    OrderCooking --&gt; AnalyticsHandler\n\n    Kitchen --&gt;|\"Pizza Ready\"| OrderReady\n    OrderReady --&gt; NotificationHandler\n    OrderReady --&gt; AnalyticsHandler\n\n    NotificationHandler --&gt; SMS\n    EmailHandler --&gt; Email\n    InventoryHandler --&gt; Inventory\n    AnalyticsHandler --&gt; Analytics\n\n    OrderReady --&gt;|\"Out for Delivery\"| OrderDelivered</code></pre>"},{"location":"patterns/event-driven/#benefits","title":"\u2705 Benefits","text":""},{"location":"patterns/event-driven/#1-loose-coupling","title":"1. Loose Coupling","text":"<p>Components communicate through events without direct dependencies:</p> <pre><code># Order placement doesn't know about kitchen or notifications\nclass PlaceOrderHandler(CommandHandler[PlaceOrderCommand, OperationResult[OrderDto]]):\n    async def handle_async(self, command: PlaceOrderCommand) -&gt; OperationResult[OrderDto]:\n        order = Order.create(command.customer_id, command.items)\n        await self._repository.save_async(order)\n\n        # Domain entity raises event - handler doesn't know who listens\n        # OrderPlacedEvent is automatically published by the framework\n\n        return self.created(self.mapper.map(order, OrderDto))\n\n# Multiple handlers can respond to events independently\nclass KitchenWorkflowHandler(EventHandler[OrderPlacedEvent]):\n    async def handle_async(self, event: OrderPlacedEvent):\n        await self._kitchen_service.add_to_queue_async(event.order_id)\n\nclass CustomerNotificationHandler(EventHandler[OrderPlacedEvent]):\n    async def handle_async(self, event: OrderPlacedEvent):\n        await self._sms_service.send_confirmation_async(\n            event.customer_phone, event.order_id\n        )\n</code></pre>"},{"location":"patterns/event-driven/#2-scalability","title":"2. Scalability","text":"<p>Event handlers can be scaled independently based on load:</p> <pre><code># High-volume analytics can be processed separately\nclass OrderAnalyticsHandler(EventHandler[OrderPlacedEvent]):\n    async def handle_async(self, event: OrderPlacedEvent):\n        # This can be processed in background/separate service\n        analytics_data = AnalyticsEvent(\n            event_type=\"order_placed\",\n            customer_id=event.customer_id,\n            order_value=event.total_amount,\n            timestamp=event.occurred_at\n        )\n        await self._analytics_service.track_async(analytics_data)\n</code></pre>"},{"location":"patterns/event-driven/#3-resilience","title":"3. Resilience","text":"<p>Failed event handlers don't affect the main workflow:</p> <pre><code># If SMS fails, order processing continues\nclass ResilientNotificationHandler(EventHandler[OrderReadyEvent]):\n    async def handle_async(self, event: OrderReadyEvent):\n        try:\n            await self._sms_service.notify_customer_async(\n                event.customer_phone,\n                f\"Your order #{event.order_id} is ready!\"\n            )\n        except Exception as ex:\n            # Log error but don't fail the entire workflow\n            self._logger.error(f\"SMS notification failed: {ex}\")\n            # Could queue for retry or use alternative notification\n</code></pre>"},{"location":"patterns/event-driven/#data-flow","title":"\ud83d\udd04 Data Flow","text":"<p>The pizza preparation workflow demonstrates event-driven data flow:</p> <pre><code>sequenceDiagram\n    participant Customer\n    participant OrderAPI\n    participant OrderHandler\n    participant EventBus\n    participant KitchenHandler\n    participant NotificationHandler\n    participant Kitchen\n    participant SMS\n\n    Customer-&gt;&gt;+OrderAPI: Place pizza order\n    OrderAPI-&gt;&gt;+OrderHandler: Handle PlaceOrderCommand\n\n    OrderHandler-&gt;&gt;OrderHandler: Create Order entity\n    Note over OrderHandler: Order.raise_event(OrderPlacedEvent)\n\n    OrderHandler-&gt;&gt;+EventBus: Publish OrderPlacedEvent\n    EventBus-&gt;&gt;KitchenHandler: Async delivery\n    EventBus-&gt;&gt;NotificationHandler: Async delivery\n    EventBus--&gt;&gt;-OrderHandler: Events published\n\n    OrderHandler--&gt;&gt;-OrderAPI: Order created successfully\n    OrderAPI--&gt;&gt;-Customer: 201 Created\n\n    Note over Customer,SMS: Parallel Event Processing\n\n    par Kitchen Workflow\n        KitchenHandler-&gt;&gt;+Kitchen: Add order to queue\n        Kitchen--&gt;&gt;-KitchenHandler: Order queued\n\n        Kitchen-&gt;&gt;Kitchen: Start cooking\n        Kitchen-&gt;&gt;+EventBus: Publish OrderCookingStartedEvent\n        EventBus--&gt;&gt;-Kitchen: Event published\n\n        Kitchen-&gt;&gt;Kitchen: Pizza ready\n        Kitchen-&gt;&gt;+EventBus: Publish OrderReadyEvent\n        EventBus-&gt;&gt;NotificationHandler: Deliver event\n        EventBus--&gt;&gt;-Kitchen: Event published\n\n    and Customer Notifications\n        NotificationHandler-&gt;&gt;+SMS: Send order confirmation\n        SMS--&gt;&gt;-NotificationHandler: SMS sent\n\n        Note over NotificationHandler: Wait for OrderReadyEvent\n\n        NotificationHandler-&gt;&gt;+SMS: Send \"order ready\" notification\n        SMS--&gt;&gt;-NotificationHandler: SMS sent\n        SMS-&gt;&gt;Customer: \"Your pizza is ready!\"\n    end</code></pre>"},{"location":"patterns/event-driven/#use-cases","title":"\ud83c\udfaf Use Cases","text":"<p>Event-Driven Architecture is ideal for:</p> <ul> <li>Microservices: Decoupled service communication</li> <li>Real-time Systems: Immediate response to state changes</li> <li>Complex Workflows: Multi-step processes with branching logic</li> <li>Integration: Connecting disparate systems</li> </ul>"},{"location":"patterns/event-driven/#implementation-in-marios-pizzeria","title":"\ud83c\udf55 Implementation in Mario's Pizzeria","text":""},{"location":"patterns/event-driven/#domain-events","title":"Domain Events","text":"<pre><code># Domain events represent important business occurrences\n@dataclass\nclass OrderPlacedEvent(DomainEvent):\n    order_id: str\n    customer_id: str\n    customer_phone: str\n    items: List[OrderItemDto]\n    total_amount: Decimal\n    delivery_address: str\n    estimated_delivery_time: datetime\n\n@dataclass\nclass OrderReadyEvent(DomainEvent):\n    order_id: str\n    customer_id: str\n    customer_phone: str\n    preparation_time: timedelta\n    pickup_instructions: str\n\n@dataclass\nclass InventoryLowEvent(DomainEvent):\n    ingredient_id: str\n    ingredient_name: str\n    current_quantity: int\n    minimum_threshold: int\n    supplier_info: SupplierDto\n</code></pre>"},{"location":"patterns/event-driven/#event-handlers","title":"Event Handlers","text":"<pre><code># Kitchen workflow responds to order events\nclass KitchenWorkflowHandler(EventHandler[OrderPlacedEvent]):\n    def __init__(self,\n                 kitchen_service: KitchenService,\n                 inventory_service: InventoryService):\n        self._kitchen = kitchen_service\n        self._inventory = inventory_service\n\n    async def handle_async(self, event: OrderPlacedEvent):\n        # Check ingredient availability\n        availability = await self._inventory.check_ingredients_async(event.items)\n        if not availability.all_available:\n            # Raise event for procurement\n            await self._event_bus.publish_async(\n                InventoryLowEvent(\n                    ingredient_id=availability.missing_ingredients[0],\n                    current_quantity=availability.current_stock,\n                    minimum_threshold=availability.required_stock\n                )\n            )\n\n        # Add to kitchen queue\n        kitchen_order = KitchenOrder(\n            order_id=event.order_id,\n            items=event.items,\n            priority=self._calculate_priority(event),\n            estimated_prep_time=self._calculate_prep_time(event.items)\n        )\n\n        await self._kitchen.add_to_queue_async(kitchen_order)\n\n        # Raise cooking started event\n        await self._event_bus.publish_async(\n            OrderCookingStartedEvent(\n                order_id=event.order_id,\n                estimated_ready_time=datetime.utcnow() + kitchen_order.estimated_prep_time\n            )\n        )\n\n# Customer communication handler\nclass CustomerCommunicationHandler:\n    def __init__(self,\n                 sms_service: SMSService,\n                 email_service: EmailService):\n        self._sms = sms_service\n        self._email = email_service\n\n    @event_handler(OrderPlacedEvent)\n    async def send_order_confirmation(self, event: OrderPlacedEvent):\n        confirmation_message = f\"\"\"\n        \ud83c\udf55 Order Confirmed!\n\n        Order #{event.order_id}\n        Total: ${event.total_amount}\n        Estimated delivery: {event.estimated_delivery_time.strftime('%H:%M')}\n\n        We'll notify you when your pizza is ready!\n        \"\"\"\n\n        await self._sms.send_async(event.customer_phone, confirmation_message)\n        await self._email.send_order_confirmation_async(event)\n\n    @event_handler(OrderReadyEvent)\n    async def send_ready_notification(self, event: OrderReadyEvent):\n        ready_message = f\"\"\"\n        \ud83c\udf89 Your pizza is ready!\n\n        Order #{event.order_id}\n        Pickup instructions: {event.pickup_instructions}\n\n        Please collect within 10 minutes for best quality.\n        \"\"\"\n\n        await self._sms.send_async(event.customer_phone, ready_message)\n\n# Analytics and reporting handler\nclass AnalyticsHandler:\n    @event_handler(OrderPlacedEvent)\n    async def track_order_metrics(self, event: OrderPlacedEvent):\n        metrics = OrderMetrics(\n            order_id=event.order_id,\n            customer_id=event.customer_id,\n            order_value=event.total_amount,\n            item_count=len(event.items),\n            order_time=event.occurred_at,\n            customer_type=await self._get_customer_type(event.customer_id)\n        )\n\n        await self._analytics_db.save_metrics_async(metrics)\n\n    @event_handler(OrderReadyEvent)\n    async def track_preparation_metrics(self, event: OrderReadyEvent):\n        prep_metrics = PreparationMetrics(\n            order_id=event.order_id,\n            preparation_time=event.preparation_time,\n            efficiency_score=self._calculate_efficiency(event.preparation_time)\n        )\n\n        await self._analytics_db.save_prep_metrics_async(prep_metrics)\n</code></pre>"},{"location":"patterns/event-driven/#event-bus-configuration","title":"Event Bus Configuration","text":"<pre><code># Configure event routing and handlers\nclass EventBusConfiguration:\n    def configure_events(self, services: ServiceCollection):\n        # Register event handlers\n        services.add_scoped(KitchenWorkflowHandler)\n        services.add_scoped(CustomerCommunicationHandler)\n        services.add_scoped(AnalyticsHandler)\n        services.add_scoped(InventoryManagementHandler)\n\n        # Configure event routing\n        services.add_event_handler(OrderPlacedEvent, KitchenWorkflowHandler)\n        services.add_event_handler(OrderPlacedEvent, CustomerCommunicationHandler)\n        services.add_event_handler(OrderPlacedEvent, AnalyticsHandler)\n\n        services.add_event_handler(OrderReadyEvent, CustomerCommunicationHandler)\n        services.add_event_handler(OrderReadyEvent, AnalyticsHandler)\n\n        services.add_event_handler(InventoryLowEvent, InventoryManagementHandler)\n</code></pre>"},{"location":"patterns/event-driven/#cloudevents-integration","title":"CloudEvents Integration","text":"<pre><code># CloudEvents for external system integration\nclass CloudEventPublisher:\n    def __init__(self, event_bus: EventBus):\n        self._event_bus = event_bus\n\n    async def publish_order_event(self, order_event: OrderPlacedEvent):\n        # Convert domain event to CloudEvent for external systems\n        cloud_event = CloudEvent(\n            source=\"mario-pizzeria/orders\",\n            type=\"com.mariopizzeria.order.placed\",\n            subject=f\"order/{order_event.order_id}\",\n            data={\n                \"orderId\": order_event.order_id,\n                \"customerId\": order_event.customer_id,\n                \"totalAmount\": float(order_event.total_amount),\n                \"items\": [item.to_dict() for item in order_event.items],\n                \"estimatedDelivery\": order_event.estimated_delivery_time.isoformat()\n            },\n            datacontenttype=\"application/json\"\n        )\n\n        await self._event_bus.publish_cloud_event_async(cloud_event)\n</code></pre>"},{"location":"patterns/event-driven/#testing-event-driven-systems","title":"\ud83e\uddea Testing Event-Driven Systems","text":"<pre><code># Test event handling independently\nclass TestKitchenWorkflowHandler:\n    def setup_method(self):\n        self.mock_kitchen = Mock(spec=KitchenService)\n        self.mock_inventory = Mock(spec=InventoryService)\n        self.handler = KitchenWorkflowHandler(self.mock_kitchen, self.mock_inventory)\n\n    async def test_order_placed_adds_to_kitchen_queue(self):\n        # Arrange\n        event = OrderPlacedEvent(\n            order_id=\"123\",\n            customer_id=\"456\",\n            items=[OrderItemDto(name=\"Margherita\", size=\"Large\")]\n        )\n\n        self.mock_inventory.check_ingredients_async.return_value = IngredientAvailability(\n            all_available=True\n        )\n\n        # Act\n        await self.handler.handle_async(event)\n\n        # Assert\n        self.mock_kitchen.add_to_queue_async.assert_called_once()\n        kitchen_order = self.mock_kitchen.add_to_queue_async.call_args[0][0]\n        assert kitchen_order.order_id == \"123\"\n\n# Integration testing with event bus\nclass TestEventIntegration:\n    async def test_order_placement_triggers_all_handlers(self):\n        # Arrange\n        event_bus = InMemoryEventBus()\n        kitchen_handler = Mock(spec=KitchenWorkflowHandler)\n        notification_handler = Mock(spec=CustomerCommunicationHandler)\n\n        event_bus.subscribe(OrderPlacedEvent, kitchen_handler)\n        event_bus.subscribe(OrderPlacedEvent, notification_handler)\n\n        event = OrderPlacedEvent(order_id=\"123\", customer_id=\"456\")\n\n        # Act\n        await event_bus.publish_async(event)\n\n        # Assert\n        kitchen_handler.handle_async.assert_called_once_with(event)\n        notification_handler.send_order_confirmation.assert_called_once_with(event)\n</code></pre>"},{"location":"patterns/event-driven/#related-patterns","title":"\ud83d\udd17 Related Patterns","text":"<ul> <li>CQRS Pattern - Commands often produce domain events</li> <li>Clean Architecture - Events enable layer decoupling</li> <li>Repository Pattern - Events can trigger repository operations</li> </ul> <p>This pattern guide demonstrates Event-Driven Architecture using Mario's Pizzeria's kitchen workflow and customer communication systems. Events enable loose coupling and reactive behavior across the entire pizza ordering experience. \ud83d\udce1</p>"},{"location":"patterns/repository/","title":"\ud83d\uddc4\ufe0f Repository Pattern","text":"<p>\ud83d\udea7 Under Construction</p> <p>This page is currently being developed with comprehensive examples from Mario's Pizzeria. More detailed implementations and code samples are being added.</p> <p>The Repository pattern abstracts data access logic and provides a uniform interface for accessing domain objects, regardless of the underlying storage mechanism.</p>"},{"location":"patterns/repository/#overview","title":"\ud83c\udfaf Overview","text":"<p>The Repository pattern encapsulates the logic needed to access data sources, centralizing common data access functionality for better maintainability and decoupling infrastructure from the domain model. Mario's Pizzeria demonstrates this through order, menu, and customer data management.</p> <pre><code>flowchart TD\n    subgraph \"\ud83c\udf55 Mario's Pizzeria Data Access\"\n        subgraph Domain[\"\ud83c\udfdb\ufe0f Domain Layer\"]\n            OrderEntity[Order Entity]\n            MenuEntity[Menu Entity]\n            CustomerEntity[Customer Entity]\n        end\n\n        subgraph Application[\"\ud83d\udcbc Application Layer\"]\n            OrderHandler[Order Handlers]\n            MenuHandler[Menu Handlers]\n            CustomerHandler[Customer Handlers]\n        end\n\n        subgraph Repositories[\"\ud83d\uddc4\ufe0f Repository Interfaces\"]\n            IOrderRepo[IOrderRepository]\n            IMenuRepo[IMenuRepository]\n            ICustomerRepo[ICustomerRepository]\n        end\n\n        subgraph Implementation[\"\ud83d\udd0c Repository Implementations\"]\n            MongoOrderRepo[MongoOrderRepository]\n            FileMenuRepo[FileMenuRepository]\n            SqlCustomerRepo[SqlCustomerRepository]\n            InMemoryRepo[InMemoryRepository]\n        end\n\n        subgraph Storage[\"\ud83d\udcbe Storage Systems\"]\n            MongoDB[(MongoDB)]\n            FileSystem[(JSON Files)]\n            PostgreSQL[(PostgreSQL)]\n            Memory[(In-Memory)]\n        end\n    end\n\n    OrderHandler --&gt; IOrderRepo\n    MenuHandler --&gt; IMenuRepo\n    CustomerHandler --&gt; ICustomerRepo\n\n    IOrderRepo -.-&gt; MongoOrderRepo\n    IMenuRepo -.-&gt; FileMenuRepo\n    ICustomerRepo -.-&gt; SqlCustomerRepo\n\n    MongoOrderRepo --&gt; MongoDB\n    FileMenuRepo --&gt; FileSystem\n    SqlCustomerRepo --&gt; PostgreSQL\n    InMemoryRepo --&gt; Memory\n\n    IOrderRepo -.-&gt; InMemoryRepo\n    IMenuRepo -.-&gt; InMemoryRepo\n    ICustomerRepo -.-&gt; InMemoryRepo</code></pre>"},{"location":"patterns/repository/#benefits","title":"\u2705 Benefits","text":""},{"location":"patterns/repository/#1-storage-independence","title":"1. Storage Independence","text":"<p>Business logic doesn't depend on specific storage implementations:</p> <pre><code># Domain service works with any repository implementation\nclass OrderService:\n    def __init__(self, order_repository: OrderRepository):\n        self._repository = order_repository  # Interface, not implementation\n\n    async def process_order(self, order: Order) -&gt; bool:\n        # Business logic is storage-agnostic\n        if order.total &gt; Decimal('100'):\n            order.apply_discount(Decimal('0.1'))  # 10% discount for large orders\n\n        await self._repository.save_async(order)\n        return True\n\n# Can swap implementations without changing business logic\n# services.add_scoped(OrderRepository, MongoOrderRepository)  # Production\n# services.add_scoped(OrderRepository, InMemoryOrderRepository)  # Testing\n</code></pre>"},{"location":"patterns/repository/#2-testability","title":"2. Testability","text":"<p>Easy to mock repositories for unit testing:</p> <pre><code>class TestOrderService:\n    def setup_method(self):\n        self.mock_repository = Mock(spec=OrderRepository)\n        self.service = OrderService(self.mock_repository)\n\n    async def test_large_order_gets_discount(self):\n        # Arrange\n        order = Order(customer_id=\"123\", total=Decimal('150'))\n\n        # Act\n        result = await self.service.process_order(order)\n\n        # Assert\n        assert order.total == Decimal('135')  # 10% discount applied\n        self.mock_repository.save_async.assert_called_once_with(order)\n</code></pre>"},{"location":"patterns/repository/#3-centralized-querying","title":"3. Centralized Querying","text":"<p>Complex queries are encapsulated in the repository:</p> <pre><code>class OrderRepository(Repository[Order, str]):\n    async def find_orders_by_customer_async(self, customer_id: str) -&gt; List[Order]:\n        \"\"\"Find all orders for a specific customer\"\"\"\n        pass\n\n    async def find_orders_by_date_range_async(\n        self,\n        start_date: datetime,\n        end_date: datetime\n    ) -&gt; List[Order]:\n        \"\"\"Find orders within a date range\"\"\"\n        pass\n\n    async def find_popular_pizzas_async(self, days: int = 30) -&gt; List[PopularPizzaStats]:\n        \"\"\"Get pizza popularity statistics\"\"\"\n        pass\n</code></pre>"},{"location":"patterns/repository/#data-flow","title":"\ud83d\udd04 Data Flow","text":"<p>Order management demonstrates repository data flow:</p> <pre><code>sequenceDiagram\n    participant Client\n    participant Handler as Order Handler\n    participant Repo as Order Repository\n    participant MongoDB as MongoDB\n    participant FileSystem as File System\n\n    Note over Client,FileSystem: Save Order Flow\n    Client-&gt;&gt;+Handler: PlaceOrderCommand\n    Handler-&gt;&gt;Handler: Create Order entity\n    Handler-&gt;&gt;+Repo: save_async(order)\n\n    alt MongoDB Implementation\n        Repo-&gt;&gt;+MongoDB: Insert document\n        MongoDB--&gt;&gt;-Repo: Success\n    else File Implementation\n        Repo-&gt;&gt;+FileSystem: Write JSON file\n        FileSystem--&gt;&gt;-Repo: Success\n    end\n\n    Repo--&gt;&gt;-Handler: Order saved\n    Handler--&gt;&gt;-Client: OrderDto result\n\n    Note over Client,FileSystem: Query Orders Flow\n    Client-&gt;&gt;+Handler: GetOrderHistoryQuery\n    Handler-&gt;&gt;+Repo: find_orders_by_customer_async(customer_id)\n\n    alt MongoDB Implementation\n        Repo-&gt;&gt;+MongoDB: Find query with aggregation\n        MongoDB--&gt;&gt;-Repo: Order documents\n    else File Implementation\n        Repo-&gt;&gt;+FileSystem: Read and filter JSON files\n        FileSystem--&gt;&gt;-Repo: Order data\n    end\n\n    Repo--&gt;&gt;-Handler: List[Order]\n    Handler-&gt;&gt;Handler: Map to DTOs\n    Handler--&gt;&gt;-Client: List[OrderDto]</code></pre>"},{"location":"patterns/repository/#use-cases","title":"\ud83c\udfaf Use Cases","text":"<p>Repository pattern is ideal for:</p> <ul> <li>Multiple Storage Options: Support different databases/storage systems</li> <li>Complex Queries: Encapsulate sophisticated data access logic</li> <li>Testing: Easy mocking and unit testing</li> <li>Legacy Integration: Abstract away legacy system complexity</li> </ul>"},{"location":"patterns/repository/#implementation-in-marios-pizzeria","title":"\ud83c\udf55 Implementation in Mario's Pizzeria","text":""},{"location":"patterns/repository/#repository-interface","title":"Repository Interface","text":"<pre><code># Abstract base repository for all entities\nclass Repository(ABC, Generic[TEntity, TKey]):\n    @abstractmethod\n    async def get_by_id_async(self, id: TKey) -&gt; Optional[TEntity]:\n        \"\"\"Get entity by ID\"\"\"\n        pass\n\n    @abstractmethod\n    async def save_async(self, entity: TEntity) -&gt; None:\n        \"\"\"Save or update entity\"\"\"\n        pass\n\n    @abstractmethod\n    async def delete_async(self, id: TKey) -&gt; bool:\n        \"\"\"Delete entity by ID\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_all_async(self) -&gt; List[TEntity]:\n        \"\"\"Get all entities\"\"\"\n        pass\n\n# Order-specific repository interface\nclass OrderRepository(Repository[Order, str]):\n    @abstractmethod\n    async def find_by_customer_async(self, customer_id: str) -&gt; List[Order]:\n        \"\"\"Find orders for a specific customer\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_by_status_async(self, status: OrderStatus) -&gt; List[Order]:\n        \"\"\"Find orders by status\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_by_date_range_async(\n        self,\n        start_date: datetime,\n        end_date: datetime\n    ) -&gt; List[Order]:\n        \"\"\"Find orders within date range\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_daily_sales_async(self, date: datetime.date) -&gt; DailySalesReport:\n        \"\"\"Get sales report for specific date\"\"\"\n        pass\n</code></pre>"},{"location":"patterns/repository/#mongodb-implementation","title":"MongoDB Implementation","text":"<pre><code>class MongoOrderRepository(OrderRepository):\n    def __init__(self, collection: Collection):\n        self._collection = collection\n\n    async def get_by_id_async(self, order_id: str) -&gt; Optional[Order]:\n        document = await self._collection.find_one({\"_id\": order_id})\n        return self._document_to_entity(document) if document else None\n\n    async def save_async(self, order: Order) -&gt; None:\n        document = self._entity_to_document(order)\n        await self._collection.replace_one(\n            {\"_id\": order.id},\n            document,\n            upsert=True\n        )\n\n    async def find_by_customer_async(self, customer_id: str) -&gt; List[Order]:\n        cursor = self._collection.find({\"customer_id\": customer_id})\n        documents = await cursor.to_list(None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def find_by_status_async(self, status: OrderStatus) -&gt; List[Order]:\n        cursor = self._collection.find({\"status\": status.value})\n        documents = await cursor.to_list(None)\n        return [self._document_to_entity(doc) for doc in documents]\n\n    async def get_daily_sales_async(self, date: datetime.date) -&gt; DailySalesReport:\n        start_datetime = datetime.combine(date, datetime.min.time())\n        end_datetime = datetime.combine(date, datetime.max.time())\n\n        pipeline = [\n            {\n                \"$match\": {\n                    \"created_at\": {\n                        \"$gte\": start_datetime,\n                        \"$lt\": end_datetime\n                    },\n                    \"status\": {\"$ne\": \"cancelled\"}\n                }\n            },\n            {\n                \"$group\": {\n                    \"_id\": None,\n                    \"total_orders\": {\"$sum\": 1},\n                    \"total_revenue\": {\"$sum\": \"$total\"},\n                    \"avg_order_value\": {\"$avg\": \"$total\"}\n                }\n            }\n        ]\n\n        result = await self._collection.aggregate(pipeline).to_list(1)\n        if result:\n            data = result[0]\n            return DailySalesReport(\n                date=date,\n                total_orders=data[\"total_orders\"],\n                total_revenue=Decimal(str(data[\"total_revenue\"])),\n                average_order_value=Decimal(str(data[\"avg_order_value\"]))\n            )\n\n        return DailySalesReport(date=date, total_orders=0, total_revenue=Decimal('0'))\n\n    def _entity_to_document(self, order: Order) -&gt; dict:\n        return {\n            \"_id\": order.id,\n            \"customer_id\": order.customer_id,\n            \"items\": [\n                {\n                    \"name\": item.pizza_name,\n                    \"size\": item.size,\n                    \"quantity\": item.quantity,\n                    \"price\": float(item.price)\n                }\n                for item in order.items\n            ],\n            \"total\": float(order.total),\n            \"status\": order.status.value,\n            \"delivery_address\": order.delivery_address,\n            \"special_instructions\": order.special_instructions,\n            \"created_at\": order.created_at,\n            \"updated_at\": order.updated_at\n        }\n\n    def _document_to_entity(self, document: dict) -&gt; Order:\n        items = [\n            OrderItem(\n                pizza_name=item[\"name\"],\n                size=PizzaSize(item[\"size\"]),\n                quantity=item[\"quantity\"],\n                price=Decimal(str(item[\"price\"]))\n            )\n            for item in document[\"items\"]\n        ]\n\n        order = Order(\n            id=document[\"_id\"],\n            customer_id=document[\"customer_id\"],\n            items=items,\n            delivery_address=document[\"delivery_address\"],\n            special_instructions=document.get(\"special_instructions\")\n        )\n\n        order.status = OrderStatus(document[\"status\"])\n        order.created_at = document[\"created_at\"]\n        order.updated_at = document[\"updated_at\"]\n\n        return order\n</code></pre>"},{"location":"patterns/repository/#file-based-implementation","title":"File-Based Implementation","text":"<pre><code>class FileOrderRepository(OrderRepository):\n    def __init__(self, data_directory: str):\n        self._data_dir = Path(data_directory)\n        self._data_dir.mkdir(exist_ok=True)\n\n    async def get_by_id_async(self, order_id: str) -&gt; Optional[Order]:\n        file_path = self._data_dir / f\"{order_id}.json\"\n        if not file_path.exists():\n            return None\n\n        async with aiofiles.open(file_path, 'r') as f:\n            data = json.loads(await f.read())\n            return self._dict_to_entity(data)\n\n    async def save_async(self, order: Order) -&gt; None:\n        file_path = self._data_dir / f\"{order.id}.json\"\n        data = self._entity_to_dict(order)\n\n        async with aiofiles.open(file_path, 'w') as f:\n            await f.write(json.dumps(data, indent=2, cls=DecimalEncoder))\n\n    async def find_by_customer_async(self, customer_id: str) -&gt; List[Order]:\n        orders = []\n        async for file_path in self._iterate_order_files():\n            async with aiofiles.open(file_path, 'r') as f:\n                data = json.loads(await f.read())\n                if data[\"customer_id\"] == customer_id:\n                    orders.append(self._dict_to_entity(data))\n        return orders\n\n    async def get_daily_sales_async(self, date: datetime.date) -&gt; DailySalesReport:\n        total_orders = 0\n        total_revenue = Decimal('0')\n\n        async for file_path in self._iterate_order_files():\n            async with aiofiles.open(file_path, 'r') as f:\n                data = json.loads(await f.read())\n                order_date = datetime.fromisoformat(data[\"created_at\"]).date()\n\n                if order_date == date and data[\"status\"] != \"cancelled\":\n                    total_orders += 1\n                    total_revenue += Decimal(str(data[\"total\"]))\n\n        avg_order_value = total_revenue / total_orders if total_orders &gt; 0 else Decimal('0')\n\n        return DailySalesReport(\n            date=date,\n            total_orders=total_orders,\n            total_revenue=total_revenue,\n            average_order_value=avg_order_value\n        )\n\n    async def _iterate_order_files(self):\n        for file_path in self._data_dir.glob(\"*.json\"):\n            yield file_path\n</code></pre>"},{"location":"patterns/repository/#in-memory-implementation-testing","title":"In-Memory Implementation (Testing)","text":"<pre><code>class InMemoryOrderRepository(OrderRepository):\n    def __init__(self):\n        self._orders: Dict[str, Order] = {}\n\n    async def get_by_id_async(self, order_id: str) -&gt; Optional[Order]:\n        return self._orders.get(order_id)\n\n    async def save_async(self, order: Order) -&gt; None:\n        # Create deep copy to avoid reference issues in tests\n        self._orders[order.id] = copy.deepcopy(order)\n\n    async def delete_async(self, order_id: str) -&gt; bool:\n        if order_id in self._orders:\n            del self._orders[order_id]\n            return True\n        return False\n\n    async def find_all_async(self) -&gt; List[Order]:\n        return list(self._orders.values())\n\n    async def find_by_customer_async(self, customer_id: str) -&gt; List[Order]:\n        return [order for order in self._orders.values()\n                if order.customer_id == customer_id]\n\n    async def find_by_status_async(self, status: OrderStatus) -&gt; List[Order]:\n        return [order for order in self._orders.values()\n                if order.status == status]\n\n    def clear(self):\n        \"\"\"Helper method for testing\"\"\"\n        self._orders.clear()\n</code></pre>"},{"location":"patterns/repository/#repository-registration","title":"Repository Registration","text":"<pre><code>class RepositoryConfiguration:\n    def configure_repositories(self, services: ServiceCollection, config: AppConfig):\n        if config.storage_type == \"mongodb\":\n            # MongoDB implementation\n            services.add_singleton(lambda sp: MongoClient(config.mongodb_connection))\n            services.add_scoped(lambda sp: MongoOrderRepository(\n                sp.get_service(MongoClient).orders_db.orders\n            ))\n\n        elif config.storage_type == \"file\":\n            # File-based implementation\n            services.add_scoped(lambda sp: FileOrderRepository(config.data_directory))\n\n        elif config.storage_type == \"memory\":\n            # In-memory implementation (testing)\n            services.add_singleton(InMemoryOrderRepository)\n\n        # Register interface to implementation\n        services.add_scoped(OrderRepository,\n                          lambda sp: sp.get_service(config.repository_implementation))\n</code></pre>"},{"location":"patterns/repository/#testing-with-repositories","title":"\ud83e\uddea Testing with Repositories","text":"<pre><code># Unit testing with mocked repositories\nclass TestOrderService:\n    def setup_method(self):\n        self.mock_repository = Mock(spec=OrderRepository)\n        self.service = OrderService(self.mock_repository)\n\n    async def test_get_customer_orders(self):\n        # Arrange\n        expected_orders = [\n            Order(customer_id=\"123\", items=[]),\n            Order(customer_id=\"123\", items=[])\n        ]\n        self.mock_repository.find_by_customer_async.return_value = expected_orders\n\n        # Act\n        result = await self.service.get_customer_orders(\"123\")\n\n        # Assert\n        assert len(result) == 2\n        self.mock_repository.find_by_customer_async.assert_called_once_with(\"123\")\n\n# Integration testing with real repositories\nclass TestOrderRepositoryIntegration:\n    def setup_method(self):\n        self.repository = InMemoryOrderRepository()\n\n    async def test_save_and_retrieve_order(self):\n        # Arrange\n        order = Order(\n            customer_id=\"123\",\n            items=[OrderItem(\"Margherita\", PizzaSize.LARGE, 1, Decimal('15.99'))]\n        )\n\n        # Act\n        await self.repository.save_async(order)\n        retrieved = await self.repository.get_by_id_async(order.id)\n\n        # Assert\n        assert retrieved is not None\n        assert retrieved.customer_id == \"123\"\n        assert len(retrieved.items) == 1\n</code></pre>"},{"location":"patterns/repository/#related-patterns","title":"\ud83d\udd17 Related Patterns","text":"<ul> <li>Clean Architecture - Repositories belong in the integration layer</li> <li>CQRS Pattern - Separate repositories for commands and queries</li> <li>Event-Driven Pattern - Repositories can publish domain events</li> </ul> <p>This pattern guide demonstrates the Repository pattern using Mario's Pizzeria's data access layer. The abstraction enables storage flexibility and comprehensive testing strategies. \ud83d\uddc4\ufe0f</p>"},{"location":"patterns/resource-oriented-architecture/","title":"\ud83c\udfaf Resource Oriented Architecture (ROA)","text":"<p>Resource Oriented Architecture is a powerful pattern for building systems that manage resources through their lifecycle, similar to how Kubernetes manages cluster resources. Neuroglia provides comprehensive support for ROA patterns including watchers, controllers, and reconciliation loops.</p>"},{"location":"patterns/resource-oriented-architecture/#overview","title":"\ud83c\udfaf Overview","text":"<p>ROA provides:</p> <ul> <li>\ud83d\udcca Resource Management: Declarative resource definitions with desired vs actual state</li> <li>\ud83d\udc40 Watchers: Continuous monitoring of resource changes through polling or event streams</li> <li>\ud83c\udfae Controllers: Business logic that responds to resource changes and implements state transitions</li> <li>\ud83d\udd04 Reconciliation: Periodic loops that ensure system consistency and handle drift detection</li> <li>\ud83d\udee1\ufe0f Safety Mechanisms: Timeout handling, error recovery, and corrective actions</li> </ul>"},{"location":"patterns/resource-oriented-architecture/#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<pre><code>graph TB\n    subgraph \"\ud83d\udcca Resource Layer\"\n        A[Resource Definition]\n        B[Resource Storage]\n        C[Resource Events]\n    end\n\n    subgraph \"\ud83d\udc40 Observation Layer\"\n        D[Watcher] --&gt; E[Event Stream]\n        F[Poller] --&gt; G[Change Detection]\n    end\n\n    subgraph \"\ud83c\udfae Control Layer\"\n        H[Controller] --&gt; I[Business Logic]\n        I --&gt; J[State Transitions]\n        I --&gt; K[Action Execution]\n    end\n\n    subgraph \"\ud83d\udd04 Reconciliation Layer\"\n        L[Reconciliation Loop] --&gt; M[Drift Detection]\n        M --&gt; N[Corrective Actions]\n        N --&gt; O[State Restoration]\n    end\n\n    subgraph \"\ud83d\udee1\ufe0f Safety Layer\"\n        P[Error Handling] --&gt; Q[Retry Logic]\n        Q --&gt; R[Circuit Breaker]\n        R --&gt; S[Timeout Management]\n    end\n\n    A --&gt; B\n    B --&gt; C\n    C --&gt; D\n    C --&gt; F\n    E --&gt; H\n    G --&gt; H\n    H --&gt; L\n    L --&gt; P\n\n    style A fill:#e3f2fd\n    style H fill:#f3e5f5\n    style L fill:#e8f5e8\n    style P fill:#fff3e0</code></pre>"},{"location":"patterns/resource-oriented-architecture/#core-components","title":"\ud83c\udfd7\ufe0f Core Components","text":""},{"location":"patterns/resource-oriented-architecture/#resource-definition","title":"Resource Definition","text":"<p>Resources are declarative objects that define desired state:</p> <pre><code>@dataclass\nclass LabInstanceResource:\n    api_version: str = \"lab.neuroglia.com/v1\"\n    kind: str = \"LabInstance\"\n    metadata: Dict[str, Any] = None\n    spec: Dict[str, Any] = None      # Desired state\n    status: Dict[str, Any] = None    # Current state\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#watcher-pattern","title":"Watcher Pattern","text":"<p>Watchers continuously monitor resources for changes:</p> <pre><code>class LabInstanceWatcher:\n    async def start_watching(self):\n        while self.is_running:\n            # Poll for changes since last known version\n            changes = self.storage.list_resources(since_version=self.last_resource_version)\n\n            for resource in changes:\n                await self._handle_resource_change(resource)\n\n            await asyncio.sleep(self.poll_interval)\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#controller-pattern","title":"Controller Pattern","text":"<p>Controllers respond to resource changes with business logic:</p> <pre><code>class LabInstanceController:\n    async def handle_resource_event(self, resource: LabInstanceResource):\n        current_state = resource.status.get('state')\n\n        if current_state == ResourceState.PENDING.value:\n            await self._start_provisioning(resource)\n        elif current_state == ResourceState.PROVISIONING.value:\n            await self._check_provisioning_status(resource)\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#reconciliation-loop","title":"Reconciliation Loop","text":"<p>Reconcilers ensure eventual consistency:</p> <pre><code>class LabInstanceScheduler:\n    async def start_reconciliation(self):\n        while self.is_running:\n            await self._reconcile_all_resources()\n            await asyncio.sleep(self.reconcile_interval)\n\n    async def _reconcile_resource(self, resource):\n        # Check for stuck states, timeouts, and drift\n        # Take corrective actions as needed\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#key-patterns","title":"\ud83d\ude80 Key Patterns","text":""},{"location":"patterns/resource-oriented-architecture/#1-declarative-state-management","title":"1. Declarative State Management","text":"<p>Resources define what should exist, not how to create it:</p> <pre><code># Desired state (spec)\nspec = {\n    'template': 'python-basics',\n    'duration': '60m',\n    'studentEmail': 'student@example.com'\n}\n\n# Current state (status)\nstatus = {\n    'state': 'ready',\n    'endpoint': 'https://lab-instance.example.com',\n    'readyAt': '2025-09-09T21:34:19Z'\n}\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#2-event-driven-processing","title":"2. Event-Driven Processing","text":"<p>Watchers detect changes and notify controllers immediately:</p> <pre><code>Resource Change \u2192 Watcher Detection \u2192 Controller Response \u2192 State Update\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#3-asynchronous-reconciliation","title":"3. Asynchronous Reconciliation","text":"<p>Controllers handle immediate responses while reconcilers provide safety:</p> <pre><code># Controller: Immediate response to events\nasync def handle_resource_event(self, resource):\n    if resource.state == PENDING:\n        await self.start_provisioning(resource)\n\n# Reconciler: Periodic safety checks\nasync def reconcile_resource(self, resource):\n    if self.is_stuck_provisioning(resource):\n        await self.mark_as_failed(resource)\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#4-state-machine-implementation","title":"4. State Machine Implementation","text":"<p>Resources progress through well-defined states:</p> <pre><code>PENDING \u2192 PROVISIONING \u2192 READY \u2192 (cleanup) \u2192 DELETING \u2192 DELETED\n    \u2193                      \u2193\n  FAILED              \u2190 FAILED\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#execution-model","title":"\u26a1 Execution Model","text":""},{"location":"patterns/resource-oriented-architecture/#timing-and-coordination","title":"Timing and Coordination","text":"<ul> <li>Watchers: Poll every 2-5 seconds for near-real-time responsiveness</li> <li>Controllers: Respond immediately to detected changes</li> <li>Reconcilers: Run every 10-30 seconds for consistency checks</li> </ul>"},{"location":"patterns/resource-oriented-architecture/#concurrent-processing","title":"Concurrent Processing","text":"<p>All components run concurrently:</p> <pre><code>async def main():\n    # Start all components concurrently\n    watcher_task = asyncio.create_task(watcher.start_watching())\n    scheduler_task = asyncio.create_task(scheduler.start_reconciliation())\n\n    # Controllers are event-driven (no separate task needed)\n    watcher.add_event_handler(controller.handle_resource_event)\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#safety-and-reliability","title":"\ud83d\udee1\ufe0f Safety and Reliability","text":""},{"location":"patterns/resource-oriented-architecture/#timeout-handling","title":"Timeout Handling","text":"<p>Reconcilers detect and handle stuck states:</p> <pre><code>if resource.state == PROVISIONING and age &gt; timeout_threshold:\n    await self.mark_as_failed(resource, \"Provisioning timeout\")\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#error-recovery","title":"Error Recovery","text":"<p>Controllers and reconcilers implement retry logic:</p> <pre><code>try:\n    await self.provision_lab_instance(resource)\nexcept Exception as e:\n    resource.status['retries'] = resource.status.get('retries', 0) + 1\n    if resource.status['retries'] &lt; max_retries:\n        await self.schedule_retry(resource)\n    else:\n        await self.mark_as_failed(resource, str(e))\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#drift-detection","title":"Drift Detection","text":"<p>Reconcilers verify that actual state matches desired state:</p> <pre><code>async def check_drift(self, resource):\n    actual_state = await self.get_actual_infrastructure_state(resource)\n    desired_state = resource.spec\n\n    if actual_state != desired_state:\n        await self.correct_drift(resource, actual_state, desired_state)\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#observability","title":"\ud83d\udcca Observability","text":""},{"location":"patterns/resource-oriented-architecture/#metrics-and-logging","title":"Metrics and Logging","text":"<p>ROA components provide rich observability:</p> <pre><code>logger.info(f\"\ud83d\udd0d Watcher detected change: {resource_id} -&gt; {state}\")\nlogger.info(f\"\ud83c\udfae Controller processing: {resource_id} (state: {state})\")\nlogger.info(f\"\ud83d\udd04 Reconciling {len(resources)} resources\")\nlogger.warning(f\"\u26a0\ufe0f Reconciler: Resource stuck: {resource_id}\")\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#resource-versioning","title":"Resource Versioning","text":"<p>Track changes with resource versions:</p> <pre><code>resource.metadata['resourceVersion'] = str(self.next_version())\nresource.metadata['lastModified'] = datetime.now(timezone.utc).isoformat()\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#configuration","title":"\ud83d\udd27 Configuration","text":""},{"location":"patterns/resource-oriented-architecture/#tuning-parameters","title":"Tuning Parameters","text":"<p>Adjust timing for your use case:</p> <pre><code># Development: Fast feedback\nwatcher = LabInstanceWatcher(storage, poll_interval=1.0)\nscheduler = LabInstanceScheduler(storage, reconcile_interval=5.0)\n\n# Production: Balanced performance\nwatcher = LabInstanceWatcher(storage, poll_interval=5.0)\nscheduler = LabInstanceScheduler(storage, reconcile_interval=30.0)\n</code></pre>"},{"location":"patterns/resource-oriented-architecture/#scaling-considerations","title":"Scaling Considerations","text":"<ul> <li>Multiple Watchers: Use resource sharding for scale</li> <li>Controller Parallelism: Process multiple resources concurrently</li> <li>Reconciler Batching: Group operations for efficiency</li> </ul>"},{"location":"patterns/resource-oriented-architecture/#use-cases","title":"\ud83c\udfaf Use Cases","text":"<p>ROA is ideal for:</p> <ul> <li>Infrastructure Management: Cloud resources, containers, services</li> <li>Workflow Orchestration: Multi-step processes with dependencies</li> <li>Resource Lifecycle: Provisioning, monitoring, cleanup</li> <li>System Integration: Managing external system state</li> <li>DevOps Automation: CI/CD pipelines, deployment management</li> </ul>"},{"location":"patterns/resource-oriented-architecture/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\ud83c\udfd7\ufe0f Watcher &amp; Reconciliation Patterns - Detailed pattern explanations</li> <li>\u26a1 Execution Flow - How components coordinate</li> <li>\ud83e\uddea Lab Resource Manager Sample - Complete ROA implementation</li> <li>\ud83c\udfaf CQRS &amp; Mediation - Command/Query patterns used in ROA</li> <li>\ud83d\uddc4\ufe0f Data Access - Repository patterns for resource storage</li> </ul>"},{"location":"patterns/watcher-reconciliation-execution/","title":"How Watcher and Reconciliation Loop Execute","text":"<p>This document provides a detailed explanation of how the Resource Watcher and Reconciliation Loop patterns execute in our Resource Oriented Architecture (ROA) implementation.</p>"},{"location":"patterns/watcher-reconciliation-execution/#execution-flow-overview","title":"\ud83d\udd04 Execution Flow Overview","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Resource       \u2502    \u2502  Resource       \u2502    \u2502  Background     \u2502\n\u2502  Watcher        \u2502    \u2502  Controller     \u2502    \u2502  Scheduler      \u2502\n\u2502                 \u2502    \u2502                 \u2502    \u2502                 \u2502\n\u2502 \u2022 Polls storage \u2502\u2500\u2500\u2500\u25b6\u2502 \u2022 Reconciles    \u2502\u25c4\u2500\u2500\u25b6\u2502 \u2022 Monitors all  \u2502\n\u2502 \u2022 Detects \u0394     \u2502    \u2502   resources     \u2502    \u2502   resources     \u2502\n\u2502 \u2022 Emits events  \u2502    \u2502 \u2022 Updates state \u2502    \u2502 \u2022 Enforces      \u2502\n\u2502 \u2022 Triggers      \u2502    \u2502 \u2022 Publishes     \u2502    \u2502   lifecycle     \u2502\n\u2502   reconciliation\u2502    \u2502   events        \u2502    \u2502                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                       \u2502                       \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                 \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502    Event Bus &amp;          \u2502\n                    \u2502  Cloud Events           \u2502\n                    \u2502                         \u2502\n                    \u2502 \u2022 Resource created      \u2502\n                    \u2502 \u2022 Resource updated      \u2502\n                    \u2502 \u2022 Status changed        \u2502\n                    \u2502 \u2022 Reconciliation done   \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#1-resource-watcher-execution","title":"1\ufe0f\u20e3 Resource Watcher Execution","text":""},{"location":"patterns/watcher-reconciliation-execution/#polling-loop-implementation","title":"Polling Loop Implementation","text":"<pre><code>class ResourceWatcherBase:\n    async def _watch_loop(self, namespace=None, label_selector=None):\n        \"\"\"\n        Main watch loop - executes continuously:\n\n        1. List current resources from storage\n        2. Compare with cached resources\n        3. Detect changes (CREATED, UPDATED, DELETED, STATUS_UPDATED)\n        4. Process each change\n        5. Update cache\n        6. Sleep until next poll\n        \"\"\"\n        while self._watching:\n            try:\n                # STEP 1: Get current state from storage\n                current_resources = await self._list_resources(namespace, label_selector)\n                current_resource_map = {r.id: r for r in current_resources}\n\n                # STEP 2: Detect changes by comparing with cache\n                changes = self._detect_changes(current_resource_map)\n\n                # STEP 3: Process each detected change\n                for change in changes:\n                    await self._process_change(change)\n\n                # STEP 4: Update cache with current state\n                self._resource_cache = current_resource_map\n\n                # STEP 5: Wait before next poll\n                await asyncio.sleep(self.watch_interval)\n\n            except Exception as e:\n                log.error(f\"Error in watch loop: {e}\")\n                await asyncio.sleep(self.watch_interval)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#change-detection-algorithm","title":"Change Detection Algorithm","text":"<pre><code>def _detect_changes(self, current_resources):\n    \"\"\"\n    Change detection compares current vs cached state:\n\n    \u2022 CREATED: resource_id in current but not in cache\n    \u2022 DELETED: resource_id in cache but not in current  \n    \u2022 UPDATED: generation increased (spec changed)\n    \u2022 STATUS_UPDATED: status fields changed\n    \"\"\"\n    changes = []\n    current_ids = set(current_resources.keys())\n    cached_ids = set(self._resource_cache.keys())\n\n    # New resources (CREATED)\n    for resource_id in current_ids - cached_ids:\n        changes.append(ResourceChangeEvent(\n            change_type=ResourceChangeType.CREATED,\n            resource=current_resources[resource_id]\n        ))\n\n    # Deleted resources (DELETED)  \n    for resource_id in cached_ids - current_ids:\n        changes.append(ResourceChangeEvent(\n            change_type=ResourceChangeType.DELETED,\n            resource=self._resource_cache[resource_id]\n        ))\n\n    # Modified resources (UPDATED/STATUS_UPDATED)\n    for resource_id in current_ids &amp; cached_ids:\n        current = current_resources[resource_id]\n        cached = self._resource_cache[resource_id]\n\n        # Spec changed (generation incremented)\n        if current.metadata.generation &gt; cached.metadata.generation:\n            changes.append(ResourceChangeEvent(\n                change_type=ResourceChangeType.UPDATED,\n                resource=current,\n                old_resource=cached\n            ))\n        # Status changed\n        elif self._has_status_changed(current, cached):\n            changes.append(ResourceChangeEvent(\n                change_type=ResourceChangeType.STATUS_UPDATED,\n                resource=current,\n                old_resource=cached\n            ))\n\n    return changes\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#event-processing-and-controller-triggering","title":"Event Processing and Controller Triggering","text":"<pre><code>async def _process_change(self, change):\n    \"\"\"\n    When changes are detected:\n\n    1. Call registered change handlers (like controllers)\n    2. Publish CloudEvents to event bus\n    3. Handle errors gracefully\n    \"\"\"\n    # STEP 1: Call all registered handlers\n    for handler in self._change_handlers:\n        try:\n            if asyncio.iscoroutinefunction(handler):\n                await handler(change)  # Triggers controller reconciliation\n            else:\n                handler(change)\n        except Exception as e:\n            log.error(f\"Change handler failed: {e}\")\n\n    # STEP 2: Publish event to broader system\n    await self._publish_change_event(change)\n\n# Example: Lab Instance Watcher\nclass LabInstanceWatcher(ResourceWatcherBase):\n    def __init__(self, repository, controller, event_publisher):\n        super().__init__(event_publisher)\n        # Register controller as change handler\n        self.add_change_handler(self._handle_resource_change)\n\n    async def _handle_resource_change(self, change):\n        \"\"\"Called automatically when changes detected\"\"\"\n        if change.change_type in [ResourceChangeType.CREATED, ResourceChangeType.UPDATED]:\n            # Trigger reconciliation for new/updated resources\n            await self.controller.reconcile(change.resource)\n        elif change.change_type == ResourceChangeType.DELETED:\n            # Trigger cleanup for deleted resources\n            await self.controller.finalize(change.resource)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#2-reconciliation-loop-execution","title":"2\ufe0f\u20e3 Reconciliation Loop Execution","text":""},{"location":"patterns/watcher-reconciliation-execution/#controller-reconciliation-pattern","title":"Controller Reconciliation Pattern","text":"<pre><code>class ResourceControllerBase:\n    async def reconcile(self, resource):\n        \"\"\"\n        Main reconciliation entry point:\n\n        1. Check if reconciliation is needed\n        2. Execute reconciliation logic with timeout\n        3. Handle results (success, failure, requeue)\n        4. Update resource status\n        5. Emit reconciliation events\n        \"\"\"\n        start_time = datetime.now()\n\n        try:\n            # STEP 1: Check if reconciliation needed\n            if not resource.needs_reconciliation():\n                log.debug(f\"Resource {resource.metadata.name} does not need reconciliation\")\n                return\n\n            # STEP 2: Execute reconciliation with timeout\n            result = await asyncio.wait_for(\n                self._do_reconcile(resource),\n                timeout=self._reconciliation_timeout.total_seconds()\n            )\n\n            # STEP 3: Handle reconciliation result\n            await self._handle_reconciliation_result(resource, result, start_time)\n\n        except asyncio.TimeoutError:\n            await self._handle_reconciliation_error(resource, TimeoutError(), start_time)\n        except Exception as e:\n            await self._handle_reconciliation_error(resource, e, start_time)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#lab-instance-controller-implementation","title":"Lab Instance Controller Implementation","text":"<pre><code>class LabInstanceController(ResourceControllerBase):\n    async def _do_reconcile(self, resource: LabInstanceRequest):\n        \"\"\"\n        Lab-specific reconciliation logic:\n\n        \u2022 PENDING \u2192 PROVISIONING: Check if should start\n        \u2022 PROVISIONING \u2192 RUNNING: Start container\n        \u2022 RUNNING \u2192 COMPLETED: Monitor completion\n        \u2022 Handle errors and timeouts\n        \"\"\"\n        current_phase = resource.status.phase\n\n        if current_phase == LabInstancePhase.PENDING:\n            if resource.should_start_now():\n                # Time to start - provision container\n                success = await self._provision_lab_instance(resource)\n                return ReconciliationResult.success() if success else ReconciliationResult.requeue()\n            else:\n                # Not time yet - requeue when it should start\n                remaining_time = resource.get_time_until_start()\n                return ReconciliationResult.requeue_after(remaining_time)\n\n        elif current_phase == LabInstancePhase.PROVISIONING:\n            # Check if container is ready\n            if await self._is_container_ready(resource):\n                resource.transition_to_running()\n                await self._repository.save_async(resource)\n                return ReconciliationResult.success()\n            else:\n                # Still provisioning - check again soon\n                return ReconciliationResult.requeue_after(timedelta(seconds=30))\n\n        elif current_phase == LabInstancePhase.RUNNING:\n            # Monitor for completion or timeout\n            if resource.is_expired():\n                await self._timeout_lab_instance(resource)\n                return ReconciliationResult.success()\n            else:\n                # Check again when it should expire\n                remaining_time = resource.get_remaining_duration()\n                return ReconciliationResult.requeue_after(remaining_time)\n\n        # No action needed for terminal phases\n        return ReconciliationResult.success()\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#3-background-scheduler-as-reconciliation-loop","title":"3\ufe0f\u20e3 Background Scheduler as Reconciliation Loop","text":""},{"location":"patterns/watcher-reconciliation-execution/#scheduler-service-implementation","title":"Scheduler Service Implementation","text":"<pre><code>class LabInstanceSchedulerService(HostedService):\n    \"\"\"\n    Background service that acts as a reconciliation loop:\n\n    \u2022 Runs independently of watchers\n    \u2022 Periodically scans all resources\n    \u2022 Applies policies and enforces state\n    \u2022 Handles bulk operations\n    \"\"\"\n\n    async def _run_scheduler_loop(self):\n        \"\"\"Main scheduler loop - runs continuously\"\"\"\n        cleanup_counter = 0\n\n        while self._running:\n            try:\n                # PHASE 1: Process scheduled instances (PENDING \u2192 PROVISIONING)\n                await self._process_scheduled_instances()\n\n                # PHASE 2: Monitor running instances (RUNNING state health)\n                await self._process_running_instances()\n\n                # PHASE 3: Periodic cleanup (expired/failed instances)\n                cleanup_counter += self._scheduler_interval\n                if cleanup_counter &gt;= self._cleanup_interval:\n                    await self._cleanup_expired_instances()\n                    cleanup_counter = 0\n\n                # Wait before next iteration\n                await asyncio.sleep(self._scheduler_interval)\n\n            except Exception as e:\n                log.error(f\"Error in scheduler loop: {e}\")\n                await asyncio.sleep(self._scheduler_interval)\n\n    async def _process_scheduled_instances(self):\n        \"\"\"Reconcile PENDING instances that should start\"\"\"\n        try:\n            # Find all pending instances that are scheduled\n            pending_instances = await self._repository.find_scheduled_pending_async()\n\n            for instance in pending_instances:\n                if instance.should_start_now():\n                    # Move toward desired state: PENDING \u2192 PROVISIONING \u2192 RUNNING\n                    await self._start_lab_instance(instance)\n\n        except Exception as e:\n            log.error(f\"Error processing scheduled instances: {e}\")\n\n    async def _process_running_instances(self):\n        \"\"\"Reconcile RUNNING instances for health/completion\"\"\"\n        try:\n            running_instances = await self._repository.find_running_instances_async()\n\n            for instance in running_instances:\n                # Check actual container state vs desired state\n                container_status = await self._container_service.get_container_status_async(\n                    instance.status.container_id\n                )\n\n                # Reconcile based on actual vs desired state\n                if container_status == \"stopped\":\n                    # Container stopped - instance should complete\n                    await self._complete_lab_instance(instance)\n                elif container_status == \"error\":\n                    # Container errored - instance should fail\n                    await self._fail_lab_instance(instance, \"Container error\")\n                elif instance.is_expired():\n                    # Policy violation - enforce timeout\n                    await self._timeout_lab_instance(instance)\n\n        except Exception as e:\n            log.error(f\"Error processing running instances: {e}\")\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#4-integration-patterns-and-event-flow","title":"4\ufe0f\u20e3 Integration Patterns and Event Flow","text":""},{"location":"patterns/watcher-reconciliation-execution/#complete-event-flow-example","title":"Complete Event Flow Example","text":"<pre><code>1. User creates LabInstanceRequest\n   \u2514\u2500 Resource saved to storage\n\n2. Watcher detects CREATED event (next poll cycle)\n   \u251c\u2500 Publishes labinstancerequest.created CloudEvent  \n   \u2514\u2500 Triggers controller.reconcile(resource)\n\n3. Controller reconciliation\n   \u251c\u2500 Checks: resource.should_start_now() \u2192 false (scheduled for later)\n   \u2514\u2500 Returns: ReconciliationResult.requeue_after(delay)\n\n4. Scheduler loop (independent polling)\n   \u251c\u2500 Finds pending instances that should start\n   \u251c\u2500 Calls _start_lab_instance(resource)\n   \u2502  \u251c\u2500 Transitions: PENDING \u2192 PROVISIONING\n   \u2502  \u251c\u2500 Creates container\n   \u2502  \u2514\u2500 Transitions: PROVISIONING \u2192 RUNNING\n   \u2514\u2500 Updates resource status in storage\n\n5. Watcher detects STATUS_UPDATED event\n   \u251c\u2500 Publishes labinstancerequest.status_updated CloudEvent\n   \u2514\u2500 Triggers controller.reconcile(resource) again\n\n6. Controller reconciliation (RUNNING phase)\n   \u251c\u2500 Calculates when instance should expire\n   \u2514\u2500 Returns: ReconciliationResult.requeue_after(remaining_time)\n\n7. Time passes... scheduler monitors container health\n\n8. Container completes/fails/times out\n   \u251c\u2500 Scheduler detects state change\n   \u251c\u2500 Updates resource: RUNNING \u2192 COMPLETED/FAILED/TIMEOUT\n   \u2514\u2500 Cleans up container resources\n\n9. Watcher detects final STATUS_UPDATED event\n   \u251c\u2500 Publishes final CloudEvent\n   \u2514\u2500 Controller reconciliation confirms no action needed\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#timing-and-coordination","title":"Timing and Coordination","text":"Component Frequency Purpose Watcher 5-10 seconds Detect changes, trigger reactive reconciliation Scheduler 30-60 seconds Proactive reconciliation, policy enforcement Controller Event-driven Handle specific resource changes"},{"location":"patterns/watcher-reconciliation-execution/#error-handling-and-resilience","title":"Error Handling and Resilience","text":"<pre><code># Watcher error handling\nasync def _watch_loop(self):\n    while self._watching:\n        try:\n            # Process changes\n            pass\n        except Exception as e:\n            log.error(f\"Watch loop error: {e}\")\n            await asyncio.sleep(self.watch_interval)  # Continue watching\n\n# Controller error handling  \nasync def reconcile(self, resource):\n    try:\n        result = await asyncio.wait_for(self._do_reconcile(resource), timeout=300)\n    except asyncio.TimeoutError:\n        # Handle timeout - mark for retry\n        result = ReconciliationResult.requeue()\n    except Exception as e:\n        # Handle error - exponential backoff\n        result = ReconciliationResult.failed(e)\n\n# Scheduler error handling\nasync def _run_scheduler_loop(self):\n    while self._running:\n        try:\n            # Process all phases\n            pass\n        except Exception as e:\n            log.error(f\"Scheduler error: {e}\")\n            await asyncio.sleep(self._scheduler_interval)  # Continue scheduling\n</code></pre>"},{"location":"patterns/watcher-reconciliation-execution/#observability-and-monitoring","title":"\ud83d\udcca Observability and Monitoring","text":""},{"location":"patterns/watcher-reconciliation-execution/#key-metrics-to-monitor","title":"Key Metrics to Monitor","text":"<pre><code># Watcher metrics\n{\n    \"watch_loop_iterations\": 1234,\n    \"changes_detected\": 56,\n    \"events_published\": 78,\n    \"cache_hit_ratio\": 0.95,\n    \"average_poll_duration\": \"150ms\"\n}\n\n# Controller metrics  \n{\n    \"reconciliations_total\": 234,\n    \"reconciliations_successful\": 220,\n    \"reconciliations_failed\": 4,\n    \"reconciliations_requeued\": 10,\n    \"average_reconciliation_time\": \"2.3s\"\n}\n\n# Scheduler metrics\n{\n    \"scheduler_loop_iterations\": 567,\n    \"resources_processed\": 890,\n    \"state_transitions\": 123,\n    \"cleanup_operations\": 45,\n    \"average_loop_duration\": \"5.2s\"\n}\n</code></pre> <p>This architecture provides a robust, scalable foundation for declarative resource management that automatically maintains desired state while being resilient to failures and providing comprehensive observability.</p>"},{"location":"patterns/watcher-reconciliation-patterns/","title":"Resource Watcher and Reconciliation Loop Patterns","text":"<p>This document explains how the Resource Watcher and Reconciliation Loop patterns work in our Resource Oriented Architecture (ROA) implementation, providing the foundation for Kubernetes-style declarative resource management.</p>"},{"location":"patterns/watcher-reconciliation-patterns/#overview","title":"\ud83c\udfaf Overview","text":"<p>The ROA implementation uses two complementary patterns:</p> <ol> <li>Resource Watcher: Detects changes to resources and emits events</li> <li>Reconciliation Loop: Continuously ensures actual state matches desired state</li> </ol> <p>These patterns work together to provide: - Declarative Management: Specify desired state, controllers make it happen - Event-Driven Processing: React to changes as they occur - Self-Healing: Automatically correct drift from desired state - Extensibility: Pluggable controllers for different resource types</p>"},{"location":"patterns/watcher-reconciliation-patterns/#resource-watcher-pattern","title":"\ud83d\udd0d Resource Watcher Pattern","text":""},{"location":"patterns/watcher-reconciliation-patterns/#how-the-watcher-works","title":"How the Watcher Works","text":"<pre><code>class ResourceWatcherBase(Generic[TResourceSpec, TResourceStatus]):\n    \"\"\"\n    The watcher follows a polling pattern:\n    1. Periodically lists resources from storage\n    2. Compares current state with cached state\n    3. Detects changes (CREATED, UPDATED, DELETED, STATUS_UPDATED)\n    4. Emits events for detected changes\n    5. Updates cache with current state\n    \"\"\"\n\n    async def _watch_loop(self, namespace=None, label_selector=None):\n        while self._watching:\n            # 1. Get current resources\n            current_resources = await self._list_resources(namespace, label_selector)\n            current_resource_map = {r.id: r for r in current_resources}\n\n            # 2. Detect changes\n            changes = self._detect_changes(current_resource_map)\n\n            # 3. Process each change\n            for change in changes:\n                await self._process_change(change)\n\n            # 4. Update cache\n            self._resource_cache = current_resource_map\n\n            # 5. Wait before next poll\n            await asyncio.sleep(self.watch_interval)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#change-detection-logic","title":"Change Detection Logic","text":"<p>The watcher detects four types of changes:</p> <pre><code>def _detect_changes(self, current_resources):\n    changes = []\n    current_ids = set(current_resources.keys())\n    cached_ids = set(self._resource_cache.keys())\n\n    # 1. CREATED: New resources that weren't in cache\n    for resource_id in current_ids - cached_ids:\n        changes.append(ResourceChangeEvent(\n            change_type=ResourceChangeType.CREATED,\n            resource=current_resources[resource_id]\n        ))\n\n    # 2. DELETED: Cached resources no longer present\n    for resource_id in cached_ids - current_ids:\n        changes.append(ResourceChangeEvent(\n            change_type=ResourceChangeType.DELETED,\n            resource=self._resource_cache[resource_id]\n        ))\n\n    # 3. UPDATED: Spec changed (generation increment)\n    # 4. STATUS_UPDATED: Status changed (observed generation, etc.)\n    for resource_id in current_ids &amp; cached_ids:\n        current = current_resources[resource_id]\n        cached = self._resource_cache[resource_id]\n\n        if current.metadata.generation &gt; cached.metadata.generation:\n            # Spec was updated\n            changes.append(ResourceChangeEvent(\n                change_type=ResourceChangeType.UPDATED,\n                resource=current,\n                old_resource=cached\n            ))\n        elif self._has_status_changed(current, cached):\n            # Status was updated\n            changes.append(ResourceChangeEvent(\n                change_type=ResourceChangeType.STATUS_UPDATED,\n                resource=current,\n                old_resource=cached\n            ))\n\n    return changes\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#event-processing-and-publishing","title":"Event Processing and Publishing","text":"<p>When changes are detected, the watcher:</p> <pre><code>async def _process_change(self, change):\n    # 1. Call registered change handlers\n    for handler in self._change_handlers:\n        if asyncio.iscoroutinefunction(handler):\n            await handler(change)\n        else:\n            handler(change)\n\n    # 2. Publish CloudEvent\n    await self._publish_change_event(change)\n\nasync def _publish_change_event(self, change):\n    event_type = f\"{resource.kind.lower()}.{change.change_type.value.lower()}\"\n\n    event = CloudEvent(\n        source=f\"watcher/{resource.kind.lower()}\",\n        type=event_type,  # e.g., \"labinstancerequest.created\"\n        subject=f\"{resource.metadata.namespace}/{resource.metadata.name}\",\n        data={\n            \"resourceUid\": resource.id,\n            \"apiVersion\": resource.api_version,\n            \"kind\": resource.kind,\n            \"changeType\": change.change_type.value,\n            \"generation\": resource.metadata.generation,\n            \"observedGeneration\": resource.status.observed_generation\n        }\n    )\n\n    await self.event_publisher.publish_async(event)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#reconciliation-loop-pattern","title":"\ud83d\udd04 Reconciliation Loop Pattern","text":""},{"location":"patterns/watcher-reconciliation-patterns/#how-reconciliation-works","title":"How Reconciliation Works","text":"<pre><code>class ResourceControllerBase(Generic[TResourceSpec, TResourceStatus]):\n    \"\"\"\n    Controllers implement the reconciliation pattern:\n    1. Receive resource change events\n    2. Compare current state with desired state\n    3. Take actions to move toward desired state\n    4. Update resource status\n    5. Emit reconciliation events\n    \"\"\"\n\n    async def reconcile(self, resource):\n        # 1. Check if reconciliation is needed\n        if not resource.needs_reconciliation():\n            return\n\n        # 2. Execute reconciliation with timeout\n        result = await asyncio.wait_for(\n            self._do_reconcile(resource),\n            timeout=self._reconciliation_timeout.total_seconds()\n        )\n\n        # 3. Handle result (success, failure, requeue)\n        await self._handle_reconciliation_result(resource, result)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#reconciliation-states","title":"Reconciliation States","text":"<p>Controllers can return different reconciliation results:</p> <pre><code>class ReconciliationStatus(Enum):\n    SUCCESS = \"Success\"          # Reconciliation completed successfully\n    FAILED = \"Failed\"            # Reconciliation failed, needs attention\n    REQUEUE = \"Requeue\"          # Retry immediately\n    REQUEUE_AFTER = \"RequeueAfter\"  # Retry after specified delay\n\n# Example usage in controller\nasync def _do_reconcile(self, resource):\n    if resource.status.phase == LabInstancePhase.PENDING:\n        if resource.should_start_now():\n            success = await self._start_lab_instance(resource)\n            return ReconciliationResult.success() if success else ReconciliationResult.requeue()\n        else:\n            # Not time to start yet, check again in 30 seconds\n            return ReconciliationResult.requeue_after(timedelta(seconds=30))\n\n    elif resource.status.phase == LabInstancePhase.RUNNING:\n        if resource.is_expired():\n            await self._stop_lab_instance(resource)\n            return ReconciliationResult.success()\n        else:\n            # Check again when it should expire\n            remaining = resource.get_remaining_duration()\n            return ReconciliationResult.requeue_after(remaining)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#integration-patterns","title":"\ud83d\udd27 Integration Patterns","text":""},{"location":"patterns/watcher-reconciliation-patterns/#pattern-1-watcher-controller-integration","title":"Pattern 1: Watcher \u2192 Controller Integration","text":"<pre><code># Watcher detects changes and triggers controller\nclass LabInstanceWatcher(ResourceWatcherBase[LabInstanceRequestSpec, LabInstanceRequestStatus]):\n    def __init__(self, repository, controller, event_publisher):\n        super().__init__(event_publisher)\n        self.repository = repository\n        self.controller = controller\n\n        # Register controller as change handler\n        self.add_change_handler(self._handle_resource_change)\n\n    async def _list_resources(self, namespace=None, label_selector=None):\n        return await self.repository.list_async(namespace=namespace)\n\n    async def _handle_resource_change(self, change):\n        \"\"\"Called when resource changes are detected.\"\"\"\n        resource = change.resource\n\n        if change.change_type in [ResourceChangeType.CREATED, ResourceChangeType.UPDATED]:\n            # Trigger reconciliation for created or updated resources\n            await self.controller.reconcile(resource)\n        elif change.change_type == ResourceChangeType.DELETED:\n            # Trigger finalization for deleted resources\n            await self.controller.finalize(resource)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#pattern-2-background-scheduler-as-reconciliation-loop","title":"Pattern 2: Background Scheduler as Reconciliation Loop","text":"<pre><code>class LabInstanceSchedulerService(HostedService):\n    \"\"\"\n    Background service that acts as a reconciliation loop:\n    1. Periodically scans all resources\n    2. Identifies resources that need reconciliation\n    3. Applies appropriate actions\n    4. Updates resource status\n    \"\"\"\n\n    async def _run_scheduler_loop(self):\n        while self._running:\n            # Reconciliation phases\n            await self._process_scheduled_instances()  # PENDING \u2192 PROVISIONING\n            await self._process_running_instances()    # RUNNING monitoring\n            await self._cleanup_expired_instances()    # TIMEOUT/CLEANUP\n\n            await asyncio.sleep(self._scheduler_interval)\n\n    async def _process_scheduled_instances(self):\n        \"\"\"Reconcile PENDING resources that should be started.\"\"\"\n        pending_instances = await self.repository.find_by_phase_async(LabInstancePhase.PENDING)\n\n        for instance in pending_instances:\n            if instance.should_start_now():\n                # Move toward desired state: PENDING \u2192 PROVISIONING \u2192 RUNNING\n                await self._start_lab_instance(instance)\n\n    async def _process_running_instances(self):\n        \"\"\"Reconcile RUNNING resources for completion/errors.\"\"\"\n        running_instances = await self.repository.find_by_phase_async(LabInstancePhase.RUNNING)\n\n        for instance in running_instances:\n            # Check actual container state vs desired state\n            container_status = await self.container_service.get_container_status_async(\n                instance.status.container_id\n            )\n\n            if container_status == \"stopped\":\n                # Actual state differs from desired, reconcile\n                await self._complete_lab_instance(instance)\n            elif instance.is_expired():\n                # Policy violation, enforce timeout\n                await self._timeout_lab_instance(instance)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#pattern-3-event-driven-reconciliation","title":"Pattern 3: Event-Driven Reconciliation","text":"<pre><code>class LabInstanceEventHandler:\n    \"\"\"Handle resource events and trigger reconciliation.\"\"\"\n\n    async def handle_lab_instance_created(self, event):\n        \"\"\"When a lab instance is created, ensure it's properly scheduled.\"\"\"\n        resource_id = event.data[\"resourceUid\"]\n        resource = await self.repository.get_by_id_async(resource_id)\n\n        if resource and resource.status.phase == LabInstancePhase.PENDING:\n            # Ensure resource is in scheduling queue\n            await self.controller.reconcile(resource)\n\n    async def handle_lab_instance_updated(self, event):\n        \"\"\"When a lab instance is updated, re-reconcile.\"\"\"\n        resource_id = event.data[\"resourceUid\"]\n        resource = await self.repository.get_by_id_async(resource_id)\n\n        if resource:\n            await self.controller.reconcile(resource)\n\n    async def handle_container_event(self, event):\n        \"\"\"When container state changes, update resource status.\"\"\"\n        container_id = event.data[\"containerId\"]\n\n        # Find resource with this container\n        instances = await self.repository.find_by_container_id_async(container_id)\n\n        for instance in instances:\n            # Reconcile to reflect new container state\n            await self.controller.reconcile(instance)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#complete-integration-example","title":"\ud83d\ude80 Complete Integration Example","text":"<p>Here's how all patterns work together:</p> <pre><code># 1. Setup watcher and controller\nwatcher = LabInstanceWatcher(repository, controller, event_publisher)\nscheduler = LabInstanceSchedulerService(repository, container_service, event_bus)\n\n# 2. Start background processes\nawait watcher.watch(namespace=\"default\")\nawait scheduler.start_async()\n\n# 3. Create a resource (triggers CREATED event)\nlab_instance = LabInstanceRequest(...)\nawait repository.save_async(lab_instance)\n\n# 4. Watcher detects CREATED event\n# 5. Watcher calls controller.reconcile(lab_instance)\n# 6. Controller checks if action needed (should_start_now?)\n# 7. If not time yet, controller returns REQUEUE_AFTER\n# 8. Scheduler loop independently checks all PENDING resources\n# 9. When time arrives, scheduler starts the lab instance\n# 10. Status update triggers STATUS_UPDATED event\n# 11. Watcher publishes CloudEvent\n# 12. Other services can react to the event\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#observability-and-monitoring","title":"\ud83d\udcca Observability and Monitoring","text":"<p>Both patterns provide rich observability:</p>"},{"location":"patterns/watcher-reconciliation-patterns/#watcher-metrics","title":"Watcher Metrics","text":"<pre><code>watcher_metrics = {\n    \"is_watching\": watcher.is_watching(),\n    \"cached_resources\": watcher.get_cached_resource_count(),\n    \"watch_interval\": watcher.watch_interval,\n    \"events_published\": watcher.events_published_count,\n    \"change_handlers\": len(watcher._change_handlers)\n}\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#controller-metrics","title":"Controller Metrics","text":"<pre><code>controller_metrics = {\n    \"reconciliations_total\": controller.reconciliation_count,\n    \"reconciliations_successful\": controller.success_count,\n    \"reconciliations_failed\": controller.failure_count,\n    \"average_reconciliation_duration\": controller.avg_duration,\n    \"pending_reconciliations\": controller.queue_size\n}\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#scheduler-metrics","title":"Scheduler Metrics","text":"<pre><code>scheduler_metrics = {\n    \"running\": scheduler._running,\n    \"scheduler_interval\": scheduler._scheduler_interval,\n    \"instances_by_phase\": {\n        phase.value: await repository.count_by_phase_async(phase)\n        for phase in LabInstancePhase\n    },\n    \"processed_this_cycle\": scheduler.processed_count\n}\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#configuration-and-tuning","title":"\u2699\ufe0f Configuration and Tuning","text":""},{"location":"patterns/watcher-reconciliation-patterns/#watcher-configuration","title":"Watcher Configuration","text":"<pre><code>watcher = LabInstanceWatcher(\n    repository=repository,\n    controller=controller,\n    event_publisher=event_publisher,\n    watch_interval=5.0  # Poll every 5 seconds\n)\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#controller-configuration","title":"Controller Configuration","text":"<pre><code>controller = LabInstanceController(\n    service_provider=service_provider,\n    event_publisher=event_publisher\n)\ncontroller._reconciliation_timeout = timedelta(minutes=10)\ncontroller._max_retry_attempts = 5\n</code></pre>"},{"location":"patterns/watcher-reconciliation-patterns/#scheduler-configuration","title":"Scheduler Configuration","text":"<pre><code>scheduler = LabInstanceSchedulerService(\n    repository=repository,\n    container_service=container_service,\n    event_bus=event_bus\n)\nscheduler._scheduler_interval = 30      # 30 second reconciliation loop\nscheduler._cleanup_interval = 300       # 5 minute cleanup cycle\n</code></pre> <p>This architecture provides a robust, observable, and extensible foundation for managing resources in a declarative, Kubernetes-style manner while integrating seamlessly with traditional CQRS patterns.</p>"},{"location":"samples/","title":"\ud83d\udcbc Sample Applications","text":"<p>Comprehensive sample applications that demonstrate real-world implementation of the Neuroglia framework. Each sample showcases different architectural patterns, integration scenarios, and business domains to provide practical guidance for building production-ready systems.</p>"},{"location":"samples/#production-ready-examples","title":"\ud83c\udfe6 Production-Ready Examples","text":""},{"location":"samples/#openbank-event-sourcing-banking-system","title":"\ud83c\udfe6 OpenBank - Event Sourcing Banking System","text":"<p>A complete banking system demonstrating event sourcing, CQRS, and financial domain modeling. Shows how to handle complex business rules, audit trails, and regulatory compliance.</p> <p>Domain Focus:</p> <ul> <li>Account management</li> <li>Transaction processing</li> <li>Balance calculations</li> <li>Regulatory compliance</li> </ul> <p>Key Patterns:</p> <ul> <li>Event sourcing with snapshots</li> <li>Complex domain aggregates</li> <li>Financial calculations with precision</li> <li>Audit trail implementation</li> </ul> <p>Technology Stack:</p> <ul> <li>EventStoreDB for event persistence</li> <li>MongoDB for read models</li> <li>FastAPI for REST APIs</li> <li>Comprehensive test coverage</li> </ul>"},{"location":"samples/#api-gateway-microservice-orchestration","title":"\ud83c\udf10 API Gateway - Microservice Orchestration","text":"<p>Demonstrates microservice coordination, request routing, and cross-cutting concerns like authentication, rate limiting, and monitoring.</p> <p>Domain Focus:</p> <ul> <li>Service discovery and routing</li> <li>Authentication and authorization</li> <li>Request/response transformation</li> <li>Circuit breaker patterns</li> </ul> <p>Key Patterns:</p> <ul> <li>Gateway aggregation pattern</li> <li>Service mesh integration</li> <li>Distributed tracing</li> <li>Health check orchestration</li> </ul> <p>Technology Stack:</p> <ul> <li>FastAPI for gateway implementation</li> <li>Redis for caching and rate limiting</li> <li>Prometheus for metrics</li> <li>Distributed logging</li> </ul>"},{"location":"samples/#desktop-controller-background-services","title":"\ud83d\udda5\ufe0f Desktop Controller - Background Services","text":"<p>Shows how to build background services that interact with system resources, handle long-running operations, and manage desktop environments.</p> <p>Domain Focus:</p> <ul> <li>System resource management</li> <li>Process orchestration</li> <li>File system operations</li> <li>Desktop environment control</li> </ul> <p>Key Patterns:</p> <ul> <li>Background service patterns</li> <li>Resource locking mechanisms</li> <li>Process lifecycle management</li> <li>System integration patterns</li> </ul> <p>Technology Stack:</p> <ul> <li>Background service hosting</li> <li>File system watchers</li> <li>System API integration</li> <li>Inter-process communication</li> </ul>"},{"location":"samples/#lab-resource-manager-kubernetes-operator","title":"\ud83e\uddea Lab Resource Manager - Kubernetes Operator","text":"<p>Kubernetes operator pattern implementation for managing laboratory resources, demonstrating watcher patterns, reconciliation loops, and cloud-native development.</p> <p>Domain Focus:</p> <ul> <li>Laboratory equipment management</li> <li>Resource allocation and scheduling</li> <li>Experiment workflow orchestration</li> <li>Usage tracking and reporting</li> </ul> <p>Key Patterns:</p> <ul> <li>Kubernetes operator pattern</li> <li>Watcher and reconciliation loops</li> <li>Resource state management</li> <li>Cloud-native architecture</li> </ul> <p>Technology Stack:</p> <ul> <li>Kubernetes API integration</li> <li>Custom Resource Definitions (CRDs)</li> <li>Controller runtime</li> <li>Cloud storage integration</li> </ul>"},{"location":"samples/#sample-application-architecture","title":"\ud83c\udfaf Sample Application Architecture","text":"<p>Each sample demonstrates different architectural focuses:</p> <pre><code>graph TB\n    subgraph \"\ud83c\udfe6 OpenBank\"\n        ES[Event Sourcing]\n        CQRS1[CQRS]\n        BANK[Banking Domain]\n    end\n\n    subgraph \"\ud83c\udf10 API Gateway\"\n        RT[Request Routing]\n        AUTH[Authentication]\n        RATE[Rate Limiting]\n    end\n\n    subgraph \"\ud83d\udda5\ufe0f Desktop Controller\"\n        BG[Background Services]\n        SYS[System Integration]\n        PROC[Process Management]\n    end\n\n    subgraph \"\ud83e\uddea Lab Resource Manager\"\n        K8S[Kubernetes Operator]\n        WATCH[Watcher Patterns]\n        REC[Reconciliation]\n    end\n\n    subgraph \"\ud83c\udfaf Common Patterns\"\n        CA[Clean Architecture]\n        DI[Dependency Injection]\n        TEST[Testing Strategies]\n    end\n\n    ES --&gt; CA\n    CQRS1 --&gt; CA\n    RT --&gt; CA\n    BG --&gt; CA\n    K8S --&gt; CA\n\n    CA --&gt; DI\n    CA --&gt; TEST\n\n    style ES fill:#e8f5e8\n    style RT fill:#e3f2fd\n    style BG fill:#fff3e0\n    style K8S fill:#f3e5f5\n    style CA fill:#fce4ec</code></pre>"},{"location":"samples/#getting-started-with-samples","title":"\ud83d\ude80 Getting Started with Samples","text":""},{"location":"samples/#quick-start-guide","title":"Quick Start Guide","text":"<ol> <li>Choose Your Domain: Select the sample that matches your use case</li> <li>Review Architecture: Understand the patterns and structure</li> <li>Run Locally: Follow setup instructions for local development</li> <li>Explore Code: Study the implementation details</li> <li>Adapt and Extend: Customize for your specific needs</li> </ol>"},{"location":"samples/#sample-complexity-levels","title":"Sample Complexity Levels","text":""},{"location":"samples/#beginner-level","title":"\ud83d\udfe2 Beginner Level","text":"<ul> <li>Desktop Controller: Straightforward background services</li> <li>Clear separation of concerns</li> <li>Basic integration patterns</li> </ul>"},{"location":"samples/#intermediate-level","title":"\ud83d\udfe1 Intermediate Level","text":"<ul> <li>API Gateway: Microservice coordination</li> <li>Cross-cutting concerns implementation</li> <li>Distributed system patterns</li> </ul>"},{"location":"samples/#advanced-level","title":"\ud83d\udd34 Advanced Level","text":"<ul> <li>OpenBank: Complex event sourcing</li> <li>Lab Resource Manager: Kubernetes operators</li> <li>Advanced domain modeling</li> </ul>"},{"location":"samples/#development-and-testing","title":"\ud83e\uddea Development and Testing","text":""},{"location":"samples/#local-development-setup","title":"Local Development Setup","text":"<p>Each sample includes:</p> <ul> <li>Docker Compose: Complete local environment</li> <li>Development Scripts: Build, test, and run commands</li> <li>Database Migrations: Schema and data setup</li> <li>Mock Services: External dependency simulation</li> </ul>"},{"location":"samples/#testing-strategies","title":"Testing Strategies","text":"<pre><code>graph LR\n    A[Unit Tests&lt;br/&gt;\ud83e\uddea Components] --&gt; B[Integration Tests&lt;br/&gt;\ud83d\udd17 Services]\n    B --&gt; C[End-to-End Tests&lt;br/&gt;\ud83c\udfaf Workflows]\n    C --&gt; D[Performance Tests&lt;br/&gt;\u26a1 Load Testing]\n\n    style A fill:#e8f5e8\n    style B fill:#e3f2fd\n    style C fill:#fff3e0\n    style D fill:#f3e5f5</code></pre>"},{"location":"samples/#deployment-options","title":"Deployment Options","text":"<ul> <li>Local Development: Docker Compose environments</li> <li>Cloud Deployment: Kubernetes manifests and Helm charts</li> <li>CI/CD Pipelines: GitHub Actions and Jenkins examples</li> <li>Monitoring Setup: Observability and logging configuration</li> </ul>"},{"location":"samples/#sample-comparison-matrix","title":"\ud83d\udcca Sample Comparison Matrix","text":"Feature OpenBank API Gateway Desktop Controller Lab Resource Manager Complexity \ud83d\udd34 Advanced \ud83d\udfe1 Intermediate \ud83d\udfe2 Beginner \ud83d\udd34 Advanced Domain Financial Integration System Scientific Architecture Event Sourcing Gateway Pattern Background Services Operator Pattern Storage EventStore + Mongo Redis + SQL File System Kubernetes etcd Integration REST APIs Multiple Services System APIs Kubernetes APIs Deployment Cloud/On-Premise Cloud Native Desktop/Server Kubernetes Only"},{"location":"samples/#learning-outcomes","title":"\ud83c\udf93 Learning Outcomes","text":""},{"location":"samples/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Real-world Implementation: See patterns in action</li> <li>Best Practices: Production-ready code examples</li> <li>Testing Strategies: Comprehensive test coverage</li> <li>Deployment Patterns: Multiple deployment scenarios</li> <li>Performance Optimization: Scalability considerations</li> </ul>"},{"location":"samples/#skills-developed","title":"Skills Developed","text":"<ul> <li>Architecture Design: Pattern selection and implementation</li> <li>Domain Modeling: Business logic representation</li> <li>Integration Patterns: External system coordination</li> <li>Testing Mastery: Test strategy development</li> <li>Operations Knowledge: Deployment and monitoring</li> </ul>"},{"location":"samples/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\ud83c\udfaf Architecture Patterns - Foundational design patterns</li> <li>\ud83d\ude80 Framework Features - Detailed feature documentation</li> <li>\ud83d\udcd6 Implementation Guides - Step-by-step tutorials</li> <li>\ud83c\udf55 Mario's Pizzeria - Unified domain example</li> </ul>"},{"location":"samples/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ol> <li>Explore Sample Code: Clone and run the samples locally</li> <li>Study Implementation: Review architecture decisions and patterns</li> <li>Adapt for Your Needs: Use samples as starting templates</li> <li>Contribute Back: Share improvements and additional samples</li> </ol> <p>Each sample application is production-ready and includes comprehensive documentation, tests, and deployment guides. They serve as both learning resources and starting templates for your own applications.</p>"},{"location":"samples/api_gateway/","title":"\ud83d\ude80 API Gateway Sample Application","text":"<p>The API Gateway sample demonstrates how to build a modern microservice gateway using the Neuroglia framework. This application showcases advanced patterns including OAuth2 authentication, external service integration, background task processing, and cloud event handling.</p>"},{"location":"samples/api_gateway/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>Microservice Gateway Patterns: How to build a centralized API gateway for service orchestration</li> <li>OAuth2 Authentication &amp; Authorization: Implementing JWT-based security with Keycloak integration</li> <li>External Service Integration: Connecting to multiple external APIs with proper abstraction</li> <li>Background Task Processing: Asynchronous task execution with Redis-backed job scheduling</li> <li>Object Storage Integration: File management with MinIO S3-compatible storage</li> <li>Cloud Events: Event-driven communication between microservices</li> <li>Advanced Dependency Injection: Complex service configuration and lifetime management</li> </ul>"},{"location":"samples/api_gateway/#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<pre><code>graph TB\n    subgraph \"API Gateway Service\"\n        A[PromptController] --&gt; B[Mediator]\n        B --&gt; C[Command/Query Handlers]\n        C --&gt; D[Domain Models]\n        C --&gt; E[Integration Services]\n\n        F[OAuth2 Middleware] --&gt; A\n        G[Cloud Event Middleware] --&gt; A\n        H[Exception Handling] --&gt; A\n    end\n\n    subgraph \"External Dependencies\"\n        I[Keycloak OAuth2]\n        J[Redis Cache]\n        K[MinIO Storage]\n        L[External APIs]\n        M[Background Tasks]\n    end\n\n    E --&gt; I\n    E --&gt; J\n    E --&gt; K\n    E --&gt; L\n    C --&gt; M</code></pre> <p>The API Gateway follows a distributed microservice pattern where:</p> <ul> <li>Gateway Layer: Centralized entry point for multiple downstream services</li> <li>Authentication Layer: OAuth2/JWT-based security with external identity provider</li> <li>Integration Layer: Multiple external service clients with proper abstraction</li> <li>DTOs: Data transfer objects for external communication</li> </ul>"},{"location":"samples/api_gateway/#key-features-demonstrated","title":"\ud83d\ude80 Key Features Demonstrated","text":""},{"location":"samples/api_gateway/#1-oauth2-authentication-security","title":"1. OAuth2 Authentication &amp; Security","text":"<pre><code># JWT token validation with Keycloak\n@post(\"/item\", response_model=ItemPromptCommandResponseDto)\nasync def create_new_item_prompt(\n    self, \n    command_dto: CreateNewItemPromptCommandDto, \n    key: str = Depends(validate_mosaic_authentication)\n) -&gt; Any:\n    # Protected endpoint with API key validation\n</code></pre>"},{"location":"samples/api_gateway/#2-multi-service-integration","title":"2. Multi-Service Integration","text":"<pre><code># External service clients\nMinioStorageManager.configure(builder)          # Object storage\nMosaicApiClient.configure(builder)              # External API\nAsyncStringCacheRepository.configure(builder)   # Redis caching\nBackgroundTaskScheduler.configure(builder)      # Async processing\n</code></pre>"},{"location":"samples/api_gateway/#3-advanced-domain-model","title":"3. Advanced Domain Model","text":"<pre><code>@map_to(PromptResponseDto)\n@dataclass\nclass PromptResponse:\n    id: str\n    prompt_id: str\n    content: str\n    status: PromptStatus\n    metadata: dict[str, Any]\n    created_at: datetime.datetime\n</code></pre>"},{"location":"samples/api_gateway/#4-background-task-processing","title":"4. Background Task Processing","text":"<pre><code># Asynchronous task execution\nBackgroundTaskScheduler.configure(builder, [\"application.tasks\"])\n\n# Redis-backed job queue\nbackground_job_store: dict[str, str | int] = {\n    \"redis_host\": \"redis47\", \n    \"redis_port\": 6379, \n    \"redis_db\": 0\n}\n</code></pre>"},{"location":"samples/api_gateway/#5-cloud-events-integration","title":"5. Cloud Events Integration","text":"<pre><code># Event publishing and consumption\nCloudEventIngestor.configure(builder, [\"application.events.integration\"])\nCloudEventPublisher.configure(builder)\napp.add_middleware(CloudEventMiddleware, service_provider=app.services)\n</code></pre>"},{"location":"samples/api_gateway/#configuration-settings","title":"\ud83d\udd27 Configuration &amp; Settings","text":""},{"location":"samples/api_gateway/#application-settings","title":"Application Settings","text":"<pre><code>class AiGatewaySettings(ApplicationSettings):\n    # OAuth2 Configuration\n    jwt_authority: str = \"http://keycloak47/realms/mozart\"\n    jwt_audience: str = \"ai-gateways\"\n    required_scope: str = \"api\"\n\n    # External Service Settings\n    s3_endpoint: str                    # MinIO storage\n    connection_strings: dict[str, str]  # Redis, databases\n    mosaic_api_keys: list[str]         # API authentication\n\n    # Background Processing\n    background_job_store: dict[str, str | int]\n    redis_max_connections: int = 10\n</code></pre>"},{"location":"samples/api_gateway/#service-registration","title":"Service Registration","text":"<pre><code># Core framework services\nMapper.configure(builder, application_modules)\nMediator.configure(builder, application_modules)\nJsonSerializer.configure(builder)\n\n# Custom application services\nAsyncStringCacheRepository.configure(builder, Prompt, str)\nBackgroundTaskScheduler.configure(builder, [\"application.tasks\"])\nMinioStorageManager.configure(builder)\nLocalFileSystemManager.configure(builder)\n\n# External integrations\nbuilder.services.add_singleton(AiGatewaySettings, singleton=app_settings)\n</code></pre>"},{"location":"samples/api_gateway/#testing-strategy","title":"\ud83e\uddea Testing Strategy","text":""},{"location":"samples/api_gateway/#unit-tests","title":"Unit Tests","text":"<pre><code>class TestPromptController:\n    def setup_method(self):\n        self.mock_mediator = Mock(spec=Mediator)\n        self.mock_mapper = Mock(spec=Mapper)\n        self.controller = PromptController(\n            service_provider=Mock(),\n            mapper=self.mock_mapper,\n            mediator=self.mock_mediator\n        )\n\n    @pytest.mark.asyncio\n    async def test_create_prompt_success(self):\n        # Test successful prompt creation\n        command_dto = CreateNewItemPromptCommandDto(content=\"test\")\n        result = await self.controller.create_new_item_prompt(command_dto, \"valid-key\")\n\n        assert result.status == \"created\"\n        self.mock_mediator.execute_async.assert_called_once()\n</code></pre>"},{"location":"samples/api_gateway/#integration-tests","title":"Integration Tests","text":"<pre><code>@pytest.mark.integration\nclass TestApiGatewayIntegration:\n    @pytest.mark.asyncio\n    async def test_full_prompt_workflow(self, test_client):\n        # Test complete workflow from API to external services\n        response = await test_client.post(\n            \"/api/prompts/item\",\n            json={\"content\": \"test prompt\"},\n            headers={\"Authorization\": \"Bearer valid-token\"}\n        )\n\n        assert response.status_code == 201\n        assert \"id\" in response.json()\n</code></pre>"},{"location":"samples/api_gateway/#implementation-details","title":"\ud83d\udcda Implementation Details","text":""},{"location":"samples/api_gateway/#1-controller-layer-apicontrollers","title":"1. Controller Layer (<code>api/controllers/</code>)","text":"<ul> <li>PromptController: Main API endpoints for prompt management</li> <li>AppController: Application health and metadata endpoints</li> <li>InternalController: Internal service endpoints</li> <li>Authentication Schemes: OAuth2 and API key validation</li> </ul>"},{"location":"samples/api_gateway/#2-application-layer-application","title":"2. Application Layer (<code>application/</code>)","text":"<ul> <li>Commands: Write operations (CreateNewPromptCommand)</li> <li>Queries: Read operations (GetPromptByIdQuery)</li> <li>Services: Business logic orchestration</li> <li>Tasks: Background job definitions</li> <li>Events: Integration event handlers</li> </ul>"},{"location":"samples/api_gateway/#3-domain-layer-domain","title":"3. Domain Layer (<code>domain/</code>)","text":"<ul> <li>Prompt: Core domain entity with business rules</li> <li>PromptResponse: Value object for API responses</li> <li>Domain Events: Business event definitions</li> <li>Validation: Domain-specific validation logic</li> </ul>"},{"location":"samples/api_gateway/#4-integration-layer-integration","title":"4. Integration Layer (<code>integration/</code>)","text":"<ul> <li>External API Clients: Mosaic, GenAI, Mozart APIs</li> <li>Storage Services: MinIO object storage, Redis caching</li> <li>Background Services: Task scheduling and execution</li> <li>DTOs: Data transfer objects for external communication</li> </ul>"},{"location":"samples/api_gateway/#background-processing","title":"\ud83d\udd04 Background Processing","text":"<p>The API Gateway demonstrates advanced background processing patterns:</p> <pre><code># Task scheduling configuration\nBackgroundTaskScheduler.configure(builder, [\"application.tasks\"])\n\n# Redis-backed job store\nbuilder.services.add_singleton(AiGatewaySettings, singleton=app_settings)\n\n# Asynchronous task execution\n@task_handler\nclass ProcessPromptTask:\n    async def execute_async(self, prompt_id: str):\n        # Long-running prompt processing\n        prompt = await self.prompt_service.get_by_id(prompt_id)\n        result = await self.genai_client.process_prompt(prompt)\n        await self.storage_service.store_result(result)\n</code></pre>"},{"location":"samples/api_gateway/#external-service-integration","title":"\ud83c\udf10 External Service Integration","text":""},{"location":"samples/api_gateway/#minio-object-storage","title":"MinIO Object Storage","text":"<pre><code>class MinioStorageManager:\n    async def upload_file_async(self, bucket: str, key: str, data: bytes) -&gt; str:\n        # S3-compatible object storage\n        return await self.client.put_object(bucket, key, data)\n</code></pre>"},{"location":"samples/api_gateway/#redis-caching","title":"Redis Caching","text":"<pre><code>class AsyncStringCacheRepository:\n    async def get_async(self, key: str) -&gt; Optional[str]:\n        return await self.redis_client.get(key)\n\n    async def set_async(self, key: str, value: str, ttl: int = None):\n        await self.redis_client.set(key, value, ex=ttl)\n</code></pre>"},{"location":"samples/api_gateway/#external-api-integration","title":"External API Integration","text":"<pre><code>class MosaicApiClient:\n    async def submit_prompt_async(self, prompt: PromptDto) -&gt; PromptResponseDto:\n        # OAuth2 authenticated API calls\n        token = await self.get_access_token()\n        response = await self.http_client.post(\n            \"/api/prompts\",\n            json=prompt.dict(),\n            headers={\"Authorization\": f\"Bearer {token}\"}\n        )\n        return PromptResponseDto.parse_obj(response.json())\n</code></pre>"},{"location":"samples/api_gateway/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"samples/api_gateway/#1-prerequisites","title":"1. Prerequisites","text":"<pre><code># Install dependencies\npip install -r requirements.txt\n\n# Configure external services\ndocker-compose up -d redis keycloak minio\n</code></pre>"},{"location":"samples/api_gateway/#2-configuration","title":"2. Configuration","text":"<pre><code># Set environment variables\nexport JWT_AUTHORITY=\"http://localhost:8080/realms/mozart\"\nexport S3_ENDPOINT=\"http://localhost:9000\"\nexport REDIS_URL=\"redis://localhost:6379\"\n</code></pre>"},{"location":"samples/api_gateway/#3-run-the-application","title":"3. Run the Application","text":"<pre><code># Start the API Gateway\npython samples/api-gateway/main.py\n\n# Access Swagger UI\nopen http://localhost:8000/docs\n</code></pre>"},{"location":"samples/api_gateway/#4-test-the-api","title":"4. Test the API","text":"<pre><code># Get access token from Keycloak\ncurl -X POST http://localhost:8080/realms/mozart/protocol/openid-connect/token \\\n  -H \"Content-Type: application/x-www-form-urlencoded\" \\\n  -d \"grant_type=client_credentials&amp;client_id=ai-gateway&amp;client_secret=secret\"\n\n# Call protected endpoint\ncurl -X POST http://localhost:8000/api/prompts/item \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"content\": \"Generate a sample prompt\"}'\n</code></pre>"},{"location":"samples/api_gateway/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>CQRS &amp; Mediation - Command/Query patterns</li> <li>Dependency Injection - Service configuration</li> <li>Data Access - Repository patterns</li> <li>OpenBank Sample - Event sourcing comparison</li> <li>Desktop Controller Sample - Background services</li> </ul>"},{"location":"samples/api_gateway/#comparison-with-openbank-sample","title":"\ud83d\udd0d Comparison with OpenBank Sample","text":"<p>The API Gateway and OpenBank samples demonstrate different architectural patterns within the Neuroglia framework. Here's a detailed comparison:</p>"},{"location":"samples/api_gateway/#architecture-patterns","title":"Architecture Patterns","text":"Aspect API Gateway OpenBank Primary Pattern Microservice Gateway Event Sourcing + DDD Data Persistence Multi-store (Redis, MinIO, MongoDB) Event Store + Read Models State Management Stateless with caching Event-sourced aggregates External Integration Multiple external APIs Focused domain model Background Processing Async task queues Event-driven projections"},{"location":"samples/api_gateway/#domain-complexity","title":"Domain Complexity","text":""},{"location":"samples/api_gateway/#api-gateway-integration-focused","title":"API Gateway - Integration-Focused","text":"<pre><code># Simple domain model focused on orchestration\n@dataclass\nclass PromptResponse:\n    id: str\n    prompt_id: str\n    content: str\n    status: PromptStatus\n    metadata: dict[str, Any]\n</code></pre>"},{"location":"samples/api_gateway/#openbank-rich-domain-model","title":"OpenBank - Rich Domain Model","text":"<pre><code># Complex aggregate with business rules\nclass BankAccountV1(AggregateRoot[str]):\n    def record_transaction(self, amount: Decimal, transaction_type: BankTransactionTypeV1):\n        # Complex business logic and invariants\n        if transaction_type == BankTransactionTypeV1.DEBIT:\n            if self.state.balance + amount &lt; -self.state.overdraft_limit:\n                raise InsufficientFundsException()\n\n        # Event sourcing\n        self.raise_event(BankAccountTransactionRecordedDomainEventV1(...))\n</code></pre>"},{"location":"samples/api_gateway/#data-persistence-strategy","title":"Data Persistence Strategy","text":""},{"location":"samples/api_gateway/#api-gateway-multi-store-architecture","title":"API Gateway - Multi-Store Architecture","text":"<pre><code># Multiple specialized storage systems\nAsyncStringCacheRepository.configure(builder, Prompt, str)  # Redis caching\nMinioStorageManager.configure(builder)                      # Object storage\nBackgroundTaskScheduler.configure(builder)                 # Job queue\n\n# Standard CRUD operations\nasync def save_prompt(self, prompt: Prompt):\n    await self.cache_repository.set_async(prompt.id, prompt.content)\n    await self.storage_manager.upload_async(prompt.id, prompt.data)\n</code></pre>"},{"location":"samples/api_gateway/#openbank-event-sourcing","title":"OpenBank - Event Sourcing","text":"<pre><code># Event-driven persistence\nESEventStore.configure(builder, EventStoreOptions(database_name, consumer_group))\n\n# Write model: Event sourcing\nDataAccessLayer.WriteModel.configure(\n    builder, \n    [\"samples.openbank.domain.models\"], \n    lambda builder_, entity_type, key_type: EventSourcingRepository.configure(...)\n)\n\n# Read model: Projections\nDataAccessLayer.ReadModel.configure(\n    builder,\n    [\"samples.openbank.integration.models\"], \n    lambda builder_, entity_type, key_type: MongoRepository.configure(...)\n)\n</code></pre>"},{"location":"samples/api_gateway/#authentication-security","title":"Authentication &amp; Security","text":""},{"location":"samples/api_gateway/#api-gateway-oauth2-api-keys","title":"API Gateway - OAuth2 + API Keys","text":"<pre><code># Multiple authentication schemes\n@post(\"/item\", dependencies=[Depends(validate_mosaic_authentication)])\nasync def create_item_prompt(self, command_dto: CreateNewItemPromptCommandDto):\n    # API key validation for external services\n\n@get(\"/status\", dependencies=[Depends(validate_token)])\nasync def get_status(self):\n    # JWT token validation for internal services\n</code></pre>"},{"location":"samples/api_gateway/#openbank-domain-focused-security","title":"OpenBank - Domain-Focused Security","text":"<pre><code># Business rule enforcement\nclass BankAccountV1(AggregateRoot[str]):\n    def record_transaction(self, amount: Decimal, transaction_type: BankTransactionTypeV1):\n        # Domain-level authorization\n        if not self.is_authorized_for_transaction(amount):\n            raise UnauthorizedTransactionException()\n</code></pre>"},{"location":"samples/api_gateway/#external-service-integration_1","title":"External Service Integration","text":""},{"location":"samples/api_gateway/#api-gateway-extensive-integration","title":"API Gateway - Extensive Integration","text":"<pre><code># Multiple external service clients\nclass MosaicApiClient:\n    async def submit_prompt_async(self, prompt: PromptDto) -&gt; PromptResponseDto:\n        token = await self.oauth_client.get_token_async()\n        return await self.http_client.post(\"/api/prompts\", prompt, token)\n\nclass GenAiClient:\n    async def process_prompt_async(self, prompt: str) -&gt; str:\n        return await self.ai_service.generate_response(prompt)\n\nclass MinioStorageManager:\n    async def store_file_async(self, bucket: str, key: str, data: bytes):\n        return await self.s3_client.put_object(bucket, key, data)\n</code></pre>"},{"location":"samples/api_gateway/#openbank-minimal-integration","title":"OpenBank - Minimal Integration","text":"<pre><code># Focused on domain logic, minimal external dependencies\nclass CreateBankAccountCommandHandler:\n    async def handle_async(self, command: CreateBankAccountCommand):\n        # Pure domain logic without external service calls\n        owner = await self.person_repository.get_by_id_async(command.owner_id)\n        account = BankAccountV1(str(uuid.uuid4()), owner, command.initial_balance)\n        await self.account_repository.save_async(account)\n</code></pre>"},{"location":"samples/api_gateway/#background-processing_1","title":"Background Processing","text":""},{"location":"samples/api_gateway/#api-gateway-task-queue-pattern","title":"API Gateway - Task Queue Pattern","text":"<pre><code># Redis-backed job queues\nBackgroundTaskScheduler.configure(builder, [\"application.tasks\"])\n\n@task_handler\nclass ProcessPromptTask:\n    async def execute_async(self, prompt_id: str):\n        prompt = await self.prompt_service.get_by_id(prompt_id)\n        result = await self.genai_client.process_prompt(prompt)\n        await self.storage_service.store_result(result)\n</code></pre>"},{"location":"samples/api_gateway/#openbank-event-driven-projections","title":"OpenBank - Event-Driven Projections","text":"<pre><code># Event handlers for read model updates\nclass BankAccountEventHandler:\n    @event_handler(BankAccountCreatedDomainEventV1)\n    async def handle_account_created(self, event: BankAccountCreatedDomainEventV1):\n        projection = BankAccountProjection.from_event(event)\n        await self.read_model_repository.save_async(projection)\n</code></pre>"},{"location":"samples/api_gateway/#testing-strategies","title":"Testing Strategies","text":""},{"location":"samples/api_gateway/#api-gateway-integration-heavy-testing","title":"API Gateway - Integration-Heavy Testing","text":"<pre><code>@pytest.mark.integration\nclass TestApiGatewayIntegration:\n    async def test_full_prompt_workflow(self, test_client, mock_external_services):\n        # Test complete workflow including external services\n        response = await test_client.post(\"/api/prompts/item\", json=prompt_data)\n\n        # Verify external service calls\n        mock_external_services.genai_client.process_prompt.assert_called_once()\n        mock_external_services.storage_manager.upload.assert_called_once()\n</code></pre>"},{"location":"samples/api_gateway/#openbank-domain-focused-testing","title":"OpenBank - Domain-Focused Testing","text":"<pre><code>class TestBankAccountAggregate:\n    def test_transaction_recording(self):\n        # Pure domain logic testing\n        account = BankAccountV1(\"123\", owner, Decimal(\"1000\"))\n        account.record_transaction(Decimal(\"-100\"), BankTransactionTypeV1.DEBIT)\n\n        # Verify business rules and events\n        assert account.state.balance == Decimal(\"900\")\n        events = account.get_uncommitted_events()\n        assert isinstance(events[-1], BankAccountTransactionRecordedDomainEventV1)\n</code></pre>"},{"location":"samples/api_gateway/#use-case-recommendations","title":"Use Case Recommendations","text":""},{"location":"samples/api_gateway/#choose-api-gateway-pattern-when","title":"Choose API Gateway Pattern when","text":"<ul> <li>\u2705 Building microservice orchestration layers</li> <li>\u2705 Integrating multiple external services</li> <li>\u2705 Need background job processing</li> <li>\u2705 Require complex authentication schemes</li> <li>\u2705 Working with heterogeneous data stores</li> <li>\u2705 Building service mesh entry points</li> </ul>"},{"location":"samples/api_gateway/#choose-event-sourcing-pattern-when","title":"Choose Event Sourcing Pattern when","text":"<ul> <li>\u2705 Need complete audit trails</li> <li>\u2705 Complex business logic and invariants</li> <li>\u2705 Temporal queries are important</li> <li>\u2705 Regulatory compliance requirements</li> <li>\u2705 High consistency requirements</li> <li>\u2705 Rich domain models with behavior</li> </ul>"},{"location":"samples/api_gateway/#framework-features-utilized","title":"Framework Features Utilized","text":"Feature API Gateway Usage OpenBank Usage CQRS/Mediation Service orchestration Domain command/query separation Dependency Injection External service clients Repository abstractions Event Handling Integration events Domain events + projections Data Access Multi-repository pattern Event sourcing + read models Background Processing Async task queues Event-driven handlers Mapping DTO transformations Domain-to-DTO mapping Validation API contract validation Business rule enforcement <p>Both samples showcase different strengths of the Neuroglia framework, demonstrating its flexibility in supporting various architectural patterns while maintaining clean architecture principles.</p>"},{"location":"samples/desktop_controller/","title":"\ud83d\udda5\ufe0f Desktop Controller Sample Application","text":"<p>The Desktop Controller sample demonstrates how to build a remote desktop management system using the Neuroglia framework. This application showcases system integration patterns including SSH-based remote control, background service registration, cloud event publishing, and OAuth2 security for enterprise desktop management.</p>"},{"location":"samples/desktop_controller/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>Remote System Control: SSH-based command execution on host systems</li> <li>Background Service Patterns: Periodic self-registration and heartbeat services</li> <li>Cloud Event Publishing: Automated service discovery and registration events</li> <li>System Integration: Host system information gathering and state management</li> <li>OAuth2 Security: Enterprise authentication with secure SSH key management</li> <li>File System Integration: Remote file management and data persistence</li> <li>Docker Host Communication: Container-to-host communication patterns</li> </ul>"},{"location":"samples/desktop_controller/#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":"<pre><code>graph TB\n    subgraph \"Desktop Controller Service\"\n        A[HostController] --&gt; B[Mediator]\n        B --&gt; C[Command/Query Handlers]\n        C --&gt; D[Domain Models]\n        C --&gt; E[SSH Integration Services]\n\n        F[OAuth2 Middleware] --&gt; A\n        G[Background Registrator] --&gt; H[Cloud Event Bus]\n        I[SSH Client] --&gt; J[Docker Host]\n\n        C --&gt; K[File System Repository]\n        K --&gt; I\n    end\n\n    subgraph \"External Dependencies\"\n        L[Keycloak OAuth2]\n        M[Desktop Registry]\n        N[Docker Host/VM]\n        O[Remote File System]\n    end\n\n    F --&gt; L\n    H --&gt; M\n    I --&gt; N\n    K --&gt; O\n\n    style A fill:#e1f5fe\n    style G fill:#f3e5f5\n    style I fill:#fff3e0</code></pre> <p>This architecture enables secure remote control of desktop systems through containerized services that communicate with their host environments via SSH while maintaining enterprise security standards.</p>"},{"location":"samples/desktop_controller/#key-features-demonstrated","title":"\ud83d\ude80 Key Features Demonstrated","text":""},{"location":"samples/desktop_controller/#1-ssh-based-remote-control","title":"1. SSH-Based Remote Control","text":"<pre><code># Secure command execution on host systems\nclass SecuredHost:\n    async def run_command_async(self, command: HostCommand) -&gt; HostCommandResult:\n        stdin, stdout, stderr = await asyncio.to_thread(\n            self.ssh_client.exec_command, command.line\n        )\n\n        exit_status = stdout.channel.recv_exit_status()\n        return HostCommandResult(\n            command=command.line,\n            exit_status=exit_status,\n            stdout=stdout.read().decode(),\n            stderr=stderr.read().decode()\n        )\n</code></pre>"},{"location":"samples/desktop_controller/#2-background-service-registration","title":"2. Background Service Registration","text":"<pre><code># Periodic self-registration with cloud events\nclass DesktopRegistrator(HostedService):\n    async def start_async(self):\n        while not self.cancellation_token.is_cancelled:\n            await self._register_desktop()\n            await asyncio.sleep(self.registration_interval_seconds)\n\n    async def _register_desktop(self):\n        event = DesktopHostRegistrationRequestedIntegrationEventV1(\n            desktop_id=self.desktop_id,\n            host_ip_address=self.host_ip,\n            registration_timestamp=datetime.utcnow()\n        )\n        await self.cloud_event_publisher.publish_async(event)\n</code></pre>"},{"location":"samples/desktop_controller/#3-host-system-information-management","title":"3. Host System Information Management","text":"<pre><code># Domain model for host information\n@dataclass\nclass HostInfo(Entity[str]):\n    desktop_id: str\n    host_ip_address: str\n    host_state: HostState\n    last_seen: datetime\n    is_locked: bool\n    system_info: dict[str, Any]\n\n    def update_system_state(self, new_state: HostState):\n        self.host_state = new_state\n        self.last_seen = datetime.now(timezone.utc)\n</code></pre>"},{"location":"samples/desktop_controller/#4-commandquery-pattern-for-remote-operations","title":"4. Command/Query Pattern for Remote Operations","text":"<pre><code># Remote command execution\n@dataclass\nclass SetHostLockCommand(Command):\n    script_name: str = \"/usr/local/bin/lock.sh\"\n\nclass HostLockCommandsHandler(CommandHandler[SetHostLockCommand, OperationResult[Any]]):\n    async def handle_async(self, command: SetHostLockCommand) -&gt; OperationResult[Any]:\n        host_command = HostCommand(line=command.script_name)\n        result = await self.docker_host_command_runner.run_async(host_command)\n\n        if result.exit_status == 0:\n            return self.success(\"Host locked successfully\")\n        return self.bad_request(f\"Lock command failed: {result.stderr}\")\n</code></pre>"},{"location":"samples/desktop_controller/#5-oauth2-with-ssh-security","title":"5. OAuth2 with SSH Security","text":"<pre><code># Dual security: OAuth2 for API + SSH for host access\n@get(\"/info\", dependencies=[Depends(validate_token)])\nasync def get_host_info(self):\n    query = ReadHostInfoQuery()\n    result = await self.mediator.execute_async(query)\n    return self.process(result)\n</code></pre>"},{"location":"samples/desktop_controller/#configuration-settings","title":"\ud83d\udd27 Configuration &amp; Settings","text":""},{"location":"samples/desktop_controller/#application-settings","title":"Application Settings","text":"<pre><code>class DesktopControllerSettings(ApplicationSettings):\n    # OAuth2 Configuration\n    jwt_authority: str = \"http://keycloak47/realms/mozart\"\n    jwt_audience: str = \"desktops\"\n    required_scope: str = \"api\"\n\n    # SSH Configuration\n    docker_host_user_name: str = \"sys-admin\"\n    docker_host_host_name: str = \"host.docker.internal\"\n\n    # File System Configuration\n    remotefs_base_folder: str = \"/tmp\"\n    hostinfo_filename: str = \"hostinfo.json\"\n    userinfo_filename: str = \"userinfo.json\"\n\n    # Registration Configuration\n    desktop_registration_interval: int = 30  # seconds\n</code></pre>"},{"location":"samples/desktop_controller/#ssh-client-configuration","title":"SSH Client Configuration","text":"<pre><code>class SshClientSettings(BaseModel):\n    username: str\n    hostname: str\n    port: int = 22\n    private_key_filename: str = \"/app/id_rsa\"\n\n# SSH key setup required:\n# 1. Generate SSH key pair\n# 2. Mount private key to container at /app/id_rsa\n# 3. Add public key to host's ~/.ssh/authorized_keys\n</code></pre>"},{"location":"samples/desktop_controller/#testing-strategy","title":"\ud83e\uddea Testing Strategy","text":""},{"location":"samples/desktop_controller/#unit-tests","title":"Unit Tests","text":"<pre><code>class TestHostController:\n    def test_host_lock_command_success(self):\n        # Test successful host locking\n        command = SetHostLockCommand(script_name=\"/usr/local/bin/lock.sh\")\n\n        # Mock SSH client response\n        mock_result = HostCommandResult(\n            command=\"/usr/local/bin/lock.sh\",\n            exit_status=0,\n            stdout=\"Host locked\",\n            stderr=\"\"\n        )\n\n        result = await handler.handle_async(command)\n        assert result.is_success\n        assert \"locked successfully\" in result.data\n</code></pre>"},{"location":"samples/desktop_controller/#integration-tests","title":"Integration Tests","text":"<pre><code>class TestDesktopControllerIntegration:\n    @pytest.mark.integration\n    async def test_ssh_host_communication(self):\n        # Test actual SSH communication with test host\n        ssh_client = SecuredHost(test_ssh_settings)\n        command = HostCommand(line=\"echo 'test'\")\n\n        result = await ssh_client.run_command_async(command)\n\n        assert result.exit_status == 0\n        assert \"test\" in result.stdout\n</code></pre>"},{"location":"samples/desktop_controller/#implementation-details","title":"\ud83d\udcda Implementation Details","text":""},{"location":"samples/desktop_controller/#1-controller-layer-apicontrollers","title":"1. Controller Layer (<code>api/controllers/</code>)","text":"<ul> <li>HostController: Host system management and information endpoints</li> <li>UserController: User session and information management</li> <li>HostScriptController: Custom script execution on host systems</li> <li>OAuth2Scheme: Authentication and authorization middleware</li> </ul>"},{"location":"samples/desktop_controller/#2-application-layer-application","title":"2. Application Layer (<code>application/</code>)","text":"<ul> <li>Commands: System control operations (lock, unlock, script execution)</li> <li>Queries: System information retrieval (host info, user info, lock status)</li> <li>Services: Background registration, SSH command execution</li> <li>Events: Integration events for desktop registration</li> </ul>"},{"location":"samples/desktop_controller/#3-domain-layer-domain","title":"3. Domain Layer (<code>domain/</code>)","text":"<ul> <li>HostInfo: Desktop system information and state</li> <li>UserInfo: User session and authentication state</li> <li>HostIsLocked: Lock state management for security</li> <li>Domain Events: System state change notifications</li> </ul>"},{"location":"samples/desktop_controller/#4-integration-layer-integration","title":"4. Integration Layer (<code>integration/</code>)","text":"<ul> <li>SSH Services: Secure host communication via SSH</li> <li>File System Repository: Remote file management</li> <li>Cloud Event Models: External service communication</li> <li>Enums: System state and configuration enumerations</li> </ul>"},{"location":"samples/desktop_controller/#external-service-integration","title":"\ud83c\udf10 External Service Integration","text":""},{"location":"samples/desktop_controller/#ssh-host-communication","title":"SSH Host Communication","text":"<pre><code>class SecuredDockerHost:\n    \"\"\"SSH-based secure communication with Docker host system\"\"\"\n\n    async def execute_system_command(self, command: str) -&gt; CommandResult:\n        ssh_command = HostCommand(line=command)\n        return await self.secured_host.run_command_async(ssh_command)\n</code></pre>"},{"location":"samples/desktop_controller/#cloud-event-publishing","title":"Cloud Event Publishing","text":"<pre><code>class DesktopRegistrationEvent:\n    \"\"\"Periodic registration with external desktop registry\"\"\"\n\n    event_type = \"com.cisco.mozart.desktop.registered.v1\"\n\n    async def publish_registration(self):\n        cloud_event = CloudEvent(\n            type=self.event_type,\n            source=f\"desktop-controller/{self.desktop_id}\",\n            data=DesktopHostRegistrationRequestedIntegrationEventV1(\n                desktop_id=self.desktop_id,\n                host_ip_address=self.get_host_ip(),\n                capabilities=self.get_host_capabilities()\n            )\n        )\n        await self.cloud_event_bus.publish_async(cloud_event)\n</code></pre>"},{"location":"samples/desktop_controller/#remote-file-system-access","title":"Remote File System Access","text":"<pre><code>class RemoteFileSystemRepository:\n    \"\"\"File-based data persistence on host system\"\"\"\n\n    async def save_host_info(self, host_info: HostInfo):\n        json_data = self.json_serializer.serialize(host_info)\n        await self.write_file_async(\"hostinfo.json\", json_data)\n\n    async def write_file_async(self, filename: str, content: str):\n        # Use SSH to write files to host filesystem\n        command = f\"echo '{content}' &gt; {self.base_path}/{filename}\"\n        await self.ssh_client.run_command_async(HostCommand(line=command))\n</code></pre>"},{"location":"samples/desktop_controller/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"samples/desktop_controller/#prerequisites","title":"Prerequisites","text":"<pre><code># 1. Docker and Docker Desktop installed\n# 2. SSH key pair generated\nssh-keygen -t rsa -b 4096 -f ~/.ssh/desktop_controller_key\n\n# 3. Copy public key to target host\nssh-copy-id -i ~/.ssh/desktop_controller_key.pub user@target-host\n</code></pre>"},{"location":"samples/desktop_controller/#running-the-application","title":"Running the Application","text":"<pre><code># 1. Clone and setup\ngit clone &lt;repository&gt;\ncd samples/desktop-controller\n\n# 2. Configure environment\ncp .env.example .env\n# Edit .env with your settings\n\n# 3. Mount SSH private key and run\ndocker run -d\n  -p 8080:80\n  -v ~/.ssh/desktop_controller_key:/app/id_rsa:ro\n  -e DOCKER_HOST_USER_NAME=sys-admin\n  -e JWT_AUTHORITY=http://your-keycloak/realms/mozart\n  desktop-controller:latest\n\n# 4. Test the API\ncurl -H \"Authorization: Bearer &lt;token&gt;\"\n     http://localhost:8080/api/host/info\n</code></pre>"},{"location":"samples/desktop_controller/#development-setup","title":"Development Setup","text":"<pre><code># 1. Install dependencies\npoetry install\n\n# 2. Configure SSH access\nsudo cp ~/.ssh/desktop_controller_key ./id_rsa\nsudo chmod 600 ./id_rsa\n\n# 3. Start development server\npoetry run python main.py\n\n# 4. Access Swagger UI\nopen http://localhost:8080/docs\n</code></pre>"},{"location":"samples/desktop_controller/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>OAuth2 Security - Authentication patterns</li> <li>Background Services - Hosted service patterns</li> <li>Cloud Events - Event publishing and consumption</li> <li>System Integration - External system communication</li> <li>API Gateway Sample - Service gateway patterns</li> <li>OpenBank Sample - Event sourcing and CQRS patterns</li> </ul>"},{"location":"samples/desktop_controller/#comparison-with-other-samples","title":"\ud83d\udd0d Comparison with Other Samples","text":""},{"location":"samples/desktop_controller/#architecture-patterns","title":"Architecture Patterns","text":""},{"location":"samples/desktop_controller/#desktop-controller-system-integration-focused","title":"Desktop Controller - System Integration Focused","text":"<pre><code># SSH-based system control\nclass HostController(ControllerBase):\n    @post(\"/lock\")\n    async def lock_host(self):\n        command = SetHostLockCommand()\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n# Background service registration\nclass DesktopRegistrator(HostedService):\n    async def start_async(self):\n        while not self.stopping:\n            await self.register_desktop()\n            await asyncio.sleep(30)\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-service-orchestration","title":"API Gateway - Service Orchestration","text":"<pre><code># External API orchestration\nclass PromptController(ControllerBase):\n    @post(\"/prompts\")\n    async def create_prompt(self, dto: CreatePromptDto):\n        command = self.mapper.map(dto, CreatePromptCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-rich-domain-model","title":"OpenBank - Rich Domain Model","text":"<pre><code># Event-sourced business logic\nclass BankAccount(AggregateRoot[str]):\n    def try_add_transaction(self, transaction: BankTransaction) -&gt; bool:\n        if self.can_process_transaction(transaction):\n            self.state.on(self.register_event(TransactionRecorded(transaction)))\n            return True\n        return False\n</code></pre>"},{"location":"samples/desktop_controller/#domain-complexity","title":"Domain Complexity","text":""},{"location":"samples/desktop_controller/#desktop-controller-system-state-management","title":"Desktop Controller - System State Management","text":"<ul> <li>Focus: Host system control and monitoring</li> <li>Entities: HostInfo, UserInfo, SystemState</li> <li>Operations: Lock/unlock, script execution, information gathering</li> <li>State: Current system state with periodic updates</li> </ul>"},{"location":"samples/desktop_controller/#api-gateway-service-integration","title":"API Gateway - Service Integration","text":"<ul> <li>Focus: Request routing and external service coordination</li> <li>Entities: Prompt, PromptResponse, ServiceConfiguration</li> <li>Operations: Create, process, route requests</li> <li>State: Request/response transformation and routing</li> </ul>"},{"location":"samples/desktop_controller/#openbank-business-domain-model","title":"OpenBank - Business Domain Model","text":"<ul> <li>Focus: Financial business rules and transactions</li> <li>Entities: BankAccount, Person, Transaction</li> <li>Operations: Account creation, money transfer, balance inquiry</li> <li>State: Event-sourced business state with full history</li> </ul>"},{"location":"samples/desktop_controller/#data-persistence-strategy","title":"Data Persistence Strategy","text":""},{"location":"samples/desktop_controller/#desktop-controller-file-based-remote-storage","title":"Desktop Controller - File-Based + Remote Storage","text":"<pre><code># File-based persistence on remote host\nclass RemoteFileSystemRepository:\n    async def save_host_info(self, host_info: HostInfo):\n        json_content = self.serializer.serialize(host_info)\n        await self.write_remote_file(\"hostinfo.json\", json_content)\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-multi-store-architecture","title":"API Gateway - Multi-Store Architecture","text":"<pre><code># Multiple storage backends\nservices.add_scoped(MinioStorageManager)      # Object storage\nservices.add_scoped(RedisCache)               # Caching\nservices.add_scoped(MongoRepository)          # Document storage\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-event-sourcing","title":"OpenBank - Event Sourcing","text":"<pre><code># Event store with projections\nclass EventStoreRepository:\n    async def save_async(self, aggregate: AggregateRoot):\n        events = aggregate._pending_events\n        await self.event_store.append_events_async(aggregate.id, events)\n</code></pre>"},{"location":"samples/desktop_controller/#authentication-security","title":"Authentication &amp; Security","text":""},{"location":"samples/desktop_controller/#desktop-controller-oauth2-ssh-keys","title":"Desktop Controller - OAuth2 + SSH Keys","text":"<pre><code># Dual security model\n@get(\"/info\", dependencies=[Depends(validate_token)])\nasync def get_host_info(self):\n    # OAuth2 for API access + SSH for host communication\n    pass\n\n# SSH key management\nclass SshClientSettings:\n    private_key_filename: str = \"/app/id_rsa\"\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-oauth2-api-keys","title":"API Gateway - OAuth2 + API Keys","text":"<pre><code># Multiple authentication schemes\n@post(\"/item\", dependencies=[Depends(validate_oauth2_token)])\nasync def create_item_oauth(self, item_data: ItemDto):\n    pass\n\n@get(\"/health\", dependencies=[Depends(validate_api_key)])\nasync def health_check(self):\n    pass\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-domain-focused-security","title":"OpenBank - Domain-Focused Security","text":"<pre><code># Business rule-based security\nclass BankAccount:\n    def withdraw(self, amount: Decimal, user: Person):\n        if not self.is_owner(user):\n            raise UnauthorizedOperationException()\n        if not self.has_sufficient_funds(amount):\n            raise InsufficientFundsException()\n</code></pre>"},{"location":"samples/desktop_controller/#external-service-integration_1","title":"External Service Integration","text":""},{"location":"samples/desktop_controller/#desktop-controller-system-integration","title":"Desktop Controller - System Integration","text":"<pre><code># Direct system integration via SSH\nclass DockerHostCommandRunner:\n    async def run_async(self, command: HostCommand) -&gt; HostCommandResult:\n        return await self.ssh_client.execute_command(command)\n\n# Cloud event publishing for registration\nclass DesktopRegistrator:\n    async def register_desktop(self):\n        event = DesktopRegistrationEvent(self.host_info)\n        await self.cloud_event_bus.publish_async(event)\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-extensive-integration","title":"API Gateway - Extensive Integration","text":"<pre><code># Multiple external service clients\nservices.add_scoped(MosaicApiClient)\nservices.add_scoped(MinioStorageManager)\nservices.add_scoped(RedisCache)\nservices.add_scoped(GenAiApiClient)\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-minimal-integration","title":"OpenBank - Minimal Integration","text":"<pre><code># Domain-focused with minimal external dependencies\nservices.add_singleton(EventStoreClient)\nservices.add_scoped(MongoRepository)  # For read models\n</code></pre>"},{"location":"samples/desktop_controller/#background-processing","title":"Background Processing","text":""},{"location":"samples/desktop_controller/#desktop-controller-periodic-registration","title":"Desktop Controller - Periodic Registration","text":"<pre><code># Background service for system registration\nclass DesktopRegistrator(HostedService):\n    async def start_async(self):\n        self.registration_task = asyncio.create_task(self.registration_loop())\n\n    async def registration_loop(self):\n        while not self.stopping:\n            await self.register_with_registry()\n            await asyncio.sleep(self.interval)\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-task-queue-pattern","title":"API Gateway - Task Queue Pattern","text":"<pre><code># Redis-backed background task processing\n@dataclass\nclass ProcessPromptTask(BackgroundTask):\n    prompt_id: str\n    user_id: str\n\nclass PromptProcessingService:\n    async def queue_processing_task(self, prompt: Prompt):\n        task = ProcessPromptTask(prompt.id, prompt.user_id)\n        await self.task_scheduler.schedule_async(task)\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-event-driven-projections","title":"OpenBank - Event-Driven Projections","text":"<pre><code># Domain event-driven read model updates\nclass BankAccountProjectionHandler:\n    @dispatch(BankAccountCreatedDomainEventV1)\n    async def handle_async(self, event: BankAccountCreatedDomainEventV1):\n        projection = BankAccountProjection.from_event(event)\n        await self.projection_repository.save_async(projection)\n</code></pre>"},{"location":"samples/desktop_controller/#testing-strategies","title":"Testing Strategies","text":""},{"location":"samples/desktop_controller/#desktop-controller-system-integration-testing","title":"Desktop Controller - System Integration Testing","text":"<pre><code># SSH integration tests\n@pytest.mark.integration\nclass TestSSHIntegration:\n    async def test_host_command_execution(self):\n        ssh_client = SecuredHost(test_settings)\n        result = await ssh_client.run_command_async(HostCommand(\"echo test\"))\n        assert result.exit_status == 0\n        assert \"test\" in result.stdout\n\n# Background service testing\nclass TestDesktopRegistrator:\n    async def test_periodic_registration(self):\n        registrator = DesktopRegistrator(mock_cloud_event_bus)\n        await registrator.start_async()\n        # Verify registration events are published\n</code></pre>"},{"location":"samples/desktop_controller/#api-gateway-integration-heavy-testing","title":"API Gateway - Integration-Heavy Testing","text":"<pre><code># External service integration tests\n@pytest.mark.integration\nclass TestExternalServices:\n    async def test_mosaic_api_integration(self):\n        client = MosaicApiClient(test_settings)\n        response = await client.get_data_async(\"test-id\")\n        assert response.status_code == 200\n\n# Background task testing\nclass TestTaskProcessing:\n    async def test_prompt_processing_workflow(self):\n        task = ProcessPromptTask(\"prompt-123\", \"user-456\")\n        result = await self.task_processor.process_async(task)\n        assert result.is_success\n</code></pre>"},{"location":"samples/desktop_controller/#openbank-domain-focused-testing","title":"OpenBank - Domain-Focused Testing","text":"<pre><code># Rich domain behavior testing\nclass TestBankAccount:\n    def test_account_creation_raises_creation_event(self):\n        account = BankAccount()\n        account.create_account(\"owner-123\", Decimal(\"1000.00\"))\n\n        events = account._pending_events\n        assert len(events) == 1\n        assert isinstance(events[0], BankAccountCreatedDomainEventV1)\n\n# Event sourcing testing\nclass TestEventStore:\n    async def test_aggregate_reconstruction_from_events(self):\n        events = [creation_event, transaction_event]\n        account = await self.repository.load_from_events(events)\n        assert account.balance == expected_balance\n</code></pre>"},{"location":"samples/desktop_controller/#use-case-recommendations","title":"Use Case Recommendations","text":""},{"location":"samples/desktop_controller/#choose-desktop-controller-pattern-when","title":"Choose Desktop Controller Pattern when","text":"<ul> <li>\u2705 Building system administration and control applications</li> <li>\u2705 Managing remote desktop or VM environments</li> <li>\u2705 Implementing SSH-based automation and control</li> <li>\u2705 Creating enterprise desktop management solutions</li> <li>\u2705 Needing periodic service registration and discovery</li> <li>\u2705 Integrating containerized apps with host systems</li> <li>\u2705 Building secure remote command execution systems</li> </ul>"},{"location":"samples/desktop_controller/#choose-api-gateway-pattern-when","title":"Choose API Gateway Pattern when","text":"<ul> <li>\u2705 Building microservice entry points and orchestration</li> <li>\u2705 Implementing complex external service integration</li> <li>\u2705 Creating service mesh control planes</li> <li>\u2705 Needing advanced authentication and authorization</li> <li>\u2705 Building background task processing systems</li> <li>\u2705 Implementing file storage and caching solutions</li> </ul>"},{"location":"samples/desktop_controller/#choose-event-sourcing-pattern-when","title":"Choose Event Sourcing Pattern when","text":"<ul> <li>\u2705 Rich domain models with behavior</li> <li>\u2705 Complete audit trails and temporal queries</li> <li>\u2705 Event-driven architecture with projections</li> <li>\u2705 Financial or business-critical applications</li> <li>\u2705 CQRS with separate read/write models</li> </ul>"},{"location":"samples/desktop_controller/#framework-features-utilized","title":"Framework Features Utilized","text":"<p>The Desktop Controller sample demonstrates unique aspects of the Neuroglia framework:</p> <ul> <li>Background Services: <code>HostedService</code> for long-running registration tasks</li> <li>SSH Integration: Custom integration services for secure system communication</li> <li>Cloud Event Publishing: External service registration and discovery</li> <li>File-Based Repositories: Remote filesystem data persistence</li> <li>OAuth2 Security: Enterprise authentication with secure key management</li> <li>System Integration Patterns: Container-to-host communication strategies</li> </ul> <p>Both samples showcase different strengths of the Neuroglia framework, demonstrating its flexibility in supporting various architectural patterns while maintaining clean architecture principles.</p>"},{"location":"samples/desktop_controller/#overview","title":"Overview","text":""},{"location":"samples/desktop_controller/#controllers-interactions","title":"Controller's Interactions","text":"<p>TODO</p>"},{"location":"samples/desktop_controller/#controllers-context","title":"Controller's Context","text":"<p>TODO</p>"},{"location":"samples/desktop_controller/#design","title":"Design","text":"<p>TODO</p>"},{"location":"samples/desktop_controller/#development","title":"Development","text":""},{"location":"samples/desktop_controller/#setup","title":"Setup","text":"<pre><code># 0. Prerequisites:\n#    Have Python 3.12 installed\n#\n#    - Create/Activate a local python environment (e.g. with pyenv)\n#      pyenv virtualenv 3.12.2 desktop-controller\n#      pyenv activate desktop-controller\n#\n#    - Start Docker Desktop locally\n#\n# 1. Clone the repository\ncd ~/\n\ngit clone git@....\n\ncd desktop-controller\n\n# pip install pre-commit\npre-commit install\n\n# pip install poetry\npoetry lock &amp;&amp; poetry install\n\n# 2. Start the docker-compose stack\n# sudo apt-get install make\nmake up\n\n# Access Swagger UI\nopen http://localhost:8080/docs\n</code></pre>"},{"location":"samples/desktop_controller/#key-implementation-highlights","title":"\ud83d\udca1 Key Implementation Highlights","text":"<p>The Desktop Controller sample uniquely demonstrates:</p>"},{"location":"samples/desktop_controller/#1-dual-security-architecture","title":"1. Dual Security Architecture","text":"<ul> <li>API Security: OAuth2/JWT for REST API access</li> <li>System Security: SSH key-based authentication for host communication</li> <li>Separation of Concerns: Different security models for different access layers</li> </ul>"},{"location":"samples/desktop_controller/#2-container-to-host-communication","title":"2. Container-to-Host Communication","text":"<ul> <li>SSH Bridge: Secure communication between containerized service and host system</li> <li>Command Execution: Remote shell command execution with result capture</li> <li>File System Access: Remote file management on host filesystem</li> </ul>"},{"location":"samples/desktop_controller/#3-background-service-registration","title":"3. Background Service Registration","text":"<ul> <li>Self-Discovery: Periodic registration with external service registry</li> <li>Cloud Events: Standards-based event publishing for service discovery</li> <li>Heartbeat Pattern: Continuous availability signaling</li> </ul>"},{"location":"samples/desktop_controller/#4-system-integration-patterns","title":"4. System Integration Patterns","text":"<ul> <li>Host Information Gathering: Real-time system state collection</li> <li>Remote Control Operations: Secure desktop management capabilities</li> <li>State Persistence: File-based data storage for inter-application communication</li> </ul> <p>This sample showcases how the Neuroglia framework can effectively bridge containerized microservices with host system management, providing enterprise-grade security and reliability for remote desktop control scenarios.</p> <p>Both the Desktop Controller and other samples demonstrate the framework's versatility in handling diverse architectural patterns - from event-sourced business applications to system integration and service orchestration solutions.</p>"},{"location":"samples/lab-resource-manager/","title":"\ud83e\uddea Lab Resource Manager Sample Application","text":"<p>The Lab Resource Manager demonstrates Resource Oriented Architecture (ROA) patterns using Neuroglia's advanced features. It simulates a system for managing ephemeral lab environments for students, showcasing watchers, controllers, and reconciliation loops.</p>"},{"location":"samples/lab-resource-manager/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li>Resource Oriented Architecture: Declarative resource management patterns</li> <li>Watcher Pattern: Continuous monitoring of resource changes</li> <li>Controller Pattern: Event-driven business logic responses</li> <li>Reconciliation Loops: Periodic consistency checks and drift correction</li> <li>State Machine Implementation: Resource lifecycle management</li> <li>Asynchronous Coordination: Multiple concurrent components working together</li> </ul>"},{"location":"samples/lab-resource-manager/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Lab Resource Manager                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502   Watcher       \u2502    \u2502   Controller    \u2502    \u2502  Reconciler     \u2502 \u2502\n\u2502  \u2502   (2s polling)  \u2502\u2500\u2500\u2500\u25b6\u2502   (immediate)   \u2502    \u2502   (10s loop)    \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502           \u2502                       \u2502                       \u2502       \u2502\n\u2502           \u25bc                       \u25bc                       \u25bc       \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502                    Resource Storage                             \u2502 \u2502\n\u2502  \u2502            (Kubernetes-like API with versioning)               \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n</code></pre>"},{"location":"samples/lab-resource-manager/#domain-model","title":"\ud83c\udfaf Domain Model","text":""},{"location":"samples/lab-resource-manager/#labinstance-resource","title":"LabInstance Resource","text":"<p>The core resource representing a student lab environment:</p> <pre><code>@dataclass\nclass LabInstanceResource:\n    api_version: str = \"lab.neuroglia.com/v1\"\n    kind: str = \"LabInstance\" \n    metadata: Dict[str, Any] = None  # Name, namespace, timestamps, versions\n    spec: Dict[str, Any] = None      # Desired state: template, duration, student\n    status: Dict[str, Any] = None    # Current state: phase, endpoint, conditions\n</code></pre>"},{"location":"samples/lab-resource-manager/#resource-states","title":"Resource States","text":"<p>Lab instances progress through a defined lifecycle:</p> <pre><code>PENDING \u2500\u2500\u2192 PROVISIONING \u2500\u2500\u2192 READY \u2500\u2500\u2192 DELETING \u2500\u2500\u2192 DELETED\n   \u2502              \u2502             \u2502\n   \u25bc              \u25bc             \u25bc\nFAILED        FAILED         FAILED\n</code></pre>"},{"location":"samples/lab-resource-manager/#sample-resource","title":"Sample Resource","text":"<pre><code>{\n  \"apiVersion\": \"lab.neuroglia.com/v1\",\n  \"kind\": \"LabInstance\",\n  \"metadata\": {\n    \"name\": \"python-basics-lab\",\n    \"namespace\": \"student-labs\",\n    \"resourceVersion\": \"1\",\n    \"creationTimestamp\": \"2025-09-09T21:34:19Z\"\n  },\n  \"spec\": {\n    \"template\": \"python-basics\",\n    \"studentEmail\": \"student@example.com\",\n    \"duration\": \"60m\",\n    \"environment\": {\n      \"PYTHON_VERSION\": \"3.11\"\n    }\n  },\n  \"status\": {\n    \"state\": \"ready\",\n    \"message\": \"Lab instance is ready\",\n    \"endpoint\": \"https://lab-python-basics.example.com\",\n    \"readyAt\": \"2025-09-09T21:34:25Z\"\n  }\n}\n</code></pre>"},{"location":"samples/lab-resource-manager/#component-implementation","title":"\ud83d\udd27 Component Implementation","text":""},{"location":"samples/lab-resource-manager/#1-watcher-labinstancewatcher","title":"1. Watcher: LabInstanceWatcher","text":"<p>Continuously monitors for resource changes:</p> <pre><code>class LabInstanceWatcher:\n    async def start_watching(self):\n        while self.is_running:\n            # Poll for changes since last known version\n            changes = self.storage.list_resources(since_version=self.last_resource_version)\n\n            for resource in changes:\n                resource_version = int(resource.metadata.get('resourceVersion', '0'))\n                if resource_version &gt; self.last_resource_version:\n                    await self._handle_resource_change(resource)\n                    self.last_resource_version = max(self.last_resource_version, resource_version)\n\n            await asyncio.sleep(self.poll_interval)\n</code></pre> <p>Key Features: - Polls every 2 seconds for near-real-time responsiveness - Uses resource versioning to detect changes efficiently - Notifies multiple event handlers when changes occur - Handles errors gracefully with continued monitoring</p>"},{"location":"samples/lab-resource-manager/#2-controller-labinstancecontroller","title":"2. Controller: LabInstanceController","text":"<p>Implements business logic for state transitions:</p> <pre><code>class LabInstanceController:\n    async def handle_resource_event(self, resource: LabInstanceResource):\n        current_state = resource.status.get('state')\n\n        if current_state == ResourceState.PENDING.value:\n            await self._start_provisioning(resource)\n        elif current_state == ResourceState.PROVISIONING.value:\n            await self._check_provisioning_status(resource)\n        elif current_state == ResourceState.READY.value:\n            await self._monitor_lab_instance(resource)\n</code></pre> <p>Key Features: - Event-driven processing responding immediately to changes - State machine implementation with clear transitions - Business rule enforcement (timeouts, validation, etc.) - Integration with external provisioning systems</p>"},{"location":"samples/lab-resource-manager/#3-reconciler-labinstancescheduler","title":"3. Reconciler: LabInstanceScheduler","text":"<p>Provides safety and eventual consistency:</p> <pre><code>class LabInstanceScheduler:\n    async def start_reconciliation(self):\n        while self.is_running:\n            await self._reconcile_all_resources()\n            await asyncio.sleep(self.reconcile_interval)\n\n    async def _reconcile_resource(self, resource):\n        # Check for stuck states\n        if self._is_stuck_provisioning(resource):\n            await self._mark_as_failed(resource, \"Provisioning timeout\")\n\n        # Check for expiration\n        if self._is_expired(resource):\n            await self._schedule_deletion(resource)\n</code></pre> <p>Key Features: - Runs every 10 seconds scanning all resources - Detects stuck states and takes corrective action - Enforces business policies (lab expiration, cleanup) - Provides safety net for controller failures</p>"},{"location":"samples/lab-resource-manager/#execution-flow","title":"\u26a1 Execution Flow","text":""},{"location":"samples/lab-resource-manager/#1-resource-creation","title":"1. Resource Creation","text":"<pre><code>1. API creates LabInstance resource (state: PENDING)\n2. Storage backend assigns resource version and timestamps\n3. Watcher detects new resource on next poll cycle (\u22642s)\n4. Controller receives sevent and starts provisioning\n5. Resource state transitions to PROVISIONING\n</code></pre>"},{"location":"samples/lab-resource-manager/#2-state-progression","title":"2. State Progression","text":"<pre><code>6. Watcher detects state change to PROVISIONING\n7. Controller checks provisioning status periodically\n8. When provisioning completes, state transitions to READY\n9. Watcher detects READY state\n10. Controller begins monitoring ready lab instance\n</code></pre>"},{"location":"samples/lab-resource-manager/#3-reconciliation-safety","title":"3. Reconciliation Safety","text":"<pre><code>11. Reconciler runs every 10 seconds checking all resources\n12. Detects if any resource is stuck in PROVISIONING too long\n13. Marks stuck resources as FAILED with timeout message\n14. Detects expired READY resources and schedules deletion\n</code></pre>"},{"location":"samples/lab-resource-manager/#running-the-sample","title":"\ud83d\ude80 Running the Sample","text":""},{"location":"samples/lab-resource-manager/#prerequisites","title":"Prerequisites","text":"<pre><code>cd samples/lab-resource-manager\n</code></pre>"},{"location":"samples/lab-resource-manager/#option-1-full-interactive-demo","title":"Option 1: Full Interactive Demo","text":"<pre><code>python run_watcher_demo.py\n</code></pre> <p>This runs the complete demonstration showing: - Resource creation and state transitions - Watcher detecting changes in real-time - Controller responding with business logic - Reconciler providing safety and cleanup</p>"},{"location":"samples/lab-resource-manager/#option-2-simple-patterns-demo","title":"Option 2: Simple Patterns Demo","text":"<pre><code>python simple_demo.py\n</code></pre> <p>A simplified version focusing on the core patterns without framework dependencies.</p>"},{"location":"samples/lab-resource-manager/#expected-output","title":"Expected Output","text":"<pre><code>\ud83c\udfaf Resource Oriented Architecture: Watcher &amp; Reconciliation Demo\n============================================================\n\ud83d\udc40 LabInstance Watcher started\n\ud83d\udd04 LabInstance Scheduler started reconciliation\n\ud83d\udce6 Created resource: student-labs/python-basics-lab\n\ud83d\udd0d Watcher detected change: student-labs/python-basics-lab -&gt; pending\n\ud83c\udfae Controller processing: student-labs/python-basics-lab (state: pending)\n\ud83d\ude80 Starting provisioning for: student-labs/python-basics-lab\n\ud83d\udd04 Updated resource: student-labs/python-basics-lab -&gt; {'status': {'state': 'provisioning'}}\n\ud83d\udd0d Watcher detected change: student-labs/python-basics-lab -&gt; provisioning\n\ud83c\udfae Controller processing: student-labs/python-basics-lab (state: provisioning)\n\ud83d\udd04 Reconciling 2 lab instances\n\u26a0\ufe0f Reconciler: Lab instance stuck in provisioning: student-labs/python-basics-lab\n</code></pre>"},{"location":"samples/lab-resource-manager/#key-implementation-details","title":"\ud83d\udca1 Key Implementation Details","text":""},{"location":"samples/lab-resource-manager/#resource-versioning","title":"Resource Versioning","text":"<p>Each resource change increments the version:</p> <pre><code>def update_resource(self, resource_id: str, updates: Dict[str, Any]):\n    resource = self.resources[resource_id]\n    self.resource_version += 1\n    resource.metadata['resourceVersion'] = str(self.resource_version)\n</code></pre>"},{"location":"samples/lab-resource-manager/#event-handling","title":"Event Handling","text":"<p>Watchers notify multiple handlers:</p> <pre><code>watcher.add_event_handler(controller.handle_resource_event)\nwatcher.add_event_handler(audit_logger.log_change)\nwatcher.add_event_handler(metrics_collector.record_event)\n</code></pre>"},{"location":"samples/lab-resource-manager/#error-resilience","title":"Error Resilience","text":"<p>All components handle errors gracefully:</p> <pre><code>try:\n    await self._provision_lab_instance(resource)\nexcept Exception as e:\n    logger.error(f\"Provisioning failed: {e}\")\n    await self._mark_as_failed(resource, str(e))\n</code></pre>"},{"location":"samples/lab-resource-manager/#concurrent-processing","title":"Concurrent Processing","text":"<p>Components run independently:</p> <pre><code>async def main():\n    watcher_task = asyncio.create_task(watcher.start_watching())\n    scheduler_task = asyncio.create_task(scheduler.start_reconciliation())\n\n    # Both run concurrently until stopped\n    await asyncio.gather(watcher_task, scheduler_task)\n</code></pre>"},{"location":"samples/lab-resource-manager/#design-patterns-demonstrated","title":"\ud83c\udfaf Design Patterns Demonstrated","text":""},{"location":"samples/lab-resource-manager/#1-observer-pattern","title":"1. Observer Pattern","text":"<p>Watchers observe storage and notify controllers of changes.</p>"},{"location":"samples/lab-resource-manager/#2-state-machine","title":"2. State Machine","text":"<p>Resources progress through well-defined states with clear transitions.</p>"},{"location":"samples/lab-resource-manager/#3-command-pattern","title":"3. Command Pattern","text":"<p>Controllers execute commands based on resource state.</p>"},{"location":"samples/lab-resource-manager/#4-strategy-pattern","title":"4. Strategy Pattern","text":"<p>Different provisioning strategies for different lab templates.</p>"},{"location":"samples/lab-resource-manager/#5-circuit-breaker","title":"5. Circuit Breaker","text":"<p>Reconcilers detect failures and prevent cascade issues.</p>"},{"location":"samples/lab-resource-manager/#configuration-options","title":"\ud83d\udd27 Configuration Options","text":""},{"location":"samples/lab-resource-manager/#timing-configuration","title":"Timing Configuration","text":"<pre><code># Development: Fast feedback\nwatcher = LabInstanceWatcher(storage, poll_interval=1.0)\nscheduler = LabInstanceScheduler(storage, reconcile_interval=5.0)\n\n# Production: Optimized performance  \nwatcher = LabInstanceWatcher(storage, poll_interval=5.0)\nscheduler = LabInstanceScheduler(storage, reconcile_interval=30.0)\n</code></pre>"},{"location":"samples/lab-resource-manager/#timeout-configuration","title":"Timeout Configuration","text":"<pre><code>class LabInstanceController:\n    PROVISIONING_TIMEOUT = 300  # 5 minutes\n    MAX_RETRIES = 3\n    RETRY_BACKOFF = 30  # seconds\n</code></pre>"},{"location":"samples/lab-resource-manager/#resource-policies","title":"Resource Policies","text":"<pre><code>class LabInstanceScheduler:\n    DEFAULT_LAB_DURATION = 3600  # 1 hour\n    CLEANUP_GRACE_PERIOD = 300   # 5 minutes\n    MAX_CONCURRENT_PROVISIONS = 10\n</code></pre>"},{"location":"samples/lab-resource-manager/#testing-the-sample","title":"\ud83e\uddea Testing the Sample","text":"<p>The sample includes comprehensive tests:</p> <pre><code># Run all sample tests\npytest samples/lab-resource-manager/tests/\n\n# Test individual components\npytest samples/lab-resource-manager/tests/test_watcher.py\npytest samples/lab-resource-manager/tests/test_controller.py\npytest samples/lab-resource-manager/tests/test_reconciler.py\n</code></pre>"},{"location":"samples/lab-resource-manager/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>\ud83c\udfaf Resource Oriented Architecture - Core ROA concepts</li> <li>\ud83c\udfd7\ufe0f Watcher &amp; Reconciliation Patterns - Detailed patterns</li> <li>\u26a1 Execution Flow - Component coordination</li> <li>\ud83c\udfaf CQRS &amp; Mediation - Command/Query handling</li> <li>\ud83d\uddc4\ufe0f Data Access - Storage patterns</li> </ul>"},{"location":"samples/lab-resource-manager/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<p>After exploring this sample:</p> <ol> <li>Extend the Domain: Add more resource types (LabTemplate, StudentSession)</li> <li>Add Persistence: Integrate with MongoDB or Event Store</li> <li>Implement Authentication: Add student authentication and authorization</li> <li>Add Monitoring: Integrate metrics collection and alerting</li> <li>Scale Horizontally: Implement resource sharding for multiple instances</li> </ol>"},{"location":"samples/openbank/","title":"\ud83c\udfe6 OpenBank Sample Application","text":"<p>OpenBank is a comprehensive sample application that demonstrates advanced Neuroglia features including event sourcing, CQRS, domain-driven design, and event-driven architecture. It simulates a simple banking system with persons and accounts.</p>"},{"location":"samples/openbank/#overview","title":"\ud83c\udfaf Overview","text":"<p>The OpenBank sample showcases:</p> <ul> <li>Event Sourcing: Complete event-sourced domain with event store</li> <li>CQRS: Separate command and query models</li> <li>Domain-Driven Design: Rich domain models with business rules</li> <li>Event-Driven Architecture: Domain events and integration events</li> <li>Clean Architecture: Clear separation of layers</li> <li>Repository Pattern: Both write (event sourcing) and read (MongoDB) repositories</li> </ul>"},{"location":"samples/openbank/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    API Layer                                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502  PersonsController \u2502  \u2502 AccountsController \u2502  \u2502  Other APIs  \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Application Layer                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502    Commands     \u2502  \u2502     Queries     \u2502  \u2502     Events     \u2502   \u2502\n\u2502  \u2502   Handlers      \u2502  \u2502    Handlers     \u2502  \u2502   Handlers     \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Domain Layer                                 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502     Person      \u2502  \u2502     Account     \u2502  \u2502    Address     \u2502   \u2502\n\u2502  \u2502   Aggregate     \u2502  \u2502   Aggregate     \u2502  \u2502 Value Object   \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Integration Layer                              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502 Event Store     \u2502  \u2502   MongoDB       \u2502  \u2502  API Clients   \u2502   \u2502\n\u2502  \u2502 Repository      \u2502  \u2502  Repository     \u2502  \u2502                \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"samples/openbank/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"samples/openbank/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+</li> <li>Docker and Docker Compose</li> <li>MongoDB (via Docker)</li> <li>EventStoreDB (via Docker)</li> </ul>"},{"location":"samples/openbank/#setup","title":"Setup","text":"<ol> <li>Start Dependencies:</li> </ol> <pre><code>cd samples/openbank\ndocker-compose up -d mongodb eventstoredb\n</code></pre> <ol> <li>Install Dependencies:</li> </ol> <pre><code>pip install -r requirements.txt\n</code></pre> <ol> <li>Run the Application:</li> </ol> <pre><code>python api/main.py\n</code></pre> <ol> <li> <p>Access the API:</p> </li> <li> <p>API Documentation: http://localhost:8000/api/docs</p> </li> <li>EventStoreDB UI: http://localhost:2113 (admin/changeit)</li> </ol>"},{"location":"samples/openbank/#project-structure","title":"\ud83d\udcc1 Project Structure","text":"<pre><code>samples/openbank/\n\u251c\u2500\u2500 api/\n\u2502   \u251c\u2500\u2500 main.py                     # Application entry point\n\u2502   \u2514\u2500\u2500 controllers/\n\u2502       \u251c\u2500\u2500 persons_controller.py   # Person management API\n\u2502       \u2514\u2500\u2500 accounts_controller.py  # Account management API\n\u251c\u2500\u2500 application/\n\u2502   \u251c\u2500\u2500 commands/\n\u2502   \u2502   \u251c\u2500\u2500 persons/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 register_person_command.py\n\u2502   \u2502   \u2514\u2500\u2500 accounts/\n\u2502   \u2502       \u251c\u2500\u2500 open_account_command.py\n\u2502   \u2502       \u2514\u2500\u2500 deposit_command.py\n\u2502   \u251c\u2500\u2500 queries/\n\u2502   \u2502   \u251c\u2500\u2500 person_by_id.py\n\u2502   \u2502   \u2514\u2500\u2500 account_by_owner.py\n\u2502   \u2514\u2500\u2500 events/\n\u2502       \u251c\u2500\u2500 integration/\n\u2502       \u2502   \u2514\u2500\u2500 person_registered_handler.py\n\u2502       \u2514\u2500\u2500 domain/\n\u251c\u2500\u2500 domain/\n\u2502   \u2514\u2500\u2500 models/\n\u2502       \u251c\u2500\u2500 person.py               # Person aggregate\n\u2502       \u251c\u2500\u2500 account.py              # Account aggregate\n\u2502       \u2514\u2500\u2500 address.py              # Address value object\n\u2514\u2500\u2500 integration/\n    \u251c\u2500\u2500 models/                     # DTOs and read models\n    \u2502   \u251c\u2500\u2500 person.py\n    \u2502   \u2514\u2500\u2500 account.py\n    \u2514\u2500\u2500 commands/                   # API command DTOs\n        \u2514\u2500\u2500 persons/\n            \u2514\u2500\u2500 register_person_command_dto.py\n</code></pre>"},{"location":"samples/openbank/#domain-models","title":"\ud83c\udfdb\ufe0f Domain Models","text":""},{"location":"samples/openbank/#person-aggregate","title":"Person Aggregate","text":"<p>The Person aggregate manages person registration and personal information:</p> <pre><code>from dataclasses import dataclass\nfrom datetime import date\nfrom neuroglia.data.abstractions import AggregateRoot\nfrom samples.openbank.integration import PersonGender\n\n@dataclass\nclass PersonState:\n    \"\"\"Person aggregate state\"\"\"\n    id: str = None\n    first_name: str = None\n    last_name: str = None\n    nationality: str = None\n    gender: PersonGender = None\n    date_of_birth: date = None\n    address: Address = None\n\nclass Person(AggregateRoot[str]):\n    \"\"\"Person aggregate root\"\"\"\n\n    def __init__(self, id: str = None):\n        super().__init__(id)\n        self.state = PersonState()\n\n    def register(self, first_name: str, last_name: str, nationality: str, \n                gender: PersonGender, date_of_birth: date, address: Address):\n        \"\"\"Register a new person\"\"\"\n\n        # Validate business rules\n        if not first_name or not last_name:\n            raise ValueError(\"First name and last name are required\")\n\n        if date_of_birth &gt;= date.today():\n            raise ValueError(\"Date of birth must be in the past\")\n\n        # Raise domain event\n        self.apply(PersonRegisteredEvent(\n            person_id=self.id,\n            first_name=first_name,\n            last_name=last_name,\n            nationality=nationality,\n            gender=gender,\n            date_of_birth=date_of_birth,\n            address=address\n        ))\n\n    def update_address(self, new_address: Address):\n        \"\"\"Update person's address\"\"\"\n        self.apply(PersonAddressUpdatedEvent(\n            person_id=self.id,\n            old_address=self.state.address,\n            new_address=new_address\n        ))\n\n    # Event handlers\n    def on_person_registered(self, event: PersonRegisteredEvent):\n        \"\"\"Handle person registered event\"\"\"\n        self.state.id = event.person_id\n        self.state.first_name = event.first_name\n        self.state.last_name = event.last_name\n        self.state.nationality = event.nationality\n        self.state.gender = event.gender\n        self.state.date_of_birth = event.date_of_birth\n        self.state.address = event.address\n\n    def on_person_address_updated(self, event: PersonAddressUpdatedEvent):\n        \"\"\"Handle address updated event\"\"\"\n        self.state.address = event.new_address\n</code></pre>"},{"location":"samples/openbank/#account-aggregate","title":"Account Aggregate","text":"<p>The Account aggregate manages banking accounts and transactions:</p> <pre><code>from decimal import Decimal\nfrom neuroglia.data.abstractions import AggregateRoot\n\n@dataclass\nclass AccountState:\n    \"\"\"Account aggregate state\"\"\"\n    id: str = None\n    owner_id: str = None\n    account_number: str = None\n    balance: Decimal = Decimal('0.00')\n    currency: str = 'USD'\n    is_active: bool = True\n\nclass Account(AggregateRoot[str]):\n    \"\"\"Account aggregate root\"\"\"\n\n    def __init__(self, id: str = None):\n        super().__init__(id)\n        self.state = AccountState()\n\n    def open(self, owner_id: str, account_number: str, initial_deposit: Decimal = None):\n        \"\"\"Open a new account\"\"\"\n\n        # Validate business rules\n        if not owner_id:\n            raise ValueError(\"Owner ID is required\")\n\n        if not account_number:\n            raise ValueError(\"Account number is required\")\n\n        if initial_deposit and initial_deposit &lt; Decimal('0'):\n            raise ValueError(\"Initial deposit cannot be negative\")\n\n        # Raise domain event\n        self.apply(AccountOpenedEvent(\n            account_id=self.id,\n            owner_id=owner_id,\n            account_number=account_number,\n            initial_deposit=initial_deposit or Decimal('0.00')\n        ))\n\n    def deposit(self, amount: Decimal, description: str = None):\n        \"\"\"Deposit money to the account\"\"\"\n\n        # Validate business rules\n        if amount &lt;= Decimal('0'):\n            raise ValueError(\"Deposit amount must be positive\")\n\n        if not self.state.is_active:\n            raise ValueError(\"Cannot deposit to inactive account\")\n\n        # Raise domain event\n        self.apply(MoneyDepositedEvent(\n            account_id=self.id,\n            amount=amount,\n            description=description,\n            balance_after=self.state.balance + amount\n        ))\n\n    def withdraw(self, amount: Decimal, description: str = None):\n        \"\"\"Withdraw money from the account\"\"\"\n\n        # Validate business rules\n        if amount &lt;= Decimal('0'):\n            raise ValueError(\"Withdrawal amount must be positive\")\n\n        if not self.state.is_active:\n            raise ValueError(\"Cannot withdraw from inactive account\")\n\n        if self.state.balance &lt; amount:\n            raise ValueError(\"Insufficient funds\")\n\n        # Raise domain event\n        self.apply(MoneyWithdrawnEvent(\n            account_id=self.id,\n            amount=amount,\n            description=description,\n            balance_after=self.state.balance - amount\n        ))\n\n    # Event handlers\n    def on_account_opened(self, event: AccountOpenedEvent):\n        \"\"\"Handle account opened event\"\"\"\n        self.state.id = event.account_id\n        self.state.owner_id = event.owner_id\n        self.state.account_number = event.account_number\n        self.state.balance = event.initial_deposit\n\n    def on_money_deposited(self, event: MoneyDepositedEvent):\n        \"\"\"Handle money deposited event\"\"\"\n        self.state.balance = event.balance_after\n\n    def on_money_withdrawn(self, event: MoneyWithdrawnEvent):\n        \"\"\"Handle money withdrawn event\"\"\"\n        self.state.balance = event.balance_after\n</code></pre>"},{"location":"samples/openbank/#application-layer","title":"\ud83d\udcbc Application Layer","text":""},{"location":"samples/openbank/#command-handlers","title":"Command Handlers","text":"<p>Command handlers execute business operations:</p> <pre><code>from neuroglia.mediation.mediator import CommandHandler\nfrom neuroglia.data.infrastructure.abstractions import Repository\n\nclass RegisterPersonCommandHandler(CommandHandler[RegisterPersonCommand, OperationResult[PersonDto]]):\n    \"\"\"Handles person registration commands\"\"\"\n\n    def __init__(self, \n                 mapper: Mapper,\n                 person_repository: Repository[Person, str]):\n        self.mapper = mapper\n        self.person_repository = person_repository\n\n    async def handle_async(self, command: RegisterPersonCommand) -&gt; OperationResult[PersonDto]:\n        try:\n            # Create new person aggregate\n            person = Person(str(uuid.uuid4()))\n\n            # Execute business operation\n            person.register(\n                first_name=command.first_name,\n                last_name=command.last_name,\n                nationality=command.nationality,\n                gender=command.gender,\n                date_of_birth=command.date_of_birth,\n                address=command.address\n            )\n\n            # Save to event store\n            saved_person = await self.person_repository.add_async(person)\n\n            # Map to DTO and return\n            person_dto = self.mapper.map(saved_person.state, PersonDto)\n            return self.created(person_dto)\n\n        except ValueError as ex:\n            return self.bad_request(str(ex))\n        except Exception as ex:\n            return self.internal_error(f\"Failed to register person: {ex}\")\n\nclass DepositCommandHandler(CommandHandler[DepositCommand, OperationResult[AccountDto]]):\n    \"\"\"Handles money deposit commands\"\"\"\n\n    def __init__(self, \n                 mapper: Mapper,\n                 account_repository: Repository[Account, str]):\n        self.mapper = mapper\n        self.account_repository = account_repository\n\n    async def handle_async(self, command: DepositCommand) -&gt; OperationResult[AccountDto]:\n        try:\n            # Load account from event store\n            account = await self.account_repository.get_by_id_async(command.account_id)\n            if account is None:\n                return self.not_found(\"Account not found\")\n\n            # Execute business operation\n            account.deposit(command.amount, command.description)\n\n            # Save changes\n            await self.account_repository.update_async(account)\n\n            # Map to DTO and return\n            account_dto = self.mapper.map(account.state, AccountDto)\n            return self.ok(account_dto)\n\n        except ValueError as ex:\n            return self.bad_request(str(ex))\n        except Exception as ex:\n            return self.internal_error(f\"Failed to deposit money: {ex}\")\n</code></pre>"},{"location":"samples/openbank/#query-handlers","title":"Query Handlers","text":"<p>Query handlers retrieve data for read operations:</p> <pre><code>class GetPersonByIdQueryHandler(QueryHandler[GetPersonByIdQuery, OperationResult[PersonDto]]):\n    \"\"\"Handles person lookup queries\"\"\"\n\n    def __init__(self, \n                 mapper: Mapper,\n                 person_repository: Repository[PersonDto, str]):  # Read model repository\n        self.mapper = mapper\n        self.person_repository = person_repository\n\n    async def handle_async(self, query: GetPersonByIdQuery) -&gt; OperationResult[PersonDto]:\n        person = await self.person_repository.get_by_id_async(query.person_id)\n\n        if person is None:\n            return self.not_found(f\"Person with ID {query.person_id} not found\")\n\n        return self.ok(person)\n\nclass GetAccountsByOwnerQueryHandler(QueryHandler[GetAccountsByOwnerQuery, OperationResult[List[AccountDto]]]):\n    \"\"\"Handles account lookup by owner queries\"\"\"\n\n    def __init__(self, account_repository: Repository[AccountDto, str]):\n        self.account_repository = account_repository\n\n    async def handle_async(self, query: GetAccountsByOwnerQuery) -&gt; OperationResult[List[AccountDto]]:\n        accounts = await self.account_repository.find_by_criteria_async(\n            {\"owner_id\": query.owner_id}\n        )\n        return self.ok(accounts)\n</code></pre>"},{"location":"samples/openbank/#event-handling","title":"\ud83d\udce1 Event Handling","text":""},{"location":"samples/openbank/#domain-events","title":"Domain Events","text":"<p>Domain events represent business events within aggregates:</p> <pre><code>@dataclass\nclass PersonRegisteredEvent(DomainEvent):\n    \"\"\"Event raised when a person is registered\"\"\"\n    person_id: str\n    first_name: str\n    last_name: str\n    nationality: str\n    gender: PersonGender\n    date_of_birth: date\n    address: Address\n\n@dataclass\nclass AccountOpenedEvent(DomainEvent):\n    \"\"\"Event raised when an account is opened\"\"\"\n    account_id: str\n    owner_id: str\n    account_number: str\n    initial_deposit: Decimal\n\n@dataclass\nclass MoneyDepositedEvent(DomainEvent):\n    \"\"\"Event raised when money is deposited\"\"\"\n    account_id: str\n    amount: Decimal\n    description: str\n    balance_after: Decimal\n</code></pre>"},{"location":"samples/openbank/#integration-events","title":"Integration Events","text":"<p>Integration events handle cross-bounded-context communication:</p> <pre><code>class PersonRegisteredIntegrationEventHandler(EventHandler[PersonRegisteredEvent]):\n    \"\"\"Handles person registered events for integration purposes\"\"\"\n\n    def __init__(self, \n                 cloud_event_publisher: CloudEventPublisher,\n                 mapper: Mapper):\n        self.cloud_event_publisher = cloud_event_publisher\n        self.mapper = mapper\n\n    async def handle_async(self, event: PersonRegisteredEvent):\n        # Create integration event\n        integration_event = PersonRegisteredIntegrationEvent(\n            person_id=event.person_id,\n            email=event.email,\n            full_name=f\"{event.first_name} {event.last_name}\",\n            timestamp=datetime.utcnow()\n        )\n\n        # Publish as CloudEvent\n        await self.cloud_event_publisher.publish_async(\n            event_type=\"person.registered.v1\",\n            data=integration_event,\n            source=\"openbank.persons\"\n        )\n</code></pre>"},{"location":"samples/openbank/#data-access","title":"\ud83d\uddc4\ufe0f Data Access","text":""},{"location":"samples/openbank/#event-sourcing-repository","title":"Event Sourcing Repository","text":"<p>The write model uses event sourcing:</p> <pre><code># Configuration in main.py\nfrom neuroglia.data.infrastructure.event_sourcing import EventSourcingRepository\nfrom neuroglia.data.infrastructure.event_sourcing.event_store import ESEventStore\n\n# Configure Event Store\nESEventStore.configure(builder, EventStoreOptions(database_name, consumer_group))\n\n# Configure event sourcing repositories\nDataAccessLayer.WriteModel.configure(\n    builder, \n    [\"samples.openbank.domain.models\"], \n    lambda builder_, entity_type, key_type: EventSourcingRepository.configure(\n        builder_, entity_type, key_type\n    )\n)\n</code></pre>"},{"location":"samples/openbank/#read-model-repository","title":"Read Model Repository","text":"<p>The read model uses MongoDB:</p> <pre><code># Configuration in main.py\nfrom neuroglia.data.infrastructure.mongo import MongoRepository\n\n# Configure MongoDB repositories\nDataAccessLayer.ReadModel.configure(\n    builder,\n    [\"samples.openbank.integration.models\", \"samples.openbank.application.events\"],\n    lambda builder_, entity_type, key_type: MongoRepository.configure(\n        builder_, entity_type, key_type, database_name\n    )\n)\n</code></pre>"},{"location":"samples/openbank/#api-layer","title":"\ud83c\udf10 API Layer","text":""},{"location":"samples/openbank/#controllers","title":"Controllers","text":"<p>Controllers expose the domain through REST APIs:</p> <pre><code>class PersonsController(ControllerBase):\n    \"\"\"Persons management API\"\"\"\n\n    @post(\"/\", response_model=PersonDto, status_code=201)\n    async def register_person(self, command: RegisterPersonCommandDto) -&gt; PersonDto:\n        \"\"\"Register a new person\"\"\"\n        # Map DTO to domain command\n        domain_command = self.mapper.map(command, RegisterPersonCommand)\n\n        # Execute through mediator\n        result = await self.mediator.execute_async(domain_command)\n\n        # Process and return result\n        return self.process(result)\n\n    @get(\"/\", response_model=List[PersonDto])\n    async def list_persons(self) -&gt; List[PersonDto]:\n        \"\"\"List all registered persons\"\"\"\n        query = ListPersonsQuery()\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/{person_id}\", response_model=PersonDto)\n    async def get_person_by_id(self, person_id: str) -&gt; PersonDto:\n        \"\"\"Get person by ID\"\"\"\n        query = GetPersonByIdQuery(person_id=person_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\nclass AccountsController(ControllerBase):\n    \"\"\"Accounts management API\"\"\"\n\n    @post(\"/\", response_model=AccountDto, status_code=201)\n    async def open_account(self, command: OpenAccountCommandDto) -&gt; AccountDto:\n        \"\"\"Open a new account\"\"\"\n        domain_command = self.mapper.map(command, OpenAccountCommand)\n        result = await self.mediator.execute_async(domain_command)\n        return self.process(result)\n\n    @post(\"/{account_id}/deposit\", response_model=AccountDto)\n    async def deposit(self, account_id: str, command: DepositCommandDto) -&gt; AccountDto:\n        \"\"\"Deposit money to account\"\"\"\n        domain_command = self.mapper.map(command, DepositCommand)\n        domain_command.account_id = account_id\n        result = await self.mediator.execute_async(domain_command)\n        return self.process(result)\n\n    @get(\"/by-owner/{owner_id}\", response_model=List[AccountDto])\n    async def get_accounts_by_owner(self, owner_id: str) -&gt; List[AccountDto]:\n        \"\"\"Get all accounts for a person\"\"\"\n        query = GetAccountsByOwnerQuery(owner_id=owner_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"samples/openbank/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"samples/openbank/#unit-tests","title":"Unit Tests","text":"<p>Test domain logic in isolation:</p> <pre><code>def test_person_registration():\n    # Arrange\n    person = Person(\"test-id\")\n    address = Address(\"123 Main St\", \"Anytown\", \"12345\", \"USA\")\n\n    # Act\n    person.register(\n        first_name=\"John\",\n        last_name=\"Doe\",\n        nationality=\"US\",\n        gender=PersonGender.MALE,\n        date_of_birth=date(1990, 1, 1),\n        address=address\n    )\n\n    # Assert\n    assert person.state.first_name == \"John\"\n    assert person.state.last_name == \"Doe\"\n    assert len(person.uncommitted_events) == 1\n    assert isinstance(person.uncommitted_events[0], PersonRegisteredEvent)\n\ndef test_account_deposit():\n    # Arrange\n    account = Account(\"test-account\")\n    account.open(\"owner-id\", \"123456789\", Decimal('100.00'))\n\n    # Act\n    account.deposit(Decimal('50.00'), \"Test deposit\")\n\n    # Assert\n    assert account.state.balance == Decimal('150.00')\n    assert len(account.uncommitted_events) == 2  # Open + Deposit\n</code></pre>"},{"location":"samples/openbank/#integration-tests","title":"Integration Tests","text":"<p>Test the complete flow:</p> <pre><code>@pytest.mark.asyncio\nasync def test_person_registration_flow():\n    # Arrange\n    client = TestClient(app)\n    person_data = {\n        \"first_name\": \"John\",\n        \"last_name\": \"Doe\",\n        \"nationality\": \"US\",\n        \"gender\": \"MALE\",\n        \"date_of_birth\": \"1990-01-01\",\n        \"address\": {\n            \"street\": \"123 Main St\",\n            \"city\": \"Anytown\",\n            \"postal_code\": \"12345\",\n            \"country\": \"USA\"\n        }\n    }\n\n    # Act\n    response = client.post(\"/api/v1/persons\", json=person_data)\n\n    # Assert\n    assert response.status_code == 201\n    person = response.json()\n    assert person[\"first_name\"] == \"John\"\n    assert person[\"last_name\"] == \"Doe\"\n\n    # Verify person can be retrieved\n    get_response = client.get(f\"/api/v1/persons/{person['id']}\")\n    assert get_response.status_code == 200\n</code></pre>"},{"location":"samples/openbank/#running-the-sample","title":"\ud83d\ude80 Running the Sample","text":""},{"location":"samples/openbank/#start-the-application","title":"Start the Application","text":"<ol> <li>Start infrastructure:</li> </ol> <pre><code>docker-compose up -d\n</code></pre> <ol> <li>Run the application:</li> </ol> <pre><code>python api/main.py\n</code></pre>"},{"location":"samples/openbank/#example-api-calls","title":"Example API Calls","text":"<p>Register a Person:</p> <pre><code>curl -X POST \"http://localhost:8000/api/v1/persons\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"first_name\": \"John\",\n    \"last_name\": \"Doe\",\n    \"nationality\": \"US\",\n    \"gender\": \"MALE\",\n    \"date_of_birth\": \"1990-01-01\",\n    \"address\": {\n      \"street\": \"123 Main St\",\n      \"city\": \"Anytown\",\n      \"postal_code\": \"12345\",\n      \"country\": \"USA\"\n    }\n  }'\n</code></pre> <p>Open an Account:</p> <pre><code>curl -X POST \"http://localhost:8000/api/v1/accounts\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"owner_id\": \"PERSON_ID_FROM_ABOVE\",\n    \"account_number\": \"123456789\",\n    \"initial_deposit\": 1000.00\n  }'\n</code></pre> <p>Deposit Money:</p> <pre><code>curl -X POST \"http://localhost:8000/api/v1/accounts/ACCOUNT_ID/deposit\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"amount\": 500.00,\n    \"description\": \"Salary deposit\"\n  }'\n</code></pre>"},{"location":"samples/openbank/#key-learnings","title":"\ud83d\udccb Key Learnings","text":"<p>The OpenBank sample demonstrates:</p> <ol> <li>Event Sourcing: How to store state as a sequence of events</li> <li>CQRS: Separation of write and read models</li> <li>Domain-Driven Design: Rich domain models with business rules</li> <li>Clean Architecture: Clear separation of concerns</li> <li>Event-Driven Architecture: How events enable loose coupling</li> <li>Repository Pattern: Abstract data access for different storage types</li> <li>Integration Events: Cross-bounded-context communication</li> </ol>"},{"location":"samples/openbank/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Basic Neuroglia concepts</li> <li>Architecture Guide - Understanding the architecture</li> <li>Event Sourcing - Event sourcing patterns</li> <li>CQRS &amp; Mediation - Command and query patterns</li> <li>Event Handling - Event-driven architecture</li> </ul>"}]}