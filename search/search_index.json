{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\ude80 Neuroglia Python Framework","text":"<p>Neuroglia is a lightweight, opinionated framework built on top of FastAPI that provides a comprehensive set of tools and patterns for building clean, maintainable, and scalable microservices. It enforces architectural best practices and provides out-of-the-box implementations of common patterns.</p>"},{"location":"#what-makes-neuroglia-special","title":"\u2728 What Makes Neuroglia Special?","text":"<ul> <li>\ud83c\udfd7\ufe0f Clean Architecture Enforced: Clear separation between API, Application, Domain, and Integration layers</li> <li>\ud83d\udc89 Powerful Dependency Injection: Lightweight container with automatic service discovery</li> <li>\ud83c\udfaf CQRS &amp; Mediation Built-in: Command Query Responsibility Segregation with mediator pattern</li> <li>\ud83d\udce1 Event-Driven by Design: Native CloudEvents, event sourcing, and reactive programming</li> <li>\ud83d\udd0c MVC Done Right: Class-based controllers with automatic discovery and OpenAPI generation</li> <li>\ud83d\uddc4\ufe0f Flexible Data Access: Repository pattern with MongoDB, Event Store, and in-memory support</li> <li>\ud83d\udcca Smart Object Mapping: Bidirectional mapping between domain models and DTOs</li> <li>\u26a1 Reactive Programming: Built-in RxPy support for asynchronous event handling</li> </ul>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"<p>Get up and running in minutes:</p> <pre><code># Install Neuroglia\npip install neuroglia\n\n# Create your first app\npython -c \"\nfrom neuroglia.hosting.web import WebApplicationBuilder\n\nbuilder = WebApplicationBuilder()\nbuilder.add_controllers(['api.controllers'])\n\napp = builder.build()\napp.use_controllers()\napp.run()\n\"\n</code></pre> <p>\ud83d\udc49 Get Started Now</p>"},{"location":"#architecture-overview","title":"\ud83c\udfaf Architecture Overview","text":"<p>Neuroglia promotes a clean, layered architecture:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 \ud83c\udf10 API Layer                     \u2502  \u2190 Controllers, DTOs, Routes\n\u2502            (FastAPI Integration)                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 Commands &amp; Queries\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              \ud83d\udcbc Application Layer                \u2502  \u2190 Handlers, Services, Workflows\n\u2502         (CQRS, Mediation, Use Cases)            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 Domain Operations\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502               \ud83c\udfdb\ufe0f Domain Layer                    \u2502  \u2190 Business Logic, Entities, Rules\n\u2502         (Pure Business Logic)                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 Interface Implementation\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            \ud83d\udd0c Integration Layer                  \u2502  \u2190 Databases, APIs, Infrastructure\n\u2502      (Repositories, External Services)          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>\ud83d\udcd6 Learn the Architecture</p>"},{"location":"#core-features","title":"\ud83c\udfaa Core Features","text":""},{"location":"#dependency-injection","title":"\ud83d\udc89 Dependency Injection","text":"<p>Powerful, lightweight DI container with automatic service discovery:</p> <pre><code># Automatic registration\nservices.add_scoped(UserService)\nservices.add_singleton(CacheService)\n\n# Constructor injection\nclass UserController(ControllerBase):\n    def __init__(self, user_service: UserService):\n        self.user_service = user_service\n</code></pre> <p>\ud83d\udcd6 Dependency Injection Guide</p>"},{"location":"#cqrs-mediation","title":"\ud83c\udfaf CQRS &amp; Mediation","text":"<p>Clean separation of commands and queries with built-in mediation:</p> <pre><code># Command\n@dataclass\nclass CreateUserCommand(Command[OperationResult[UserDto]]):\n    email: str\n    first_name: str\n\n# Handler\nclass CreateUserHandler(CommandHandler[CreateUserCommand, OperationResult[UserDto]]):\n    async def handle_async(self, command: CreateUserCommand) -&gt; OperationResult[UserDto]:\n        # Business logic here\n        return self.created(user_dto)\n\n# Usage in controller\nresult = await self.mediator.execute_async(command)\n</code></pre> <p>\ud83d\udcd6 CQRS &amp; Mediation Guide</p>"},{"location":"#mvc-controllers","title":"\ud83d\udd0c MVC Controllers","text":"<p>Class-based controllers with automatic discovery and full FastAPI integration:</p> <pre><code>class UsersController(ControllerBase):\n    @post(\"/\", response_model=UserDto, status_code=201)\n    async def create_user(self, user_dto: CreateUserDto) -&gt; UserDto:\n        command = self.mapper.map(user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre> <p>\ud83d\udcd6 MVC Controllers Guide</p>"},{"location":"#event-driven-architecture","title":"\ud83d\udce1 Event-Driven Architecture","text":"<p>Native support for CloudEvents and reactive programming:</p> <pre><code># Domain events\nclass UserCreatedEvent(DomainEvent):\n    user_id: str\n    email: str\n\n# Event handlers\nclass WelcomeEmailHandler(EventHandler[UserCreatedEvent]):\n    async def handle_async(self, event: UserCreatedEvent):\n        await self.email_service.send_welcome(event.email)\n</code></pre> <p>\ud83d\udcd6 Event Handling Guide</p>"},{"location":"#data-access","title":"\ud83d\uddc4\ufe0f Data Access","text":"<p>Flexible repository pattern with multiple storage backends:</p> <pre><code># Repository interface\nclass IUserRepository(Repository[User, str]):\n    async def get_by_email(self, email: str) -&gt; User:\n        pass\n\n# MongoDB implementation\nclass MongoUserRepository(IUserRepository):\n    # Implementation\n\n# Event sourcing implementation  \nclass EventSourcedUserRepository(IUserRepository):\n    # Implementation\n</code></pre> <p>\ud83d\udcd6 Data Access Guide</p>"},{"location":"#sample-applications","title":"\ud83c\udf93 Sample Applications","text":"<p>Learn by example with complete, production-ready sample applications:</p>"},{"location":"#openbank-event-sourced-banking-system","title":"\ud83c\udfe6 OpenBank - Event-Sourced Banking System","text":"<p>A comprehensive banking domain showcasing:</p> <ul> <li>\u2705 Event sourcing with EventStoreDB</li> <li>\u2705 CQRS with separate read/write models  </li> <li>\u2705 Domain-driven design patterns</li> <li>\u2705 Event-driven architecture</li> <li>\u2705 Clean architecture layers</li> </ul> <p>\ud83d\udc49 Explore OpenBank</p>"},{"location":"#api-gateway-microservice-gateway","title":"\ud83d\udeaa API Gateway - Microservice Gateway","text":"<p>An intelligent API gateway featuring:</p> <ul> <li>\u2705 Request routing and load balancing</li> <li>\u2705 Authentication and authorization</li> <li>\u2705 Rate limiting and caching</li> <li>\u2705 Monitoring and observability</li> </ul> <p>\ud83d\udc49 Explore API Gateway</p>"},{"location":"#desktop-controller-remote-management","title":"\ud83d\udda5\ufe0f Desktop Controller - Remote Management","text":"<p>A desktop management API demonstrating:</p> <ul> <li>\u2705 Background services and scheduling</li> <li>\u2705 Real-time communication</li> <li>\u2705 System integration patterns</li> <li>\u2705 Docker containerization</li> </ul> <p>\ud83d\udc49 Explore Desktop Controller</p>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":""},{"location":"#getting-started","title":"\ud83d\ude80 Getting Started","text":"<ul> <li>Quick Start Guide - Build your first app in 10 minutes</li> <li>Architecture Overview - Understand the framework's design</li> <li>Project Structure - Organize your code properly</li> </ul>"},{"location":"#feature-guides","title":"\ud83c\udfaa Feature Guides","text":"Feature Description Documentation Dependency Injection Service container and automatic registration \ud83d\udcd6 Guide CQRS &amp; Mediation Command/Query separation with mediator \ud83d\udcd6 Guide MVC Controllers Class-based API controllers \ud83d\udcd6 Guide Data Access Repository pattern and persistence \ud83d\udcd6 Guide Event Handling Events, messaging, and reactive programming \ud83d\udcd6 Guide Object Mapping Automatic object-to-object mapping \ud83d\udcd6 Guide Configuration Settings and environment management \ud83d\udcd6 Guide Hosting Web application hosting and lifecycle \ud83d\udcd6 Guide"},{"location":"#requirements","title":"\ud83d\udccb Requirements","text":"<ul> <li>Python 3.11+</li> <li>FastAPI (automatic)</li> <li>Pydantic (automatic)</li> <li>Optional: MongoDB, EventStoreDB, Redis (based on features used)</li> </ul>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions! Here's how you can help:</p> <ul> <li>\ud83d\udc1b Report bugs - Found an issue? Let us know!</li> <li>\ud83d\udca1 Suggest features - Have an idea? We'd love to hear it!</li> <li>\ud83d\udcdd Improve docs - Help make our documentation better</li> <li>\ud83d\udd27 Submit PRs - Code contributions are always welcome</li> </ul> <p>\ud83d\udc49 Contributing Guide</p>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"#why-choose-neuroglia","title":"\ud83c\udf1f Why Choose Neuroglia?","text":"<p>\u2705 Production Ready: Battle-tested patterns and practices \u2705 Developer Friendly: Intuitive APIs and excellent documentation \u2705 Highly Testable: Built with testing in mind from day one \u2705 Scalable: Patterns that grow with your application \u2705 Modern: Leverages the latest Python and FastAPI features \u2705 Flexible: Use only what you need, when you need it  </p> <p>Ready to build something amazing? Get Started Now \ud83d\ude80</p>"},{"location":"#running-background-tasks","title":"Running Background Tasks","text":"<p>Neuroglia integrates with apscheduler for background tasks:</p> <pre><code>from apscheduler.schedulers.asyncio import AsyncIOScheduler\nfrom neuroglia.hosting.abstractions import HostedService\n\nclass BackgroundTaskService(HostedService):\n    def __init__(self):\n        self._scheduler = AsyncIOScheduler()\n\n    async def start_async(self):\n        # Add jobs\n        self._scheduler.add_job(self._process_data, 'interval', minutes=5)\n        self._scheduler.start()\n\n    async def stop_async(self):\n        self._scheduler.shutdown()\n\n    async def _process_data(self):\n        # Task implementation\n        pass\n</code></pre>"},{"location":"#advanced-features","title":"Advanced Features","text":""},{"location":"#real-time-communication-with-cloudevents","title":"Real-time Communication with CloudEvents","text":"<pre><code>from neuroglia.eventing.cloud_events.infrastructure import CloudEventIngestor\nfrom neuroglia.eventing.cloud_events.decorators import cloud_event_handler\n\nclass NotificationService:\n    def __init__(self, event_ingestor: CloudEventIngestor):\n        event_ingestor.subscribe(\"user.created\", self._on_user_created)\n\n    @cloud_event_handler\n    async def _on_user_created(self, event_data):\n        # Process user created event\n        user_id = event_data[\"id\"]\n        # Send notification\n</code></pre>"},{"location":"#custom-repository-implementation","title":"Custom Repository Implementation","text":"<pre><code>from neuroglia.data.infrastructure.abstractions import Repository\n\nclass CustomRepository(Repository[Entity, str]):\n    async def add(self, entity: Entity) -&gt; None:\n        # Custom implementation\n\n    async def update(self, entity: Entity) -&gt; None:\n        # Custom implementation\n\n    async def remove(self, entity: Entity) -&gt; None:\n        # Custom implementation\n\n    async def find_by_id(self, id: str) -&gt; Optional[Entity]:\n        # Custom implementation\n</code></pre>"},{"location":"#samples","title":"Samples","text":""},{"location":"#openbank","title":"OpenBank","text":"<p>Implements a simplified Bank that manages Accounts, Users and Transactions with full Event Sourcing, CQRS</p> <p>Explore OpenBank</p>"},{"location":"#desktop-controller","title":"Desktop Controller","text":"<p>Remotely and securely control custom files or commands on a Desktop running the app as a Docker container...</p> <p>Explore Desktop Controller</p>"},{"location":"#api-gateway","title":"API Gateway","text":"<p>Expose single entry point for 3rd party clients into an internal layer, like a GenAI stack... Models a Prompt entity, enforces a business logic (e.g. Prompt' state-machine), handles scheduled background task (with persistence), exposes API with multiple Security schemes, ...</p> <p>Explore API Gateway</p>"},{"location":"#cisco-remote-output-collector","title":"Cisco Remote Output Collector","text":"<p>Statefull microservice that handles complex and custom HTTP Commands which in turn each encapsulates arbitrary interactions with given Cisco Device(s) via Telnet, such as <code>FindPrompt</code>, <code>CollectCommandLineOutput</code>, <code>AddConfiguration</code>, <code>SaveConfiguration</code>, <code>Ping</code>, <code>Traceroute</code>, <code>ClearNatTranslation</code>, <code>CheckReachability</code>, <code>BounceInterface</code>, <code>RunViaTelnetTo</code>, <code>FindSpanningTreeRoot</code>, ... etc.</p> <p>Explore IOS ROC</p> <p>Current state: functional but simple implemention, 100% stateless collection of multiple CLI to a single device via Telnet.</p> <p>TODO:</p> <ul> <li>[ ] Add Session management (defines a Pod for subsequent scenarios) with persistence</li> <li>[ ] Add DeviceConnection and ConnectionManager</li> <li>[ ] Add DeviceDrivers and PromptPatterns libraries</li> <li>[ ] ...</li> </ul>"},{"location":"#deployment","title":"Deployment","text":""},{"location":"#docker-deployment","title":"Docker Deployment","text":"<p>The framework is designed to work seamlessly with Docker. A typical Dockerfile might look like:</p> <pre><code>FROM python:3.10-slim\n\nWORKDIR /app\n\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\nCOPY . .\n\nEXPOSE 8000\n\nCMD [\"uvicorn\", \"api.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n</code></pre>"},{"location":"#environment-configuration","title":"Environment Configuration","text":"<p>Following the 12-Factor App principles, configuration is stored in environment variables:</p> <pre><code>from neuroglia.hosting.abstractions import ApplicationSettings\nfrom pydantic import BaseSettings\n\nclass MyAppSettings(ApplicationSettings):\n    database_url: str\n    api_key: str\n    debug_mode: bool = False\n</code></pre>"},{"location":"#testing","title":"Testing","text":"<p>The framework supports comprehensive testing with pytest:</p> <pre><code># Example test for a command handler\nasync def test_create_user_command():\n    # Arrange\n    handler = CreateUserCommandHandler(mock_repository)\n    command = CreateUserCommand(\"test\", \"test@example.com\")\n\n    # Act\n    result = await handler.handle(command)\n\n    # Assert\n    assert result is not None\n    assert mock_repository.add.called_once\n</code></pre>"},{"location":"#best-practices","title":"Best Practices","text":"<ol> <li>Keep Domain Models Pure: Domain models should be free of infrastructure concerns</li> <li>Use Commands for State Changes: All state-changing operations should be modeled as commands</li> <li>Use Queries for Reading Data: All data retrieval should be modeled as queries</li> <li>Leverage Dependency Injection: Always use DI to create loosely coupled components</li> <li>Handle Errors with Problem Details: Use the standard ProblemDetails format for error responses</li> <li>Follow Layered Architecture: Maintain clear boundaries between API, Application, Domain, and Integration layers</li> </ol>"},{"location":"#conclusion","title":"Conclusion","text":"<p>The Neuroglia Python Framework provides a comprehensive foundation for building clean, maintainable, and feature-rich microservices. By embracing modern architectural patterns like CQRS, Event Sourcing, and Clean Architecture, it helps developers create applications that are easier to understand, test, and evolve over time.</p> <p>For more information, check out the sample applications or contribute to the framework development.</p>"},{"location":"architecture/","title":"\ud83c\udfd7\ufe0f Architecture Guide","text":"<p>Neuroglia implements a clean, layered architecture that promotes separation of concerns, testability, and maintainability. This guide explains the architectural principles and how they're implemented in the framework.</p>"},{"location":"architecture/#architectural-principles","title":"\ud83c\udfaf Architectural Principles","text":""},{"location":"architecture/#1-clean-architecture","title":"1. Clean Architecture","text":"<p>Neuroglia follows Clean Architecture principles:</p> <ul> <li>Dependency Rule: Dependencies always point inward (toward the domain)</li> <li>Independent of Frameworks: Business logic doesn't depend on framework details</li> <li>Testable: Business rules can be tested without external dependencies</li> <li>Independent of UI: The application can work with different interfaces</li> <li>Independent of Database: Business rules aren't bound to a specific database</li> </ul>"},{"location":"architecture/#2-separation-of-concerns","title":"2. Separation of Concerns","text":"<p>Each layer has a specific responsibility and doesn't concern itself with the details of other layers:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 API Layer                        \u2502  \u2190 External Interface\n\u2502            (Controllers, DTOs)                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 depends on\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Application Layer                   \u2502  \u2190 Orchestration\n\u2502         (Commands, Queries, Handlers)           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 depends on\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502               Domain Layer                       \u2502  \u2190 Business Logic\n\u2502            (Entities, Services)                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 implements\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            Integration Layer                     \u2502  \u2190 External Concerns\n\u2502        (Repositories, API Clients)              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#3-inversion-of-control","title":"3. Inversion of Control","text":"<p>The framework uses dependency injection to invert control flow and reduce coupling between components.</p>"},{"location":"architecture/#layer-breakdown","title":"\ud83c\udfe2 Layer Breakdown","text":""},{"location":"architecture/#api-layer-srcapi","title":"\ud83d\udce1 API Layer (<code>src/api/</code>)","text":"<p>Purpose: Defines the external interface of your application</p> <p>Responsibilities:</p> <ul> <li>HTTP endpoints and routing</li> <li>Request/response DTOs</li> <li>Authentication and authorization</li> <li>Input validation</li> <li>OpenAPI documentation</li> </ul> <p>Key Components:</p> <ul> <li>Controllers: Handle HTTP requests and delegate to application layer</li> <li>DTOs: Data Transfer Objects for API contracts</li> <li>Middleware: Cross-cutting concerns like authentication, logging</li> </ul> <p>Example Structure:</p> <pre><code>api/\n\u251c\u2500\u2500 controllers/\n\u2502   \u251c\u2500\u2500 users_controller.py\n\u2502   \u2514\u2500\u2500 orders_controller.py\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 user_dto.py\n\u2502   \u2514\u2500\u2500 order_dto.py\n\u2514\u2500\u2500 middleware/\n    \u251c\u2500\u2500 auth_middleware.py\n    \u2514\u2500\u2500 logging_middleware.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Keep controllers thin - delegate business logic to application layer</li> <li>Use DTOs to define API contracts</li> <li>Validate input at the API boundary</li> <li>Map between DTOs and domain models</li> </ul>"},{"location":"architecture/#application-layer-srcapplication","title":"\ud83d\udcbc Application Layer (<code>src/application/</code>)","text":"<p>Purpose: Orchestrates business workflows and coordinates domain operations</p> <p>Responsibilities:</p> <ul> <li>Command and query handling</li> <li>Business workflow orchestration</li> <li>Transaction management</li> <li>Event publishing</li> <li>Application services</li> </ul> <p>Key Components:</p> <ul> <li>Commands: Represent actions that change state</li> <li>Queries: Represent read operations</li> <li>Handlers: Process commands and queries</li> <li>Services: Application-specific business logic</li> </ul> <p>Example Structure:</p> <pre><code>application/\n\u251c\u2500\u2500 commands/\n\u2502   \u251c\u2500\u2500 create_user_command.py\n\u2502   \u2514\u2500\u2500 update_user_command.py\n\u251c\u2500\u2500 queries/\n\u2502   \u251c\u2500\u2500 get_user_query.py\n\u2502   \u2514\u2500\u2500 list_users_query.py\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 user_service.py\n\u2502   \u2514\u2500\u2500 notification_service.py\n\u2514\u2500\u2500 events/\n    \u251c\u2500\u2500 user_created_event.py\n    \u2514\u2500\u2500 user_updated_event.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Each command/query should have a single responsibility</li> <li>Use the mediator pattern to decouple handlers</li> <li>Keep application services focused on coordination</li> <li>Publish domain events for side effects</li> </ul>"},{"location":"architecture/#domain-layer-srcdomain","title":"\ud83c\udfdb\ufe0f Domain Layer (<code>src/domain/</code>)","text":"<p>Purpose: Contains the core business logic and rules</p> <p>Responsibilities:</p> <ul> <li>Business entities and aggregates</li> <li>Value objects</li> <li>Domain services</li> <li>Business rules and invariants</li> <li>Domain events</li> </ul> <p>Key Components:</p> <ul> <li>Entities: Objects with identity and lifecycle</li> <li>Value Objects: Immutable objects defined by their attributes</li> <li>Aggregates: Consistency boundaries</li> <li>Domain Services: Business logic that doesn't belong to entities</li> </ul> <p>Example Structure:</p> <pre><code>domain/\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 user.py\n\u2502   \u251c\u2500\u2500 order.py\n\u2502   \u2514\u2500\u2500 address.py\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 pricing_service.py\n\u2502   \u2514\u2500\u2500 validation_service.py\n\u2514\u2500\u2500 events/\n    \u251c\u2500\u2500 user_registered.py\n    \u2514\u2500\u2500 order_placed.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Keep domain models rich with behavior</li> <li>Enforce business invariants</li> <li>Use domain events for decoupling</li> <li>Avoid dependencies on infrastructure</li> </ul>"},{"location":"architecture/#integration-layer-srcintegration","title":"\ud83d\udd0c Integration Layer (<code>src/integration/</code>)","text":"<p>Purpose: Handles external integrations and infrastructure concerns</p> <p>Responsibilities:</p> <ul> <li>Database repositories</li> <li>External API clients</li> <li>Message queue integration</li> <li>File system operations</li> <li>Caching</li> </ul> <p>Key Components:</p> <ul> <li>Repositories: Data access implementations</li> <li>API Clients: External service integrations</li> <li>DTOs: External data contracts</li> <li>Infrastructure Services: Technical concerns</li> </ul> <p>Example Structure:</p> <pre><code>integration/\n\u251c\u2500\u2500 repositories/\n\u2502   \u251c\u2500\u2500 user_repository.py\n\u2502   \u2514\u2500\u2500 order_repository.py\n\u251c\u2500\u2500 clients/\n\u2502   \u251c\u2500\u2500 payment_client.py\n\u2502   \u2514\u2500\u2500 email_client.py\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 user_entity.py\n\u2502   \u2514\u2500\u2500 payment_dto.py\n\u2514\u2500\u2500 services/\n    \u251c\u2500\u2500 cache_service.py\n    \u2514\u2500\u2500 file_service.py\n</code></pre> <p>Best Practices:</p> <ul> <li>Implement domain repository interfaces</li> <li>Handle external failures gracefully</li> <li>Use DTOs for external data contracts</li> <li>Isolate infrastructure concerns</li> </ul>"},{"location":"architecture/#data-flow","title":"\ud83d\udd04 Data Flow","text":""},{"location":"architecture/#command-flow-write-operations","title":"Command Flow (Write Operations)","text":"<ol> <li>Controller receives HTTP request with DTO</li> <li>Controller maps DTO to Command and sends to Mediator</li> <li>Mediator routes Command to appropriate Handler</li> <li>Handler loads domain entities via Repository</li> <li>Handler executes business logic on domain entities</li> <li>Handler saves changes via Repository</li> <li>Handler publishes domain events</li> <li>Handler returns result to Controller</li> <li>Controller maps result to DTO and returns HTTP response</li> </ol> <pre><code>HTTP Request \u2192 Controller \u2192 Command \u2192 Handler \u2192 Domain \u2192 Repository \u2192 Database\n                    \u2193           \u2193        \u2193\n               HTTP Response \u2190 DTO \u2190 Result \u2190 Events\n</code></pre>"},{"location":"architecture/#query-flow-read-operations","title":"Query Flow (Read Operations)","text":"<ol> <li>Controller receives HTTP request with parameters</li> <li>Controller creates Query and sends to Mediator</li> <li>Mediator routes Query to appropriate Handler</li> <li>Handler loads data via Repository or Read Model</li> <li>Handler returns data to Controller</li> <li>Controller maps data to DTO and returns HTTP response</li> </ol> <pre><code>HTTP Request \u2192 Controller \u2192 Query \u2192 Handler \u2192 Repository \u2192 Database\n                    \u2193         \u2193       \u2193\n               HTTP Response \u2190 DTO \u2190 Result\n</code></pre>"},{"location":"architecture/#patterns-implemented","title":"\ud83c\udfad Patterns Implemented","text":""},{"location":"architecture/#1-command-query-responsibility-segregation-cqrs","title":"1. Command Query Responsibility Segregation (CQRS)","text":"<p>Separates read and write operations to optimize performance and scalability:</p> <pre><code># Command (Write)\n@dataclass\nclass CreateUserCommand(Command[OperationResult[UserDto]]):\n    email: str\n    first_name: str\n    last_name: str\n\n# Query (Read)\n@dataclass\nclass GetUserQuery(Query[OperationResult[UserDto]]):\n    user_id: str\n</code></pre>"},{"location":"architecture/#2-mediator-pattern","title":"2. Mediator Pattern","text":"<p>Decouples components by routing requests through a central mediator:</p> <pre><code># In controller\nresult = await self.mediator.execute_async(command)\n</code></pre>"},{"location":"architecture/#3-repository-pattern","title":"3. Repository Pattern","text":"<p>Abstracts data access and provides a consistent interface:</p> <pre><code>class UserRepository(Repository[User, str]):\n    async def add_async(self, user: User) -&gt; User:\n        # Implementation details\n        pass\n</code></pre>"},{"location":"architecture/#4-event-sourcing-optional","title":"4. Event Sourcing (Optional)","text":"<p>Stores state changes as events rather than current state:</p> <pre><code>class User(AggregateRoot[str]):\n    def register(self, email: str, name: str):\n        self.apply(UserRegisteredEvent(email, name))\n</code></pre>"},{"location":"architecture/#5-dependency-injection","title":"5. Dependency Injection","text":"<p>Manages object creation and dependencies:</p> <pre><code># Automatic registration\nbuilder.services.add_scoped(UserService)\n\n# Resolution\nuser_service = provider.get_required_service(UserService)\n</code></pre>"},{"location":"architecture/#testing-architecture","title":"\ud83e\uddea Testing Architecture","text":"<p>The layered architecture makes testing straightforward:</p>"},{"location":"architecture/#unit-tests","title":"Unit Tests","text":"<p>Test individual components in isolation:</p> <pre><code>def test_user_registration():\n    # Arrange\n    command = CreateUserCommand(\"test@example.com\", \"John\", \"Doe\")\n    handler = CreateUserCommandHandler(mock_repository)\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n</code></pre>"},{"location":"architecture/#integration-tests","title":"Integration Tests","text":"<p>Test interactions between layers:</p> <pre><code>def test_create_user_endpoint():\n    # Test API \u2192 Application \u2192 Domain integration\n    response = test_client.post(\"/api/v1/users\", json=user_data)\n    assert response.status_code == 201\n</code></pre>"},{"location":"architecture/#architecture-tests","title":"Architecture Tests","text":"<p>Verify architectural constraints:</p> <pre><code>def test_domain_has_no_infrastructure_dependencies():\n    # Ensure domain layer doesn't depend on infrastructure\n    domain_modules = get_domain_modules()\n    for module in domain_modules:\n        assert not has_infrastructure_imports(module)\n</code></pre>"},{"location":"architecture/#benefits","title":"\ud83d\ude80 Benefits","text":""},{"location":"architecture/#maintainability","title":"Maintainability","text":"<ul> <li>Clear boundaries: Each layer has well-defined responsibilities</li> <li>Loose coupling: Changes in one layer don't affect others</li> <li>High cohesion: Related functionality is grouped together</li> </ul>"},{"location":"architecture/#testability","title":"Testability","text":"<ul> <li>Isolated testing: Each layer can be tested independently</li> <li>Mock dependencies: External dependencies can be easily mocked</li> <li>Fast tests: Business logic tests don't require infrastructure</li> </ul>"},{"location":"architecture/#scalability","title":"Scalability","text":"<ul> <li>CQRS: Read and write models can be optimized separately</li> <li>Event-driven: Asynchronous processing for better performance</li> <li>Microservice ready: Clear boundaries make extraction easier</li> </ul>"},{"location":"architecture/#flexibility","title":"Flexibility","text":"<ul> <li>Technology agnostic: Swap implementations without affecting business logic</li> <li>Framework independence: Business logic isn't tied to web framework</li> <li>Future-proof: Architecture adapts to changing requirements</li> </ul>"},{"location":"architecture/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Build your first application</li> <li>Dependency Injection - Managing dependencies</li> <li>CQRS &amp; Mediation - Command and query patterns</li> <li>Data Access - Repository pattern and persistence</li> <li>Event Handling - Event-driven architecture</li> </ul>"},{"location":"getting-started/","title":"\ud83d\ude80 Getting Started with Neuroglia","text":"<p>This guide will help you create your first Neuroglia application from scratch. By the end, you'll have a working REST API with dependency injection, CQRS patterns, and clean architecture.</p>"},{"location":"getting-started/#prerequisites","title":"\ud83d\udccb Prerequisites","text":"<ul> <li>Python 3.11 or higher</li> <li>Basic understanding of FastAPI and async/await patterns</li> <li>Familiarity with dependency injection concepts</li> </ul>"},{"location":"getting-started/#quick-setup","title":"\u26a1 Quick Setup","text":""},{"location":"getting-started/#1-installation","title":"1. Installation","text":"<pre><code># Install from PyPI (when available)\npip install neuroglia\n\n# Or install from source\ngit clone &lt;repository-url&gt;\ncd pyneuro\npip install -e .\n</code></pre>"},{"location":"getting-started/#2-project-structure","title":"2. Project Structure","text":"<p>Create a new project with the following structure:</p> <pre><code>my-app/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 main.py                 # Application entry point\n\u2502   \u251c\u2500\u2500 api/                    # API Layer\n\u2502   \u2502   \u2514\u2500\u2500 controllers/        # REST controllers\n\u2502   \u251c\u2500\u2500 application/            # Application Layer\n\u2502   \u2502   \u251c\u2500\u2500 commands/           # Command handlers\n\u2502   \u2502   \u251c\u2500\u2500 queries/            # Query handlers\n\u2502   \u2502   \u2514\u2500\u2500 services/           # Business services\n\u2502   \u251c\u2500\u2500 domain/                 # Domain Layer\n\u2502   \u2502   \u2514\u2500\u2500 models/             # Domain entities\n\u2502   \u2514\u2500\u2500 integration/            # Integration Layer\n\u2502       \u251c\u2500\u2500 models/             # DTOs and external models\n\u2502       \u2514\u2500\u2500 services/           # External service clients\n\u2514\u2500\u2500 requirements.txt\n</code></pre>"},{"location":"getting-started/#3-create-your-first-application","title":"3. Create Your First Application","text":"<p>main.py - Application entry point:</p> <pre><code>import logging\nfrom neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.mediation.mediator import Mediator\nfrom neuroglia.mapping.mapper import Mapper\nfrom neuroglia.serialization.json import JsonSerializer\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlog = logging.getLogger(__name__)\n\ndef create_app():\n    \"\"\"Create and configure the Neuroglia application\"\"\"\n\n    # Create the application builder\n    builder = WebApplicationBuilder()\n\n    # Configure core services\n    Mapper.configure(builder, [\"application\", \"domain\", \"integration\"])\n    Mediator.configure(builder, [\"application\"])\n    JsonSerializer.configure(builder)\n\n    # Register controllers\n    builder.add_controllers([\"api.controllers\"])\n\n    # Build the application\n    app = builder.build()\n\n    # Configure middleware and routes\n    app.use_controllers()\n\n    return app\n\nif __name__ == \"__main__\":\n    app = create_app()\n    app.run()\n</code></pre>"},{"location":"getting-started/#4-create-a-domain-model","title":"4. Create a Domain Model","text":"<p>domain/models/user.py:</p> <pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Optional\nfrom neuroglia.data.abstractions import Entity\n\n@dataclass\nclass User(Entity[str]):\n    \"\"\"User domain entity\"\"\"\n\n    id: str\n    email: str\n    first_name: str\n    last_name: str\n    is_active: bool = True\n    created_at: Optional[datetime] = None\n\n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.utcnow()\n\n    @property\n    def full_name(self) -&gt; str:\n        \"\"\"Get the user's full name\"\"\"\n        return f\"{self.first_name} {self.last_name}\"\n\n    def deactivate(self):\n        \"\"\"Deactivate the user\"\"\"\n        self.is_active = False\n</code></pre>"},{"location":"getting-started/#5-create-dtos-for-the-api","title":"5. Create DTOs for the API","text":"<p>integration/models/user_dto.py:</p> <pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Optional\n\n@dataclass\nclass UserDto:\n    \"\"\"User data transfer object\"\"\"\n\n    id: str\n    email: str\n    first_name: str\n    last_name: str\n    full_name: str\n    is_active: bool\n    created_at: Optional[datetime] = None\n\n@dataclass\nclass CreateUserDto:\n    \"\"\"DTO for creating a new user\"\"\"\n\n    email: str\n    first_name: str\n    last_name: str\n</code></pre>"},{"location":"getting-started/#6-create-commands-and-queries","title":"6. Create Commands and Queries","text":"<p>application/commands/create_user_command.py:</p> <pre><code>from dataclasses import dataclass\nfrom neuroglia.core.operation_result import OperationResult\nfrom neuroglia.mediation.mediator import Command, CommandHandler\nfrom neuroglia.mapping.mapper import Mapper, map_from\nfrom integration.models.user_dto import CreateUserDto, UserDto\nfrom domain.models.user import User\nimport uuid\n\n@map_from(CreateUserDto)\n@dataclass\nclass CreateUserCommand(Command[OperationResult[UserDto]]):\n    \"\"\"Command to create a new user\"\"\"\n\n    email: str\n    first_name: str\n    last_name: str\n\nclass CreateUserCommandHandler(CommandHandler[CreateUserCommand, OperationResult[UserDto]]):\n    \"\"\"Handler for CreateUserCommand\"\"\"\n\n    def __init__(self, mapper: Mapper):\n        self.mapper = mapper\n        # In a real app, you'd inject a repository here\n        self._users = {}  # Simple in-memory storage for demo\n\n    async def handle_async(self, command: CreateUserCommand) -&gt; OperationResult[UserDto]:\n        # Create the domain entity\n        user = User(\n            id=str(uuid.uuid4()),\n            email=command.email,\n            first_name=command.first_name,\n            last_name=command.last_name\n        )\n\n        # Store the user (in a real app, use a repository)\n        self._users[user.id] = user\n\n        # Map to DTO and return\n        user_dto = self.mapper.map(user, UserDto)\n        return self.created(user_dto)\n</code></pre> <p>application/queries/get_user_query.py:</p> <pre><code>from dataclasses import dataclass\nfrom neuroglia.core.operation_result import OperationResult\nfrom neuroglia.mediation.mediator import Query, QueryHandler\nfrom neuroglia.mapping.mapper import Mapper\nfrom integration.models.user_dto import UserDto\nfrom typing import Optional\n\n@dataclass\nclass GetUserQuery(Query[OperationResult[UserDto]]):\n    \"\"\"Query to get a user by ID\"\"\"\n\n    user_id: str\n\nclass GetUserQueryHandler(QueryHandler[GetUserQuery, OperationResult[UserDto]]):\n    \"\"\"Handler for GetUserQuery\"\"\"\n\n    def __init__(self, mapper: Mapper):\n        self.mapper = mapper\n        # In a real app, you'd inject a repository here\n        self._users = {}  # Simple in-memory storage for demo\n\n    async def handle_async(self, query: GetUserQuery) -&gt; OperationResult[UserDto]:\n        user = self._users.get(query.user_id)\n\n        if user is None:\n            return self.not_found(f\"User with ID {query.user_id} not found\")\n\n        user_dto = self.mapper.map(user, UserDto)\n        return self.ok(user_dto)\n</code></pre>"},{"location":"getting-started/#7-create-a-controller","title":"7. Create a Controller","text":"<p>api/controllers/users_controller.py:</p> <pre><code>from typing import List\nfrom fastapi import status\nfrom classy_fastapi.decorators import get, post\nfrom neuroglia.mvc.controller_base import ControllerBase\nfrom neuroglia.dependency_injection.service_provider import ServiceProviderBase\nfrom neuroglia.mapping.mapper import Mapper\nfrom neuroglia.mediation.mediator import Mediator\n\nfrom integration.models.user_dto import UserDto, CreateUserDto\nfrom application.commands.create_user_command import CreateUserCommand\nfrom application.queries.get_user_query import GetUserQuery\n\nclass UsersController(ControllerBase):\n    \"\"\"Users API controller\"\"\"\n\n    def __init__(self, service_provider: ServiceProviderBase, mapper: Mapper, mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n    @post(\"/\", response_model=UserDto, status_code=status.HTTP_201_CREATED)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        \"\"\"Create a new user\"\"\"\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @get(\"/{user_id}\", response_model=UserDto)\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        \"\"\"Get a user by ID\"\"\"\n        query = GetUserQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"getting-started/#8-configure-object-mapping","title":"8. Configure Object Mapping","text":"<p>Add mapping profiles to configure how objects are mapped between layers:</p> <p>application/mapping/user_mapping.py:</p> <pre><code>from neuroglia.mapping.mapper import Mapper\nfrom domain.models.user import User\nfrom integration.models.user_dto import UserDto\n\ndef configure_user_mapping():\n    \"\"\"Configure mapping between User and UserDto\"\"\"\n\n    # Map from User entity to UserDto\n    Mapper.create_map(User, UserDto).add_member_mapping(\n        lambda src: src.full_name, lambda dst: dst.full_name\n    )\n\n    # Map from UserDto back to User (if needed)\n    Mapper.create_map(UserDto, User)\n\n# Auto-configure when module is imported\nconfigure_user_mapping()\n</code></pre>"},{"location":"getting-started/#9-run-your-application","title":"9. Run Your Application","text":"<pre><code>cd my-app\npython src/main.py\n</code></pre> <p>Your API will be available at:</p> <ul> <li>API Documentation: http://localhost:8000/api/docs</li> <li>Create User: <code>POST http://localhost:8000/api/v1/users/</code></li> <li>Get User: <code>GET http://localhost:8000/api/v1/users/{user_id}</code></li> </ul>"},{"location":"getting-started/#testing-your-api","title":"\ud83e\uddea Testing Your API","text":"<p>Use curl or any HTTP client to test your endpoints:</p> <pre><code># Create a user\ncurl -X POST \"http://localhost:8000/api/v1/users/\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"email\": \"john.doe@example.com\",\n    \"first_name\": \"John\",\n    \"last_name\": \"Doe\"\n  }'\n\n# Get the user (replace {user_id} with the ID from the response above)\ncurl \"http://localhost:8000/api/v1/users/{user_id}\"\n</code></pre>"},{"location":"getting-started/#what-youve-learned","title":"\ud83c\udfaf What You've Learned","text":"<p>Congratulations! You've created a complete Neuroglia application that demonstrates:</p> <p>\u2705 Clean Architecture: Separation of concerns across layers \u2705 Dependency Injection: Automatic service registration and resolution \u2705 CQRS Pattern: Commands for writes, queries for reads \u2705 Object Mapping: Automatic mapping between domain models and DTOs \u2705 MVC Controllers: Clean REST API endpoints \u2705 Mediation: Decoupled request handling  </p>"},{"location":"getting-started/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<p>Now that you have a basic application running, explore these advanced features:</p> <ul> <li>Data Access: Add real repositories with MongoDB or Event Store</li> <li>Event Handling: Implement event-driven architecture with CloudEvents</li> <li>Authentication: Add security to your APIs</li> <li>Background Tasks: Process long-running tasks</li> <li>Testing: Write comprehensive tests for your application</li> </ul>"},{"location":"getting-started/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Architecture Guide - Deep dive into the framework's architecture</li> <li>Dependency Injection - Advanced DI patterns</li> <li>CQRS &amp; Mediation - Command and query patterns</li> <li>Sample Applications - Complete example applications</li> </ul>"},{"location":"features/cqrs-mediation/","title":"\ud83c\udfaf CQRS &amp; Mediation","text":"<p>Neuroglia implements Command Query Responsibility Segregation (CQRS) through a powerful mediation pattern that decouples your application logic and promotes clean separation between commands (writes) and queries (reads).</p>"},{"location":"features/cqrs-mediation/#overview","title":"\ud83c\udfad Overview","text":"<p>The mediation system provides:</p> <ul> <li>Commands: Operations that modify state</li> <li>Queries: Operations that retrieve data  </li> <li>Events: Notifications of state changes</li> <li>Handlers: Process commands, queries, and events</li> <li>Mediator: Routes requests to appropriate handlers</li> </ul>"},{"location":"features/cqrs-mediation/#core-concepts","title":"\ud83c\udfd7\ufe0f Core Concepts","text":""},{"location":"features/cqrs-mediation/#commands","title":"Commands","text":"<p>Commands represent intentions to change the system state:</p> <pre><code>from dataclasses import dataclass\nfrom neuroglia.mediation.mediator import Command\nfrom neuroglia.core.operation_result import OperationResult\n\n@dataclass\nclass CreateUserCommand(Command[OperationResult[UserDto]]):\n    \"\"\"Command to create a new user\"\"\"\n    email: str\n    first_name: str\n    last_name: str\n    password: str\n\n@dataclass\nclass UpdateUserCommand(Command[OperationResult[UserDto]]):\n    \"\"\"Command to update an existing user\"\"\"\n    user_id: str\n    first_name: str\n    last_name: str\n\n@dataclass\nclass DeactivateUserCommand(Command[OperationResult]):\n    \"\"\"Command to deactivate a user\"\"\"\n    user_id: str\n</code></pre>"},{"location":"features/cqrs-mediation/#queries","title":"Queries","text":"<p>Queries represent requests for data without side effects:</p> <pre><code>from dataclasses import dataclass\nfrom typing import List\nfrom neuroglia.mediation.mediator import Query\n\n@dataclass\nclass GetUserByIdQuery(Query[OperationResult[UserDto]]):\n    \"\"\"Query to get a user by ID\"\"\"\n    user_id: str\n\n@dataclass\nclass GetUsersByDepartmentQuery(Query[OperationResult[List[UserDto]]]):\n    \"\"\"Query to get users by department\"\"\"\n    department_id: str\n    include_inactive: bool = False\n\n@dataclass\nclass SearchUsersQuery(Query[OperationResult[List[UserDto]]]):\n    \"\"\"Query to search users\"\"\"\n    search_term: str\n    page: int = 1\n    page_size: int = 20\n</code></pre>"},{"location":"features/cqrs-mediation/#events","title":"Events","text":"<p>Events represent things that have happened in the system:</p> <pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom neuroglia.data.abstractions import DomainEvent\n\n@dataclass\nclass UserCreatedEvent(DomainEvent):\n    \"\"\"Event raised when a user is created\"\"\"\n    user_id: str\n    email: str\n    created_at: datetime\n\n@dataclass\nclass UserUpdatedEvent(DomainEvent):\n    \"\"\"Event raised when a user is updated\"\"\"\n    user_id: str\n    changes: dict\n    updated_at: datetime\n\n@dataclass\nclass UserDeactivatedEvent(DomainEvent):\n    \"\"\"Event raised when a user is deactivated\"\"\"\n    user_id: str\n    reason: str\n    deactivated_at: datetime\n</code></pre>"},{"location":"features/cqrs-mediation/#handlers","title":"\ud83c\udfaa Handlers","text":""},{"location":"features/cqrs-mediation/#command-handlers","title":"Command Handlers","text":"<p>Process commands and execute business logic:</p> <pre><code>from neuroglia.mediation.mediator import CommandHandler\nfrom neuroglia.mapping.mapper import Mapper\nfrom neuroglia.data.abstractions import Repository\n\nclass CreateUserCommandHandler(CommandHandler[CreateUserCommand, OperationResult[UserDto]]):\n    \"\"\"Handles user creation commands\"\"\"\n\n    def __init__(self, \n                 user_repository: Repository[User, str],\n                 mapper: Mapper,\n                 password_service: IPasswordService,\n                 email_service: IEmailService):\n        self.user_repository = user_repository\n        self.mapper = mapper\n        self.password_service = password_service\n        self.email_service = email_service\n\n    async def handle_async(self, command: CreateUserCommand) -&gt; OperationResult[UserDto]:\n        # Validate business rules\n        existing_user = await self.user_repository.get_by_email_async(command.email)\n        if existing_user:\n            return self.conflict(\"User with this email already exists\")\n\n        # Hash password\n        password_hash = await self.password_service.hash_password(command.password)\n\n        # Create domain entity\n        user = User.create(\n            email=command.email,\n            first_name=command.first_name,\n            last_name=command.last_name,\n            password_hash=password_hash\n        )\n\n        # Save to repository\n        saved_user = await self.user_repository.add_async(user)\n\n        # Send welcome email (side effect)\n        await self.email_service.send_welcome_email(saved_user.email)\n\n        # Map to DTO and return success\n        user_dto = self.mapper.map(saved_user, UserDto)\n        return self.created(user_dto)\n</code></pre>"},{"location":"features/cqrs-mediation/#query-handlers","title":"Query Handlers","text":"<p>Process queries and return data:</p> <pre><code>class GetUserByIdQueryHandler(QueryHandler[GetUserByIdQuery, OperationResult[UserDto]]):\n    \"\"\"Handles user lookup queries\"\"\"\n\n    def __init__(self, \n                 user_repository: Repository[User, str],\n                 mapper: Mapper):\n        self.user_repository = user_repository\n        self.mapper = mapper\n\n    async def handle_async(self, query: GetUserByIdQuery) -&gt; OperationResult[UserDto]:\n        user = await self.user_repository.get_by_id_async(query.user_id)\n\n        if user is None:\n            return self.not_found(f\"User with ID {query.user_id} not found\")\n\n        user_dto = self.mapper.map(user, UserDto)\n        return self.ok(user_dto)\n\nclass SearchUsersQueryHandler(QueryHandler[SearchUsersQuery, OperationResult[List[UserDto]]]):\n    \"\"\"Handles user search queries\"\"\"\n\n    def __init__(self, \n                 user_repository: Repository[User, str],\n                 mapper: Mapper):\n        self.user_repository = user_repository\n        self.mapper = mapper\n\n    async def handle_async(self, query: SearchUsersQuery) -&gt; OperationResult[List[UserDto]]:\n        users = await self.user_repository.search_async(\n            search_term=query.search_term,\n            page=query.page,\n            page_size=query.page_size\n        )\n\n        user_dtos = [self.mapper.map(user, UserDto) for user in users]\n        return self.ok(user_dtos)\n</code></pre>"},{"location":"features/cqrs-mediation/#event-handlers","title":"Event Handlers","text":"<p>Process events for side effects and integrations:</p> <pre><code>from neuroglia.mediation.mediator import EventHandler\n\nclass UserCreatedEventHandler(EventHandler[UserCreatedEvent]):\n    \"\"\"Handles user created events\"\"\"\n\n    def __init__(self, \n                 audit_service: IAuditService,\n                 analytics_service: IAnalyticsService):\n        self.audit_service = audit_service\n        self.analytics_service = analytics_service\n\n    async def handle_async(self, event: UserCreatedEvent):\n        # Log audit entry\n        await self.audit_service.log_user_created(event.user_id, event.created_at)\n\n        # Track analytics\n        await self.analytics_service.track_user_registration(event.user_id)\n\nclass SendWelcomeEmailHandler(EventHandler[UserCreatedEvent]):\n    \"\"\"Sends welcome email when user is created\"\"\"\n\n    def __init__(self, email_service: IEmailService):\n        self.email_service = email_service\n\n    async def handle_async(self, event: UserCreatedEvent):\n        await self.email_service.send_welcome_email(event.email)\n</code></pre>"},{"location":"features/cqrs-mediation/#mediator-usage","title":"\ud83d\ude80 Mediator Usage","text":""},{"location":"features/cqrs-mediation/#configuration","title":"Configuration","text":"<p>Configure the mediator in your application startup:</p> <pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.mediation.mediator import Mediator\n\nbuilder = WebApplicationBuilder()\n\n# Configure mediator with handler modules\nMediator.configure(builder, [\n    \"application.commands\",\n    \"application.queries\",\n    \"application.events\"\n])\n\napp = builder.build()\n</code></pre>"},{"location":"features/cqrs-mediation/#in-controllers","title":"In Controllers","text":"<p>Use the mediator in your API controllers:</p> <pre><code>from neuroglia.mvc.controller_base import ControllerBase\n\nclass UsersController(ControllerBase):\n\n    @post(\"/\", response_model=UserDto, status_code=201)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        # Map DTO to command\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n\n        # Execute through mediator\n        result = await self.mediator.execute_async(command)\n\n        # Process result and return\n        return self.process(result)\n\n    @get(\"/{user_id}\", response_model=UserDto)\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        # Create query\n        query = GetUserByIdQuery(user_id=user_id)\n\n        # Execute through mediator\n        result = await self.mediator.execute_async(query)\n\n        # Process result and return\n        return self.process(result)\n\n    @get(\"/\", response_model=List[UserDto])\n    async def search_users(self, \n                          search: str = \"\",\n                          page: int = 1,\n                          page_size: int = 20) -&gt; List[UserDto]:\n        # Create query\n        query = SearchUsersQuery(\n            search_term=search,\n            page=page,\n            page_size=page_size\n        )\n\n        # Execute through mediator\n        result = await self.mediator.execute_async(query)\n\n        # Process result and return\n        return self.process(result)\n</code></pre>"},{"location":"features/cqrs-mediation/#in-services","title":"In Services","text":"<p>Use the mediator in application services:</p> <pre><code>class UserService:\n    def __init__(self, mediator: Mediator):\n        self.mediator = mediator\n\n    async def register_user(self, registration_data: UserRegistrationData) -&gt; UserDto:\n        # Create command\n        command = CreateUserCommand(\n            email=registration_data.email,\n            first_name=registration_data.first_name,\n            last_name=registration_data.last_name,\n            password=registration_data.password\n        )\n\n        # Execute command\n        result = await self.mediator.execute_async(command)\n\n        if result.is_success:\n            return result.data\n        else:\n            raise UserRegistrationException(result.error_message)\n</code></pre>"},{"location":"features/cqrs-mediation/#advanced-patterns","title":"\ud83c\udfad Advanced Patterns","text":""},{"location":"features/cqrs-mediation/#pipeline-behaviors","title":"Pipeline Behaviors","text":"<p>Add cross-cutting concerns through pipeline behaviors:</p> <pre><code>from neuroglia.mediation.mediator import PipelineBehavior\n\nclass ValidationBehavior(PipelineBehavior):\n    \"\"\"Validates requests before processing\"\"\"\n\n    async def handle_async(self, request, next_handler):\n        # Validate request\n        if hasattr(request, 'validate'):\n            validation_result = request.validate()\n            if not validation_result.is_valid:\n                return OperationResult.validation_error(validation_result.errors)\n\n        # Continue to next behavior/handler\n        return await next_handler()\n\nclass LoggingBehavior(PipelineBehavior):\n    \"\"\"Logs requests and responses\"\"\"\n\n    def __init__(self, logger: Logger):\n        self.logger = logger\n\n    async def handle_async(self, request, next_handler):\n        request_name = type(request).__name__\n        self.logger.info(f\"Executing {request_name}\")\n\n        try:\n            result = await next_handler()\n            self.logger.info(f\"Completed {request_name}\")\n            return result\n        except Exception as ex:\n            self.logger.error(f\"Failed {request_name}: {ex}\")\n            raise\n\n# Register behaviors\nbuilder.services.add_pipeline_behavior(ValidationBehavior)\nbuilder.services.add_pipeline_behavior(LoggingBehavior)\n</code></pre>"},{"location":"features/cqrs-mediation/#transaction-behavior","title":"Transaction Behavior","text":"<p>Wrap commands in database transactions:</p> <pre><code>class TransactionBehavior(PipelineBehavior):\n    \"\"\"Wraps commands in database transactions\"\"\"\n\n    def __init__(self, unit_of_work: IUnitOfWork):\n        self.unit_of_work = unit_of_work\n\n    async def handle_async(self, request, next_handler):\n        # Only apply to commands\n        if not isinstance(request, Command):\n            return await next_handler()\n\n        async with self.unit_of_work.begin_transaction():\n            try:\n                result = await next_handler()\n                await self.unit_of_work.commit()\n                return result\n            except Exception:\n                await self.unit_of_work.rollback()\n                raise\n</code></pre>"},{"location":"features/cqrs-mediation/#caching-behavior","title":"Caching Behavior","text":"<p>Cache query results:</p> <pre><code>class CachingBehavior(PipelineBehavior):\n    \"\"\"Caches query results\"\"\"\n\n    def __init__(self, cache_service: ICacheService):\n        self.cache_service = cache_service\n\n    async def handle_async(self, request, next_handler):\n        # Only cache queries\n        if not isinstance(request, Query):\n            return await next_handler()\n\n        # Generate cache key\n        cache_key = f\"{type(request).__name__}:{hash(str(request))}\"\n\n        # Try to get from cache\n        cached_result = await self.cache_service.get_async(cache_key)\n        if cached_result:\n            return cached_result\n\n        # Execute query\n        result = await next_handler()\n\n        # Cache successful results\n        if result.is_success:\n            await self.cache_service.set_async(cache_key, result, expiry=timedelta(minutes=5))\n\n        return result\n</code></pre>"},{"location":"features/cqrs-mediation/#domain-events","title":"\ud83c\udfdb\ufe0f Domain Events","text":""},{"location":"features/cqrs-mediation/#publishing-events","title":"Publishing Events","text":"<p>Publish domain events from entities or handlers:</p> <pre><code>class User(AggregateRoot[str]):\n    def create(self, email: str, first_name: str, last_name: str):\n        # Apply business rules\n        self.email = email\n        self.first_name = first_name\n        self.last_name = last_name\n        self.created_at = datetime.utcnow()\n\n        # Raise domain event\n        self.raise_event(UserCreatedEvent(\n            user_id=self.id,\n            email=self.email,\n            created_at=self.created_at\n        ))\n\nclass CreateUserCommandHandler(CommandHandler[CreateUserCommand, OperationResult[UserDto]]):\n    async def handle_async(self, command: CreateUserCommand) -&gt; OperationResult[UserDto]:\n        # Create user (events are raised automatically)\n        user = User.create(command.email, command.first_name, command.last_name)\n\n        # Save user (this will publish the events)\n        await self.user_repository.add_async(user)\n\n        return self.created(self.mapper.map(user, UserDto))\n</code></pre>"},{"location":"features/cqrs-mediation/#event-dispatching","title":"Event Dispatching","text":"<p>Events are automatically dispatched to registered handlers:</p> <pre><code># Multiple handlers can listen to the same event\nclass UserCreatedEventHandler(EventHandler[UserCreatedEvent]):\n    async def handle_async(self, event: UserCreatedEvent):\n        # Handle audit logging\n        pass\n\nclass WelcomeEmailHandler(EventHandler[UserCreatedEvent]):\n    async def handle_async(self, event: UserCreatedEvent):\n        # Send welcome email\n        pass\n\nclass AnalyticsHandler(EventHandler[UserCreatedEvent]):\n    async def handle_async(self, event: UserCreatedEvent):\n        # Track user registration\n        pass\n</code></pre>"},{"location":"features/cqrs-mediation/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"features/cqrs-mediation/#testing-handlers","title":"Testing Handlers","text":"<p>Test handlers in isolation:</p> <pre><code>import pytest\nfrom unittest.mock import Mock\n\n@pytest.mark.asyncio\nasync def test_create_user_command_handler():\n    # Arrange\n    mock_repository = Mock()\n    mock_mapper = Mock()\n    mock_password_service = Mock()\n    mock_email_service = Mock()\n\n    handler = CreateUserCommandHandler(\n        mock_repository, \n        mock_mapper, \n        mock_password_service,\n        mock_email_service\n    )\n\n    command = CreateUserCommand(\n        email=\"test@example.com\",\n        first_name=\"John\",\n        last_name=\"Doe\",\n        password=\"password123\"\n    )\n\n    # Configure mocks\n    mock_repository.get_by_email_async.return_value = None\n    mock_password_service.hash_password.return_value = \"hashed_password\"\n    mock_repository.add_async.return_value = test_user\n    mock_mapper.map.return_value = test_user_dto\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n    assert result.data == test_user_dto\n    mock_repository.add_async.assert_called_once()\n    mock_email_service.send_welcome_email.assert_called_once()\n</code></pre>"},{"location":"features/cqrs-mediation/#integration-testing","title":"Integration Testing","text":"<p>Test the complete flow through the mediator:</p> <pre><code>@pytest.mark.asyncio\nasync def test_user_creation_flow():\n    # Arrange\n    test_client = TestClient(app)\n\n    user_data = {\n        \"email\": \"test@example.com\",\n        \"first_name\": \"John\",\n        \"last_name\": \"Doe\",\n        \"password\": \"password123\"\n    }\n\n    # Act\n    response = test_client.post(\"/api/v1/users\", json=user_data)\n\n    # Assert\n    assert response.status_code == 201\n\n    created_user = response.json()\n    assert created_user[\"email\"] == user_data[\"email\"]\n    assert created_user[\"first_name\"] == user_data[\"first_name\"]\n\n    # Verify user was actually created\n    get_response = test_client.get(f\"/api/v1/users/{created_user['id']}\")\n    assert get_response.status_code == 200\n</code></pre>"},{"location":"features/cqrs-mediation/#best-practices","title":"\ud83d\ude80 Best Practices","text":""},{"location":"features/cqrs-mediation/#1-single-responsibility","title":"1. Single Responsibility","text":"<p>Each command/query should have a single, well-defined purpose:</p> <pre><code># Good - Single responsibility\nclass CreateUserCommand: pass\nclass UpdateUserEmailCommand: pass\nclass DeactivateUserCommand: pass\n\n# Avoid - Multiple responsibilities\nclass ManageUserCommand: pass  # Too broad\n</code></pre>"},{"location":"features/cqrs-mediation/#2-immutable-requests","title":"2. Immutable Requests","text":"<p>Make commands and queries immutable:</p> <pre><code># Good - Immutable\n@dataclass(frozen=True)\nclass CreateUserCommand:\n    email: str\n    first_name: str\n    last_name: str\n\n# Avoid - Mutable\nclass CreateUserCommand:\n    def __init__(self):\n        self.email = None\n        self.first_name = None\n</code></pre>"},{"location":"features/cqrs-mediation/#3-rich-domain-models","title":"3. Rich Domain Models","text":"<p>Use domain events to decouple side effects:</p> <pre><code># Good - Domain events\nclass User:\n    def activate(self):\n        self.is_active = True\n        self.raise_event(UserActivatedEvent(self.id))\n\n# Avoid - Direct coupling\nclass User:\n    def activate(self, email_service: IEmailService):\n        self.is_active = True\n        email_service.send_activation_email(self.email)  # Tight coupling\n</code></pre>"},{"location":"features/cqrs-mediation/#4-validation","title":"4. Validation","text":"<p>Validate inputs at the right level:</p> <pre><code># Domain validation (business rules)\nclass CreateUserCommand:\n    def validate(self) -&gt; ValidationResult:\n        errors = []\n        if not self.email or '@' not in self.email:\n            errors.append(\"Valid email is required\")\n        return ValidationResult(errors)\n\n# Input validation (format/required fields)\nclass CreateUserDto:\n    email: str = Field(..., regex=r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$')\n    first_name: str = Field(..., min_length=1, max_length=50)\n</code></pre>"},{"location":"features/cqrs-mediation/#5-error-handling","title":"5. Error Handling","text":"<p>Use consistent error handling patterns:</p> <pre><code>class CreateUserCommandHandler(CommandHandler):\n    async def handle_async(self, command: CreateUserCommand) -&gt; OperationResult[UserDto]:\n        try:\n            # Business logic\n            user = await self.create_user(command)\n            return self.created(user)\n\n        except EmailAlreadyExistsException:\n            return self.conflict(\"Email already exists\")\n        except InvalidEmailException:\n            return self.bad_request(\"Invalid email format\")\n        except Exception as ex:\n            return self.internal_error(f\"Failed to create user: {ex}\")\n</code></pre>"},{"location":"features/cqrs-mediation/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Basic CQRS usage</li> <li>Architecture Guide - How CQRS fits in the architecture</li> <li>Dependency Injection - DI with handlers</li> <li>Data Access - Repositories and units of work</li> <li>Event Handling - Domain events and integration events</li> </ul>"},{"location":"features/data-access/","title":"\ud83d\uddc4\ufe0f Data Access","text":"<p>Neuroglia provides a flexible data access layer that supports multiple storage backends through a unified repository pattern. It includes built-in support for MongoDB, Event Store, and in-memory repositories, with extensibility for other data stores.</p>"},{"location":"features/data-access/#overview","title":"\ud83c\udfaf Overview","text":"<p>The data access system provides:</p> <ul> <li>Repository Pattern: Unified interface for data operations</li> <li>Multiple Storage Backends: MongoDB, Event Store, in-memory, and custom implementations</li> <li>Event Sourcing: Complete event sourcing support with EventStoreDB</li> <li>CQRS Support: Separate read and write models</li> <li>Query Abstractions: Flexible querying capabilities</li> <li>Unit of Work: Transaction management across repositories</li> </ul>"},{"location":"features/data-access/#core-abstractions","title":"\ud83c\udfd7\ufe0f Core Abstractions","text":""},{"location":"features/data-access/#repository-interface","title":"Repository Interface","text":"<p>The base repository interface defines standard CRUD operations:</p> <pre><code>from abc import ABC, abstractmethod\nfrom typing import Generic, TypeVar, List, Optional\n\nTEntity = TypeVar('TEntity')\nTKey = TypeVar('TKey')\n\nclass Repository(Generic[TEntity, TKey], ABC):\n    \"\"\"Base repository interface\"\"\"\n\n    @abstractmethod\n    async def get_by_id_async(self, id: TKey) -&gt; Optional[TEntity]:\n        \"\"\"Get entity by ID\"\"\"\n        pass\n\n    @abstractmethod\n    async def add_async(self, entity: TEntity) -&gt; TEntity:\n        \"\"\"Add new entity\"\"\"\n        pass\n\n    @abstractmethod\n    async def update_async(self, entity: TEntity) -&gt; TEntity:\n        \"\"\"Update existing entity\"\"\"\n        pass\n\n    @abstractmethod\n    async def remove_async(self, entity: TEntity):\n        \"\"\"Remove entity\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_async(self, predicate) -&gt; List[TEntity]:\n        \"\"\"Find entities matching predicate\"\"\"\n        pass\n</code></pre>"},{"location":"features/data-access/#queryable-interface","title":"Queryable Interface","text":"<p>For advanced querying capabilities:</p> <pre><code>from neuroglia.data.abstractions import Queryable\n\nclass ExtendedRepository(Repository[TEntity, TKey], Queryable[TEntity]):\n    \"\"\"Repository with advanced querying\"\"\"\n\n    async def where(self, predicate) -&gt; 'ExtendedRepository[TEntity, TKey]':\n        \"\"\"Filter entities\"\"\"\n        pass\n\n    async def order_by(self, selector) -&gt; 'ExtendedRepository[TEntity, TKey]':\n        \"\"\"Order entities\"\"\"\n        pass\n\n    async def take(self, count: int) -&gt; 'ExtendedRepository[TEntity, TKey]':\n        \"\"\"Take specified number of entities\"\"\"\n        pass\n</code></pre>"},{"location":"features/data-access/#mongodb-integration","title":"\ud83d\uddc3\ufe0f MongoDB Integration","text":""},{"location":"features/data-access/#mongodb-repository","title":"MongoDB Repository","text":"<p>Built-in MongoDB repository implementation:</p> <pre><code>from neuroglia.data.infrastructure.mongo import MongoRepository\nfrom motor.motor_asyncio import AsyncIOMotorClient\n\nclass UserRepository(MongoRepository[User, str]):\n    \"\"\"MongoDB repository for users\"\"\"\n\n    def __init__(self, connection_string: str, database_name: str):\n        super().__init__(connection_string, database_name, \"users\")\n\n    async def get_by_email_async(self, email: str) -&gt; Optional[User]:\n        \"\"\"Custom method to find user by email\"\"\"\n        filter_dict = {\"email\": email}\n        document = await self.collection.find_one(filter_dict)\n\n        if document is None:\n            return None\n\n        return self._map_document_to_entity(document)\n\n    async def find_by_department_async(self, department: str) -&gt; List[User]:\n        \"\"\"Find users by department\"\"\"\n        filter_dict = {\"department\": department}\n        cursor = self.collection.find(filter_dict)\n\n        users = []\n        async for document in cursor:\n            users.append(self._map_document_to_entity(document))\n\n        return users\n</code></pre>"},{"location":"features/data-access/#configuration","title":"Configuration","text":"<p>Configure MongoDB repositories in your application:</p> <pre><code>from neuroglia.hosting.web import WebApplicationBuilder\nfrom neuroglia.hosting.configuration.data_access_layer import DataAccessLayer\n\nbuilder = WebApplicationBuilder()\n\n# Configure MongoDB repositories for read models\nDataAccessLayer.ReadModel.configure(\n    builder,\n    [\"integration.models\"],  # Modules containing DTOs\n    lambda builder_, entity_type, key_type: MongoRepository.configure(\n        builder_, entity_type, key_type, \"myapp_db\"\n    )\n)\n\napp = builder.build()\n</code></pre>"},{"location":"features/data-access/#event-sourcing","title":"\ud83d\udcc5 Event Sourcing","text":""},{"location":"features/data-access/#event-store-repository","title":"Event Store Repository","text":"<p>For event-sourced aggregates:</p> <pre><code>from neuroglia.data.infrastructure.event_sourcing import EventSourcingRepository\nfrom neuroglia.data.abstractions import AggregateRoot\n\nclass Person(AggregateRoot[str]):\n    \"\"\"Event-sourced person aggregate\"\"\"\n\n    def __init__(self, id: str = None):\n        super().__init__(id)\n        self.state = PersonState()\n\n    def register(self, first_name: str, last_name: str, email: str):\n        \"\"\"Register a new person\"\"\"\n        self.apply(PersonRegisteredEvent(\n            person_id=self.id,\n            first_name=first_name,\n            last_name=last_name,\n            email=email\n        ))\n\n    def change_email(self, new_email: str):\n        \"\"\"Change person's email\"\"\"\n        self.apply(PersonEmailChangedEvent(\n            person_id=self.id,\n            old_email=self.state.email,\n            new_email=new_email\n        ))\n\n    # Event handlers\n    def on_person_registered(self, event: PersonRegisteredEvent):\n        self.state.id = event.person_id\n        self.state.first_name = event.first_name\n        self.state.last_name = event.last_name\n        self.state.email = event.email\n\n    def on_person_email_changed(self, event: PersonEmailChangedEvent):\n        self.state.email = event.new_email\n</code></pre>"},{"location":"features/data-access/#event-store-configuration","title":"Event Store Configuration","text":"<p>Configure EventStoreDB integration:</p> <pre><code>from neuroglia.data.infrastructure.event_sourcing.event_store import ESEventStore\nfrom neuroglia.data.infrastructure.event_sourcing.abstractions import EventStoreOptions\n\n# Configure EventStore\nbuilder = WebApplicationBuilder()\n\nESEventStore.configure(\n    builder,\n    EventStoreOptions(\n        database_name=\"myapp\",\n        consumer_group=\"myapp_consumers\"\n    )\n)\n\n# Configure event sourcing repositories for write models\nDataAccessLayer.WriteModel.configure(\n    builder,\n    [\"domain.models\"],  # Modules containing aggregates\n    lambda builder_, entity_type, key_type: EventSourcingRepository.configure(\n        builder_, entity_type, key_type\n    )\n)\n</code></pre>"},{"location":"features/data-access/#in-memory-repository","title":"\ud83d\udcbe In-Memory Repository","text":"<p>For testing and development:</p> <pre><code>from neuroglia.data.infrastructure.memory import MemoryRepository\n\nclass InMemoryUserRepository(MemoryRepository[User, str]):\n    \"\"\"In-memory repository for testing\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self._users_by_email = {}\n\n    async def add_async(self, user: User) -&gt; User:\n        \"\"\"Add user and index by email\"\"\"\n        result = await super().add_async(user)\n        self._users_by_email[user.email] = user\n        return result\n\n    async def get_by_email_async(self, email: str) -&gt; Optional[User]:\n        \"\"\"Get user by email\"\"\"\n        return self._users_by_email.get(email)\n\n    async def remove_async(self, user: User):\n        \"\"\"Remove user and clean up email index\"\"\"\n        await super().remove_async(user)\n        if user.email in self._users_by_email:\n            del self._users_by_email[user.email]\n</code></pre>"},{"location":"features/data-access/#cqrs-with-separate-models","title":"\ud83d\udd04 CQRS with Separate Models","text":""},{"location":"features/data-access/#write-model-commands","title":"Write Model (Commands)","text":"<p>Use event-sourced aggregates for write operations:</p> <pre><code>class CreateUserCommandHandler(CommandHandler[CreateUserCommand, OperationResult[UserDto]]):\n    \"\"\"Handles user creation commands\"\"\"\n\n    def __init__(self, \n                 user_repository: Repository[User, str],  # Event-sourced repository\n                 mapper: Mapper):\n        self.user_repository = user_repository\n        self.mapper = mapper\n\n    async def handle_async(self, command: CreateUserCommand) -&gt; OperationResult[UserDto]:\n        # Create aggregate\n        user = User(str(uuid.uuid4()))\n        user.register(command.first_name, command.last_name, command.email)\n\n        # Save to event store\n        saved_user = await self.user_repository.add_async(user)\n\n        # Return DTO\n        user_dto = self.mapper.map(saved_user.state, UserDto)\n        return self.created(user_dto)\n</code></pre>"},{"location":"features/data-access/#read-model-queries","title":"Read Model (Queries)","text":"<p>Use optimized read models for queries:</p> <pre><code>@dataclass\nclass UserReadModel:\n    \"\"\"Optimized read model for user queries\"\"\"\n    id: str\n    first_name: str\n    last_name: str\n    email: str\n    full_name: str\n    department: str\n    created_at: datetime\n    is_active: bool\n\nclass GetUsersQueryHandler(QueryHandler[GetUsersQuery, OperationResult[List[UserDto]]]):\n    \"\"\"Handles user queries using read model\"\"\"\n\n    def __init__(self, \n                 read_model_repository: Repository[UserReadModel, str]):\n        self.read_model_repository = read_model_repository\n\n    async def handle_async(self, query: GetUsersQuery) -&gt; OperationResult[List[UserDto]]:\n        # Query optimized read model\n        users = await self.read_model_repository.find_async(\n            lambda u: u.department == query.department if query.department else True\n        )\n\n        # Map to DTOs\n        user_dtos = [self._map_to_dto(user) for user in users]\n        return self.ok(user_dtos)\n</code></pre>"},{"location":"features/data-access/#custom-repository-implementation","title":"\ud83c\udfed Custom Repository Implementation","text":""},{"location":"features/data-access/#creating-custom-repository","title":"Creating Custom Repository","text":"<p>Implement the repository interface for custom data stores:</p> <pre><code>import aioredis\nfrom typing import Optional, List\n\nclass RedisUserRepository(Repository[User, str]):\n    \"\"\"Redis-based user repository\"\"\"\n\n    def __init__(self, redis_url: str):\n        self.redis_url = redis_url\n        self._redis = None\n\n    async def _get_redis(self):\n        \"\"\"Get Redis connection\"\"\"\n        if self._redis is None:\n            self._redis = await aioredis.from_url(self.redis_url)\n        return self._redis\n\n    async def get_by_id_async(self, user_id: str) -&gt; Optional[User]:\n        \"\"\"Get user from Redis\"\"\"\n        redis = await self._get_redis()\n        data = await redis.get(f\"user:{user_id}\")\n\n        if data is None:\n            return None\n\n        return self._deserialize_user(data)\n\n    async def add_async(self, user: User) -&gt; User:\n        \"\"\"Add user to Redis\"\"\"\n        redis = await self._get_redis()\n        data = self._serialize_user(user)\n        await redis.set(f\"user:{user.id}\", data)\n\n        # Add to email index\n        await redis.set(f\"user:email:{user.email}\", user.id)\n\n        return user\n\n    async def update_async(self, user: User) -&gt; User:\n        \"\"\"Update user in Redis\"\"\"\n        return await self.add_async(user)  # Redis is key-value, so update = set\n\n    async def remove_async(self, user: User):\n        \"\"\"Remove user from Redis\"\"\"\n        redis = await self._get_redis()\n        await redis.delete(f\"user:{user.id}\")\n        await redis.delete(f\"user:email:{user.email}\")\n\n    async def find_async(self, predicate) -&gt; List[User]:\n        \"\"\"Find users (basic implementation)\"\"\"\n        redis = await self._get_redis()\n        keys = await redis.keys(\"user:*\")\n\n        users = []\n        for key in keys:\n            if not key.startswith(\"user:email:\"):\n                data = await redis.get(key)\n                user = self._deserialize_user(data)\n                if predicate(user):\n                    users.append(user)\n\n        return users\n\n    def _serialize_user(self, user: User) -&gt; str:\n        \"\"\"Serialize user to JSON\"\"\"\n        import json\n        return json.dumps({\n            'id': user.id,\n            'first_name': user.first_name,\n            'last_name': user.last_name,\n            'email': user.email\n        })\n\n    def _deserialize_user(self, data: str) -&gt; User:\n        \"\"\"Deserialize user from JSON\"\"\"\n        import json\n        user_data = json.loads(data)\n        return User(\n            id=user_data['id'],\n            first_name=user_data['first_name'],\n            last_name=user_data['last_name'],\n            email=user_data['email']\n        )\n</code></pre>"},{"location":"features/data-access/#unit-of-work-pattern","title":"\ud83d\udd04 Unit of Work Pattern","text":"<p>For transaction management across multiple repositories:</p> <pre><code>from abc import ABC, abstractmethod\nfrom contextlib import asynccontextmanager\n\nclass IUnitOfWork(ABC):\n    \"\"\"Unit of work interface\"\"\"\n\n    @property\n    @abstractmethod\n    def users(self) -&gt; Repository[User, str]:\n        pass\n\n    @property\n    @abstractmethod\n    def orders(self) -&gt; Repository[Order, str]:\n        pass\n\n    @abstractmethod\n    async def commit_async(self):\n        \"\"\"Commit all changes\"\"\"\n        pass\n\n    @abstractmethod\n    async def rollback_async(self):\n        \"\"\"Rollback all changes\"\"\"\n        pass\n\n    @asynccontextmanager\n    async def transaction(self):\n        \"\"\"Context manager for transactions\"\"\"\n        try:\n            yield self\n            await self.commit_async()\n        except Exception:\n            await self.rollback_async()\n            raise\n\nclass MongoUnitOfWork(IUnitOfWork):\n    \"\"\"MongoDB implementation of unit of work\"\"\"\n\n    def __init__(self, client: AsyncIOMotorClient, database_name: str):\n        self.client = client\n        self.database_name = database_name\n        self.session = None\n        self._users = None\n        self._orders = None\n\n    @property\n    def users(self) -&gt; Repository[User, str]:\n        if self._users is None:\n            self._users = MongoUserRepository(self.client, self.database_name, self.session)\n        return self._users\n\n    @property\n    def orders(self) -&gt; Repository[Order, str]:\n        if self._orders is None:\n            self._orders = MongoOrderRepository(self.client, self.database_name, self.session)\n        return self._orders\n\n    async def commit_async(self):\n        \"\"\"Commit transaction\"\"\"\n        if self.session:\n            await self.session.commit_transaction()\n\n    async def rollback_async(self):\n        \"\"\"Rollback transaction\"\"\"\n        if self.session:\n            await self.session.abort_transaction()\n\n    @asynccontextmanager\n    async def transaction(self):\n        \"\"\"Start a MongoDB transaction\"\"\"\n        async with await self.client.start_session() as session:\n            self.session = session\n            async with session.start_transaction():\n                try:\n                    yield self\n                    await session.commit_transaction()\n                except Exception:\n                    await session.abort_transaction()\n                    raise\n                finally:\n                    self.session = None\n\n# Usage in command handler\nclass ProcessOrderCommandHandler(CommandHandler[ProcessOrderCommand, OperationResult]):\n    def __init__(self, unit_of_work: IUnitOfWork):\n        self.unit_of_work = unit_of_work\n\n    async def handle_async(self, command: ProcessOrderCommand) -&gt; OperationResult:\n        async with self.unit_of_work.transaction():\n            # Get user\n            user = await self.unit_of_work.users.get_by_id_async(command.user_id)\n            if user is None:\n                return self.not_found(\"User not found\")\n\n            # Create order\n            order = Order.create(command.items, user.id)\n            await self.unit_of_work.orders.add_async(order)\n\n            # Update user stats\n            user.increment_order_count()\n            await self.unit_of_work.users.update_async(user)\n\n            # Transaction commits automatically\n            return self.ok()\n</code></pre>"},{"location":"features/data-access/#testing-with-repositories","title":"\ud83e\uddea Testing with Repositories","text":""},{"location":"features/data-access/#test-doubles","title":"Test Doubles","text":"<p>Use in-memory repositories for testing:</p> <pre><code>import pytest\nfrom unittest.mock import Mock\n\n@pytest.fixture\ndef user_repository():\n    \"\"\"In-memory user repository for testing\"\"\"\n    return InMemoryUserRepository()\n\n@pytest.mark.asyncio\nasync def test_create_user_command(user_repository):\n    # Arrange\n    mapper = Mock()\n    mapper.map.return_value = test_user_dto\n\n    handler = CreateUserCommandHandler(user_repository, mapper)\n    command = CreateUserCommand(\"John\", \"Doe\", \"john@example.com\")\n\n    # Act\n    result = await handler.handle_async(command)\n\n    # Assert\n    assert result.is_success\n\n    # Verify user was saved\n    saved_user = await user_repository.get_by_id_async(result.data.id)\n    assert saved_user is not None\n    assert saved_user.email == \"john@example.com\"\n</code></pre>"},{"location":"features/data-access/#integration-testing","title":"Integration Testing","text":"<p>Test with real databases:</p> <pre><code>import pytest\nimport motor.motor_asyncio\nfrom testcontainers.mongodb import MongoDbContainer\n\n@pytest.fixture(scope=\"session\")\nasync def mongodb_container():\n    \"\"\"Start MongoDB container for testing\"\"\"\n    with MongoDbContainer() as container:\n        yield container\n\n@pytest.fixture\nasync def mongo_repository(mongodb_container):\n    \"\"\"MongoDB repository for integration testing\"\"\"\n    connection_string = mongodb_container.get_connection_url()\n    return MongoUserRepository(connection_string, \"test_db\")\n\n@pytest.mark.asyncio\nasync def test_user_repository_integration(mongo_repository):\n    # Arrange\n    user = User(\"test-id\", \"John\", \"Doe\", \"john@test.com\")\n\n    # Act\n    saved_user = await mongo_repository.add_async(user)\n    retrieved_user = await mongo_repository.get_by_id_async(user.id)\n\n    # Assert\n    assert saved_user.id == user.id\n    assert retrieved_user is not None\n    assert retrieved_user.email == user.email\n</code></pre>"},{"location":"features/data-access/#best-practices","title":"\ud83d\ude80 Best Practices","text":""},{"location":"features/data-access/#1-use-interface-segregation","title":"1. Use Interface Segregation","text":"<p>Define specific repository interfaces for different use cases:</p> <pre><code># Good - Specific interfaces\nclass IUserReadRepository(ABC):\n    async def get_by_email_async(self, email: str) -&gt; Optional[UserDto]:\n        pass\n\n    async def search_async(self, criteria: UserSearchCriteria) -&gt; List[UserDto]:\n        pass\n\nclass IUserWriteRepository(ABC):\n    async def add_async(self, user: User) -&gt; User:\n        pass\n\n    async def update_async(self, user: User) -&gt; User:\n        pass\n\n# Avoid - Generic repository for everything\nclass IGenericUserRepository(Repository[User, str]):\n    # Too broad, mixes read and write concerns\n    pass\n</code></pre>"},{"location":"features/data-access/#2-separate-read-and-write-models","title":"2. Separate Read and Write Models","text":"<p>Use different models for commands and queries:</p> <pre><code># Write model (domain entity)\nclass User(AggregateRoot[str]):\n    # Rich domain model with behavior\n    def change_email(self, new_email: str):\n        # Business logic and validation\n        pass\n\n# Read model (DTO)\n@dataclass\nclass UserListDto:\n    # Optimized for display\n    id: str\n    display_name: str\n    email: str\n    last_login: datetime\n    status: str\n</code></pre>"},{"location":"features/data-access/#3-handle-concurrency","title":"3. Handle Concurrency","text":"<p>Implement optimistic concurrency for event-sourced aggregates:</p> <pre><code>class User(AggregateRoot[str]):\n    def __init__(self, id: str = None):\n        super().__init__(id)\n        self.version = 0  # Concurrency token\n\n    def apply_event(self, event: DomainEvent):\n        super().apply_event(event)\n        self.version += 1\n\nclass EventSourcingRepository(Repository[User, str]):\n    async def update_async(self, user: User) -&gt; User:\n        # Check for concurrent modifications\n        current_version = await self.get_version(user.id)\n        if current_version != user.original_version:\n            raise ConcurrencyException(\"Entity was modified by another process\")\n\n        # Save events\n        await self.save_events(user.uncommitted_events, user.version)\n        return user\n</code></pre>"},{"location":"features/data-access/#4-use-specifications-pattern","title":"4. Use Specifications Pattern","text":"<p>For complex queries:</p> <pre><code>from abc import ABC, abstractmethod\n\nclass Specification(ABC):\n    @abstractmethod\n    def is_satisfied_by(self, entity) -&gt; bool:\n        pass\n\n    def and_(self, other: 'Specification') -&gt; 'Specification':\n        return AndSpecification(self, other)\n\n    def or_(self, other: 'Specification') -&gt; 'Specification':\n        return OrSpecification(self, other)\n\nclass ActiveUserSpecification(Specification):\n    def is_satisfied_by(self, user: User) -&gt; bool:\n        return user.is_active\n\nclass UserInDepartmentSpecification(Specification):\n    def __init__(self, department: str):\n        self.department = department\n\n    def is_satisfied_by(self, user: User) -&gt; bool:\n        return user.department == self.department\n\n# Usage\nactive_engineering_users = ActiveUserSpecification().and_(\n    UserInDepartmentSpecification(\"Engineering\")\n)\n\nusers = await repository.find_async(active_engineering_users.is_satisfied_by)\n</code></pre>"},{"location":"features/data-access/#5-repository-registration","title":"5. Repository Registration","text":"<p>Register repositories properly in DI container:</p> <pre><code># In application startup\nbuilder = WebApplicationBuilder()\n\n# Register by interface\nbuilder.services.add_scoped(IUserRepository, MongoUserRepository)\nbuilder.services.add_scoped(IOrderRepository, EventSourcedOrderRepository)\n\n# Register factory for complex initialization\ndef create_user_repository(provider: ServiceProviderBase) -&gt; IUserRepository:\n    config = provider.get_required_service(DatabaseConfig)\n    if config.use_event_sourcing:\n        return EventSourcedUserRepository(config.event_store_connection)\n    else:\n        return MongoUserRepository(config.mongo_connection, config.database_name)\n\nbuilder.services.add_scoped(IUserRepository, factory=create_user_repository)\n</code></pre>"},{"location":"features/data-access/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Basic repository usage</li> <li>Architecture Guide - How repositories fit in the architecture</li> <li>CQRS &amp; Mediation - Using repositories with CQRS</li> <li>Event Sourcing - Event sourcing with repositories</li> <li>Dependency Injection - DI with repositories</li> </ul>"},{"location":"features/dependency-injection/","title":"\ud83d\udc89 Dependency Injection","text":"<p>Neuroglia provides a lightweight, powerful dependency injection (DI) container that manages service registration, lifetime, and resolution. The DI system supports automatic service discovery and follows common DI patterns.</p>"},{"location":"features/dependency-injection/#overview","title":"\ud83c\udfaf Overview","text":"<p>The dependency injection system consists of:</p> <ul> <li>ServiceCollection: Registry for service definitions</li> <li>ServiceProvider: Container for resolving and managing services</li> <li>ServiceLifetime: Controls when services are created and disposed</li> <li>Automatic Discovery: Services can be automatically discovered and registered</li> </ul>"},{"location":"features/dependency-injection/#service-lifetimes","title":"\ud83c\udfd7\ufe0f Service Lifetimes","text":""},{"location":"features/dependency-injection/#singleton","title":"Singleton","text":"<p>Created once and reused for the entire application lifetime:</p> <pre><code>from neuroglia.dependency_injection.service_provider import ServiceCollection\n\nservices = ServiceCollection()\nservices.add_singleton(DatabaseConnection)\nservices.add_singleton(CacheService)\n</code></pre> <p>Use Cases:</p> <ul> <li>Database connections</li> <li>Configuration services</li> <li>Caching services</li> <li>Application-wide state</li> </ul>"},{"location":"features/dependency-injection/#scoped","title":"Scoped","text":"<p>Created once per scope (typically per HTTP request):</p> <pre><code>services.add_scoped(UserRepository)\nservices.add_scoped(OrderService)\n</code></pre> <p>Use Cases:</p> <ul> <li>Repositories</li> <li>Unit of Work</li> <li>Request-specific services</li> <li>Database contexts</li> </ul>"},{"location":"features/dependency-injection/#transient","title":"Transient","text":"<p>Created each time they are requested:</p> <pre><code>services.add_transient(EmailService)\nservices.add_transient(CalculationService)\n</code></pre> <p>Use Cases:</p> <ul> <li>Stateless services</li> <li>Lightweight operations</li> <li>Services with short lifecycles</li> </ul>"},{"location":"features/dependency-injection/#registration-patterns","title":"\ud83d\udd27 Registration Patterns","text":""},{"location":"features/dependency-injection/#interface-and-implementation","title":"Interface and Implementation","text":"<p>Register services by interface and implementation:</p> <pre><code>from abc import ABC, abstractmethod\n\nclass IUserRepository(ABC):\n    @abstractmethod\n    async def get_by_id(self, user_id: str) -&gt; User:\n        pass\n\nclass MongoUserRepository(IUserRepository):\n    async def get_by_id(self, user_id: str) -&gt; User:\n        # MongoDB implementation\n        pass\n\n# Registration\nservices.add_scoped(IUserRepository, MongoUserRepository)\n</code></pre>"},{"location":"features/dependency-injection/#factory-functions","title":"Factory Functions","text":"<p>Use factory functions for complex initialization:</p> <pre><code>def create_database_connection() -&gt; DatabaseConnection:\n    connection_string = get_connection_string()\n    return DatabaseConnection(connection_string)\n\nservices.add_singleton(DatabaseConnection, factory=create_database_connection)\n</code></pre>"},{"location":"features/dependency-injection/#generic-services","title":"Generic Services","text":"<p>Register generic services with type parameters:</p> <pre><code>from typing import TypeVar, Generic\n\nT = TypeVar('T')\n\nclass Repository(Generic[T]):\n    def __init__(self, db_context: DbContext):\n        self.db_context = db_context\n\n# Registration\nservices.add_scoped(Repository[User])\nservices.add_scoped(Repository[Order])\n</code></pre>"},{"location":"features/dependency-injection/#automatic-discovery","title":"\ud83d\udd0d Automatic Discovery","text":"<p>Neuroglia can automatically discover and register services based on conventions:</p>"},{"location":"features/dependency-injection/#module-based-discovery","title":"Module-Based Discovery","text":"<pre><code>from neuroglia.hosting.web import WebApplicationBuilder\n\nbuilder = WebApplicationBuilder()\n\n# Automatically discover and register services in modules\nbuilder.services.discover_services([\n    \"application.services\",\n    \"integration.repositories\",\n    \"domain.services\"\n])\n</code></pre>"},{"location":"features/dependency-injection/#attribute-based-registration","title":"Attribute-Based Registration","text":"<p>Use decorators to mark services for automatic registration:</p> <pre><code>from neuroglia.dependency_injection import service\n\n@service(lifetime=ServiceLifetime.SCOPED)\nclass UserService:\n    def __init__(self, user_repository: IUserRepository):\n        self.user_repository = user_repository\n\n@service(interface=IUserRepository, lifetime=ServiceLifetime.SCOPED)\nclass MongoUserRepository(IUserRepository):\n    def __init__(self, db_context: MongoContext):\n        self.db_context = db_context\n</code></pre>"},{"location":"features/dependency-injection/#service-resolution","title":"\ud83d\udd04 Service Resolution","text":""},{"location":"features/dependency-injection/#manual-resolution","title":"Manual Resolution","text":"<pre><code># Build the service provider\nprovider = services.build_service_provider()\n\n# Resolve services\nuser_service = provider.get_required_service(UserService)\nuser_repo = provider.get_service(IUserRepository)  # Returns None if not registered\nall_repos = provider.get_services(IRepository)  # Returns all implementations\n</code></pre>"},{"location":"features/dependency-injection/#constructor-injection","title":"Constructor Injection","text":"<p>Services are automatically injected into constructors:</p> <pre><code>class UserController(ControllerBase):\n    def __init__(self, \n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator,\n                 user_service: UserService):  # Automatically injected\n        super().__init__(service_provider, mapper, mediator)\n        self.user_service = user_service\n</code></pre>"},{"location":"features/dependency-injection/#property-injection","title":"Property Injection","text":"<p>Access services through the service provider:</p> <pre><code>class UserService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.service_provider = service_provider\n\n    def get_email_service(self) -&gt; EmailService:\n        return self.service_provider.get_required_service(EmailService)\n</code></pre>"},{"location":"features/dependency-injection/#advanced-patterns","title":"\ud83c\udfad Advanced Patterns","text":""},{"location":"features/dependency-injection/#service-locator-pattern","title":"Service Locator Pattern","text":"<pre><code>class ServiceLocator:\n    _provider: ServiceProviderBase = None\n\n    @classmethod\n    def configure(cls, provider: ServiceProviderBase):\n        cls._provider = provider\n\n    @classmethod\n    def get_service(cls, service_type: Type[T]) -&gt; T:\n        return cls._provider.get_required_service(service_type)\n\n# Usage\nemail_service = ServiceLocator.get_service(EmailService)\n</code></pre>"},{"location":"features/dependency-injection/#conditional-registration","title":"Conditional Registration","text":"<p>Register services based on conditions:</p> <pre><code>if app_settings.use_redis_cache:\n    services.add_singleton(ICacheService, RedisCacheService)\nelse:\n    services.add_singleton(ICacheService, MemoryCacheService)\n</code></pre>"},{"location":"features/dependency-injection/#decorated-services","title":"Decorated Services","text":"<p>Wrap services with additional behavior:</p> <pre><code>class LoggingUserService(IUserService):\n    def __init__(self, inner: IUserService, logger: Logger):\n        self.inner = inner\n        self.logger = logger\n\n    async def create_user(self, user_data: UserData) -&gt; User:\n        self.logger.info(f\"Creating user: {user_data.email}\")\n        result = await self.inner.create_user(user_data)\n        self.logger.info(f\"User created: {result.id}\")\n        return result\n\n# Registration with decoration\nservices.add_scoped(IUserService, UserService)\nservices.decorate(IUserService, LoggingUserService)\n</code></pre>"},{"location":"features/dependency-injection/#configuration-integration","title":"\ud83d\udd27 Configuration Integration","text":""},{"location":"features/dependency-injection/#configuration-objects","title":"Configuration Objects","text":"<p>Bind configuration sections to objects:</p> <pre><code>from dataclasses import dataclass\n\n@dataclass\nclass DatabaseConfig:\n    connection_string: str\n    timeout: int\n    retry_count: int\n\n# Register configuration\nservices.configure(DatabaseConfig, app_settings.database)\n\n# Use in services\nclass UserRepository:\n    def __init__(self, config: DatabaseConfig):\n        self.connection_string = config.connection_string\n</code></pre>"},{"location":"features/dependency-injection/#options-pattern","title":"Options Pattern","text":"<p>Use the options pattern for configuration:</p> <pre><code>from neuroglia.configuration import IOptions\n\nclass UserService:\n    def __init__(self, options: IOptions[UserServiceOptions]):\n        self.options = options.value\n\n    def send_welcome_email(self, user: User):\n        if self.options.send_welcome_emails:\n            # Send email logic\n            pass\n</code></pre>"},{"location":"features/dependency-injection/#testing-with-di","title":"\ud83e\uddea Testing with DI","text":""},{"location":"features/dependency-injection/#test-service-registration","title":"Test Service Registration","text":"<p>Override services for testing:</p> <pre><code>import pytest\nfrom neuroglia.dependency_injection import ServiceCollection\n\n@pytest.fixture\ndef test_services():\n    services = ServiceCollection()\n\n    # Register test implementations\n    services.add_singleton(IUserRepository, InMemoryUserRepository)\n    services.add_singleton(IEmailService, MockEmailService)\n\n    return services.build_service_provider()\n\ndef test_user_creation(test_services):\n    user_service = test_services.get_required_service(UserService)\n    result = user_service.create_user(user_data)\n    assert result.is_success\n</code></pre>"},{"location":"features/dependency-injection/#mock-dependencies","title":"Mock Dependencies","text":"<p>Use mocking frameworks with DI:</p> <pre><code>from unittest.mock import Mock\n\ndef test_user_service_with_mocks():\n    # Arrange\n    mock_repo = Mock(spec=IUserRepository)\n    mock_repo.add_async.return_value = test_user\n\n    services = ServiceCollection()\n    services.add_instance(IUserRepository, mock_repo)\n    provider = services.build_service_provider()\n\n    # Act\n    user_service = provider.get_required_service(UserService)\n    result = await user_service.create_user(user_data)\n\n    # Assert\n    mock_repo.add_async.assert_called_once()\n    assert result.email == test_user.email\n</code></pre>"},{"location":"features/dependency-injection/#framework-integration","title":"\ud83c\udfaa Framework Integration","text":""},{"location":"features/dependency-injection/#web-application-builder","title":"Web Application Builder","text":"<p>The WebApplicationBuilder provides convenient methods for service registration:</p> <pre><code>from neuroglia.hosting.web import WebApplicationBuilder\n\nbuilder = WebApplicationBuilder()\n\n# Configure framework services\nbuilder.services.add_mediation([\"application\"])\nbuilder.services.add_mapping([\"application\", \"domain\"])\nbuilder.services.add_repositories([\"integration.repositories\"])\n\n# Add custom services\nbuilder.services.add_scoped(UserService)\nbuilder.services.add_singleton(EmailService)\n\napp = builder.build()\n</code></pre>"},{"location":"features/dependency-injection/#controller-dependencies","title":"Controller Dependencies","text":"<p>Controllers automatically receive dependencies:</p> <pre><code>class UsersController(ControllerBase):\n    def __init__(self, \n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator,\n                 user_service: UserService,\n                 email_service: EmailService):\n        super().__init__(service_provider, mapper, mediator)\n        self.user_service = user_service\n        self.email_service = email_service\n</code></pre>"},{"location":"features/dependency-injection/#middleware-dependencies","title":"Middleware Dependencies","text":"<p>Middleware can also use dependency injection:</p> <pre><code>class AuthenticationMiddleware:\n    def __init__(self, auth_service: IAuthService):\n        self.auth_service = auth_service\n\n    async def __call__(self, request: Request, call_next):\n        # Use auth_service for authentication logic\n        pass\n</code></pre>"},{"location":"features/dependency-injection/#best-practices","title":"\ud83d\ude80 Best Practices","text":""},{"location":"features/dependency-injection/#1-register-by-interface","title":"1. Register by Interface","text":"<p>Always register services by their interface when possible:</p> <pre><code># Good\nservices.add_scoped(IUserRepository, MongoUserRepository)\n\n# Avoid\nservices.add_scoped(MongoUserRepository)\n</code></pre>"},{"location":"features/dependency-injection/#2-use-appropriate-lifetimes","title":"2. Use Appropriate Lifetimes","text":"<p>Choose the correct lifetime for your services:</p> <ul> <li>Singleton: Expensive to create, stateless, or application-wide</li> <li>Scoped: Request-specific, maintains state during request</li> <li>Transient: Lightweight, stateless, or disposable</li> </ul>"},{"location":"features/dependency-injection/#3-avoid-service-locator","title":"3. Avoid Service Locator","text":"<p>Prefer constructor injection over service locator:</p> <pre><code># Good - Constructor injection\nclass UserService:\n    def __init__(self, user_repository: IUserRepository):\n        self.user_repository = user_repository\n\n# Avoid - Service locator\nclass UserService:\n    def __init__(self, service_provider: ServiceProviderBase):\n        self.service_provider = service_provider\n\n    def some_method(self):\n        repo = self.service_provider.get_required_service(IUserRepository)\n</code></pre>"},{"location":"features/dependency-injection/#4-validate-dependencies","title":"4. Validate Dependencies","text":"<p>Ensure all required dependencies are registered:</p> <pre><code>def validate_services(provider: ServiceProviderBase):\n    \"\"\"Validate that all required services are registered\"\"\"\n    required_services = [IUserRepository, IEmailService, ICacheService]\n\n    for service_type in required_services:\n        service = provider.get_service(service_type)\n        if service is None:\n            raise ValueError(f\"Required service {service_type} not registered\")\n</code></pre>"},{"location":"features/dependency-injection/#5-use-factories-for-complex-objects","title":"5. Use Factories for Complex Objects","text":"<p>Use factory functions for services that need complex initialization:</p> <pre><code>def create_user_repository(provider: ServiceProviderBase) -&gt; IUserRepository:\n    config = provider.get_required_service(DatabaseConfig)\n    connection = provider.get_required_service(DatabaseConnection)\n\n    if config.use_caching:\n        cache = provider.get_required_service(ICacheService)\n        return CachedUserRepository(connection, cache)\n    else:\n        return UserRepository(connection)\n\nservices.add_scoped(IUserRepository, factory=create_user_repository)\n</code></pre>"},{"location":"features/dependency-injection/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Basic DI usage</li> <li>Architecture Guide - How DI fits in the architecture</li> <li>CQRS &amp; Mediation - DI with command handlers</li> <li>Data Access - DI with repositories</li> <li>Testing - Testing with dependency injection</li> </ul>"},{"location":"features/mvc-controllers/","title":"\ud83d\udd0c MVC Controllers","text":"<p>Neuroglia provides a powerful MVC controller system built on top of FastAPI that enables class-based API development with automatic discovery, dependency injection, and OpenAPI documentation generation.</p>"},{"location":"features/mvc-controllers/#overview","title":"\ud83c\udfaf Overview","text":"<p>The MVC system provides:</p> <ul> <li>Class-based Controllers: Organize related endpoints in classes</li> <li>Automatic Discovery: Controllers are automatically found and registered</li> <li>Dependency Injection: Full DI support in controllers</li> <li>OpenAPI Integration: Automatic documentation generation</li> <li>Routing: Flexible routing with prefixes and tags</li> <li>Response Processing: Built-in result processing and error handling</li> </ul>"},{"location":"features/mvc-controllers/#controller-basics","title":"\ud83c\udfd7\ufe0f Controller Basics","text":""},{"location":"features/mvc-controllers/#creating-a-controller","title":"Creating a Controller","text":"<p>All controllers inherit from <code>ControllerBase</code>:</p> <pre><code>from neuroglia.mvc.controller_base import ControllerBase\nfrom neuroglia.dependency_injection.service_provider import ServiceProviderBase\nfrom neuroglia.mapping.mapper import Mapper\nfrom neuroglia.mediation.mediator import Mediator\n\nclass UsersController(ControllerBase):\n    def __init__(self, \n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator):\n        super().__init__(service_provider, mapper, mediator)\n</code></pre>"},{"location":"features/mvc-controllers/#basic-endpoints","title":"Basic Endpoints","text":"<p>Use FastAPI decorators to define endpoints:</p> <pre><code>from classy_fastapi.decorators import get, post, put, delete\nfrom fastapi import status\nfrom typing import List\n\nclass UsersController(ControllerBase):\n\n    @get(\"/\", response_model=List[UserDto])\n    async def get_users(self) -&gt; List[UserDto]:\n        \"\"\"Get all users\"\"\"\n        query = GetAllUsersQuery()\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/{user_id}\", response_model=UserDto)\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        \"\"\"Get user by ID\"\"\"\n        query = GetUserByIdQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @post(\"/\", response_model=UserDto, status_code=status.HTTP_201_CREATED)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        \"\"\"Create a new user\"\"\"\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @put(\"/{user_id}\", response_model=UserDto)\n    async def update_user(self, user_id: str, update_user_dto: UpdateUserDto) -&gt; UserDto:\n        \"\"\"Update an existing user\"\"\"\n        command = self.mapper.map(update_user_dto, UpdateUserCommand)\n        command.user_id = user_id\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n    @delete(\"/{user_id}\", status_code=status.HTTP_204_NO_CONTENT)\n    async def delete_user(self, user_id: str):\n        \"\"\"Delete a user\"\"\"\n        command = DeleteUserCommand(user_id=user_id)\n        result = await self.mediator.execute_async(command)\n        self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#advanced-features","title":"\ud83d\ude80 Advanced Features","text":""},{"location":"features/mvc-controllers/#query-parameters","title":"Query Parameters","text":"<p>Handle query parameters for filtering and pagination:</p> <pre><code>from fastapi import Query\nfrom typing import Optional\n\nclass UsersController(ControllerBase):\n\n    @get(\"/\", response_model=List[UserDto])\n    async def get_users(self,\n                       department: Optional[str] = Query(None, description=\"Filter by department\"),\n                       active_only: bool = Query(True, description=\"Include only active users\"),\n                       page: int = Query(1, ge=1, description=\"Page number\"),\n                       page_size: int = Query(20, ge=1, le=100, description=\"Items per page\")) -&gt; List[UserDto]:\n        \"\"\"Get users with filtering and pagination\"\"\"\n\n        query = GetUsersQuery(\n            department=department,\n            active_only=active_only,\n            page=page,\n            page_size=page_size\n        )\n\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#request-body-validation","title":"Request Body Validation","text":"<p>Use Pydantic models for request validation:</p> <pre><code>from pydantic import BaseModel, Field, EmailStr\nfrom typing import Optional\n\nclass CreateUserDto(BaseModel):\n    email: EmailStr = Field(..., description=\"User's email address\")\n    first_name: str = Field(..., min_length=1, max_length=50, description=\"First name\")\n    last_name: str = Field(..., min_length=1, max_length=50, description=\"Last name\")\n    department: Optional[str] = Field(None, max_length=100, description=\"Department\")\n\n    class Config:\n        schema_extra = {\n            \"example\": {\n                \"email\": \"john.doe@company.com\",\n                \"first_name\": \"John\",\n                \"last_name\": \"Doe\",\n                \"department\": \"Engineering\"\n            }\n        }\n\nclass UsersController(ControllerBase):\n\n    @post(\"/\", response_model=UserDto, status_code=status.HTTP_201_CREATED)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        \"\"\"Create a new user\"\"\"\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#file-uploads","title":"File Uploads","text":"<p>Handle file uploads:</p> <pre><code>from fastapi import UploadFile, File\n\nclass UsersController(ControllerBase):\n\n    @post(\"/{user_id}/avatar\", response_model=UserDto)\n    async def upload_avatar(self, \n                           user_id: str,\n                           file: UploadFile = File(..., description=\"Avatar image\")) -&gt; UserDto:\n        \"\"\"Upload user avatar\"\"\"\n\n        # Validate file type\n        if not file.content_type.startswith('image/'):\n            return self.bad_request(\"File must be an image\")\n\n        # Create command\n        command = UploadUserAvatarCommand(\n            user_id=user_id,\n            file_name=file.filename,\n            file_content=await file.read(),\n            content_type=file.content_type\n        )\n\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#response-headers","title":"Response Headers","text":"<p>Set custom response headers:</p> <pre><code>from fastapi import Response\n\nclass UsersController(ControllerBase):\n\n    @get(\"/{user_id}/export\", response_class=Response)\n    async def export_user_data(self, user_id: str, response: Response):\n        \"\"\"Export user data as CSV\"\"\"\n\n        query = ExportUserDataQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n\n        if not result.is_success:\n            return self.process(result)\n\n        # Set CSV headers\n        response.headers[\"Content-Type\"] = \"text/csv\"\n        response.headers[\"Content-Disposition\"] = f\"attachment; filename=user_{user_id}.csv\"\n\n        return result.data\n</code></pre>"},{"location":"features/mvc-controllers/#controller-configuration","title":"\ud83c\udfaa Controller Configuration","text":""},{"location":"features/mvc-controllers/#custom-routing","title":"Custom Routing","text":"<p>Customize controller routing:</p> <pre><code>class UsersController(ControllerBase):\n    def __init__(self, service_provider, mapper, mediator):\n        super().__init__(service_provider, mapper, mediator)\n\n        # Custom prefix and tags\n        self.router.prefix = \"/users\"\n        self.router.tags = [\"User Management\"]\n\n        # Add custom middleware to this controller\n        self.router.middleware(\"http\")(self.auth_middleware)\n\n    async def auth_middleware(self, request, call_next):\n        \"\"\"Custom authentication middleware for this controller\"\"\"\n        # Authentication logic\n        response = await call_next(request)\n        return response\n</code></pre>"},{"location":"features/mvc-controllers/#nested-controllers","title":"Nested Controllers","text":"<p>Create hierarchical resource structures:</p> <pre><code>class UserAccountsController(ControllerBase):\n    \"\"\"Handles user account operations\"\"\"\n\n    def __init__(self, service_provider, mapper, mediator):\n        super().__init__(service_provider, mapper, mediator)\n        self.router.prefix = \"/users/{user_id}/accounts\"\n\n    @get(\"/\", response_model=List[AccountDto])\n    async def get_user_accounts(self, user_id: str) -&gt; List[AccountDto]:\n        \"\"\"Get all accounts for a user\"\"\"\n        query = GetUserAccountsQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @post(\"/\", response_model=AccountDto, status_code=status.HTTP_201_CREATED)\n    async def create_account(self, user_id: str, create_account_dto: CreateAccountDto) -&gt; AccountDto:\n        \"\"\"Create a new account for a user\"\"\"\n        command = self.mapper.map(create_account_dto, CreateAccountCommand)\n        command.user_id = user_id\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#error-handling","title":"\ud83d\udee1\ufe0f Error Handling","text":""},{"location":"features/mvc-controllers/#built-in-error-responses","title":"Built-in Error Responses","text":"<p>Controllers include standard error responses:</p> <pre><code>class UsersController(ControllerBase):\n\n    @get(\"/{user_id}\", \n         response_model=UserDto,\n         responses=ControllerBase.error_responses)  # Adds 400, 404, 500 responses\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        \"\"\"Get user by ID\"\"\"\n        query = GetUserByIdQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)  # Automatically handles error responses\n</code></pre>"},{"location":"features/mvc-controllers/#custom-error-handling","title":"Custom Error Handling","text":"<p>Add custom error handling:</p> <pre><code>from fastapi import HTTPException\n\nclass UsersController(ControllerBase):\n\n    @post(\"/\", response_model=UserDto, status_code=status.HTTP_201_CREATED)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        \"\"\"Create a new user\"\"\"\n        try:\n            command = self.mapper.map(create_user_dto, CreateUserCommand)\n            result = await self.mediator.execute_async(command)\n            return self.process(result)\n\n        except EmailAlreadyExistsException:\n            raise HTTPException(\n                status_code=status.HTTP_409_CONFLICT,\n                detail=\"A user with this email already exists\"\n            )\n        except ValidationException as ex:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=str(ex)\n            )\n</code></pre>"},{"location":"features/mvc-controllers/#global-error-handling","title":"Global Error Handling","text":"<p>Use middleware for global error handling:</p> <pre><code>from neuroglia.hosting.web import ExceptionHandlingMiddleware\n\n# In main.py\napp.add_middleware(ExceptionHandlingMiddleware, service_provider=app.services)\n</code></pre>"},{"location":"features/mvc-controllers/#authentication-authorization","title":"\ud83d\udd10 Authentication &amp; Authorization","text":""},{"location":"features/mvc-controllers/#dependency-injection-for-auth","title":"Dependency Injection for Auth","text":"<p>Inject authentication services:</p> <pre><code>from fastapi import Depends\nfrom neuroglia.security import IAuthService, AuthUser\n\nclass UsersController(ControllerBase):\n\n    def __init__(self, \n                 service_provider: ServiceProviderBase,\n                 mapper: Mapper,\n                 mediator: Mediator,\n                 auth_service: IAuthService):\n        super().__init__(service_provider, mapper, mediator)\n        self.auth_service = auth_service\n\n    @get(\"/profile\", response_model=UserDto)\n    async def get_current_user(self, \n                              current_user: AuthUser = Depends(auth_service.get_current_user)) -&gt; UserDto:\n        \"\"\"Get current user's profile\"\"\"\n        query = GetUserByIdQuery(user_id=current_user.user_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#role-based-authorization","title":"Role-based Authorization","text":"<p>Implement role-based access control:</p> <pre><code>from neuroglia.security import require_role\n\nclass UsersController(ControllerBase):\n\n    @get(\"/\", response_model=List[UserDto])\n    @require_role(\"admin\")  # Custom decorator\n    async def get_all_users(self) -&gt; List[UserDto]:\n        \"\"\"Get all users (admin only)\"\"\"\n        query = GetAllUsersQuery()\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @delete(\"/{user_id}\")\n    @require_role([\"admin\", \"manager\"])  # Multiple roles\n    async def delete_user(self, user_id: str):\n        \"\"\"Delete a user (admin or manager only)\"\"\"\n        command = DeleteUserCommand(user_id=user_id)\n        result = await self.mediator.execute_async(command)\n        self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#response-processing","title":"\ud83d\udcca Response Processing","text":""},{"location":"features/mvc-controllers/#the-process-method","title":"The <code>process</code> Method","text":"<p>The <code>process</code> method handles <code>OperationResult</code> objects automatically:</p> <pre><code># OperationResult with data\nresult = OperationResult.success(user_dto)\nreturn self.process(result)  # Returns user_dto with 200 status\n\n# OperationResult with error\nresult = OperationResult.not_found(\"User not found\")\nreturn self.process(result)  # Raises HTTPException with 404 status\n\n# OperationResult created\nresult = OperationResult.created(user_dto)\nreturn self.process(result)  # Returns user_dto with 201 status\n</code></pre>"},{"location":"features/mvc-controllers/#custom-response-processing","title":"Custom Response Processing","text":"<p>Override response processing for special cases:</p> <pre><code>class UsersController(ControllerBase):\n\n    @get(\"/{user_id}\", response_model=UserDto)\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        \"\"\"Get user by ID\"\"\"\n        query = GetUserByIdQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n\n        # Custom processing\n        if not result.is_success:\n            if result.status_code == 404:\n                # Log the attempt\n                self.logger.warning(f\"Attempt to access non-existent user: {user_id}\")\n            return self.process(result)\n\n        # Add custom headers for successful responses\n        response = self.process(result)\n        # Custom logic here\n        return response\n</code></pre>"},{"location":"features/mvc-controllers/#testing-controllers","title":"\ud83e\uddea Testing Controllers","text":""},{"location":"features/mvc-controllers/#unit-testing","title":"Unit Testing","text":"<p>Test controllers with mocked dependencies:</p> <pre><code>import pytest\nfrom unittest.mock import Mock, AsyncMock\n\n@pytest.mark.asyncio\nasync def test_get_user_success():\n    # Arrange\n    mock_mediator = Mock()\n    mock_mediator.execute_async = AsyncMock(return_value=OperationResult.success(test_user_dto))\n\n    controller = UsersController(\n        service_provider=mock_service_provider,\n        mapper=mock_mapper,\n        mediator=mock_mediator\n    )\n\n    # Act\n    result = await controller.get_user(\"user123\")\n\n    # Assert\n    assert result == test_user_dto\n    mock_mediator.execute_async.assert_called_once()\n</code></pre>"},{"location":"features/mvc-controllers/#integration-testing","title":"Integration Testing","text":"<p>Test controllers with TestClient:</p> <pre><code>from fastapi.testclient import TestClient\n\ndef test_create_user_integration():\n    # Arrange\n    client = TestClient(app)\n    user_data = {\n        \"email\": \"test@example.com\",\n        \"first_name\": \"John\",\n        \"last_name\": \"Doe\"\n    }\n\n    # Act\n    response = client.post(\"/api/v1/users\", json=user_data)\n\n    # Assert\n    assert response.status_code == 201\n\n    created_user = response.json()\n    assert created_user[\"email\"] == user_data[\"email\"]\n    assert \"id\" in created_user\n</code></pre>"},{"location":"features/mvc-controllers/#api-testing","title":"API Testing","text":"<p>Test the complete API flow:</p> <pre><code>def test_user_crud_flow():\n    client = TestClient(app)\n\n    # Create user\n    create_response = client.post(\"/api/v1/users\", json=test_user_data)\n    assert create_response.status_code == 201\n    user = create_response.json()\n    user_id = user[\"id\"]\n\n    # Get user\n    get_response = client.get(f\"/api/v1/users/{user_id}\")\n    assert get_response.status_code == 200\n    assert get_response.json()[\"id\"] == user_id\n\n    # Update user\n    update_data = {\"first_name\": \"Jane\"}\n    update_response = client.put(f\"/api/v1/users/{user_id}\", json=update_data)\n    assert update_response.status_code == 200\n    assert update_response.json()[\"first_name\"] == \"Jane\"\n\n    # Delete user\n    delete_response = client.delete(f\"/api/v1/users/{user_id}\")\n    assert delete_response.status_code == 204\n\n    # Verify deletion\n    get_deleted_response = client.get(f\"/api/v1/users/{user_id}\")\n    assert get_deleted_response.status_code == 404\n</code></pre>"},{"location":"features/mvc-controllers/#best-practices","title":"\ud83d\ude80 Best Practices","text":""},{"location":"features/mvc-controllers/#1-keep-controllers-thin","title":"1. Keep Controllers Thin","text":"<p>Controllers should delegate to the application layer:</p> <pre><code># Good - Thin controller\nclass UsersController(ControllerBase):\n    @post(\"/\", response_model=UserDto)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n\n# Avoid - Business logic in controller\nclass UsersController(ControllerBase):\n    @post(\"/\", response_model=UserDto)\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        # Validate email\n        if not self.is_valid_email(create_user_dto.email):\n            raise HTTPException(400, \"Invalid email\")\n\n        # Check if user exists\n        existing = await self.user_repo.get_by_email(create_user_dto.email)\n        if existing:\n            raise HTTPException(409, \"User exists\")\n\n        # Create user\n        user = User(...)\n        # ... more business logic\n</code></pre>"},{"location":"features/mvc-controllers/#2-use-dtos-for-api-contracts","title":"2. Use DTOs for API Contracts","text":"<p>Always use DTOs to define your API contracts:</p> <pre><code># API DTOs\nclass CreateUserDto(BaseModel):\n    email: str\n    first_name: str\n    last_name: str\n\nclass UserDto(BaseModel):\n    id: str\n    email: str\n    first_name: str\n    last_name: str\n    created_at: datetime\n\n# Domain entities stay separate\nclass User(Entity[str]):\n    def __init__(self, email: str, first_name: str, last_name: str):\n        # Domain logic\n        pass\n</code></pre>"},{"location":"features/mvc-controllers/#3-consistent-error-handling","title":"3. Consistent Error Handling","text":"<p>Use consistent patterns for error handling:</p> <pre><code>class UsersController(ControllerBase):\n\n    @get(\"/{user_id}\", \n         response_model=UserDto,\n         responses={\n             404: {\"description\": \"User not found\"},\n             400: {\"description\": \"Invalid user ID format\"}\n         })\n    async def get_user(self, user_id: str) -&gt; UserDto:\n        # Validate input format\n        if not self.is_valid_uuid(user_id):\n            return self.bad_request(\"Invalid user ID format\")\n\n        # Execute query\n        query = GetUserByIdQuery(user_id=user_id)\n        result = await self.mediator.execute_async(query)\n\n        # Process will handle 404 automatically\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#4-document-your-apis","title":"4. Document Your APIs","text":"<p>Provide comprehensive API documentation:</p> <pre><code>class UsersController(ControllerBase):\n\n    @post(\"/\",\n          response_model=UserDto,\n          status_code=status.HTTP_201_CREATED,\n          summary=\"Create a new user\",\n          description=\"Creates a new user account in the system\",\n          response_description=\"The created user\",\n          tags=[\"User Management\"])\n    async def create_user(self, create_user_dto: CreateUserDto) -&gt; UserDto:\n        \"\"\"\n        Create a new user account.\n\n        - **email**: User's email address (must be unique)\n        - **first_name**: User's first name\n        - **last_name**: User's last name\n\n        Returns the created user with generated ID and timestamps.\n        \"\"\"\n        command = self.mapper.map(create_user_dto, CreateUserCommand)\n        result = await self.mediator.execute_async(command)\n        return self.process(result)\n</code></pre>"},{"location":"features/mvc-controllers/#5-version-your-apis","title":"5. Version Your APIs","text":"<p>Plan for API versioning:</p> <pre><code># v1 controller\nclass V1UsersController(ControllerBase):\n    def __init__(self, service_provider, mapper, mediator):\n        super().__init__(service_provider, mapper, mediator)\n        self.router.prefix = \"/v1/users\"\n\n# v2 controller with breaking changes\nclass V2UsersController(ControllerBase):\n    def __init__(self, service_provider, mapper, mediator):\n        super().__init__(service_provider, mapper, mediator)\n        self.router.prefix = \"/v2/users\"\n</code></pre>"},{"location":"features/mvc-controllers/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Basic controller usage</li> <li>Architecture Guide - How controllers fit in the architecture</li> <li>CQRS &amp; Mediation - Using mediator in controllers</li> <li>Dependency Injection - DI in controllers</li> <li>Data Access - Working with data in controllers</li> </ul>"},{"location":"samples/api_gateway/","title":"API Gateway","text":"<p>TODO</p>"},{"location":"samples/desktop_controller/","title":"Desktop Controller","text":"<p>REST API to remotely control a Desktop (i.e. the Docker Host running the controller) over HTTP.</p> <p>The Controller must:</p> <ol> <li>Register itself periodically (via CloudEvent) to the Desktops Registry (providing its IP address as the identifier to the Registry)</li> <li>Securely expose a set of <code>Commands</code> and <code>Queries</code> via a REST API (with OpenAPI 3.x specs) that enable remote control for the Desktop's <code>HostInfo</code> and <code>UserInfo</code> (wrapping Linux Shell commands as HTTP Requests)</li> <li>Maintain various local files (e.g. <code>/data/hostinfo.json</code>, <code>/data/userinfo.json</code>) that other apps (on the Desktop VM) may rely upon (Screen Logger).</li> <li>Trigger remote execution of custom Shell scripts to be run on the Desktop VM (not the controller's container!)</li> </ol> <p>[[TOC]]</p>"},{"location":"samples/desktop_controller/#overview","title":"Overview","text":""},{"location":"samples/desktop_controller/#controllers-interactions","title":"Controller's Interactions","text":""},{"location":"samples/desktop_controller/#controllers-context","title":"Controller's Context","text":""},{"location":"samples/desktop_controller/#design","title":"Design","text":""},{"location":"samples/desktop_controller/#development","title":"Development","text":""},{"location":"samples/desktop_controller/#setup","title":"Setup","text":"<pre><code># 0. Prerequisites:\n#    Have Python 3.12 installed\n# \n#    - Create/Activate a local python environment (e.g. with pyenv)\n#      pyenv virtualenv 3.12.2 desktop-controller\n#      pyenv activate desktop-controller\n# \n#    - Start Docker Desktop locally\n#\n# 1. Clone the repository\ncd ~/\n\ngit clone git@....\n\ncd desktop-controller\n\n# pip install pre-commit\npre-commit install\n\n# pip install poetry\npoetry lock &amp;&amp; poetry install \n\n# 2. Start the docker-compose stack\n# sudo apt-get install make\nmake up\n\n# 3. Connect the vscode debugger to the running container\n# From vscode: hit F5 (ensure that the \"Run and Debug\" launcher is set to \"Python: Remote Attach\")\n\n# 4. Open the SwaggerUI at http://localhost:9781/api/docs\n\n# 5. Add a Breakpoint, e.g. in api.controllers.userinfo_controller.py:29...\n\n# 6. Send a test request :)\n\n# 7. Enjoy live debugging on your local development\n</code></pre>"},{"location":"samples/desktop_controller/#code-contribution","title":"Code Contribution","text":"<ol> <li>Clone <code>main</code> branch</li> <li>Create new branch, e.g. <code>feat-cmd-userinfo</code> or <code>fix-linux-cmd</code></li> <li>Push the new branch to Gitlab and create a Merge Request into <code>main</code></li> <li>Document the review</li> <li>Approve and merge (may discard the branch if needed)</li> </ol>"},{"location":"samples/desktop_controller/#release-process","title":"Release Process","text":"<ol> <li>Refer to Semantic Versioning</li> <li>Create new Tag in Gitlab &gt; Repository &gt; Tags &gt; New Tag</li> <li>This will trigger Gitlab CI to publish a new container image based on the latest commit in the <code>main</code> branch and will be named as per the new Tag.</li> <li>Test the image locally: <code>docker run -p 8080:80 desktop-controller:latest</code> then browse to http://localhost:8080/api/docs</li> </ol>"},{"location":"samples/desktop_controller/#settings","title":"Settings","text":"<p>Required configuration:</p> <ul> <li>create new SSH key pair</li> <li>install the private key into the container and the public key into the DockerHost/SSH server</li> <li>mount the SSH private key to <code>:/app/id_rsa</code> when starting the container</li> <li>add the pub key to the DockerHost's <code>~/.ssh/authorized_keys</code></li> <li>add env var <code>DOCKER_HOST_USER_NAME</code> with the sys-admin' username on the DockerHost!</li> </ul> <p>See App Settings.</p>"},{"location":"samples/desktop_controller/#testing","title":"Testing","text":"<p>The API has a sample <code>Command</code> that ultimately resolves to remotely run <code>~/test_shell_script_on_host.sh -i {user_input}</code> on the DockerHost. </p> <p>See sample_bin/test_shell_script_on_host.sh.</p> <p>E.g.: Install with</p> <pre><code># copy the sample shell script on the Docker Host' user' home folder\ncp sample_bin/test_shell_script_on_host.sh ~/test_shell_script_on_host.sh\n\n# set permissions to execute\nchmod a+x ~/test_shell_script_on_host.sh\n\n# set ownership\nchown $USERNAME:staff ~/test_shell_script_on_host.sh\n\n# test run as user:\n~/test_shell_script_on_host.sh -i \"my input value\"\n\nAdding a new line my input value to /tmp/test.txt...\n\n# verify local file on Docker Host: \ncat /tmp/test.txt\n\nUserInput: my input value\n</code></pre>"},{"location":"samples/desktop_controller/#test_shell_script_on_hostsh","title":"test_shell_script_on_host.sh","text":"<p>See sample_bin/test_shell_script_on_host.sh.</p> <p>This test script just adds a line to a file <code>/tmp/test.txt</code>.</p> <pre><code>#!/bin/bash\n\n# test_shell_script_on_host.sh\n\nif [ $# -lt 2 ]; then\n  echo \"Error: Please provide an argument after the -i flag.\"\n  exit 1\nfi\n\nif [ \"$1\" != \"-i\" ]; then\n  echo \"Error: Please use the -i flag followed by your argument.\"\n  exit 1\nfi\n\nargument=\"$2\"\n\necho \"Adding a new line $argument to /tmp/test.txt...\"\n\necho \"UserInput: $argument\" &gt;&gt; /tmp/test.txt\n</code></pre>"},{"location":"samples/desktop_controller/#call-test-endpoint","title":"Call Test Endpoint","text":"<p>The HTTP <code>Command</code> runs a SSH client that simply connects to the DockerHost at <code>host.docker.internal</code> (with preconfigured username and SSH keys) and runs a custom command_line.</p> <p>From SwaggerUI</p> <p><code>http://localhost:9781/api/docs#/Custom/run_test_write_file_on_host_api_v1_custom_test_shell_script_on_host_sh_post</code></p> <p>From Curl: (will need <code>Authorization</code> header with JWT, see API Auth)</p> <pre><code>curl -X 'POST' \\\n  'http://localhost:9781/api/v1/custom/test/shell_script_on_host.sh' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n  \"user_input\": \"my input value\"\n}'\n</code></pre> <pre><code># 201   Response body\n{\n  \"command_line\": \"~/test_shell_script_on_host.sh -i my_input_value\",\n  \"stdout\": [\n    \"Adding a new line my_input_value to /tmp/test.txt...\"\n  ],\n  \"stderr\": [],\n  \"aggregate_id\": \"4c660c0572d8449598ee5fde58e04423\",\n  \"success\": true\n}\n</code></pre>"},{"location":"samples/desktop_controller/#api-authentication","title":"API Authentication","text":"<p>We're using Keycloak as the IDP. See <code>deployment/keycloak/realm-config.json</code> for sample keycloak config.</p> <p>The intent is that \"whoever\" wants to remotely control a desktop first needs to get a valid token from the common Keycloak instance (which is the one that the VDI/BYOD Desktops - ie. DockerHosts have access to!).</p> <p>Local testings can be done with a local/dev Keycloak instance. Just include it in <code>docker-compose.yml</code>!</p> <pre><code>version: \"3.4\"\n\nname: mozart-dev\nservices:\n  # http://localhost:9780\n  keycloak97:\n    image: jboss/keycloak\n    environment:\n      - KEYCLOAK_USER=admin\n      - KEYCLOAK_PASSWORD=admin\n      - KEYCLOAK_IMPORT=/tmp/realm-export.json\n    volumes:\n      - ./deployment/keycloak/realm-config.json:/tmp/realm-export.json\n    ports:\n      - 9780:8080\n    networks:\n      - desktopcontrollernet\n</code></pre> <p>Login at http://localhost:9780 using <code>admin</code>:<code>admin</code></p>"},{"location":"samples/desktop_controller/#source-code","title":"Source Code","text":""},{"location":"samples/desktop_controller/#context","title":"Context","text":""},{"location":"samples/desktop_controller/#containers","title":"Containers","text":""},{"location":"samples/desktop_controller/#components","title":"Components","text":""},{"location":"samples/desktop_controller/#code","title":"Code","text":""},{"location":"samples/desktop_controller/#app-settings","title":"App Settings","text":"<pre><code>    environment:\n      APP_TITLE: Remote Desktop Controller\n      LOCAL_DEV: true\n      LOG_LEVEL: DEBUG\n\n      CLOUD_EVENT_SINK: http://event-player97/events/pub\n      CLOUD_EVENT_SOURCE: https://desktop-controller.domain.com\n      CLOUD_EVENT_TYPE_PREFIX: com.domain.desktop-controller\n\n      OAUTH2_SCHEME: client_credentials  # authorization_code or client_credentials\n      JWT_AUTHORITY: http://keycloak97/auth/realms/mozart\n      JWT_SIGNING_KEY: MIIBIj...copy_from_keycloak...elJ3dvQIDAQAB\n      JWT_AUDIENCE: desktops\n      REQUIRED_SCOPE: api\n\n      SWAGGER_UI_JWT_AUTHORITY: http://localhost:9780/auth/realms/mozart\n      SWAGGER_UI_CLIENT_ID: desktop-controller\n      SWAGGER_UI_CLIENT_SECRET: 6Wbr0V1TtgEUPUCRSqHh1T0vYuVyG0aa\n\n      USER_INFO_FILE_NAME: '/tmp/userinfo.json'\n      HOST_INFO_FILE_NAME: '/tmp/hostinfo.json'\n      DOCKER_HOST_USER_NAME: bvandewe  # UPDATE TO YOUR LOCAL USERNAME!\n      DOCKER_HOST_HOST_NAME: host.docker.internal\n</code></pre> <p>Set corresponding <code>ENV VARS</code> in <code>docker-compose.yml</code>.</p> <p>Pydantic settings automatically parses environment variables, see ./src/api/settings.py.</p> <pre><code># ./src/api/settings.py\n\nfrom neuroglia.hosting.abstractions import ApplicationSettings\nfrom pydantic import ConfigDict\n\n\nclass DesktopControllerSettings(ApplicationSettings):\n    model_config = ConfigDict(extra=\"allow\")\n\n    required_scopes: str\n    jwt_authority: str\n    jwt_signing_key: str\n    jwt_audience: str = \"desktops\"\n    docker_host_user_name: str = \"sys-admin\"\n    userinfo_filename: str = \"/app/data/userinfo.json\"\n    ...\n\napp_settings = DesktopControllerSettings(_env_file=\".env\")\n</code></pre>"},{"location":"samples/desktop_controller/#app-bootup","title":"App Bootup","text":"<p>The <code>main.py</code> file pre-loads all required services using the Dependency Injection mechanism from the neuroglia framework.</p> <p>API Controllers and Application Handlers may then declare any dependencies in their constructor (<code>def __init__(self, my_dependency: RegisteredDependency)</code>) and the framework will provide the instance!</p> <p>See Dependency Injection.</p> <pre><code># ./src/main.py\n...\nbuilder = WebApplicationBuilder()\n\n# required shared resources\nMapper.configure(builder, application_modules)\nMediator.configure(builder, application_modules)\nJsonSerializer.configure(builder)\nCloudEventIngestor.configure(builder, application_modules)\nCloudEventPublisher.configure(builder)\n\n# custom shared resources\n# \n# ADD ANY REQUIRED RESOURCE\nbuilder.services.add_scoped(paramiko.SSHClient, paramiko.SSHClient)\nbuilder.services.add_scoped(SecuredDockerHost, SecuredDockerHost)\nbuilder.services.add_singleton(DockerHostSshClientSettings, singleton=DockerHostSshClientSettings(username=builder.settings.docker_host_user_name))\nbuilder.services.add_scoped(DockerHostCommandRunner, DockerHostCommandRunner)\n\n# app\napp = builder.build()\n...\napp.run()\n</code></pre>"},{"location":"samples/desktop_controller/#dependency-injection","title":"Dependency Injection","text":"<ol> <li>Add a Custom Service source code file (likely in any of the <code>application_modules</code> folder in <code>./src/api/controllers</code> or <code>./src/application/commands</code> or <code>./src/application/queries</code> or <code>./src/application/events</code>) that requires a <code>Dependency</code>:</li> </ol> <pre><code># ./src/application/services/docker_host_command_runner.py\n...\nclass DockerHostCommandRunner:\n    def __init__(self, secured_docker_host: SecuredDockerHost):  # Declare Dependencies!\n        self.secured_docker_host = secured_docker_host\n\n    secured_docker_host: SecuredDockerHost  # Injected when handling a Command!\n\n    async def run(self, command: HostCommand) -&gt; dict[str, Any]:\n        data = {}\n        await self.secured_docker_host.connect()\n        stdout, stderr = await self.secured_docker_host.execute_command(command)\n        await self.secured_docker_host.close()\n        stdout_lines = [line.strip() for line in stdout.splitlines() if line.strip()]\n        data = {\"command_line\": command.line, \"stdout\": stdout_lines, \"stderr\": stderr.splitlines() if stderr else []}\n        return data\n...\n</code></pre> <ol> <li>Add the source code for the dependency itself (likely in <code>./src/integration/services</code>!). It may also include other dependencies! (e.g. <code>DockerHostSshClientSettings</code>!!)</li> </ol> <pre><code># ./src/integration/services/secured_docker_host.py\n...\n\nclass DockerHostSshClientSettings(BaseModel):\n    username: str\n    hostname: str = \"host.docker.internal\"\n    port: int = 22\n    private_key_filename: str = \"/app/id_rsa\"\n...\nclass SecuredDockerHost:\n    \"\"\"Service that Securely provides access to the Docker Host's Shell via SSH.\"\"\"\n\n    def __init__(self, ssh_client: paramiko.SSHClient, ssh_client_settings: DockerHostSshClientSettings):\n        self.hostname: str = ssh_client_settings.hostname\n        self.port: int = ssh_client_settings.port\n        self.username: str = ssh_client_settings.username\n        self.private_key_filename: str = ssh_client_settings.private_key_filename\n        self.ssh_client: paramiko.SSHClient = ssh_client\n        self.ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n\n    async def connect(self):\n        ...\n\n    async def execute_command(self, command: HostCommand):\n        async def run_command(command_line: str):\n            ...\n\n        stdout, stderr = await run_command(command.line)\n        return stdout.decode(), stderr.decode()\n\n    async def close(self):\n        ...\n</code></pre> <ol> <li>Register its service_type (<code>singleton</code>, <code>scoped</code>, <code>transient</code>) in the <code>main.py</code> bootup script</li> </ol> <pre><code># ./src/main.py\n...\nbuilder.services.add_scoped(paramiko.SSHClient, paramiko.SSHClient)\nbuilder.services.add_scoped(SecuredDockerHost, SecuredDockerHost)\nbuilder.services.add_singleton(DockerHostSshClientSettings, singleton=DockerHostSshClientSettings(username=builder.settings.docker_host_user_name))\nbuilder.services.add_scoped(DockerHostCommandRunner, DockerHostCommandRunner)\n...\n</code></pre> <ol> <li>Declare it as a dependency in a consumer Service, e.g. Application's <code>CommandHandler</code>: </li> </ol> <p>Note how the <code>DockerHostCommandRunner</code> is just declared as a dependency in the constructor function <code>__init__</code>! This is the same for the other dependencies (<code>CloudEventBus</code>, <code>CloudEventPublishingOptions</code>)</p> <pre><code>@map_from(TestHostScriptCommandDto)\n@map_to(TestHostScriptCommandDto)\n@dataclass\nclass TestHostScriptCommand(Command):\n    user_input: str\n\n\nclass TestHostScriptCommandsHandler(CommandHandler[TestHostScriptCommand, OperationResult[Any]]):\n    \"\"\"Represents the service used to handle UserInfo-related Commands\"\"\"\n\n    cloud_event_bus: CloudEventBus\n    \"\"\" Gets the service used to observe the cloud events consumed and produced by the application \"\"\"\n\n    cloud_event_publishing_options: CloudEventPublishingOptions\n    \"\"\" Gets the options used to configure how the application should publish cloud events \"\"\"\n\n    docker_host_command_runner: DockerHostCommandRunner\n\n    def __init__(self, cloud_event_bus: CloudEventBus, cloud_event_publishing_options: CloudEventPublishingOptions, docker_host_command_runner: DockerHostCommandRunner):\n        self.cloud_event_bus = cloud_event_bus\n        self.cloud_event_publishing_options = cloud_event_publishing_options\n        self.docker_host_command_runner = docker_host_command_runner\n\n    async def handle_async(self, command: TestHostScriptCommand) -&gt; OperationResult[Any]:\n        command_id = str(uuid.uuid4()).replace(\"-\", \"\")\n        command_line = HostCommand()\n        data = {}\n        try:\n            line = f\"~/test_shell_script_on_host.sh -i {command.user_input.replace(' ', '_')}\"\n            log.debug(f\"TestHostScriptCommand Line: {line}\")\n            await self.publish_cloud_event_async(DesktopHostCommandReceivedIntegrationEventV1(aggregate_id=command_id, command_line=line))\n\n            command_line.line = line\n            data = await self.docker_host_command_runner.run(command_line)\n            data.update({\"aggregate_id\": command_id})\n            log.debug(f\"TestHostScriptCommand: {data}\")\n\n            await self.publish_cloud_event_async(DesktopHostCommandExecutedIntegrationEventV1(**data))\n            data.update({\"success\": True}) if len(data[\"stderr\"]) == 0 else data.update({\"success\": False})\n            return self.created(data)\n\n        except Exception as ex:\n            return self.bad_request(f\"Exception when trying to run a shell script on the host: {command_line.line}: {data}: {ex}\")\n</code></pre>"},{"location":"samples/desktop_controller/#api-controllers","title":"API Controllers","text":"<ul> <li>inherits ControllerBase</li> </ul> <pre><code># ./src/api/controllers/host_controller.py\n\nclass HostController(ControllerBase):\n    def __init__(self, service_provider: ServiceProviderBase, mapper: Mapper, mediator: Mediator):\n        ControllerBase.__init__(self, service_provider, mapper, mediator)\n\n    @post(\"/info\", response_model=Any, status_code=201, responses=ControllerBase.error_responses)\n    async def set_host_info(self, command_dto: SetHostInfoCommandDto, token: str = Depends(validate_token)) -&gt; Any:\n        \"\"\"Sets data of the hostinfo.json file.\"\"\"\n        log.debug(f\"set_host_info: command_dto:{command_dto}, token={token}\")\n        return self.process(await self.mediator.execute_async(self.mapper.map(command_dto, SetHostInfoCommand)))\n\n    @get(\"/info\", response_model=Any, status_code=201, responses=ControllerBase.error_responses)\n    async def get_host_info(self):\n        query = ReadHostInfoQuery()\n        log.debug(f\"get_host_info: query:{query}\")\n        return self.process(await self.mediator.execute_async(query))\n</code></pre>"},{"location":"samples/open_bank/","title":"OpenBank","text":"<p>See samples/openbank...</p>"},{"location":"samples/openbank/","title":"\ud83c\udfe6 OpenBank Sample Application","text":"<p>OpenBank is a comprehensive sample application that demonstrates advanced Neuroglia features including event sourcing, CQRS, domain-driven design, and event-driven architecture. It simulates a simple banking system with persons and accounts.</p>"},{"location":"samples/openbank/#overview","title":"\ud83c\udfaf Overview","text":"<p>The OpenBank sample showcases:</p> <ul> <li>Event Sourcing: Complete event-sourced domain with event store</li> <li>CQRS: Separate command and query models</li> <li>Domain-Driven Design: Rich domain models with business rules</li> <li>Event-Driven Architecture: Domain events and integration events</li> <li>Clean Architecture: Clear separation of layers</li> <li>Repository Pattern: Both write (event sourcing) and read (MongoDB) repositories</li> </ul>"},{"location":"samples/openbank/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    API Layer                                     \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502  PersonsController \u2502  \u2502 AccountsController \u2502  \u2502  Other APIs    \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Application Layer                             \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502    Commands     \u2502  \u2502     Queries     \u2502  \u2502     Events     \u2502   \u2502\n\u2502  \u2502   Handlers      \u2502  \u2502    Handlers     \u2502  \u2502   Handlers     \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Domain Layer                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502     Person      \u2502  \u2502     Account     \u2502  \u2502    Address     \u2502   \u2502\n\u2502  \u2502   Aggregate     \u2502  \u2502   Aggregate     \u2502  \u2502 Value Object   \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Integration Layer                               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502 Event Store     \u2502  \u2502   MongoDB       \u2502  \u2502  API Clients   \u2502   \u2502\n\u2502  \u2502 Repository      \u2502  \u2502  Repository     \u2502  \u2502                \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"samples/openbank/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"samples/openbank/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+</li> <li>Docker and Docker Compose</li> <li>MongoDB (via Docker)</li> <li>EventStoreDB (via Docker)</li> </ul>"},{"location":"samples/openbank/#setup","title":"Setup","text":"<ol> <li>Start Dependencies:</li> </ol> <pre><code>cd samples/openbank\ndocker-compose up -d mongodb eventstoredb\n</code></pre> <ol> <li>Install Dependencies:</li> </ol> <pre><code>pip install -r requirements.txt\n</code></pre> <ol> <li>Run the Application:</li> </ol> <pre><code>python api/main.py\n</code></pre> <ol> <li> <p>Access the API:</p> </li> <li> <p>API Documentation: http://localhost:8000/api/docs</p> </li> <li>EventStoreDB UI: http://localhost:2113 (admin/changeit)</li> </ol>"},{"location":"samples/openbank/#project-structure","title":"\ud83d\udcc1 Project Structure","text":"<pre><code>samples/openbank/\n\u251c\u2500\u2500 api/\n\u2502   \u251c\u2500\u2500 main.py                     # Application entry point\n\u2502   \u2514\u2500\u2500 controllers/\n\u2502       \u251c\u2500\u2500 persons_controller.py   # Person management API\n\u2502       \u2514\u2500\u2500 accounts_controller.py  # Account management API\n\u251c\u2500\u2500 application/\n\u2502   \u251c\u2500\u2500 commands/\n\u2502   \u2502   \u251c\u2500\u2500 persons/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 register_person_command.py\n\u2502   \u2502   \u2514\u2500\u2500 accounts/\n\u2502   \u2502       \u251c\u2500\u2500 open_account_command.py\n\u2502   \u2502       \u2514\u2500\u2500 deposit_command.py\n\u2502   \u251c\u2500\u2500 queries/\n\u2502   \u2502   \u251c\u2500\u2500 person_by_id.py\n\u2502   \u2502   \u2514\u2500\u2500 account_by_owner.py\n\u2502   \u2514\u2500\u2500 events/\n\u2502       \u251c\u2500\u2500 integration/\n\u2502       \u2502   \u2514\u2500\u2500 person_registered_handler.py\n\u2502       \u2514\u2500\u2500 domain/\n\u251c\u2500\u2500 domain/\n\u2502   \u2514\u2500\u2500 models/\n\u2502       \u251c\u2500\u2500 person.py               # Person aggregate\n\u2502       \u251c\u2500\u2500 account.py              # Account aggregate\n\u2502       \u2514\u2500\u2500 address.py              # Address value object\n\u2514\u2500\u2500 integration/\n    \u251c\u2500\u2500 models/                     # DTOs and read models\n    \u2502   \u251c\u2500\u2500 person.py\n    \u2502   \u2514\u2500\u2500 account.py\n    \u2514\u2500\u2500 commands/                   # API command DTOs\n        \u2514\u2500\u2500 persons/\n            \u2514\u2500\u2500 register_person_command_dto.py\n</code></pre>"},{"location":"samples/openbank/#domain-models","title":"\ud83c\udfdb\ufe0f Domain Models","text":""},{"location":"samples/openbank/#person-aggregate","title":"Person Aggregate","text":"<p>The Person aggregate manages person registration and personal information:</p> <pre><code>from dataclasses import dataclass\nfrom datetime import date\nfrom neuroglia.data.abstractions import AggregateRoot\nfrom samples.openbank.integration import PersonGender\n\n@dataclass\nclass PersonState:\n    \"\"\"Person aggregate state\"\"\"\n    id: str = None\n    first_name: str = None\n    last_name: str = None\n    nationality: str = None\n    gender: PersonGender = None\n    date_of_birth: date = None\n    address: Address = None\n\nclass Person(AggregateRoot[str]):\n    \"\"\"Person aggregate root\"\"\"\n\n    def __init__(self, id: str = None):\n        super().__init__(id)\n        self.state = PersonState()\n\n    def register(self, first_name: str, last_name: str, nationality: str, \n                gender: PersonGender, date_of_birth: date, address: Address):\n        \"\"\"Register a new person\"\"\"\n\n        # Validate business rules\n        if not first_name or not last_name:\n            raise ValueError(\"First name and last name are required\")\n\n        if date_of_birth &gt;= date.today():\n            raise ValueError(\"Date of birth must be in the past\")\n\n        # Raise domain event\n        self.apply(PersonRegisteredEvent(\n            person_id=self.id,\n            first_name=first_name,\n            last_name=last_name,\n            nationality=nationality,\n            gender=gender,\n            date_of_birth=date_of_birth,\n            address=address\n        ))\n\n    def update_address(self, new_address: Address):\n        \"\"\"Update person's address\"\"\"\n        self.apply(PersonAddressUpdatedEvent(\n            person_id=self.id,\n            old_address=self.state.address,\n            new_address=new_address\n        ))\n\n    # Event handlers\n    def on_person_registered(self, event: PersonRegisteredEvent):\n        \"\"\"Handle person registered event\"\"\"\n        self.state.id = event.person_id\n        self.state.first_name = event.first_name\n        self.state.last_name = event.last_name\n        self.state.nationality = event.nationality\n        self.state.gender = event.gender\n        self.state.date_of_birth = event.date_of_birth\n        self.state.address = event.address\n\n    def on_person_address_updated(self, event: PersonAddressUpdatedEvent):\n        \"\"\"Handle address updated event\"\"\"\n        self.state.address = event.new_address\n</code></pre>"},{"location":"samples/openbank/#account-aggregate","title":"Account Aggregate","text":"<p>The Account aggregate manages banking accounts and transactions:</p> <pre><code>from decimal import Decimal\nfrom neuroglia.data.abstractions import AggregateRoot\n\n@dataclass\nclass AccountState:\n    \"\"\"Account aggregate state\"\"\"\n    id: str = None\n    owner_id: str = None\n    account_number: str = None\n    balance: Decimal = Decimal('0.00')\n    currency: str = 'USD'\n    is_active: bool = True\n\nclass Account(AggregateRoot[str]):\n    \"\"\"Account aggregate root\"\"\"\n\n    def __init__(self, id: str = None):\n        super().__init__(id)\n        self.state = AccountState()\n\n    def open(self, owner_id: str, account_number: str, initial_deposit: Decimal = None):\n        \"\"\"Open a new account\"\"\"\n\n        # Validate business rules\n        if not owner_id:\n            raise ValueError(\"Owner ID is required\")\n\n        if not account_number:\n            raise ValueError(\"Account number is required\")\n\n        if initial_deposit and initial_deposit &lt; Decimal('0'):\n            raise ValueError(\"Initial deposit cannot be negative\")\n\n        # Raise domain event\n        self.apply(AccountOpenedEvent(\n            account_id=self.id,\n            owner_id=owner_id,\n            account_number=account_number,\n            initial_deposit=initial_deposit or Decimal('0.00')\n        ))\n\n    def deposit(self, amount: Decimal, description: str = None):\n        \"\"\"Deposit money to the account\"\"\"\n\n        # Validate business rules\n        if amount &lt;= Decimal('0'):\n            raise ValueError(\"Deposit amount must be positive\")\n\n        if not self.state.is_active:\n            raise ValueError(\"Cannot deposit to inactive account\")\n\n        # Raise domain event\n        self.apply(MoneyDepositedEvent(\n            account_id=self.id,\n            amount=amount,\n            description=description,\n            balance_after=self.state.balance + amount\n        ))\n\n    def withdraw(self, amount: Decimal, description: str = None):\n        \"\"\"Withdraw money from the account\"\"\"\n\n        # Validate business rules\n        if amount &lt;= Decimal('0'):\n            raise ValueError(\"Withdrawal amount must be positive\")\n\n        if not self.state.is_active:\n            raise ValueError(\"Cannot withdraw from inactive account\")\n\n        if self.state.balance &lt; amount:\n            raise ValueError(\"Insufficient funds\")\n\n        # Raise domain event\n        self.apply(MoneyWithdrawnEvent(\n            account_id=self.id,\n            amount=amount,\n            description=description,\n            balance_after=self.state.balance - amount\n        ))\n\n    # Event handlers\n    def on_account_opened(self, event: AccountOpenedEvent):\n        \"\"\"Handle account opened event\"\"\"\n        self.state.id = event.account_id\n        self.state.owner_id = event.owner_id\n        self.state.account_number = event.account_number\n        self.state.balance = event.initial_deposit\n\n    def on_money_deposited(self, event: MoneyDepositedEvent):\n        \"\"\"Handle money deposited event\"\"\"\n        self.state.balance = event.balance_after\n\n    def on_money_withdrawn(self, event: MoneyWithdrawnEvent):\n        \"\"\"Handle money withdrawn event\"\"\"\n        self.state.balance = event.balance_after\n</code></pre>"},{"location":"samples/openbank/#application-layer","title":"\ud83d\udcbc Application Layer","text":""},{"location":"samples/openbank/#command-handlers","title":"Command Handlers","text":"<p>Command handlers execute business operations:</p> <pre><code>from neuroglia.mediation.mediator import CommandHandler\nfrom neuroglia.data.infrastructure.abstractions import Repository\n\nclass RegisterPersonCommandHandler(CommandHandler[RegisterPersonCommand, OperationResult[PersonDto]]):\n    \"\"\"Handles person registration commands\"\"\"\n\n    def __init__(self, \n                 mapper: Mapper,\n                 person_repository: Repository[Person, str]):\n        self.mapper = mapper\n        self.person_repository = person_repository\n\n    async def handle_async(self, command: RegisterPersonCommand) -&gt; OperationResult[PersonDto]:\n        try:\n            # Create new person aggregate\n            person = Person(str(uuid.uuid4()))\n\n            # Execute business operation\n            person.register(\n                first_name=command.first_name,\n                last_name=command.last_name,\n                nationality=command.nationality,\n                gender=command.gender,\n                date_of_birth=command.date_of_birth,\n                address=command.address\n            )\n\n            # Save to event store\n            saved_person = await self.person_repository.add_async(person)\n\n            # Map to DTO and return\n            person_dto = self.mapper.map(saved_person.state, PersonDto)\n            return self.created(person_dto)\n\n        except ValueError as ex:\n            return self.bad_request(str(ex))\n        except Exception as ex:\n            return self.internal_error(f\"Failed to register person: {ex}\")\n\nclass DepositCommandHandler(CommandHandler[DepositCommand, OperationResult[AccountDto]]):\n    \"\"\"Handles money deposit commands\"\"\"\n\n    def __init__(self, \n                 mapper: Mapper,\n                 account_repository: Repository[Account, str]):\n        self.mapper = mapper\n        self.account_repository = account_repository\n\n    async def handle_async(self, command: DepositCommand) -&gt; OperationResult[AccountDto]:\n        try:\n            # Load account from event store\n            account = await self.account_repository.get_by_id_async(command.account_id)\n            if account is None:\n                return self.not_found(\"Account not found\")\n\n            # Execute business operation\n            account.deposit(command.amount, command.description)\n\n            # Save changes\n            await self.account_repository.update_async(account)\n\n            # Map to DTO and return\n            account_dto = self.mapper.map(account.state, AccountDto)\n            return self.ok(account_dto)\n\n        except ValueError as ex:\n            return self.bad_request(str(ex))\n        except Exception as ex:\n            return self.internal_error(f\"Failed to deposit money: {ex}\")\n</code></pre>"},{"location":"samples/openbank/#query-handlers","title":"Query Handlers","text":"<p>Query handlers retrieve data for read operations:</p> <pre><code>class GetPersonByIdQueryHandler(QueryHandler[GetPersonByIdQuery, OperationResult[PersonDto]]):\n    \"\"\"Handles person lookup queries\"\"\"\n\n    def __init__(self, \n                 mapper: Mapper,\n                 person_repository: Repository[PersonDto, str]):  # Read model repository\n        self.mapper = mapper\n        self.person_repository = person_repository\n\n    async def handle_async(self, query: GetPersonByIdQuery) -&gt; OperationResult[PersonDto]:\n        person = await self.person_repository.get_by_id_async(query.person_id)\n\n        if person is None:\n            return self.not_found(f\"Person with ID {query.person_id} not found\")\n\n        return self.ok(person)\n\nclass GetAccountsByOwnerQueryHandler(QueryHandler[GetAccountsByOwnerQuery, OperationResult[List[AccountDto]]]):\n    \"\"\"Handles account lookup by owner queries\"\"\"\n\n    def __init__(self, account_repository: Repository[AccountDto, str]):\n        self.account_repository = account_repository\n\n    async def handle_async(self, query: GetAccountsByOwnerQuery) -&gt; OperationResult[List[AccountDto]]:\n        accounts = await self.account_repository.find_by_criteria_async(\n            {\"owner_id\": query.owner_id}\n        )\n        return self.ok(accounts)\n</code></pre>"},{"location":"samples/openbank/#event-handling","title":"\ud83d\udce1 Event Handling","text":""},{"location":"samples/openbank/#domain-events","title":"Domain Events","text":"<p>Domain events represent business events within aggregates:</p> <pre><code>@dataclass\nclass PersonRegisteredEvent(DomainEvent):\n    \"\"\"Event raised when a person is registered\"\"\"\n    person_id: str\n    first_name: str\n    last_name: str\n    nationality: str\n    gender: PersonGender\n    date_of_birth: date\n    address: Address\n\n@dataclass\nclass AccountOpenedEvent(DomainEvent):\n    \"\"\"Event raised when an account is opened\"\"\"\n    account_id: str\n    owner_id: str\n    account_number: str\n    initial_deposit: Decimal\n\n@dataclass\nclass MoneyDepositedEvent(DomainEvent):\n    \"\"\"Event raised when money is deposited\"\"\"\n    account_id: str\n    amount: Decimal\n    description: str\n    balance_after: Decimal\n</code></pre>"},{"location":"samples/openbank/#integration-events","title":"Integration Events","text":"<p>Integration events handle cross-bounded-context communication:</p> <pre><code>class PersonRegisteredIntegrationEventHandler(EventHandler[PersonRegisteredEvent]):\n    \"\"\"Handles person registered events for integration purposes\"\"\"\n\n    def __init__(self, \n                 cloud_event_publisher: CloudEventPublisher,\n                 mapper: Mapper):\n        self.cloud_event_publisher = cloud_event_publisher\n        self.mapper = mapper\n\n    async def handle_async(self, event: PersonRegisteredEvent):\n        # Create integration event\n        integration_event = PersonRegisteredIntegrationEvent(\n            person_id=event.person_id,\n            email=event.email,\n            full_name=f\"{event.first_name} {event.last_name}\",\n            timestamp=datetime.utcnow()\n        )\n\n        # Publish as CloudEvent\n        await self.cloud_event_publisher.publish_async(\n            event_type=\"person.registered.v1\",\n            data=integration_event,\n            source=\"openbank.persons\"\n        )\n</code></pre>"},{"location":"samples/openbank/#data-access","title":"\ud83d\uddc4\ufe0f Data Access","text":""},{"location":"samples/openbank/#event-sourcing-repository","title":"Event Sourcing Repository","text":"<p>The write model uses event sourcing:</p> <pre><code># Configuration in main.py\nfrom neuroglia.data.infrastructure.event_sourcing import EventSourcingRepository\nfrom neuroglia.data.infrastructure.event_sourcing.event_store import ESEventStore\n\n# Configure Event Store\nESEventStore.configure(builder, EventStoreOptions(database_name, consumer_group))\n\n# Configure event sourcing repositories\nDataAccessLayer.WriteModel.configure(\n    builder, \n    [\"samples.openbank.domain.models\"], \n    lambda builder_, entity_type, key_type: EventSourcingRepository.configure(\n        builder_, entity_type, key_type\n    )\n)\n</code></pre>"},{"location":"samples/openbank/#read-model-repository","title":"Read Model Repository","text":"<p>The read model uses MongoDB:</p> <pre><code># Configuration in main.py\nfrom neuroglia.data.infrastructure.mongo import MongoRepository\n\n# Configure MongoDB repositories\nDataAccessLayer.ReadModel.configure(\n    builder,\n    [\"samples.openbank.integration.models\", \"samples.openbank.application.events\"],\n    lambda builder_, entity_type, key_type: MongoRepository.configure(\n        builder_, entity_type, key_type, database_name\n    )\n)\n</code></pre>"},{"location":"samples/openbank/#api-layer","title":"\ud83c\udf10 API Layer","text":""},{"location":"samples/openbank/#controllers","title":"Controllers","text":"<p>Controllers expose the domain through REST APIs:</p> <pre><code>class PersonsController(ControllerBase):\n    \"\"\"Persons management API\"\"\"\n\n    @post(\"/\", response_model=PersonDto, status_code=201)\n    async def register_person(self, command: RegisterPersonCommandDto) -&gt; PersonDto:\n        \"\"\"Register a new person\"\"\"\n        # Map DTO to domain command\n        domain_command = self.mapper.map(command, RegisterPersonCommand)\n\n        # Execute through mediator\n        result = await self.mediator.execute_async(domain_command)\n\n        # Process and return result\n        return self.process(result)\n\n    @get(\"/\", response_model=List[PersonDto])\n    async def list_persons(self) -&gt; List[PersonDto]:\n        \"\"\"List all registered persons\"\"\"\n        query = ListPersonsQuery()\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\n    @get(\"/{person_id}\", response_model=PersonDto)\n    async def get_person_by_id(self, person_id: str) -&gt; PersonDto:\n        \"\"\"Get person by ID\"\"\"\n        query = GetPersonByIdQuery(person_id=person_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n\nclass AccountsController(ControllerBase):\n    \"\"\"Accounts management API\"\"\"\n\n    @post(\"/\", response_model=AccountDto, status_code=201)\n    async def open_account(self, command: OpenAccountCommandDto) -&gt; AccountDto:\n        \"\"\"Open a new account\"\"\"\n        domain_command = self.mapper.map(command, OpenAccountCommand)\n        result = await self.mediator.execute_async(domain_command)\n        return self.process(result)\n\n    @post(\"/{account_id}/deposit\", response_model=AccountDto)\n    async def deposit(self, account_id: str, command: DepositCommandDto) -&gt; AccountDto:\n        \"\"\"Deposit money to account\"\"\"\n        domain_command = self.mapper.map(command, DepositCommand)\n        domain_command.account_id = account_id\n        result = await self.mediator.execute_async(domain_command)\n        return self.process(result)\n\n    @get(\"/by-owner/{owner_id}\", response_model=List[AccountDto])\n    async def get_accounts_by_owner(self, owner_id: str) -&gt; List[AccountDto]:\n        \"\"\"Get all accounts for a person\"\"\"\n        query = GetAccountsByOwnerQuery(owner_id=owner_id)\n        result = await self.mediator.execute_async(query)\n        return self.process(result)\n</code></pre>"},{"location":"samples/openbank/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"samples/openbank/#unit-tests","title":"Unit Tests","text":"<p>Test domain logic in isolation:</p> <pre><code>def test_person_registration():\n    # Arrange\n    person = Person(\"test-id\")\n    address = Address(\"123 Main St\", \"Anytown\", \"12345\", \"USA\")\n\n    # Act\n    person.register(\n        first_name=\"John\",\n        last_name=\"Doe\",\n        nationality=\"US\",\n        gender=PersonGender.MALE,\n        date_of_birth=date(1990, 1, 1),\n        address=address\n    )\n\n    # Assert\n    assert person.state.first_name == \"John\"\n    assert person.state.last_name == \"Doe\"\n    assert len(person.uncommitted_events) == 1\n    assert isinstance(person.uncommitted_events[0], PersonRegisteredEvent)\n\ndef test_account_deposit():\n    # Arrange\n    account = Account(\"test-account\")\n    account.open(\"owner-id\", \"123456789\", Decimal('100.00'))\n\n    # Act\n    account.deposit(Decimal('50.00'), \"Test deposit\")\n\n    # Assert\n    assert account.state.balance == Decimal('150.00')\n    assert len(account.uncommitted_events) == 2  # Open + Deposit\n</code></pre>"},{"location":"samples/openbank/#integration-tests","title":"Integration Tests","text":"<p>Test the complete flow:</p> <pre><code>@pytest.mark.asyncio\nasync def test_person_registration_flow():\n    # Arrange\n    client = TestClient(app)\n    person_data = {\n        \"first_name\": \"John\",\n        \"last_name\": \"Doe\",\n        \"nationality\": \"US\",\n        \"gender\": \"MALE\",\n        \"date_of_birth\": \"1990-01-01\",\n        \"address\": {\n            \"street\": \"123 Main St\",\n            \"city\": \"Anytown\",\n            \"postal_code\": \"12345\",\n            \"country\": \"USA\"\n        }\n    }\n\n    # Act\n    response = client.post(\"/api/v1/persons\", json=person_data)\n\n    # Assert\n    assert response.status_code == 201\n    person = response.json()\n    assert person[\"first_name\"] == \"John\"\n    assert person[\"last_name\"] == \"Doe\"\n\n    # Verify person can be retrieved\n    get_response = client.get(f\"/api/v1/persons/{person['id']}\")\n    assert get_response.status_code == 200\n</code></pre>"},{"location":"samples/openbank/#running-the-sample","title":"\ud83d\ude80 Running the Sample","text":""},{"location":"samples/openbank/#start-the-application","title":"Start the Application","text":"<ol> <li>Start infrastructure:</li> </ol> <pre><code>docker-compose up -d\n</code></pre> <ol> <li>Run the application:</li> </ol> <pre><code>python api/main.py\n</code></pre>"},{"location":"samples/openbank/#example-api-calls","title":"Example API Calls","text":"<p>Register a Person:</p> <pre><code>curl -X POST \"http://localhost:8000/api/v1/persons\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"first_name\": \"John\",\n    \"last_name\": \"Doe\",\n    \"nationality\": \"US\",\n    \"gender\": \"MALE\",\n    \"date_of_birth\": \"1990-01-01\",\n    \"address\": {\n      \"street\": \"123 Main St\",\n      \"city\": \"Anytown\",\n      \"postal_code\": \"12345\",\n      \"country\": \"USA\"\n    }\n  }'\n</code></pre> <p>Open an Account:</p> <pre><code>curl -X POST \"http://localhost:8000/api/v1/accounts\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"owner_id\": \"PERSON_ID_FROM_ABOVE\",\n    \"account_number\": \"123456789\",\n    \"initial_deposit\": 1000.00\n  }'\n</code></pre> <p>Deposit Money:</p> <pre><code>curl -X POST \"http://localhost:8000/api/v1/accounts/ACCOUNT_ID/deposit\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"amount\": 500.00,\n    \"description\": \"Salary deposit\"\n  }'\n</code></pre>"},{"location":"samples/openbank/#key-learnings","title":"\ud83d\udccb Key Learnings","text":"<p>The OpenBank sample demonstrates:</p> <ol> <li>Event Sourcing: How to store state as a sequence of events</li> <li>CQRS: Separation of write and read models</li> <li>Domain-Driven Design: Rich domain models with business rules</li> <li>Clean Architecture: Clear separation of concerns</li> <li>Event-Driven Architecture: How events enable loose coupling</li> <li>Repository Pattern: Abstract data access for different storage types</li> <li>Integration Events: Cross-bounded-context communication</li> </ol>"},{"location":"samples/openbank/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>Getting Started - Basic Neuroglia concepts</li> <li>Architecture Guide - Understanding the architecture</li> <li>Event Sourcing - Event sourcing patterns</li> <li>CQRS &amp; Mediation - Command and query patterns</li> <li>Event Handling - Event-driven architecture</li> </ul>"}]}